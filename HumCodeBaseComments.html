	<head>		<style>			body {font-family: MONOSPACE;}				method {   }		comment { color: DarkGreen; }		todo { color: Red; }		r { color: Red; }		return { color: Blue; }		</style>	</head><body><h1>Hum Code Base</h1><hr/><hr/><h2>Hum-FileIn</h2><hr/><h3>Hum-FileIn -- HumFileInSubclass</h3><pre><b>subclassMethod: anArgument3</b></pre><hr/><h3>Hum-FileIn -- HumFileIn</h3><pre><b>anotherMethod: anArgument2</b><comment>   "This is a second method to check for iteration anomolies."</comment><comment>   "Another minor edit."</comment></pre><pre><b>someMethod: anArgument</b><comment>   "This method provides means to test file in from generated code."</comment><comment>   "Minor Edit"</comment><return>   ^someInstanceVariable.</return></pre><hr/><h3>Hum-FileIn -- HumFileOut</h3><pre><b>myInstanceVariable</b><return>   ^ myInstanceVariable.</return></pre><hr/><hr/><h2>Hum-Graph</h2><hr/><h3>Hum-Graph -- HumGraphTests</h3><pre><b>test110GraphHasNodes</b><comment>   "A graph has a collection (set) of nodes"</comment></pre><pre><b>test120GraphHasConnections</b><comment>   "A graph has a collection (set) of connections."</comment></pre><pre><b>test130PutGetNode</b><comment>   "A graph has a collection (set) of nodes"</comment></pre><pre><b>test140PutGetConnector</b><comment>   "A graph has a collection (set) of connections."</comment></pre><pre><b>test150PutGetLabeledConnections</b><comment>   "A graph has a collection (set) of connections"</comment><r>***22 lines of code ***</r></pre><pre><b>test152PutGetParallelConnections</b><comment>   "A graph has a collection (set) of nodes"</comment><r>***40 lines of code ***</r></pre><pre><b>test160DetectCycle</b><comment>   "A graph has a collection (set) of nodes"</comment></pre><hr/><h3>Hum-Graph -- HumGraph</h3><pre><b>addConnection: anAssociation </b></pre><pre><b>addConnection: anAssociation label: aString</b><comment>   "Note: A pair of nodes may have more than one relation."</comment><comment>   "Make sure the nodes are in the node set."</comment><comment>   "In this set, there can be more than one per association."</comment></pre><pre><b>addNode: anObject </b><comment>   "Add the given object to the set of nodes"</comment><comment>   " Note that each object / node is unique"</comment></pre><pre><b>addNode: anObject label: aString</b><comment>   "Add the given object to the set of nodes"</comment><comment>   " Note that each object / node is unique"</comment></pre><pre><b>connectionLabels</b><comment>   "Note: A pair of nodes may have more than one relation."</comment><comment>   "See: #addConnection:label:"</comment><return>   ^ connectionLabels ifNil: [ connectionLabels := Set new ].</return></pre><pre><b>connections</b><comment>   "Return the connections (associations) in this graph."</comment><comment>         "entry looks like {  association. label.  }"</comment><return>   ^bagConnections.</return></pre><pre><b>connectionsFrom: aNode </b><comment>   "Get the outbound connections from this node. "</comment><return>   ^outboundConnections.</return></pre><pre><b>countNeighborsOfNode: aNode</b><comment>   "Return the number of neighbors of this node.</comment><return>   ^ count</return></pre><pre><b>hasCycle</b><comment>   "Does the graph contain at least one cycle?"</comment><comment>         "downStreamFrom: will not extend leafs that match root"</comment><return>   ^false.</return></pre><pre><b>nodeLabels</b><return>   ^nodeLabels ifNil: [ nodeLabels := Set new ].</return></pre><pre><b>nodes</b><comment>   "Return the nodes in this graph."</comment><comment>         "entry looks like {  label. object. }"</comment><return>   ^bagNodes.</return></pre><pre><b>nodesDownStreamFrom: aRootNode </b><comment>   "Collect the nodes that are down-stream from a root node."</comment><comment>   "Set up recursive loop."</comment><comment>   "Avoid cycles."</comment><return>   ^downStream.</return></pre><pre><b>nodesDownStreamFrom: aRootNode butNotIn: upStreamNodes </b><comment>   "Find nodes that are down-stream from the root node but not in the upStreamNodes."</comment><comment>   "Note: It is possible for a pair of nodes to have more than one relationship."</comment><comment>         "Unpack the tuple."</comment><todo>   "TODO: ADD RECURSION AFTER THIS IS DEBUGGED."</todo><return>   ^downStreamNodes.</return></pre><hr/><hr/><h2>Hum-IDE</h2><hr/><h3>Hum-IDE -- HumCodeBase</h3><pre><b>everythingIsClassSide</b><comment>   "This is organized as a singleton - all the methods are on the class side."</comment></pre><hr/><h3>Hum-IDE -- HumCodeStream</h3><pre><b>&lt;&lt; aString </b></pre><pre><b>asString</b><return>   ^self printString.</return></pre><pre><b>contents</b><return>   ^(self stream) contents.</return></pre><pre><b>limit</b><comment>   "At what point do we assume code generation has run amock?"</comment><return>   ^ limit ifNil: [ limit := 200 ].</return></pre><pre><b>limit: aSmallInteger </b></pre><pre><b>printString</b><return>   ^(self stream) contents.</return></pre><pre><b>stream</b><return>   ^stream.</return></pre><hr/><h3>Hum-IDE -- HumFrameUpdater</h3><pre><b>addActionLine: aSourceString </b><comment>                   "Start a new action frame. This action is in the role`s PUBLIC API."        
                 self frame: (HumFrame4Action ontology: ontology </comment><comment>                   "Start a new action frame. This action is in the role`s PRIVATE API."        </comment><r>***22 lines of code ***</r></pre><pre><b>addDictionaryLine: aSourceString </b></pre><pre><b>addMarkUp: aSourceString </b></pre><pre><b>addPlanLine: aSourceString </b><comment>   "The kind of line is modal."</comment><comment>   "Look for lines that reset the mode."</comment><return>         ^self.</return><return>         ^self.</return><comment>   "Process the source line according to mode set by prior source line."   </comment><return>         ^self</return><return>         ^self.</return><return>         ^self</return><r>***41 lines of code ***</r></pre><pre><b>addVignetteInstruction: anInstructionLine </b></pre><pre><b>addVignetteLine: aSourceString </b><comment>   "DEBUG</comment><comment>   "</comment><comment>            "Store prior vignette frame and Start a new vignette frame."</comment><r>***52 lines of code ***</r></pre><pre><b>addVignetteResponse: aResponseString </b></pre><pre><b>appendFrameLine: aSourceString </b><comment>   "Create appropriate frameLine type and append to frame."</comment><comment>      "For vignette lines, we want to preserve leading dot because it identifies instruction lines."</comment></pre><pre><b>appendInstructionRole: aRole statement: aStatement </b></pre><pre><b>appendInstructionRole: aRole statement: aStatement comment: aComment </b></pre><pre><b>appendInstructionStatement: aStatement </b><comment>   "Append a simple instruction (no delegation, no comment) to the frame."</comment></pre><pre><b>appendPrecondition: aPreconditionStatement </b></pre><pre><b>appendRole: aRole action: aStatement </b><comment>   "Pass through to frame."</comment></pre><pre><b>checkFrameSyntax</b><return>   ^errors.</return></pre><pre><b>compileToOntology: aHumOntology </b><comment>   "Delegate to the frame."</comment><return>   ^errors.</return></pre><pre><b>frame</b><comment>   "If frame is not initialized before this call, we have a logic error."</comment><return>   ^frame ifNil: [ Error signal: 'frame has not bee initialized in FrameEditor instance.'].</return></pre><pre><b>frame: aFrame </b><comment>   "What frame am I editing ?"</comment></pre><pre><b>getInstructionAt: aSmallInteger </b><return>   ^self lines at: aSmallInteger .</return></pre><pre><b>isEmpty</b><return>   ^ (frame isNil) or: [frame isEmpty].</return></pre><pre><b>lines</b><return>   ^ (self frame) lines.</return></pre><pre><b>nextVignetteContext: aString </b></pre><pre><b>ontology</b><return>   ^ (ontology) ifNil: [ Error signal: 'Frame Updater instance must have an ontology.']</return></pre><pre><b>ontology: aHumOntology </b></pre><pre><b>parseInstruction: sourceWith </b><comment>   "Allow blank lines for readability."</comment><comment>   "Identify pattern and parse accordingly."</comment><return>   ^resultLine.</return><r>***21 lines of code ***</r></pre><pre><b>prettyPrint</b><comment>   "Pretty print the frame content (rendering as HTML)."</comment><return>   ^html</return></pre><pre><b>programmersAssistant</b><return>   ^ programmersAssistant ifNil: [programmersAssistant := HumProgrammersAssistant new].</return></pre><pre><b>putInstruction: aHumInstruction at: aSmallInteger </b></pre><pre><b>storeFrameInOntology</b><comment>   "Store my frame in my ontology"</comment><comment>   "The frame must have a title."</comment></pre><pre><b>stripLeaderFrom: aLine </b><return>   ^stmt</return></pre><pre><b>vignetteContext</b><return>   ^result.</return></pre><pre><b>vignetteMode</b><comment>   "What mode is the vignette parser in?"</comment><return>   ^vignetteMode</return></pre><pre><b>vignetteMode: newMode</b><comment>   "What mode is the vignette parser in?"</comment></pre><hr/><h3>Hum-IDE -- HumProgrammersAssistant</h3><pre><b>clearOntology</b></pre><pre><b>getAnnotationFromSource: aSourceString </b><comment>   "Match '[...]' if any, and extract it from source."</comment><return>   ^comment.</return></pre><pre><b>getCommentFromSource: aSourceString </b><comment>   "Match '(...)' if any, and extract it from source."</comment><return>   ^comment.</return></pre><pre><b>getLabelFromSource: aSourceString</b><comment>   "Match 'word:' at the front of the string.</comment><return>   ^label.</return></pre><pre><b>loadOntology: anOntology fromTextFileNamed: fileName</b><comment>   "Load an ontology from the given text file."</comment><return>   ^ontology.</return></pre><pre><b>loadOntologyFromSaveFileNamed: aFileNameString </b><comment>   "Reload an ontology from the given save file."</comment><return>   ^ontology.</return></pre><pre><b>loadOntologyFromTextFileNamed: fileName</b><comment>   "Load an ontology from the given text file."</comment><return>   ^ontology.</return></pre><pre><b>loadOntologyFromTextStream: aStream </b><comment>   "Discover frame type and store each frame in ontology."</comment><comment>   "Use ontology provided by caller or lazy initialization."</comment><comment>   "Define a function to detect action subframe case."</comment><comment>   "Read frames from the stream."</comment><comment>               "Get a fresh frameUpdater."</comment><comment>               "Get the title line and discover what kind of frame comes next."</comment><comment>   "Strore frame - unless frame is empty."   </comment><return>   ^ontology.</return><r>***28 lines of code ***</r></pre><pre><b>makeFramePerTitleLine: source </b><comment>   "The label on the title line indicates the kind of frame."</comment><return>   ^frame.</return><r>***43 lines of code ***</r></pre><pre><b>ontology</b><comment>   "Return the ontolgy. If nil initialize one."</comment><return>   ^ ontology ifNil: [ ontology := HumOntology new. ].</return></pre><pre><b>ontology: aHumOntology</b></pre><pre><b>parseActionLine: source </b><comment>   "An action line begins with 'Action:' or 'To:' label.</comment><comment>   "</comment><comment>   "Look-up #word types to see if they are #noun types."</comment><return>   ^ tokenPairsWithNounsMarked.</return><r>***22 lines of code ***</r></pre><pre><b>parseActionLine: aString keywords: aCollection </b><comment>   "An action line begins with 'Action:' or 'To:' keyword.</comment></pre><pre><b>parseInstructionSource: source keywords: keywords</b><comment>   "Parse the source -- Return a list of token-type pairs: ( token -&gt; tokenType ).</comment><comment>   "</comment><comment>   "Look-up #word types to see if they are #noun types."</comment><comment>   "If second token is colon, first token is a role."   </comment><return>   ^ tokenPairsWithNounsMarked.</return><r>***33 lines of code ***</r></pre><pre><b>parseMarkupSource: aSourceString </b><return>   ^result.</return></pre><pre><b>parseSource: source keywords: keywords</b><comment>   "Parse the source -- Return a list of token-type pairs: ( token -&gt; tokenType ).</comment><comment>   "</comment><comment>   "Look-up #word types to see if they are #noun types."</comment><return>   ^ tokenPairsWithNounsMarked.</return><r>***25 lines of code ***</r></pre><pre><b>removeAnnotationFromSource: aSourceString </b><return>   ^cleanerSource. </return></pre><pre><b>removeCommentFromSource: aSourceString </b><return>   ^cleanerSource. </return></pre><pre><b>removeLabelFromSource: aSourceString </b><comment>   "If there is a label, remove it and return the remainder."</comment><return>   ^remainder.</return></pre><pre><b>saveOntologyOnFileNamed: aFileName </b><comment>   "Save my ontology on the given ReferenceStream file."</comment><comment>   "Note: This method  does not provide any kind of versioning."</comment><todo>   "ToDo: If we save ontology in a WorldBase instead, </todo><comment>   "Open the file for write -- clear it if necessary."</comment><comment>   "Write the various data structures to the file."</comment></pre><pre><b>writeFrame: aFrame onStream: aStream</b><comment>   "Write frame-lines to given stream in canonical format.    *** NO SENDERS ***</comment><comment>            "My indent convention involves dot leader"</comment></pre><pre><b>writeOntologyContextVignettesOnStream: aStream</b></pre><pre><b>writeOntologyFrame: aFrame onStream: aStream</b><comment>   "Write to given stream - customize per frame-type as needed."</comment><comment>            "Eh? - All lines have the same dotLeader ???  What was I thinking???"</comment><comment>            "See also: writeOntologyFrameWithIndents:onStream:"    </comment></pre><pre><b>writeOntologyFrameWithIndents: aSubFrame onStream: aStream</b><comment>   "Vignette and View frames use dot-leader only for instruction lines."</comment><comment>            "My indent convention involves dot leader"</comment><comment>            "NOTE: This assumes the source does not contain its own dot-leader."      </comment></pre><pre><b>writeOntologyFramesOfType: aFrameClass onStream: aStream</b><comment>   "Select frames of given class and write them on the stream."</comment></pre><pre><b>writeOntologyOnTextFileNamed: aFileName </b><comment>   "Save my ontology in text format on the file with the given name. "</comment><comment>   "Order: Comment, Dictionary, Vignette, Role-Action, Plan, View"</comment><comment>   " -- NOTE: Original file order (if any) is not maintained. That means that comment frames may lack original context."</comment><comment>   "Write context vignettes in consolidated frames."</comment><comment>   "Write role-actions in consolidated frames."</comment><comment>   "Write the remaining frames. ( Plan, View )"</comment></pre><pre><b>writeOntologyRoleActionsOnStream: aStream</b><comment>   "Write role-action frames ordered by role and action."</comment><r>***21 lines of code ***</r></pre><pre><b>writeOntologyVFrame: aFrame onStream: aStream</b><comment>   "Write UI frames: Vignette and View frames only use dot-leader for instruction lines."</comment><comment>            "My indent convention involves dot leader"</comment></pre><hr/><h3>Hum-IDE -- HumTextEditor</h3><pre><b>beep</b><comment>   "Signal that cursor is out-of-bounds."</comment></pre><pre><b>bumpColumn: anInteger </b></pre><pre><b>bumpRow: anInteger </b></pre><pre><b>column</b><comment>   "What is the current column position of the cursor?"</comment><return>   ^column ifNil: [ column := 1 ].</return></pre><pre><b>column: anInteger </b><comment>   "Move cursor to given column position."</comment></pre><pre><b>currentLine</b><return>   ^self lineAt: (self row).</return></pre><pre><b>currentLine: aString </b></pre><pre><b>cursorPosition</b><comment>   "Where is the insert point?"</comment><return>   ^ (self row)@(self column).</return></pre><pre><b>deleteOrMerge</b><comment>   "Delete character to left of cursor.</comment><comment>            "Move remaining lines up"</comment><r>***38 lines of code ***</r></pre><pre><b>drawTextOnCanvas: aHumCanvas font: aFont </b></pre><pre><b>drawTextOnPane: aHumPane font: aFont </b></pre><pre><b>hasNewContent</b><comment>   "Has the content been changed? -- (Dirty data flag)"</comment><return>   ^hasNewContent ifNil: [ hasNewContent := false ].</return></pre><pre><b>hasNewContent: aBoolean </b><comment>   "Set true whenever the content has been changed."</comment><todo>   "TODO: Notify watchers if the boolean is true."</todo></pre><pre><b>insertCharacter: aCharacter </b></pre><pre><b>keyStroke: aCharacter</b><comment>   "Respond to simple keyboard input. (KISS: a character)</comment><comment>   "NOTE: Character does not support control, command, or shift modes."</comment></pre><pre><b>lineAt: anInteger </b><comment>   "Get string for given row"</comment><return>   ^aLine.</return></pre><pre><b>lines</b><comment>   "PRIVATE: My text lines. </comment><return>   ^lines ifNil: [ lines := Dictionary new ].</return></pre><pre><b>row</b><comment>   "What is the current row position of the cursor?"</comment><return>   ^row ifNil: [ row := 1 ].</return></pre><pre><b>row: anInteger </b><comment>   "Move cursor to given row position."</comment><comment>   "Note: You can move row beyond current lines."</comment></pre><pre><b>splitRow</b><comment>   "Everything after the current row is moved down one."</comment><comment>   "Split the current line."</comment><r>***22 lines of code ***</r></pre><hr/><hr/><h2>Hum-Language</h2><hr/><h3>Hum-Language -- HumConditionLine</h3><pre><b>&lt;= aHumConditionLine </b><comment>   "Provide a way to order preconditions</comment><return>   ^(self source) &lt;= (aHumConditionLine source)</return></pre><pre><b>annotation</b><return>   ^ annotation ifNil: [ '' ].</return></pre><pre><b>annotation: aString </b><comment>   "Annotation may indicate that condition is 'assumed'.  Other cases are not yet defined."</comment></pre><pre><b>checkSyntaxWithOntology: aHumOntology </b><comment>   "Is the precondition assumed?"</comment><comment>   "Otherwise: See if we have a plan for satisfying this precondition."</comment><comment>   "NOTE: #getPlanFrameForGoal: will return an empty plan frame  if there is none in the ontology. </comment><comment>   "</comment><return>   ^errors.</return><r>***21 lines of code ***</r></pre><pre><b>comment</b><return>   ^ comment ifNil: [ '' ].</return></pre><pre><b>compileLineToOntology: aHumOntology </b><comment>   "compile a precondition line into the ontology.</comment><comment>   "</comment><return>   ^problems.</return></pre><pre><b>source
   | s |</b><return>   ^ s. </return></pre><pre><b>source: aString</b><comment>   "DEBUG: Should not be 'Precondition' or: 'Pre'"</comment><return>   ^super source: aString.</return></pre><pre><b>statement</b><return>   ^ statement ifNil: [ '' ].</return></pre><pre><b>statement: aSource </b><comment>   "Set my statement."</comment></pre><hr/><h3>Hum-Language -- HumDictionaryLine</h3><pre><b>comment</b><return>   ^ comment ifNil: [ comment := String new. ].</return></pre><pre><b>compileLineToOntology: aHumOntology </b><comment>   "Add nouns and noun-relations to the ontology.</comment><comment>   "</comment><comment>   "We may discover syntax errors while compiling.</comment><comment>   "</comment><return>            ^lineErrors.</return><return>            ^lineErrors.</return><return>            ^lineErrors.</return><return>            ^lineErrors.</return><return>            ^lineErrors.</return><return>         ^lineErrors. </return><return>         ^lineErrors. </return><return>            ^ lineErrors.</return><return>            ^ lineErrors.</return><return>            ^lineErrors.</return><return>            ^lineErrors.</return><return>            ^lineErrors.</return><return>            ^lineErrors.].</return><comment>   "Comment: Shorthand and synonym and abbreviation features enable jargon. </comment><comment>   "</comment><comment>   "If we fall through to here, </comment><return>   ^ lineErrors.</return><r>***134 lines of code ***</r></pre><pre><b>getListAfter: aString </b><comment>   "Remove the word 'and' from the list."</comment><return>   ^list.</return></pre><pre><b>source</b><comment>   "Construct a source line based on convention and content of my attributes."</comment><return>   ^ s. </return></pre><pre><b>statement</b><return>   ^ statement</return></pre><pre><b>statement: aStatementString </b></pre><hr/><h3>Hum-Language -- HumFrame4Action</h3><pre><b>actionStatement</b><return>   ^ actionStatement ifNil:[ Error signal: 'Action frame must have an action statement']. </return></pre><pre><b>actionStatement: anObject</b></pre><pre><b>appendInstructionRole: aRole statement: aStatement </b></pre><pre><b>appendInstructionRole: aRole statement: aStatement comment: aComment   </b></pre><pre><b>appendInstructionStatement: aSource </b></pre><pre><b>checkSyntaxWithOntology: anOntology </b><comment>   "Critique the instructions for this role action."</comment><comment>   "Return the critique as a sequence of strings."</comment><comment>   "The action should contain at least one noun."</comment><comment>   "There should be at least one instruction for the action statement."      </comment><comment>   "Nouns in the instructions should find antecedants in the action statement."</comment><todo>   "TODO: The line after  'For . . .  : ' or  'If . . .  : '  or 'Else:' should be indented."   </todo><todo>   "TODO: Think about how indentation should be assured. </todo><comment>   "</comment><return>   ^critique.</return><r>***31 lines of code ***</r></pre><pre><b>compileToOntology: aHumOntology </b><comment>   "Compile the frame into the ontology."</comment><comment>   "Make sure frame is stored."</comment><comment>   "Index the role-action"   </comment><comment>   "Add the instruction sequence"</comment><comment>         "aHumOntology appendInstruction: instruction toRole: (self role) action: (self actionStatement)."</comment><comment>   "Return no errors."   </comment><return>   ^ (self checkSyntaxWithOntology:  aHumOntology ).</return><r>***22 lines of code ***</r></pre><pre><b>instructionLines</b><return>   ^ instructions ifNil: [ instructions := OrderedCollection new ].</return></pre><pre><b>instructions</b><return>   ^ instructions ifNil: [ instructions := OrderedCollection new. ].</return></pre><pre><b>instructions: anObject</b></pre><pre><b>role</b><return>   ^ role.</return></pre><pre><b>role: anObject</b></pre><pre><b>titleLine</b><comment>   "Format a cannonical title line."</comment><return>   ^ 'Role: ', ( self role asString capitalized), ' -- ', ( self actionStatement asString ).</return></pre><hr/><h3>Hum-Language -- HumFrame4Comment</h3><pre><b>appendFrameLine: aLine</b></pre><hr/><h3>Hum-Language -- HumFrame4Data</h3><pre><b>appendEntity: aEntityName attrribute: anAttributeName value: aValueString </b></pre><pre><b>asString</b><return>   ^s.</return></pre><hr/><h3>Hum-Language -- HumFrame4Dictionary</h3><pre><b>addDictionaryLine: aSourceString </b></pre><pre><b>compileToOntology: aHumOntology </b><comment>   "Each dictionary line will have some additive effect on the ontology."</comment><comment>   "Make sure frame is stored."</comment><comment>   "We may discover syntax errors while compiling."</comment><return>   ^syntaxErrors.</return></pre><hr/><h3>Hum-Language -- HumFrame4Plan</h3><pre><b>actionStatements</b><return>   ^self planActions.</return></pre><pre><b>appendInstructionRole: aRole statement: aStatement </b></pre><pre><b>appendPrecondition: aSource </b></pre><pre><b>appendPrecondition: aStatement annotation: anAnnotation</b></pre><pre><b>appendRole: aRole action: aSource </b><comment>   "Add 'role: action-statement' to plan-frame"</comment></pre><pre><b>appendRole: aRole action: aSource comment: aComment</b><comment>   "Add 'role: action-statement. (comment)' to plan-frame"</comment></pre><pre><b>check</b><comment>   "Check the basic integrity of the plan frame."</comment><comment>   "The callers sees the problems in the same order we do."</comment><comment>   "The plan frame must have a goal."</comment><comment>   "A plan frame should have at least two preconditions."</comment><return>   ^problems.</return></pre><pre><b>checkSyntaxWithOntology: anOntology</b><comment>   "Check stand-alone syntax.</comment><comment>   "</comment><comment>   "Check data flow. </comment><return>   ^frameErrors.</return><r>***24 lines of code ***</r></pre><pre><b>compileToOntology: aHumOntology </b><comment>   "Check the basic integrity of the plan frame.</comment><comment>   "Make sure frame is stored."</comment><comment>   "The callers sees the problems in the same order we do."</comment><comment>   "A plan frame should have at least two preconditions. (should not must)"</comment><comment>   "The plan frame must have a goal."</comment><comment>                        "If the frame has a goal, store the frame regardless of errors."</comment><comment>   "Compile the preconditions"      </comment><comment>            "Index the precondition"</comment><comment>             "aHumOntology frameRelations add: { (self title). #precondition. (precondition statement asString). }."</comment><todo>            "TODO: Decide if we want the title or the frame itself. (frame reference)"</todo><comment>            "Note: The title may change when the goal statement is edited. However, recompile should fix."</comment><comment>            "Note: Our structure could enable changing definition, changes all references."</comment><comment>   "Compile the actions"      </comment><comment>            "Index the precondition"</comment><comment>             "aHumOntology frameRelations add: { (self title). #invokesAction. ( action titleLine ). }."</comment><return>   ^problems.</return><r>***53 lines of code ***</r></pre><pre><b>goal</b><comment>   "Get the plan frame's goal statement."</comment><return>   ^ goal</return></pre><pre><b>goal: aSource </b><comment>   "This instance variable contains the plan frame's goal statement."</comment></pre><pre><b>isNoPlan</b><comment>   "Frame is no plan if there are no preconditions and no actions.</comment><comment>   "</comment><return>   ^true.</return></pre><pre><b>planActions</b><comment>  "A sequence of actions to be performed after preconditions are satisfied.</comment><comment>  "</comment><return>   ^ planActions ifNil: [ planActions := OrderedCollection new. ].</return></pre><pre><b>preconditions</b><comment>   "Preconditions are ordered to preserve the author`s sequence,</comment><comment>   "</comment><return>   ^ preconditions ifNil: [ preconditions := OrderedCollection new ].</return></pre><hr/><h3>Hum-Language -- HumFrame4View</h3><pre><b>addMarkUp: aSource </b></pre><pre><b>compileToOntology: aHumOntology</b><comment>   ""</comment><comment>   "Make sure frame is stored."</comment><comment>   "Index cases where a widget refers to another view."</comment><comment>                     "(aHumOntology frameRelations) add: { (self title). #invokesView. viewName. }"</comment><return>      ^errors := (super compileToOntology: aHumOntology ).</return><r>***24 lines of code ***</r></pre><pre><b>entity</b><return>   ^ entity ifNil: [ entity := HumCalculator given: (self titleLine) extractAfter: ': '].</return></pre><pre><b>entity: anObject</b></pre><pre><b>viewEntity: anEntityType. </b><comment>   "What entity-type is this view displaying."</comment></pre><pre><b>viewName: aString</b><comment>   "Caller passes the name of the view - to be used in calls."</comment><comment>   "View-name is a noun."</comment></pre><hr/><h3>Hum-Language -- HumFrame4Vignette</h3><pre><b>addPattern: aPatternString </b><comment>   "Enter a pattern -- What pattern will the vignette respond to?"</comment><comment>   "Nil is ignored when parser is running."</comment></pre><pre><b>addVignetteInstruction: anInstructionLine </b><comment>   "Append an instruction to be executed in response to the user / client."</comment><comment>         "check for role"</comment></pre><pre><b>addVignettePattern: patternString </b><comment>   "Append an Pattern to be executed in response to the user / client."</comment></pre><pre><b>addVignetteResponse: aResponseString </b><comment>   "Append a verbal response line."</comment></pre><pre><b>checkSyntaxWithOntology: anOntology</b><comment>   "Check the vignette for syntax problems."</comment><comment>   "First get the critique of the frame lines."</comment><comment>   "The vignette must have a context and a pattern."</comment><comment>   "The nextContext should be known to the ontology.</comment><comment>   "</comment><comment>   "Each [noun] field  in the pattern should reference known nouns."</comment><return>   ^critique.</return><r>***35 lines of code ***</r></pre><pre><b>compileToOntology: anOntology</b><comment>   "Update the ontology with this vignette."</comment><comment>   "Make sure frame is stored."</comment><comment>   "Index any external action calls."</comment><return>   ^ ( self checkSyntaxWithOntology: anOntology ) .</return><r>***42 lines of code ***</r></pre><pre><b>inputToken: inputToken isEquivalentTo: patternToken</b><comment>   "Is the input equivalent to the pattern?</comment><comment>   " </comment><comment>   "Simple case."</comment><comment>   "Handle tricky pattern tokens."</comment></pre><pre><b>inputTokensIn: aString</b><comment>   "Return the pattern tokens in the given string."</comment><comment>   "Extract strings in the input as separate tokens."</comment><todo>   "TODO: Numbers followed by measurement units should be treated as a single token."</todo><return>   ^tokens. </return><r>***27 lines of code ***</r></pre><pre><b>instructionLines</b><comment>   "Return the vignette's instruction lines. "</comment><return>   ^ instructionLines ifNil: [ instructionLines := OrderedCollection new. ].</return></pre><pre><b>nextVignetteContext</b><comment>   "By default, the next context is the current context."</comment><return>   ^ nextContext.</return></pre><pre><b>nextVignetteContext: aContextName </b><comment>   "What will be the context after the response is rendered?</comment><comment>   "</comment></pre><pre><b>patternFields: pattern</b><comment>   "Parse the pattern and return the [noun] fields - including the brackets."</comment><return>   ^fields.</return></pre><pre><b>patternMatchScore: aString</b><comment>   "How well does the string (from client) match the pattern int this vignette?</comment><comment>   "</comment><comment>   "But first, one pattern has to match. Then we score it."</comment><comment>         "These parsers remove noise words (a, an, the)."</comment><comment>         "Attempt to match input to pattern."</comment><comment>                        "Does the remaining input have the next pattern token?</comment><comment>                        "</comment><comment>                        "xNextInput := inputTokens indexOf: nextPatternToken startingAt: xInput ifAbsent: [ -1 ]."</comment><comment>                        "For now, assume the next input token matches the bracket expression."</comment><comment>                        "Advance the pattern token index to the closing bracket."</comment><comment>                        "A missing bracket should have been caught at compile-time."</comment><comment>                        "Advance the input to the next pattern token."</comment><comment>                        "Force out to the next pattern."</comment><comment>                        "Partial match does not score."</comment><comment>                        "Force out to the next pattern."</comment><return>   ^ bestPatternPoints.</return><r>***98 lines of code ***</r></pre><pre><b>patternNouns</b><return>   ^ nouns.</return></pre><pre><b>patternNouns: pattern</b><comment>   "Parse the pattern and return the nouns referenced in [noun] fields. </comment><comment>   "</comment><return>   ^fields.</return></pre><pre><b>patternTokensIn: aString </b><comment>   "Return the pattern tokens in the given string.</comment><comment>   "</comment><return>   ^tokens.</return></pre><pre><b>patterns</b><return>   ^ patterns ifNil: [ patterns := OrderedCollection new ].</return></pre><pre><b>responseLines</b><comment>   "What will be the verbal response? "</comment><return>   ^ responseLines ifNil: [ responseLines := OrderedCollection new. ].</return></pre><pre><b>titleLine</b><return>   ^s.</return></pre><pre><b>vignetteContext</b><comment>   "The context is used to prioritize responses when two or more patterns match a user input.</comment><comment>   "</comment><return>   ^ vignetteContext</return></pre><pre><b>vignetteContext: aContextString </b><comment>   "The context is used to prioritize responses when two or more patterns match a user input.</comment><comment>   "</comment></pre><pre><b>zpatternMatchScore: aString</b><comment>   "How well does the string (from client) match the pattern int this vignette?</comment><comment>   "</comment><comment>   "(aString beginsWith: 'My name is') ifTrue: [self halt]." "DEBUG"</comment><comment>   "But first, one pattern has to match. Then we score it."</comment><comment>         "Remove noise words and punctuation"</comment><comment>         "Attempt to match input to pattern."</comment><comment>                        "Does the remaining input have the next pattern token?</comment><comment>                        "</comment><todo>                        "TODO: HOW SHOULD WE INTERPRET THIS?</todo><comment>                        "</comment><comment>                        "For now, assume the next input token matches the bracket expression."</comment><comment>                        "Advance the pattern token index to the closing bracket."</comment><comment>                        "Force out to the next pattern."</comment><comment>                        "Force out to the next pattern."</comment><return>   ^ bestPatternPoints.</return><r>***93 lines of code ***</r></pre><hr/><h3>Hum-Language -- HumFrameLine</h3><pre><b>checkForAntecedantsIn: aHumStatement withOntology: aHumOntology </b><return>   ^result.</return></pre><pre><b>checkSyntaxWithOntology: aHumOntology </b><return>   ^ errors.</return></pre><pre><b>comment</b><comment>   "Any frame line can have a comment."</comment><return>   ^comment ifNil: [comment := ''].</return></pre><pre><b>comment: aString</b><comment>   "Any frame line can have a comment."</comment></pre><pre><b>compileLineToOntology: aHumOntology </b><comment>   "Compile this instruction line."</comment><comment>   "Subtypes should implement."</comment><comment>   "Error signal: 'Subtypes should implement.'."</comment><return>   ^ errors.</return></pre><pre><b>doTokensIn: input at: x matchPatternTokensIn: patternTokens at: xPattern</b><comment>   "See if we can get any matching sequence."</comment><todo>   "TODO: Everything in this method category should probably be in HumOntologyTranslator."</todo><comment>   "If we run out of pattern, we have succeeded."</comment><comment>   "If we run out self before we run out of pattern, we have failed."</comment><comment>   "A pattern token that is a digit will match anything. </comment><comment>   "</comment><return>                  ^isMatch. </return><comment>   "Remainder assumes that current pattern token is NOT a digit."            </comment><comment>   "If the current pattern token matches the current self token, proceed to the next token in both lists."</comment><return>                   ^isMatch </return><return>                  ^isMatch. ].      </return><comment>   "At this point we have a mismatch for sure. (I think maybe.)"</comment><return>   ^isMatch.</return><r>***34 lines of code ***</r></pre><pre><b>extractPatternParameters: aPatternString </b><comment>   "Extract parameters (tokens) from source that match the pattern."</comment><comment>   "Search to see if a sequence in my tokens matches a sequence in pattern tokens."</comment><return>   ^ parameters reversed.</return></pre><pre><b>generateCodeFrom: aTemplateString using: parameterValues </b><comment>   "Generate code (string) from the template replacing parameters with values in the parameter list."</comment><todo>   "TODO: Does this method belong in HumOntologyTranslator ?"</todo><return>   ^code.</return></pre><pre><b>getParametersIn: input at: x thatMatchParametersIn: patternTokens at: xPattern accumulating: parameters</b><comment>   "See if we can get any matching sequence."</comment><comment>   "If we run out of pattern, we have succeeded."</comment><comment>   "If we run out self before we run out of pattern, we have failed."</comment><comment>   "A pattern token that is a digit will match anything. </comment><comment>   "</comment><return>                 ^isMatch.</return><comment>   "Remainder assumes that current pattern token is not a parameter."            </comment><comment>   "If the current pattern token matches the current self token, proceed to the next token in both lists."</comment><return>                   ^isMatch </return><return>                  ^isMatch. ].      </return><comment>   "At this point we have a mismatch for sure. (I think maybe.)"</comment><return>   ^isMatch.</return><r>***35 lines of code ***</r></pre><pre><b>getTokensIn: aString</b><comment>   "This is a helper for #matchesPattern: (). It implements a Hum-friendly tokenizer."</comment><todo>   "TODO: Does this method belong in HumOntologyTranslator ?  It also might be in HumCalculator."</todo><comment>   "Punctuation does not include hyphen because nouns may be hypenated."</comment><comment>   "White space includes space, cr, tab."   </comment><comment>   "Tokens are all lower-case and include punctuation."</comment><return>   ^tokens.</return></pre><pre><b>matchesPattern: aPatternString </b><comment>   "Does some part of the frame-line match the given pattern?"</comment><comment>   "Search to see if a sequence in my tokens matches a sequence in pattern tokens."</comment><return>   ^isMatch.</return></pre><pre><b>onMatch: aPatternString generate: aTemplateString </b><comment>   "When some part of the content in the current line matches the pattern,</comment><comment>   "</comment><comment>   "If there is no match, there is nothing to do. Return an empty string."</comment><comment>   "Otherwise, we have a match.</comment><comment>   "</comment><return>   ^code.</return></pre><pre><b>printOn: aStream</b><comment>   "Append to the argument, aStream, a sequence of characters that  </comment><comment>      "nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);"</comment></pre><pre><b>sameAs: anotherFrameLine</b><comment>   "Eh? Why are we here?"</comment></pre><pre><b>source</b><return>   ^ source</return></pre><pre><b>source: aString </b><comment>   "Any frame line might have a comment between ()."</comment></pre><hr/><h3>Hum-Language -- HumFrame</h3><pre><b>appendFrameLine: aFrameLine</b><comment>   "Append a line to the frame."</comment></pre><pre><b>checkSyntaxWithOntology: anOntology</b><comment>   "Check stand-alone syntax.</comment><comment>   "</comment><return>   ^frameErrors.</return></pre><pre><b>compileToOntology: aHumOntology </b><comment>   "Regardless of errors add frame to the ontology."   </comment><return>   ^problems.</return></pre><pre><b>debug</b><comment>   "Am I in debug mode?"</comment><return>   ^ debug ifNil: [debug := false].</return></pre><pre><b>debug: aBoolean </b></pre><pre><b>delegateToTranslator</b></pre><pre><b>delegated</b></pre><pre><b>frameLines</b><return>   ^frameLines ifNil: [ frameLines := OrderedCollection new.]</return></pre><pre><b>frameName</b><comment>   "The name of the frame is guaranteed to be a string.</comment><comment>   "</comment><return>   ^ frameName.</return></pre><pre><b>initialize</b><comment>   "The instance should always be a subtype."</comment></pre><pre><b>isEmpty</b><return>   ^result.</return></pre><pre><b>linesAsHTMLwithOntology: anOntology</b><return>   ^html.</return></pre><pre><b>ontology</b><return>   ^ ontology</return></pre><pre><b>ontology: anOntology</b></pre><pre><b>origin</b><comment>   "Where did this frame come from?"</comment><return>   ^origin ifNil: [ origin := 'unknown' ].</return></pre><pre><b>origin: aString</b><comment>   "Where did this frame come from?"</comment></pre><pre><b>prettyPrintWithOntology: aHumOntology</b><comment>   "Pretty-print using HTML5 and CSS</comment><return>   ^html.</return></pre><pre><b>printOn: aStream</b><comment>   "Append to the argument, aStream, a sequence of characters that  </comment><comment>      "nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);"</comment></pre><pre><b>title</b><return>   ^ self titleLine </return></pre><pre><b>titleLine</b><return>   ^titleLine</return></pre><pre><b>titleLine: anObject</b></pre><pre><b>uniqueIdentifier</b><comment>   "Note: Lazy initialization for this frame`s identifier."</comment><return>   ^ uniqueIdentifier </return></pre><pre><b>zcompileToOntology: aHumOntology </b><comment>   "Regardless of errors add frame to the ontology."   </comment><comment>   "Looking for trouble!"</comment><comment>         "Action, Plan, and Vignette frames all may have instruction lines."</comment><return>   ^problems.</return></pre><hr/><h3>Hum-Language -- HumInstructionLine</h3><pre><b>= anInstruction</b><comment>   "??? Looks like bad code ???  "</comment><comment>   "Find out where this is used.  (2015-12-26: None of the unit tests trip over this halt.)"</comment></pre><pre><b>annotation</b><return>   ^ annotation ifNil: [^'' ].</return></pre><pre><b>annotation: aString </b><comment>   "Annotation may indicate timing for simulations. </comment><comment>   "</comment></pre><pre><b>checkSyntaxWithOntology: aHumOntology </b><return>   ^ errors.</return></pre><pre><b>checkSyntaxWithOntology: aHumOntology defaultRole: aRole</b><comment>   "Forgive a nil statement. Sometimes an instruction line has no statement."</comment><comment>   "Ignore empty statement"</comment><comment>   "Check that the nouns in the statement are known. (defined in the ontology)."</comment><comment>   "Check that a delegated action is defined in the ontology."</comment><return>   ^ errors.</return></pre><pre><b>comment</b><return>   ^ comment ifNil: [''].</return></pre><pre><b>comment: aString </b><comment>   "Comment is not executable. May be displayed in certain contexts."</comment></pre><pre><b>compileLineToOntology: aHumOntology </b><comment>   "Compile this instruction line."</comment><comment>   "Check syntax"</comment><comment>   "remember the errors - May show in HTML and other views"</comment><return>   ^ errors.</return></pre><pre><b>compileLineToOntology: aHumOntology defaultRole: aRole</b><comment>   "Compile this instruction line."</comment><todo>   "TODO: Kludge some polymorphism.</todo><comment>   "Check syntax"</comment><comment>   "remember the errors - May show in HTML and other views"</comment><return>   ^ errors.</return></pre><pre><b>indent</b><comment>   "How many indents (tabs) before the start of the code-text ?"</comment><return>   ^ indent ifNil: [ indent := 1 ].</return></pre><pre><b>indent: aSmallInteger</b><comment>   "How many indents (tabs) before the start of the code-text ?"</comment></pre><pre><b>jobTicket</b><comment>   "There should be a job ticket if the (run-time) caller expects one."</comment><return>   ^ jobTicket ifNil: [ Error signal: 'no jobTicket']</return></pre><pre><b>jobTicket: aJobTicket</b><comment>   "At run-time, a job ticket may be associated with action request."</comment><todo>   "TODO: This instance variable is here because the run-time needs to pass a jobTicket when delegating an instruction. (?)</todo></pre><pre><b>onComment: aBlockClosure </b><comment>   "If instruction includes a comment, execute the block."</comment></pre><pre><b>onRole: aBlockClosure </b><comment>   "If instruction includes a role prefix, execute the block."</comment></pre><pre><b>role</b><comment>   "What role am I delegating to? If none, the instruction is to myself."</comment><return>   ^ role  ifNotNil: [ (role) ] ifNil: ['']. </return><todo>   "TODO: Consider returning #self instead of an empty string."</todo></pre><pre><b>role: aString </b><comment>   "Delegate the task (statement) to this role at run-time. "</comment></pre><pre><b>source</b><comment>   "Construct a source line based on convention and content of my attributes."</comment><return>   ^ s. </return></pre><pre><b>source: aString</b><comment>   "Should not be: 'Action:' block-label."</comment><return>   ^super source: aString.</return></pre><pre><b>statement</b><comment>   "What will be done . . . will be done at run-time."</comment><return>   ^ statement </return></pre><pre><b>statement: aSource </b><comment>   "What to do  at run-time?"</comment><comment>         "Determine the indent level."</comment><return>         ^self.</return><return>         ^self. ].</return><r>***26 lines of code ***</r></pre><pre><b>title</b><return>   ^ self titleLine.</return></pre><pre><b>titleLine</b><return>   ^ ( self role), ': ', ( self statement asString ).</return></pre><pre><b>translation: aString </b></pre><hr/><h3>Hum-Language -- HumMarkupLine</h3><pre><b>checkSyntaxWithOntology: aHumOntology </b><comment>   "Syntax errors in mark-up mainly have to do with widgets that won't work.</comment><comment>   "</comment><comment>   ""</comment><comment>   "Look for unknown nouns in widgets."</comment><todo>   "TODO: Look for unknown widget-types in widgets.</todo><comment>   "</comment><return>   ^errors.</return><r>***32 lines of code ***</r></pre><pre><b>compileLineToOntology: aHumOntology </b><comment>   ""</comment><comment>   "Look for unknown nouns in widgets."</comment><todo>   "TODO: Look for unknown widget-types in widgets."</todo><return>   ^errors.</return><r>***24 lines of code ***</r></pre><pre><b>generateCodeOfType: aSymbol fromTokens: tokens at: xToken</b><comment>   "Generate code of the given type HTML/Seaside/JavaScript based on token stream."</comment><comment>   "Current experiment is to generate HTML5 from Hum mark-up."</comment><comment>   "If we ran out of tokens, we are done?"</comment><comment>   "If we are at beginning of line, there are special rules."</comment><return>               ^ code.</return><comment>               "Remainder of line is in this header"</comment><return>               ^code.</return><comment>               "If level has changed, we need to output &lt;ul&gt; or &lt;/ul&gt;"</comment><comment>               "Remainder of line is in this header"</comment><return>               ^code.</return><comment>            "If we have come this far, the line begins with nothing special."</comment><comment>              "Go on as if we were not on the first token."</comment><comment>      "Look for quotes -- we need to remove tokens between quotes from translation."</comment><return>            ^code.</return><comment>      "Look for emphasis -- tokens between are in scope of  . . ."</comment><comment>            "Note: Above is a bit simplistic. </comment><comment>            "</comment><return>            ^code.</return><comment>      "Look for widgets."</comment><r>***80 lines of code ***</r></pre><pre><b>generateHtmlTableFor: aNoun withOntology: anOntology</b><comment>   "If the entity has no attributes, generate a default table."</comment><comment>  "Otherwise generate a normal table."</comment><return>   ^html.</return></pre><pre><b>getWidgetArgument: aWidgetString</b><comment>   "Parse the widget string to get verb`s argument, if any."</comment><return>   ^argument</return></pre><pre><b>getWidgetNoun: aWidgetString</b><comment>   "Parse the widget-string to get the widget`s noun (blackboard entity-attribute-name), if any."</comment><return>   ^noun</return></pre><pre><b>getWidgetVerb: aWidgetString</b><comment>   "Parse the widget-string to get the widget`s verb, if any."</comment><return>   ^verb</return></pre><pre><b>widgets</b><comment>   "Scan the source matching pairs of [. . .] or [[. . .]]."</comment><comment>   "Scan for widgets"      </comment><return>   ^widgets.</return><r>***21 lines of code ***</r></pre><hr/><h3>Hum-Language -- HumOntologyTranslator</h3><pre><b>asJava</b><comment>   "This is crude version.</comment><comment>   "</comment><return>   ^ code.</return></pre><pre><b>attachAction: aMethodName toActorClass: aClassName fromSource: aSource</b><comment>   "Attach the given method source </comment></pre><pre><b>attachPrologToActorClass: aClassName fromSource: aSourceString </b><comment>   "Attach the given prologue source code to the named class."</comment><comment>   "Note: There can be only one prologue for each actor class"</comment></pre><pre><b>contextEntity: aString </b></pre><pre><b>countLeading: aCharacter inString: line</b><comment>   "Count leading"</comment><return>  ^n-1.</return></pre><pre><b>genHTML: generatedCodeString</b><comment>   "Append generated code to 'html' instance variable. (YIKES!)"</comment><comment>   "If code begins with a tag, insert cr to improve readability."</comment></pre><pre><b>generateErlangDocumentation</b><comment>   "2015-12-26: I wrote some experimental versions of an Erlang Messenger some time ago.</comment><comment>   "</comment><return>   ^translationStrategy, runTimeStrategy.</return></pre><pre><b>generateErlangForActionCall: aString</b><comment>   "Translate a Hum Action call into an Erlang OTP call."</comment><comment>   "Extract the statement string from the Instruction Line."</comment><todo>   "TODO: HumStatement knows how to parse better than HumCalculator. It knows about comments and annotations."   </todo><return>   ^erlang</return></pre><pre><b>generateErlangForActionHeader: aString </b><comment>   "Then: The do header looks like 'do( { action-statement, noun-values } )' "</comment><todo>   "TODO: Fix case where statementString contains single quote/s."</todo><return>   ^ erlang.</return></pre><pre><b>generateErlangForEntity: anEntity</b><comment>   "Translate entity into an Erlang record data structure. &lt;&lt;&lt; OBSOLETE</comment><comment>   "</comment><comment>   "After all, action call will be ?CALL({',roleAtom,',"',statementString,'",NounValues}). where NounValues is a list of {noun, noun-value} tuples."</comment><comment>   "Generate the preamble."</comment><comment>   "Generate the tuple elements."</comment><return>   ^erlangCode.   </return><r>***33 lines of code ***</r></pre><pre><b>generateErlangForInstruction: aHumInstructionLine </b><comment>   "Generate self-call or RPC for given instruction."</comment><comment>   "Insert comment, if any, before the Erlang translation of the statement."</comment><comment>   "If a role-label is present, the action is delegated to another role; otherwise calling self."</comment><return>   ^erlangCode contents.</return><r>***22 lines of code ***</r></pre><pre><b>generateErlangForPlanFrame: aHumFrame4Plan </b><comment>   "Translate the plan frame into an Erlang data structure.</comment><comment>   "</comment><return>   ^erlangCode.</return><r>***28 lines of code ***</r></pre><pre><b>generateErlangForRole: aRoleName</b><comment>   "Generate Erlang code for the given role-name."</comment><comment>   "Generate the module`s declarations."</comment><todo>   "TODO: Define TBD string (see above) - Call is routed to appropriate Hum Dispatcher via Hum Messenger."</todo><comment>   "Following causes compiler to show macro expansion. "</comment><comment>   "Generate the logic for each action frame."</comment><return>   ^moduleDeclarationCode contents, moduleLogicCode contents.</return><r>***37 lines of code ***</r></pre><pre><b>generateErlangForRoles</b><comment>   "Generate a Erlang module file for each Hum role."</comment></pre><pre><b>generateErlangForSelfCall: aString</b><comment>   "Translate a Hum Self call into an Erlang self call."</comment><todo>   "TODO: HumStatement knows how to parse better than above. It knows about comments and annotations."</todo><return>   ^erlang</return></pre><pre><b>generateErlangNounValuesForStatement: aStatementString</b><comment>   "Get statement nouns."</comment><return>   ^ nounValueTuples contents.</return></pre><pre><b>generateHTMLforMarkupLines: aListOfFrameLines blackboard: aBlackboard</b><comment>   "Build HTML for the given list of frame-lines"</comment><comment>   "My code produces side-effect in instance-variable 'html', (shame on me)</comment><comment>   "</comment><comment>               "There should be no remainder"</comment><return>    ^self html contents.</return><r>***59 lines of code ***</r></pre><pre><b>generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard</b><comment>   "Build output until we see a substring matching aStopString."</comment><comment>   "When we need to recurse, </comment><comment>   "</comment><comment>   "Emphasis patterns.  (bold, italic, underline, superscript)"</comment><comment>   "Hypertext"</comment><comment>   "Delegate to another pane."</comment><comment>   "Button"</comment><comment>   "Treat button as a special case?"</comment><comment>   "Radio Button or Comment"</comment><comment>                           "Is a radio button intended?"</comment><comment>   "Input widgets"</comment><todo>   "TODO: When view is invoked with 'Show:' rather than 'Ask:', the input fields should be disabled."</todo><todo>                                 "TODO: Adapt input to datatype." </todo><comment>                           "Catch checkbox case"</comment><todo>                                     "TODO: Adapt input to datatype.</todo><comment>                                     " </comment><comment>   "table row -- Should be implemented elsewhere."</comment><comment>  "Just ordinary text."</comment><return>         ^remainder := ''.         </return><comment>  "Recurse"</comment><return>   ^self generateHTMLforMarkupString: remainder blackboard: aBlackBoard.</return><r>***123 lines of code ***</r></pre><pre><b>generateHTMLforViewFrame: aHumFrame4View blackboard: aHumBlackBoard </b><comment>   "Wrap viewframe lines with  HTML form and submit logic."</comment><comment>   "Translate the Hum markup"</comment><comment>   "Add a submit button"</comment><comment>   "The user might not be ready to fill-in-the-blanks. Give user a way to decline."</comment><todo>   "TODO: The Scribe must interpret 'Go!' versus 'NoGo!' -- to invoke appropriate dialog vignette."</todo><comment>   "Wrap in a form."</comment><return>   ^formHTML.</return><r>***23 lines of code ***</r></pre><pre><b>generateJavaCallForFrameLine: aHumInstructionLine </b><comment>   "space := Character space asString."</comment><comment>   "Generate optional code if role or comment is present."</comment><comment>   "Generate Java code -- depending on type of statement."</comment><return>   ^instructionCode.</return><r>***21 lines of code ***</r></pre><pre><b>generateJavaCallForStatement: aHumStatement </b><return>   ^code.</return><r>***22 lines of code ***</r></pre><pre><b>generateJavaConditionalForStatement: aHumStatement </b><return>   ^code.</return></pre><pre><b>generateJavaForFrame: aHumFrame4Action </b><comment>   "Translate frame to Java using the nouns given in the ontology."</comment><todo>         "TODO: Translate if/else/for"</todo><return>   ^ javaDoc, cr, selectorCode, space, '{', frameCode, cr, '}' .</return><r>***23 lines of code ***</r></pre><pre><b>generateJavaForFrameLine: aHumInstructionLine </b><comment>   "space := Character space asString."</comment><comment>   "Generate optional code if role or comment is present."</comment><comment>   "Generate Java code -- depending on type of statement."</comment><return>   ^instructionCode.</return></pre><pre><b>generateJavaForPlanFrame: aHumFrame4Plan </b><comment>   "The plan is data, so translation involves translating each goal frame into a series of Java setters.</comment><comment>   "</comment><return>   ^javaCode.</return><r>***22 lines of code ***</r></pre><pre><b>generateJavaForStatement: aHumStatement </b><comment>   "TODO -- This will fail if there is a comment appended to the statement."</comment><return>   ^code</return></pre><pre><b>generateJavaIterationForStatement: aHumStatement </b><comment>   "Given a Hum for-statement, generate a Java for-statement."</comment><todo>   "TODO: Refactor this to use a template. (Should be cleaner code.)"</todo><return>   ^code.</return></pre><pre><b>generateJavaMethodDeclarationForStatement: aHumStatement </b><return>   ^code.</return><r>***22 lines of code ***</r></pre><pre><b>generateJavaScriptAngularReadMe</b><comment>   "Angular is a JavaScript user interface framework."</comment><comment>   "Angular-Bootstrap simplifies the programming of layouts and rich interface effects."</comment></pre><pre><b>generateSeasideForView: aHumFrame4View </b><comment>   "Implement the view frame via Seaside components.</comment><comment>   "</comment><comment>         "Generate Seaside code for each line in the view frame"</comment><todo>         "TODO: SUSPECT THERE SHOULD BE A COMMA IN GENERATED CODE ABOVE."</todo><return>   ^frameCode.</return><r>***22 lines of code ***</r></pre><pre><b>generateSeasideForViewMarkup: aHumMarkupLine </b><comment>   "Generate Seaside code to implement a view mark-up line."</comment><comment>   "Parse into tokens"</comment><comment>   "Generate for heading"</comment><comment>   "Generate input fields."</comment><return>   ^lineCode. </return></pre><pre><b>generateSeasideHeadingFor: source</b><comment>   "Generate Seaside heading code for the given heading line."</comment><return>   ^outlineCode.</return><r>***28 lines of code ***</r></pre><pre><b>generateSeasideWidgetForField: fieldName</b><comment>   "This is the default to cover when we fall through the cases."</comment><comment>   "Does widget contain a colon. If not, we have a simple attribute."</comment><todo>   "TODO: REFACTOR above so that it is more sensitive to the attribute`s data-type. </todo><comment>   "</comment><todo>   "TODO: Hum panes need to be enclosed in table &lt;td&gt; or perhaps &lt;div&gt; </todo><comment>   "</comment><return>   ^ commentCode, String cr, widgetCode.</return><r>***76 lines of code ***</r></pre><pre><b>generateSeasideWidgetsForSource: aSourceString</b><comment>   "Generate Seaside calls for the widgets found in this mark-up line."</comment><comment>   "*** CALLER MUST REPLACE ALL [] WITH {} BECAUSE WE GENERATE [] IN SEASIDE CODE. ***"</comment><comment>   "Match button."</comment><comment>         "Get all the buttons before we go on."</comment><comment>   "Match check-box" </comment><comment>         "Get all the check-boxes before we go on."</comment><comment>   "Match other widgets."</comment><comment>       "Name followed by space and digit means multi-line text box"</comment><todo>               "TODO: If the attribute-name is plural, render as a table."</todo><todo>         "TODO: Special handling for other types: category, date-time, measure."</todo><comment>   "Match radio-button -- TODO: THIS RADIO BUTTON STRATEGY WILL FAIL."   </comment><comment>         "Call myself recursively"</comment><todo>         "TODO: Need &lt;group&gt; tags."</todo><return>   ^wip.   </return><r>***68 lines of code ***</r></pre><pre><b>generateSmalltalk</b><comment>   "This is crude version.</comment><comment>   "</comment><return>   ^ code.</return></pre><pre><b>generateSmalltalkActionFor: aHumFrame4Action </b><comment>   "Translate frame to Smalltalk using the nouns given in the ontology."</comment><comment>   "Translate the lines. Adding block ends when indent is reduced."</comment><return>   ^ selectorCode, String cr, frameCode .</return><r>***22 lines of code ***</r></pre><pre><b>generateSmalltalkForConditional: aHumStatement </b><return>   ^code.</return></pre><pre><b>generateSmalltalkForFrame: aHumFrame</b><comment>   "Translate frame to Smalltalk using the nouns given in the ontology."</comment><return>   ^frameCode.</return></pre><pre><b>generateSmalltalkForFrameLine: anInstructionLine </b><comment>   "space := Character space asString."</comment><return>   ^instructionCode.</return></pre><pre><b>generateSmalltalkForStatement: aHumStatement </b><comment>   "TODO -- This will fail if there is a comment appended to the statement."</comment><return>         ^code ].</return><return>   ^code</return></pre><pre><b>generateSmalltalkIfFor: aHumStatement </b><comment>   "Translate a Hum if-statement into a Smalltalk (  ) ifTrue: [] expression."</comment><todo>   "TODO: Refactor this to use a template. (Should be cleaner code.)"</todo><todo>   "TODO: Refactor to make the operator an argument."</todo><return>               ^code := smalltalkIf valueWithArguments: { entity1. attribute2. entity3. attribute4. '&gt;'.}</return><return>               ^code := smalltalkIf valueWithArguments: { entity1. attribute2. entity3. attribute4. '&gt;'.}</return><return>               ^code := smalltalkIf valueWithArguments: { entity1. attribute2. entity3. attribute4. '&lt;'.}</return><return>               ^code := smalltalkIf valueWithArguments: { entity1. attribute2. entity3. attribute4. '&lt;'.}</return><return>               ^code := smalltalkIf valueWithArguments: { entity1. attribute2. entity3. attribute4. '='.}</return><return>               ^code := smalltalkIf valueWithArguments: { entity1. attribute2. entity3. attribute4. '='.}</return><return>   ^code.</return><r>***41 lines of code ***</r></pre><pre><b>generateSmalltalkIterationFor: aHumStatement </b><todo>   "TODO: Refactor this to use a template. (Should be cleaner code.)"</todo><return>   ^code.</return></pre><pre><b>generateSmalltalkOnFile: aFileName</b><comment>   "Open file and produce File-Out / File-In format."</comment><comment>     "Following is template for file-out / file-in format."</comment><comment>"</comment><comment>   ""@@MethodComment""</comment><comment>"      </comment><comment>   "This is crude version.</comment><comment>   "</comment><r>***37 lines of code ***</r></pre><pre><b>generateXamarinReadMe</b><comment>   "Xamarin runs on Windows, iOS, and Android devices.  (client side)</comment><comment>   "See XamarinHQ on YouTube for tutorials."</comment></pre><pre><b>getMethodsForClass: aClassName</b><comment>   "Get the methods colletion (a Dictionary) for the given Class"</comment><return>   ^methods.</return></pre><pre><b>html</b><return>   ^html ifNil: [html := ReadWriteStream on: ''.].</return></pre><pre><b>humParserError: aComplaint inCodeFragment: aCodeFragment</b><todo>   "TODO: In the future, we might not want this to stop execution."</todo><comment>   "Generate HTML to embed critique near problem"</comment><return>   ^complaintHTML.</return></pre><pre><b>methodsForClasses</b><return>   ^ methodsForClasses ifNil: [ methodsForClasses := Dictionary new ].</return></pre><pre><b>moveCodeGenerator</b></pre><pre><b>nounAsCamelCase: aNoun </b><comment>   "Generate camel-case string the the given noun."</comment><comment>   "Note: First letter is also capitalized. </comment><return>   ^camelCase.</return></pre><pre><b>nounsAsJava</b><comment>   "Emit java code that implements noun relations."</comment><comment>   "Currently this emits all classes into a single code stream. </comment><comment>   "</comment><comment>   "Get a list of the entities."</comment><comment>   "Define a private function that determines the correct supertype for a given noun."</comment><todo>         "TODO: Fix this up so that multiple inheritance is correctly handled."</todo><comment>         "Function returns the discovered supertype or the default supertype"</comment><comment>   "Emit a class for each entity."</comment><comment>      "Everything extends Entity class -- which provides toHTML(), toXML(), and persistence methods (TBD)."</comment><todo>      "TODO: If the entity has a single superclass, override the extendsSuperType value with that superclass name."</todo><comment>      "Get the entity's attributes."</comment><comment>      "Emit instance variable declarations for each attribute. -- Default type is String."</comment><comment>         "If noun is plural, make the type Bag&lt;Entity&gt;"</comment><comment>      "Class ends with closing brace and a comment."</comment><comment>   "Comment: This demonstrates that entities can be translated to java classes.</comment><return>   ^code.</return><r>***56 lines of code ***</r></pre><pre><b>ontology</b><return>   ^ ontology ifNil: [ontology := HumOntology new.]</return></pre><pre><b>ontology: aHumOntology </b></pre><pre><b>prologues</b><return>   ^ prologues ifNil: [ prologues := Dictionary new ].</return></pre><pre><b>rolesAsJava</b><return>   ^code.</return><r>***25 lines of code ***</r></pre><pre><b>when: aSource matchesPattern: aPattern produce: aBlock</b><comment>   "Convertstrings to streams."</comment><comment>   "Does source begin with markup?"</comment><return>         ^remainder.</return><comment>  "The source must begin with a markup character."</comment><comment>   "If the pattern does not match, </comment><comment>  "If there is a match, build the argument list."</comment><comment>                 "Does the pattern match the source? </comment><comment>   "If we matched, run the production block"</comment><comment>   "Return the remainder of the source."</comment><return>  ^remainder.</return><r>***66 lines of code ***</r></pre><hr/><h3>Hum-Language -- HumOntologyViewer</h3><pre><b>asHTML5</b><comment>   "Render the ontology as an HTML5 page.</comment><comment>   "</comment><return>   ^html</return></pre><pre><b>asHTML5withCritique</b><comment>   "Render the ontology as an HTML5 page.</comment><comment>   "</comment><return>   ^html</return></pre><pre><b>asHTML5withCritique: withCritique withBase: withBase</b><comment>   "Render the ontology as an HTML5 page.</comment><comment>   "</comment><comment>   "Creating a fresh calculator initializes XML indent."</comment><comment>                  "Build the HTML body"   </comment><comment>                           "Render the ontology fiilename, if any, as an HTML5 heading element."</comment><comment>                                 "Delegate rendering of the frames to the frames."</comment><comment>                                 "The &lt;hr/&gt; seems to be needed. I cannot figure out how to do that with CSS."</comment><comment>                           "The &lt;hr/&gt; also seems to be needed. I cannot figure out how to do that in CSS either."</comment><todo>   "TODO: Add plan-tree rendering.  Render plan-tree for each goal that is invoked in a vignette."</todo><comment>   "See: renderPlanTreeForGoal: aGoal"</comment><todo>   "TODO: Add noun-tree rendeing. Render a noun-tree for each entity."</todo><comment>   "See: renderNounTreeForNoun: aNoun"</comment><todo>   "TODO: Add role-dependency rendering. Render a dependency tree for each role."</todo><todo>   "TODO: Add context-path rendering.  Render the context path diagram starting with 'Start' context. "</todo><return>   ^html.    </return><r>***40 lines of code ***</r></pre><pre><b>asHTML5withCritiqueSkippingBaseOntology</b><comment>   "Render the ontology as an HTML5 page.</comment><comment>   "</comment><return>   ^html.</return></pre><pre><b>css</b><comment>   "generate HTML Cascading Style Sheet (CSS) code segment"</comment><todo>   "TODO: Consider using class='indentN' to control indent in action frames.</todo><comment>   "</comment><return>   ^html.</return><r>***49 lines of code ***</r></pre><pre><b>generateCategoryPullDownFor: aNoun </b><comment>   "Render category noun as a pull-down selection."</comment><comment>   "Use global HumCalculator to generate XML "</comment><return>   ^html.</return></pre><pre><b>generateHtmlTableFor: anEntity</b><comment>   "Generate a dummy table showing the attributes for this entity-name." </comment><comment>   "If the entity has no attributes, generate a default table."</comment><comment>  "Otherwise generate a normal table."</comment><return>   ^html.</return></pre><pre><b>initialize</b></pre><pre><b>modeStack</b><comment>   "Stack to track list-type modes."</comment><return>   ^ modeStack ifNil: [ modeStack := Stack new.]</return></pre><pre><b>ontology: aHumOntology </b></pre><pre><b>render: asSymbol onFileNamed: aNewFile</b><return>   ^string.</return></pre><pre><b>renderActionFrame: aHumFrame4Action </b><comment>   "Render action frame with indentation.</comment><comment>         "Else: reduces indent for self."</comment><comment>         "If, Else, for-each, all increase indent."</comment><return>   ^html.</return><r>***28 lines of code ***</r></pre><pre><b>renderActionFrame: aHumFrame4Action withCritique: aBoolean</b><comment>   "Render source code. </comment><comment>         "Else: reduces indent for self."</comment><comment>         "If, Else, for-each, all increase indent."</comment><return>   ^html.</return><r>***28 lines of code ***</r></pre><pre><b>renderActionLine: aHumFrameLine </b><comment>   "Tests indicate this is redundant."</comment><return>   ^ calc xml: 'titleLine' with: [source].</return></pre><pre><b>renderAs: aSymbol </b><comment>   "FUTURE: Render as X -- Currently not needed."</comment><comment>   "Call the HTML rendering code."</comment></pre><pre><b>renderAsHTMLonFileNamed: aNewFile </b><comment>   "Render as HTML5 and echo on given file."</comment><return>   ^html.</return></pre><pre><b>renderAsHTMLwithCritique: withCritique withBase: withBase onFileNamed: aNewFile </b><comment>   "Render as HTML5 and echo on given file."</comment><return>   ^html.</return></pre><pre><b>renderAsHTMLwithCritiqueOnFileNamed: aNewFile </b><comment>   "Render as HTML5 and echo on given file."</comment><return>   ^html.</return></pre><pre><b>renderCommentIn: aFrameLine </b><comment>   "Render comment (if any) as HTML"</comment><return>    ^html.</return></pre><pre><b>renderConditionLine: aHumConditionLine  </b><comment>   "Avoid empty statement element."   </comment><comment>   "Avoid empty comment element.</comment><comment>   "Render the annotation."   </comment><comment>   "Assemble it without any line breaks."   </comment><todo>   "TODO: Add hyperlink to frame (if any) that has goal matching this precondition."</todo><return>   ^html.</return></pre><pre><b>renderCritiqueForFrame: aHumFrame </b><comment>   "Return (HTML5) rendering of the frame`s critique"</comment><return>   ^html.</return></pre><pre><b>renderDictionaryLine: aHumDictionaryLine </b><return>   ^ calc xml: 'DictionaryLine' </return></pre><pre><b>renderFrame: aHumFrame  withCritique: withCritique</b><comment>   "Render (pretty print) source code. </comment><return>   ^html.</return></pre><pre><b>renderFrame: aHumFrame  withCritique: withCritique withBase: withBaseOntology</b><comment>   "Render (pretty print) source code. </comment><comment>      "Abbreviate the frame if we are skipping base ontology frames."</comment><comment>            "html := calc xml: 'commentLine' with: [ (aHumFrame titleLine), ' -- See base ontology.'  ]. "</comment><return>            ^html.</return><comment>   "Wrap the lines with a HumFrame tag."</comment><comment>   "Note: &lt;frame&gt; has semantics in HTML, so we use &lt;HumFrame&gt; tag instead."</comment><comment>               "Return"</comment><return>   ^'&lt;hr/&gt;',String cr,html.</return><r>***30 lines of code ***</r></pre><pre><b>renderFrameLine: frameLine  </b><comment>   "Dispatch frameLine to rendering specialist."</comment><comment>   "Under some conditions we get an ordinary frame line in Action frames."</comment><r>***21 lines of code ***</r></pre><pre><b>renderFrameLinesIn: aHumFrame </b><comment>   "Iterate throught the frame lines" </comment><comment>   "View frames are rendered as HTML forms with widgets."</comment><comment>   "Plan frames are rendered with Precondition and Action sections"</comment><comment>   "Action frames are rendered with Role: and Action: labels."</comment><comment>   "Other frame types are just pretty-printed?"</comment><return>   ^html.</return></pre><pre><b>renderInstruction: aHumStatement </b><comment>  "Pretty-print statement as HTML"</comment><return>   ^self renderStatement: aHumStatement triggerWords: triggerWords keywords: keywords.</return></pre><pre><b>renderInstructionLine: aHumInstructionLine  </b><comment>   "Pretty-print using HTML5 tags and CSS."</comment><comment>   "Avoid an empty role element.</comment><comment>   "Avoid empty statement element."   </comment><comment>   "Avoid empty comment element.</comment><comment>   "Render the annotation."   </comment><comment>   "Assemble it without any line breaks."   </comment><return>   ^html.</return><r>***26 lines of code ***</r></pre><pre><b>renderMarkupAsHTML5: markupSource</b><comment>   "Render the given mark-up text as HTML headings, lists, emphasis."</comment><todo>   "TODO: Replace this with call to HumOntologyTranslator." </todo><comment>   "Maintain spacing."</comment><comment>   "Is this markup line a heading?"</comment><comment>   "If this is a heading, render the whole line as a heading. "   </comment><comment>   "Call self recursively to catch any additional emphasis (e.g. italics)"</comment><comment>   "Is this markup line a bullet/numbered list item."   </comment><todo>            "TODO: Figure out how to emit '&lt;/ul&gt;' and '&lt;/ol&gt;.' -- Might need MODES. (heavens)"</todo><return>            ^html.   </return><comment>   "None of the above"</comment><comment>   "Delegate emphasis"</comment><return>   ^html.</return><r>***61 lines of code ***</r></pre><pre><b>renderMarkupEmphasisAsHTML5: aString </b><comment>   "Render bold, italic, underscore emphasis."</comment><comment>   "Initialize work-in-progress."</comment><comment>   "Cannot use #match: for asterisk case. So we use this trick:"</comment><return>   ^wip.</return><r>***32 lines of code ***</r></pre><pre><b>renderNounTreeForNoun: aNoun </b><comment>   "Render a noun-tree rooted at the given noun (entity)."</comment><return>   ^ string.</return><r>***28 lines of code ***</r></pre><pre><b>renderNounTreeForNounAsHTML: aNoun </b><comment>   "Render a noun-tree rooted at the given noun (entity)."</comment><return>   ^html</return></pre><pre><b>renderPlanActionsIn: aHumFrame4Plan </b><comment>   "render precondition lines"</comment><comment>         "html := html, '&lt;br/&gt;', ( self renderStatement: actionLine ), cr."</comment><return>   ^ html</return></pre><pre><b>renderPlanFrame: aHumFrame4Plan </b><comment>   "Render source code. </comment><return>   ^html.</return></pre><pre><b>renderPlanPreconditionsIn: aHumFrame4Plan </b><comment>   "render precondition lines"</comment><comment>   "Always include this subheading."</comment><return>   ^ html</return></pre><pre><b>renderPlanTreeForGoal: aGoal</b><comment>   "Render HTML for a previous created planTree (generated by  buildPlanTreeForGoal: )"</comment><comment>   "NOTE: The goals that are most relevant are those found in dialog vignettes."</comment><comment>   "See: HumOntologyTests&gt;&gt;test540GetPlanTree </comment><comment>   "</comment><return>   ^ string.</return><r>***26 lines of code ***</r></pre><pre><b>renderStatement: aHumStatement keywords: keywords </b><comment>         "Assign a tag that the CSS can then style."</comment><comment>         "Just another token with no particular type."</comment><return>   ^html</return></pre><pre><b>renderStatement: aHumStatement triggerWords: triggerWords keywords: keywords </b><comment>         "Assign a tag that the CSS can then style."</comment><comment>         "Just another token with no particular type."</comment><return>   ^html</return></pre><pre><b>renderView: aHumViewFrame </b><comment>   "Views are rendered as HTML forms -- which is different from other frames."</comment><comment>            "Markup lines will control line-breaks without my help."</comment><comment>            "Future: View might have instruction-lines for tables."</comment><comment>      "Block returns "</comment><return>   ^html.</return><r>***21 lines of code ***</r></pre><pre><b>renderWidgetsInMarkup: aSourceString </b><comment>   "Return HTML5 equivalent of the widgets found in this mark-up line."</comment><comment>   "Match button."</comment><comment>         "Get all the buttons before we go on."</comment><comment>   "Match check-box" </comment><comment>         "Get all the check-boxes before we go on."</comment><comment>   "Match other widgets."</comment><comment>       "Name followed by space and digit means multi-line text box"</comment><todo>               "TODO: If the attribute-name is plural, render as a table."</todo><todo>         "TODO: Special handling for other types: category, date-time, measure."</todo><comment>   "Match radio-button"   </comment><todo>         "TODO: Need &lt;group&gt; tags. HOW ARE WE GOING TO DO THAT?"</todo><comment>   "If no widgets were found in this pass: Return;  Otherwise: Iterate."</comment><r>***68 lines of code ***</r></pre><pre><b>showPlanTree: aPlanTree</b><comment>   "Display a previous created planTree (generated by  buildPlanTreeForGoal: )"</comment><comment>   "See: HumOntologyTests&gt;&gt;test540GetPlanTree </comment><comment>   "</comment><todo>      "TODO: What does this produce?  It looks like a simple rendering with no indentation."</todo><return>   ^ string.</return></pre><pre><b>showPlanTreeForGoal: aGoal</b><comment>   "Display a previous created planTree (generated by  buildPlanTreeForGoal: )"</comment><comment>   "See: HumOntologyTests&gt;&gt;test540GetPlanTree </comment><comment>   "</comment><return>   ^ string.</return><r>***24 lines of code ***</r></pre><hr/><h3>Hum-Language -- HumOntology</h3><pre><b>actionsOf: aRole</b><comment>   "The actions of a role define its public interface. (API).</comment><comment>   "</comment><return>      ^self projectValuesOf: (self roleActions) from: (aRole capitalized).</return></pre><pre><b>addEntity: anEntity attribute: anAttribute </b><comment>      "Define these nouns and their relationship."</comment><comment>   "Add entity-attribute relationship."</comment></pre><pre><b>addEntity: anEntity attributes: anAttributeCollection </b><comment>      "Define these nouns and their relationship."</comment></pre><pre><b>addNoun: aNoun </b><comment>   "Remember noun."</comment><return>         ^self.</return><comment>   "Watch for parsing bug"</comment><comment>   "Check if noun has an implied supertype."</comment></pre><pre><b>addNoun: aSubType isA: aSuperType </b><comment>      "Add these nouns and add is-A relation."</comment><comment>   "Add these nouns in case they are not already added."</comment><comment>   "Add inverse relation -- Note: subtypes is also a Set."</comment></pre><pre><b>addNoun: aNoun isDerivedFrom: anotherNoun</b></pre><pre><b>addNoun: aSynonym isSynonymFor: aStandardNoun </b><comment>   "Add these nouns and add is-A relation."</comment><comment>   "Add these nouns in case they are not already added."</comment><comment>   "Add inverse relation -- Note: subtypes is also a Set."</comment></pre><pre><b>addNoun: aNounString reference: aFrameLine </b><comment>   "Remember where nouns are referenced."</comment></pre><pre><b>addNouns: anArrayOfNouns </b></pre><pre><b>addPlanFrame: aPlanFrame ForGoal: aGoalString </b><comment>   "Store frame as a plan frame - index as needed."</comment></pre><pre><b>addRole: aRole </b></pre><pre><b>addViewFrame: aHumFrame4View </b></pre><pre><b>addVignette: aFrame4Vignette toContext: aContext </b><comment>   "Add to store"</comment><comment>   "frame defines context"</comment></pre><pre><b>allAttributesOfEntity: anEntity </b><comment>   "Get the attributes, the attributes of the attributes, and the attributes of the supertypes."</comment><comment>   "Get the immediate properties of this entity."</comment><comment>   "Entity properties include attributes and supertypes."</comment><comment>   "For each local property: Look up attributes and add them to the result set."</comment><comment>         "RECURSIVE CALL !!!"</comment><comment>         "Detect cycles in the tree."</comment><return>   ^allAttributes</return><r>***32 lines of code ***</r></pre><pre><b>allSubtypesOf: aSuperType </b><comment>   "Get the subtypes (if any) of this noun and the subtypes of the subtypes all the way down"</comment><comment>         "RECURSION: Get the subtypes for each of those subtypes."</comment><comment>         "Merge the sets"</comment><comment>         "Detect cycles in the tree."</comment><comment>   "Return the merged set of all subtypes."   </comment><return>   ^allSubtypes.</return></pre><pre><b>allSupertypesOf: aSubType </b><comment>   "Get the Supertypes (if any) of this noun and the Supertypes of the Supertypes all the way down"</comment><comment>         "RECURSION: Get the Supertypes for each of those Supertypes."</comment><comment>         "Merge the sets"</comment><comment>         "Detect cycles in the tree."</comment><comment>   "Return the merged set of all Supertypes."   </comment><return>   ^allSupertypes.</return></pre><pre><b>appendInstruction: aHumInstruction toRole: aRole action: anAction </b><comment>   "Append the given instruction to the action's sequence of instructions."</comment><comment>   "Get the sequence of instructions belonging to this role action."</comment><comment>   "Append the given instruction to the sequence."</comment><comment>   "Assure that the data store is updated."</comment></pre><pre><b>appendRole: aRole action: actionStatement </b><comment>   "Add role and action statement."</comment><comment>   "Assure role is in set."</comment><comment>   "Assure statement is in set."</comment></pre><pre><b>attributeChain</b><return>   ^attributeChain ifNil: [ attributeChain := Stack new.]</return></pre><pre><b>attributeChainPop: anAttribute </b></pre><pre><b>attributeChainPush: anAttribute </b></pre><pre><b>buildNounTreeForNoun: aNoun indent: anIndentLevel </b><comment>   ""</comment><comment>         "Detect a cycle in the tree."</comment><return>   ^nounTree.   </return></pre><pre><b>buildPlanTreeForGoal: aGoal indent: anIndentLevel</b><comment>   "Build a list of associations: ( goalStatement -&gt; { anIndentLevel. precondition statement.} )"</comment><comment>   "Stop building the plan subtree if the root frame is not defined."</comment><comment>         "Detect a cycle in the tree."</comment><return>   ^planTree.</return></pre><pre><b>categoriesOf: anAttributeName </b><return>   ^categories := (self nounCategories) at: anAttributeName ifAbsent: [Set new].</return></pre><pre><b>categoriesOf: anAttributeName include: anArrayOfCategoryNames</b><comment>   "Add this noun in case it is not already added;"</comment><comment>   "and make it a kind of category"</comment></pre><pre><b>checkPlanTreeForGoal: aGoal </b><comment>   "Check for problems that would prevent the plan from working."</comment><comment>   "Safety check -- &gt;&gt;buildPlanTreeForGoal: . . . will stop execution if there is a cycle in the plan-tree."</comment><return>                  ^ planTreeProblems ].</return><comment>   " Look for preconditions that have no corresponding plan frame in the ontology."</comment><return>   ^planTreeProblems.</return><r>***24 lines of code ***</r></pre><pre><b>cleanKey: aString</b><comment>   "Assure that the string will be a clean key -- convert to lower-case, trim blanks."</comment><return>   ^camelCase.</return></pre><pre><b>codeGenerator</b><comment>   "Return a translator."</comment><return>   ^translator </return><comment>         "Precondition: Assure we are compiled."</comment><todo>         "TODO: This 'Assure we are compiled.' strategy will fail </todo><comment>         "Post condition: translator is set."</comment></pre><pre><b>collectPlanFramesForGoal: aGoalStatement </b><comment>   "| goalStatement planTree subTree rootFrame |</comment><return>   ^planTree."</return><comment>   "First check to make sure the plan frames are complete."</comment><comment>   "Collect the plan frames."</comment><return>   ^frameCollection.</return><r>***30 lines of code ***</r></pre><pre><b>compileAllFrames</b><comment>   "Compile the dictionary frames first, then the others." </comment><comment>   "Return any problems found."</comment><comment>   "Reset the frame index"</comment><comment>   "Compile the dictionary frames first."</comment><comment>   "Compile the remaining frames."</comment><return>   ^problems.</return><r>***25 lines of code ***</r></pre><pre><b>contextVignettes</b><comment>   "This list holds the (1:M) relation (context -&gt; vignette)."</comment><comment>   "Vignettes are evaluated in the order seen."</comment><todo>   "TODO: Decide if we need a priority attribute on a vignette to enable re-ordering." </todo><return>   ^contextVignettes.</return></pre><pre><b>contexts</b><return>   ^ contexts ifNil: [  contexts := Set new. ]</return></pre><pre><b>critiqueRole: aRole action: anAction </b><comment>   "Critique the instructions for this role action."</comment><comment>   "Return the critique as a sequence of strings."</comment><comment>   "The action should contain at least one noun."</comment><comment>   "There should be at least one instruction for the action statement."      </comment><comment>   "Nouns in the instructions should find antecedants in the action statement."</comment><return>      ^critique.</return><r>***26 lines of code ***</r></pre><pre><b>debug</b><comment>   "Am I in debug mode?"</comment><return>   ^ debug ifNil: [debug := false].</return></pre><pre><b>entityAttributes</b><comment>   "This instance variable is a map, a set of associations ( anEntity -&gt; anAttribute )"</comment><return>   ^entityAttributes ifNil: [ entityAttributes := Set new.].</return></pre><pre><b>fetchFrameByIdentifier: aPrimaryKey </b><comment>   "Fetch the frame with this identifier."</comment><return>   ^frame.</return></pre><pre><b>fetchFrameByName: aString </b><comment>   "self assert: (aString endsWith: '.')."</comment><return>   ^frame.</return></pre><pre><b>file</b><return>   ^ fromFile ifNil: [ fromFile := 'HumOntologyFile.ontology' ].</return></pre><pre><b>file: aString </b></pre><pre><b>findBestMatchingVignetteForInput: aString inContextStack: aStack </b><comment>   "Search the vignette frames for the one whose pattern is the best match</comment><comment>   "We want the best match with a score better than zero."</comment><comment>         "See if we have any vignettes that match that context."</comment><comment>         "Get the bestMatch from that set."</comment><return>   ^ bestMatch.</return><r>***28 lines of code ***</r></pre><pre><b>frameRelations</b><comment>   "The cross index collection tracks relationships between frames."</comment><comment>   "Entries have the form: { frameA. #symbol. frameB. }</comment><comment>   "</comment><return>   ^ frameRelations ifNil: [ frameRelations := Set new. ].</return></pre><pre><b>frameRelationsWhere:  aBlock</b><comment>   "Return frame relations where aBlock evaluates as true"</comment><return>   ^selectedRelations.</return></pre><pre><b>frames</b><return>   ^ frames ifNil: [ frames := Set new. ].</return></pre><pre><b>framesByIdentifier</b><comment>   "Each frame is given a unique identifier. </comment><return>   ^ framesByIdentifier ifNil: [ framesByIdentifier := Dictionary new. ].</return></pre><pre><b>framesByName</b><comment>   "Enable access to frames by their name (title line string)."</comment><return>   ^ framesByName ifNil: [ framesByName := Dictionary new ].</return></pre><pre><b>fromFile</b><comment>   "The file name serves as a natural identifier. "</comment><return>   ^ fromFile ifNil: [ ^ '(untitled)' ].</return></pre><pre><b>getEntityAttributePhraseFromStatement: aHumStatement </b><comment>   "Return collection of 'entity attribute' pairs when statement contains possessive nouns."</comment><todo>         "TODO: Perhaps we should put '`s' in the pair. Leave a clue, other than the space, for other processes."</todo><return>   ^pairs.</return></pre><pre><b>getFrameForRole: aRole action: anAction </b><comment>   "Get the frame that matches given role and action."</comment><todo>   "TODO: Kludge some polymorphism.</todo><return>                  ^frame.</return><comment>   "If no frame is found/generated (will happen for a new role), return an empty frame."</comment><return>   ^frame.</return><r>***30 lines of code ***</r></pre><pre><b>getFramesThatDefineContext: aContextName </b><comment>   "Get the vignette frames that define the given context."</comment><return>   ^resultSet.</return></pre><pre><b>getFramesThatInvokeAction: anActionString </b><comment>   "Lookup the frames where action is invoked."</comment><return>   ^ resultSet.</return></pre><pre><b>getFramesThatInvokeContext: aContextName </b><comment>   "Get frames with 'Push context &lt;aContextName&gt;.'  instructions."</comment><return>   ^resultSet.</return></pre><pre><b>getFramesThatInvokePrecondition: aStatementString </b><comment>   "Lookup the frames where precondition is invoked."</comment><return>   ^ resultSet.</return></pre><pre><b>getFramesThatInvokeView: aViewName</b><comment>   "A view may be invoked by another view or by a vignette."</comment><comment>   "Compiler will scan views to index [pane: ...] pattern. " </comment><comment>   "Compiler will scan vignettes to index instructions 'Show &lt;viewname&gt;.' and 'Ask &lt;viewname&gt;.'"</comment><return>   ^resultSet.</return></pre><pre><b>getFramesWithRelation: aSymbol object: aName</b><comment>   "Get frames that are indexed with given relation and object."</comment><return>   ^resultSet.</return></pre><pre><b>getPlanFrameForGoal: aGoalString </b><return>                        ^ HumFrame4Plan ontology: self goal: (aGoalString asString).</return><return>   ^frame.</return></pre><pre><b>getRole: aRole action: aStringOrStatement </b><comment>   "Get the action if it already exists."</comment><todo>   "TODO: Kludge some polymorphism.</todo><comment>   "Assure that we are dealing with a HumStatment."</comment><comment>   "If the role action set already contains the action statement,</comment><comment>   "   </comment><todo>         "TODO: Refactor to handle polymorphism."</todo><return>         ^nil ].</return><return>   ^actionStatement.</return></pre><pre><b>getViewFrame: nameString </b><comment>   "Get the view frame with the given name."</comment><return>   ^frame.</return></pre><pre><b>hasNoVignetteMatchFor: aString </b><return>   ^ defaultVignette.</return></pre><pre><b>immediateAttributesOfEntity: anEntity </b><return>   ^ self projectValuesOf: (self entityAttributes) from: anEntity.</return></pre><pre><b>immediateSubtypesOf: aSuperType </b><comment>   "Get the subtypes (if any) of this noun."</comment><return>   ^ self projectValuesOf: (self nounSubtypes) from: aSuperType.</return></pre><pre><b>immediateSupertypesOf: aNoun</b><comment>   "Get the immedate supertypes (if any) for this noun." </comment><comment>   "Initialize the result set."</comment><comment>   "for each map ( supertype -&gt; subtype ):"</comment><return>   ^supertypes.</return></pre><pre><b>indexFrame: aHumFrame relation: aSymbol object: aKeyString </b><comment>   "Add the given frame to the index"</comment></pre><pre><b>indexRole: aRole action: actionStatement </b><comment>   "Index role and action statement."</comment><comment>   "Assure role is in set."</comment><comment>   "Assure statement is in set."</comment></pre><pre><b>instructionsForRole: aRole action: anAction</b><return>   ^lines.  </return></pre><pre><b>isActionDefined: anInstructionLine inRole: aRole</b><comment>   "Has the given statement been defined as an action for the given role?"</comment><todo>   "TODO: Kludge some polymorphism.</todo><comment>   "(result) ifFalse: [ self halt. ]."</comment><return>   ^ result.</return></pre><pre><b>isActionDefinedV01: anInstructionLine </b><comment>   "See if we have a definition for the given action."</comment><return>   ^ numberOfDefinitions &gt; 0.</return></pre><pre><b>isAttribute: aNameString</b><comment>   "Does the string name an attribute? (An attribute has no attributes of its own.)"</comment><comment>   "First: Does it name a noun?"</comment><comment>   "An attribute has no attributes. </comment><return>   ^result.</return></pre><pre><b>isCategory: aNameString</b><comment>   "Does the string name an attribute? (An attribute has no attributes of its own.)"</comment><comment>   "First: Does it name a noun?"</comment><return>   ^result.</return></pre><pre><b>isEntity: aNameString</b><comment>   "Does the string name an entity?"</comment><comment>   "First: Does it name a noun?"</comment><comment>   "An entity has one or more attributes."</comment><return>   ^result.</return></pre><pre><b>isEntity: entityName attribute: attributeName</b><comment>   "Does this combination make sense? "</comment><comment>   "Does the first noun name an entity?"</comment><comment>   "Is the second noun an attribute of the first noun?"</comment><return>   ^result.</return></pre><pre><b>isNoun: aNounString    </b><comment>   "Is the given string a noun?"</comment><todo>   "TODO: Refactor to deal with possessive case. e.g. 'user`s name'. "</todo><return>   ^( self nouns ) include: singular.</return></pre><pre><b>isPluralNoun: aNoun</b><comment>   "Return true if the noun is plural."</comment><return>   ^isSingular not.</return></pre><pre><b>isViewName: aString </b><comment>   "Does the string name a view frame?"</comment><return>   ^result.</return></pre><pre><b>nounAsCamelCase: aString </b><return>   ^result.</return></pre><pre><b>nounCategories</b><return>   ^ nounCategories ifNil: [ nounCategories := Dictionary new ].</return></pre><pre><b>nounReferences</b><return>   ^ nounReferences ifNil: [ nounReferences := Set new. ].</return></pre><pre><b>nounSubtypes</b><comment>   "This instance variable is a map, a set of associations ( aSuperType -&gt; aSubType )."</comment><return>   ^ nounSubtypes ifNil: [ nounSubtypes := Set new.].</return></pre><pre><b>nounSynonyms</b><return>   ^nounSynonyms ifNil: [  nounSynonyms := Set new ].</return></pre><pre><b>nouns</b><comment>   "This instance variable is the set of all nouns that have been defined so far."</comment><return>   ^nouns ifNil: [ nouns := Set new.].</return></pre><pre><b>nounsInStatement: aHumStatement </b><comment>   "Return the (known) nouns found in the statement."</comment><comment>   "Forgive a nil statement. (Sometimes an instruction line has no statement.)"</comment><comment>   "Forgive a string instead of a statement."</comment><todo>   "TODO: Detect entity-attribute noun-phrase. Example: recipe`s bake-time."</todo><comment>         "Remove nouns in each pair from the prior set."</comment><todo>   "TODO: Technical strategy for dealing with explicit constants in caller code."</todo><todo>   "TODO: Detect quoted strings as nouns? -- (Caller side)"</todo><todo>   "TODO: Detect measurements as nouns? -- (Caller side)"</todo><todo>   "TODO: Detect names as nouns? -- (Caller side) "</todo><return>   ^statementNouns.</return><r>***32 lines of code ***</r></pre><pre><b>parseFrameLine: frameLine keywords: keywords</b><comment>   "Parse the frameLine -- Return a list of token-type pairs: ( token -&gt; tokenType ).</comment><comment>   "Note: Preserve uppercase in tokens so that first word of a sentence is capitalized."</comment><comment>   "QUESTION: Is the role-label part of the statement? </comment><comment>               "Does the source have a comment?"</comment><comment>               "Does the source have annotation?"</comment><return>   ^ tokenTypePairs.</return><r>***46 lines of code ***</r></pre><pre><b>parseStatement: aHumStatement triggerWords: triggerWords keywords: keywords </b><comment>   "Parse the statement -- Return a list of token-type pairs: ( token -&gt; tokenType ).</comment><todo>   "TODO: Scan to detect and remove strings delimited by quote or double-quote."</todo><comment>   "Note: Preserve uppercase in tokens so that first word of a sentence is capitalized."</comment><comment>   "QUESTION: Is the role-label part of the statement? </comment><todo>   "TODO: Detect measurement pattern: 'number unit-of-measure' "</todo><return>   ^ tokenTypes.</return><r>***31 lines of code ***</r></pre><pre><b>planFrames</b><return>   ^planFrames </return></pre><pre><b>projectValuesOf: aSetOfAssociations from: aKey</b><comment>   "encapsulate a bit of recurring code"</comment><return>   ^resultSet.</return></pre><pre><b>roleActions</b><comment>   "This instance variable is a map, a set of associations  ( role -&gt; actionStatement ) "</comment><return>   ^roleActions ifNil: [ roleActions := Set new.]</return></pre><pre><b>roles</b><comment>   "This instance variable contains the set of all roles that have been defined so far."</comment><return>   ^roles ifNil: [ roles := Set new.].</return></pre><pre><b>setAutomaticSupertypeForNoun: aNoun </b><comment>   "If a hyphenated nouns ends with the name of another noun,</comment><comment>   "See if there is a hyphen in the noun."</comment><comment>   "See if the last token is currently a noun."</comment><comment>  "The last token is currently a noun, so make this noun a subtype."</comment></pre><pre><b>singularFormOfNoun: aNoun </b><comment>   "If noun ends in 's'  remove the 's'.  Crude."</comment><comment>   "Following is first approximation. </comment><return>   ^singular.</return></pre><pre><b>storeFrame: aFrame </b><comment>   "Store this frame in the ontology.</comment><comment>   "</comment><comment>   "If the frame does not have an ID (serial-number) give it one."</comment><comment>   "The title of the frame can serve to index it but cannot be used to ID it </comment><comment>   "Also enable caller to fetch a frame by its name."</comment><comment>   "Also enable caller to fetch frames by role."</comment><comment>   "Enable caller to fetch vignettes by context-name."</comment><comment>   "Also enable caller to fetch frame collection without any keys."</comment><r>***27 lines of code ***</r></pre><pre><b>title</b><return>   ^ title ifNil: [ title :=  (self fromFile), ' -- No title yet.'. ].</return></pre><pre><b>title: aString </b></pre><pre><b>view</b><return>   ^viewer ifNil: [ viewer := HumOntologyViewer ontology: self. ].</return></pre><pre><b>vignettesForContext: aRequestedContext</b><comment>   "DEBUG ('*activity*' match: aRequestedContext ) ifTrue: [ self halt. ]."</comment><return>   ^vignettes.</return></pre><pre><b>xparseString: aStatementString keywords: keywords </b><comment>   "Coding experiment to see if I can tweak existing code to handle quoted strings."</comment><comment>   "Parse the statement string -- Return a list of token-type pairs: ( token -&gt; tokenType ).</comment><comment>   "Note: Preserve uppercase in tokens so that first word of a sentence is capitalized."</comment><comment>   "QUESTION: Is the role-label part of the statement? </comment><comment>   "Collapse quoted string."</comment><todo>   "TODO: Detect measurement pattern: 'number unit-of-measure' "</todo><return>   ^ tokenTypes.</return><r>***34 lines of code ***</r></pre><pre><b>yesNoun: aSubtype isAKindOf: aSuperType </b><comment>   "Is the noun a subtype of the given supertype? Used when matching action statements."</comment><comment>   "Check for special case:</comment><comment>   "</comment><comment>   "Normal case:"</comment><return>   ^result.</return></pre><pre><b>yesRole: aRole hasAction: aSource</b><comment>   "Is the given action defined for the given role?"</comment><comment>   "Convert String to Statement, if needed."</comment><return>   ^(self actionsOf: (aRole capitalized ) ) anySatisfy: [ :statement | </return></pre><hr/><h3>Hum-Language -- HumParser2</h3><pre><b>alphanumeric: aString </b><comment>   "Match that part of the string that is alpha-numeric"</comment><return>   ^result.</return></pre><pre><b>checkbox: aSource</b><comment>   "Does the current source start with a check box widget?"</comment></pre><pre><b>checkbox: aSource produce: aProductionBlock</b><comment>   "Does the current source start with a check box widget?"</comment><comment>         "A check box must contain a single letter. </comment></pre><pre><b>digits: source </b><comment>   "Match leading part of source that is digits"</comment><return>   ^result.</return></pre><pre><b>generateChoicesFor: anAttributeName inOntology: aHumOntology </b><comment>   "Generate HTML choice tags"</comment><return>   ^html.</return></pre><pre><b>generatedCode</b><comment>   ""</comment><return>   ^code.</return></pre><pre><b>ignoreNext</b><return>   ^ignoreNext ifNil: [ ignoreNext := false. ].</return></pre><pre><b>ignoreNext: aBoolean </b></pre><pre><b>markupSyntax</b><comment>   "Experimental BNF syntax"</comment><comment>   "x is the matched text -- see alphanum below"</comment><comment>   "n is the size of the match -- see _prefix below"</comment><return>   ^markup.   </return><r>***38 lines of code ***</r></pre><pre><b>markupSyntaxWithOntology: anOntology</b><comment>   "Experimental BNF syntax"</comment><comment>   "x is the matched text -- see alphanum below"</comment><comment>   "n is the size of the match -- see _prefix below"</comment><todo>   "TODO: FIGURE OUT HOW TO DO AN ORDERED (NUMBERED) LIST."</todo><comment>                        "Note the name='...' value must be HTML, CSS, jQuery and HumBlackboard compatible "</comment><return>   ^markup.</return><r>***70 lines of code ***</r></pre><pre><b>markupSyntaxWithOntology: anOntology blackBoard: aBlackBoard</b><comment>   "Experimental BNF syntax"</comment><comment>   "x is the matched text -- see alphanum below"</comment><comment>   "n is the size of the match -- see _prefix below"</comment><todo>   "TODO: FIGURE OUT HOW TO DO AN ORDERED (NUMBERED) LIST."</todo><comment>   "humNoun := [:s | x := (self noun: s ). self halt. ]."</comment><comment>                        "Note the name='...' value must be HTML, CSS, jQuery and HumBlackboard compatible "</comment><return>   ^markup.</return><r>***73 lines of code ***</r></pre><pre><b>match: source oneOf: anArrayOfSyntaxThings</b><return>   ^result.</return></pre><pre><b>match: source oneOf: anArrayOfSyntaxThings produce: productionBlock</b><comment>   "Does current source match array? If so, run the production."</comment><return>   ^result.</return></pre><pre><b>match: source repeat: anArrayOfSyntaxThings</b><comment>   "Does current source match array?"</comment><return>                     ^result].</return><comment>            "Call myself recursively."</comment><return>               ^result. </return><comment>   "If we fall through we've matched nothing"</comment><return>   ^result.</return><r>***30 lines of code ***</r></pre><pre><b>match: source sequence: anArrayOfSyntaxThings</b><comment>   "Does current source match array?"</comment><return>   ^result.</return></pre><pre><b>match: source sequence: anArrayOfSyntaxThings produce: productionBlock</b><comment>   "Does current source match array? If so, run the production."</comment><return>   ^result.</return></pre><pre><b>match: aString with: syntaxThing </b><comment>   "Does aString match with syntaxThing?"</comment><return>   ^result.</return></pre><pre><b>noun: source </b><comment>   "Match that part of the string that might name a Hum noun"</comment><comment>               "A Hum noun must start with a letter."</comment><comment>               "A Hum noun must be more than a single letter."</comment><return>               ^result</return><return>   ^result.</return></pre><pre><b>ontology: aHumOntology blackBoard: aBlackBoard produceView: aViewName </b><comment>   "Produce the HTML for the given view frame."</comment><comment>   "Set up an indepent parser so that we don't interfere with caller."</comment><comment>   "Pass the view name through -- is also default entity-name."</comment><return>   ^code := parser generatedCode .</return><r>***22 lines of code ***</r></pre><pre><b>ontology: aHumOntology isAttribute: aSource </b><comment>   "Does the current source, upto some delimiter, match an ontology attribute name?"</comment><comment>   "An attribute name must be alphanumeric"</comment><return>   ^result.</return></pre><pre><b>ontology: aHumOntology isCategory: aSource </b><comment>   "Does the current source, upto some delimiter, match an ontology category name?"</comment><comment>   "A category name must be alphanumeric"</comment><return>   ^result.</return></pre><pre><b>ontology: aHumOntology isEntity: aSource </b><comment>   "Does the current source, upto some delimiter, match an ontology entity name?"</comment><comment>   "An entity name must be alphanumeric"</comment><return>   ^result.</return></pre><pre><b>ontology: aHumOntology isViewName: aSource </b><comment>   "Does the current source, upto some delimiter, match an ontology view name?"</comment><comment>   "a view name must be alphanumeric"</comment><return>   ^result.</return></pre><pre><b>ontology: aHumOntology isViewName: aSource produce: productionBlock </b><comment>   "Does the current source, upto some delimiter, match an ontology view name? </comment><comment>   "a view name must be alphanumeric"</comment><return>   ^result.</return></pre><pre><b>ontology: aHumOntology produceView: aViewName </b><comment>   "Produce the HTML for the given view frame."</comment><comment>   "Set up an indepent parser so that we don't interfere with caller."</comment><return>   ^code := parser generatedCode .</return></pre><pre><b>pop: aSmallInteger </b></pre><pre><b>push: aString </b><return>   ^aString</return></pre><pre><b>pushIgnore: aString </b><return>   ^aString</return></pre><pre><b>radioButton: aSource produce: aProductionBlock</b><comment>   "Does the current source start with a radio button widget?"</comment><comment>         "A radio button must contain a single letter. </comment></pre><pre><b>spaces: source </b><comment>   "Match leading part of source that is digits"</comment><return>   ^result.</return></pre><pre><b>stack</b><return>   ^stack ifNil: [ stack := OrderedCollection new.]</return></pre><pre><b>text: aString </b><comment>   "Return that part of string that contains no mark-up."</comment><comment>         "Terminate on any character that indicates emphasis or widget."</comment><return>   ^self push: result.</return></pre><pre><b>top</b><return>   ^item.</return></pre><pre><b>url: source</b><comment>   "Does current source match a URL pattern?"</comment><comment>   "Note: Calling trimBoth above might accidentally clean up a bad URL."</comment><return>   ^result.</return></pre><hr/><h3>Hum-Language -- HumStatement</h3><pre><b>= aStatement </b><return>   ^self halt.</return></pre><pre><b>asCamelCase </b><comment>   "Convert this statement to camelCase."</comment><comment>  "Do not inlude articles in the camel case."</comment><return>   ^code</return></pre><pre><b>asCamelCaseWithOntology: aHumOntology </b><comment>   "Convert this statement to camelCase."</comment><todo>   "TODO: Deal with polymorphism by looking up the proper definition.</todo><comment>   "</comment><return>   ^code</return></pre><pre><b>asString</b><return>   ^ self source asString.</return></pre><pre><b>delegateToTranslator</b></pre><pre><b>errors</b><return>   ^errors ifNil: [ errors := Set new.].</return></pre><pre><b>hash </b><comment>   "This HACK (which may be a bad idea) makes HumStatement hash the same as a matching string.</comment><comment>   "</comment><return>   ^ ( source hash ).</return></pre><pre><b>isConditional</b><return>   ^false.   </return></pre><pre><b>isSatisfied: aBoolean </b></pre><pre><b>matchesCandidateStatement: aCandidate inOntology: aHumOntology</b><comment>   "Does the candidate match me? (Candidate nouns might be subtypes of my nouns.)"</comment><comment>   "Get tokens minus articles."</comment><todo>   "TODO: Parse allowing for quoted strings."</todo><comment>   "Is my noun a supertype of the argument`s noun?"</comment><todo>                  "TODO: A series of nouns (example: entity attribute attribute) matches a single noun. "   </todo><return>   ^ true.   </return><r>***34 lines of code ***</r></pre><pre><b>matchesTemplateStatement: aStatementTemplate inOntology: aHumOntology </b><comment>   "Do I match the given template? (My nouns may be subtypes of template nouns)"</comment><comment>   "First try a shortcut."</comment><comment>   "Get tokens minus articles."</comment><todo>   "TODO: Parse statements containing quoted strings."   </todo><comment>   "Is each template noun a supertype of my noun?"</comment><todo>                  "TODO: A series of nouns (example: entity attribute attribute) matches a single noun. "   </todo><return>   ^ true.   </return><r>***30 lines of code ***</r></pre><pre><b>noun: aNoun value: aValueObject </b><comment>   "Noun values are set at run-time just prior to executing the statement.</comment><comment>   "</comment><r>***24 lines of code ***</r></pre><pre><b>nounAsCamelCase: aString </b><comment>   "Delegate to ontology class"</comment><return>   ^ HumOntology nounAsCamelCase: aString.</return></pre><pre><b>nounValues</b><comment>   "Noun values are set at run-time. </comment><comment>   "</comment><return>   ^ nounValues ifNil: [ nounValues := Dictionary new.].</return></pre><pre><b>onMatch: aPatternString do: aBlockClosure </b><comment>   "When my source matches pattern, execute the block with matching arguments.</comment></pre><pre><b>printOn: aStream</b><comment>   "Append to the argument, aStream, a sequence of characters that  </comment><comment>      "nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);"</comment></pre><pre><b>role</b><return>   ^role ifNil: [ Error signal: 'role was not set in HumStatement']</return></pre><pre><b>role: aString</b><comment>   "What role is meant to execute this statement?</comment><comment>   "</comment></pre><pre><b>sameAs: aHumStatement </b><comment>   "Return true if receiver is semantically equivalent to (argument) aHumStatement."</comment><todo>   "TODO: Allow variations in use of 'a' 'an' 'the'.   "   </todo><todo>   "TODO: Allow a cascade of nouns. (example: entity attribute-entity attribute-entity attribute)"</todo></pre><pre><b>source</b><return>   ^ source</return></pre><pre><b>source: aSource</b><comment>      "Set and check the source string."</comment><comment>   "Remember my source string."</comment><comment>   "Reset errors."</comment><comment>   "self stripLeader." "Leader is a UI artifact. Not really part of the source."</comment><comment>   "Syntax check: A statement ends with a period or a colon."</comment><comment>   "Last character was not a period or colon."</comment><r>***27 lines of code ***</r></pre><pre><b>stripRole</b><comment>   "Source should not contain a role prefix in this context.</comment><comment>   "Note: Preserve uppercase in tokens so that first word of a sentence is capitalized."</comment><comment>            "role := tokens at: 1.</comment></pre><pre><b>syntaxError: anErrorMessage </b><comment>   "Error signal: anErrorMessage."</comment></pre><pre><b>tokens</b><comment>   "Return the tokens in the statement as an array of strings."</comment><comment>   "WARNING: Hum has a quirk: Accent (`) is used as apostrophe. </comment><return>   ^tokens.</return></pre><pre><b>translation</b><comment>   "How might the statement be translated into another programming language?"</comment><return>   ^translation</return></pre><pre><b>translation: aString </b><comment>   "How might the statement be translated into another programming language?"</comment></pre><hr/><h3>Hum-Language -- HumVignettePatternLine</h3><pre><b>checkSyntaxWithOntology: aHumOntology</b><todo>   "TODO: Look for [noun]. Is the noun defined in the ontology?"</todo><return>   ^ OrderedCollection new.</return></pre><hr/><h3>Hum-Language -- HumVignetteResponseLine</h3><pre><b>checkSyntaxWithOntology: aHumOntology</b><todo>   "TODO: Look for [noun]. Is the noun defined in the ontology?"</todo><return>   ^ OrderedCollection new.</return></pre><hr/><hr/><h2>Hum-RunTime</h2><hr/><h3>Hum-RunTime -- HumActor</h3><pre><b>blackboard</b><return>   ^ blackboard ifNil: [ blackboard := HumBlackBoard new. ].</return></pre><pre><b>blackboard: aHumBlackBoard </b></pre><pre><b>checkIn</b><comment>   "First, check-in with the messenger."</comment><todo>   "TODO: REFACTOR THIS CALL.  ---  Why? Why? "</todo><comment>   "Don't check-in with self."</comment><comment>   "Coordinator is not dispatched by Dispatcher"</comment><comment>   "Allow Dialog Agents to be dispatched for Push messages."</comment><comment>   "We don't expect Scribes here. </comment><comment>   "Send check-in message to my Dispatcher."</comment><r>***35 lines of code ***</r></pre><pre><b>checkOut</b><comment>   "Tell the Dispather that this actor is no longer available for assignments."</comment><comment>   "Don't check-in with self."</comment><comment>   "Coordinator is not dispatched by Dispatcher"</comment><comment>   "Send check-out message to my Dispatcher."</comment></pre><pre><b>completedAction: anAction inRole: aRoleString onJob: aHumJobTicket </b><comment>   "Following is first-cut direct call.</comment><comment>   "</comment><todo>   "TODO: Refactor above - It is using the messengers back door and is only valid in test mode."</todo></pre><pre><b>completedInstruction: aHumInstructionLine inRole: aRoleString onJob: aHumJobTicket </b><comment>   "Following is first-cut direct call.</comment><comment>   "</comment><todo>   "TODO: Refactor above - It is using the messengers back door and is only valid in test mode."</todo></pre><pre><b>delegateAction: anAction toRole: aRole onJob: aJobTicket</b><comment>   "Delegate action to another role."</comment></pre><pre><b>dispatcherID</b><return>   ^self configuration dispatcherID.</return></pre><pre><b>ontology</b><return>   ^self configuration ontology.</return></pre><pre><b>roles</b><return>   ^roles ifNil: [ roles := { self class name. }].</return></pre><pre><b>roles: anArray </b></pre><pre><b>runAction: anAction inRole: aRole onJob: aHumJobTicket</b><comment>   "Run the action frame named ..." </comment><todo>   "TODO: Ontology has instruction sequence, but lacks frame lines."</todo><comment>   "Tell Dispatcher that we completed action normally."</comment></pre><pre><b>runInstruction: anInstruction inRole: aRole onJob: aJobTicket</b><comment>   "Execute, simulate, or log the given statement"</comment><comment>   "If instruction role is not one of my roles, delegate the instruction."</comment><comment>   "If statement has a translation (assume Smalltalk), run the translation."      </comment><comment>         "Charge to job ticket"   </comment><comment>         "Tell Dispatcher that we completed action normally."</comment><return>         ^self.</return><comment>         "Append to log"</comment><comment>            "Charge to job ticket"   </comment><return>         ^ self.</return><r>***36 lines of code ***</r></pre><pre><b>updateBlackBoardFromBlackBoard: aHumBlackBoard </b><comment>   "Update my blackboard with entries from callers blackboard."</comment><comment>   "Delegate this to Blackboard. Note: Subtypes might want to override."</comment></pre><pre><b>zrunInstruction: anInstruction inRole: aRole onJob: aJobTicket</b><comment>   "Execute, simulate, or log the given statement"</comment><comment>   "If instruction role is not one of my roles, delegate the instruction."</comment><comment>   "If statement has a translation (assume Smalltalk), run the translation."      </comment><comment>         "Charge to job ticket"   </comment><comment>         "Tell Dispatcher that we completed action normally."</comment><return>         ^self.</return><comment>         "Append to log"</comment><comment>         "Charge to job ticket"   </comment><return>         ^ self.</return><r>***32 lines of code ***</r></pre><hr/><h3>Hum-RunTime -- HumBase</h3><pre><b>entitiesOfType</b><return>   ^ entitiesOfType ifNil: [ entitiesOfType := Dictionary new ].</return></pre><pre><b>entitiesWithValue</b><comment>   "A dictionary of sets. The set of entities with the given { attribute value }."</comment><return>   ^ entitiesWithValue ifNil: [ entitiesWithValue := Dictionary new].</return></pre><pre><b>entityAttributeValue</b><comment>   "A dictionary holding a temporal stack of {value event} for each {entity attribute}.</comment><return>   ^ entityAttributeValue ifNil: [ entityAttributeValue := Dictionary new ].</return></pre><pre><b>entityID: anID entityType: aType attribute: anAttribute value: aValue event: anEvent</b><comment>   "Create a record of entity-attribute-value from event."</comment><comment>   "Add entity to set of that type."</comment><comment>   "ASSUMED: The entity does not change type over time."</comment><comment>   "Add entity to index by value."</comment><todo>   "TODO: entitiesWithValue is meant to be current value. We need to remove old entry, if any."</todo><comment>   "Add record."</comment><comment>   "( self entityAttributeValue ) at: { anID. anAttribute. } put: { aValue. anEvent. }."</comment></pre><pre><b>eventWho: aWho what: aWhat where: aWhere why: aWhy </b><comment>   "when := yyyy*1e4+mo*1e2+day*1e2+hh*1e2+mm*1e2+ss*1e12+nn."</comment><return>   ^eventID.</return><r>***21 lines of code ***</r></pre><pre><b>events</b><return>   ^ events ifNil: [ events := Dictionary new].</return></pre><pre><b>findEntitiesOfType: anEntityType </b><return>   ^setOfEntities.</return></pre><pre><b>findEntitiesWhereAttribute: anAttributeType satisfies: aBlockClosure </b><comment>   "Get collections of entities where current attribute value satisfies condition"</comment><return>   ^setOfEntities.   </return></pre><pre><b>getEntityID: anEntityID attribute: anAttributeType </b><comment>   "Get the current value for given entityID attributeType"</comment><return>   ^result.</return></pre><pre><b>insert: anItem at: aKey into: aDictionaryOfSets</b><comment>   "Insert the item into a set at the given key."</comment><comment>   "Add entity to set associated with that key."</comment></pre><pre><b>push: anItem at: aKey onto: aDictionaryOfStacks</b><comment>   "Insert the item into a list at the given key."</comment><comment>   "Add entity to list of that type."</comment></pre><pre><b>remove: anEntityID at: aKey from: aDictionaryOfSets </b><comment>   "Remove the entityID from the set associated with the key."</comment></pre><hr/><h3>Hum-RunTime -- HumBlackBoard</h3><pre><b>appendEntity: childEntityID toEntity: parentEntityID list: anAttributeName </b><comment>   "Append the given child entity to the named list attribute"</comment></pre><pre><b>businessEvent</b><comment>   "What business event is in progress?"</comment><return>   ^businessEvent ifNil: [Error signal: 'event not set']</return></pre><pre><b>businessEvent: aString</b><comment>   "What business event is in progress?"</comment><todo>   "TODO: We need a stronger (W5) business-event representation."</todo><todo>   "TODO: Create a Business Event class with W5 (who, what, when, where, why) attributes."</todo><return>   ^businessEvent := aString</return></pre><pre><b>cleanAttribute: anAttributeNameString </b><return>   ^result.</return></pre><pre><b>cleanEntity: anEntityTypeString </b><comment>   "Assure that the type-name is properly-trimmed, lowercase string"</comment><return>   ^result.</return></pre><pre><b>clearEntity: anEntityType </b><comment>   "Clear all data for the given entity-name / entity-type."</comment><comment>   "REFACTOR/RETHINK: The BlackBoard seems to be built for single instances of an entity-type."</comment><todo>   "TODO: Think about the interaction between business roles, views, and persistence."</todo><comment>   "Hum`s general rule is 'Persist everthing, then add purge rules.'"</comment><comment>   "REFACTOR/RETHINK: The WorldBase should check for valid ID (defensive code). "</comment><comment>   "Why? - Because an long-running dialog may have already created an entity of this type,</comment><comment>   "(cleanName = 'topic') ifTrue: [self halt.]."</comment><comment>   "At this point, quadsToBe has no data associated with the entity-type."</comment><r>***29 lines of code ***</r></pre><pre><b>entityIdentifiers</b><comment>   "What identifier is associated with a entity type noun (entity name)?"</comment><return>   ^ entityIdentifiers ifNil: [entityIdentifiers := Dictionary new].</return></pre><pre><b>generateNewIdentifierForEntityName: anEntityName</b><comment>   "Create a unique identifier for an instance of the given entity-name noun."</comment><return>   ^id.</return></pre><pre><b>getEntityID: entityID attribute: anAttributeName </b><comment>   " Get requested value (if any) from the blackboard instance "</comment><todo>   "ToDo: If I don't have it, maybe WorldBase does. "</todo><todo>   "TODO: If the entity-attribute-value is updated in the worldbase, are the Blackboards notified?  If so, how?"</todo><return>   ^ value.</return></pre><pre><b>getEntityName: anEntityName attribute: anAttributeName </b><comment>   "Get the entityID for that entity-name and fetch the requested attribute."</comment><return>   ^value.</return></pre><pre><b>identifierForEntityName: anEntityName </b><comment>   "Do I already have an entity of that name? </comment><return>   ^id.</return></pre><pre><b>makeEntityOfType: anEntityType </b><comment>   "Add a new entity ID for the given entity type. (entity name)."</comment><comment>   "Generally invoked via 'New entityType.' in a dialog vignette. "</comment><comment>   "NOTE: If dialog blackboard already contains an entity of this type, it is no longer accessable."</comment></pre><pre><b>quads</b><comment>   "a dictionary of { aValue. tau. } keyed by ( entityID -&gt; attribute )"</comment><return>   ^ quads ifNil: [ quads := Dictionary new. ].</return></pre><pre><b>setEntityID: entityID attribute: anAttributeName toValue: aValue</b><comment>   "Store given value in the blackboard with a time-stamp. </comment><comment>   "Put value of entity attribute and the timestamp."</comment><comment>   "Update the world base also."</comment><comment>   "NOTE: Mutation in the world-base is treated via versioning."</comment><todo>   "TODO: Blackboard detects mutations ? -- And then what?"</todo><todo>   "TODO: Code critic flags mutation as Error?"</todo><comment>   "COMMENT: Mutation in a business-entity is mainly a danger when a natural-key is mutated."</comment><r>***24 lines of code ***</r></pre><pre><b>setEntityName: anEntityName attribute: anAttributeName toValue: aValue</b><comment>   "for now -- same as:"</comment><comment>   "Do I already have an entity of that name? </comment><return>         ^self.</return><r>***21 lines of code ***</r></pre><pre><b>updateBlackBoardFromBlackBoard: aHumBlackBoard </b><comment>   "Update myself from entries in the other blackboard."</comment><comment>   "Assume that caller is not sharing this blackboard."</comment><comment>   "Interpret caller quads"</comment><comment>            "Parse dictionary key - it is a map of the form: (entitID -&gt; attributeType)"</comment><comment>            "Parse dictionary value - It is a tuple of the form: { value. tau. }"</comment><comment>            "tau := value at: 2."</comment><comment>            "Update myself -- Note: I will generate my own tau."</comment><r>***25 lines of code ***</r></pre><pre><b>worldbase</b><return>   ^ worldbase ifNil: [Error signal: 'Blackboard configured without a world base.']</return></pre><pre><b>worldbase: aHumWorldBase </b></pre><hr/><h3>Hum-RunTime -- HumBookkeeper</h3><pre><b>chargesBy: attribute</b><comment>   "Produce dictionary of sums for given subdivision type."</comment><return>      ^sums.</return><r>***22 lines of code ***</r></pre><pre><b>chargesByAction</b><comment>   "Produce dictionary of sums keyed by action."</comment><return>   ^sums.</return></pre><pre><b>chargesByActor</b><comment>   "Produce dictionary of sums keyed by actor."</comment><return>      ^sums.</return></pre><pre><b>chargesByJob</b><comment>   "Produce dictionary of sums keyed by job."</comment><return>   ^sums.</return></pre><pre><b>chargesByMetric</b><comment>   "Produce dictionary of sums keyed by unit of measure. "</comment><return>      ^sums.</return><r>***21 lines of code ***</r></pre><pre><b>chargesByRole</b><comment>   "Produce dictionary of sums keyed by role-name.."</comment><return>   ^sums.</return></pre><pre><b>jobTickets</b><return>   ^ jobTickets ifNil: [ jobTickets := OrderedCollection new. ].</return></pre><pre><b>recordJobTicket: aHumJobTicket </b><comment>   "Add the given job ticket to my collection of job tickets."</comment></pre><hr/><h3>Hum-RunTime -- HumBusinessEvent</h3><pre><b>what: aString</b><comment>   "What is the cause/actor doing in the business event?"</comment></pre><pre><b>when: aTimeStamp</b><comment>   "When (at what date-time) is business event happening?"</comment></pre><pre><b>where: aString</b><comment>   "Where (at what location/context) is business event happening?"</comment></pre><pre><b>who: aString</b><comment>   "Who is the cause/actor in the business event"</comment></pre><pre><b>who: aWho what: aWhat when: aTimeStamp where: aWhere why: aJobTicket</b><comment>   "Set the business event attributes."</comment></pre><pre><b>why: aJobTicket</b><comment>   "Why (job-ticket) is business event happening?"</comment></pre><hr/><h3>Hum-RunTime -- HumCalculator</h3><pre><b>cases</b><comment>   "Initialize case cascade.</comment><comment>      "</comment></pre><pre><b>doTokensIn: input at: xInput matchPatternTokensIn: pattern at: xPattern</b><return>   ^result.</return></pre><pre><b>exdent</b><comment>   "Remove a tab from the global indent string."</comment></pre><pre><b>fillTemplate: template fromDictionary: dictionary</b><comment>   "Create a String based on the given template and parameters."</comment><comment>         "Get and remove the name of the parameter"</comment><comment>         "Insert the value of the parameter"</comment><return>   ^result.</return></pre><pre><b>given: sourceString extractAfter: stringA </b><comment>   "Return the substring in the sourceString between the two."</comment><return>   ^result.</return></pre><pre><b>given: input extractAfterSecond: marker </b><comment>   "Parse cases like matching quotes or markup emphasis."</comment><return>   ^result.</return></pre><pre><b>given: sourceString extractBetween: stringA and: stringB</b><comment>   "Return the substring in the sourceString between the two."</comment><return>   ^result.</return></pre><pre><b>given: sourceString extractUpto: stringA </b><comment>   "Return the substring in the sourceString between the two."</comment><return>   ^result.</return></pre><pre><b>given: inputString onMatch: aPatternString do: aBlockClosure </b><comment>   "When the inputString matches pattern, execute the block with matching arguments.</comment></pre><pre><b>given: input replaceAll: old with: new </b><return>   ^result. </return></pre><pre><b>given: s topic: aTopic doOnce: aBlock</b><comment>   "Use this to produce subheadings."</comment></pre><pre><b>indent</b><comment>   "Append a tab to the global indent string."</comment></pre><pre><b>indentLevel: n </b><comment>   "Reset the indent level. Produce indent string (tabs)."</comment></pre><pre><b>initialize</b></pre><pre><b>justTheWordsIn: aString</b><return>   ^self class justTheWordsIn: aString.</return></pre><pre><b>on: aValue do: aBlockClosure </b></pre><pre><b>otherwise: thenBlock</b><comment>   "If a prior case was true, ignore this case. </comment><comment>   "otherwise"</comment><return>   ^self.</return></pre><pre><b>parse: aString</b><comment>   "Parse into { token. type. start. stop. }"</comment><return>   ^sequence.</return></pre><pre><b>priorCaseIsTrue</b><return>   ^ priorCaseIsTrue ifNil: [priorCaseIsTrue := false ].</return></pre><pre><b>scoreCandidate: candidateString againstPattern: patternString</b><comment>   "Return a score indicating the number of tokens that match." </comment><comment>   "Parse."</comment><return>   ^commonTokens size.</return></pre><pre><b>string: stringA isLike: stringB </b><comment>   "Compare ignoring differences in whitespace."</comment><return>   ^self class string: stringA isLike: stringB. </return></pre><pre><b>string: aString isLike: aString2 ignore: aString3 </b><return>   ^self class string: aString isLike: aString2 ignore: aString3.</return></pre><pre><b>switch: aCharacter </b></pre><pre><b>testValue: anObject </b></pre><pre><b>when: whenBlock then: thenBlock</b><comment>   "If the whenBlock evaluated to true, execute the thenBlock."</comment><comment>   "If a prior case was true, ignore this case."   </comment><comment>   "If the when block is true"</comment><return>   ^self.</return></pre><pre><b>xml: aTagString dictionary: aDictionaryOrList </b><comment>   "Create a stand-alone tag (ending with '/&gt;') with the given attribute values."</comment><comment>   "Don not mess with indent here. Caller should handle."</comment><return>   ^xml.</return></pre><pre><b>xml: aTagString dictionary: aDictionary with: aBlockClosure </b><comment>   "Generate the front tag and the end tag with block to produce the middle"</comment><comment>   "Restore prior indent"</comment><return>   ^xml.</return></pre><pre><b>xml: tagString list: anArray </b><comment>   "Iterate: Enclose each item with given tagString"</comment><return>   ^result.</return></pre><pre><b>xml: aTag with: aBlock </b><comment>   "Fix up the indent after we get this working."</comment><comment>   "Restore prior indent."</comment><return>   ^xml.</return></pre><pre><b>xmlOpen: aTagString dictionary: aDictionary </b><comment>   "Create an opening tag ( NOT ending with '/&gt;' ) with the given attribute values."</comment><return>   ^xml.</return></pre><hr/><h3>Hum-RunTime -- HumConfiguration</h3><pre><b>bookkeeperID</b><return>   ^ bookkeeperID</return></pre><pre><b>bookkeeperID: anObject</b></pre><pre><b>clock</b><comment>   "What object is providing time-keeping?"</comment><return>   ^ clock ifNil: [clock := HTime "class singleton"].</return></pre><pre><b>clock: anObjectThatImplementsNow</b><comment>   "Clock must be an object that imlements &gt;&gt;now as a number of seconds (an Integer)."</comment></pre><pre><b>configuration: aHumConfiguration </b><comment>   "Copy configuration."</comment></pre><pre><b>debug</b><comment>   "Am I in debug mode?"</comment><return>   ^ debug ifNil: [debug := false].</return></pre><pre><b>dispatcherID</b><return>   ^ dispatcherID ifNil: [ Error signal: 'A configuration must have a Dispatcher.' ].</return></pre><pre><b>dispatcherID: anObject</b></pre><pre><b>getWorldBase</b><comment>   "Get this configuration`s worldbase instance."</comment><return>   ^worldbaseInstance.</return></pre><pre><b>isTest</b><comment>  "Are we running in TEST mode?"</comment><return>   ^isTest ifNil: [ isTest := true. ].</return></pre><pre><b>isTest: aBoolean</b><comment>   "Are we running in TEST mode?"</comment></pre><pre><b>messenger</b><return>   ^ messengerProxy </return></pre><pre><b>messenger: aHumMessenger</b><comment>   "Set the messenger -- Use to configure mocks when needed."</comment></pre><pre><b>messengerID</b><return>   ^ messengerID</return></pre><pre><b>messengerID: aString</b></pre><pre><b>messengerID: idMessenger dispatcherID: idDispatcher bookkeeperID: idBookkeeper worldbaseID: idWorldbase</b><comment>   "WARNING: I am not sure this is a good idea."</comment></pre><pre><b>now</b><comment>   "What time is it in configured world (may be simulation)?"</comment><return>   ^ clock now.</return></pre><pre><b>ontology</b><return>   ^ ontology ifNil: [ Error signal: 'ontology is missing from configuration'].</return><todo>   "TODO: Perhaps we should return HumOntology baseOntology instead."</todo></pre><pre><b>ontology: aHumOntology </b></pre><pre><b>openWorldBase</b><comment>   "Create world base instance and register with messenger."</comment><return>   ^worldbaseInstance.</return></pre><pre><b>worldbaseID</b><return>   ^ worldbaseID</return></pre><pre><b>worldbaseID: anObject</b></pre><hr/><h3>Hum-RunTime -- HumCoordinator</h3><pre><b>conditionIsSatisfied: precondition </b><comment>   "Note that condition is satisfied.</comment><comment>   "</comment></pre><pre><b>context: aHumActor</b></pre><pre><b>coordinatorID: anID uri: aURI goal: aGoalStatementString dialog: aHumDialogAgent configuration: aHumConfiguration</b><return>   ^self.</return></pre><pre><b>dialogAgent: aHumDialogAgent </b><comment>   "Concept: The dialog agent provides noun values </comment></pre><pre><b>getActionSequence</b><comment>   "Parse the job ticket to show the sequence of actions."</comment><return>   ^listOfActions.</return></pre><pre><b>goal: aStatement</b><return>         ^self.</return></pre><pre><b>goalStatement</b><comment>   "Translate goal string to goal statement"</comment><todo>   "TODO: THERE IS SOMETHING WRONG HERE."</todo><return>   ^ statement. </return></pre><pre><b>isPlanFrameRunnable: aHumFrame4Plan</b><comment>   "Determine if the given plan frame is runnable.</comment><comment>   " </comment><return>      ^true</return></pre><pre><b>jobTicket</b><return>   ^ jobTicket ifNil: [ jobTicket := HumJobTicket title: goal ].</return></pre><pre><b>planIsRunnable</b><todo>   "TODO: ADD NEEDED CHECKS TO THIS STUB."</todo><comment>   "   </comment><comment>   "</comment><todo>   "TODO: DANGER -- THIS IS A STUB!!!"</todo><return>   ^true.</return></pre><pre><b>remainingConditions</b><return>   ^ remainingConditions ifNil: [ remainingConditions := Set new.] .</return></pre><pre><b>runAction: anInstructionLine </b><comment>   "Run the given action statement."</comment><todo>   "TODO: Track work-in-progress so that run-time instrumentation can view."</todo></pre><pre><b>runPlan</b><comment>   "Run my plan.</comment><comment>   "</comment></pre><pre><b>runPlanFrameForCondition: aGoalString</b><comment>   "This visits the subtree and runs each frame that is ready to run.</comment><comment>   "</comment><comment>   "If the condition is already satisfied (not in remainingConditions set), we can skip and return immediately."</comment><comment>   "Get the root of this subtree."</comment><comment>   "REFACTOR: The rootFrame does not know if it is runnable. But the Coordinator knows."</comment><comment>         "Run actions"</comment><comment>         "Declare goal satisfied"</comment><return>         ^true.    "Indicates something was runnable. See check below."</return><comment>                  "Call recursively on preconditions."</comment><comment>               "Check post condition </comment><comment>      "Fall through to here when goal frame is not runnable and we ran preconditions.</comment><comment>            "In this context,</comment><return>      ^result.</return><r>***48 lines of code ***</r></pre><pre><b>runPlanSetup</b><comment>   "Setup to run a plan:</comment><comment>   "</comment><comment>  "Populate the remaining conditions collection"</comment><r>***21 lines of code ***</r></pre><hr/><h3>Hum-RunTime -- HumDecimal</h3><pre><b>fromString: aString</b><comment>   "Count the digits in the string to estimate accuracy."</comment></pre><pre><b>nDecimal</b><comment>   "How many decimal places should we display."</comment><return>   ^nDecimal ifNil: [ 0 ].</return></pre><pre><b>nDecimal: anInteger </b><comment>   "How many decimal places should we display."</comment></pre><pre><b>printOn: aStream</b></pre><hr/><h3>Hum-RunTime -- HumDialogAgent</h3><pre><b>askView: aViewName</b><comment>   "Delegate display to my scribe."</comment></pre><pre><b>buildDialogAgentOntology</b><comment>   "Return ontology with Dialog Agent actions defined and executable in Smalltalk."</comment><return>   ^ontology. </return></pre><pre><b>clearEntity: entityType</b><comment>   "Clear prior data in my blackboard for the given entity type."</comment><comment>   "WARNING: Assumes dialogs vignettes only address one instance of an entity at a time."</comment><todo>   "TODO: I think there is a UX problem here. This behavior may confuse users."</todo><comment>   "PROBLE: It makes no sense to clear a real-world entity. </comment></pre><pre><b>client: aString </b></pre><pre><b>clientSays: aString </b><comment>   "Match user utterance to vignette patterns in the ontology</comment><comment>   "</comment><comment>   "We need a context stack to define the best match."</comment><comment>   "Delegate the search to the ontology."</comment><todo>   "TODO: Now that I've got a vignette (or not), what do I do with it?"</todo><todo>   "TODO: We need a stronger (W5: who, what, when, where, why) business-event representation."</todo><comment>   "who = clientID, what = says: ___, when = date-stamp, where = dialog, why = vignette"</comment><comment>   "*** Return vignette for DEBUG? *** "</comment><todo>   "TODO: THINK -- Should test cases examine my step log instead?"</todo><return>   ^ bestMatch.</return><r>***22 lines of code ***</r></pre><pre><b>contextStack</b><return>   ^ contextStack ifNil: [ contextStack := Stack new. self pushContext: 'Start.'. contextStack ].</return></pre><pre><b>dialogAgentOntology</b><comment>   "Return ontology with Dialog Agent actions defined and executable in Smalltalk."</comment><return>   ^ dialogAgentOntology ifNil: [dialogAgentOntology := self buildDialogAgentOntology].</return></pre><pre><b>dialogOntologySourceStream</b><comment>   "Return a stream of frames defining Dialog Agent actions."</comment><return>   ^stream.</return><r>***24 lines of code ***</r></pre><pre><b>extractFieldValuesFromUserInput: inputString pattern: patternString </b><comment>   "Extract values from user input and post to my blackboard. </comment><comment>   "</comment><r>***44 lines of code ***</r></pre><pre><b>fillInSlotIn: aMarkupString </b><comment>   " Fill-in first [entity attribute] dialog-response-slot with data from blackboard.</comment><comment>   "</comment><comment>   "Break the field name into entityName and attributeType."</comment><comment>   "Insert field-value into markup string."</comment><return>   ^result.</return></pre><pre><b>interpretVignette: aHumFrame4Vignette withInput: aUserInput</b><comment>   "Send response lines. Execute response instructions."</comment><comment>   "Extract any values in user input and update blackboard.</comment><comment>   "Interpret the response lines (fill in any value slots as needed)."</comment><comment>         "Interpret markup."</comment><comment>   "If there are no instructions in the response, we are done."   </comment><todo>   "TODO: What is the rationale for job-ticket in this context?"   </todo><comment>   "Interpret any instructions found in the response."</comment><r>***51 lines of code ***</r></pre><pre><b>newEntity: anEntityType </b><comment>   "Create a new entity to be associated with the given entity-type/entity-name."</comment><todo>   "TODO: If the blackboard already contains and entity of that type, </todo><todo>   "TODO: Think about the interaction between business process roles, entity-type, and views."</todo><comment>   "Advice: New business entities are created in the blackboard when a dialog requires them.</comment><comment>   "</comment></pre><pre><b>pushContext: aString </b></pre><pre><b>runAction: anAction inRole: aRole onJob: aHumJobTicket</b><comment>   "Dialog Agent knows: 'Ask view', 'Show view', 'Push context ...'" </comment><todo>      "TODO: Give some thought to the interaction of business process roles and views."</todo><r>***28 lines of code ***</r></pre><pre><b>sayToClient: aHumMarkupLine </b><comment>   "Say something to the client. </comment><comment>   "Delegate actual UI to my Scribe."</comment></pre><pre><b>scribeProxy</b><comment>   "Return an instance that understands #systemSays:</comment><comment>   "</comment><return>   ^scribeProxy </return></pre><pre><b>showView: aViewName</b><comment>   "Delegate display to my scribe."</comment></pre><hr/><h3>Hum-RunTime -- HumDispatcher</h3><pre><b>actor: anActor completedAction: aHumStatement</b><comment>   "Dispatcher is informed that the actor completed the assigned action.</comment><comment>   "</comment><comment>   "Send charges to bookkeeper."</comment><comment>   "For now, just call direct.</comment><comment>   "</comment><todo>   "TODO: Refactor this. It is by-passing the messenger."</todo></pre><pre><b>assignAction: aHumInstructionLine toRole: aByteString forJob: aHumJobTicket </b></pre><pre><b>assignRole: roleString action: actionInstruction </b><comment>   "Assign the given action to an actor advertising the given role."</comment><comment>   "Find an actor that knows the role."</comment><comment>   "Filter potential actors to include only available actors."</comment><comment>   "Assign an actor at random."</comment><comment>   "Send the action to the actor."</comment><comment>   "Simulating asynch: </comment><r>***31 lines of code ***</r></pre><pre><b>availableActors</b><return>   ^ availableActors ifNil: [ availableActors := Set new. ].</return></pre><pre><b>busyActors</b><return>   ^ busyActors ifNil: [ busyActors := Set new ].</return></pre><pre><b>checkInActor: actorID at: aURI withRoles: actorKnowsRoles </b><comment>   "The Dispatcher should delegate finding the URI to messenger."</comment><comment>   "For each actor role: </comment></pre><pre><b>checkOutActor: anActorID at: anActorURI </b><comment>   "Actor is no longer available for assignments."</comment><comment>   "Remove the actor from role-&gt;actor map."</comment><comment>   "Remove the actor from the available actor list."</comment><comment>   "Assume actor will not check-out with work in progress.</comment><comment>   "</comment><return>   ^self.</return></pre><pre><b>roleActor</b><comment>   "Return the role-&gt;actor map set."</comment><return>   ^ roleActor ifNil: [ roleActor := Set new. ].</return></pre><pre><b>runAction: anAction inRole: aRole onJob: aHumJobTicket</b><comment>   "Dispatch the action to an actor in the given role." </comment><return>         ^self.</return><comment>   "Otherwise: Assign action to an actor that has registered previously with that role."   </comment></pre><pre><b>sendMessage: aMessageObject to: recipientID.</b><todo>   "TODO: HumActor does not need to know that delegating a statement is a message send.</todo><comment>   "</comment><comment>   "self checkID: recipientID."</comment></pre><hr/><h3>Hum-RunTime -- HumEntity</h3><pre><b>asString</b><return>   ^self title.</return></pre><pre><b>debug</b><comment>   "Am I in debug mode?"</comment><return>   ^ debug ifNil: [debug := false].</return></pre><pre><b>id</b><comment>   "Return a unique identifier."</comment><return>   ^ id ifNil: [ Error signal: 'Entity ID should be set by Blackboard or DialogAgent.'.</return></pre><pre><b>id: aString </b><comment>   "Set the entity`s identifier."</comment></pre><pre><b>printOn: aStream</b></pre><pre><b>title</b><comment>   "a display string describing this entity" </comment><return>   ^ title ifNil: [title := 'Unknown Entity'].</return></pre><pre><b>title: aString</b><comment>   "a display string describing this entity" </comment></pre><hr/><h3>Hum-RunTime -- HumFuzzy</h3><pre><b>* aHumFuzzy </b><return>   ^result.</return></pre><pre><b>+ aHumFuzzy </b><return>   ^result.</return></pre><pre><b>- aHumFuzzy </b><return>   ^result.</return></pre><pre><b>/ aHumFuzzy </b><return>   ^result.</return></pre><pre><b>asCrudeMorph</b><comment>      "verticle grid"</comment><comment>     "horizontal grid"</comment><comment>   "You can delete morph by double-clicking it."</comment><r>***32 lines of code ***</r></pre><pre><b>asCrudeMorph2</b><comment>   "Normalize v range to [0,100]."</comment><comment>   "Flip Y. Screen coordinates have Y pointing down."</comment><comment>   "Paint grid lines"</comment><comment>      "vertical grid"</comment><comment>     "horizontal grid"</comment><comment>   "You can delete morph by double-clicking it."</comment><r>***40 lines of code ***</r></pre><pre><b>asCrudeMorphInRectangle: aRectangle</b><comment>   "Display a plot in a Morph with the origin and extent indicated by the given Rectangle."</comment><comment>   "Pixels per normalized value unit."</comment><comment>   "Normalize v range to [0,100]."</comment><comment>   "Flip Y. Screen coordinates have Y pointing down."</comment><comment>   "Paint grid lines"</comment><comment>      "vertical grid"</comment><comment>     "horizontal grid"</comment><comment>   "You can delete morph by double-clicking it."</comment><r>***44 lines of code ***</r></pre><pre><b>atP: aFloat </b><comment>   "Return the appropriate value from the distribution.</comment><comment>   "Check that aFloat is between zero and one"</comment><comment>   "Look up value or interpolate to get a result."</comment><return>   ^ result.</return></pre><pre><b>correctInterceptInDistribution: aDistribution</b><comment>   "-- Use slope-intercept to get a better estimate of the S-curve value at probability 0.</comment><comment>   "</comment><r>***25 lines of code ***</r></pre><pre><b>distribution: aDictionary </b><comment>   "Distribution is an S-curve that maps probability to value.</comment><comment>   "</comment></pre><pre><b>distributionDo: pvBlock</b><comment>   "Vist the key-&gt;value (probability-&gt;value) entries in the distribution."</comment></pre><pre><b>fromScaledDecimal: aScaledDecimal</b><comment>   "Set the distribution from the given string.</comment><comment>   "</comment><r>***22 lines of code ***</r></pre><pre><b>fromString: aString</b><comment>   "Set the distribution from the given string.</comment><comment>   "</comment></pre><pre><b>initialize</b></pre><pre><b>interpolate: aProbability</b><comment>   "Return the predicted value at aProbability using linear interpolation."</comment><comment>   "Following depends on Dictionary semantics"</comment><comment>   "Find the interval that brackets the requested point."</comment><comment>   "Do simple linear interpolation."</comment><comment>   "Check: for an S-Curve the slope is always positive."</comment><comment>   "Check: the result must be between upper and lower function values"</comment><todo>   "TODO: If we need more accuracy, use two quadratic splines.</todo><comment>   "</comment><return>   ^result.</return><r>***29 lines of code ***</r></pre><pre><b>mean</b><return>   ^result.</return></pre><pre><b>median</b><comment>   "find the point that represents the median"</comment><comment>   "Distribution is list of f-&gt;p".</comment><comment>   "Look for f@0.50"</comment><return>   ^medianPoint.</return></pre><pre><b>op: aSymbol with: aHumFuzzy</b><comment> "Add two fuzzy distibutions using Monte Carlo sampling"</comment><comment>   "Create a new distribution with points every 10%"</comment><comment>   "Note: Assertion above occasionally fails due to accidental matches in set.</comment><comment>   "self correctInterceptInDistribution: distributionC."</comment><return>   ^fuzzyC.</return><r>***39 lines of code ***</r></pre><pre><b>sampleSize: anInteger</b><comment>   "Reset the sample size used in Monte Carlo sampling of input distributions.</comment><comment>   "</comment></pre><pre><b>sampleSize: aSampleSize resultDivisions: aDivisionCount</b><comment>   "Reset the sample size used in Monte Carlo sampling of input distributions.</comment><comment>   "</comment><comment>   "The Monte Carlo will randomly sample the inputs this many times."</comment><comment>   "The resulting S-curve will have N+1 points selected from sampleSize points."</comment></pre><pre><b>sampleWithBlock: aBlock</b><comment> "Operate on fuzzy distibution using Monte Carlo sampling"</comment></pre><hr/><h3>Hum-RunTime -- HumHttpRequest</h3><pre><b>atField: aKey put: aValue</b><comment>   "The Http Request form included this input name:value pair."</comment></pre><pre><b>fields</b><return>   ^myFields ifNil: [myFields := Dictionary new.].</return></pre><hr/><h3>Hum-RunTime -- HumIdentifier</h3><pre><b>&lt; aHumIdentifier </b><return>   ^ result.</return></pre><pre><b>&lt;= aHumIdentifier </b><return>   ^ result.</return></pre><pre><b>asString</b><return>         ^(entityName asString),':',(bigNumber asString)].</return><return>   ^ (entityName asString),':',(bigNumber printStringHex).</return></pre><pre><b>entityName</b><comment>   "Return entity name -- force nil to string if needed."</comment><return>   ^ entityName asString.</return></pre><pre><b>generateForEntityName: anEntityName inContext: aBusinessEvent</b><comment>   "Make self a unique identifier for given entity context."</comment><todo>   "TODO: Think: Should the business context where the entity originates be embedded in the ID somehow ???"</todo><comment>   "Singleton holds prior values."</comment><comment>   "Post Conditions:"   </comment><comment>   "Set the singleton values."</comment><r>***27 lines of code ***</r></pre><pre><b>initialize</b><comment>   "This UUID represents the run-time. </comment></pre><pre><b>printOn: aStream</b></pre><pre><b>uuid: aUUID </b></pre><hr/><h3>Hum-RunTime -- HumJobTicket</h3><pre><b>appendCharge: aHumMeasure forAction: action byActor: anID inRole: aRoleName onJob: aJobID </b><comment>   "Use a dictionary to represent a charge."</comment><comment>   "Append this charge to ticket`s charges."   </comment><r>***22 lines of code ***</r></pre><pre><b>charges</b><return>   ^charges ifNil: [ charges := OrderedCollection new.]</return></pre><pre><b>getActionSequence</b><comment>   "Parse the job ticket to show the sequence of actions."</comment><return>   ^listOfActions.</return></pre><pre><b>printOn: aStream</b></pre><hr/><h3>Hum-RunTime -- HumMeasure</h3><pre><b>* multiplier </b><return>                     ^result.</return><return>         ^result.</return><comment>         "Increment and net-out the dimensions."</comment><return>   ^result.   </return><r>***22 lines of code ***</r></pre><pre><b>+ operand </b><comment>   "The units of measure must be the same."</comment><comment>   "Make a deep copy to get fresh dimensions and quantity."</comment><return>   ^result.   </return></pre><pre><b>- operand </b><return>   ^result.   </return></pre><pre><b>/ aDivisor </b><comment>   "If the dimensions match, the result is a ratio. But we keep it as a HumMeasure to enable cascade."</comment><comment>   "Otherwise"      </comment><comment>         "Decrement and net-out the dimensions."</comment><return>   ^result.   </return><r>***22 lines of code ***</r></pre><pre><b>&lt; operand </b><comment>   "The units of measure must be the same."</comment><return>   ^result.   </return></pre><pre><b>= operand </b><comment>   "The units of measure must be the same."</comment><return>   ^result.   </return></pre><pre><b>&gt; operand </b><comment>   "The units of measure must be the same."</comment><return>   ^result.   </return></pre><pre><b>@ aHumMeasure </b><return>   ^point.</return></pre><pre><b>abs</b><return>   ^measure.</return></pre><pre><b>adaptToCollection: aCollection andSend: aSymbol </b><return>   ^resultingCollection.</return></pre><pre><b>arcTan: aDenominator </b><comment>   "Return the arc-tangent (angle) for self divided by aDenominator"</comment><return>   ^angle.</return></pre><pre><b>as: aSymbol</b><comment>   "Convert to the unit of measure indicated by aSymbol, and renders as String"</comment><return>   ^string.</return></pre><pre><b>asFloat</b><return>   ^q.</return></pre><pre><b>asMillimeter</b><comment>   "Convert pixel dimensions to millimeter dimensions"</comment><comment>    "For convenience while debugging. Enlarge those pixels?"</comment><return>   ^result.</return></pre><pre><b>asMillimeters</b><return>   ^self asMillimeter.</return></pre><pre><b>asPercent</b><comment>   "This is valid only if given measure is dimensionless."</comment><comment>   "For this to be useful, </comment><todo>   "TODO: Consider simply returning a scalar: (^self * 0.01)"</todo><return>   ^measure.</return></pre><pre><b>asString</b><return>   ^result.</return></pre><pre><b>cos</b><return>   ^ quantity cos.</return></pre><pre><b>cubed</b><return>   ^result.</return></pre><pre><b>dimensions</b><comment>   "Tracks units and powers of units -- "</comment><return>   ^ dimensions ifNil: [ dimensions := Dictionary new.]</return></pre><pre><b>dimensions: aDictionary </b></pre><pre><b>displayUnits</b><return>   ^displayUnits.</return></pre><pre><b>incrementDimensionsAt: aUnit by: anIncrement</b><comment>   "Increment / Decrement dimension exponent by given increment (negative when decrementing).</comment><comment>   "</comment><comment>   "Remove zeroed dimensions."</comment><todo>   "TODO: THINK: This discards potentially useful information."</todo><comment>   " e.g. meter^0 indicates scale or stress or coeficient of expansion ... " </comment><todo>   "TODO: When units cancel (e.g. length/length), find some way to preserve information.</todo><comment>   "</comment></pre><pre><b>isDimensionless</b><comment>   "Is the current measure dimensionless?"</comment></pre><pre><b>isPixels</b><return>   ^result.</return></pre><pre><b>isRadian</b><return>   ^result.</return></pre><pre><b>negated</b><return>   ^result.</return></pre><pre><b>printOn: aStream</b><comment>   "Append to the argument, aStream, a sequence of characters that  </comment></pre><pre><b>quantity</b><comment>   "Return the quantity that was observed for this instance."</comment><comment>   "Raise an error if caller attempts to access without a previous set."</comment><return>   ^ quantity ifNil: [ Error signal: 'measure quantity not set.' ].</return></pre><pre><b>quantity: aNumber </b></pre><pre><b>quantity: aNumber per: denominatorUnits</b><comment>   "Set instance denominator units.</comment><comment>   "</comment></pre><pre><b>quantity: aNumber units: numeratorUnits </b><comment>   "Set instance numerator units</comment><comment>   "</comment></pre><pre><b>quantity: aNumber units: numeratorUnits per: denominatorUnits</b><comment>   "Set instance numerator and denominator units.</comment><comment>   "</comment><comment>   "Get matching numerator exponent, if any, so that we correctly handle ratios </comment><r>***26 lines of code ***</r></pre><pre><b>quantityAsString</b><comment>   "Return the quantity that was observed for this instance."</comment><return>   ^result.</return></pre><pre><b>quantityAsString: q</b><comment>   "Return the quantity that was observed for this instance."</comment><return>                 ^result. </return><return>   ^result.</return></pre><pre><b>sin</b><return>   ^ quantity sin.</return></pre><pre><b>sqrt</b><return>   ^instance.</return></pre><pre><b>standardNameFor: aString </b><comment>   "Fix up names of units to assure consistency."</comment><comment>   "Remove square- cubic-"</comment><comment>   "Standardize terms"</comment><return>   ^unitsString.</return></pre><pre><b>units</b><comment>   "Render dimensions as a string"</comment><return>   ^string trimBoth.</return><r>***32 lines of code ***</r></pre><pre><b>unitsSynonyms</b><return>   ^ self class unitsSynonyms</return></pre><hr/><h3>Hum-RunTime -- HumMessage</h3><pre><b>nounValues: associations </b><todo>   "TODO: Consider: a HumStatement also has nounValues. Which noun values are which?"</todo></pre><pre><b>receiver: aString </b></pre><pre><b>sender: aString </b></pre><pre><b>statement: aHumStatement </b></pre><pre><b>whenSent: aTimeStamp </b><comment>   " "</comment></pre><hr/><h3>Hum-RunTime -- HumMessenger</h3><pre><b>getActorInstanceFromID: actorID</b><comment>   "*** Backdoor *** during debug to bypass the messenger"</comment><return>   ^actorInstance.</return></pre><pre><b>logInstruction: aHumStatement sentFrom: senderURI to: recipientURI </b><comment>   "Get the clock time - may be a simulator clock"</comment></pre><pre><b>network</b><comment>   "Return the chosen physical implementation of network service."</comment><return>   ^ network ifNil: [ network := HumNetwork new].</return></pre><pre><b>nodeIDtoURI</b><comment>   "actorURI contains (actor-&gt;URI) maps"</comment><return>   ^ nodeIDtoURI ifNil: [ nodeIDtoURI := Dictionary new ].</return></pre><pre><b>ping: aURI</b><comment>   "MOCK: Return the ID of the given URI"</comment><return>   ^ ( self uriToNodeID ) at: aURI ifAbsent: [ Error signal: 'Messenger has no ID entry for URI: ', aURI ].</return></pre><pre><b>playbackLog</b><return>   ^playbackLog ifNil: [ playbackLog := Dictionary new].</return></pre><pre><b>playbackLogFromActor: aHumActor </b><comment>   "Extract/Get log entries sent to/from a specific actor.</comment><todo>   "TODO: Add timestamp feature. </todo><return>   ^result.</return><r>***23 lines of code ***</r></pre><pre><b>playbackLogFromURI: aURI </b><comment>   "Extract/Get log entries sent to/from a specific actor.</comment><todo>   "TODO: Add timestamp feature. </todo><return>   ^result.</return></pre><pre><b>playbackLogToURI: aURI </b><comment>   "Extract/Get log entries sent to/from a specific actor.</comment><todo>   "TODO: Add timestamp feature. </todo><return>   ^result.</return><r>***21 lines of code ***</r></pre><pre><b>registerActor: anActor atURI: aURI </b><comment>   "Track actor."</comment><comment>   "Track URI-&gt;actor association."</comment></pre><pre><b>registerNode: aNode atURI: aURI </b><comment>   "Track actor."</comment><comment>   "Track URI-&gt;actor association."</comment></pre><pre><b>sendAction: anInstructionLine toID: recipientID fromID: senderID </b><comment>   "Transmit action request between actors."</comment><comment>   "Translate ID to URI."</comment><comment>   "Send  . . ."</comment></pre><pre><b>sendAction: anInstruction toURI: recipientURI fromURI: senderURI </b><comment>   "Send the (action) statement to the given actor."</comment><comment>   "Delegate implementation to HumNetwork"</comment></pre><pre><b>sendInstruction: anInstruction toURI: recipientURI fromURI: senderURI</b><comment>   "Send the (action) statement to the given actor."</comment><todo>   "TODO: REFACTOR so that this pushes to a network. </todo><comment>   "Following only works when actor is local."</comment><todo>   "TODO: Fix so that it works when actor is remote."</todo><todo>   "TODO: Need a better simulation of async."</todo><comment>   "========================================"</comment></pre><pre><b>uriToNodeID</b><comment>   "What actor ID is associated with URI?"</comment><return>   ^ uriToNodeID ifNil: [ uriToNodeID := Dictionary new]</return></pre><hr/><h3>Hum-RunTime -- HumNetwork</h3><pre><b>sendAction: anInstruction toURI: recipientURI fromURI: senderURI </b><comment>   "Send the (action) statement to the given actor."</comment><comment>   "Following only works when actor is local."</comment><todo>   "TODO: Fix so that it works when actor is remote."</todo></pre><pre><b>uriToNode</b><comment>   "Return dictionary that maps a URI to an actual actor instance"</comment><comment>   "NOTE: This should only be used in test/local mode. </comment><return>   ^ uriToNode ifNil: [ uriToNode := Dictionary new. ].</return></pre><hr/><h3>Hum-RunTime -- HumNode</h3><pre><b>asString</b><return>   ^ self id ifNil: [ 'no ID'].</return></pre><pre><b>checkIn</b><comment>   "Check-in with the messenger."</comment></pre><pre><b>clock</b><return>   ^ clock ifNil: [clock := DateAndTime "class singleton"].</return></pre><pre><b>clock: anObjectThatImplementsNow</b><comment>   "WARNING: #clock also appears in HumConfiguration."</comment></pre><pre><b>configuration</b><return>   ^ configuration ifNil: [Error signal: 'Node has not been configured.'].</return></pre><pre><b>configuration: aHumConfiguration </b></pre><pre><b>htmlAgent</b><comment>   "Return http/html agent implementation.</comment><return>   ^ htmlAgent ifNil: [ htmlAgent := self ].</return></pre><pre><b>id</b><return>   ^myID</return></pre><pre><b>id: aString </b></pre><pre><b>log</b><return>   ^ log ifNil: [ log := OrderedCollection new ].</return></pre><pre><b>messenger</b><return>   ^self configuration messenger.</return></pre><pre><b>printOn: aStream</b><comment>   "Append to the argument, aStream, a sequence of characters that  </comment></pre><pre><b>sendHTML: htmlString </b><comment>   "This is a dummy/mock for testing."</comment></pre><pre><b>sendHTML: htmlString to: aURL</b><comment>   "This is a dummy/mock for testing. TODO: Make this real."</comment></pre><pre><b>stepLog</b><return>   ^ stepLog ifNil: [ stepLog := OrderedCollection new.].</return></pre><pre><b>stepLogDisplay</b><comment>   "Display the step log"</comment></pre><pre><b>uri</b><return>   ^myURI.</return></pre><pre><b>uri: aURI</b></pre><hr/><h3>Hum-RunTime -- HumNumberParser</h3><pre><b>nDigits</b><return>   ^nDigits.</return></pre><hr/><h3>Hum-RunTime -- HumScribe</h3><pre><b>about</b><comment>"</comment><comment>"</comment><comment>"</comment><comment>"Note: An Avatar may be a kind of widget. </comment><r>***21 lines of code ***</r></pre><pre><b>askView: viewFrame withBlackBoard: aBlackBoard</b><comment>   "Current implementation assumes user interface is a HTML browser."</comment><todo>   "TODO: HTML stuff belongs in a subtype of Scribe."</todo><comment>   "Generate an HTML form for the view."</comment><comment>   "Wrap the view with HTML prolog, navigation, epilog, etc."</comment><todo>   "TODO: Associate an event with the ask-view data-entry."</todo></pre><pre><b>askViewCompleted</b><comment>   "Inform caller that the 'Ask viewName' task </comment><comment>   "Skip this if there was no dialog caller."</comment><comment>   "Send results back to my Dialog Agent"</comment><todo>   "TODO: ?? Do we return results in completion message ?? </todo><comment>   "Get current task context and send task complete message."</comment></pre><pre><b>blackboard</b><comment>   "Override"</comment><return>   ^blackboard ifNil: [Error signal: 'Scribe writes to DialogAgent blackboard']</return></pre><pre><b>client: aClientConection </b><comment>   "synonym"</comment></pre><pre><b>clientConnection</b><return>   ^ clientConnection ifNil:[ clientConnection := myURI ].</return></pre><pre><b>clientConnection: aConnectionOfSomeKind </b><comment>   "How does the Scribe connect to the user/client sensors?"</comment><todo>   "TODO: THIS NEEDS DEEPER/MORE DETAILED THOUGHT."
   self assert: ( aConnectionOfSomeKind isKindOf: ZnUrl ).</todo></pre><pre><b>clientSays: aString </b><comment>   "After a client sensor input is interpreted,</comment><comment>   "</comment><comment>   "*** Following is here for DEBUG? -- Scribe need not be coupled to ontology."</comment><return>   ^vignette.</return></pre><pre><b>dialogAgent</b><comment>   "Returns the Dialog Agent that was attached to this Scribe when the Scribe was instantiated."</comment><return>   ^dialogAgent ifNil: [ Error signal: 'Scribe {',myID asString,'} has no dialog agent.']</return></pre><pre><b>dialogAgent: aHumDialogAgent</b></pre><pre><b>dialogAgentURI</b><comment>   "Returns an instance of HumDialogAgent."</comment><return>   ^dialogAgentURI</return></pre><pre><b>dialogAgentURI: aHumDialogAgentURI </b></pre><pre><b>handleHttpPostRequest: aHumHttpRequest </b><comment>   "The scribe handles the post request by </comment><comment>   "</comment><todo>   "TODO: Should I clear the blackboard before placing these (new/replacement) values?</todo><comment>   "</comment><comment>            "Put the data on my blackboard. </comment><comment>   "I am ready to send data back to the dialog agent </comment><r>***28 lines of code ***</r></pre><pre><b>htmlSession</b><return>   ^ htmlSession ifNil: [ htmlSession := HumSession new ].</return></pre><pre><b>htmlStyle</b><comment>   "Return CSS style element."</comment><return>   ^styleElement.</return></pre><pre><b>initialize</b><comment>   "DEBUG Check: Scribe should be initialized with a dialogAgent at creation."</comment></pre><pre><b>mockDataEntry: userData </b><comment>   "Mock the user entering given data into view.</comment><comment>   "</comment><comment>   "HTML/HTTP magic places data into HTTP Request."</comment></pre><pre><b>runAction: anAction inRole: aRole onJob: aHumJobTicket</b><comment>   "Over-ride HumActor to handle Scribe actions."</comment></pre><pre><b>runInstruction: anInstruction inRole: aRole onJob: aJobID</b><comment>   "Override the HumActor -- (Why?)"</comment><comment>   "We cannot accept statement strings here because we need noun values."</comment><comment>   "We are expecting 'Ask viewName.' or 'Show viewName.'"</comment><return>   ^self.</return><r>***33 lines of code ***</r></pre><pre><b>sendToDialogAgent: aClientSpeechString </b><comment>   "Send the string to my Dialog Agent."</comment><return>   ^vignette.</return></pre><pre><b>sendView: htmlView</b><comment>   "Wrap the view element with HTML header, navigation, epilog, etc." </comment><todo>   "TODO: When we more than one kind of scribe, this method will be abstract."</todo><return>   ^htmlResult.</return></pre><pre><b>systemSays: aString </b><comment>   "The Dialog Agent has responded with this String.</comment><comment>   "</comment><comment>   "*** Subtype implementations will override this method. ***"</comment></pre><pre><b>zdialogAgent: aHumDialogAgent </b></pre><hr/><h3>Hum-RunTime -- HumSimulator</h3><pre><b>after: aDuration sendSpeech: aString from: aClientID </b><comment>   "Put this event into my queue."</comment><todo>   "TODO: Generalize to send string to specific actor, not just user dialog."</todo></pre><pre><b>buildDialogAgentNamed: clientID</b><comment>   "Build a dialog agent configured for our simulation."</comment><comment>   "Check-in with Messenger to enable communication with Dispatcher and WorldBase."</comment><return>   ^clientAgent. </return></pre><pre><b>clientScribes</b><return>   ^clientScribes ifNil: [ clientScribes := Dictionary new.]</return></pre><pre><b>dialogAgents</b><return>   ^ dialogAgents ifNil: [ dialogAgents := Dictionary new ].</return></pre><pre><b>dialogSequence: anArrayOfString </b><comment>   "Identify the sequence of dialog responses to be sent during this simulation."</comment></pre><pre><b>getDialogAgentNamed: aClientID </b><return>   ^clientAgent.</return></pre><pre><b>getScribeForClient: aClientID </b><comment>   "Get the Scribe instance corresponding to the client ID."</comment><return>   ^scribe</return></pre><pre><b>initialize</b><comment>   "Use factory methods to build singleton accomplices"</comment><comment>   "self dispatcher: (HumActor dispatcherID: 'SimDispatcherID' uri: 'SimDispatcherURI' configuration: self)."</comment><comment>     "self bookkeeper: (HumActor bookkeeperID: 'SimBookkeeperID' uri: 'SimBookkeeperURI' configuration: self)."</comment><comment>   "self worldBase: (HumWorldBase openWorldBase: 'SimWorldBase')."</comment></pre><pre><b>log4Dialog</b><return>   ^ log4Dialog ifNil: [ log4Dialog := OrderedCollection new. ].</return></pre><pre><b>logDialogWhen: aDuration who: aClientID why: clientSaid what: systemSaid</b></pre><pre><b>now</b><return>   ^ self simulatedClockSecond.</return></pre><pre><b>now: aDuration </b></pre><pre><b>numberOfDialogs: aSmallInteger </b><comment>   "How many dialogs are to be run simulataneously?"</comment></pre><pre><b>queue</b><return>   ^ queue </return></pre><pre><b>randomStartingIntervals: aDistribution</b><comment>      "Express the distribution as an S-curve in seconds."</comment></pre><pre><b>simulatedClockSecond</b><return>   ^ simulatedClockSecond ifNil: [simulatedClockSecond := 0 seconds].</return></pre><pre><b>step</b><comment>   "Send all events with timing that matches the top event."</comment><comment>   "If the queue is empty, do nothing. </comment><comment>   "Update my clock."</comment><comment>   "Pull the events for this clock-time from the queue."</comment><comment>   "Send those events"</comment><comment>      "Someday we might do more than one type of event. But, currently, we just do speech events."</comment><comment>      "The *fundamental* idea is that user-gestures are translated to speech-acts </comment><todo>      "TODO: Generalize to send event to specific actor, not just the user dialog."</todo><comment>      "The dialog agent may, in turn, trigger self-actions, plans, and/or actions. "</comment><r>***27 lines of code ***</r></pre><pre><b>stepUntilDone</b></pre><hr/><h3>Hum-RunTime -- HumText</h3><pre><b>= anotherHumText</b><comment>   "Does this text have same content as the other"</comment><return>   ^isSame.</return></pre><hr/><h3>Hum-RunTime -- HumTextLine</h3><pre><b>copy</b><return>   ^newInstance.</return></pre><pre><b>indentLevel</b><comment>   "The indent level indicates the level of indentation,</comment><return>   ^ indentLevel ifNil: [ indentLevel := 0 ].</return></pre><pre><b>indentLevel: aSmallInteger</b></pre><pre><b>size</b><return>   ^ self string size</return></pre><pre><b>string</b><return>   ^string.</return></pre><pre><b>string: aByteString </b></pre><hr/><h3>Hum-RunTime -- HumText</h3><pre><b>addLine: aString </b><comment>   "Append given line at bottom of text."</comment></pre><pre><b>copy</b><return>   ^newInstance.</return></pre><pre><b>insertEmptyLineAfter: lineIndex </b><comment>   "Note: Following will call self changed."   </comment></pre><pre><b>lines</b><comment>   "Return the HumText list of HumTextLine instances"</comment><return>   ^lines. </return></pre><pre><b>lines: anOrderedCollection </b></pre><pre><b>printOn: aStream</b><comment>   "Append to the argument, aStream, a sequence of characters that  </comment></pre><pre><b>string</b><comment>   "Return self as a string. (Lines with CR inserted as needed.)"</comment><return>   ^result.</return></pre><hr/><h3>Hum-RunTime -- HumVMInstruction</h3><pre><b>opCodeName</b><return>   ^name.</return></pre><pre><b>operand</b><return>   ^ operand ifNil: [ Error signal: 'operand not set in HumInstruction'.  operand := 000].</return></pre><pre><b>operand: objectIndex </b></pre><pre><b>operation</b><return>   ^ operation ifNil: [ Error signal: 'op code not set in HumInstruction'.  operation := 000].</return></pre><pre><b>operation: opCode </b></pre><pre><b>slotName</b><return>   ^'Undefined.'</return></pre><hr/><h3>Hum-RunTime -- HumVM</h3><pre><b>measureRegister</b><return>   ^ measure ifNil: [ measure := HumMeasure new. ].</return></pre><pre><b>runInstruction: aHumInstruction </b><comment>   "Get the microCode. (a block)"</comment><comment>   "Run the microCode. (a block)"</comment><comment>   "Assure cascade."</comment><return>   ^self. </return></pre><pre><b>setSlot: slotIndex to: aHumObject </b><comment>   "The slots allow objects to be referenced by byte-code indices."</comment><comment>   "Slots are used like registers in this VM thought-experiment. "</comment></pre><pre><b>slots</b><comment>   "slots allow objects to be referenced by byte-code indices."</comment><return>   ^ slots ifNil: [slots := Dictionary new. ].</return></pre><pre><b>transferVector</b><return>   ^transferVector.</return></pre><hr/><h3>Hum-RunTime -- HumVector</h3><pre><b>asString</b><comment>   "render my value as a string"</comment><return>   ^result.</return></pre><pre><b>at: index</b><return>   ^v.</return></pre><pre><b>at: k put:  aValue</b></pre><pre><b>cross: anotherHumVector</b><comment>   "Return the 3-dimensional vector cross product U x V</comment><comment>   "</comment><return>   ^s.</return><r>***25 lines of code ***</r></pre><pre><b>dot: aHumVector</b><return>   ^sum.</return></pre><pre><b>length</b><return>   ^length.</return></pre><pre><b>lengthSquared</b><comment>   "length := s sqrt."</comment><return>   ^s.</return></pre><pre><b>pitch: anAngleInRadians</b><comment>   "Transform receiver by a rotation about x (East pointing) axis."</comment><return>   ^vector.</return></pre><pre><b>pitch: anAngleInRadians aboutPivot: pivot</b><comment>   "Transform receiver by a rotation about X (side pointing) axis."</comment><comment>   "The effect is to move the effective origin."</comment><comment>   "Restore the coordinate origin."</comment><comment>   "Post condition: The length of the vector should not change"</comment><return>   ^vector.</return><r>***21 lines of code ***</r></pre><pre><b>quantityAsString</b><return>   ^s.</return></pre><pre><b>roll: anAngleInRadians</b><comment>   "Transform receiver by a rotation about y (North pointing) axis."</comment><return>   ^vector.</return></pre><pre><b>roll: anAngleInRadians aboutPivot: pivot</b><comment>   "Transform receiver by a rotation about Y (forward pointing) axis."</comment><comment>   "Arithmetic is all via HumMeasure"</comment><comment>   "The effect is to move the effective origin."</comment><comment>   "Restore the coordinate origin."</comment><comment>   "Post condition: The length of the vector should not change"</comment><return>   ^vector.</return><r>***25 lines of code ***</r></pre><pre><b>size</b><comment>   "compatibility"</comment></pre><pre><b>x</b><return>   ^(self at: 1).</return></pre><pre><b>x: xValue y: yValue z: zValue</b><comment>   "Hum coordinates are plan-view. x points East. y North. z Up."</comment><comment>   "Create array and store as quantity."</comment><comment>   "Assume all elements have same unit of measure (by definition)."</comment></pre><pre><b>y</b><return>   ^self at: 2.</return></pre><pre><b>yaw: anAngleInRadians</b><comment>   "Transform receiver by a rotation about z (Up pointing) axis."</comment><return>   ^vector.</return></pre><pre><b>yaw: anAngleInRadians aboutPivot: pivot</b><comment>   "Transform receiver by a rotation about Z (Up pointing) axis."</comment><comment>   "The effect is to move the effective origin."</comment><comment>   "Restore the coordinate origin."</comment><comment>   "Post condition: The length of the vector should not change"</comment><return>   ^vector.</return><r>***23 lines of code ***</r></pre><pre><b>z</b><return>   ^z := self at: 3.</return></pre><hr/><h3>Hum-RunTime -- HumWorldBase</h3><pre><b>checkTau: aTau </b></pre><pre><b>getEntityID: entityID attribute: attributeType </b><comment>   " Get requested value (if any) from the world base instance "</comment><return>   ^ value.</return></pre><pre><b>history</b><return>   ^ history ifNil: [ history := Dictionary new. ].</return></pre><pre><b>initialize</b></pre><pre><b>quads</b><comment>   "For quad internal structure see </comment><return>   ^ quads ifNil: [ quads := Dictionary new. ].</return></pre><pre><b>setEntityID: entityID attribute: attributeType toValue: aValue</b><comment>   "Put attribute-value (if any) into the world base instance. "</comment><todo>   "TODO: Tau should refer to a business event."</todo><comment>   "If there is a different prior value, archive in history."</comment><comment>   "Put value of entity attribute and the timestamp."</comment><todo>   "TODO: For large scale applications, </todo><comment>   "</comment><todo>   "TODO: Should (other) blackboards holding the same entityID be notified of the change? If so, how?"</todo><r>***22 lines of code ***</r></pre><pre><b>title</b><return>   ^ title ifNil: [ Error signal: 'A world base instance must have a title.'].</return></pre><pre><b>title: aWorldBaseName </b></pre><pre><b>whereAttribute: attributeType satisfies: aBlockClosure</b><comment>   "Return a set of entity identifiers where the attribute value satisfies the block"</comment><comment>                  "Tau (timestamp) is not really used. I've included it for clarity and debug."</comment><return>   ^identifierSet.</return></pre><hr/><hr/><h2>Hum-Seaside</h2><hr/><h3>Hum-Seaside -- HumApplication</h3><pre><b>bookkeeper: aHumBookkeeper</b><comment>   "This application instance will be served by this bookkeeper instance."</comment></pre><pre><b>dispatcher: aHumResourceManager</b><comment>   "This application instance will be served by this Dispatcher instance."</comment></pre><pre><b>messenger: aHumMessenger</b><comment>   "This application instance will be served by this messenger instance."</comment></pre><pre><b>ontology: aHumOntology</b><comment>   "This application a run-time manifestation of that ontology."</comment></pre><pre><b>worldBase: aHumWorldBase</b><comment>   "This application instance will be served by this world-base instance."</comment></pre><hr/><h3>Hum-Seaside -- HumBrowserEditFrame</h3><pre><b>critic</b><return>   ^ critic ifNil: [ critic := '*** No frame critique yet ***' ].</return></pre><pre><b>critic: aTextString</b><comment>   "This is a dummy to accomodate a side-effect of using a TextArea to display the critique.</comment><comment>   "</comment><comment>   "self trace: 'critc called with: ', aTextString. "</comment></pre><pre><b>fetchCodeForTitle: aString</b></pre><pre><b>firstLine</b><return>   ^ result.</return></pre><pre><b>frameCode</b><return>   ^ frameCode ifNil: [ frameCode := '*** No frame code yet. ***']</return></pre><pre><b>frameCode: aTextString</b></pre><pre><b>initialize</b></pre><pre><b>lastSaved</b><return>   ^ lastSaved ifNil: [ lastSaved := '*** NOT SAVED YET ***' ].</return></pre><pre><b>lastSaved:  anObject</b></pre><pre><b>layoutFrameAsColumnsOnCanvas: aWAHtmlCanvas</b><comment>   "Generate the column style layout"</comment><r>***33 lines of code ***</r></pre><pre><b>layoutFrameAsRowsOnCanvas: aWAHtmlCanvas</b><comment>   "Generate the row style layout."</comment><comment>               "readonly: False; " </comment><r>***39 lines of code ***</r></pre><pre><b>renderContentOn: html</b></pre><pre><b>runCritic</b><comment>   "Run the ontology critic that is appropriate to this type of frame."</comment></pre><pre><b>setCritique: aTextString</b><comment>   "Set the critique value.</comment><comment>   "</comment></pre><pre><b>title</b><return>   ^ title ifNil: [ title := 'TBD']</return></pre><pre><b>title: aString</b><comment>   "Otherwise -- fetch the code for the new title."</comment></pre><pre><b>trace: aString</b></pre><hr/><h3>Hum-Seaside -- HumBrowserSession</h3><pre><b>currentFrame</b><comment>   "What frame is currently being editted?"</comment><return>   ^ currentFrame ifNil: [ currentFrame :=  HumBrowserEditFrame new. ].</return></pre><hr/><h3>Hum-Seaside -- HumBrowser</h3><pre><b>blackboard</b><return>   ^ blackboard ifNil: [blackboard := HumBlackBoard worldbase: 'none'.]</return></pre><pre><b>clearOntology</b></pre><pre><b>contextDiagram</b><return>   ^ contextDiagram ifNil: [ contextDiagram := HumDiagram new title: 'Context Diagram '].</return></pre><pre><b>currentFrame</b><comment>   "What frame is currently being editted?"</comment><return>   ^ self session currentFrame.</return></pre><pre><b>dialog</b><return>   ^ dialog ifNil: [ dialog := HumSeasideComponentThingy new. ].</return></pre><pre><b>editActionFrame: aTitleString forRole: aRoleString</b><comment>   "Create / View / Edit the frame with the given title."</comment></pre><pre><b>editDialogFrame: aString </b><comment>   "Create / View / Edit the frame with the given title."</comment></pre><pre><b>editDictionaryFrame: aString </b><comment>   "Create / View / Edit the frame with the given title."</comment></pre><pre><b>editPlanFrame: aString </b><comment>   "Create / View / Edit the frame with the given title. (Use goal statement as title.)"</comment></pre><pre><b>editViewFrame: aString </b><comment>   "Create / View / Edit the frame with the given title."</comment></pre><pre><b>hideDiagrams</b><return>   ^ hideDiagrams ifNil: [ hideDiagrams = False ].</return></pre><pre><b>hideDiagrams: aBoolean</b><return>   ^ hideDiagrams := aBoolean.</return></pre><pre><b>initialize</b></pre><pre><b>layout</b><comment>   "What style of browser layout (#rows or #columns)?</comment><comment>   "</comment><return>   ^ layout ifNil: [ layout = #rows ].</return></pre><pre><b>layout: aSymbol</b><comment>   "What style of browser layout (#rows or #columns)?</comment><comment>   "</comment><return>   ^ layout := aSymbol.</return></pre><pre><b>layoutDiagramsAsColumnOnCanvas: aWAHtmlhtml</b><return>   ^ html div</return><comment>               "html label: 'Diagram Column'.</comment><comment>                     "Draw plan diagram on this html."</comment><r>***25 lines of code ***</r></pre><pre><b>layoutDiagramsAsRowOnCanvas: aWAHtmlCanvas</b><comment>            "html label: 'Diagram Row'.</comment><r>***25 lines of code ***</r></pre><pre><b>layoutMenuActionsAsColumnOnCanvas: html</b><comment>   "Identify the actions that the user may invoke via menu navigation."</comment><comment>   "A menu is a sequence of name -&gt; action pairs.</comment><comment>   "</comment><comment>   "</comment><comment>   "</comment><comment>   "</comment><comment>      "* Save will overwrite an existing file without asking. </comment><comment>      "* I expect Save-As to be used like it is in Smalltalk </comment><comment>   "</comment><comment>   "</comment><comment>   "</comment><comment>   "</comment><comment>   "Hide or UnHide"</comment><comment>   "Render the main menu"</comment><r>***86 lines of code ***</r></pre><pre><b>layoutWindowAsColumns</b><comment>   "*** This is a design document defining layout in Hum markup. ***</comment><comment>   "Hum view mark-up for the window layout.</comment><comment>   "</comment><comment>   "The Source Frame Tabs are similar to Eclipse source code navigation.</comment><comment>   "</comment><comment>   "The Diagram Column shows a set of diagram viewers.</comment><comment>   "</comment><comment>   "The menu bar is a row of tabs identical to common desktop window menus in operation.</comment><comment>   "What does the user/programmer need in the status bar?</comment><comment>   "</comment><r>***64 lines of code ***</r></pre><pre><b>layoutWindowAsColumnsOnCanvas: aWAHtmlCanvas</b><comment>   "This layout is visually two columns with editor on left and diagrams on right."</comment><comment>   "Layout the Window as a table with three rows."</comment><comment>   "Finally we generate the window contents by calling the functions [blocks] that we defined above."   </comment><comment>   "html render: [ htmlMenuBar value: html ].</comment><comment>               "Editor Column and Diagram Column"</comment><r>***32 lines of code ***</r></pre><pre><b>layoutWindowAsRows</b><comment>   "This layout is visually two rows with editor on bottom row and diagrams on top row."</comment><comment>   "Hum view mark-up for the window layout.</comment><comment>   "</comment><comment>   "The Source Frame Tabs are similar to Eclipse source code navigation.</comment><comment>   "</comment><comment>   "The Diagram Row shows a set of diagram viewers.</comment><comment>   "</comment><comment>   "The menu bar is a row of tabs identical to common desktop window menus in operation.</comment><comment>   "What does the user/programmer need in the status bar?</comment><comment>   "</comment><r>***56 lines of code ***</r></pre><pre><b>layoutWindowAsRowsOnCanvas: aWAHtmlCanvas</b><comment>   "This layout is visually two Rows with diagrams in top row and editor in lower row."</comment><comment>   "Layout the Window as a table with three rows."</comment><comment>   "Finally we generate the window contents by calling the functions [blocks] that we defined above."</comment><comment>   "html render: [ htmlMenuBar value: html ].</comment><r>***39 lines of code ***</r></pre><pre><b>loadOntologyFile: aFileSpec </b><comment>   "To be consistent with Hum design ideas, we will use a WorldBase instead of local file."</comment></pre><pre><b>loadOntologyInstance: ontologyTitle </b><comment>   "Initialize / Replace my ontology instance."</comment><return>   ^ontology.</return></pre><pre><b>log: aString</b><comment>   "Use #logUserAction instead."</comment></pre><pre><b>logUserAction: aString</b><comment>   "Log the user action for potential analysis / diagnosis."</comment></pre><pre><b>menuActions</b><comment>   "Identify the actions that the user may invoke via menu navigation."</comment><comment>   "A menu is a sequence of name -&gt; action pairs.</comment><comment>   "</comment><comment>   "</comment><comment>   "</comment><comment>   "</comment><comment>      "* Save will overwrite an existing file without asking If file is not known, it will dialog for a file name. (Relatively harmless if we have infinite undo.)"</comment><comment>      "* I expect Save-As to be used like it is in Smalltalk - as a kind of poor-man's source code label mechanism."</comment><comment>   "</comment><comment>   "</comment><comment>   "</comment><comment>   "</comment><comment>   "The following will force each menu action to be defined, if not implemented."</comment><comment>         "Evaluate the block to force the selectors it references to be created."</comment><comment>   "force value: ontologyMenu."</comment><return>   ^ combinedMenu.</return><r>***68 lines of code ***</r></pre><pre><b>newOntology</b><comment>   "Start with a fresh new ontology and clear any related views."</comment></pre><pre><b>nounDiagram</b><return>   ^ nounDiagram ifNil: [ nounDiagram := HumDiagram new title: 'Noun Diagram '].</return></pre><pre><b>ontology</b><return>   ^ ontology ifNil: [ ontology := HumOntology new. ].</return></pre><pre><b>openOntology</b><comment>   "Clear all views and load an ontology from a save file."</comment></pre><pre><b>openOntologyDialog</b></pre><pre><b>planDiagram</b><return>   ^ planDiagram ifNil: [ planDiagram := HumDiagram new title: 'Plan Diagram '].</return></pre><pre><b>printOntology</b><comment>   "Document the current ontology in a HTML document"</comment></pre><pre><b>programmersAssistant</b><return>   ^ programmersAssistant ifNil: [ programmersAssistant := HumProgrammersAssistant new ].</return></pre><pre><b>renderContentOn: html</b></pre><pre><b>roleDiagram</b><return>   ^ roleDiagram ifNil: [ roleDiagram := HumDiagram new title: 'Role Diagram '].</return></pre><pre><b>saveOntology</b><comment>   "Write the current ontology into a save file."</comment></pre><pre><b>showSubMenu: aMenu title: aString onCanvas: html</b><comment>   "aMenu is an OrderedCollection of ( name -&gt; action ).</comment><comment>   "</comment><r>***21 lines of code ***</r></pre><pre><b>toggleDiagramView</b></pre><pre><b>toggleFullScreen</b></pre><pre><b>transposeLayout</b></pre><pre><b>userActions</b><return>   ^ userActions ifNil: [ userActions := OrderedCollection new.].</return></pre><hr/><h3>Hum-Seaside -- HumSeasideComponentThingy</h3><pre><b>ask: aSymbol </b><comment>   "Ask, set, and return the requested attrbute."</comment><comment>   "STUB"</comment><return>   ^ 'HERE IS STUB ANSWER'</return></pre><pre><b>ask: aString choice: anArrayOfSymbol</b><comment>   "The array of symbols liimits the user's choices"</comment><comment>   "*** THIS IS A STUB ***"</comment><return>   ^ (anArrayOfSymbol at: 1).</return></pre><pre><b>askFile: aString </b><comment>   "Initiate a file spec dialog."</comment><return>   ^result.</return></pre><pre><b>askV00: aSymbol </b><comment>   "Ask, set, and return the requested attrbute."</comment><comment>   "*** THIS IS A MOCK ***"</comment><return>   ^result.</return></pre><pre><b>attributes</b><return>   ^ attributes ifNil: [ attributes := Dictionary new. ].</return></pre><pre><b>logDialogAction: aString </b></pre><pre><b>renderView: anEntityID onCanvas: html</b><comment>   "**** Check generated code by pasting it below. ****"</comment><r>***24 lines of code ***</r></pre><pre><b>valueOfAttribute: aSymbol </b><comment>   "Return the requested attrbute."</comment><return>   ^result.</return></pre><hr/><hr/><h2>Hum-Tests</h2><hr/><h3>Hum-Tests -- GivenWhenThen4Seaside</h3><pre><b>assert: aBlock match: aPatternString </b><comment>   "This is a utility function to improve readability."</comment></pre><pre><b>assert: aBlock matches: aPatternString </b><comment>   "This is a utility function to improve readability."</comment></pre><pre><b>assertString: stringA includesSubstring: stringB</b><comment>    " stringB should be a substring in stringA "</comment></pre><pre><b>expect: expectedValue actual: actualValue </b></pre><pre><b>given: aDescriptionString code: aBlock</b><comment>   "Given in a given-when-then triplet </comment><comment>   "</comment><comment>   "Save the block so that multiple *when* can restore initial state before running."</comment><return>   ^self.</return></pre><pre><b>givenWhenThenComment</b><comment>   "The #given:code: and #when:code: and #then:code: methods are designed to be cascaded.</comment><comment>   "</comment><return>   ^ 'The #given:code: and #when:code: and #then:code: methods are designed to be cascaded.</return></pre><pre><b>log</b><return>   ^ log ifNil: [ log := OrderedCollection new. ].</return></pre><pre><b>log: aString</b><comment>   "Prepend a CR to make inspection more readable."</comment></pre><pre><b>test105GivenWhenThenSuccess</b><comment>   "Test the test utility - In this situation the test assertion is true."</comment><comment>   "A typical test looks like this."   </comment><comment>   "Blocks should have executed."</comment></pre><pre><b>test106GivenWhenThenFail</b><comment>   "Test the test utility - In this situation the test assertion is true."</comment><comment>   "Normally, this test is not needed."</comment><comment>   "A typical test looks like this."   </comment><comment>      "Following should show assertion fails."</comment></pre><pre><b>test110BasicLog</b><comment>   "Test the testcase`s own log"</comment></pre><pre><b>test120GivenWhenThenLogging</b><comment>   "Test the testcase`s own log"</comment><comment>   "A typical test looks like this."   </comment><comment>   "The log should contain the descriptions."</comment></pre><pre><b>then: aDescriptionString code: aBlock</b><comment>   "*Then* in a given-when-then triplet </comment><comment>   "</comment><comment>   "Run my assertions."</comment><return>   ^self.</return></pre><pre><b>when: aDescriptionString code: whenBlock</b><comment>   "*When* in a given-when-then triplet </comment><comment>   "</comment><comment>   "Run the given block to reset to initial state.</comment><comment>   "</comment><comment>   "Now run my block"</comment><return>   ^self.</return></pre><hr/><h3>Hum-Tests -- GivenWhenThen</h3><pre><b>assertString: stringA includesSubstring: stringB</b><comment>    " stringB should be a substring in stringA "</comment></pre><pre><b>given: aDescriptionString code: aBlock</b><comment>   "Given in a given-when-then triplet </comment><comment>   "</comment><comment>   "Save the block so that multiple *when* can restore initial state before running."</comment><return>   ^self.</return></pre><pre><b>givenWhenThenComment</b><comment>   "The #given:code: and #when:code: and #then:code: methods are designed to be cascaded.</comment><comment>   "</comment><return>   ^ 'The #given:code: and #when:code: and #then:code: methods are designed to be cascaded.</return></pre><pre><b>log</b><return>   ^ log ifNil: [ log := OrderedCollection new. ].</return></pre><pre><b>log: aString</b><comment>   "Prepend a CR to make inspection more readable."</comment></pre><pre><b>test105GivenWhenThenSuccess</b><comment>   "Test the test utility - In this situation the test assertion is true."</comment><comment>   "A typical test looks like this."   </comment><comment>   "Blocks should have executed."</comment></pre><pre><b>test106GivenWhenThenFail</b><comment>   "Test the test utility - In this situation the test assertion is true."</comment><comment>   "Normally, this test is not needed."</comment><comment>   "A typical test looks like this."   </comment><comment>      "Following should show assertion fails."</comment></pre><pre><b>test110BasicLog</b><comment>   "Test the testcase`s own log"</comment></pre><pre><b>test120GivenWhenThenLogging</b><comment>   "Test the testcase`s own log"</comment><comment>   "A typical test looks like this."   </comment><comment>   "The log should contain the descriptions."</comment></pre><pre><b>then: aDescriptionString code: aBlock</b><comment>   "*Then* in a given-when-then triplet </comment><comment>   "</comment><comment>   "Run my assertions."</comment><return>   ^self.</return></pre><pre><b>when: aDescriptionString code: whenBlock</b><comment>   "*When* in a given-when-then triplet </comment><comment>   "</comment><comment>   "Run the given block to reset to initial state.</comment><comment>   "</comment><comment>   "Now run my block"</comment><return>   ^self.</return></pre><hr/><h3>Hum-Tests -- Hum000RefactoringTests</h3><pre><b>givenOntology</b><comment>   "Create an Action Frame."</comment><comment>   "Create a Dictionary Frame."</comment><comment>   "Create a View Frame."</comment><comment>   "Frames must be compiled if nouns are to be marked."</comment><return>   ^ontology</return><r>***60 lines of code ***</r></pre><pre><b>humClassResponsiblityCollaboration</b><return>^'Collaborative Roles and Responsibilities</return><r>***228 lines of code ***</r></pre><pre><b>strategyForSeaside</b><return>^'TBD -- Currently considering subtyping HumWidgets as WAComponents</return></pre><pre><b>test110addFrame</b><comment>   "Add frame to ontology"</comment><comment>   "A plan frame should have a goal and at least two preconditions."</comment></pre><pre><b>test121getFrameForGoal</b><comment>   "Get the plan frame that defines a goal."</comment><comment>   "A plan frame should have a goal and at least two preconditions."</comment></pre><pre><b>test122getFrameForAction</b><comment>   "Get frame where action statement is defined."</comment><comment>   "Initialize for an Action Frame."</comment><r>***21 lines of code ***</r></pre><pre><b>test123getFrameForView</b><comment>   "Get frame where view is defined."</comment></pre><pre><b>test131getFramesInvokingPrecondition</b><comment>   "Get the goal frames that invoke a given precondition."</comment><r>***24 lines of code ***</r></pre><pre><b>test132getFramesInvokingAction</b><comment>   "Get the frames that invoke a given action."</comment><comment>   "Actions may be invoked in goal-frames, action-frames, and vignettes."</comment><comment>   "Create a goal frame. "</comment><comment>   "Create an action frame."</comment><comment>   "Create a vignette."</comment><r>***28 lines of code ***</r></pre><pre><b>test133getFramesInvokingView</b><comment>   "Get views frames and vignettes that invoke a view."</comment><comment>   "Create an ontology"</comment><comment>   "Create a view that invokes another view."</comment><comment>   "Create a vignette that invokes a view."</comment><r>***26 lines of code ***</r></pre><pre><b>test134getFramesDefiningContext</b><comment>   "Get vignettes that define a context."</comment><comment>   "Create an ontology"</comment><comment>   "Create a vignette that defines part of a context."</comment><comment>   "Create another vignette in the same context."</comment><comment>   "Test: Make this not case-sensitive."</comment><r>***26 lines of code ***</r></pre><pre><b>test135getFramesInvokingContext</b><comment>   "Get vignettes that define a context."</comment><comment>   "Create an ontology"</comment><comment>   "Create a vignette that defines part of a context."</comment><comment>   "Create another vignette in the same context."</comment><comment>   "Test: Make this not case-sensitive."</comment><r>***26 lines of code ***</r></pre><pre><b>test210prettyPrintOntologyAsHTML</b><comment>   "Refactor so that this function is view OntologyViewer"</comment><comment>   "Call via a OntologyViewer instance."</comment></pre><pre><b>test211prettyPrintOntologyAsHTMLonFile</b><comment>   "Pretty print the given ontology on an HTML file."</comment><comment>   "Call via a OntologyViewer instance."</comment></pre><pre><b>test220renderCollectionAsHtmlTable</b><comment>   "A plural noun indicates a collection.</comment><comment>   "</comment><comment>   "Call via a OntologyViewer instance."</comment><comment>   "Should see two tables"</comment><comment>   "Should see attributes of steps."</comment><comment>   "Should see attributes of ingredients."</comment><comment>   "html inspect."</comment></pre><pre><b>test221renderCollectionAsHtmlTableOnFile</b><comment>   "A plural noun indicates a collection.</comment><comment>   "</comment><comment>   "Call via a OntologyViewer instance."</comment><comment>   "Should see two tables"</comment><comment>   "Should see attributes of steps."</comment><comment>   "Should see attributes of ingredients."</comment></pre><pre><b>test230renderEmphasisAsHTML</b><comment>   "Render emphasis in the markup as underscore, italic, bold. </comment><comment>   "</comment><comment>      "Create a View Frame."</comment><comment>   "Frames must be compiled if nouns are to be marked."</comment><comment>   "Call via a OntologyViewer instance."</comment><comment>   "Expect _not_ to become &lt;u&gt;not&lt;/u&gt; "</comment><comment>   "Expect ~preheat~ to become &lt;i&gt;preheat&lt;/i&gt; "</comment><comment>   "Expect *oven* to become &lt;b&gt;oven&lt;/b&gt; "</comment><comment>   "Note: Might also see noun &lt;n&gt; tags."</comment><r>***30 lines of code ***</r></pre><hr/><h3>Hum-Tests -- Hum000TestPlanOverview</h3><pre><b>aReadMe</b><comment>   "See the class description for the intended (future) tests."</comment><return>   ^'See the class description for the intended (future) tests.'</return></pre><pre><b>givenWhenThenInHTML</b><comment>   "HTML GivenWhenThen frames."</comment><return>^'&lt;html&gt;</return><r>***157 lines of code ***</r></pre><pre><b>progress</b><return>   ^ ' </return><r>***41 lines of code ***</r></pre><hr/><h3>Hum-Tests -- HumBaseTest</h3><pre><b>test110putGetValue</b><comment>   "Save entity-attribute-value and fetch."</comment><r>***29 lines of code ***</r></pre><pre><b>test120updateGetValue</b><comment>   "Save entity-attribute-value and fetch."</comment><comment>   "Set initial value"</comment><comment>   "Update value"</comment><r>***42 lines of code ***</r></pre><pre><b>test130putGetEvent</b><comment>   "put get event"</comment></pre><hr/><h3>Hum-Tests -- HumByteCodeTests</h3><pre><b>setUp</b><comment>   "For convenience, create a Hum VM instance for all of the tests to use."</comment></pre><pre><b>test110EachInstructionHasTwoBytes</b><comment>   "A Hum byte code instruction has two bytes -- one for operation and one for operand."</comment></pre><pre><b>test120OpCode000IsHalt</b><comment>   "An opCode of 000 is a halt instruction. (operand is ignored)"</comment></pre><pre><b>test130Operand000IsNone</b><comment>   "An operand index of zero is treated as None.</comment></pre><pre><b>test210MeasureLoad</b><comment>   "Load measure into measure-arithmetic register."</comment></pre><pre><b>test220MeasureAdd</b><comment>   "Add measure into measure-arithmetic register."</comment><comment>   "First load a measure into the register."</comment><comment>   "Add another measure into the register."</comment></pre><pre><b>test230MeasureMinus</b><comment>   "Add measure into measure-arithmetic register."</comment><comment>   "First load a measure into the register."</comment><comment>   "Subtract another measure from the register."</comment></pre><hr/><h3>Hum-Tests -- HumCalculatorTests</h3><pre><b>test110substringAfter</b><comment>   "Test helper method that finds a substring between two given substrings."</comment></pre><pre><b>test115substringBefore</b><comment>   "Test helper method that finds a substring between two given substrings."</comment></pre><pre><b>test120substringBetween</b><comment>   "Test helper method that finds a substring between two given substrings."</comment></pre><pre><b>test130substringBetweenBrackets</b><comment>   "Test helper method that finds a substring between a pair of brackets or similar pairs."</comment></pre><pre><b>test210templateFill</b><r>***21 lines of code ***</r></pre><pre><b>test305parse</b><comment>   "Test the simple parser."</comment><comment>   "Parse produces a collection of tuples: { token. type. start. stop. }"</comment></pre><pre><b>test310parse</b><comment>   "calc parse: s - recognizes quoted strings as single tokens."</comment></pre><pre><b>test311parse</b><comment>   "What if string ends with quoted text?"</comment></pre><pre><b>test312parse</b><comment>   "Test parse with quote within string."</comment></pre><pre><b>test313parse</b><comment>   "calc parse: s - recognizes quoted strings as single tokens."</comment></pre><pre><b>test314parse</b><comment>   "Test parse with quote within string."</comment><todo>   "TODO: Think about following convention where doubled quote within a string is treated as embedded quote."</todo><todo>   "TODO: Think about following convention where special characters are preceded with back-slash (\)."</todo></pre><pre><b>test510measurePlusSameUnits</b><comment>   "Measures may be added if same units."</comment></pre><pre><b>test520measureMinusSameUnits</b><comment>   "Measures may be added if same units."</comment></pre><pre><b>test540CommonUnits</b><comment>   "Test that these do not crash"</comment><comment>   "Transcript cr; show: 'test540CommonUnits d = '; show: d asString."</comment><r>***21 lines of code ***</r></pre><pre><b>test542UnitsShouldCancel</b><comment>   "Test that these do not crash"</comment><r>***22 lines of code ***</r></pre><pre><b>test545Conversions</b><comment>   "Test that these do not crash"</comment><r>***31 lines of code ***</r></pre><pre><b>test546ConvertVolumeMeasures</b></pre><pre><b>test550CasualMeasures</b><comment>   "Work with non-KMS measures. Develop HumMeasure2"</comment><r>***29 lines of code ***</r></pre><pre><b>test552CasualMeasuresAdd</b><comment>   "Work with non-KMS measures. Develop HumMeasure2"</comment></pre><pre><b>test553CasualMeasuresSubtract</b><comment>   "Work with non-KMS measures. Develop HumMeasure2"</comment></pre><pre><b>test554AsPercent</b><comment>   "Work with non-KMS measures. Develop HumMeasure2"</comment></pre><pre><b>test555CasualMeasuresAsString</b><comment>   "Test asString"</comment><comment>   "check ' per '"</comment><comment>   "Check square"</comment><comment>   "Check cubic"</comment><r>***25 lines of code ***</r></pre><pre><b>test556CasualMeasuresSquares</b><comment>   "Test asString"</comment></pre><pre><b>test557CasualMeasuresCubics</b><comment>   "Test asString"</comment></pre><pre><b>test560coefficientOfExpansion</b><comment>   "Sometimes the exponents are all negative."</comment><comment>   "coefficient of expansion for aluminum</comment></pre><pre><b>test570CreateMeasureFromString</b><comment>   "Create a measure from a sting of the form: -999 units"</comment></pre><pre><b>test580exampleBussardRamJet</b><comment>   "Is relatvity relevant at this speed?"</comment><comment>   "The interstellar medium within the Local Bubble has a density of about 0.07 atoms/cm3"</comment><comment>   "How much power does the CNO fusion provide?"</comment><comment>   "Seems way too small to power, let alone move, a structure 1 km in radius." </comment><r>***26 lines of code ***</r></pre><pre><b>test581megaWattToAcceleration</b><comment>   "What kind of acceleration does a megaWatt per tonne give?"</comment><comment>   "kinetic energy KE = mass * v * v / 2. </comment><comment>   "</comment><comment>   "1 kilowatt per kilogram ==&gt; high acceleration (assuming perfect energy conversion)"</comment></pre><pre><b>test582megaWattToAcceleration</b><comment>   "What level of acceleration does a megaWatt give to 100 tonnes of ship mass?"</comment><comment>   "kinetic energy KE = mass * v * v / 2. </comment><comment>   "</comment><comment>   "Lower limit for one megawatt of energy production and conversion is probably about 10 tonne. </comment></pre><pre><b>test590examples</b><comment>   "Class-side examples should not fail"</comment></pre><pre><b>testV110VectorCrossProduct</b><comment>   "Check the vector cross product"</comment></pre><pre><b>testV111VectorCrossProduct</b><comment>   "Check the vector cross product"</comment></pre><pre><b>testV112VectorCrossProduct</b><comment>   "Check the vector cross product"</comment></pre><pre><b>testV113VectorCrossProduct</b><comment>   "Check the vector cross product"</comment></pre><pre><b>testV115VectorCrossProduct</b><comment>   "Check the vector cross product"</comment></pre><pre><b>testV117VectorCrossProduct</b><comment>   "Check the vector cross product"</comment></pre><pre><b>testV210IdentityVector</b><comment>   "Creat a identity vector I * V = V.</comment><comment>   "</comment><comment>   "Multiplication by unit vector should return same."</comment><comment>   "Dot product should produce sum of elements."</comment><comment>   "Crossed with itself."</comment><comment>   "Dot with itself."</comment><r>***23 lines of code ***</r></pre><pre><b>ztest530measureTimesPercent</b><comment>   "Percent times percent produces percent"</comment></pre><hr/><h3>Hum-Tests -- HumCodeBaseTests</h3><pre><b>test110MyPackages</b></pre><pre><b>test120MyClasses</b></pre><pre><b>test130GetPackageClassTuples</b><comment>   "packageClassTree inspect."</comment></pre><pre><b>test140GetPackageClassMethodTuples</b></pre><pre><b>test146CountTestModules</b></pre><pre><b>test147CountLongModules</b><comment>"1 --- Twenty lines is roughly the maximum amount of code </comment><r>***24 lines of code ***</r></pre><pre><b>test148CountLongModules</b><comment>   "Count modules whose listing will exceed one page. "</comment></pre><pre><b>test150gatherSources</b></pre><pre><b>test160LinesOfCode</b></pre><pre><b>test161LinesOfCodePerModule</b></pre><pre><b>test170FindToDoLines</b></pre><pre><b>test171FindCommentLines</b></pre><pre><b>test175FindAssertLines</b></pre><pre><b>test180listOnHTML</b></pre><pre><b>test182listOnHTML2Lines</b></pre><pre><b>test183listOnHTMLcomments</b></pre><hr/><h3>Hum-Tests -- HumFuzzyTests</h3><pre><b>testF100FuzzyArithmeticReadMe</b><comment>   "</comment><comment>   "</comment><r>***23 lines of code ***</r></pre><pre><b>testF110CreateFuzzyWithDistribution</b><comment>   "Create a fuzzy quantity from a given distribution."</comment><comment>   "A distribution is a Dictionary of f-&gt;p points</comment></pre><pre><b>testF112CheckEdgeCases</b><comment>   "Create a fuzzy quantity from a given distribution."</comment><comment>   "A distribution is a Dictionary of f-&gt;p points</comment></pre><pre><b>testF120Interpolation</b><comment>   "Create a fuzzy quantity from a given distribution."</comment><comment>   "A distribution is a Dictionary of p-&gt;f points</comment><comment>   "Should be able to return given point value."</comment><comment>   "Force interpolation"</comment><r>***27 lines of code ***</r></pre><pre><b>testF125Mean</b><comment>   "Create a fuzzy quantity from a given distribution."</comment><comment>   "A distribution is a Dictionary of p-&gt;f points</comment><comment>   "Calculate mean"</comment><comment>   "the mean will be higher than the median because of long tail"</comment><r>***26 lines of code ***</r></pre><pre><b>testF130Plus</b><comment>   "Add fuzzy distributions.</comment><comment>   "A distribution is a Dictionary of p-&gt;f points</comment><comment>   " Niave median is just . . . "</comment><comment>   " But, because there is a long tail . . . "</comment><comment>   "Examine expectedMean"</comment><comment>   "Expect some difference due to long tail."</comment><comment>   "The difference is typically about 3 to 4%; but is occasionally greater than 5%."</comment><comment>   "Transcript cr; show: 'testF130Plus diffMean = ', ( diffMean asString)."</comment><r>***42 lines of code ***</r></pre><pre><b>testF140Op</b><comment>   "Test op:with:"</comment><comment>   "A distribution is a Dictionary of p-&gt;f points</comment><comment>   " Niave median is just . . . "</comment><comment>   " But, because there is a long tail . . . "</comment><r>***30 lines of code ***</r></pre><pre><b>testF150MinusOp</b><comment>   "Subtract fuzzy distributions."</comment><comment>   "A distribution is a Dictionary of p-&gt;f points</comment><comment>   " Niave median is just . . . "</comment><comment>   " But, because there is a long tail . . . "</comment><r>***36 lines of code ***</r></pre><pre><b>testF155Minus</b><comment>   "Subtract fuzzy distributions."</comment><comment>   "A distribution is a Dictionary of p-&gt;f points</comment><comment>   " Niave median is just . . . "</comment><comment>   " But, because there is a long tail . . . "</comment><comment>   "NOTE: Following will fail occasionally."</comment><comment>      "Examine expectedMean"</comment><comment>   "The difference will typically be on the order of 5-15%"</comment><comment>   "It could be close to zero, but that will be a rare event."</comment><r>***46 lines of code ***</r></pre><pre><b>testF160Division</b><comment>   "Divide fuzzy distributions."</comment><comment>   "A distribution is a Dictionary of p-&gt;f points</comment><comment>   " Niave median is just . . . "</comment><comment>   " But, because there is a long tail . . . "</comment><comment>   "NOTE: Following will fail occasionally."</comment><comment>      "Examine expectedMean"</comment><comment>   "The difference will typically be on the order of 5-15%"</comment><comment>   "It could be close to zero, but that will be a rare event."</comment><r>***42 lines of code ***</r></pre><pre><b>testF170Product</b><comment>   "Multiply fuzzy distributions."</comment><comment>   "A distribution is a Dictionary of p-&gt;f points</comment><comment>   " Niave median is just . . . "</comment><comment>   " But, because there is a long tail . . . "</comment><comment>   "NOTE: Following will fail occasionally."</comment><comment>      "Examine expectedMean"</comment><comment>   "The difference will typically be less than 3%"</comment><comment>   "It could be close to zero, but that will be a rare event."</comment><r>***45 lines of code ***</r></pre><pre><b>testF210PlusOrMinus</b><comment>   "A measure stated as plus-or-minus </comment><comment>   "Use Float #closeto: "</comment><comment>   "Note: Following will fail occasionally."</comment></pre><pre><b>testF230Plus</b><comment>   "Add fuzzy distributions."</comment><comment>   "A distribution is a Dictionary of p-&gt;f points</comment><comment>   " Niave median is just . . . "</comment><comment>   " In this case, the tail is not long. "</comment><comment>   "Examine expectedMean"</comment><comment>   "The difference is typically less than 1% "</comment><comment>   "Transcript cr; show: 'testF230Plus diffMean = ', ( diffMean asString)."</comment><r>***29 lines of code ***</r></pre><pre><b>testF310Mode</b><comment>   "Estimate the mode of a distribution by calculating expected value."</comment></pre><pre><b>testF410Plot</b><comment>   "Estimate the mode of a distribution by calculating expected value."</comment></pre><pre><b>testF430PlotPlus</b><comment>   "Add fuzzy distributions.</comment><comment>   "A distribution is a Dictionary of p-&gt;f points</comment><r>***27 lines of code ***</r></pre><pre><b>testF431PlotPlus</b><comment>   "Add fuzzy distributions.</comment><comment>   "A distribution is a Dictionary of p-&gt;f points</comment><r>***27 lines of code ***</r></pre><pre><b>ztestF410LearnToPlot</b><comment>   "Estimate the mode of a distribution by calculating expected value."</comment><comment>      "verticle grid"</comment><comment>     "horizontal grid"</comment><comment>   "Should we display the canvas?"</comment><comment>      "You can delete morph by double-clicking it."</comment><r>***46 lines of code ***</r></pre><hr/><h3>Hum-Tests -- HumOntologyTests</h3><pre><b>test001newOntology</b><comment>   "create a new Ontology"</comment></pre><pre><b>test100nounTypes</b><comment>   "An entity noun will have attributes."</comment><comment>   "A category noun will have categories."</comment><comment>   "An entity noun may have supertypes and/or subtypes."</comment><comment>   "A plural noun indicates a list or set or bag collection. By default, it indicates a set."</comment><comment>   "A noun may have a synonym. "</comment></pre><pre><b>test102addOneNoun</b><comment>   "Add one noun to current set."</comment></pre><pre><b>test103addTwoNouns</b><comment>   "Add two nouns to current set."</comment><comment>   "Add first noun."</comment><comment>   "Add second noun."</comment><comment>   "Make sure we did not overlay original"</comment></pre><pre><b>test104addArrayOfNouns</b><comment>   "Add array of nouns to current set."</comment><comment>   "Add one noun."</comment><comment>   "Add from array."</comment><comment>   "Add from set."</comment><r>***22 lines of code ***</r></pre><pre><b>test110addEntityAttribute</b><comment>   "Add an entity-attribute relation."</comment><comment>   "Add noun."</comment><comment>   "Add entity-attribute relation."</comment><comment>   "Test"</comment><comment>   "Add a second entity-attribute relation."</comment><comment>   "Test"</comment><r>***21 lines of code ***</r></pre><pre><b>test111getAllAttributesOfNoun</b><comment>   "Add an is-A relation."</comment><comment>   "Define a few relations."</comment><comment>   "The attrbutes include both the supertypes and the attributes of the supertypes."</comment><comment>   "THINK -- Is this what we want?  What will we do with the supertypes?"</comment><comment>   "</comment><comment>   "</comment><r>***27 lines of code ***</r></pre><pre><b>test120addSubtype</b><comment>   "Add an is-A relation."</comment><comment>   "Add noun."</comment><comment>   "Add is-A relation."</comment><comment>   "Test isKindOf"</comment><comment>   "Test subtypes"</comment></pre><pre><b>test121automaticSubtype</b><comment>   "Add an is-A relation."</comment><comment>   "Add noun."</comment><comment>   "Add an automatic subtype."</comment><comment>   "Test isKindOf"</comment><comment>   "Test subtypes"</comment></pre><pre><b>test122getAllSubtypesOfNoun</b><comment>   "Get all subtypes of a noun -- Use at run-time for polymorphism."</comment><comment>   "Add a few subtype-supertype relations."</comment><comment>   "Party has two subtypes (person, organization)."</comment><comment>   "Party has 8 subtypes in the whole subtype tree. "</comment><comment>   "Transcript show: allSubtypes asSortedCollection; cr."</comment><r>***31 lines of code ***</r></pre><pre><b>test123getImmediateSupertypesOfNoun</b><comment>   "Get immediate super types of a noun -- Use when translating to another language ."</comment><comment>   "Add a few subtype-supertype relations."</comment><comment>   "Vendor has one immediate supertype: Vendor is an organization."</comment><comment>   "Supplier has one immediate supertype: Supplier is a vendor."</comment><comment>   "Employee has one immediate supertype: Employee is a worker.."</comment><comment>   "Worker has one immediate supertype: Worker is a party."</comment><comment>   "Party has two subtypes (person, organization)."</comment><comment>   "Party has no supertypes in this ontology."</comment><comment>   "Self-employed-constulant has two immediate supertypes: </comment><r>***54 lines of code ***</r></pre><pre><b>test124getAllSupertypesOfNoun</b><comment>   "Get immediate super types of a noun -- Use when translating to another language ."</comment><comment>   "Add a few subtype-supertype relations."</comment><comment>   "Vendor has one immediate supertype: Vendor is an organization."</comment><comment>   "Supplier has one immediate supertype: Supplier is a vendor."</comment><comment>   "Employee has one immediate supertype: Employee is a worker.."</comment><comment>   "Worker has one immediate supertype: Worker is a party."</comment><comment>   "Party has two subtypes (person, organization)."</comment><comment>   "Party has no supertypes in this ontology."</comment><comment>   "Self-employed-constulant has two immediate supertypes: </comment><comment>   "consultant &gt; worker &gt; person &gt; party; also: consultant &gt; vendor &gt; organization &gt; party"</comment><r>***58 lines of code ***</r></pre><pre><b>test220addOneRole</b><comment>   "Add one role to current set."</comment></pre><pre><b>test230addTwoRoles</b><comment>   "Add two roles  to current set."</comment><comment>   "Add first role."</comment><comment>   "Add second role."</comment><comment>   "Make sure we did not overlay original"</comment></pre><pre><b>test310statementTokens</b><comment>   "A statement is made up of tokens."</comment><comment>   "Make a statement and get its tokens."</comment><comment>   "Tokens are in an ordered collection (array-like)."</comment><comment>    "Tokens are converted to lower case."</comment><comment>   "Tokens include punctuation."</comment></pre><pre><b>test320statementEndsWithPeriodOrColon</b><comment>   "A statement must end with a period or a colon."</comment><comment>   "A statement ending in a period should not raise an error."</comment><comment>   "A statement ending in a colon should not raise an error."</comment><comment>   "A statement not ending in a colon or period should raise an error."</comment><comment>   "Transcript show: statement errors; cr."</comment></pre><pre><b>test330statementHasNouns</b><comment>   "A statement has nouns."</comment><comment>   "The nouns might be defined after the statement is defined. "</comment><comment>   "(Nouns are not completely bound until compile time.)"</comment><r>***21 lines of code ***</r></pre><pre><b>test340statementParsing</b><comment>   "The parser recognizes that tokens are nouns, punctuation, keywords, or just words."</comment><comment>   "The nouns might be defined after the statement is defined. "</comment><comment>   "(Nouns are not completely bound until compile time.)"</comment><comment>   "Get tokenTypes."</comment><comment>   "Check nouns."</comment><comment>   "Check keywords."</comment><comment>   "Check punctuation."</comment><comment>   "Add is only another word.  -- Verbs are not special."</comment><comment>   "The word 'to' is only another word. -- Prepositions are not special."</comment><r>***35 lines of code ***</r></pre><pre><b>test342statementParsingConsolidatesStrings</b><comment>   "A string is delimited by double quotes."</comment></pre><pre><b>test350frameLineSeparateLabelStatementCommentAnnotation</b><comment>   "Generic frameline = ( indent ) ( label : ) ( statement '.' ) ( '(' comment ')' ) ( '[' annotation ']' )</comment><comment>   "</comment></pre><pre><b>test351frameLineParsingRemovesComments</b><comment>   "The parser recognizes that tokens are nouns, punctuation, keywords, or just words."</comment></pre><pre><b>test353frameLineParsingSeparatesAnnotation</b><comment>   "The parser recognizes that tokens are nouns, punctuation, keywords, or just words."</comment></pre><pre><b>test360statementMatchesPatternForEach</b><comment>   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "</comment><comment>   "Match for each"</comment></pre><pre><b>test361statementMatchesPatternForEachInThe</b><comment>   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "</comment><comment>   "Match for each"</comment><comment>   "Preset 'No match' -- to fail fast if the pattern match does not work as expected.'"</comment><comment>   "Fail fast if the result was not reset."</comment><comment>   "This is the result we are expecting."</comment></pre><pre><b>test362statementMatchesPatternIsA</b><comment>   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "</comment><comment>   "Match ___  is a ___"</comment><comment>   "Preset 'No match' -- to fail fast if the pattern match does not work as expected.'"</comment><comment>   "Fail fast if the result was not reset."</comment><comment>   "This is the result we are expecting."</comment></pre><pre><b>test363statementMatchesElse</b><comment>   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "</comment><comment>   "Match 'Else:'"</comment><comment>   "Fail fast if there is no match."</comment><comment>   "The following will fail if the parser thinks there are nouns."</comment><comment>   "Test for no match."</comment><comment>   "This is the result we are expecting."</comment></pre><pre><b>test364statementMatchesCategories</b><comment>   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "</comment><comment>   ". . . categories include blah, blah, blah."</comment></pre><pre><b>test365statementMatchesCategoriesAnd</b><comment>   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "</comment><comment>   ". . . categories include blah, blah, AND blah.'"</comment><comment>   "The word 'and' should be allowed in a list without confusion."</comment></pre><pre><b>test366statementMatchesAttributes</b><comment>   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "</comment><comment>   ". . .  attributes include blah, blah, blah."</comment></pre><pre><b>test367statementMatchesAttributesAnd</b><comment>   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "</comment><comment>   ". . . attributes include . . . blah, blah, AND blah "</comment></pre><pre><b>test410addOneAction</b><comment>   "An action belongs to a role."</comment><comment>   "Set up"</comment><comment>   "Add role."</comment><comment>   "An action is identified by a statement."</comment><comment>   "Add action to the role's set of actions."</comment></pre><pre><b>test420actionInstructions</b><comment>   "An action statement is defined by a sequence of instructions."</comment><comment>   "Set up"</comment><comment>   "Add action to the role's set of actions."</comment><comment>   "Create an instruction."</comment><comment>   " -- Instructions elements are all optional and include role, statement, comment, annotaion, translation."</comment><comment>   "Append instruction to sequence of instructions."</comment><comment>   "test"</comment><comment>   "Create another instruction."</comment><comment>   "Append second instruction to sequence of instructions."</comment><comment>   "test"</comment><r>***38 lines of code ***</r></pre><pre><b>test430createInstructionsInline</b><comment>   "Create instructions in-line using Class methods"</comment><comment>   "Set up"</comment><comment>   "Add action to the role's set of actions."</comment><comment>   "Append first instruction to sequence of instructions."</comment><comment>   "Append second instruction."</comment><r>***24 lines of code ***</r></pre><pre><b>test440getRoleActionStatement</b><comment>   "An action belongs to a role."</comment><comment>   "Set up"</comment><comment>   "Add action to the role's set of actions."</comment><comment>   "Get back the action statement. "</comment><comment>   "It should, of course, match."</comment></pre><pre><b>test441matchActionStatementAgainstCandidate</b><comment>   "Retrieve statement object from ontology when given a similar string."</comment><comment>   "Set up"</comment><comment>   "Add action to the role's set of actions."</comment><comment>   "Check that String&gt;&gt;sameAs: means what we expect."</comment><comment>   "Should be able to retrieve with string that matches our source."</comment><comment>   "Get back the action statement. "</comment><comment>   "Candidate should match when it is word for word the same."</comment><comment>   "Candidate should also match if the articles are dropped or different."</comment><r>***31 lines of code ***</r></pre><pre><b>test442matchActionStatementPolymorphic</b><comment>   "Retrieve appropriate statement with supertype </comment><comment>   "Set up"</comment><comment>   "Define subtypes"</comment><comment>   "Add action to the role's set of actions."</comment><comment>   "Check that String&gt;&gt;sameAs: means what we expect."</comment><comment>   "Should be able to retrieve with string that matches our source."</comment><comment>   "Get back the action statement. "</comment><comment>   "Candidate should match when it is word for word the same."</comment><comment>   "Candidate should also match if the articles are dropped or different."</comment><comment>   "Now prove polymorphism works."</comment><comment>   "But cookie-batch is not defined as a subtype in this ontology.</comment><r>***48 lines of code ***</r></pre><pre><b>test450instructionNounAntecedents</b><comment>   "Nouns in instructions should have antecedants in the action statement.</comment><comment>   "Set up"</comment><comment>   "Add action to the role's set of actions."</comment><comment>   "Append first instruction to sequence of instructions."</comment><comment>   "Append second instruction."</comment><comment>   "In the given instruction sequence, the nouns 'oven' and 'batter' were not seen in the action statement."</comment><r>***31 lines of code ***</r></pre><pre><b>test461Frame4ActionCrossReferences</b><comment>   "Given: An action instruction delegates to another role (or same role).</comment><comment>   "</comment><comment>   "Initialize for an Action Frame."</comment><comment>   "Frames must be compiled if nouns are to be flagged"</comment><comment>  "When: The action frame is compiled."</comment><comment>   "Then: The ontology tracks where (which role-action frame) the action statement is invoked."</comment><comment>   "*** Look under the covers to check expectations. TODO: REFACTOR THIS. *** "</comment><r>***45 lines of code ***</r></pre><pre><b>test510CreatePlanFrame</b><comment>   "Make one plan frame. (TDD to drive basic parts)"</comment><comment>   "A plan frame has a goal. (post condition)"</comment><comment>   "A plan frame has a collection of preconditions."</comment><comment>   "A plan frame has a set of zero or more actions</comment><r>***34 lines of code ***</r></pre><pre><b>test520CheckPlanFrame</b><comment>   "A plan frame SHOULD have a goal and at least two preconditions.</comment><comment>   " </comment><comment>   "Fix that problem."</comment><comment>   "A plan frame SHOULD have at least two preconditions."</comment><comment>   "If there is only one, the business process should be stated as a procedure."</comment><comment>   "Half fix that problem."</comment><comment>   "Fully fix that problem."</comment><r>***36 lines of code ***</r></pre><pre><b>test530AddPlanFrame</b><comment>   "Make one plan frame. (TDD to drive basic parts)"</comment><comment>   "A plan frame should have a goal and at least two preconditions."</comment><comment>   "===</comment><comment>   "</comment><r>***26 lines of code ***</r></pre><pre><b>test540GetPlanTree</b><comment>   "Make several plan frames. Get the resulting plan tree."</comment><comment>   "A plan frame must have a goal and at should have at least two preconditions."</comment><todo>   "TODO: The plan tree is incomplete at this point </todo><comment>   "ontology showPlanTree: planTree."</comment><todo>   "TODO: IS THIS CORRECT? THIS TEST DOES NOT COUNT THE GOAL AT THE ROOT AS PART OF THE PLAN TREE."</todo><r>***41 lines of code ***</r></pre><pre><b>test545DrawPlanTree</b><comment>   "Make several plan frames. Get the resulting plan tree."</comment><comment>   "A plan frame must have a goal and at should have at least two preconditions."</comment><todo>   "TODO: The plan tree is incomplete at this point </todo><comment>   "Transcript cr; show: 'test545DrawPlanTree'; show: planTreeView; cr."
 </comment><r>***34 lines of code ***</r></pre><pre><b>test550CheckPlanTree</b><comment>   "Check for an incomplete plan."</comment><comment>   "A plan frame must have a goal and should have at least two preconditions."</comment><comment>   "</comment><comment>   "</comment><r>***36 lines of code ***</r></pre><pre><b>test610renderStatementAsHTML</b><comment>   "In the HTML rendering, statement nouns are enclosed in &lt;n&gt;...&lt;/n&gt; to enable style sheet rendering."</comment><comment>   "The nouns might be defined after the statement is defined. "</comment></pre><pre><b>test611renderInstructionLines</b><comment>   "Create instructions in-line using Class methods"</comment><comment>   "Set up"</comment><comment>   "Add action to the role's set of actions."</comment><comment>   "Append first instruction to sequence of instructions."</comment><comment>   "Append second instruction."</comment><comment>   "Initialize for a Dictionary Frame."</comment><comment>   "Frames must be compiled before rendering if nouns are to be flagged."</comment><r>***33 lines of code ***</r></pre><pre><b>test620renderFrame4PlanAsHTML</b><comment>   "The frame editor instance knows what kind of frame it is editing.</comment><comment>   "</comment><comment>   "Initialize for a Plan Frame."</comment><comment>   "Frames must be compiled before rendering if nouns are to be flagged."</comment><comment>   "Test:  Is the goal-statement included in the HTML ?"</comment><comment>   "Test: Are each of the preconditions included ?"   </comment><comment>   "Test: Is the action instruction role and statment included ?"</comment><comment>   "HTML should include a 'Preconditions' subheading."</comment><comment>   "HTML should include a 'Actions' subheading."</comment><comment>   "HTML should include nouns flags"</comment><comment>   "Preconditions should have nouns marked"</comment><comment>   "Actions should have nouns marked."</comment><comment>   "Goal should have nouns marked."</comment><r>***44 lines of code ***</r></pre><pre><b>test625renderPlanTreeAsHTML</b><comment>   "Make several plan frames. Get the resulting plan tree."</comment><comment>   "A plan frame must have a goal and at should have at least two preconditions."</comment><comment>      "Create a Dictionary Frame."</comment><r>***57 lines of code ***</r></pre><pre><b>test626renderNounTreeAsHTML</b><comment>   "Define a dictionary with more than one level. Render as a noun tree."</comment><comment>      "Create a Dictionary Frame."</comment><todo>"TODO: HumCalculator translates &lt;&gt; to &lt; &gt;"</todo><r>***47 lines of code ***</r></pre><pre><b>test630renderFrame4ActionAsHTML</b><comment>   "Given: The frame editor contains a role-action frame.</comment><comment>   "</comment><comment>   "Initialize for an Action Frame."</comment><comment>   "Frames must be compiled if nouns are to be flagged"</comment><comment>   "Test: Title line is rendered."</comment><comment>   "First instruction is rendered."</comment><comment>   "2nd instruction is rendered."</comment><comment>   "3rd instruction is rendered."</comment><comment>   "4th inststruction statement is rendered"</comment><comment>   "Comment is rendered"</comment><comment>   "Role is rendered."</comment><comment>   "HTML should include 'Action:' label."</comment><comment>   "Avoid double-space bug"</comment><comment>   "html inspect."</comment><r>***53 lines of code ***</r></pre><pre><b>test640renderFrame4ViewAsHTML</b><comment>   "Given: The frame editor instance knows what kind of frame it is editing.</comment><comment>   "</comment><comment>   "Initialize for a View Frame."</comment><comment>   "Test that labels are present in the rendering."</comment><comment>   "Title line"</comment><comment>   "1st markup line"</comment><comment>   "2nd markup line"</comment><comment>   "3rd markup line"</comment><comment>   "4th (last) marup line"</comment><comment>   "Test that widgets are present in the rendering."</comment><comment>   "1st markup line"</comment><comment>   "2nd markup line -- TODO: Should be multi-line box."</comment><comment>   "3rd markup line -- TODO: Should be input-table.  (HOW?) "</comment><comment>   "4th markup line -- TODO: Should be input-table.  (HOW?) "</comment><todo>   "TODO: WIDGETS NEED TO BE ARTICULATED BY TYPE."</todo><comment>   "Inspect -- paste result into HTML tool/file."</comment><comment>   "html inspect."</comment><r>***51 lines of code ***</r></pre><pre><b>test641renderRadioButtonAsHTML</b><comment>   "Given: The frame editor instance knows what kind of frame it is editing.</comment><comment>   "</comment><comment>   "Initialize for a View Frame."</comment><comment>   "Test that labels are present in the rendering."</comment><comment>   "Title lines"</comment><comment>   "Are radio widgets rendered?"</comment><comment>   "Expect radio button"</comment><comment>   "Inspect -- paste result into HTML tool/file."</comment><comment>   "html inspect."</comment><r>***34 lines of code ***</r></pre><pre><b>test642renderCheckBoxAsHTML</b><comment>   "Given: The frame editor instance knows what kind of frame it is editing.</comment><comment>   "</comment><comment>   "Initialize for a View Frame."</comment><comment>   "Test that labels are present in the rendering."</comment><comment>   "Title lines"</comment><comment>   "Are widgets rendered?"</comment><comment>   "Expect radio button"</comment><comment>   "Watch for bug"</comment><comment>   "Inspect -- paste result into HTML tool/file."</comment><comment>   "html inspect."</comment><r>***38 lines of code ***</r></pre><pre><b>test643renderTextAsHTML</b><comment>   "Given: The frame editor instance knows what kind of frame it is editing.</comment><comment>   "</comment><comment>   "Initialize for a View Frame."</comment><comment>   "Test that labels are present in the rendering."</comment><comment>   "Title lines"</comment><comment>   "Are widgets rendered?"</comment><comment>   "Check textarea tag attributes."</comment><comment>   "Inspect -- paste result into HTML tool/file."</comment><comment>   "html inspect."</comment><r>***36 lines of code ***</r></pre><pre><b>test650renderFrame4DictionaryAsHTML</b><comment>   "The frame editor instance knows what kind of frame it is editing.</comment><comment>   "</comment><comment>   "Initialize for a Dictionary Frame."</comment><comment>   "Note: String&gt;&gt;match: is not case sensitive.</comment><r>***31 lines of code ***</r></pre><pre><b>test680renderOntologyAsHTML</b><comment>   "Render an ontology object in HTML and store on given filename."</comment><comment>   "Create a Plan Frame."</comment><comment>   "Create an Action Frame."</comment><comment>   "Create a Dictionary Frame."</comment><comment>   "Create a View Frame."</comment><comment>   "Frames must be compiled if nouns are to be marked."</comment><comment>   "Frames should be have horizontal lines between."</comment><comment>   "Should see some nouns flagged."</comment><r>***66 lines of code ***</r></pre><pre><b>test690renderOntologyAsHTMLonFile</b><comment>   "Render an ontology object in HTML and store on given filename."</comment><comment>   "Create an Action Frame."</comment><comment>   "Create a Dictionary Frame."</comment><comment>   "Create a View Frame."</comment><comment>   "Frames must be compiled if nouns are to be marked."</comment><comment>   "Write on a file."</comment><r>***70 lines of code ***</r></pre><pre><b>test900checkUsability</b><comment>   "Test the pattern matching.</comment><comment>   "</comment><comment>   "Test using a dictionary statement pattern."</comment><comment>   "Create a frame line that will match the pattern."</comment><comment>   "Should match"</comment><comment>   "Generate some code"</comment><comment>   "Check usability -- What if we wanted to generate Smalltalk?"</comment><comment>   "Check usability -- What if we wanted to generate Java?  </comment><comment>   "Check usability -- What if we wanted to generate JavaScript?"</comment><comment>   "Check usability -- What if we wanted to generate Erlang?</comment><comment>   "</comment><comment>   "Check usability -- What if we wanted to generate Python?</comment><comment>   "Generate arbitrary code"</comment><r>***46 lines of code ***</r></pre><pre><b>test910lineMatchesPattern</b><comment>   "Test the pattern matching.</comment><comment>   "</comment><comment>   "Test using a dictionary statement pattern."</comment><comment>   "Create a frame line that will match the pattern."</comment><comment>   "Should match"</comment></pre><pre><b>test911lineDoesNotMatchPattern</b><comment>   "Test the pattern matching.</comment><comment>   "</comment><comment>   "Test using a dictionary statement pattern."</comment><comment>   "Create a frame line that will match the pattern."</comment><comment>   "Should not match"</comment></pre><pre><b>test912lineMatchesFloatingPattern</b><comment>   "Test the pattern matching.</comment><comment>   "</comment><comment>   "Test using a dictionary statement pattern."</comment><comment>   "Create a frame line that will match the pattern."</comment><comment>   "Should match"</comment></pre><pre><b>test913lineMatchesFloatingPattern</b><comment>   "Test the pattern matching.</comment><comment>   "</comment><comment>   "Test using a dictionary statement pattern."</comment><comment>   "Create a frame line that will match the pattern."</comment><comment>   "Should match"</comment></pre><pre><b>test914lineMatchesFloatingPattern</b><comment>   "Test the pattern matching.</comment><comment>   "</comment><comment>   "Test using a dictionary statement pattern."</comment><comment>   "Create a frame line that will match the pattern."</comment><comment>   "Should match"</comment></pre><pre><b>test915lineFailsFloatingPattern</b><comment>   "Test the pattern matching.</comment><comment>   "</comment><comment>   "Test using a dictionary statement pattern."</comment><comment>   "Create a frame line that will match the pattern."</comment><comment>   "Should match"</comment></pre><pre><b>test920lineMatchesPatternParameters</b><comment>   "Test the pattern matching.</comment><comment>   "</comment><comment>   "Test using a dictionary statement pattern."</comment><comment>   "Create a frame line that will match the pattern."</comment><comment>   "Should match"</comment><comment>   "Get parameters"</comment></pre><pre><b>test922lineMatchesFloatingPatternParameters</b><comment>   "Test the pattern matching.</comment><comment>   "</comment><comment>   "Test using a dictionary statement pattern."</comment><comment>   "Create a frame line that will match the pattern."</comment><comment>   "Should match"</comment><comment>   "Get parameters"</comment></pre><pre><b>test923lineMatchesFloatingPatternParameters</b><comment>   "Test the pattern matching.</comment><comment>   "</comment><comment>   "Test using a dictionary statement pattern."</comment><comment>   "Create a frame line that will match the pattern."</comment><comment>   "Should match"</comment><comment>   "Get parameters"</comment></pre><pre><b>test930generateCode</b><comment>   "Generate some code that does not require that we find a singular noun.</comment><comment>   "</comment><comment>   "Test using a dictionary statement pattern."</comment><comment>   "Create a frame line that will match the pattern."</comment><comment>   "Should match"</comment><comment>   "Generate some code"</comment><comment>   "Check usability -- What if we wanted to generate JavaScript?"</comment><comment>   "Generate arbitrary code"</comment><r>***25 lines of code ***</r></pre><hr/><h3>Hum-Tests -- HumOntologyTranslatorTests</h3><pre><b>assertExpectedTokensIn: expected matchesTokensIn: actual</b><comment>   "Compare the two strings as a stream of tokens.</comment><comment>   "</comment><comment>         "Note failing this assert will halt the loop."</comment><return>   ^ self</return><r>***28 lines of code ***</r></pre><pre><b>bakeThePanInTheOvenForTheTimeGivenInTheRecipeQpan: aPan oven: aOven time: aTime recipe: aRecipe </b><comment>   "Open the oven door. "</comment><comment>   "Place the pan in the oven. "</comment><comment>   "Close the oven door. "</comment><comment>   "Oven: Heat for the time given in the recipe.We have a smart oven."</comment></pre><pre><b>fulfillOrderQorder: aOrder </b><comment>   "For each order-item in the order: "</comment><comment>      "Pull order-item from stock and place on cart. "</comment><comment>   "Ship the order to the order-address. "</comment></pre><pre><b>test010AssertExpectedTokensInAMatchesTokensInB</b><comment>   "Test the utility with the cases that matter to me."</comment><comment>   "Two cases that differ only in white space will match"</comment><comment>   "Two cases that differ in substance will fail"</comment></pre><pre><b>test110AttachMethodToClass</b><comment>   "Attach a method to a class."</comment><comment>   "Example in Java syntax with Hum accounting"</comment><todo>   "TODO: Need some asserts."</todo></pre><pre><b>test111GetMethodsForClass</b><comment>   "Attach a method and get it back."</comment><comment>   "Example in Java syntax with Hum accounting"</comment><comment>   "Now get it back."</comment><r>***24 lines of code ***</r></pre><pre><b>test120AttachClassPrologue</b><comment>   "Attach prologue source lines to an actor class.</comment><comment>   "</comment><comment>   "Example in Java syntax with Hum accounting.</comment><comment>   "An Actor`s implementation in Java or Erlang must reside in a file of the same name.</comment><comment>   "</comment><r>***33 lines of code ***</r></pre><pre><b>test370forStatementAsSmalltalk</b><comment>   "Translate for . . .    to Smalltalk"</comment><comment>   "---</comment><comment>   "</comment><comment>   "Add entity-attribute relation."</comment><comment>   "Translate the Hum 'For . . . '   statement into Smalltalk."</comment><comment>   "smalltalkCode := forStatement asSmalltalkWithOntology: ontology."</comment><comment>   "Expect: </comment><comment>   "</comment><comment>   "</comment><comment>   "</comment><r>***31 lines of code ***</r></pre><pre><b>test380ifStatementAsSmalltalk</b><comment>   "Translate if . . .   to  Smalltalk"</comment></pre><pre><b>test381ifStatementAsSmalltalk</b><comment>   "Translate if . . .   to  Smalltalk"</comment></pre><pre><b>test382ifStatementAsSmalltalk</b><comment>   "Translate if . . .   to  Smalltalk"</comment></pre><pre><b>test383ifStatementAsSmalltalk</b><comment>   "Translate if . . .   to  Smalltalk"</comment></pre><pre><b>test384ifStatementAsSmalltalk</b><comment>   "Translate if . . .   to  Smalltalk"</comment></pre><pre><b>test385ifStatementAsSmalltalk</b><comment>   "Translate if . . .   to  Smalltalk"</comment></pre><pre><b>test390elseStatementAsSmalltalk</b><comment>   "Translate if . . .  else . . .  to Smalltalk"</comment><todo>   "TODO: Figure out how to translate 'Else:' from Hum to Smalltalk."</todo></pre><pre><b>test710translateFrame4ActionToSmalltalk</b><comment>   "Given: a Hum action frame.</comment><comment>   "</comment><comment>   "Initialize for an Action Frame."</comment><comment>   "Test: Title line is rendered."</comment><comment>   "First instruction is rendered."</comment><comment>   "2nd instruction is rendered."</comment><comment>   "3rd instruction is rendered."</comment><comment>   "4th (delegated) inststruction is rendered"</comment><comment>   "Comment is rendered"</comment><comment>   "Role is rendered."</comment><comment>   "Transcript cr; show: 'Generated Smalltalk:'; cr; show: code; cr."</comment><todo>   "TODO: Review the translation methods to assure consistency in how nouns are handled.</todo><comment>   "</comment><comment>   "code inspect."</comment><r>***47 lines of code ***</r></pre><pre><b>test720translateFrame4ActionToSmalltalk</b><comment>   "Given: a Hum action frame.</comment><comment>   "</comment><comment>   "Initialize for an Action Frame."</comment><comment>   "Transcript cr; show: 'Generated Smalltalk:'; cr; show: code; cr."</comment><comment>   "Test: Title line is rendered."</comment><comment>   "First instruction is rendered."</comment><comment>   "2nd instruction is rendered."</comment><comment>   "3rd instruction is rendered."</comment><comment>   "4th (delegated) inststruction is rendered"</comment><comment>   "Comment is rendered"</comment><comment>   "Role is rendered."</comment><r>***43 lines of code ***</r></pre><pre><b>test730translateFrame4ActionToSmalltalkExdentToBlockEnd</b><comment>   "Given: a Hum action frame.</comment><comment>   "</comment><comment>   "Initialize for an Action Frame."</comment><comment>   "Enter an iteration statement."</comment><comment>   "Enter some inside the loop. (It should be indented when rendered.)"</comment><comment>   "THINK: Should we require indentation here."</comment><comment>   "Next statement has no indent. That signals end of the iteration block."</comment><comment>   "</comment><comment>   "</comment><comment>   "Test: Title line is rendered."</comment><comment>   "For is implemented by do:"</comment><comment>   "Look for opening and closing ']' on the block."</comment><comment>   "Watch for proper close on the do: []. "</comment><comment>   "Watch for proper position for closing ']'"</comment><comment>   "code inspect."</comment><r>***60 lines of code ***</r></pre><pre><b>testE210translateActionHeaderToErlang</b><comment>   "Translate Hum action header to Erlang do pattern.</comment><comment>   "</comment><comment>   "Our strategy involves a generic do( ... ) pattern that receives the message."</comment><comment>   "Given: ontology knows which words are nouns"</comment><comment>   "When: Action header is translated to Erlang do header"</comment><comment>   "Then: The do header looks like 'do( { action-statement, noun-values } )' "</comment><todo>   "TODO: The Erlang boiler plate must assure that the do() will be invoked </todo><r>***27 lines of code ***</r></pre><pre><b>testE220translateActionCallToErlang</b><comment>   "Translate a Hum action call to an Erlang call."</comment><comment>   "Our strategy involves a generic calling pattern that sends the message."</comment><comment>   "Given: The ontology knows which words are nouns"</comment><comment>   "When: Action call is translated to Erlang call"</comment><comment>   "Then: The message passed to the Dispatcher looks like { roleAtom, ActionStatement, NounValues }."</comment><comment>   "Note: The role is translated to an Erlang atom."</comment><comment>   "self assert: (( '*', expectedMessage, '*' ) match: erlangSource )."</comment><comment>   "Then: The call looks like '?CALL({Role,Action,NounValues}).'"</comment><comment>   "?CALL is an Erlang macro that will probably become 'gen_supervisor:call( dispatcher, ' </comment><comment>   "Transcript cr; show: 'in test220translateActionCallToErlang';</comment><r>***25 lines of code ***</r></pre><pre><b>testE230translateInstructionToErlang</b><comment>   "Translate Hum instruction (invoke) to Erlang do()."</comment><comment>   "Our strategy involves a generic calling pattern that sends the message."</comment><comment>   "Given: ontology knows which words are nouns."</comment><todo>   "TODO: In the actual instruction the nouns may be replaced by subtypes.</todo><comment>   "</comment><comment>   "When: Action call is translated to Erlang call"</comment></pre><pre><b>testE310translatePlanFramesToErlang</b><todo>   "TODO: Decide how to do this.</todo><comment>   "</comment><comment>   "*** TODO: Write the HumCoordinator agent in Erlang. *** (Confirm that Alternative-C is workable.)"</comment><comment>   "*** See: HumCoordinator&gt;&gt;runPlanFrameForCondition: aGoalString ***"</comment><r>***39 lines of code ***</r></pre><pre><b>testE311translatePreconditionsToErlangList</b><comment>   "Translate a plan-frame`s preconditions to an Erlang list.</comment><comment>   "</comment><comment>   "A plan frame should have a goal and at least two preconditions."</comment><comment>   "erlangCode inspect."</comment><r>***30 lines of code ***</r></pre><pre><b>testE400ReadMe</b><comment>   "Thinking Out Loud:</comment><comment>   "</comment><r>***27 lines of code ***</r></pre><pre><b>testE410translateEntityToErlang</b><comment>   "An entity is translated into an Erlang record structure.</comment><comment>   "I will keep this code around for a little while."</comment><comment>   "Note: This implies that we have records nested in records. </comment><todo>   "TODO: Decide if we nest records or refer to the inner attribute entity via an identifier."</todo><todo>   "TODO: . . . If so, it means that every entity has a hidden attribute . . . &lt;entity name&gt;-identifier."</todo><todo>   "TODO: Decide how to pass attribute values. -- That will partially resolve the question above."</todo><todo>   "TODO: Current implementation does not order the attributes."</todo><comment>   "erlangCode inspect."</comment><r>***33 lines of code ***</r></pre><pre><b>testE500RoleReadMe</b><comment>   "Strategy: Each each role becomes an Erlang module."</comment></pre><pre><b>testE510RoleModuleHeader</b><comment>   "A role becomes a module. Here we check the module declaration."</comment><comment>   "Create a role-action frame in an ontology."</comment><comment>      "Instruction for self."</comment><comment>   "Delegated instruction."</comment><comment>   "Define subtype supertype relation."</comment><r>***21 lines of code ***</r></pre><pre><b>testE520RoleModuleHeaderExport</b><comment>   "A role becomes a module. Here we check the module header export declarations."</comment><comment>   "Create a role-action frame in an ontology."</comment><comment>   "Instruction for self."</comment><comment>   "Delegated instruction."</comment><comment>   "Define subtype supertype relation."</comment><comment>   "Erlang action calls invoke do( {  statementString, NounValues } )."</comment><todo>   "TODO: Confirm OTP exports if OTP is used."</todo><r>***24 lines of code ***</r></pre><pre><b>testE525RoleModuleHeaderMacros</b><comment>   "When a role delegates an action, a ?CALL macro is invoked. "</comment><comment>   "Create a role-action frame in an ontology."</comment><comment>   "Instruction for self."</comment><comment>   "Delegated instruction."</comment><comment>   "Define subtype supertype relation."</comment><comment>   "Erlang action calls invoke do( {  statementString, NounValues } )."</comment><todo>   "TODO: Confirm OTP exports if OTP is used."</todo><comment>   "Check for CALL macro define."</comment><comment>   "-define( CALL( Role, Statement, NounValues ), ?TBD( Role, Statement, NounValues )."</comment><comment>   "Call is routed to a role-qualified actor via Hum Dispatcher and Hum Messenger."</comment><r>***28 lines of code ***</r></pre><pre><b>testE530RoleModuleActionFrames</b><comment>   "A role becomes a module. Here we check the module header export declarations."</comment><comment>   "Create a role-action frame in an ontology."</comment><comment>   "Instruction for self."</comment><comment>   "Delegated instruction."</comment><comment>   "Define subtype supertype relation."</comment><todo>   "TODO: Noun bake-time is attribute of recipe."</todo><comment>   "Erlang action calls invoke do( {  statementStringAtom, NounValues } )."</comment><comment>   "Expect to see function definition corresponding to action statement."</comment><comment>   "NounValues become: [ {'cake', Cake}, {'recipe', Recipe} ] -- Note: single-quotes are doubled here."</comment><comment>   "Expect to see self-call corresponding to instruction."</comment><comment>   "NounValues become: [ {'cake-pan', CakePan} ]"</comment><comment>   "Expect to see delegated call via macro."</comment><comment>   "NounValues becomes: [ {'recipe bake-time', BakeTime} ] -- NOTE: Noun bake-time is attribute of recipe."</comment><comment>   "Entity attribute needs a slightly different noun-value key."</comment><r>***43 lines of code ***</r></pre><pre><b>testH110tranlateEmphasis</b><comment>   "*text* becomes bold, ~text~ becomes italic, _text_ becomes underline, ^text^ becomes superscript"</comment></pre><pre><b>testH115tranlateEmphasisAtEnd</b><comment>   "*text* becomes bold, ~text~ becomes italic, _text_ becomes underline, ^text^ becomes superscript"</comment></pre><pre><b>testH120tranlatePageWidget</b><comment>   "Translate [page:text] into HTML anchor element"</comment></pre><pre><b>testH125tranlatePageWidgetAtEnd</b><comment>   "Translate [page:text] into HTML anchor element - test for bug when widget is at line end."</comment></pre><pre><b>testH130tranlateLinkWidget</b><comment>   "Translate [link: text | URL ] into HTML anchor element"</comment></pre><pre><b>testH140tranlateImageWidget</b><comment>   "Translate [link: text | URL ] into HTML anchor element"</comment></pre><pre><b>testH210tranlateButtonWidget</b><comment>   "Translate [[label]] into HTML button element"</comment></pre><pre><b>testH215tranlateButtonWidgetAtLineEnd</b><comment>   "Translate [[label]] into HTML button element -- Test for bug when widget is at end of line."</comment></pre><pre><b>testH216tranlateButtonWidgetAtLineEnd</b><comment>   "Translate [[label]] into HTML button element -- Test for bug when widget is at end of line."</comment></pre><pre><b>testH220tranlateCheckBox</b><comment>   "Translate [z] into HTML checkbox element."</comment></pre><pre><b>testH230tranlateRadioButtons</b><comment>   "Translate (a) into HTML radio-button element."</comment><todo>"TODO: FIGURE OUT HOW TO GROUP RADIO BUTTONS."</todo></pre><pre><b>testH310tranlateTableRow</b><comment>   "Translate | ... | ... | into table elements."</comment></pre><pre><b>testH320tranlateTableRowWithEmphasis</b><comment>   "Translate | ... | ... | into table elements."</comment></pre><pre><b>testH330tranlateHeading</b><comment>   "Translate !!! into HTML heading"</comment></pre><pre><b>testH340tranlateHeadingWithEmphasis</b><comment>   "Translate !!! into HTML heading"</comment></pre><pre><b>testH350tranlateListItem</b><comment>   "Translate !!! into HTML heading"</comment></pre><pre><b>testH360tranlateListItemWithEmphasis</b><comment>   "Translate !!! into HTML heading"</comment></pre><pre><b>testH410tranlateAttributeWidget</b><comment>   "Translate [attribute] into input tag."</comment></pre><pre><b>testH420tranlateTextAreaWidget</b><comment>   "Translate [attribute 9] into textarea tag."</comment><r>***24 lines of code ***</r></pre><pre><b>testH430tranlateEntityAttributeWidget</b><comment>   "Translate [entity`s attribute] into input tag."</comment></pre><pre><b>testJ805translateStatementToCamelcase</b><comment>   "A statement is translated directly to CamelCase."</comment></pre><pre><b>testJ806translateStatementToCamelcase</b><comment>   "A statement is translated directly to CamelCase, but articles are dropped."</comment></pre><pre><b>testJ810translateFrame4ActionToJava</b><comment>   "Given: a Hum action frame.</comment><comment>   "</comment><comment>   "Initialize for an Action Frame."</comment><comment>   "Transcript cr; show: 'test810translateFrame4ActionToJava Generated Java'; cr; show: code; cr."</comment><comment>   "Test: Title line is rendered."</comment><todo>   "TODO: The generated Java code (see below) will not compile because 'aDoor' is not defined."</todo><comment>   "QUESTION: Is 'aDoor' a noise-word in this context? Do we really need it?"</comment><comment>   "QUESTION: Should we/Could we fix the problem by adding a local variable declaration where needed?"   </comment><comment>   "First instruction is rendered."</comment><comment>   "2nd instruction is rendered."</comment><comment>   "3rd instruction is rendered."</comment><comment>   "4th (delegated) inststruction is rendered"</comment><comment>   "Comment is rendered"</comment><comment>   "Code ends with a bracket"</comment><comment>   "Code should not contain doubled semi-colon.  (Test for bug)"</comment><comment>   "code inspect."</comment><r>***52 lines of code ***</r></pre><pre><b>testJ811translateFrame4ActionToJava</b><comment>   "Given: a Hum action frame with a hyphenated noun.</comment><comment>   "</comment><comment>   "Initialize for an Action Frame."</comment><comment>   "Transcript cr; show: 'testJ811translateFrame4ActionToJava Generated Java'; cr; show: code; cr."</comment><comment>   "Test: Title line is rendered."</comment><todo>   "TODO: The generated Java code (see below) will not compile because 'aDoor' is not defined."   </todo><comment>   "First instruction is rendered."</comment><comment>   "2nd instruction is rendered."</comment><comment>   "3rd instruction is rendered."</comment><comment>   "4th (delegated) inststruction is rendered"</comment><comment>   "Comment is rendered"</comment><comment>   "Code ends with a bracket"</comment><comment>   "Code should not contain doubled semi-colon.  (Test for bug)"</comment><todo>   "TODO: Test for case where noun is a hyphenated term."</todo><comment>   "code inspect."</comment><r>***50 lines of code ***</r></pre><pre><b>testJ820translateDictionaryToJava</b><comment>   "Entity becomes class. Attribute becomes String, Category, ..."</comment><comment>   "Define a few relations."</comment><comment>   "Transcript cr; show: 'test820translateDictionaryToJava'; cr; show: code; cr; show: '%%%%%%%%%%'; cr."</comment><comment>   "Expect each entity to become a class declaration."</comment><comment>   "Entities extend their Hum supertype."</comment><comment>   "Attributes with no supertype are Strings by default"</comment><comment>   "Attributes with supertypes declare accordingly"</comment><comment>   "Classes have closing brace."</comment><comment>   "Expect 'extends' clauses for subtypes."</comment><comment>   "Expect 'category' to be detected."</comment><comment>   "Check for bug:"</comment><comment>   "code inspect."</comment><r>***74 lines of code ***</r></pre><pre><b>testJ825translateCollectionNounToJava</b><comment>   "Test a more complicated dictionary with a collection and recursive structure."</comment><comment>   "Define a few relations."</comment><comment>   "Translate to Java"   </comment><comment>   "Expect each entity to become a class declaration."</comment><comment>   "Entities extend their Hum supertype."</comment><comment>   "Attributes with no supertype are Strings by default"</comment><comment>   "Attributes with supertypes declare accordingly"</comment><comment>   "Classes have closing brace."</comment><todo>   "TODO: By default a collection is a Bag&lt;Entity&gt;. </todo><comment>   "code  inspect."</comment><r>***45 lines of code ***</r></pre><pre><b>testJ830translateFrame4ActionToJavaExdentToBlockEnd</b><comment>   "Given: a Hum action frame.</comment><comment>   "</comment><comment>   "Initialize for an Action Frame."</comment><comment>   "Enter an iteration statement."</comment><comment>   "Enter some inside the loop. (It should be indented when rendered.)"</comment><comment>   "THINK: Should we require indentation here."</comment><comment>   "Next statement has no indent. That signals end of the iteration block."</comment><comment>"   Transcript cr; </comment><comment>"   </comment><comment>   "Test: Title line is rendered."</comment><comment>   "Test: 'For each order-item in the order:' "</comment><comment>   "Look for opening and closing '} // for' on the block."</comment><comment>   "code inspect."</comment><r>***60 lines of code ***</r></pre><pre><b>testJ840translatePlanFrameToJava</b><comment>   "The plan is data, so translation involves translating each goal frame into a series of Java setters.</comment><comment>   "</comment><comment>   "javaCode inspect."</comment><r>***36 lines of code ***</r></pre><hr/><h3>Hum-Tests -- HumProgrammersAssistantTests</h3><pre><b>aReadMe</b><comment>   "See the class description for the intended (future) tests."</comment><return>   ^'See the class description for the intended (future) tests.'</return></pre><pre><b>storeInOntology: aHumOntology fromFrameUpdater: frameUpdater1</b><comment>   "The frame editor receives the command to store the frame from the user interface (Scribe)."</comment><comment>   "The frame will now have a uniqueIdentifier."</comment><comment>   "We can use the identifier to fetch the frame into another frameUpdater."</comment><comment>   "Check the content."</comment><comment>   "Check the content."</comment><r>***36 lines of code ***</r></pre><pre><b>test110newOntology</b><comment>   "PA initializes (re-initializes) to an empty ontology."</comment></pre><pre><b>test120saveOntology</b><comment>   "PA saves (writes) the ontology to a file."</comment></pre><pre><b>test130loadOntology</b><comment>   "PA loads (reads) the ontology fram a file where it was saved previously."</comment></pre><pre><b>test200createFrame</b><comment>   "There are seven types of frame: (See HumFrame hierarchy)</comment><comment>   "</comment></pre><pre><b>test220createFrame4Plan</b><comment>   "Test a plan frame (goal frame).</comment><comment>   "</comment><comment>   "Initialize for a Plan Frame."</comment><comment>   "Append precondition lines."</comment><comment>   "Finish with action statement."</comment><r>***28 lines of code ***</r></pre><pre><b>test230createFrame4Action</b><comment>   "The frame editor instance knows what kind of frame it is editing.</comment><comment>   "</comment><comment>   "Initialize for an Action Frame."</comment><comment>   "Append instruction lines."</comment><comment>   "Append an instruction that is delegated"</comment><r>***25 lines of code ***</r></pre><pre><b>test231formatFrame4Action</b><comment>  "The frame editor instance knows what kind of frame it is editing.</comment><comment>  "</comment><comment>  "Initialize for an Action Frame."</comment><comment>  "Append instruction lines."</comment><comment>  "Append an instruction that is delegated"</comment><r>***39 lines of code ***</r></pre><pre><b>test240createFrame4View</b><comment>   "The frame editor instance knows what kind of frame it is editing.</comment><comment>   "</comment><comment>   "Initialize for a View Frame."</comment><comment>   "Add markup lines."</comment></pre><pre><b>test250createFrame4Dictionary</b><comment>   "The frame editor instance knows what kind of frame it is editing.</comment><comment>   "</comment><comment>   "Initialize for a Dictionary Frame."</comment><comment>   "Add dictionary lines."</comment><comment>   "attributes"</comment><comment>   "set collection"</comment><comment>   "list collection"</comment><comment>   "Attribute used in  set above is an entity with its own attributes. Entities are members of set."</comment><comment>   "Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"</comment><r>***25 lines of code ***</r></pre><pre><b>test260createFrame4Vignette</b><comment>   "Create a dialog vignette..</comment><comment>   "</comment><comment>   "Initialize for a Dictionary Frame."</comment></pre><pre><b>test261updateFrame4Vignette</b><comment>   "Create a dialog vignette.</comment><comment>   "</comment><comment>   "Initialize for a Dialog Frame."</comment><comment>   "Add response lines."</comment><comment>   "There are two kinds of resonse, verbal responses and actions."</comment><r>***33 lines of code ***</r></pre><pre><b>test270createFrame4Comment</b><comment>   "Create with a comment frame..</comment><comment>   "</comment><comment>   "Initialize for a Comment Frame."</comment></pre><pre><b>test300codeCriticFeatures</b><comment>   "The code critic generates errors and warnings for each type of frame."</comment><comment>   "General syntax in most frames:</comment><comment>   "</comment><comment>   "For statements in any frame:</comment><comment>   "</comment><comment>   "For plan frames:</comment><comment>   "</comment><comment>   "For dictionary frames:</comment><comment>   "</comment><comment>   "For vignette frames:</comment><comment>   "</comment><comment>   "For widgets:</comment><comment>   "</comment><comment>   "For text markup in view and vignette:</comment><comment>   "</comment><r>***52 lines of code ***</r></pre><pre><b>test320critiqueFrame4Plan</b><comment>   "Check plan frame - no known nouns - no plans</comment><comment>   "</comment><comment>   "Initialize for a Plan Frame."</comment><comment>   "Append precondition lines."</comment><comment>   "Finish with action statement."</comment><comment>   "Expect complaints about no nouns."</comment><comment>   "Expect complaints about preconditions with no plans."</comment><comment>   "Transcript cr; show: 'test320critiqueFrame4Plan Errors: ', errors asString; cr."</comment><r>***29 lines of code ***</r></pre><pre><b>test321critiqueFrame4Plan</b><comment>   "Detect: Every precondition has a noun that traces back to the goal statement.</comment><comment>   "</comment><comment>   "Initialize for a Plan Frame."</comment><comment>   "Append precondition lines."</comment><comment>   "Finish with action statement."</comment><comment>   "Every line has recipe as a noun."</comment><comment>   "Expect no complaints about no nouns. "</comment><r>***26 lines of code ***</r></pre><pre><b>test322critiqueFrame4PlanMissingAntecedant</b><comment>   "Detect: One or more preconditions have a noun with no antecedant in the goal statement.</comment><comment>   "</comment><comment>   "Initialize for a Plan Frame."</comment><comment>   "Append precondition lines."</comment><comment>   "Finish with action statement."</comment><comment>   "Every line has recipe as a noun."</comment><comment>   "Expect 'no antecedant' complaints "</comment><r>***26 lines of code ***</r></pre><pre><b>test330critiqueFrame4Action</b><comment>   "Detect: No known nouns.</comment><comment>   "</comment><comment>   "Initialize for an Action Frame."</comment><comment>   "Append instruction lines."</comment><comment>   "Append an instruction that is delegated"</comment><comment>   "Expect  complaints about no nouns on every line because the ontology has not been informed."</comment><comment>   "Check the simple instructions."</comment><comment>   "Check the last one - It is delegated."</comment><comment>   "The action line should have nouns too."</comment><r>***41 lines of code ***</r></pre><pre><b>test331critiqueFrame4Action</b><comment>   "Detect: Some nouns, but still not enough.</comment><comment>   "</comment><comment>   "Initialize for an Action Frame."</comment><comment>   "Append instruction lines."</comment><comment>   "Append an instruction that is delegated"</comment><comment>   "Still expect one complaints about no nouns on the last line."</comment><r>***26 lines of code ***</r></pre><pre><b>test332critiqueFrame4ActionForAntecedants</b><comment>   "Detect: 'No known noun' and/or  'no antecedant'</comment><comment>   "</comment><comment>   "Initialize for an Action Frame."</comment><comment>   "Append instruction lines."</comment><comment>   "Append an instruction that is delegated"</comment><comment>   "Still expect one complaints about no nouns on the last line."</comment><comment>   "Check for antecedants - Happy path: 'door' is not a noun and needs no antecedant."</comment><comment>   "But if we make door a noun, it will now lack an antecedant."</comment><r>***38 lines of code ***</r></pre><pre><b>test345critiqueFrame4View</b><comment>   "Detect: No nouns in a view frame.</comment><comment>   "</comment><comment>   "Turn this on/off for now."</comment><comment>   "Initialize for a View Frame."</comment><comment>   "Add markup lines.</comment><comment>   "</comment><comment>   "Expect complaints about no nouns."</comment><comment>   "Transcript show: errors; cr."</comment><r>***36 lines of code ***</r></pre><pre><b>test346critiqueFrame4View</b><comment>   "When the nouns are defined, there are no complaints. s</comment><comment>   "</comment><comment>   "Initialize for a View Frame."</comment><comment>   "Add markup lines."</comment><comment>   "Expect no complaints about no nouns."</comment><comment>   "Transcript show: 'test346critiqueFrame4View errors:'; cr; show: errors; cr."</comment><r>***34 lines of code ***</r></pre><pre><b>test350critiqueFrame4Dictionary</b><comment>   "Critique a dictionary frame.</comment><comment>   "</comment><comment>   "Initialize for a Dictionary Frame."</comment><comment>   "Add dictionary lines."</comment><comment>   "attributes"</comment><comment>   "set collection"</comment><comment>   "list collection"</comment><comment>   "Attribute used in  set above is an entity with its own attributes. Entities are members of set."</comment><comment>   "Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"</comment><comment>   "Until the frame is compiled, the nouns are not recognized.</comment><comment>   "</comment><comment>   "Transcript  cr; show: 'test350critiqueFrame4Dictionary'; cr; show: errors; cr."</comment><r>***39 lines of code ***</r></pre><pre><b>test351critiqueFrame4Dictionary</b><comment>   "Critique a dictionary frame.</comment><comment>   "</comment><comment>   "Initialize for a Dictionary Frame."</comment><comment>   "Add dictionary lines."</comment><comment>   "attributes"</comment><comment>   "set collection"</comment><comment>   "list collection"</comment><comment>   "Attribute used in  set above is an entity with its own attributes. Entities are members of set."</comment><comment>   "Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"</comment><comment>   "ontology addNouns: #( 'recipe' 'name' 'description' 'ingredient' 'step' )."</comment><comment>   "Expect no complaints about no nouns."</comment><comment>   "Transcript  cr; show: 'test351critiqueFrame4Dictionary'; cr; show: errors; cr."</comment><r>***37 lines of code ***</r></pre><pre><b>test361critiqueFrame4Vignette</b><comment>   "Critique a dialog vignette.</comment><comment>   "</comment><comment>   "Initialize for a Dialog Frame."</comment><comment>   "{Ask menu.} is not defined in this ontology."</comment><r>***60 lines of code ***</r></pre><pre><b>test421compileFrame4Plan</b><comment>   "In this context, 'compile' means that the plan frame is inserted into the ontology,</comment><comment>   "</comment><comment>   "Initialize for a Plan Frame."</comment><comment>   "Append precondition lines."</comment><comment>   "Finish with action statement."</comment><comment>   "Every line has recipe as a noun."</comment><comment>   "Expect no complaints about no nouns. "</comment><comment>   "Now we should see frame in the ontology."</comment><r>***37 lines of code ***</r></pre><pre><b>test431compileFrame4Action</b><comment>   "In this case, 'compile' means adding the frame to the ontology,</comment><comment>   "</comment><comment>   "Initialize for an Action Frame."</comment><comment>   "Append instruction lines."</comment><comment>   "Append an instruction that is delegated"</comment><comment>   "Now we can get the action from the ontology"</comment><comment>   "Now we can also get the instruction sequence "</comment><comment>   "And the role`s actions includes "</comment><r>***47 lines of code ***</r></pre><pre><b>test446compileFrame4View</b><comment>   "Compile a view frame.</comment><comment>   "</comment><comment>   "Initialize for a View Frame."</comment><comment>   "Add markup lines."</comment><comment>   "Expect no complaints about no nouns."</comment><r>***32 lines of code ***</r></pre><pre><b>test450compileFrame4Dictionary</b><comment>   "In this context, </comment><comment>   "</comment><comment>   "Initialize for a Dictionary Frame."</comment><comment>   "Add dictionary lines."</comment><comment>   "supertype"</comment><comment>   "attributes"</comment><comment>   "set collection"</comment><comment>   "list collection"</comment><comment>   "Attribute used in  set above is an entity with its own attributes. Entities are members of set."</comment><comment>   "Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"</comment><comment>   "There are no syntax errors."</comment><comment>   "Check that ontology has all that stuff."</comment><comment>   "Check that the supertypes are recorded also."</comment><r>***40 lines of code ***</r></pre><pre><b>test461compileFrame4Vignette</b><comment>   "Compile a dialog vignette.</comment><comment>   "</comment><comment>   "Initialize a Vignette Frame."</comment><comment>   "The ontology should have these frames."</comment><comment>   ""</comment><r>***47 lines of code ***</r></pre><pre><b>test510storeFrame</b><comment>   "Store the frame in the given ontology.</comment><comment>   "</comment><comment>   "Initialize for a Dictionary Frame."</comment><comment>   "Add dictionary lines."</comment><comment>   "supertype"</comment><comment>   "attributes"</comment><comment>   "set collection"</comment><comment>   "list collection"</comment><comment>   "Attribute used in  set above is an entity with its own attributes. Entities are members of set."</comment><comment>   "Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"</comment><comment>   "The frame editor receives the command to store the frame from the user interface (Scribe)."</comment><r>***30 lines of code ***</r></pre><pre><b>test520fetchFrameByID</b><comment>   "Store a dictionary frame and then get it back using its uniqueIdentifier.</comment><comment>   "</comment><comment>   "Initialize for a Dictionary Frame."</comment><comment>   "Add dictionary lines."</comment><comment>   "supertype"</comment><comment>   "attributes"</comment><comment>   "set collection"</comment><comment>   "list collection"</comment><comment>   "Attribute used in  set above is an entity with its own attributes. Entities are members of set."</comment><comment>   "Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"</comment><comment>   "The frame editor receives the command to store the frame from the user interface (Scribe)."</comment><comment>   "The frame will now have a uniqueIdentifier."</comment><comment>   "We can use the identifier to fetch the frame into another frameUpdater."</comment><comment>   "Check the content."</comment><r>***45 lines of code ***</r></pre><pre><b>test531fetchFrame4PlanByID</b><comment>   "Create a plan frame in editor; store it; get it back via its ID.</comment><comment>   "</comment><comment>   "Initialize for a Plan Frame."</comment><comment>   "Append precondition lines."</comment><comment>   "Finish with action statement."</comment><comment>   "Every line has recipe as a noun."</comment><comment>   "Expect no complaints about no nouns. "</comment><comment>   "The frame editor receives the command to store the frame from the user interface (Scribe)."</comment><comment>   "The frame will now have a uniqueIdentifier."</comment><comment>   "We can use the identifier to fetch the frame into another frameUpdater."</comment><comment>   "Check the content."</comment><r>***50 lines of code ***</r></pre><pre><b>test532fetchFrame4PlanByTitle</b><comment>   "Create a plan frame in editor; store it; get it back via its title.</comment><comment>   "</comment><comment>   "Initialize for a Plan Frame."</comment><comment>   "Append precondition lines."</comment><comment>   "Finish with action statement."</comment><comment>   "Every line has recipe as a noun."</comment><comment>   "Expect no complaints about no nouns. "</comment><comment>   "The frame editor receives the command to store the frame from the user interface (Scribe)."</comment><comment>   "The frame will now have a uniqueIdentifier."</comment><comment>   "We can use the identifier to fetch the frame into another frameUpdater."</comment><comment>   "Check the content."</comment><comment>   "Make sure it still works when there is more than one plan frame."   </comment><comment>   "Check the content."</comment><r>***60 lines of code ***</r></pre><pre><b>test540fetchFrame4DictionaryByID</b><comment>   "Initialize for a Dictionary Frame."</comment><comment>   "Add dictionary lines."</comment><comment>   "attributes"</comment><comment>   "set collection"</comment><comment>   "list collection"</comment><comment>   "Attribute used in  set above is an entity with its own attributes. Entities are members of set."</comment><comment>   "Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"</comment><comment>      "The frame editor receives the command to store the frame from the user interface (Scribe)."</comment><comment>   "The frame will now have a uniqueIdentifier."</comment><comment>   "We can use the identifier to fetch the frame into another frameUpdater1."</comment><comment>   "Check the content."</comment><r>***43 lines of code ***</r></pre><pre><b>test541fetchFrame4DictionaryByTitle</b><comment>   "Ontology will fetch a dictionary frame given its title."</comment><comment>   "Given: Ontology has several dictionary frames."</comment><comment>   "When: Caller (PA) requests a dictionary frame by its title."</comment><comment>   "Then: Ontology returns the matching frame."</comment><comment>   "--- Otherwise ---"</comment><comment>   "The caller may request a ranked list of nearest matches. (test542 ?)"</comment><comment>   "Initialize for a Dictionary Frame."</comment><comment>   "Add dictionary lines."</comment><comment>   "attributes"</comment><comment>   "set collection"</comment><comment>   "list collection"</comment><comment>   "Attribute used in  set above is an entity with its own attributes. Entities are members of set."</comment><comment>   "Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"</comment><comment>      "The frame editor receives the command to store the frame from the user interface (Scribe)."</comment><comment>   "The frame will now have a uniqueIdentifier."</comment><comment>   "We can use the identifier to fetch the frame into another frameUpdater."</comment><comment>   "Check the content."</comment><r>***50 lines of code ***</r></pre><pre><b>test551fetchFrame4ActionByTitle</b><comment>   "The title of an action includes the role and the statement."</comment><comment>   "Given: Ontology contains several action frames."</comment><comment>   "When: Caller (PA) requests the action frame with role and statement-string."</comment><comment>   "Then: Ontology returns the matching action frame.</comment><comment>   "Initialize for an Action Frame."</comment><comment>   "Append instruction lines."</comment><comment>   "Append an instruction that is delegated"</comment><comment>   "We can use the identifier to fetch the frame into another frameUpdater."</comment><comment>   "Check the content."</comment><r>***46 lines of code ***</r></pre><pre><b>test561fetchFrame4ViewByTitle</b><comment>   "This should be easy."</comment><comment>   "Given: PA or run-time has ontology open with several view frames."</comment><comment>   "When: PA or run-time correctly requests a view by name."</comment><comment>   "Then: Ontology returns the frame containing that view."</comment><comment>   "--- Following can go into another test: ---"</comment><comment>   "When: The name does not match any view,"</comment><comment>   "Then: The PA can ask the ontology for a ranked list of view names. (best match)"</comment><comment>   "Initialize for a View Frame."</comment><comment>   "Add markup lines."</comment><comment>   "We can use the identifier to fetch the frame into another frameUpdater."</comment><comment>   "Check the content."</comment><r>***41 lines of code ***</r></pre><pre><b>test571fetchFrame4VignetteByTitle</b><todo>   "TODO: Think about how vignettes would be identified to users.</todo><comment>   "</comment><comment>   "Given: A context is active."</comment><comment>   "When: Scribe delivers a pattern and run-time looks it up."</comment><comment>   "Then: If the pattern matches one of the vignette`s in the active context, </comment><comment>      "Create a dialog vignette.</comment><comment>   "</comment><comment>   "Initialize for a Dialog Frame."</comment><comment>   "Add response lines."</comment><comment>   "There are two kinds of resonse, verbal responses and actions."</comment><comment>   "We can use the identifier to fetch the frame into another frameUpdater."</comment><comment>   "Check the content."</comment><r>***69 lines of code ***</r></pre><pre><b>test620storeFrame4Plan</b><comment>   "Store plan frame.</comment><comment>   "</comment><comment>   "Initialize for a Plan Frame."</comment><comment>   "Append precondition lines."</comment><comment>   "Finish with action statement."</comment><comment>   "Run store and fetch test routine"</comment><r>***22 lines of code ***</r></pre><pre><b>test630storeFrame4Action</b><comment>   "Store an action frame.</comment><comment>   "</comment><comment>   "Initialize for an Action Frame."</comment><comment>   "Append instruction lines."</comment><comment>   "Append an instruction that is delegated"</comment><comment>   "Run store and fetch test routine"</comment><r>***27 lines of code ***</r></pre><pre><b>test640storeFrame4View</b><comment>   "Store a view frame.</comment><comment>   "</comment><comment>   "Initialize for a View Frame."</comment><comment>   "Add markup lines."</comment><comment>   "Run store and fetch test routine"</comment><r>***23 lines of code ***</r></pre><pre><b>test650storeFrame4Dictionary</b><comment>   "Store a dictionary frame.</comment><comment>   "</comment><comment>   "Initialize for a Dictionary Frame."</comment><comment>   "Add dictionary lines."</comment><comment>   "attributes"</comment><comment>   "set collection"</comment><comment>   "list collection"</comment><comment>   "Attribute used in  set above is an entity with its own attributes. Entities are members of set."</comment><comment>   "Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"</comment><comment>   "Run store and fetch test routine"</comment><r>***28 lines of code ***</r></pre><pre><b>test660storeFrame4Vignette</b><comment>   "Store a dictionary frame.</comment><comment>   "</comment><comment>   "Initialize for a Dialog Frame."</comment><comment>   "Add response lines."</comment><comment>   "There are two kinds of resonse, verbal responses and actions."</comment><comment>   "Run store and fetch test routine"</comment><r>***24 lines of code ***</r></pre><pre><b>test700parseSourceLineReadMe</b><comment>   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</comment><comment>   "The role prefix is optional - It only appears when one role is delegating to another."</comment><comment>   "Comments and annotation are optional."</comment></pre><pre><b>test701parseInstructionLine</b><comment>   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</comment><comment>   "The role prefix is optional - It only appears when one role is delegating to another."</comment><comment>   "Comments and annotation are optional."</comment><r>***23 lines of code ***</r></pre><pre><b>test702parseInstructionLineWithComment</b><comment>   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</comment><comment>   "The role prefix is optional - It only appears when one role is delegating to another."</comment><comment>   "Comments and annotation are optional."</comment><r>***24 lines of code ***</r></pre><pre><b>test703parseInstructionLineWithString</b><comment>   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</comment><comment>   "The role prefix is optional - It only appears when one role is delegating to another."</comment><comment>   "Comments and annotation are optional."</comment></pre><pre><b>test704parseInstructionLineWithTwoComments</b><comment>   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</comment><comment>   "The role prefix is optional - It only appears when one role is delegating to another."</comment><comment>   "Comments and annotation are optional."</comment><r>***25 lines of code ***</r></pre><pre><b>test705parseActionLine</b><comment>   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</comment><comment>   "The role prefix is optional - It only appears when one role is delegating to another."</comment><comment>   "Comments and annotation are optional."</comment><r>***23 lines of code ***</r></pre><pre><b>test706parseActionLineWithComment</b><comment>   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</comment><comment>   "The role prefix is optional - It only appears when one role is delegating to another."</comment><comment>   "Comments and annotation are optional."</comment><r>***24 lines of code ***</r></pre><pre><b>test707parseActionLineWithAnnotation</b><comment>   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</comment><comment>   "The role prefix is optional - It only appears when one role is delegating to another."</comment><comment>   "Comments and annotation are optional."</comment><r>***22 lines of code ***</r></pre><pre><b>test708parseActionLineWithCommentAndAnnotation</b><comment>   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</comment><comment>   "The role prefix is optional - It only appears when one role is delegating to another."</comment><comment>   "Comments and annotation are optional."</comment><r>***23 lines of code ***</r></pre><pre><b>test710getLabel</b><comment>   "Some framelines have labels. Some don't."</comment></pre><pre><b>test720getComment</b><comment>   "Some framelines have comments. Some don't."</comment><comment>   "Note: Following assumes there is just one comment in the source.</comment></pre><pre><b>test725noComment</b><comment>   "Some framelines have comments. Some don't."</comment></pre><pre><b>test730getAnnotation</b><comment>   "Some framelines have annotations. Some don't."</comment></pre><pre><b>test735noAnnotation</b><comment>   "Some framelines have annotations. Some don't."</comment></pre><pre><b>test741getOneWidget</b><comment>   "Markup-line class includes own parser.  </comment></pre><pre><b>test742getTwoWidgets</b><comment>   "Markup-line includes a parser."</comment></pre><pre><b>test743getTwoWidgetsAndButton</b><comment>   "Markup-line includes a parser."</comment></pre><pre><b>test751parseOneWidget</b><comment>   "Parse a markup-line containing a widget."</comment><r>***37 lines of code ***</r></pre><pre><b>test752parseMultipleWidgets</b><comment>   "Parse a markup line containing multiple widgets."</comment><r>***26 lines of code ***</r></pre><pre><b>test753parseRadioButtons</b><comment>   "Parse a line containing radio button widgets."</comment><r>***27 lines of code ***</r></pre><pre><b>test754parseActionButton</b><comment>   "Parse a line containing an action button."</comment></pre><pre><b>test755parseLinkWidget</b><comment>   "Parse a mark-up line with a link widget."</comment><r>***24 lines of code ***</r></pre><pre><b>test760parseEmphasisMarkup</b><comment>   "Parse a mark-up line with emphasis markup."</comment><r>***37 lines of code ***</r></pre><pre><b>test770parseHeadingMarkup</b><comment>   "Parse a mark-up line with emphasis markup."</comment><r>***32 lines of code ***</r></pre><pre><b>test772parseBulletListMarkup</b><comment>   "Parse a mark-up line with bullet list markup."</comment><r>***34 lines of code ***</r></pre><pre><b>test773parseNumberListMarkup</b><comment>   "Parse a mark-up line with emphasis markup."</comment><r>***36 lines of code ***</r></pre><pre><b>test800LoadFileReadMe</b><comment>   "The Programmers Assistant may load and parse a text file.</comment><comment>   "</comment><comment>   "Frames are separated by lines beginning with ===.</comment><comment>   "</comment></pre><pre><b>test810FramesAreSeparatedByFrameDelimiter</b><comment>   "Frames are separated by lines beginning with ===.</comment><comment>   "</comment><r>***21 lines of code ***</r></pre><pre><b>test811StreamStartsWithFrameDelimiter</b><comment>   "Test where file starts with a frame-delimiter."</comment><comment>   "Test where file starts with a frame-delimiter."</comment></pre><pre><b>test812StreamEndsWithEndOfFile</b><comment>   "Test where frame ends on end-of-file"</comment><comment>   "Test where frame ends on end-of-file"</comment></pre><pre><b>test813StreamStartsWithFrameDelimiterEndsWithEOF</b><comment>   "Test where file starts with a frame-delimiter and ends on end-of-file."</comment><comment>   "Test where file starts with a frame-delimiter and ends on end-of-file."</comment></pre><pre><b>test814StreamHasViewAndDictionaryFrames</b><comment>   "Load two frames: a view frame and a dictionary frame."</comment><comment>   "Load two frames."</comment><r>***22 lines of code ***</r></pre><pre><b>test815StreamHasViewDictionaryAndPlanFrame</b><comment>   "Load three frames: a view, a dictionary, and a plan frame."</comment><comment>   "Load three frames."</comment><comment>   "Test for correct number of plan lines. (Remove defect where block labels are of wrong type.)"</comment><r>***40 lines of code ***</r></pre><pre><b>test816StreamHasViewDictionaryPlanAndCommentFrames</b><comment>   "Load four frames: a view, a dictionary, a plan, and a comment frame."</comment><comment>   "Load four frames."</comment><r>***35 lines of code ***</r></pre><pre><b>test817StreamHasViewDictionaryPlanAndActionFrames</b><comment>   "Load four frames: a view, a dictionary, a plan, and an action frame."</comment><comment>   "Load four frames."</comment><r>***45 lines of code ***</r></pre><pre><b>test820StreamHasVignettes</b><comment>   "Test that vignettes are properly parsed, loaded, and indexed."</comment><comment>   "Load these frames."</comment><r>***55 lines of code ***</r></pre><pre><b>test910LoadFromTextFile</b><comment>   "Load from pizza-ontology.txt"</comment></pre><pre><b>test912LoadDonutShop</b><comment>   "Load from pizza-ontology.txt"</comment></pre><pre><b>test913LoadBarista</b><comment>   "Load from pizza-ontology.txt"</comment><comment>   "We want at least one of each type of frame."</comment></pre><pre><b>test914LoadClubMech</b><comment>   "Load from pizza-ontology.txt"</comment><comment>   "Transcript cr; show: 'test914LoadClubMech begins'."</comment><comment>   "Transcript cr; show: 'test914LoadClubMech ends'."</comment></pre><pre><b>test920LoadFromTextFileAndRenderAsHTML</b><comment>   "Load from pizza-ontology.txt"</comment></pre><pre><b>test922LoadDonutShopAndRenderAsHTML</b><comment>   "Load from some-ontology.txt"</comment></pre><pre><b>test923LoadBaristaAndRenderAsHTML</b><comment>   "Load from some-ontology.txt"</comment></pre><pre><b>test924LoadClubMechAndRenderAsHTML</b><comment>   "Load from some-ontology.txt"</comment></pre><pre><b>test925LoadClubMechAndRenderAsHTMLwithCritique</b><comment>   "Load from some-ontology.txt"</comment></pre><pre><b>test926LoadDonutShopAndRenderAsHTMLwithCritique</b><comment>   "Load from some-ontology.txt"</comment></pre><pre><b>test927LoadBaseOntologyAndRenderAsHTMLwithCritique</b><comment>   "Load from some-ontology.txt"</comment></pre><pre><b>test928LoadVROntologyAndRenderAsHTMLwithCritique</b><comment>   "Load from some-ontology.txt"</comment></pre><pre><b>test929LoadMarkupViewAndRenderAsHTMLwithCritique</b><comment>   "Load from some-ontology.txt"</comment></pre><pre><b>test930LoadActionFrame</b><comment>   "Load, parse, and render a slightly tricky action frame."</comment><comment>   "actionFrame := frames at: 1."</comment><comment>    "</comment><comment>   "</comment><r>***39 lines of code ***</r></pre><pre><b>test944LoadClubMechSaveReload</b><comment>   "Load from some-ontology.txt, save it, reload it."</comment><comment>   "Transcript cr; show: 'test914LoadClubMech begins'."</comment><comment>   "Save it to another file and reload it from the saved file."</comment><comment>   "Load it back - should get same result as before."</comment><r>***25 lines of code ***</r></pre><pre><b>test945LoadDonutShopSaveReload</b><comment>   "Load from some-ontology.txt, save it, reload it."</comment><comment>   "Save it to another file and reload it from the saved file."</comment><comment>   "Load it back - should get same result as before."</comment><comment>   "Counts should be same as above."</comment><r>***38 lines of code ***</r></pre><pre><b>test954LoadClubMechSaveReload</b><comment>   "Load from some-ontology.txt, save it, reload it."</comment><comment>   "Transcript cr; show: 'test914LoadClubMech begins'."</comment><comment>   "Save it to another file and reload it from the saved file."</comment><comment>   "Load it back - should get same result as before."</comment><r>***25 lines of code ***</r></pre><pre><b>test971CreateNounTreeGraph</b><comment>   "Create a graph of the base ontology noun tree."</comment><comment>   "Assign creation of the noun tree to Ontology (HumOntology). </comment></pre><pre><b>testU000UserInitiatedEvents</b><comment>"Plan for user-initiated events."</comment><comment>"KeyboardEvents:</comment><comment>"</comment><comment>"OntologyUpdateEvents:</comment><comment>"</comment><comment>"RenameEvents:</comment><comment>"</comment><r>***33 lines of code ***</r></pre><pre><b>testU100KeyBoardEvents</b><comment>"KeyboardEvents:</comment><comment>"</comment><comment>"</comment><comment>"</comment><r>***41 lines of code ***</r></pre><pre><b>testU200NewRelationEvents</b><comment>"NewRelationEvents:</comment><comment>"</comment></pre><pre><b>testU300RenameEvents</b><comment>"RenameEvents:</comment><comment>"</comment></pre><pre><b>text930expected</b><return>   ^'&lt;html&gt;</return><r>***125 lines of code ***</r></pre><hr/><h3>Hum-Tests -- HumRunTimeTests</h3><pre><b>aReadMe</b><comment>   "See the class description for the intended (future) tests."</comment><return>   ^'See the class description for the intended (future) tests.'</return></pre><pre><b>expect: actualValue is: expectedValue </b><comment>   ""</comment><return>   ^ self</return></pre><pre><b>expected:  expectedValue actual: actualValue </b><comment>   ""</comment><return>   ^ self</return></pre><pre><b>setUp</b><comment>   "This setup is used by many run-time tests. </comment><comment>   "Set the ID"</comment><comment>   "Define a Hum configuration."</comment><comment>   "Attach local messenger (Mock)".</comment><comment>   "Create worldbase instance and check-in."</comment><comment>   "A resource Dispatcher must know a messenger and a bookkeeper."</comment><comment>   "A bookkeeper must know a messenger and a world base."               </comment><comment>   "A worker must know a messenger and a Dispatcher and some roles"</comment><comment>   "Messenger needs to know bookkeeper and Dispatcher"</comment><comment>   "Check in."</comment><r>***35 lines of code ***</r></pre><pre><b>setUpKnockKnockOnOntology: anOntology</b><comment>   "Provide a view frame."</comment><comment>   "Provide a dictionary frame."</comment></pre><pre><b>tearDown</b><comment>   "Transcript cr; show: 'completed: ', (testSelector asString)."</comment></pre><pre><b>test000ApplicationConfigurationReadMe</b><comment>   "An application has a run-time configuration."</comment><comment>   "</comment><comment>"</comment><r>***22 lines of code ***</r></pre><pre><b>test005ApplicationConfigurationSetup</b><comment>   "This setup is used by several tests. "</comment><comment>   "Define a Hum configuration."</comment><comment>   "#setUp creates a shared configuration."</comment><r>***26 lines of code ***</r></pre><pre><b>test100ActorReadMe</b><comment>   "</comment><comment>   "</comment><r>***45 lines of code ***</r></pre><pre><b>test100ReadMe</b><comment>   "Network is a wrapper on whatever technology is used to communicate between Actors."</comment><comment>"Features:"</comment><comment>   "The Network sends/receives messages (wrapping the communication technology)."   </comment><comment>   "The Network component provides serialization and de-serialization of Message instances (see HumMessage)."</comment><comment>   "Design Note: The serialization strategy assumes 'payload' is not sensitive to communication stack."</comment><comment>   "TBD: Consider Erlang strategy and interface. Assume most tests will be on the Erlang side."</comment></pre><pre><b>test105actorConfiguration</b><comment>   "A Hum Actor is configured with the address of a messenger node.</comment><comment>   "</comment><comment>   "Create the (mock) messenger service"</comment><comment>   "A resource dispatcher must know a messenger and a bookkeeper."</comment><comment>   "A bookkeeper must know a messenger and a world base."               </comment><comment>   "A worker must know a messenger and a dispatcher and some roles"</comment><r>***30 lines of code ***</r></pre><pre><b>test110workerChecksIn</b><comment>   "Worker checks-in, announcing roles."</comment><comment>   "The check-in protocol has the worker-side and the resource dispatcher side."</comment><comment>   "Worker says:</comment><comment>   "Get the worker from the setup."</comment><comment>   "Get the resource dispatcher from the setup."</comment><comment>   "Execute the check-in directly."</comment><comment>   "dispatcher now includes worker in set of those who know that role."</comment><r>***25 lines of code ***</r></pre><pre><b>test120workerCheckInMessage</b><comment>   "Worker checks-in, announcing roles."</comment><comment>   "The check-in protocol has the worker-side and the resource dispatcher side."</comment><comment>   "Worker says:</comment><comment>   "Get the worker from the setup."</comment><comment>   "Get the resource dispatcher from the setup."</comment><comment>   "Use a Smalltalk coded message to tell dispatcher."</comment><comment>   "To: Execute the check-in directly, we would say:"</comment><comment>   "dispatcher checkInActor: worker name at: 'worker uri' withRoles: worker roles."</comment><comment>   "dispatcher now includes worker in set of those who know that role."</comment><r>***27 lines of code ***</r></pre><pre><b>test130workerChecksInViaMessenger</b><comment>   "Worker checks-in, announcing roles."</comment><comment>   "The check-in protocol has the worker-side and the resource dispatcher side."</comment><comment>   "Worker says:</comment><comment>   "Get the worker from the setup."</comment><comment>   "Get the resource dispatcher from the setup."</comment><comment>   "Tell the worker to check-in."</comment><comment>   "dispatcher now includes worker in set of those who know that role."</comment><r>***21 lines of code ***</r></pre><pre><b>test135workerChecksOutViaMessenger</b><comment>   "Worker checks-in, announcing roles."</comment><comment>   "The check-in protocol has the worker-side and the resource dispatcher side."</comment><comment>   "Worker says:</comment><comment>   "Get the worker from the setup."</comment><comment>   "Get the resource dispatcher from the setup."</comment><comment>   "Tell the worker to check-in."</comment><comment>   "dispatcher now includes worker in set of those who know that role."</comment><comment>   "Tell the worker to check-out."</comment><r>***25 lines of code ***</r></pre><pre><b>test200DispatcherReadMe</b><comment>"The Dispatcher (RM) - assigns tasks to actors.</comment><comment>"</comment><r>***47 lines of code ***</r></pre><pre><b>test210DispatcherAssignsAction</b><comment>   "Some actor delegates a task to a role.</comment><comment>   "</comment><comment>   "Get the Dispatcher from the setup."</comment><comment>   "Create a baker worker"</comment><comment>   "Create another actor to be oven. " </comment><comment>   "Tell the actors to check-in."</comment><comment>   "======= Set up the action frame  =========="</comment><comment>   "Initialize for an Action Frame."</comment><comment>   "Append an instruction that is delegated"</comment><comment>   "We need at least one noun."</comment><comment>   "============== ================="</comment><comment>   "We will pretend to be Coordinator running a plan.</comment><comment>   "</comment><comment>   "After the task is done, a resource usage entry will be sent to the bookkeeper."</comment><comment>   "See also: Bookkeeper tests."</comment><r>***63 lines of code ***</r></pre><pre><b>test300CoordinatorReadMe</b><comment>"Coordinator - controls execution of plans and dialogs.</comment><comment>         "</comment></pre><pre><b>test310coordinatorRunsPlan</b><comment>   "Dialog:</comment><comment>   "</comment><comment>   "Create an ontology."</comment><comment>   "Define a few nouns."</comment><comment>   "Compile it"</comment><comment>   "Define a simple plan."</comment><comment>   "Create the corresponding action frame."</comment><comment>   "Store it in the ontology."</comment><comment>   "Compile it."</comment><comment>   ""</comment><comment>   "Create a running instance of the plan and a coordinator to run it."</comment><comment>   "Run the plan."</comment><comment>   "After that plan has run. The goal will be fulfilled."</comment><comment>   "Now there should be at least one change on the job ticket."</comment><r>***61 lines of code ***</r></pre><pre><b>test320coordinatorInvokesAction</b><comment>   "Goal: Plan has one frame with no preconditions.</comment><comment>   "</comment><comment>   "Define a few nouns."</comment><comment>   "Compile it"</comment><comment>   "Define a simple plan."</comment><comment>   "Create the corresponding action frame."</comment><comment>   "Store it in the ontology."</comment><comment>   "Compile it."</comment><comment>   ""</comment><comment>   "Create a running instance of the plan and a coordinator to run it."</comment><comment>   "Run the plan."</comment><comment>   "After that plan has run. The goal will be fulfilled."</comment><comment>   "Now there should be at least one change on the job ticket."</comment><r>***64 lines of code ***</r></pre><pre><b>test330twoPlanFrames</b><comment>   "Test with two plan frames.</comment><comment>   "</comment><comment>   "Root frame has one prereq and one action"</comment><comment>   "Create the corresponding action frame."</comment><comment>   "Second level frame with no prereq and one action"   </comment><comment>      "Create the corresponding action frame."</comment><comment>   "We need at least one noun."</comment><r>***49 lines of code ***</r></pre><pre><b>test340planTreeBranches</b><comment>   "Test a plan tree with several levels and significant branching.</comment><comment>   "</comment><comment>   "The root frame of this plan tree has several preconditions."</comment><comment>   "Corresponding action frame:"</comment><comment>   "Second level frame -- This frame has a precondition, therefore a third level will be needed."</comment><comment>   "Corresponding action frame:"</comment><comment>   "Another second level frame - has no precondtions at this time."</comment><comment>   "Corresponding action frame:"</comment><comment>   "Still another second level frame - has no preconditions at this time."</comment><comment>   "Corresponding action frame:"</comment><comment>   "Third level frame - has no preconditions at this time."</comment><comment>   "Corresponding action frame:"</comment><comment>   "We need at least one noun."</comment><comment>   "</comment><comment>   "</comment><r>***96 lines of code ***</r></pre><pre><b>test400BookkeeperReadMe</b><comment>   "A Bookkeeper tracks resource utilization.</comment><comment>   "</comment></pre><pre><b>test410BookkeeperRecordsJobTickets</b><comment>   "If we ask the bookkeeper to 'run' a jobTicket, it stores it in its jobTickets collection.'"</comment></pre><pre><b>test420BookkeeperSums</b><comment>   "The bookkeeper tracks utilization of an actor by action, actor, role, job.</comment><comment>   "</comment><comment>   "Measures are tracked by action, role, actor, and job."</comment><comment>  "Send to bookkeeper."</comment><comment>   "Bookkeeper tracks utilization by Action."</comment><comment>   "Bookkeeper tracks utilization by Actor."</comment><comment>   "Bookkeeper tracks utilization by Role."</comment><comment>   "Bookkeeper tracks utilization by Job."</comment><comment>   "Sum by metric (calls, steps, gross counts)"</comment><r>***45 lines of code ***</r></pre><pre><b>test600WorldBaseReadMe</b><comment>   "</comment><comment>   "</comment></pre><pre><b>test610CreateWorldBaseInstance</b><comment>   "Create an instance of a Hum World Base (a database to be shared by multiple actors)."</comment></pre><pre><b>test615CreateUniqueIdentifier</b><comment>   "Create an instance of a Hum World Base (a database to be shared by multiple actors)."</comment></pre><pre><b>test616CreateUniqueIdentifierDoesNotBreak</b><comment>   "Create an instance of a Hum World Base (a database to be shared by multiple actors)."</comment><comment>   "Make sure it can handle high rate."</comment></pre><pre><b>test620setAndGet</b><comment>   "set entity-attribute value"</comment></pre><pre><b>test630setGetReplace</b><comment>   "set entity-attribute value"</comment></pre><pre><b>test640FindWhere</b><comment>   "set entity-attribute value"</comment><comment>   "Insert two entity instances with attribute vlaues."</comment><comment>   "Return a set of entity identifiers satisfying my criteria."</comment><comment>   "entitySet sorted asArray inspect."</comment><todo>   "TODO: Decide: EntityType is innate. EntityType is an attribute."</todo><r>***25 lines of code ***</r></pre><pre><b>test700BlackBoardReadMe</b><comment>   "</comment><comment>   "</comment><comment>   "</comment><comment>   "</comment></pre><pre><b>test710setAndGet</b><comment>   "set entity-attribute value"</comment><comment>   "Set entity-attribute value."</comment></pre><pre><b>test720setGetReplace</b><comment>   "Update entity-attribute value"</comment></pre><pre><b>test730clearEntity</b><comment>   "Update entity-attribute value"</comment><r>***30 lines of code ***</r></pre><pre><b>test800DialogAgentReadMe</b><comment>   "</comment><comment>   "</comment></pre><pre><b>test810createSimpleVignette</b><comment>   "Create a vignette frame."</comment></pre><pre><b>test820createDialogAgent</b><comment>   "Create a dialog agent."</comment></pre><pre><b>test825DialogAgentHasScribe</b><comment>   "When a dialog agent is activated, a Scribe is already present."</comment><comment>   "How is the scribe`s presence evidenced?</comment><comment>   "</comment></pre><pre><b>test830dialogAgentMatchesInputToVignette</b><comment>   "Pattern 'Hello *.' matches 'Hello.'.</comment><comment>   "</comment><comment>   "Simulate call from Scribe."</comment><r>***29 lines of code ***</r></pre><pre><b>test832dialogAgentMatchesInputToVignette2</b><comment>   "Pattern 'Hello *.' matches 'Hello Ms. Robot.'</comment><comment>   "</comment><comment>   "Simulate call from Scribe."</comment><r>***30 lines of code ***</r></pre><pre><b>test833dialogAgentMatchesInputToVignette3</b><comment>   "Pattern ('Hello *.' 'Hi *.') matches 'Hi there.'.</comment><comment>   "</comment><comment>   "Simulate call from Scribe."</comment><r>***30 lines of code ***</r></pre><pre><b>test834dialogAgentMatchesInputWithAlternatePunctuations</b><comment>   "Pattern ('Hello *.' 'Hi *.' 'Hi *!' 'Hello * ?') matches 'Hi there.'.</comment><comment>   "</comment><comment>   "Simulate call from Scribe."</comment><r>***33 lines of code ***</r></pre><pre><b>test840dialogAgentSorry</b><comment>   "Stimulus 'Help' returns 'Sorry ...'</comment><comment>   "</comment><comment>   "Simulate call from Scribe."</comment><r>***34 lines of code ***</r></pre><pre><b>test850dialogAgentMatchesInputWithAlternatePunctuations</b><comment>   "Pattern ('Hello *.' 'Hi *.') matches 'Hi!'.</comment><comment>   "</comment><comment>   "Simulate call from Scribe."</comment><r>***32 lines of code ***</r></pre><pre><b>test860dialogAgentMatchesInputWithNounSlot</b><comment>   "Pattern ('My name is [full-name].') matches 'My name is Tessie Tester.'.</comment><comment>   "</comment><comment>   "Simulate call from Scribe."</comment><comment>   "Was slot filled-in?"</comment><r>***36 lines of code ***</r></pre><pre><b>testM110MessengerRemembersActors</b><comment>   "Create an actor -- The actor automatically registers itself with the messenger in its configuration."</comment><comment>   "One more should make no problem."</comment></pre><pre><b>testM120MessageAttributes</b><comment>   "The components of a message include sender, receiver, when sent, statement, and noun-values. "</comment></pre><pre><b>testS100ScribeReadMe</b><comment>   "These Scribe tests generally involve a Scribe that is independent of Seaside.</comment><comment>   "</comment><comment>   "</comment><comment>   "A Scribe is a HumActor that interprets user gestures seen by some set of sensors."</comment><comment>   "In this set of tests, the Scribe interprets HTTP requests."</comment><comment>   "General dataflow / workflow:</comment><comment>   "</comment><todo>   "TODO: How does the Dispatcher know what kind of Scribe to delegate 'Ask viewName.' ???"</todo><comment>   "Thinking Out Loud:</comment><comment>   "</comment><comment>   "Summary - Restatement:</comment><comment>   "</comment><r>***73 lines of code ***</r></pre><pre><b>testS110SetupScribe</b><comment>   "A scribe is attached to a dialogAgent Agent.</comment><comment>   "</comment></pre><pre><b>testS131ScribeHandlesHttpPostRequest</b><comment>   "Scribe: Captures data from Http Response and returns data to Dialog Agent in task-completion message. "</comment><todo>   "TODO: REFACTOR this test -- It is very confused."</todo><comment>   "Setup the Dialog actor and the Scribe actor."</comment><comment>   "scribe := HumScribe scribeID: 'scribeID' </comment><comment>   "scribe checkIn."</comment><comment>   "Create this HTTP request. </comment><comment>   "Set Http Request form to include this input - name:value pair."</comment><comment>   "Ask Scribe to handle the request."</comment><comment>   "We should see data in Scribe`s Blackboard and a change in scribe state."</comment><comment>   "We should also see data in the Dialog Agent`s blackboard"</comment><r>***40 lines of code ***</r></pre><pre><b>testS132ScribeHandlesViewReturn</b><comment>   "Scribe: Captures data from Http Response and returns data to Dialog Agent in task-completion message. "</comment><todo>   "TODO: REFACTOR this test -- It is very confused."</todo><comment>   "Scenario:</comment><comment>   "Dialog delegates 'Ask' to Scribe"</comment><comment>   "htmlSent := scribe log at: 2.</comment><r>***43 lines of code ***</r></pre><pre><b>testS133ScribeMocksViewDataEntry</b><comment>   "Scribe: Captures data from Http Response and returns data to Dialog Agent in task-completion message. "</comment><todo>   "TODO: REFACTOR this test -- It is very confused."</todo><comment>   "Scenario:</comment><comment>   "Dialog delegates 'Ask' to Scribe"</comment><comment>   "Mock data entry."</comment><comment>   "The blackboard should now match data entered."</comment><comment>   "And the worldbase has also been updated"</comment><r>***51 lines of code ***</r></pre><pre><b>testV100ReadMe</b><comment>   "Test HumVector - which is a subclass of FloatArray"</comment><comment>   "Test vector arithmetic v + v, v - v, v dot: v, v cross: v. v * scalar. v / scalar."</comment></pre><pre><b>testV105GetPutXYZ</b><comment>   "Test HumVector - which is a subclass of HumMeasure"</comment><comment>   "Test vector arithmetic v + v, v - v, v dot: v, v cross: v. v * scalar. v / scalar."</comment></pre><pre><b>testV110TestVplusV</b><comment>   "Test HumVector - which is a subclass of . . ."</comment><comment>   "Test vector arithmetic v + v, v - v, v dot: v, v cross: v. v * scalar. v / scalar."</comment></pre><pre><b>testV120TestVminusV</b><comment>   "Test HumVector - which is a subclass of . . ."</comment><comment>   "Test vector arithmetic v + v, v - v, v dot: v, v cross: v. v * scalar. v / scalar."</comment></pre><pre><b>testV130TestVdotV</b><comment>   "Test HumVector - which is a subclass of . . ."</comment><comment>   "Test vector arithmetic v + v, v - v, v dot: v, v cross: v. v * scalar. v / scalar."</comment></pre><pre><b>testV140TestVcrossV</b><comment>   "Test HumVector - which is a subclass of . . ."</comment><comment>   "Test vector arithmetic v + v, v - v, v dot: v, v cross: v. v * scalar. v / scalar."</comment><comment>   "Test with unit vectors."</comment><comment>   "Text with some numbers."</comment><r>***21 lines of code ***</r></pre><pre><b>testV150TestVtimesScalar</b><comment>   "Test HumVector - which is a subclass of . . ."</comment><comment>   "Test vector arithmetic v + v, v - v, v dot: v, v cross: v. v * scalar. v / scalar."</comment></pre><pre><b>testV160TestVdividedByScalar</b><comment>   "Test HumVector - which is a subclass of . . ."</comment><comment>   "Test vector arithmetic v + v, v - v, v dot: v, v cross: v. v * scalar. v / scalar."</comment></pre><hr/><h3>Hum-Tests -- HumSeasideProgrammersAssistantTests</h3><pre><b>aReadMe</b><comment>   "</comment><comment>   "</comment><return>   ^'See the class description for the intended (future) tests.'</return></pre><pre><b>test110newOntology</b><comment>   "Browser initializes (re-initializes) to an empty ontology."</comment></pre><pre><b>test121loadOntologyInstance</b><comment>   "Browser saves (writes) the ontology to a file."</comment></pre><pre><b>test130saveOntology</b><comment>   "Browser saves (writes) the ontology to a file."</comment></pre><pre><b>test222OpenOntologyInstance</b><comment>   "Test the dialog that asks the user for the file name."</comment><comment>   "</comment><comment>   "</comment></pre><hr/><h3>Hum-Tests -- HumSeasideUserInterfaceTests</h3><pre><b>checkGeneratedCode</b><comment>   "This is a place to see if generated code will compile."</comment></pre><pre><b>setUpViewFrameInOntology: aHumOntology</b><comment>   "Generate a view frame and dictionary entries for several tests.</comment><comment>   "</comment><comment>   "Create a view frame."</comment><comment>   "Add markup lines."</comment><todo>   "TODO: Make this smarter. </todo><comment>   "</comment><comment>   "Create a dictionary frame."</comment><todo>   "TODO: Should render description as a text area."</todo><todo>   "TODO: Should render ingredients as an unordered list."</todo><todo>   "TODO: Should render steps as an ordered list."</todo><r>***50 lines of code ***</r></pre><pre><b>test310ViewBecomesForm</b><comment>   "A Hum view frame is rendered as a Seaside Form.</comment><comment>   "</comment><comment>   "Initialize the View Frame for this test."</comment><comment>   "There is only one frame in this ontology."</comment><comment>   "Generate Seaside code for the view frame."</comment></pre><pre><b>test311ViewHasMultipleLines</b><comment>   "A Hum view frame is rendered as a Seaside Form.</comment><comment>   "</comment><comment>   "Initialize the View Frame for this test."</comment><comment>   "There is only one frame in this ontology."</comment><comment>   "Generate Seaside code for the view frame."</comment></pre><pre><b>test312ViewHeader</b><comment>   "A Hum view frame is rendered as a Seaside Form.</comment><comment>   "</comment><comment>   "Initialize the View Frame for this test."</comment><comment>   "There is only one frame in this ontology."</comment><comment>   "Generate Seaside code for the view frame."</comment><r>***22 lines of code ***</r></pre><pre><b>test313ViewField</b><comment>   "A Hum view frame is rendered as a Seaside Form.</comment><comment>   "</comment><comment>   "Initialize the View Frame for this test."</comment><comment>   "There is only one frame in this ontology."</comment><comment>   "Generate Seaside code for the view frame."</comment><comment>   "See if the resulting code will compile in the context of a HumDialogAgent."</comment><comment>   "Transcript show: '*** test313ViewField frameCode: ***'; cr; show: frameCode; cr."</comment><r>***34 lines of code ***</r></pre><pre><b>test314CheckGeneratedCode</b><comment>   "This is a place to see if generated code will compile and run."</comment><comment>   "Following is pasted from test313ViewField Transcript show: </comment><comment>   "</comment><comment>   "Expect the HTML output to look like this."</comment><comment>   "Compare strings ignoring differences in white space."</comment><comment>   "   </comment><comment>    "   </comment><r>***37 lines of code ***</r></pre><hr/><h3>Hum-Tests -- HumSeasideWidgetTests</h3><pre><b>setUpViewFrameInOntology: aHumOntology</b><comment>   "Generate a view frame and dictionary entries for several tests.</comment><comment>   "</comment><comment>   "Create a view frame."</comment><comment>   "Add markup lines."</comment><todo>   "TODO: Make this smarter. </todo><comment>   "</comment><comment>   "Create a dictionary frame."</comment><todo>   "TODO: Should render description as a text area."</todo><todo>   "TODO: Should render ingredients as an unordered list."</todo><todo>   "TODO: Should render steps as an ordered list."</todo><r>***50 lines of code ***</r></pre><pre><b>test010GivenWhenThen</b><comment>   "Test the test frame"</comment></pre><pre><b>test011GivenWhenThenFail</b><comment>   "Dry test the test frame"</comment></pre><pre><b>test100BasicWiring</b><comment>   "A Hum view frame is rendered as a Seaside Form."</comment><comment>   "Initialize the View Frame for this test."</comment><comment>   "Create HumView as interface between Ontology and Seaside"</comment><comment>   "Generate Seaside code for the view frame."   </comment></pre><pre><b>test102BasicWiring2</b><comment>   "A Hum view frame is rendered as a Seaside Form."</comment><comment>   "Initialize the View Frame for this test."</comment><comment>   "Add markup lines."</comment><comment>   "Create HumView as interface between Ontology and Seaside"</comment><comment>   "Generate Seaside code for the view frame."   </comment><r>***23 lines of code ***</r></pre><pre><b>test105BindWidgetToBlackboard</b><comment>   "A widget may be bound to blackboard"</comment><comment>   "wire it up -- No worldbase for this test."</comment><comment>   "Test flow: widget ==&gt; blackboard ==&gt; world base"</comment><r>***21 lines of code ***</r></pre><pre><b>test107BindWidgetToCategory</b><comment>   "A widget may be bound to blackboard"</comment><comment>   "wire it up"</comment><comment>   "Test flow: widget ==&gt; blackboard ==&gt; world base"</comment><r>***22 lines of code ***</r></pre><pre><b>test110ViewHasViewTag</b><comment>   "A Hum view frame is rendered as a Seaside Form.   "</comment><comment>   "Initialize the View Frame for this test."</comment><comment>   "Add markup lines."</comment><comment>   "Create HumView as interface between Ontology and Seaside"</comment><comment>   "Generate Seaside code for the view frame."   </comment><r>***23 lines of code ***</r></pre><pre><b>test120ViewHasFormTag</b><comment>   "A Hum view frame is rendered as a Seaside Form.   "</comment><comment>   "Initialize the View Frame for this test."</comment><comment>   "Add markup lines."</comment><comment>   "Create HumView as interface between Ontology and Seaside"</comment><comment>   "Generate Seaside code for the view frame."   </comment><r>***23 lines of code ***</r></pre><pre><b>test130ViewHasMarkupLines</b><comment>   "A Hum view frame is rendered as a Seaside Form ...</comment><comment>   "</comment><comment>   "Initialize the View Frame for this test."</comment><comment>   "Add markup lines."</comment><comment>   "</comment><comment>   "</comment><comment>   "Create HumView as interface between Ontology and Seaside"</comment><comment>   "Generate Seaside code for the view frame."   </comment><comment>   "Expect break within the form."</comment><r>***33 lines of code ***</r></pre><pre><b>test132ViewHasHeadingLine</b><comment>   "A Hum view frame is rendered as a Seaside Form ...</comment><comment>   "</comment><comment>   "Initialize the View Frame for this test."</comment><comment>   "Add markup lines."</comment><comment>   "Create HumView as interface between Ontology and Seaside"</comment><comment>   "Generate Seaside code for the view frame."   </comment><comment>   "Expect heading within the form."</comment><r>***27 lines of code ***</r></pre><pre><b>test134ViewHasStringWidget</b><comment>   "A Hum view frame is rendered as a Seaside Form ...</comment><comment>   "</comment><comment>   "Initialize the View Frame for this test."</comment><comment>   "Add markup lines."</comment><comment>   "frameEditor addMarkUp: '!! Recipe'."</comment><comment>   "</comment><comment>   "</comment><comment>   "Create HumView as interface between Ontology and Seaside"</comment><comment>   "Generate Seaside code for the view frame."   </comment><comment>   "Expect input within the form."</comment><r>***33 lines of code ***</r></pre><pre><b>test135ViewUptoWidget</b><comment>   "A Hum view frame is rendered as a Seaside Form ...</comment><comment>   "</comment><comment>   "Initialize the View Frame for this test."</comment><comment>   "Add markup lines."</comment><comment>   "frameEditor addMarkUp: '!! Recipe'."</comment><comment>   "</comment><comment>   "</comment><comment>   "Create HumView as interface between Ontology and Seaside"</comment><comment>   "Generate Seaside code for the view frame."   </comment><comment>   "Expect input within the form."</comment><r>***33 lines of code ***</r></pre><pre><b>test136ViewHasTextWidget</b><comment>   "A Hum view frame is rendered as a Seaside Form ...</comment><comment>   "</comment><comment>   "Initialize the View Frame for this test."</comment><comment>   "Add markup lines."</comment><comment>   "frameEditor addMarkUp: '!! Recipe'.</comment><comment>   "</comment><comment>   "</comment><comment>   "</comment><comment>   "Create HumView as interface between Ontology and Seaside"</comment><comment>   "Generate Seaside code for the view frame."   </comment><comment>   "Expect test area within the form."</comment><r>***35 lines of code ***</r></pre><pre><b>test138ViewHasDateWidget</b><comment>   "A Hum view frame is rendered as a Seaside Form ...</comment><comment>   "</comment><comment>   "Initialize the View Frame for this test."</comment><comment>   "Add markup lines."</comment><comment>   "Create HumView as interface between Ontology and Seaside"</comment><comment>   "Generate Seaside code for the view frame."   </comment><comment>   "Expect date input within the form."</comment><r>***27 lines of code ***</r></pre><pre><b>test139ViewHasCategoryWidget</b><comment>   "A Hum view frame is rendered as a Seaside Form ...</comment><comment>   "</comment><comment>   "Initialize the View Frame for this test."</comment><comment>   "Add markup lines."</comment><comment>   "Create HumView as interface between Ontology and Seaside"</comment><comment>   "Generate Seaside code for the view frame."   </comment><comment>   "Expect date input within the form."</comment><r>***27 lines of code ***</r></pre><pre><b>test140ViewHasMeasureWidget</b><comment>   "A Hum view frame is rendered as a Seaside Form ...</comment><comment>   "</comment><comment>   "Initialize the View Frame for this test."</comment><comment>   "Add markup lines."</comment><comment>   "Create HumView as interface between Ontology and Seaside"</comment><comment>   "Generate Seaside code for the view frame."   </comment><comment>   "Expect date input within the form."</comment><r>***27 lines of code ***</r></pre><pre><b>test150ViewLineHasSeveralWidgets</b><comment>   "A Hum view frame is rendered as a Seaside Form ...</comment><comment>   "</comment><comment>   "Initialize the View Frame for this test."</comment><comment>   "Add markup lines."</comment><comment>   "Create HumView as interface between Ontology and Seaside"</comment><comment>   "Generate Seaside code for the view frame."   </comment><comment>   "Expect date input within the form."</comment><r>***28 lines of code ***</r></pre><hr/><h3>Hum-Tests -- HumSimulatorTests</h3><pre><b>aDesignNoteEventQueue</b><comment>   "The Simulator provides the means for 'regression testing'.</comment><comment>   "</comment><comment>   "Design Analysis:</comment><comment>   "</comment><comment>   "When events are sparse, or the actual system response time is highly variable, method 'a' is preferred.</comment><comment>   "</comment><comment>   "Method 'b' is typically more convenient for animations where the concept of frame-rate applies.</comment><comment>   "</comment><comment>   "On the whole, method 'a' appears to be more flexible. So that is what we will implement.</comment><comment>   "</comment><r>***40 lines of code ***</r></pre><pre><b>setUpBasicConfigurationOn: aHumSimulator </b><return>   ^setup. "Return dictionary of actors to simplify test and debug."      </return></pre><pre><b>setUpDogAndPonyConfigurationOn: aHumSimulator </b><comment>   "Attach the configuration to the Simulator. "</comment><comment>   "Instantiate the infrastructure agents."</comment><comment>   "Instantiate the worker agents."</comment><comment>   "Return a dictionary of actors for test convenience."</comment><return>   ^myActors.</return><r>***34 lines of code ***</r></pre><pre><b>setUpDogAndPonyOntology</b><comment>   "When this ontology runs,</comment><comment>   ""</comment><comment>   "Root of plan"</comment><comment>   ""</comment><comment>   ""</comment><comment>   "planFrame3 addPrecondition: 'Pony is in the ring.' annotation: 'assumed'."</comment><comment>   ""</comment><comment>   ""</comment><comment>   ""</comment><comment>   "testOntology inspect.</comment><return>   ^testOntology.</return><r>***52 lines of code ***</r></pre><pre><b>setUpHotelOntology</b><comment>   "Provide a set of vignettes."</comment><return>   ^testOntology.   </return><r>***30 lines of code ***</r></pre><pre><b>setUpKnockKnockOnOntology: anOntology</b><comment>   "Provide a view frame."</comment><comment>   "Provide a dictionary frame."</comment></pre><pre><b>testX100SimulatorReadMe</b><comment>   "The Simulator provides the means for 'regression testing'.</comment><comment>   "</comment><comment>   "Simulations 'load' the system under test by starting dialog sequences </comment><comment>   "</comment><comment>   "The simulator (Scribe?) emulates a human response rate </comment><comment>   "</comment><comment>   "A simulation loads 'events' into a time-sorted queue and sends the events asynchronously.</comment><comment>   "</comment><r>***25 lines of code ***</r></pre><pre><b>testX101RepresentDialogSequence</b><comment>   "Simulations 'load' the system under test by starting dialog sequences </comment><comment>   "Represent a dialog sequence as an sequencable collection or array."</comment></pre><pre><b>testX102RepresentRandomIntervals</b><comment>   "Simulations 'load' the system under test by starting dialog sequences </comment><comment>   "</comment><comment>   "Express the distribution as an S-curve in seconds."</comment><todo>   "TODO: This random execution concept has not been implemented yet."</todo></pre><pre><b>testX103RepresentNumberOfDialogs</b><comment>   "Simulations 'load' the system under test by starting dialog sequences </comment><comment>   "</comment><todo>   "TODO: This parallel execution concept has not been implemented yet."</todo></pre><pre><b>testX110AddEventToQueue</b><comment>   "A simulation loads client speech-acts into a queue with a specified delay.</comment><comment>   "</comment><comment>   "Speech acts are interpreted by dialog vignettes in an ontology."</comment></pre><pre><b>testX112AddTwoEventsToQueue</b><comment>   "A simulation loads client speech-acts into a queue with a specified delay.</comment><comment>   "</comment><comment>   "Speech acts are interpreted by dialog vignettes in an ontology."</comment></pre><pre><b>testX120Step</b><comment>   "A simulation loads client speech-acts into a queue with a specified delay.</comment><comment>   "</comment><comment>   "set up"</comment><comment>   "Speech acts are interpreted by dialog vignettes in an ontology."</comment><comment>   "Examine log for expected event and values."</comment><r>***28 lines of code ***</r></pre><pre><b>testX122StepStep</b><comment>   "A simulation loads client speech-acts into a queue with a specified delay.</comment><comment>   "</comment><comment>   "set up"</comment><comment>   "Speech acts are interpreted by dialog vignettes in an ontology."</comment><comment>   "Examine logs for expected event and values."</comment><r>***40 lines of code ***</r></pre><pre><b>testX124StepUntilDone</b><comment>   "A simulation loads client speech-acts into a queue with a specified delay.</comment><comment>   "</comment><comment>   "Given: set up"</comment><comment>   "Speech acts are interpreted by dialog vignettes in an ontology."</comment><comment>   "simulator log4Dialog inspect."</comment><comment>   "Examine logs for expected event and values."</comment><r>***34 lines of code ***</r></pre><pre><b>testX130DialogUsesScribe</b><comment>   "There should be a Scribe in the chain.</comment><comment>   "</comment><comment>   "setup"</comment><comment>   "Speech acts are interpreted by dialog vignettes in an ontology."</comment><comment>   "Examine log for expected event and values."</comment><comment>   "Verify that a Scribe is involved."</comment><r>***32 lines of code ***</r></pre><pre><b>testX140VignetteTriggersGoal</b><comment>   "A vignette may trigger a goal."</comment><comment>   "setup"</comment><comment>   "Speech acts are interpreted by dialog vignettes in an ontology."</comment><comment>   "Verify that expected messages were sent."</comment><comment>   "Expect logs for coordinator dispatcher bookkeeper worldbase dog pony band."</comment><r>***26 lines of code ***</r></pre><pre><b>testX142RunClubMech</b><comment>   "A vignette may trigger a goal."</comment><comment>   "set up"</comment><comment>   "Speech acts are interpreted by dialog vignettes in an ontology."</comment><comment>   "Verify that expected messages were sent."</comment><comment>   "WHEN: Client enters data (speaker, title, description) and presses [Go!] button ... "</comment><comment>   "THEN: WorldBase should have a topic entity with attribute values for speaker, title, description. "</comment><comment>   "WorldBase should contain user`s name, topic`s speaker, title, description"</comment><comment>   "Enter a second topic. Result should be a second topic instance, not an updated version of first topic."</comment><comment>   "At this point, 'Clear topic' instruction should have cleared topic entries from blackboard."</comment><r>***76 lines of code ***</r></pre><pre><b>testX143RunBarista</b><comment>   "A vignette may trigger a goal."</comment><comment>   "set up"</comment><comment>   "Speech acts are interpreted by dialog vignettes in an ontology."</comment><comment>
  "2015-01-22: Data is not being passed from order to worker. "</comment><todo>   "TODO: Simulate form fill-in."</todo><comment>  "2015-01-22: Fails because polymorphism is not implemented."</comment><todo>   "TODO: Implement polymorphism."</todo><comment>   "Verify that expected messages were sent."</comment><r>***41 lines of code ***</r></pre><pre><b>testX144RunDonutShop</b><comment>   "A vignette may trigger a goal."</comment><comment>   "set up"</comment><comment>   "Speech acts are interpreted by dialog vignettes in an ontology."</comment><comment>   "Verify that expected messages were sent."</comment><r>***31 lines of code ***</r></pre><pre><b>testX150RunParallel</b><comment>   "A vignette may trigger a goal."</comment><comment>   "Speech acts are interpreted by dialog vignettes in an ontology."</comment><comment>   "Verify that expected messages were sent."</comment><comment>   "Verify that expected messages were sent."</comment><comment>   "Expect logs for coordinator dispatcher bookkeeper worldbase dog pony band."</comment><r>***35 lines of code ***</r></pre><hr/><h3>Hum-Tests -- HumTestCase</h3><pre><b>assert: stringA sameAs: stringB </b></pre><pre><b>assertPattern: stringPattern matches: string </b></pre><pre><b>ensure</b><comment>   "I think this belongs under HClientServerTests"</comment></pre><pre><b>ensureBlock: aBlock</b><comment>   "I think this belongs under HClientServerTests"</comment></pre><pre><b>eventSeen</b><return>   ^ eventSeen ifNil: [ eventSeen := 'No value was preset.' ]</return></pre><pre><b>eventSeen: anObject </b><comment>   "Set my one-shot memory of the last event seen."</comment></pre><pre><b>expect: expectedValue actual: actualValue </b><return>         ^self assert: (( expected compare: actual caseSensitive: true ) = 2)</return></pre><pre><b>expect: expectedValue actual: actualValue description: aDescription </b></pre><pre><b>pattern: stringPattern matches: string </b></pre><pre><b>signal</b><comment>   "I think method this belongs under HClientServerTests"</comment></pre><pre><b>update: anObject</b><comment>   "This is called by event handler."</comment></pre><hr/><h3>Hum-Tests -- HumTextEditorTests</h3><pre><b>test110ArrowKeys</b><r>***23 lines of code ***</r></pre><pre><b>test120NormalKeys</b><r>***30 lines of code ***</r></pre><pre><b>test130BreakLine</b></pre><pre><b>test140DeleteKey</b><comment>   "If cursor column &gt; 1, delete character to the left of cursor and decrement column position."</comment><comment>   "Set up"</comment><comment>   "Delete one character"</comment></pre><pre><b>test150DeleteLine</b><comment>   "If cursor column = 1, append current line to prior line and move remaining lines up."</comment><comment>   "Set up three lines"</comment><comment>   "Move cursor to start of second line."</comment><comment>   "Delete one character"</comment><r>***22 lines of code ***</r></pre><pre><b>test208CharacterizeStringDraw</b><comment>   "Tinker until we learn what we need to know about canvas, form, font integration."</comment><comment>   "Option to display the form"</comment><comment>   "This canvas has no background, so it will be tranparent when displayed."</comment></pre><pre><b>test209CharacterizeStringDraw</b><comment>   "Tinker until we learn what we need to know about canvas, form, font integration."</comment><comment>   "Paint background and border."</comment><comment>   "Option to display the form"</comment><r>***25 lines of code ***</r></pre><pre><b>test226DrawSeveralTextLinesOnPane</b><comment>   "TextEditor draws its lines on a HumPane -- ???"</comment><todo>   "TODO: To be internally consistent, </todo><comment>   "</comment><comment>   "Option to display the pane"</comment><r>***30 lines of code ***</r></pre><hr/><h3>Hum-Tests -- HumUserInterfaceTests</h3><pre><b>aReadMe</b><comment>   "See the class description for the intended (future) tests."</comment><return>   ^'See the class description for the intended (future) tests.'</return></pre><pre><b>aReadMe2</b><comment>"</comment><comment>"   </comment><r>***32 lines of code ***</r></pre><pre><b>aReadMe3</b><return>^'</return><comment>"*** Learn how GL connects to viewports. ***"</comment><r>***25 lines of code ***</r></pre><pre><b>aReadMe4</b><return>^'Test Driven Design       (Decide if the following cascade makes sense.)</return><r>***54 lines of code ***</r></pre><pre><b>assert: x equals: a or: b</b></pre><pre><b>buildAvatar</b><comment>   "Create example to indicate development idea/s."</comment><comment>   "Color"</comment><comment>   "Assemble."</comment><return>   ^avatar.</return><r>***30 lines of code ***</r></pre><pre><b>buildTrailerAssembly</b><comment>   "Build trailer - to be used in other tests."</comment><comment>   "deck"</comment><comment>  "walls"</comment><comment>   "Assembly deck and walls"</comment><comment>   "======= bed room ========"</comment><comment>   "closets"</comment><comment>   "======= bath room ==========="</comment><comment>   "Postion hand sink above toilet but below topSpace - top will be ~ 1 meter ~ 40 inches above floor"</comment><comment>   "Position shower by East wall (east of center aisle in bath roos)"</comment><comment>   "======== galley =========="</comment><comment>   "Assure shoulder room at table" </comment><comment>   "Reset interior length"</comment><comment>   "Transcript cr; show: 'buildTrailer'; cr; show: 'corrected interior length = ', interiorLength asString; cr."</comment><comment>   "Correct south wall position"</comment><return>   
   ^trailer.</return><r>***117 lines of code ***</r></pre><pre><b>buildTrailerNoseCurve</b><comment>   "Return curve of #(x y) where x = 0 is front-most point, y is offset from centerline"</comment><comment>   "Transcript cr; show: '========='."</comment><comment>         "Transcript cr; show: (x printShowingDecimalPlaces:2),'==&gt;',(y printShowingDecimalPlaces:2)."</comment><return>   ^curve </return></pre><pre><b>buildTrailerScene</b><comment>   "Build trailer scene - to be used in other tests."</comment><comment>   "deck"</comment><comment>  "walls"</comment><comment>   "Assembly deck and walls"</comment><comment>   "======= bed room ========"</comment><comment>   "closets"</comment><comment>   "======= bath room ==========="</comment><comment>   "Postion hand sink above toilet but below topSpace - top will be ~ 1 meter ~ 40 inches above floor"</comment><comment>   "Position shower by East wall (east of center aisle in bath roos)"</comment><comment>   "======== galley =========="</comment><comment>   "Assure shoulder room at table" </comment><comment>   "Reset interior length"</comment><comment>   "Transcript cr; show: 'buildTrailer'; cr; show: 'corrected interior length = ', interiorLength asString; cr."</comment><comment>   "Correct south wall position"</comment><r>***119 lines of code ***</r></pre><pre><b>checkViewPortMorph</b><return>   ^ checkViewPortMorph ifNil: [ checkViewPortMorph := false ].</return></pre><pre><b>checkViewPortMorph: aBoolean</b></pre><pre><b>expect: actualValue is: expectedValue </b><comment>   "syntax sugar"</comment><return>   ^ self expect: expectedValue actual: actualValue.</return></pre><pre><b>for: someExpression expect: someResult</b><return>   ^self expect: someResult actual: someExpression</return></pre><pre><b>lastChange</b><return>   ^ lastChange </return></pre><pre><b>showViewPort: aHumViewPort </b></pre><pre><b>test110surfaceHasOrigin</b><comment>   "A surface is initialized with a origin object which is zerosized and at 0,0."</comment></pre><pre><b>test120surfaceSizeIsDurable</b><comment>   "A surface is initialized with a origin object which is zero-sized and at 0,0."</comment><comment>   "Note: Dimensions used here are not typical - They are just for testing convenience."</comment><comment>   "Bump surface over the the right."</comment><comment>   "Bump surface up."</comment><comment>   "Bump surface from bottom."</comment><comment>   "Pull surface via the right edge."</comment></pre><pre><b>test130surfaceLayers</b><comment>   "An Surface Assembly has multiple shapes in one or more layers ."</comment><comment>   "Note: Dimensions used here are not typical - They are just for testing convenience."</comment><comment>   "Put rectangle A on the surface."</comment><comment>   "Overlay rectangle B on top of rectangle A"</comment><comment>   "By convention, the top and left edges will align."</comment><comment>   "And other edges should be:"</comment><comment>   "By convention, the layer is greater for the thing on top."</comment><r>***35 lines of code ***</r></pre><pre><b>test135surfaceBoundingBox</b><comment>   "An pane has a bounding box determined by the min/max of its collection of shapes."</comment><comment>   "Note: Dimensions used here are meaningless - They are just for testing convenience."</comment><comment>   "Put rectangle A on the pane."</comment><comment>   "Put rectange B on top of rectangle A"</comment><comment>   "By convention, the top and left edges will align."</comment><comment>   "By convention, the layer is greater for the thing on top."</comment><comment>   "Expect bounding box metrics to be . . ."</comment><r>***36 lines of code ***</r></pre><pre><b>test140surfaceLayout</b><comment>   "A surface is initialized with a origin shape which is zero-sized and at 0,0."</comment><comment>   "Note: Dimensions used here are arbitrary - They are just for testing convenience."</comment><comment>   "Put rectangle A on the surface."</comment><comment>   "Put B below A."</comment><comment>   "By convention B is in same layer as A. (They are side by side in the same layer. )"</comment><comment>   "Now put B above A. "</comment><comment>   "Now put B left of A."</comment><comment>   "Now put B right of A."</comment><r>***41 lines of code ***</r></pre><pre><b>test150surfaceLayoutForPA</b><comment>   "Test for usability -- Consider a layout like the PA."</comment><comment>   "NOTE: Dimensions used here are ages of the container !!!"</comment><comment>   "Create the main divisions."</comment><comment>   "Assemble them."</comment><comment>   "Create editStack divisions and assemble them."</comment><comment>   "Create diagramStack divisions."</comment><r>***46 lines of code ***</r></pre><pre><b>test210boxHasOrigin</b><comment>   "A box is initialized with a origin object which is zero-sized and at 0,0."</comment></pre><pre><b>test210surfaceAsSVG</b><comment>   "Test for usability -- Consider a layout like the PA."</comment><comment>   "Get the SVG string for this assembly."</comment></pre><pre><b>test220boxSizeIsDurable</b><comment>   "When we move an edge, the width, height, and length are not affected."</comment><comment>   "Bump box over to the the East by pushing on the West edge."</comment><comment>   "Bump box up."</comment><comment>   "Bump box from bottom."</comment><comment>   "Pull box via the East edge."</comment><comment>   "Bump box to the South by pushing on the North edge."</comment><comment>   "Pull box to the South by pulling on the South edge."</comment><r>***24 lines of code ***</r></pre><pre><b>test220surfaceAsSvgViewBox</b><comment>   "Test for usability -- Consider a layout like the PA."</comment><comment>   "Get the SVG string for this assembly."</comment><r>***22 lines of code ***</r></pre><pre><b>test230boxIsAContainer</b><comment>   "Boxes may contain other spaces. Boxes are container-like."</comment><comment>   ""</comment></pre><pre><b>test240boxLayout</b><comment>   "We can position boxes using absolute position values and relative positions."</comment><comment>   ""</comment><comment>   "Set absolute position (centroid)"</comment><comment>   "Position boxes relative to each other."</comment><comment>   "Place B on top of A."</comment><comment>   "Place B under A."</comment><comment>   "Place B on East side of A."</comment><comment>   "Place B on West side of A."</comment><comment>   "Place B on North side of A."</comment><comment>   "Place B on South side  of A."</comment><r>***46 lines of code ***</r></pre><pre><b>test250boxCentering</b><comment>   "Center one box on top of another."</comment><comment>   "Default unit of measure is meter."</comment><comment>   "Center B on top of A."</comment></pre><pre><b>test255surfaceAssemblyAsSVG</b><comment>   "Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."</comment><comment>   "Create the main divisions. NOTE: Dimensions will default to inches"</comment><comment>   "Assemble them."</comment><comment>   "Create editStack divisions and assemble them."</comment><comment>   "Create diagramStack divisions."</comment><comment>   "Get the SVG string for this assembly."</comment><comment>   "Transcript cr; show: 'test255surfaceAssemblyAsSVG'; cr; show: svgString; cr."</comment><r>***48 lines of code ***</r></pre><pre><b>test260surfaceAssemblyAsSvgPercent</b><comment>   "Test for usability -- Consider a layout like the PA."</comment><comment>   "NOTE: Dimensions used here are percentages of the container !!!"</comment><comment>   "Create the main divisions."</comment><comment>   "Assemble them."</comment><comment>   "Create editStack divisions and assemble them."</comment><comment>   "Create diagramStack divisions."</comment><comment>   "Get the SVG string for this assembly."</comment><comment>   "Transcript cr; show: 'from test260surfaceAssemblyAsSvgPercent: ; cr; show: svgString; cr."</comment><r>***53 lines of code ***</r></pre><pre><b>test270surfaceAssemblyAsSvgInch</b><comment>   "Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."</comment><comment>   "Create the main divisions."</comment><comment>   "Assemble them."</comment><comment>   "Create editStack divisions and assemble them."</comment><comment>   "Create diagramStack divisions."</comment><comment>   "Get the SVG string for this assembly."</comment><comment>   "Transcript cr; show: svgString; cr."</comment><r>***54 lines of code ***</r></pre><pre><b>test310spaceHasOrigin</b><comment>   "A space is initialized with a origin object which is zero-sized and at 0,0."</comment></pre><pre><b>test310surfaceAsXML</b><comment>   "First principle: Express a hum surface as XML.</comment><comment>   "</comment><comment>   "Get the SVG string for this assembly."</comment><comment>   "Transcript cr; show: 'from test310surfaceAsXML : '; cr; show: xmlString; cr."</comment><r>***22 lines of code ***</r></pre><pre><b>test320spaceSizeIsDurable</b><comment>   "When an edge is moved, the opposite edge is also moved."</comment><comment>   "Bump space over to the the East by pushing on the West edge."</comment><comment>   "Bump space up."</comment><comment>   "Bump space from bottom."</comment><comment>   "Pull space via the East edge."</comment><comment>   "Bump space to the South by pushing on the North edge."</comment><comment>   "Pull space to the South by pulling on the South edge."</comment><r>***24 lines of code ***</r></pre><pre><b>test320surfaceAssemblyAsXML</b><comment>   "Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."</comment><comment>   "NOTE: Dimensions used here are percentages of the container !!!"</comment><comment>   "Create the main divisions."</comment><comment>   "Assemble them."</comment><comment>   "Create editStack divisions and assemble them."</comment><comment>   "Create diagramStack divisions."</comment><comment>   "Get the SVG string for this assembly."</comment><comment>   "Transcript cr; show: 'from test320surfaceAssemblyAsXML'; cr; show: xmlString; cr."</comment><r>***56 lines of code ***</r></pre><pre><b>test330spaceContainer</b><comment>   "We can specify a box position in terms of its centroid."</comment><comment>   ""</comment><comment>   "Note: These box positions are relative to the container`s edges."</comment></pre><pre><b>test340spaceLayout</b><comment>   "HumAssembly may position its parts relative to itself and each other."</comment><comment>   ""</comment><comment>   "Place B on top of A."</comment><comment>   "Place B under A."</comment><comment>   "Place B on East side of A."</comment><comment>   "Place B on West side of A."</comment><comment>   "Place B on North side of A."</comment><comment>   "Place B on South side  of A."</comment><r>***44 lines of code ***</r></pre><pre><b>test350assemblyDimensions</b><comment>   "A HumAssembly dimensions enclose whatever is inside the assembly"</comment><comment>   ""</comment><comment>   "Note: These positions are relative to the container`s origin."</comment><comment>   "Place B on top of A."</comment><comment>   "Place B under A."</comment><comment>   "Place B on East side of A."</comment><comment>   "Place B on West side of A."</comment><comment>   "Place B on North side of A."</comment><comment>   "Place B on South side  of A."</comment><comment>   "Test bounding box of the assembly."</comment><comment>   "Test bounding box edges of the assembly."</comment><r>***61 lines of code ***</r></pre><pre><b>test410surfaceAsHTML</b><comment>   "Test for usability -- Consider a layout like the PA."</comment><comment>   "This #asHTML  feature is deferred until javascript code is written to enable it."</comment><comment>   "Get the SVG string for this assembly."</comment><r>***21 lines of code ***</r></pre><pre><b>test470surfaceAssemblyAsHTML</b><comment>   "Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."</comment><comment>   "This feature is deferred until javascript code is written to enable it."</comment><return>      ^self skip ].</return><comment>   "NOTE: Dimensions used here are percentages of the container !!!"</comment><comment>   "Create the main divisions."</comment><comment>   "Assemble them."</comment><comment>   "Create editStack divisions and assemble them."</comment><comment>   "Create diagramStack divisions."</comment><comment>   "Get the SVG string for this assembly."</comment><r>***58 lines of code ***</r></pre><pre><b>test510surfaceAsHumScript</b><comment>   "Test first principle: Produce a hum action call.</comment><comment>   "</comment><comment>   "This #asHTML  feature is deferred until javascript code is written to enable it."</comment><comment>   "Get the SVG string for this assembly."</comment><comment>   "Expect something like '. Painter: Paint surface with id 'window' width '800 px' height '450 px'.   "</comment><comment>   "Transcript cr; show: 'from test510surfaceAsHumScript '; cr; show: script; cr."</comment><r>***27 lines of code ***</r></pre><pre><b>test570surfaceAssemblyAsHumScript</b><comment>   "Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."</comment><comment>   "This feature is deferred until javascript code is written to enable it."</comment><comment>   "NOTE: Dimensions used here are percentages of the container !!!"</comment><comment>   "Create the main divisions."</comment><comment>   "Assemble them."</comment><comment>   "Create editStack divisions and assemble them."</comment><comment>   "Create diagramStack divisions."</comment><comment>   "Get the SVG string for this assembly."</comment><comment>   "</comment><comment>   "</comment><r>***56 lines of code ***</r></pre><pre><b>testA110addPart</b><comment>   "Add a part to an assembly. Check content and event handling"</comment><comment>   "At this point part1 and part2 should be in assembly`s parts."</comment><comment>   "The assembly should be in the dependents of each part."</comment><comment>   "Whan  part is changed, the assembly should be informed and activate its #changed actions."</comment><comment>   "First check my test bed."</comment><comment>   "Now check for part to assembly notification."</comment><r>***38 lines of code ***</r></pre><pre><b>testA210assembleAvatar</b><comment>   "Create example to indicate development idea/s."</comment><comment>   "Assemble."</comment><comment>   "Assert some expectations"</comment><comment>   "Head is centered. So edges are inboard from torso."</comment><comment>   "But some things were not constrained. So set those also."</comment><todo>   "TODO: Check that constraints are effective."</todo><r>***39 lines of code ***</r></pre><pre><b>testA220colorAvatar</b><comment>   "Create example to indicate development idea/s."</comment><comment>   "Assemble."</comment><comment>   "Color"</comment><comment>   "This is a usability test. Does it pass?"</comment><r>***28 lines of code ***</r></pre><pre><b>testA410x3dAssembly</b><comment>   "render the objects in HumAssembly"</comment><todo>   "TODO: Most parts of this assembly are omitted to temporarily simplify this test. ***"</todo><comment>   "upperArmLeft := HumSolid id: #upperArmLeft type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.   </comment><comment>   "Assemble."</comment><comment>   "Assume avatar is facing us."</comment><comment>   "avatar position: upperArmLeft eastOf: torso.</comment><comment>   "Color"</comment><comment>"   upperArmLeft color: ( Color paleGreen ).   </comment><comment>   "render"</comment><comment>   "Transcript cr; show: 'testS410x3dAssembly'; cr; show: x3d; cr."   </comment><comment>   "Write code out to a file for easier inspection and possible compilation."</comment><r>***37 lines of code ***</r></pre><pre><b>testA420trailerExample</b><comment>   "Test DSL usability - No code is generated by this test."</comment><comment>   "deck"</comment><comment>  "walls"</comment><comment>   "Assembly deck and walls"</comment><comment>   "======= bed room ========"</comment><comment>   "closets"</comment><comment>   "======= bath room ==========="</comment><comment>   "Postion hand sink above toilet but below topSpace - top will be ~ 1 meter ~ 40 inches above floor"</comment><comment>   "Position shower by East wall (east of center aisle in bath roos)"</comment><comment>   "======== galley =========="</comment><comment>   "Assure shoulder room at table" </comment><comment>   "Reset interior length"</comment><comment>   "Transcript cr; show: 'testS420trailerExample'; cr; show: 'corrected interior length = ', interiorLength asString; cr."</comment><comment>   "Correct south wall position"</comment><r>***112 lines of code ***</r></pre><pre><b>testA425trailerExample2</b><comment>   "Test DSL usability -- change #depth to #length -- No code is generated."</comment><comment>   "deck"</comment><comment>  "walls"</comment><comment>   "Assembly deck and walls"</comment><comment>   "======= bed room ========"</comment><comment>   "closets"</comment><comment>   "======= bath room ==========="</comment><comment>   "Postion hand sink above toilet but below topSpace - top will be ~ 1 meter ~ 40 inches above floor"</comment><comment>   "Position shower by East wall (east of center aisle in bath roos)"</comment><comment>   "======== galley =========="</comment><comment>   "Assure shoulder room at table" </comment><comment>   "Reset interior length"</comment><comment>   "Transcript cr; show: 'testS425trailerExample'; cr; show: 'corrected interior length = ', interiorLength asString; cr."</comment><comment>   "Correct south wall position"</comment><r>***112 lines of code ***</r></pre><pre><b>testA430showTrailerLayoutTable</b><comment>   "Display a table of the trailer parts edges.</comment><comment>   "</comment><comment>   "table heading"</comment><comment>   "table rows"</comment></pre><pre><b>testA530assemblyAsThreeJS</b><comment>   "Render a box as a ThreeJS cube"</comment><comment>   "Expect this prolog."   </comment><comment>  "Expect this code fragment -- one of many like this."</comment></pre><pre><b>testA540sceneAsThreeJS</b><comment>   "Render a box as a ThreeJS cube"</comment><comment>   "Expect this scene prolog"</comment><comment>   "Expect this layer prolog. One of several like this."   </comment><comment>  "Expect this code fragment -- one of many like this."</comment><r>***23 lines of code ***</r></pre><pre><b>testA550sceneAsThreeJSinHTML</b><comment>   "Render a box as a ThreeJS cube"</comment><comment>   "write it to a file as see if it compiles and renders"</comment></pre><pre><b>testA600VPythonReadMe</b><comment>   "I started this when my VPython environment started working again.</comment><comment>   "</comment></pre><pre><b>testA625VPythonTrailer</b><comment>   "Generated code should contain BoxThing() instances."</comment><todo>   "TODO: Generated code should contain positioning statements."</todo><comment>   "Write code out to a file for easier inspection and possible compilation."</comment></pre><pre><b>testC210CreateHumCanvas</b><comment>   "HumCanvas provides a wrapper on actual implementation."</comment><comment>   "HumCanvas provides a wrapper on the physical implentation. (So we can move to another one if needed)"</comment><comment>   "For time being, use the Squeak Canvase API -- May change my mind later."</comment></pre><pre><b>testC211CreateHumCanvas</b><comment>   "HumCanvas provides a wrapper on actual implementation."</comment><comment>   "HumCanvas provides a wrapper on the physical implentation. (So we can move to another one if needed)"</comment><comment>   "For time being, use the Squeak Canvase API -- May change my mind later."</comment></pre><pre><b>testC220DrawRawPolygon</b><comment>   "HumCanvas provides a wrapper on actual implementation."</comment><comment>   "Triangle"</comment><comment>   "Draw it on canvas"</comment></pre><pre><b>testC222DrawHumPolygon</b><comment>   "HumCanvas provides a wrapper on actual implementation."</comment><comment>   "Triangle"</comment><comment>   "Draw it on canvas -- Note: HumCanvas delegates to FormCanvas."</comment></pre><pre><b>testD110CreateDiagram</b><comment>   "Create a diagram with three nodes and two connections."</comment><r>***22 lines of code ***</r></pre><pre><b>testD210LayoutDiagram</b><comment>   "Create a diagram with three nodes and two connections."</comment><comment>  "Layout the diagram."</comment><r>***29 lines of code ***</r></pre><pre><b>testD220LayoutDiagram</b><comment>   "Create a diagram with four nodes and three connections."</comment><comment>  "Layout the diagram."</comment><r>***32 lines of code ***</r></pre><pre><b>testD230LayoutDiagram</b><comment>   "Create a diagram with five nodes and four connections."</comment><comment>  "Layout the diagram."</comment><comment>   "Note nodeC and nodeD will be assigned 12@0 or 12@8. But the choice may be random."      </comment><comment>   "Note nodeC and nodeD will be assigned -12@0 or -12@8. But the choice may be random."      </comment><comment>   "diagram inspect."</comment><r>***49 lines of code ***</r></pre><pre><b>testD310DistanceBetweenNodes</b><comment>   "Calculate the (layout) distance between two nodes."</comment><comment>   "Force the layout 3-4-5 triangle to make this test easier"</comment><comment>   "The distance from nodeA to nodeC should be 50."</comment><r>***34 lines of code ***</r></pre><pre><b>testD321EnergyBetweenNodes</b><comment>   "Calculate the (layout) force between two nodes."</comment><comment>      ";</comment><comment>      "</comment><comment>   "Force the layout to make this test easier"</comment><r>***41 lines of code ***</r></pre><pre><b>testE110EditorPosition</b><comment>   "The editor owns a (cursor) position."</comment><comment>   "Initial position is at front of first line."</comment></pre><pre><b>testE120EditorInsertCharacterAtEndOfLine</b><comment>   "When we insert a character, the cursor advances and the character is in the text string."</comment><comment>   "Initial position of the cursor is line 1, column 1"</comment><comment>   "When a character is inserted at the cursor position, the cursor advances."</comment><comment>   "And, of course, the text has the new character."</comment><comment>   "Insert another character . . ."</comment><comment>   "Editor is a controller. Text is a model. When text is changed, it issues a change notice."</comment><r>***26 lines of code ***</r></pre><pre><b>testE121EditorInsertCharacterAtFrontOfLine</b><comment>   "When we insert a character, the cursor advances and the character is in the text string."</comment><comment>   "Initial position of the cursor is line 1, column 1"</comment><comment>   "When a character is inserted at the cursor position, the cursor advances."</comment><comment>   "And, of course, the text has the new character."</comment><comment>   "Insert another character, but at the front of the line."</comment><r>***22 lines of code ***</r></pre><pre><b>testE130EditorInsertLine</b><comment>   "When we insert a line, the cursor advances to the beginning of the new line."</comment><comment>   "Initial position of the cursor is line 1, column 1"</comment><comment>   "When a character is inserted at the cursor position, the cursor advances."</comment><comment>   "And, of course, the text has the new character."</comment><comment>   "Insert another character . . ."</comment><comment>   "Insert an empty line."</comment><comment>   "We should see event"</comment><r>***33 lines of code ***</r></pre><pre><b>testE131EditorInsertTwoLines</b><comment>   "When we insert a line, the cursor advances to the beginning of the new line."</comment><comment>   "Initial position of the cursor is line 1, column 1"</comment><comment>   "When a character is inserted at the cursor position, the cursor advances."</comment><comment>   "And, of course, the text has the new character."</comment><comment>   "Insert another character . . ."</comment><comment>   "Insert an empty line."</comment><r>***29 lines of code ***</r></pre><pre><b>testE140EditorDeleteCharacterAtEndOfLine</b><comment>   "When we delete a character, the cursor decrements </comment><comment>   "Initial position of the cursor is line 1, column 1"</comment><comment>   "When a character is inserted at the cursor position, the cursor advances."</comment><comment>   "And, of course, the text has the new character."</comment><comment>   "Insert another character . . ."</comment><comment>   "Delete the character at end of line."</comment><r>***30 lines of code ***</r></pre><pre><b>testE141EditorDeleteCharacterAtStartOfLine</b><comment>   "When we delete a character, the cursor decrements </comment><comment>   "Initial position of the cursor is line 1, column 1"</comment><comment>   "When a character is inserted at the cursor position, the cursor advances."</comment><comment>   "And, of course, the text has the new character."</comment><comment>   "Insert another character . . ."</comment><comment>   "Delete the character at end of line."</comment><comment>   "Delete the character at start of line."</comment><r>***33 lines of code ***</r></pre><pre><b>testE142EditorIgnoresDeleteWhenCursorAtStartOfLine</b><comment>   "When we delete a character, the cursor decrements </comment><comment>   "Initial position of the cursor is line 1, column 1"</comment><comment>   "When a character is inserted at the cursor position, the cursor advances."</comment><comment>   "And, of course, the text has the new character."</comment><comment>   "Insert another character . . ."</comment><comment>   "Move cursor to start of line"</comment><comment>   "Attempt delete -- should be ignored"</comment><comment>   "Delete the character at start of line."</comment><r>***32 lines of code ***</r></pre><pre><b>testE143EditorDeleteCharactersWillNotBackOverBeginningOfLine</b><comment>   "When we delete a character, the cursor decrements </comment><comment>   "</comment><comment>   "Initial position of the cursor is line 1, column 1"</comment><comment>   "When a character is inserted at the cursor position, the cursor advances."</comment><comment>   "And, of course, the text has the new character."</comment><comment>   "Insert another character . . ."</comment><comment>   "Delete the character at end of line."</comment><comment>   "Delete the character at start of line."</comment><comment>   "Attempt one more delete."</comment><r>***42 lines of code ***</r></pre><pre><b>testE210InterpretArrowKeys</b><comment>   "The arrow keys move the cursor and forget the selection.</comment><comment>   "</comment><comment>   "When we try to push beyond the current text. The cursor does not move."</comment><r>***47 lines of code ***</r></pre><pre><b>testE220InterpretAltArrowKeys</b><comment>   "The arrow keys move the cursor and forget the selection.</comment><comment>   "</comment><comment>   "When we try to push beyond the current text. The cursor does not move."</comment><r>***50 lines of code ***</r></pre><pre><b>testE230InterpretShiftArrowKeys</b><comment>   "The shift arrow keys move the cursor and update the selection.</comment><comment>   "</comment><comment>   "Go the other way."</comment><r>***58 lines of code ***</r></pre><pre><b>testE310EditorSupportsUnDo</b><comment>   "Editor supports multiple levels of undo."</comment><comment>   "Initial position of the cursor is line 1, column 1"</comment><comment>   "When a character is inserted at the cursor position, the cursor advances."</comment><comment>   "Insert another character . . ."</comment><comment>   "Insert an empty line."</comment><comment>   "Test undo"</comment><comment>   "Multiple levels of undo"</comment><r>***44 lines of code ***</r></pre><pre><b>testE315EditorSupportsUnDoAtBottom</b><comment>   "Editor supports multiple levels of undo - tolerates too many pops."</comment><comment>   "Initial position of the cursor is line 1, column 1"</comment><comment>   "When a character is inserted at the cursor position, the cursor advances."</comment><comment>   "Insert another character . . ."</comment><comment>   "Insert an empty line."</comment><comment>   "Test undo"</comment><comment>   "Multiple levels of undo"</comment><comment>   "Too many undo should not raise exception or produce unexpected side effect."</comment><r>***48 lines of code ***</r></pre><pre><b>testE320EditorSupportsReDo</b><comment>   "Editor supports multiple levels of undo and redo."</comment><comment>   "Initial position of the cursor is line 1, column 1"</comment><comment>   "When a character is inserted at the cursor position, the cursor advances."</comment><comment>   "Insert another character . . ."</comment><comment>   "Insert an empty line."</comment><comment>   "Test undo"</comment><comment>   "Multiple levels of undo"</comment><comment>   "Multiple levels of redo"</comment><r>***53 lines of code ***</r></pre><pre><b>testE325EditorSupportsReDoToBottom</b><comment>   "Editor supports multiple levels of undo and redo."</comment><comment>   "Initial position of the cursor is line 1, column 1"</comment><comment>   "When a character is inserted at the cursor position, the cursor advances."</comment><comment>   "Insert another character . . ."</comment><comment>   "Insert an empty line."</comment><comment>   "Test undo"</comment><comment>   "Multiple levels of undo"</comment><comment>   "Multiple levels of redo"</comment><comment>   "Tolerate one too many."</comment><r>***57 lines of code ***</r></pre><pre><b>testS110boxFacesAsPolygons</b><comment>   "Expect South face"</comment></pre><pre><b>testS120boxVolumeMassWeight</b></pre><pre><b>testS200x3dReadMe</b><comment>   "   TODO: X3D is my preferred target language for 3D visualization.</comment><comment>   "</comment></pre><pre><b>testS210x3dColor</b><comment>   "HumSolid x3dColor should produce a X3D color string"</comment></pre><pre><b>testS220x3dExtent</b><comment>   "Produce a x3d box extent from my length width height"</comment></pre><pre><b>testS230x3dCenter   </b><comment>   "Produce a x3d box position from my length width height (and default position)"</comment></pre><pre><b>testS310x3dMaterial</b><comment>   "HumSolid x3dMaterial should produce a X3D xml string"</comment></pre><pre><b>testS320x3dShape</b><comment>   "Produce a x3d box extent from my length width height"</comment></pre><pre><b>testS500ThreeJSReadMe</b><comment>   "The advantage of ThreeJS is that it runs WebGL in a relatively straight-forward manner.</comment><comment>   "</comment></pre><pre><b>testS505ThreeJSColor</b><comment>   "HumSolid three.js needs HTML color string"</comment></pre><pre><b>testS520ThreeJSBox</b><comment>   "Produce a Three.js cube with my length width height and position"</comment></pre><pre><b>testS610VPythonThing</b><comment>   "Produce a VPython Thing.py box with my length width height and position"</comment></pre><pre><b>testS615VPythonSpace</b><comment>   "Produce a VPython Thing.py box with my length width height and position, but not visible"</comment></pre><pre><b>testS620VPythonPreamble</b><comment>   "Produce a general purpose VPython scene preamble "</comment><r>***24 lines of code ***</r></pre><pre><b>testS710changed</b><comment>   "#changed is propagated to parent, dependents."</comment></pre><pre><b>testT110initialTextHasOneEmptyLine</b><comment>   "When it is initialized, there is one empty line.</comment><comment>   "</comment><comment>      "Initial position of the cursor is line 1, column 1"</comment></pre><pre><b>testT115initialTextCopyHasOneEmptyLine</b><comment>   "When it is initialized, there is one empty line.</comment><comment>   "</comment><comment>   "Initial position of the cursor is line 1, column 1"</comment></pre><pre><b>testV100ReadMe</b><comment>   "The current viewport uses low-level graphics functions rather than Morph. </comment><comment>   "</comment></pre><pre><b>testV105CreateCamera</b><comment>   "The camera is modeled by a pin-hole box camera."</comment><comment>   "Camera should be positioned at adult eye-height."</comment><comment>   "Default camera has westEdge to match westEdge of a newly created BillBoard."</comment></pre><pre><b>testV110PositionCameraFacingBillboard</b><comment>   "The default/initial viewport frustrum is laid directly onto the surface.</comment><comment>   "</comment><comment>   "Create a simple billboard with three surfaces."</comment><comment>   "Create a billboard and put it into a scene."</comment><r>***44 lines of code ***</r></pre><pre><b>testV115PanCameraUpDownLeftRight</b><comment>   "Move the camera in the scene to effect pan motion."</comment><comment>   "Create a billboard and put it into a scene."</comment><r>***22 lines of code ***</r></pre><pre><b>testV116CameraRotateSlideForward</b><comment>   "Move the camera in the scene to effect pan motion."</comment><comment>   "Create a billboard and put it into a scene."</comment><r>***37 lines of code ***</r></pre><pre><b>testV117CameraRotateSlideSideways</b><comment>   "Move the camera in the scene to effect pan motion."</comment><comment>   "Create a billboard and put it into a scene."</comment><r>***37 lines of code ***</r></pre><pre><b>testV118CameraRotateSlideUpDown</b><comment>   "Move the camera in the scene to effect pan motion."</comment><comment>   "Create a billboard and put it into a scene."</comment><r>***37 lines of code ***</r></pre><pre><b>testV120MapPointsFromSceneToViewport</b><comment>   "In an orthographic projection, </comment><comment>   "</comment><comment>   ""</comment><comment>   "Note: These positions are relative to the container`s origin."</comment><comment>   "Place B on top of A."</comment><comment>   "Place B on East side of A."</comment><comment>   "Place B on North side of A."</comment><comment>   "Put camera in the scene. Attach a viewport to the camera."</comment><comment>   "Position camera"</comment><comment>   "Project the 3D points onto the 2D surface."</comment><comment>   "viewportPolygons inspect." </comment><r>***49 lines of code ***</r></pre><pre><b>testV200ReadMe</b><comment>   "This group characterizes the low level drawing infrastructure </comment></pre><pre><b>testV300checkViewPortMorph</b><comment>   "This group characterizes the low level drawing infrastructure </comment></pre><pre><b>testV310ConnectViewPortToHumCanvas</b><comment>   "HumCanvas provides a wrapper on actual implementation."</comment><comment>   "Connect the viewport to the canvas."</comment><comment>   "The viewport will paint itself onto the canvas at the given canvas coordinates."</comment></pre><pre><b>testV320DrawPolygon</b><comment>   "Draw a 2D polygon on the viewport canvas."</comment><comment>   "Connect the viewport to the canvas."</comment><comment>   "The viewport will paint itself onto the canvas at the given canvas coordinates."</comment><comment>   "Polygon -- Triangle in canvas pixel coordinates."</comment><comment>   "Paint the polygon onto a Surface."</comment><comment>   "Reset height and width to fit content."</comment><comment>   "Tranlate the surface into a Billboard."</comment><comment>   "Put the Billboard into a Scene."</comment><comment>   "Put a Camera in the Scene and attach it to a ViewPort."</comment><comment>   "Project the scene into the ViewPort."</comment><comment>   "Render the ViewPort onto the assigned Canvas."</comment><comment>   "Display the Canvas to see what we got."</comment><r>***35 lines of code ***</r></pre><pre><b>testV330DrawABox</b><comment>   "Draw a 3D box on the viewport - use perspective projection."</comment></pre><pre><b>testV331PaintABox</b><comment>   "Draw a 3D box on the viewport - use perspective projection."</comment></pre><pre><b>testV332PaintAPyramid</b><comment>   "Draw a 3D box on the viewport - use perspective projection."</comment></pre><pre><b>testV333PaintARotation</b><comment>   "Draw a 3D box on the viewport - use perspective projection."</comment></pre><pre><b>testV334PaintACylinder</b><comment>   "Draw a 3D box on the viewport - use perspective projection."</comment></pre><pre><b>testV334PaintAnElipsoid</b><comment>   "Draw a 3D box on the viewport - use perspective projection."</comment><comment>"   xy := OrderedCollection new.</comment><comment>"   </comment><r>***21 lines of code ***</r></pre><pre><b>testV335PaintAThing</b><comment>   "Draw a 3D thing on the viewport - use perspective projection."</comment></pre><pre><b>testV335PaintATorus</b><comment>   "Draw a 3D thing on the viewport - use perspective projection."</comment><comment>   "scene center: camera at: { 40. -40. 30. }.</comment></pre><pre><b>testV336DrawAThing</b><comment>   "Draw a 3D thing on the viewport - use perspective projection."</comment></pre><pre><b>testV336WireframeATorus</b><comment>   "Draw a 3D thing on the viewport - use perspective projection."</comment></pre><pre><b>testV337DrawAThingWireFrame</b><comment>   "Draw a 3D box on the viewport - use perspective projection."</comment></pre><pre><b>testV338DrawABoxAsTriangles</b><comment>   "Draw a 3D box on the viewport - use perspective projection."</comment></pre><pre><b>testV345DrawASolidRotated</b><comment>   "Draw a 3D box on the viewport - use perspective projection."</comment></pre><pre><b>testV346DrawASolidTilted</b><comment>   "Draw a 3D box on the viewport - use perspective projection."</comment></pre><pre><b>testV347DrawASolidRotatedAndTilted</b><comment>   "Draw a 3D box on the viewport - use perspective projection."</comment></pre><pre><b>testV350paintAvatar</b><comment>   "camera rotateRight: (90 degrees)."</comment></pre><pre><b>testW100ReadMe</b><comment>   "Hum Widgets are wrappers on various presentation layer technologies.</comment><comment>   "</comment><comment>   "Hum Widgets are typically bound to a BlackBoard and an Ontology.</comment><comment>   "</comment></pre><pre><b>testW110LayoutContainsOtherWidgets</b><comment>   "A layout widget contains one or more other widgets."</comment><comment>   "Widgets are orderd as added."</comment></pre><pre><b>testW120RowLayout</b><comment>   "A row layout arranges child widgets in a row."</comment></pre><pre><b>testW130ColumnLayout</b><comment>   "A column layout arranges child widgets in a column."</comment></pre><pre><b>testW220RowLayoutHTML</b><comment>   "A row layout arranges child widgets in a row."</comment></pre><pre><b>testW230ColumnLayoutHTML</b><comment>   "A row layout arranges child widgets in a row."</comment></pre><pre><b>testW320RowLayoutAsMorph</b><comment>   "A row layout arranges child widgets in a row."</comment><r>***22 lines of code ***</r></pre><pre><b>testW330ColumnLayoutAsMorph</b><comment>   "A row layout arranges child widgets in a row."</comment><r>***21 lines of code ***</r></pre><pre><b>update: someObject</b><comment>   "Record fact that someObject was updated by a test.</comment><comment>   "</comment></pre><hr/><h3>Hum-Tests -- HumVRTests</h3><pre><b>test100CreateVRwith2scenes</b><comment>   "A virtual reality has one or more scenes."</comment><comment>   "Create a VR world"</comment><comment>   "Create two scenes"</comment><comment>   "Add scenes to world."</comment><comment>   "Start the world - stepping."</comment><comment>   "Stop the world - stop stepping."</comment></pre><hr/><hr/><h2>Hum-UI</h2><hr/><h3>Hum-UI -- HumAssembly</h3><pre><b>addPart: aHumBox</b><comment>   "Add the component to my parts list"</comment><comment>   "When the part is changed, the assembly (me myself) (e.g. scene) will be notified."</comment></pre><pre><b>addParts: aCollection</b><comment>   "Add the component to my parts list"</comment></pre><pre><b>advance: aBox by: anArray </b><comment>   "Move the box by the given increments.</comment><comment>   "</comment><comment>   "Assure that aBox is in my collection. "</comment><comment>   "Compute edge positions to center aBox at those coordinates."</comment><r>***23 lines of code ***</r></pre><pre><b>asPolygons</b><comment>   "Return polygons for my parts."</comment><return>   ^assemblyPolygons.</return></pre><pre><b>asPolygonsColorCoded</b><comment>   "Return polygons for my parts."</comment><return>   ^assemblyPolygons.</return></pre><pre><b>asThreeJS</b><comment>   "render the parts contained in this assembly"</comment><todo>   "TODO: Add method to generate Three.js boiler plate."</todo><comment>   "Initialize geometry for this assembly."</comment><comment>            "Create the part"</comment><comment>            "Merge it into the assembly."</comment><comment>            "The template drives this, producing one line of code."</comment><return>   ^js.</return><r>***25 lines of code ***</r></pre><pre><b>asVPython</b><comment>   "Render my parts via Visual Python Things"</comment><comment>   "Note: Put the assembly in a scene.</comment><return>   ^pythonCode.</return></pre><pre><b>asX3D</b><comment>   "Return a string representing this assembly as a X3D element and scene.</comment><comment>   "</comment><return>   ^x3d.</return></pre><pre><b>bbBottomEdge</b><comment>   "Find my bounding box edge."</comment><return>   ^bottomEdge := myEdge.</return></pre><pre><b>bbDepth</b><comment>   "Depth is another name for length."</comment><return>   ^self bbLength.</return></pre><pre><b>bbEastEdge</b><comment>   "Find my bounding box edge."</comment><return>   ^eastEdge := myEdge.</return></pre><pre><b>bbHeight</b><comment>   "height of my bounding box"</comment><return>   ^height.</return></pre><pre><b>bbLength</b><comment>   "length of my bounding box"</comment><return>   ^height.</return></pre><pre><b>bbNorthEdge</b><comment>   "Find my bounding box edge."</comment><return>   ^northEdge := myEdge.</return></pre><pre><b>bbSouthEdge</b><comment>   "Find my bounding box edge."</comment><return>   ^southEdge := myEdge.</return></pre><pre><b>bbTopEdge</b><comment>   "Find my bounding box edge."</comment><return>   ^topEdge := myEdge.</return></pre><pre><b>bbWestEdge</b><comment>   "Find my bounding box edge."</comment><return>   ^westEdge := myEdge.</return></pre><pre><b>bbWidth</b><comment>   "width of my bounding box"</comment><return>   ^height.</return></pre><pre><b>center: aHumBox above: aHumBox2 </b><comment>   "synonym"</comment></pre><pre><b>center: aBox at: a3Vector </b><comment>   "Center the part (aBox) at the given coordinates. { east. north. up. }</comment><comment>   "Make sure I have that box in my parts list."</comment></pre><pre><b>center: boxB below: boxA </b><comment>  "Center boxB over boxA"</comment></pre><pre><b>center: boxB eastOf: boxA </b><comment>  "Center boxB over boxA"</comment></pre><pre><b>center: boxB northOf: boxA </b><comment>  "Center boxB over boxA"</comment></pre><pre><b>center: boxB onTopOf: boxA </b><comment>  "Center boxB over boxA"</comment></pre><pre><b>center: aHumBox over: aHumBox2 </b><comment>   "synonym"</comment></pre><pre><b>center: boxB southOf: boxA </b><comment>  "Center boxB over boxA"</comment></pre><pre><b>center: boxB westOf: boxA </b><comment>  "Center boxB over boxA"</comment></pre><pre><b>changed</b><comment>   "Transcript cr; show: 'Assembly ',self id,' changed.'."</comment></pre><pre><b>exploded</b><comment>   "Explode assemblies so that all the parts of parts become visible."</comment><return>   ^allParts.</return></pre><pre><b>parts</b><return>   ^ parts ifNil: [ parts := Set new ].</return></pre><pre><b>position: boxA above: boxB</b><comment>   "synonym"</comment></pre><pre><b>position: boxA below: boxB</b><comment>   "synonym"</comment></pre><pre><b>position: boxA eastOf: boxB</b><comment>   "Position A on East edge of B."</comment><comment>   "Assure both are in my collection."</comment><comment>   "By convention, A`s West edge will now equal B`s East edge. (zero clearance)"</comment><comment>   "Note that up-down  and north-south edges are not affected.</comment><comment>   "</comment></pre><pre><b>position: boxA northOf: boxB</b><comment>   "Position A on North edge of B."</comment><comment>   "Assure both are in my collection."</comment><comment>  "By convention, A`s South edget will now equal B`s North."</comment></pre><pre><b>position: boxA onBottomOf: boxB</b><comment>   "Position A on bottom of B."</comment><comment>  "Assure both are in my collection."</comment><comment>   "By convention, A`s top will now equal B`s bottom."</comment></pre><pre><b>position: boxA onTopOf: boxB</b><comment>   "Position A on top of B."</comment><comment>  "Assure both are in my collection."</comment><comment>   "By convention, A`s bottom will now equal B`s top."</comment></pre><pre><b>position: boxA over: boxB</b><comment>   "synonym"</comment></pre><pre><b>position: boxA southOf: boxB</b><comment>   "Position A on South edge of B."</comment><comment>  "Assure both are in my collection."</comment><comment>   "By convention, A`s North edge will now equal B`s South. (zero clearance)"</comment></pre><pre><b>position: boxA under: boxB</b><comment>   "synonym"</comment></pre><pre><b>position: boxA westOf: boxB</b><comment>   "Position A on West edge of B."</comment><comment>  "Assure both are in my collection."</comment><comment>   "By convention, A`s bottom will now equal B`s top."</comment></pre><pre><b>update:  anObject </b><comment>   "TBD"</comment><comment>   "Transcript cr; show: 'Assembly: ', self id, ' sees update of: ', anObject asString."</comment></pre><pre><b>update: anAspect with: anObject </b><comment>   "TBD"</comment></pre><pre><b>x3DOM</b><todo>   "TODO: Generate HTML to enable X3DOM viewing in Browser."</todo><return>   ^html.</return><r>***130 lines of code ***</r></pre><pre><b>x3dBackground</b><comment>   "Provide (default) X3D background element (skybox)"</comment><return>   ^x3d.</return></pre><pre><b>x3dBoilerPlate</b><comment>   "Provide boilerplate attributes for X3D element"</comment><comment>   "profile='Interchange' version='3.2' </comment><return>   ^attributes.</return></pre><pre><b>x3dObjects</b><comment>   "Render each of the objects in my collection"</comment><return>   ^x3d.</return></pre><pre><b>x3dScene</b><comment>   "Return a string representing this assembly as a X3D scene.</comment><comment>   "</comment><return>   ^x3d.</return></pre><pre><b>zcenter: aBox at: anArray </b><comment>   "Center the part (aBox) at the given coordinates. { east. north. up. }</comment><comment>   "Assure that aBox is in my collection. "</comment><comment>   "Compute edge positions to center aBox at those coordinates relative to my origin."</comment></pre><pre><b>zcenter: boxB onTopOf: boxA </b><comment>  "Center boxB over boxA"</comment><comment>  "Adjust the x,y coordinates to match the bottom box`s center"</comment><comment>   "Keep the new Z."</comment></pre><hr/><h3>Hum-UI -- HumBox</h3><pre><b>aboutEdges</b><return>   ^'WARNING: The set/get methods for edges assume a default orientation.'.</return></pre><pre><b>addPolygon: aHumPolygon </b></pre><pre><b>asCamelCase</b><return>   ^ (self id asCamelCase uncapitalized ).</return></pre><pre><b>asMeasure: aQuantity</b><return>   ^measure</return></pre><pre><b>asThreeJS</b><comment>   "Render this as a box in Three.js"</comment><comment>   "Note: Caller must merge this into a scene or group geometry"</comment><return>   ^js. </return><r>***22 lines of code ***</r></pre><pre><b>asX3D</b><comment>   "Return a string in X3D notation representing this box / thing.</comment><comment>   "</comment><todo>  "TODO: Subtypes may add appearance and/or material elements"                     </todo><return>   ^x3d.</return></pre><pre><b>bottomEdge</b><return>   ^ bottomEdge</return></pre><pre><b>bottomEdge: aQuantity</b><comment>   "WARNING: Assumes the box has default orientation."</comment><comment>   "Reset the bottom edge"</comment><comment>   "Force the top "</comment></pre><pre><b>center</b><comment>   "Center of box (and/or center of bounding box) -- { x y z } = { east north up }"</comment><comment>   "Compute my center coordinates - { east. north. up }"</comment><return>   ^position.</return></pre><pre><b>centerAt: a3Vector </b><comment>   "Center myself at the given coordinates. { east. north. up. }</comment><comment>   "Compute new edge positions to center aBox at those coordinates relative to my origin."</comment></pre><pre><b>centerX</b><comment>   "X axis points East"</comment><return>    ^(self westEdge + ( (self width ) * 0.5 )).</return></pre><pre><b>centerY</b><comment>   "Y dimension points North"</comment><return>    ^( self southEdge + ( (self length ) * 0.5 ) ).</return></pre><pre><b>centerZ</b><comment>   "Z dimension points up."</comment><return>    ^( self bottomEdge + ( (self height ) * 0.5 )  ).</return></pre><pre><b>changed</b><comment>   "Notify my dependents."</comment><comment>   "x,y,z are HumMeasure"</comment><comment>   "Transcript cr; </comment></pre><pre><b>depth</b><comment>  "synonym"</comment><return>   ^ length.</return></pre><pre><b>depth: aHumMeasure </b><comment>   "synonym"</comment></pre><pre><b>eastEdge</b><return>   ^ eastEdge</return></pre><pre><b>eastEdge: aQuantity</b><comment>   "Reset the East edge."</comment><comment>   "Force the West edge."</comment></pre><pre><b>equationOfMotion</b><comment>   "The equation-of-motion should be a block with args: box and time"</comment><return>   ^equationOfMotion.</return></pre><pre><b>equationOfMotion: fcSelfAndTime</b><comment>   "The equation-of-motion should be a block with args: box and time"</comment></pre><pre><b>exploded</b><return>   ^{ self }.</return></pre><pre><b>height</b><comment>   "Get the height. By convention, height runs up and down."</comment><return>   ^ height</return></pre><pre><b>height: aQuantity</b><comment>   "Reset the up-down dimension."</comment><comment>   "Hold botton steady and force the top."</comment></pre><pre><b>id</b><comment>   "Identifier used in rendering context"</comment><return>   ^ id ifNil: [ id := self identityHash printString ].</return></pre><pre><b>id: aString</b><comment>   "Identifier used in rendering contexts"</comment></pre><pre><b>id: aString height: aHeight width: aWidth depth: aDepth </b><comment>   "synonym"</comment><return>   ^ self id: aString height: aHeight width: aWidth length: aDepth.</return></pre><pre><b>id: aString height: aHeight width: aWidth length: aLength </b></pre><pre><b>initialize</b><comment>   "Set dimensions to zero."</comment><comment>   "By convention length is North-South, width is East-West, and height is top-bottom."</comment><comment>   "X: East is +. West is -."</comment><comment>   "Y: North is +. South is -."</comment><comment>   "Z: Up is +. Down is -."</comment><comment>   "Default system of metrics is MKS (Meters, Kilograms, Seconds)"</comment><comment>   "Velocity vector = (northward, eastward, upward)"</comment><comment>   "Position edges at zero."</comment><r>***21 lines of code ***</r></pre><pre><b>jump: aTime</b><comment>   "Evaluate my equationOfMotion"</comment><todo>   "TODO: Can we make this compatible with HumSimulator?"</todo></pre><pre><b>length</b><comment>   "Get the length. By convention, length runs North and South."</comment><return>   ^ length</return></pre><pre><b>length: aQuantity</b><comment>   "set North-South dimension"</comment><comment>   "Reset the length. By convention, length runs North and South."</comment><comment>   "Hold South steady and force the North."</comment></pre><pre><b>mm: aMeasure</b><comment>   "Format this measure to 3 digits accuracy - i.e. millimeter accuracy"</comment><return>            ^ measure quantity printShowingDecimalPlaces: 3. ].</return></pre><pre><b>mmShave: aMeasure</b><comment>   "Format this measure to 3 digits accuracy - i.e. millimeter accuracy.</comment><return>   ^ (aMeasure - (2 millimeter)) quantity printShowingDecimalPlaces: 3.</return></pre><pre><b>nextColor</b><comment>    "Select from a sequence of colors. Enables reproducable result."</comment><return>   ^nextColor.</return></pre><pre><b>northEdge</b><return>   ^ northEdge</return></pre><pre><b>northEdge: aQuantity</b><comment>   "Reset North edge."</comment><comment>   "Hold North steady and force South."</comment></pre><pre><b>origin</b><comment>   "Origin is always a zero-sized object at (0 0 0)."</comment><return>   ^ origin ifNil: [ origin := HumBox new.  ].</return></pre><pre><b>polygons</b><return>   ^ polygons ifNil: [ polygons := OrderedCollection new ].</return></pre><pre><b>polygons: aCollection </b><comment>   "Computed polygons *may* be stored here."</comment></pre><pre><b>printOn: aStream</b><comment>   "Append to the argument, aStream, a sequence of characters that  </comment></pre><pre><b>rSquared</b><comment>   "How far am I from the origin? Use R-squared of my centroid as metric."</comment><return>   ^rSquared.</return></pre><pre><b>resetColoring</b></pre><pre><b>rotateLeft: angleInDegrees</b><comment>   "Set rotation (yaw) in scene coordinates - Note: This is not additive."</comment></pre><pre><b>rotatePolygons: inputPolygons </b><comment>   "Correct the polygons for my rotation (yaw)."</comment><return>   ^resultPolygons.</return><r>***25 lines of code ***</r></pre><pre><b>rotateRight: angleInDegrees</b><comment>   "Set rotation (yaw) in scene coordinates - Note: This is not additive."</comment></pre><pre><b>rotation</b><comment>   "Get my rotation in scene coordinates as a value expressed in radians "</comment><return>   ^rotation ifNil: [ rotation := 0.0 ].</return></pre><pre><b>rotation: angle</b><comment>   "Set my rotation in scene coordinates as a value expressed in radians "</comment></pre><pre><b>rotationDegrees: angle</b><comment>   "Set my rotation angle in scene coordinates. "</comment></pre><pre><b>slideBackward: aHumMeasure </b><comment>   "Slide in the South direction - TODO: adjust for camera rotation."</comment></pre><pre><b>slideDown: aHumMeasure </b><comment>   "Move box (e.g. camera) up or down in the scene coordinates."</comment><todo>   "TODO: Refactor to make this work in camera coordinates - corrected for rotation and tilt."</todo></pre><pre><b>slideForward: aHumMeasure </b><comment>   "Slide in the North direction - TODO: adjust for camera rotation."</comment></pre><pre><b>slideLeft: aHumMeasure </b><return>   ^self slideRight: (aHumMeasure negated).</return></pre><pre><b>slideRight: aHumMeasure </b><comment>   "Move camera left or right --- TODO: Correct this for camera orientation."</comment></pre><pre><b>slideUp: aHumMeasure </b><return>   ^self slideDown: (aHumMeasure negated).</return></pre><pre><b>solidColor: aColor</b><comment>   "What color should be used to render box or bounding-box in a view?"</comment></pre><pre><b>southEdge</b><return>   ^ southEdge</return></pre><pre><b>southEdge: aQuantity</b><comment>   "Reset the South edge."</comment><comment>   "Force North edge."</comment></pre><pre><b>tilt</b><comment>   "Get my tilt in scene coordinates as a value expressed in radians.</comment><return>   ^tiltUpDown ifNil: [ tiltUpDown := 0.0. ].</return></pre><pre><b>tilt: tiltInRadians</b><comment>   "Set my tilt in scene coordinates as a value expressed in radians.</comment></pre><pre><b>tiltDegrees: angleInDegrees</b><comment>   "Set my tilt (pitch) angle in scene coordinates. "</comment><comment>   "Otherwise:"</comment></pre><pre><b>tiltDown: angleInDegrees</b><comment>   "Set tilt  (pitch)  in scene coordinates - Note: This is not additive."</comment></pre><pre><b>tiltPolygons: inputPolygons </b><comment>   "Correct the polygons for my tilt (pitch)."</comment><return>   ^resultPolygons.</return><r>***26 lines of code ***</r></pre><pre><b>tiltUp: angleInDegrees</b><comment>   "Set tilt (pitch) in scene coordinates - Note: This is not additive."</comment></pre><pre><b>topEdge</b><return>   ^ topEdge</return></pre><pre><b>topEdge: aQuantity</b><comment>   "Reset the top edge."</comment><comment>   "Force the bottom edge."</comment></pre><pre><b>velocity: aHumVector</b><comment>   "What is the 3D object`s current velocity?"</comment></pre><pre><b>volume</b><comment>   "Calculate the volume"</comment><todo>   "TODO: This should be a HumMeasure with dimension of L^3"</todo><return>   ^v.</return></pre><pre><b>westEdge</b><return>   ^ westEdge</return></pre><pre><b>westEdge: aQuantity</b><comment>   "Reset the West edge."</comment><comment>   "Force the East edge."</comment></pre><pre><b>width</b><comment>   "Get the width. By convention, the width runs East and West."</comment><return>   ^ width</return></pre><pre><b>width: aQuantity</b><comment>   "Reset the East-West dimension"</comment><comment>   "Hold West edge steady and force the East edge."</comment></pre><pre><b>x3dCenter</b><comment>   "Center of box (and/or center of bounding box) -- { x y z }</comment><comment>   "</comment><comment>   "X"</comment><comment>   "Y"</comment><return>   ^s</return></pre><pre><b>x3dExtent</b><comment>   "Return x y z extents as a string</comment><comment>   "</comment><comment>   "X"</comment><comment>   "Y"</comment><comment>   "Z"</comment><return>   ^s.</return></pre><pre><b>xyzString</b><return>   ^s.</return></pre><pre><b>zslideRight: aHumMeasure </b><comment>   "Move camera left or right --- TODO: Correct this for camera orientation."</comment></pre><hr/><h3>Hum-UI -- HumCamera</h3><pre><b>eyeX</b><comment>   "Eye in scene coordinates.  </comment><return>   ^(self westEdge + ((self width) * 0.5) ).</return></pre><pre><b>eyeY</b><comment>   "Eye in scene coordinates."</comment><return>   ^(self northEdge) - (self depth).</return></pre><pre><b>eyeZ</b><comment>   "Eye in scene coordinates."</comment><return>   ^((self topEdge) - ((self height) * 0.5) )</return></pre><pre><b>isPointInFieldOfView: a3Dpoint </b><comment>   "Is the given 3D point within my field of view.  </comment><comment>   "Is the point behind the camera`s aperture?"</comment><comment>   "Is point in horizontal field of view?"</comment><comment>   "Is point in verticle field of view?"</comment><comment>   "Passed the filters. Looks okay."</comment><return>   ^true.</return><r>***24 lines of code ***</r></pre><pre><b>slideBackward: aDistance</b></pre><pre><b>slideForward: aDistance</b><comment>   "Move in the direction the camera is pointing."</comment></pre><pre><b>slideLeft: aDistance</b><return>   ^self slideRight: (aDistance negated).</return></pre><pre><b>slideRight: aDistance</b><comment>   "Move in the direction the camera is pointing."</comment></pre><pre><b>slideUpward: aDistance</b><comment>   "Move in the direction the camera is pointing."</comment></pre><pre><b>unitForward</b><comment>   "Return unit vector pointing along my internal y axis due to my rotation and tilt."</comment><return>   ^unitVector.</return></pre><pre><b>unitSideways</b><comment>   "Return unit vector pointing along my internal x axis due to my rotation and tilt."</comment><return>   ^unitVector.</return></pre><pre><b>unitUpDown</b><comment>   "Return unit vector pointing along my internal x axis due to my rotation and tilt."</comment><return>   ^unitVector.</return></pre><hr/><h3>Hum-UI -- HumCanvas</h3><pre><b>about</b><comment>"</comment></pre><pre><b>asMorph</b><comment>   "morph := self formCanvas form asMorph."</comment><return>   ^morph.</return></pre><pre><b>borderWidth: aWidth borderColor: aColor </b></pre><pre><b>brushColor</b><comment>   "Get my brush color."</comment><return>   ^brushColor ifNil: [brushColor := Color black].</return></pre><pre><b>brushColor: aColor </b><comment>   "Set my brush color."</comment></pre><pre><b>brushPosition</b><comment>   "Get my latest brush position."</comment><return>   ^brushPosition ifNil: [ Error signal: 'brush position has not been set' ]</return></pre><pre><b>brushPosition: aPoint </b><comment>   "Remember my latest brush position."</comment></pre><pre><b>drawHumPolygon: aHumPolygon </b><comment>   "The HumPolygon contains 3D points  and specifies fill and border colors. </comment><comment>   "aFillColor := aHumPolygon fillColor."</comment><comment>   "Transform to 2D points"</comment></pre><pre><b>drawPolygon: aHumPolygon scale: pxPerMeter </b></pre><pre><b>drawTextLines: textLines withFont: aFont</b></pre><pre><b>fillBackground</b><comment>   "self formCanvas </comment></pre><pre><b>formCanvas </b><comment>   "What form should I draw on."</comment><return>   ^formCanvas ifNil: [  formCanvas := FormCanvas on: (Form extent: DisplayScreen boundingBox extent depth: 32) ].</return></pre><pre><b>formCanvas: aFormCanvas </b><comment>   "What form should I draw on."</comment></pre><pre><b>moveBrushTo: aCanvasPoint</b><comment>   "Position the brush, but do not paint yet."</comment></pre><pre><b>paintTo: aCanvasPoint </b><comment>   "The point should be inside the canvas bounds. Rectangle"</comment><todo>   "TODO: Put pixels from brush onto my Form."</todo></pre><pre><b>projectScenePoint: aScenePoint cameraDepth: aCameraDepth</b><comment>   "Translate from scene coordinates (meters) to canvas coordinates (px)"</comment><comment>   "Map East-West to x; North-South to y; Up-Down to z, Time to w."</comment><return>   ^aCanvasPoint.</return><r>***23 lines of code ***</r></pre><pre><b>scalePixelsPerMillimeter</b><comment>   "How many pixels per millimeter of camera viewbox?"</comment><return>   ^ pixelsPerMillimeter ifNil: [ 4 ].</return></pre><pre><b>scalePixelsPerMillimeter: aNumber</b><comment>   "How many pixels per millimeter of viewbox?"</comment></pre><pre><b>scalePoint: aScenePoint scaleRatio: pxPerMeter </b><comment>   "Return a x@y point by scaling the given scene point"</comment><return>   ^ canvasX @ canvasY.</return><r>***22 lines of code ***</r></pre><pre><b>skyColor</b><comment>   "What color to use for background fill?"</comment><return>   ^ skyColor ifNil: [ skyColor := Color cyan lighter lighter  ]</return></pre><pre><b>skyColor: aColor</b><comment>   "What color to use for background fill?"</comment></pre><hr/><h3>Hum-UI -- HumCategoryWidget</h3><pre><b>categories</b><return>   ^categories ifNil: [Error signal: 'categories have not been initialized']</return></pre><pre><b>categories: anArrayOfCategoryNames </b></pre><pre><b>renderContentOn: aWAHtmlCanvas</b><comment>   "render self via a simple input tag"</comment></pre><hr/><h3>Hum-UI -- HumColumnLayoutWidget</h3><pre><b>asHTML</b><comment>   "Generate a div containing child widget renderings."</comment><return>   ^html.</return><r>***23 lines of code ***</r></pre><pre><b>asMorph</b><return>   ^layoutMorph.</return><r>***23 lines of code ***</r></pre><hr/><h3>Hum-UI -- HumDateWidget</h3><pre><b>renderContentOn: aWAHtmlCanvas</b><comment>   "render self via a simple input tag"</comment></pre><hr/><h3>Hum-UI -- HumDiagram</h3><pre><b>addConnection: anAssociation </b><comment>   "anAssociation := ( fromNode -&gt; toNode )"</comment></pre><pre><b>addConnection: anAssociation label: aString</b><comment>   "anAssociation := ( fromNode -&gt; toNode )"</comment><todo>   "TODO: REFACTOR HumDiagram to use HumGraph as a model."</todo></pre><pre><b>addNode: anObject</b><comment>   "A node object should have a title. </comment></pre><pre><b>asSVGonHtml: html width: aWidth height: aHeight </b><todo>   "TODO: REFACTOR to render as HTML string."</todo><comment>         "Eventually, we want to draw the diagram using SVG."</comment><comment>            "FOLLOWING IS A STUB -- EVENTUALLY THIS WILL DRAW NODES AND CONNECTIONS"</comment><todo>            "ToDo: Finish this after we have layout working."</todo><r>***32 lines of code ***</r></pre><pre><b>asSVGonHtmlCanvas: html width: aWidth height: aHeight </b><comment>   "Render this diagram on the given Seaside canvas.</comment><comment>   "</comment><comment>         "Eventually, we want to draw the diagram using SVG."</comment><comment>            "FOLLOWING IS A STUB -- EVENTUALLY THIS WILL DRAW NODES AND CONNECTIONS"</comment><todo>            "ToDo: Finish this after we have layout working."</todo><r>***34 lines of code ***</r></pre><pre><b>asSVGonSeasideCanvas: html width: aWidth height: aHeight </b><comment>   "Render this diagram on the given Seaside canvas.</comment><comment>   "</comment><comment>         "Eventually, we want to draw the diagram using SVG."</comment><comment>            "FOLLOWING IS A STUB -- EVENTUALLY THIS WILL DRAW NODES AND CONNECTIONS"</comment><todo>            "ToDo: Finish this after we have layout working."</todo><r>***34 lines of code ***</r></pre><pre><b>connections</b><comment>   "Model connections as a set of associations."</comment><return>   ^ self graph connections.</return></pre><pre><b>countNeighborsOfNode: aNode</b><comment>   "Return the number of neighbors of this node.</comment><return>   ^ count</return></pre><pre><b>getNodesDownstreamFromNode: thisNode </b><comment>   "Return nodes that are connected downstream from this node."</comment><return>   ^ result.</return></pre><pre><b>getNodesUpstreamFromNode: thisNode </b><comment>   "Return nodes that are connected upstream from this node."</comment><return>   ^ result.</return></pre><pre><b>getPositionForNode: aNodeObject</b><return>   ^ self mapNodePosition at: aNodeObject ifAbsent: [ ^nil ].</return></pre><pre><b>graph</b><return>   ^graph ifNil: [ graph := HumGraph new. ].</return></pre><pre><b>initialize</b><comment>   "Set up the graph instance that backs this diagram."</comment></pre><pre><b>layoutDiagramWithNodeExtent: extentPoint nodeSpacing: spacingPoint</b><comment>   "Layout the diagram using the given node extent and spacing between node edges."</comment><comment>   "Following must be set before calling me."</comment><comment>   "Following is assumed in code below."</comment><comment>   "Reset these instance (global) variables!"</comment><comment>   "Compute increments between grid locations."</comment><comment>   "In this version, the placement is on a rectalinear grid.</comment><comment>   "</comment><comment>   "Strategy: Prioritize the objects that have the most connections."</comment><comment>   "Count the number of connections that each node has."</comment><comment>   "Sort into a collection where nodes with most connections appear first."   </comment><comment>   "Place the nodes with the most connections on the first pass.</comment><comment>   "   </comment><r>***54 lines of code ***</r></pre><pre><b>layoutDistanceFromNode: nodeA toNode: nodeB</b><comment>   "Calculate the length of the connection between the nodes."</comment><return>   ^r</return></pre><pre><b>layoutEnergyOnNode: nodeA fromNode: nodeB</b><comment>   "Calculate a energy scalar. </comment><comment>   "</comment><comment>   "Radius is the length of the connection between the nodes."</comment><comment>   "Attractive force increases when the radius increases.</comment><comment>   "</comment><comment>   "Repulsion increases when charge Q (number of direct connections) increases.</comment><comment>   "</comment><todo>   "TODO: Consider using minimum of qA or qB.</todo><comment>   "</comment><return>   ^ ( attraction - repulsion ). </return><comment>   "Notes: </comment><comment>   "</comment><todo>   "TODO: Refactor so that attraction and repulsion factors are instance variables and externally adjustable."</todo><todo>   "TODO: Set up a UI where user can tinker with the factors. (And we can verify the intended layout effects.)"</todo><r>***41 lines of code ***</r></pre><pre><b>layoutNode: aNode from: aPosition by: anIncrement</b><comment>   "Find a place for the given node starting from the given position.</comment><comment>   "            </comment><comment>   "If the node has already been positioned, leave it where it is."</comment><comment>   "At this point, proposedPosition should be the related node`s position"</comment><comment>   "Return the position where we placed the node."   </comment><return>   ^ nodePosition.</return><r>***26 lines of code ***</r></pre><pre><b>layoutRecursiveWithNode: node relativePosition: relativePosition seenBefore: priorNodes</b><comment>   "Assign initial position to this node, and then, using recursion, to its neighbors.</comment><comment>   "</comment><comment>   "Return immediately if this node has been seen before.</comment><comment>   "Following must be set before calling me."</comment><comment>   "Following is assumed in code below."</comment><comment>   "Compute increments between grid locations."</comment><comment>   "In this version, the placement is on a rectalinear grid.</comment><comment>   "</comment><comment>   "Next: Find positions for nodes that are downstream from this node."</comment><todo>               "ToDo: Calculate which node positions are intersected by connecting lines.</todo><comment>               "</comment><comment>   "Next: Find positions for nodes that are upstream from this node."</comment><todo>               "ToDo: Calculate which node positions are intersected by connecting lines."</todo><r>***54 lines of code ***</r></pre><pre><b>mapNodePosition</b><return>   ^ mapNodePosition ifNil: [ mapNodePosition := Dictionary new. ].</return></pre><pre><b>mapPositionNode</b><comment>   " What node is at a position"</comment><return>   ^ mapPositionNode ifNil: [ mapPositionNode := Dictionary new. ].</return></pre><pre><b>nodeExtent: aPoint </b></pre><pre><b>nodeSpacing: aPoint </b></pre><pre><b>nodes</b><comment>   "Model nodes as a set of objects."</comment><return>   ^ self graph nodes.</return></pre><pre><b>setNode: aNodeObject position: aPosition</b><comment>   "Node should also be in nodes collection for internal consistency."</comment></pre><pre><b>title</b><return>   ^ title ifNil: [ title := '** Diagram has no title! **'].</return></pre><pre><b>title: aString</b></pre><hr/><h3>Hum-UI -- HumEditor</h3><pre><b>addLine: aString </b><comment>   "Delegate to HumText instance."</comment></pre><pre><b>beep</b><comment>   "If sound is enabled, beep."         </comment></pre><pre><b>characterIndex</b><comment>   "Character index is equal to the number of charactes to the left of the cursor."</comment><return>   ^ characterIndex ifNil: [ characterIndex := 0 ].</return></pre><pre><b>characterIndex: aSmallInteger </b><comment>   "character index ranges from 0 (left of line) to ()"</comment></pre><pre><b>currentLine</b><return>   ^result.</return></pre><pre><b>deletePriorCharacter</b><comment>   "Insert a character into the text at the current (cursor) position"</comment><comment>   "If cursor is at the front of the line, delete is a no op."</comment><comment>   "Otherwise . . ."</comment><comment>   "(self lines) at: (self lineIndex) put: humTextLine."</comment><comment>   "Back the cursor."</comment><r>***26 lines of code ***</r></pre><pre><b>emptySelection</b><comment>   "The selection is empty.</comment></pre><pre><b>initialize</b><comment>   "Set up undo stack and notification."</comment></pre><pre><b>insertCharacter: aCharacter </b><comment>   "Insert a character into the text at the current (cursor) position"</comment><comment>   "notify model"</comment><comment>   "(self lines) at: (self lineIndex) put: humTextLine."</comment><comment>   "Advance the cursor."</comment><r>***22 lines of code ***</r></pre><pre><b>insertLine</b><comment>   "Delegate to our HumText instance"</comment><comment>   "Adjust the cursor to point to the beginning of the new line."</comment></pre><pre><b>interpretKey: aSymbol </b><comment>   "Interpret various keyboard gestures."</comment><comment>         "Simple arrow keys"</comment><comment>         "Alt-Arrow keys"</comment><comment>         "Shift-Arrow keys move cursor same as simple arrow keys, but selection is updated."</comment><comment>         "Escape key is a no-op at this time."</comment><comment>   "Interpret the symbol (keyboard action name) given"</comment><r>***33 lines of code ***</r></pre><pre><b>lineIndex</b><return>   ^ lineIndex ifNil: [ lineIndex := 1 ].</return></pre><pre><b>lineIndex: aSmallInteger </b></pre><pre><b>lines</b><return>   ^ self text lines.</return></pre><pre><b>redo</b><comment>   "Replace text with text that was replaced at last undo."</comment></pre><pre><b>redoStack</b><return>   ^ redoStack ifNil: [ redoStack := OrderedCollection new ].</return></pre><pre><b>selectedText</b><comment>   "Return selected text as a string with CR inserted as needed at ends of lines."</comment><return>   ^result.</return><r>***29 lines of code ***</r></pre><pre><b>selectionAnchor</b><comment>   "Return selection anchor."</comment><return>   ^ selectionAnchor ifNil: [selectionAnchor := lineIndex @ characterIndex ].</return></pre><pre><b>text</b><return>   ^ text ifNil: [ text := HumText new ].</return></pre><pre><b>undo</b><comment>   "Replace text with last item from undo stack."</comment><comment>   "last contains current text"</comment><comment>   "Now top contains priorText"</comment><todo>   "TODO: Keep track of where the cursor was."</todo></pre><pre><b>undoStack</b><comment>                  "Initialize stack"</comment><return>   ^undoStack.</return></pre><pre><b>update: aText</b><comment>   "When text is updated, we are informed. Put on undo stack."</comment><todo>   "TODO: Also track the cursor. </todo><comment>   "</comment></pre><pre><b>updateSelection</b><comment>   "Selection extends from an anchor-point to current cursor position.</comment><comment>   "</comment><r>***22 lines of code ***</r></pre><hr/><h3>Hum-UI -- HumElipsoid</h3><pre><b>asPolygons</b><return>   ^ self asPolygonsColoredBy: [ self solidColor ].</return></pre><pre><b>asPolygonsColorCoded</b><return>   ^ self asPolygonsColoredBy: [ self nextColor ].</return></pre><pre><b>asPolygonsColoredBy: aBlockRule</b><comment>   "Produce polygons from the xyList points and the rotation nWedges."</comment><comment>   "Wikipedia:</comment><comment>   "</comment><return>   ^polygons.</return><r>***44 lines of code ***</r></pre><pre><b>asVPython</b></pre><hr/><h3>Hum-UI -- HumExtrusion</h3><pre><b>asPolygonsColoredBy: aColorRule</b><comment>   "To create a set of layers, </comment><comment>   "Create  polygons (triangles) by connecting the layers."</comment></pre><pre><b>asVPython</b></pre><pre><b>path: a3DPath</b><comment>   "Define the 3D path used to extrude the polygon."</comment></pre><pre><b>polygon: aHumPolygon</b><comment>   "Define the polygon that will be extruded along a path."</comment></pre><hr/><h3>Hum-UI -- HumFormWidget</h3><pre><b>renderContentOn: aWAHtmlCanvas</b></pre><pre><b>renderOn: aWAHtmlCanvas</b></pre><pre><b>view</b><comment>  "Return my view"</comment><return>   ^ view ifNil: [Error signal: (self class,' not properly initialized')]</return></pre><pre><b>view: aHumView </b></pre><hr/><h3>Hum-UI -- HumLayoutWidget</h3><pre><b>addWidget: aHumWidget </b></pre><pre><b>reorder: aSortBlock</b><comment>   "Re-order the widgets according to the given sort criteria."</comment></pre><pre><b>widgets</b><return>   ^ widgets ifNil: [ widgets := OrderedCollection new. ]</return></pre><hr/><h3>Hum-UI -- HumMeasureWidget</h3><pre><b>renderContentOn: aWAHtmlCanvas</b><comment>   "render self via a simple input tag"</comment></pre><hr/><h3>Hum-UI -- HumPane</h3><pre><b>drawTextLines: textLines onCanvas: aCanvas font: aFont </b></pre><pre><b>textChanged: aHumTextEditor </b><comment>   "Text to be displayed in this pane has changed."</comment><comment>   "Draw the text lines on my canvas."</comment></pre><hr/><h3>Hum-UI -- HumPolygon</h3><pre><b>&lt;= aHumPolygon </b><comment>   "Z-ordering: Is my north-most point more northerly than the other."</comment><return>   ^result.</return></pre><pre><b>&gt; aHumPolygon </b><comment>   "Is my north-most point more northerly than the other."</comment><return>   ^result.</return></pre><pre><b>addVertex: aScenePoint </b><comment>   "The convention is to list vertices in a counter-clockwise direction as seen from the 'outside' of a solid."</comment><comment>   "Comment: Wishing to be programmer-friendly or more generic, we allow more than one kind of point.</comment></pre><pre><b>asTriangles</b><comment>         "Make a polygon with same colors"</comment><return>   ^triangles.</return><r>***27 lines of code ***</r></pre><pre><b>borderColor</b><return>   ^ borderColor ifNil: [ borderColor := Color blue ].</return></pre><pre><b>borderColor: aColor </b></pre><pre><b>bottom</b><comment>   "If points are 2D, Return min y or zero."</comment><return>   ^minY negated.</return></pre><pre><b>centroid</b><comment>   "Compute the centroid of the vertices."</comment><return>   ^centroid.</return></pre><pre><b>color: aColor </b><comment>   "Specify border-color or fll-color instead."</comment></pre><pre><b>drawOn: aHumCanvas </b></pre><pre><b>fillColor</b><return>   ^ fillColor ifNil: [  fillColor := Color gray. ].</return></pre><pre><b>fillColor: aColor </b></pre><pre><b>inFrontOfCamera</b><comment>   "Return true if at least one y-value is positive."</comment><comment>   "This only works properly if vertices have been transformed into camera coordinates."</comment><return>   ^false.</return></pre><pre><b>left</b><comment>   "Trick because we collection has max: method but no min: method."</comment><return>   ^minY negated.</return></pre><pre><b>maxRsquared</b><comment>   "Compute the centroid of the vertices."</comment><return>   ^maxSquared.</return></pre><pre><b>meanRsquared</b><comment>   "Compute the centroid of the vertices."</comment><return>   ^(meanRsquared / n).</return></pre><pre><b>minRsquared</b><comment>   "Compute the centroid of the vertices."</comment><return>   ^minSquared.</return></pre><pre><b>northMostPoint</b><comment>   "Find the value of the point that is furtherest North (z-Ordering)"</comment><comment>   "Hum coordinate axis point {East. North. Up.}"</comment><return>   ^northMost.</return></pre><pre><b>parentSolid</b><comment>   "Remember where I came from."</comment><return>   ^ parentSolid ifNil: [ Error signal: 'parentSolid not defined' ].</return></pre><pre><b>parentSolid: aHumSolid </b><comment>   "Remember where I came from."</comment></pre><pre><b>path</b><return>   ^self vertices.</return></pre><pre><b>pitch: pitchAngle </b><comment>   "Return a new polygon with my points adjusted by pitch about origin."</comment><return>   ^newPolygon</return></pre><pre><b>rSquared</b><return>   ^rSquared.</return></pre><pre><b>right</b><return>   ^maxY</return></pre><pre><b>roll: rollAngle </b><comment>   "Return a new polygon with my points adjusted by roll about origin."</comment><return>   ^newPolygon</return></pre><pre><b>top</b><comment>   "If points are 2D, Return max y."</comment><return>   ^maxY.</return></pre><pre><b>vertices</b><comment>   "The convention is to list vertices in a counter-clockwise direction as seen from the 'outside' of a solid."</comment><return>   ^vertices ifNil: [ vertices := H3dPath new ].</return></pre><pre><b>verticesDo: aBlockClosure </b></pre><pre><b>xyPoints</b><comment>   "Flatten my 3D points to 2D points in X-Y (floor plan) plane"</comment><return>   ^xyVertices.</return></pre><pre><b>xzPoints</b><comment>   "Flatten my 3D points to 2D points in X-Z (viewport/billboard) plane. "</comment><return>   ^xzVertices.</return></pre><pre><b>yaw: yawAngle </b><comment>   "Return a new polygon with my points adjusted by yaw about origin."</comment><comment>   "See HumVector"</comment><return>   ^newPolygon</return></pre><pre><b>yaw: yawAngle aboutPivot: pivot</b><comment>   "Return a new polygon with my points adjusted by yaw about origin."</comment><comment>   "See HumVector"</comment><return>   ^newPolygon</return></pre><hr/><h3>Hum-UI -- HumRotation</h3><pre><b>asPolygonsColoredBy: aColorRule</b><comment>   "Produce polygons from the xyList points and the rotation nWedges."</comment><return>   ^tPolygons.</return><r>***41 lines of code ***</r></pre><pre><b>asVPython</b></pre><pre><b>nWedges: numberOfWedges</b></pre><pre><b>xyList: aCollection </b><comment>   "List of XY (XZ) points that define surface of revolution."</comment></pre><hr/><h3>Hum-UI -- HumRowLayoutWidget</h3><pre><b>asHTML</b><comment>   "Generate a div containing child widget renderings."</comment><return>   ^html.</return><r>***22 lines of code ***</r></pre><pre><b>asMorph</b><return>   ^morph.</return></pre><hr/><h3>Hum-UI -- HumScene</h3><pre><b>asThreeJS</b><comment>   "Render the scene as ThreeJS"</comment><comment>   "Prolog: Create the ThreeJS scene with appropriate attributes."</comment><comment>   "Render the content (layers or objects)"</comment><comment>   "Append the epilog."</comment><return>   ^js.</return></pre><pre><b>asThreeJSGeometry</b><comment>   "Render the assembly as ThreeJS geometry"</comment><comment>   "Render the content (layers or objects)"</comment><return>   ^js.</return></pre><pre><b>asThreeJSinHTML</b><comment>   "Wrap ThreeJS rendering with HTML5."</comment><comment>      "Define a geometry named by (self asCamelCase)."</comment><comment>      "Generate additional function to build geometry and insert it into scene."</comment><comment>      "Complete the HTML."</comment><return>   ^html.</return><r>***167 lines of code ***</r></pre><pre><b>asVPython</b><comment>   "render scene and the objects in it via VPython."</comment><return>   ^ pythonCode.</return></pre><pre><b>asVPythonPreamble</b><return>   ^ pythonCode.</return></pre><pre><b>jump: aTime</b><todo>   "TODO: Is this consistent with HumSimulator?"</todo></pre><pre><b>setupFloor4ThreeJS</b><comment>   "Provide boilerplate that creates a visible floor."</comment><comment>   "NOTE: JavaScript must call setupScene() before setupFloor()."</comment><todo>   "TODO: Parameterize the size of the floor."</todo><return>   ^ js.</return></pre><pre><b>setupScene4ThreeJS</b><comment>   ""</comment><return>   ^js, String cr.</return><r>***29 lines of code ***</r></pre><hr/><h3>Hum-UI -- HumSolid</h3><pre><b>asPolygons</b><comment>   "Translate each face into a list of 3D points."</comment><return>   ^self asPolygonsColoredBy: [ self solidColor ].</return></pre><pre><b>asPolygonsColorCoded</b><comment>   "Color code the facets of the solid."</comment><return>    ^self asPolygonsColoredBy: [ self nextColor ]. </return></pre><pre><b>asPolygonsColoredBy: aColorRule</b><comment>   "Generate polygons from the solid`s dimension. - Subtypes should over-ride."</comment><comment>   "Color by evaluating the given color rule block."</comment><comment>   "Hum coordinates are plan view. X points East. Y points North. Z points up."</comment><comment>   "North surface "</comment><comment>   "East surface"</comment><comment>   "West surface"</comment><comment>   "Bottom surface"</comment><comment>   "Top surface"</comment><comment>   "South surface"</comment><return>   ^tiltedPolygons. </return><r>***68 lines of code ***</r></pre><pre><b>asThreeJS</b><comment>   "Render this solid  as a cube via three.js"</comment><comment>   "Note: Caller must merge this into a scene or group geometry"</comment><todo>   "TODO: Dispatch to other kinds of shapes per the solid`s type."</todo><return>   ^js. </return><r>***28 lines of code ***</r></pre><pre><b>asVPython</b><return>   ^pythonCode</return></pre><pre><b>asVPythonPosition</b><comment>   "Generate VPythgon code giving position."</comment><return>   ^centerString.</return></pre><pre><b>asVPythonThing</b><comment>   "A solid has color and is visible."</comment><return>   ^pythonCode</return></pre><pre><b>asX3D</b><comment>   "Return a string in X3D notation representing this box / thing.</comment><comment>   "</comment><todo>   "TODO: Replace this with a template implementation"</todo><return>   ^x3d.</return><r>***25 lines of code ***</r></pre><pre><b>attachCanvas: aCanvas toFace: aSymbol </b><comment>   "Attach the  canvas to the face. -- Used for billboards. </comment></pre><pre><b>color</b><return>   ^solidColor ifNil: [ solidColor := Color gray. ].</return></pre><pre><b>color: aColor </b><comment>   "What id the default (background) color of the surface and interior of this solid 3D object?"</comment></pre><pre><b>density</b><comment>   "Return set density otherwise lookup the density of my material."</comment><return>   ^ density ifNil: [ (self densityOfMaterial) ].</return></pre><pre><b>density: aMeasure</b><comment>   "What is the average density (mass per cube) of this solid?</comment><comment>   "</comment><comment>   "HumMeasure handles conversions to KMS units.</comment><comment>   "</comment></pre><pre><b>densityOfMaterial</b><comment>   "The table is held on the class side to avoid clutter and instance bloat."</comment><return>   ^result.</return></pre><pre><b>faces</b><comment>   "Hold image/canvas to be attached to a face."</comment><return>   ^faces ifNil: [  faces := Dictionary new. ]</return></pre><pre><b>initialize</b></pre><pre><b>mass</b><return>   ^ mass ifNil: [ mass := (self volume) * (self density)].</return></pre><pre><b>mass: aMeasure</b><comment>   "What is the mass of this object?"</comment><comment>   "HumMeasure handles conversions to KMS units.</comment><comment>   "</comment></pre><pre><b>material</b><return>   ^ material ifNil: [ Error signal: 'Material has not been set for this solid'].</return></pre><pre><b>material: aString </b><comment>   "See also: #densityOfMaterial for names of standard materials. "</comment></pre><pre><b>solidColor</b><return>   ^solidColor ifNil: [ solidColor := Color gray. ]</return></pre><pre><b>type: aSymbol </b><todo>   "TODO: Why was this coded? </todo></pre><pre><b>weight</b><comment>   "Get the Earth-bound weight of the object.  (in Newtons)."</comment><return>   ^ ( self mass ) * ( 1.0 gravity ).</return></pre><pre><b>wireFrameColor</b><return>   ^wireFrameColor ifNil: [ wireFrameColor := Color black ].</return></pre><pre><b>x3dColor</b><comment>   "Translate my Smalltalk Color to x3dColor string"</comment><return>   ^result.</return></pre><pre><b>x3dExampleJSON</b><comment>      "Following is here to hold some useful patterns while I think over the design strategy."</comment><comment>  "html": {</comment><comment>    "-xmlns": "http://www.w3.org/1999/xhtml",</comment><comment>    "head": {</comment><comment>      "meta": [</comment><comment>          "-http-equiv": "X-UA-Compatible",</comment><comment>          "-content": "chrome=1"</comment><comment>          "-http-equiv": "Content-Type",</comment><comment>          "-content": "text/html;charset=utf-8"</comment><comment>      "title": "Primitives: Box, Cone, Cylinder and Sphere Primitives",</comment><comment>      "link": {</comment><comment>        "-rel": "stylesheet",</comment><comment>        "-type": "text/css",</comment><comment>        "-href": "x3dom.css"</comment><comment>    "body": {</comment><comment>      "h1": "Primitives: Box, Cone, Cylinder and Sphere Primitives",</comment><comment>      "p": [</comment><comment>          "-class": "case",</comment><comment>          "X3D": {</comment><comment>            "-xmlns": "http://www.web3d.org/specifications/x3d-namespace",</comment><comment>            "-id": "boxes",</comment><comment>            "-showStat": "true",</comment><comment>            "-showLog": "false",</comment><comment>            "-x": "0px",</comment><comment>            "-y": "0px",</comment><comment>            "-width": "400px",</comment><comment>            "-height": "400px",</comment><comment>            "Scene": {</comment><comment>              "Background": { "-skyColor": "1 1 1" },</comment><comment>              "Transform": [</comment><comment>                  "-DEF": "coneTrafo",</comment><comment>                  "-translation": "-4.5 0 0",</comment><comment>                  "Shape": {</comment><comment>                    "-DEF": "coneShape",</comment><comment>                    "Appearance": {</comment><comment>                      "-DEF": "coneApp",</comment><comment>                      "Material": {</comment><comment>                        "-diffuseColor": "0 1 0",</comment><comment>                        "-specularColor": ".5 .5 .5"</comment><comment>                    "Cone": { "-DEF": "cone" }</comment><comment>                  "-DEF": "boxTrafo",</comment><comment>                  "-translation": "-1.5 0 0",</comment><comment>                  "Shape": {</comment><comment>                    "-DEF": "boxShape",</comment><comment>                    "Appearance": {</comment><comment>                      "-DEF": "boxApp",</comment><comment>                      "Material": {</comment><comment>                        "-diffuseColor": "1 0 0",</comment><comment>                        "-specularColor": ".5 .5 .5"</comment><comment>                    "Box": { "-DEF": "box" }</comment><comment>                  "-DEF": "sphereTrafo",</comment><comment>                  "-translation": "1.5 0 0",</comment><comment>                  "Shape": {</comment><comment>                    "-DEF": "sphereShape",</comment><comment>                    "Appearance": {</comment><comment>                      "-DEF": "sphereApp",</comment><comment>                      "Material": {</comment><comment>                        "-diffuseColor": "0 0 1",</comment><comment>                        "-specularColor": ".5 .5 .5"</comment><comment>                    "Sphere": { "-DEF": "sphere" }</comment><comment>                  "-DEF": "cylinderTrafo",</comment><comment>                  "-translation": "4.5 0 0",</comment><comment>                  "Shape": {</comment><comment>                    "-DEF": "cylinderShape",</comment><comment>                    "Appearance": {</comment><comment>                      "-DEF": "cylinderApp",</comment><comment>                      "Material": {</comment><comment>                        "-diffuseColor": "1 1 0",</comment><comment>                        "-specularColor": ".5 .5 .5"</comment><comment>                    "Cylinder": {</comment><comment>                      "-DEF": "cylinder",</comment><comment>                      "-radius": "1.0",</comment><comment>                      "-height": "2.0"</comment><comment>              "Viewpoint": {</comment><comment>                "-centerOfRotation": "0 0 0",</comment><comment>                "-position": "0 0 15",</comment><comment>                "-orientation": "0 1 0 0"</comment><comment>          "-class": "case",</comment><comment>          "#text": "  "</comment><comment>      "script": {</comment><comment>        "-type": "text/javascript",</comment><comment>        "-src": "x3dom.js"</comment><return>   ^ json.</return><r>***129 lines of code ***</r></pre><pre><b>x3dExampleXML</b><comment>   "Example to aid design </comment><comment>        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</comment><return>   ^xml.</return><r>***74 lines of code ***</r></pre><pre><b>x3dMaterial</b><comment>   "Return X3D element for appearance/material of this color and opacity.</comment><comment>   "</comment><return>   ^x3d.</return></pre><pre><b>x3dMaterialColorRed: red green: green blue: blue alpha: alpha </b><comment>   "Return X3D element for appearance/material of this color and opacity."</comment><comment>   "All of the arguments are between zero and one."</comment><return>   ^x3d.</return></pre><pre><b>x3dShape</b><comment>   "Produce X3D XML shape element"</comment><comment>   "Check that my typeOfSolid instance variable is x3d compatible."</comment><return>   ^x3d.</return></pre><pre><b>x3dShape: typeOfShape diffuseColor: diffuseColor specularColor: specularColor</b><comment>   "Produce X3D XML shape element - override instance variable color?"</comment><return>   ^x3d.</return><r>***23 lines of code ***</r></pre><hr/><h3>Hum-UI -- HumSpace</h3><pre><b>asPolygons</b><comment>   "Return an empty collection of polygons - HumSpace is not drawn. It is used for spacing in layout logic."</comment><return>   ^    OrderedCollection new.</return></pre><pre><b>asPolygonsColorCoded</b><comment>   "Return an empty collection of polygons - HumSpace is not drawn. It is used for spacing in layout logic."</comment><return>   ^    OrderedCollection new.</return></pre><pre><b>asVPythonThing</b><comment>   "A space has no color and is not visible."</comment><return>   ^pythonCode</return></pre><hr/><h3>Hum-UI -- HumStringWidget</h3><pre><b>asHTML</b><comment>   "Generate HTML input element"</comment><return>   ^html.</return></pre><pre><b>asMorph</b><return>   ^morph.</return></pre><pre><b>renderContentOn: aWAHtmlCanvas</b><comment>   "render self via a simple input tag"</comment></pre><hr/><h3>Hum-UI -- HumSurface</h3><pre><b>about</b><comment>"</comment></pre><pre><b>addShape: aHumSurface </b></pre><pre><b>asBillBoard</b><comment>   "Convert the surface to a thin HumBox."</comment><comment>   "Note: Dimensions given in pixels will be coverted to millimeters."</comment><comment>   "Draw children, if any, on canvas"</comment><todo>         "TODO: Position the part on the billboard"</todo><comment>   "Attach the canvas to the South face of the billboard."   </comment><return>   ^billboard.</return><r>***25 lines of code ***</r></pre><pre><b>asHTML</b><comment>   " Render surface as HTML"</comment><return>   ^html.</return></pre><pre><b>asHtmlCanvasOffsetX: offsetX y: offsetY</b><comment>   "Return a HTML &lt;rect . . . /&gt; element for this surface."</comment><comment>   "Don't scale dimensions in this version"</comment><return>   ^xml. </return><r>***29 lines of code ***</r></pre><pre><b>asMeasure: aQuantity</b><comment>   "Require internal consistency."</comment><return>   ^measure</return></pre><pre><b>asMorph</b><return>   ^result.</return></pre><pre><b>asSVG</b><comment>   "Generate the opening &lt;svg . . . &gt; element."</comment><return>   ^svg.</return></pre><pre><b>asSvgRect</b><comment>   "Return a SVG &lt;rect . . . /&gt; element for this surface."</comment><todo>   "TODO: Determine what SVG scale and transpose should be applied to this surface's rectangle."</todo><todo>   "TODO: Order the shapes by layer."</todo><return>   ^xml. </return><r>***24 lines of code ***</r></pre><pre><b>asSvgRectOffsetX: offsetX y: offsetY</b><comment>   "Return a SVG &lt;rect . . . /&gt; element for this surface."</comment><comment>   "Don't scale dimensions in this version"</comment><return>   ^xml. </return><r>***28 lines of code ***</r></pre><pre><b>asSvgViewBox</b><comment>   "Set up standard attributes for the svg prolog."</comment><return>   ^svg.</return><r>***25 lines of code ***</r></pre><pre><b>asXML</b><return>   ^xml.</return></pre><pre><b>asXMLRectOffsetX: offsetX y: offsetY </b><comment>   "Return a hum &lt;surface . . . /&gt; element for this surface."</comment><return>   ^xml. </return><r>***27 lines of code ***</r></pre><pre><b>backgroundColor</b><return>   ^ backgroundColor ifNil: [backgroundColor := Color gray ].</return></pre><pre><b>backgroundColor: aColor</b><comment>   "Set color to be used when background is rendered."</comment></pre><pre><b>bbBottom</b><comment>   "Find my bounding box edge."</comment><return>   ^myEdge.</return></pre><pre><b>bbEdge: aSymbol</b><comment>   "Find my bounding box edge. </comment><return>   ^myEdge.</return></pre><pre><b>bbHeight</b><comment>   "Find my bounding box edge."</comment><return>   ^bbHeight.</return></pre><pre><b>bbLeft</b><comment>   "Find my bounding box edge."</comment><return>   ^myEdge.</return></pre><pre><b>bbRight</b><comment>   "Find my bounding box edge."</comment><return>   ^myEdge.</return></pre><pre><b>bbTop</b><comment>   "Find my bounding box edge."</comment><return>   ^myEdge.</return></pre><pre><b>bbWidth</b><comment>   "Find my bounding box edge."</comment><return>   ^bbWidth.</return></pre><pre><b>borderColor</b><comment>   "What color is my border, ifany?"</comment><return>   ^borderColor ifNil: [ borderColor := Color black ].</return></pre><pre><b>bottom</b><return>   ^ bottom ifNil: [ self bottom: 0 meter ].</return></pre><pre><b>bottom: aNumber</b><comment>   "Reset the bottom edge."</comment><comment>   "Force top edge to be bottom + height"</comment></pre><pre><b>canvas</b><comment>   "Attach a canvas - for placing drawings and images on the surface"</comment><return>   ^canvas ifNil:[ canvas := HumCanvas new ].</return></pre><pre><b>defaultUnits</b><return>   ^defaultUnits ifNil: [ defaultUnits := 'px' ].</return></pre><pre><b>defaultUnits: aSymbol</b><return>   ^defaultUnits := aSymbol.</return></pre><pre><b>drawOn: aHumCanvas </b><comment>   "Draw self on the given canvas."</comment></pre><pre><b>expandToFit</b></pre><pre><b>fillColor</b><comment>   "What color is my fill, ifany?"</comment><return>   ^fillColor ifNil: [ fillColor := Color gray ].</return></pre><pre><b>generateHumScript</b><comment>   "Proof of concept: Generate Hum code."</comment><return>   ^script.</return></pre><pre><b>height</b><comment>   "What is the height of this object?</comment><comment>   "</comment><return>   ^ height ifNil: [ self height: 0 meter ].</return></pre><pre><b>height: aNumber.</b><comment>   "Reset the distance between top and bottom edges."</comment><comment>   "Force the bottom to be the top minus the height."</comment></pre><pre><b>id</b><return>   ^ id</return></pre><pre><b>id: aString </b></pre><pre><b>initialize</b></pre><pre><b>initialize: units</b><comment>   "Reset #pixel to #px as needed.</comment><comment>   "</comment><r>***21 lines of code ***</r></pre><pre><b>layer</b><comment>   "What layer is the surface in?</comment><comment>   "</comment><comment>   "By default, a surface is in layer zero."</comment><return>   ^ layer ifNil: [ layer := 0 ].</return></pre><pre><b>layer: aNumber</b></pre><pre><b>left</b><return>   ^ left ifNil: [ self left: 0 meter ].</return></pre><pre><b>left: aNumber</b><comment>   "Reset the left edge."</comment><comment>   "Force the right edge to keep width constant."</comment></pre><pre><b>origin</b><comment>   "a zero-size object positioned at ( left top layer ) = ( 0 0 0 )"</comment><return>   ^ origin ifNil: [ origin := HumSurface new.  ].</return></pre><pre><b>overlay: aHumSurfaceB onTopOf: aHumSurfaceA </b><comment>   "Both shapes are assumed (forced) to be present in my collection."</comment><comment>   "By convention, surface B will be aligned with A's top and left edges."</comment><comment>   "By convention, surface B will be placed in a higher numbered layer."</comment><comment>   "Note: If there already was already another shape on top and in same layer, </comment></pre><pre><b>place: aHumSurfaceB above: aHumSurfaceA </b><comment>   "Place B above A on the surface. </comment><comment>   "Assure that A and B are in my collection."</comment><comment>   "By convention, set B's bottom will be equal to A's top.</comment><comment>   "By convention, B is now in the same layer as A."</comment></pre><pre><b>place: aHumSurface at: anArray </b></pre><pre><b>place: aHumSurfaceB below: aHumSurfaceA </b><comment>   "Place B below A on the surface. (Not to be confused with putting B on a different  layer.)"</comment><todo>   "TODO: Consider making calls to top: right: left: using blocks (closures) so that everything is dynamic.</todo><comment>   "</comment><comment>   "Assure that A and B are in my collection."</comment><comment>   "By convention, set B's top to be equal to A's bottom.</comment><comment>   "By convention, B is now in the same layer as A."</comment></pre><pre><b>place: aHumSurfaceB leftOf: aHumSurfaceA </b><comment>   "Place B left of A on the surface. "</comment><comment>   "Assure that A and B are in my collection."</comment><comment>   "By convention, set B's left to be equal to A's right.</comment><comment>   "By convention, B is now in the same layer as A."</comment></pre><pre><b>place: aHumSurfaceB rightOf: aHumSurfaceA </b><comment>   "Place B right of A on the surface. "</comment><comment>   "Assure that A and B are in my collection."</comment><comment>   "By convention, set B's right to be equal to A's left.</comment><comment>   "By convention, B is now in the same layer as A."</comment></pre><pre><b>right</b><return>   ^ right ifNil: [self right: 0 meter ].</return></pre><pre><b>right: aNumber</b><comment>   "Reset the right edge."</comment><comment>   "Force the left edge to keep the width constant."</comment></pre><pre><b>shapes</b><comment>   "I remember the 2d objects placed on me."</comment><return>   ^ shapes ifNil: [ shapes := Set new. ].</return></pre><pre><b>title</b><return>   ^ title ifNil: [ self id ].</return></pre><pre><b>title: aString</b></pre><pre><b>top</b><return>   ^ top ifNil: [ top := 0 ].</return></pre><pre><b>top: aNumber</b><comment>   "Reset the top edge."</comment><comment>   "Force the bottom edge to keep the height constant."</comment></pre><pre><b>width</b><return>   ^ width ifNil: [ self width: 0 meter. ]</return></pre><pre><b>width: anObject</b><comment>   "Reset the width. </comment><comment>   "Force the right edge to be consistent."</comment></pre><hr/><h3>Hum-UI -- HumTextPrettyPrinter</h3><pre><b>addCommentToEndOfLineStartsWith: aString </b></pre><pre><b>parse: aHumTextLine </b><comment>   "delimiters := (' ', startCommentToEndOfLine )."</comment><return>   ^ ppTokens.</return></pre><hr/><h3>Hum-UI -- HumTextPrettyToken</h3><pre><b>string</b><return>   ^ string ifNil: [ string := String new. ].</return></pre><pre><b>string: aString </b></pre><hr/><h3>Hum-UI -- HumTextWidget</h3><pre><b>asHTML</b><comment>   "Generate HTML textarea element"</comment><return>   ^html.</return></pre><pre><b>asMorph</b><comment>   "Instantiate a TextMorph of some kind."</comment><comment>   "Set some visual properties."</comment><todo>   "TODO: Wire up the UI interaction: </todo><return>   ^morph.</return></pre><pre><b>renderContentOn: aWAHtmlCanvas</b><comment>   "render self via a text area tag"</comment></pre><pre><b>rows</b><comment>   "How many rows should we display?" </comment><return>   ^ rows</return></pre><pre><b>rows: aSmallInteger</b><comment>   "How many rows should we display?" </comment></pre><hr/><h3>Hum-UI -- HumVR</h3><pre><b>addScene: aHumScene </b></pre><pre><b>jump:  aTime</b><comment>   "Execute equations of motion, etc."</comment><todo>   "TODO: Make compatible to HumSimulator."</todo></pre><pre><b>jumpTime</b><return>   ^jumpTime.</return></pre><pre><b>jumpTime: aTime</b></pre><pre><b>scenes</b><return>   ^ scenes ifNil: [  scenes := Dictionary new ].</return></pre><pre><b>start</b><comment>   "Start stepping."</comment></pre><pre><b>stop</b><comment>   "Stop stepping"</comment></pre><hr/><h3>Hum-UI -- HumViewPortMorph</h3><pre><b>camera</b><return>   ^camera.</return></pre><pre><b>handleKeystroke: anEvent</b><r>***32 lines of code ***</r></pre><pre><b>handlesMouseOver: evt</b><return>   ^true.</return></pre><pre><b>mouseEnter: anEvent</b></pre><pre><b>mouseLeave: anEvent</b></pre><pre><b>viewPort</b><return>   ^ viewPort</return></pre><pre><b>viewPort: aHumViewPort </b></pre><hr/><h3>Hum-UI -- HumViewPort</h3><pre><b>asMorph</b><return>   ^morph.</return></pre><pre><b>camera</b><comment>   "Which camera (in the scene)?"</comment><return>   ^camera ifNil: [ Error signal: 'Viewport needs a camera.' ]</return></pre><pre><b>camera: aCamera </b><comment>   "Which camera (in the scene)?"</comment></pre><pre><b>cameraCanSeePolygon: aHumPolygon </b><comment>   "The camera can see the polygon </comment><comment>      "Delegate to camera (HumCamera)"</comment><return>   ^false.</return></pre><pre><b>changed</b></pre><pre><b>getPolygonsForSolids: aCollectionOfSolids </b><comment>   "Return polygons corresponding to the surfaces of the given solids."</comment><comment>   "NOTE: These polygons are not transformed."</comment><return>   ^polygons.</return></pre><pre><b>getPolygonsForSolids: aCollectionOfSolids colorRule: aOneArgumentBlock</b><comment>   "Return polygons corresponding to the surfaces of the given solids."</comment><comment>   "NOTE: These polygons are not transformed."</comment><return>   ^polygons.</return></pre><pre><b>mapPolygonsFrom3Dto2D</b><comment>   "Each solid in the scene provides a collection of polygons with points in 3D scene coordinates. </comment><return>    ^viewportPolygons.</return></pre><pre><b>mapPolygonsFrom3Dto2DcolorCoded</b><comment>   "Each solid in the scene provides a collection of polygons with points in 3D scene coordinates. </comment><comment>               "Project onto camera frustrum"</comment><todo>         "TODO: Cull faces that are behind the camera."</todo><todo>         "TODO: Sort faces to draw those that are far from camera under those that are close."</todo><return>   ^viewportPolygons.</return><r>***32 lines of code ***</r></pre><pre><b>mapPolygonsToViewPort: aCollectionOfPolygons </b><comment>   "Map from 3D to 2D"</comment><return>   ^viewportPolygons</return></pre><pre><b>mapToCanvas: aHumCanvas bounds: aRectangle </b><comment>   "Declare where to draw me. Drawing is defered. See . . ."</comment><todo>   "TODO: These declarations should affect asMorph."</todo></pre><pre><b>mapTrianglesFrom3Dto2D</b><comment>   "Each solid in the scene provides a collection of polygons with points in 3D scene coordinates. </comment><return>   ^viewportPolygons.</return></pre><pre><b>paintHumPolygon: aHumPolygon </b><comment>   "The HumPolygon may contain 3D points and specifies fill and border colors. </comment></pre><pre><b>paintScene</b><comment>   "Render solids in my scene as polygons projected onto my canvas."</comment><comment>   "Solid faces are 3D polygons. Project to 2D viewport canvas."</comment></pre><pre><b>paintSceneAsTriangles</b><comment>   "Render solids in my scene as polygons projected onto my canvas."</comment><comment>   "Solid faces are 3D polygons. Project to 2D viewport canvas."</comment></pre><pre><b>paintSceneColorCoded</b><comment>   "Render solids in my scene as polygons projected onto my canvas."</comment><return>   ^ self renderSceneAsTriangles. </return></pre><pre><b>projectPolygon: aScenePolygon </b><comment>   "Return a new polygon with the points transformed into camera`s coordinate system."</comment><comment>   "Initialize polygon colors"</comment><comment>   "Get camera depth"</comment><return>   ^transformedPolygon.</return></pre><pre><b>projectScenePoint: aViewPoint cameraDepth: aCameraDepth</b><comment>   "Translate from camera view coordinates (meters) to canvas coordinates (px)"</comment><comment>   "Map East-West to x; North-South to y; Up-Down to z, Time to w."</comment><return>   ^aCanvasPoint.</return><r>***23 lines of code ***</r></pre><pre><b>projectionMode</b><comment>   "Map the scene polygons onto the viewport using orthogonal or perspective projection?"</comment><return>   ^ projectionMode ifNil: [ projectionMode := #perspective ]</return></pre><pre><b>projectionMode: aSymbol </b></pre><pre><b>renderScene</b><comment>   "Render solids in my scene as polygons projected onto my canvas."</comment><return>   ^self renderSceneAsTriangles.</return></pre><pre><b>renderSceneAsTriangles</b><comment>      "Render solids in my scene as polygons projected onto my canvas."</comment><comment>   "Solid faces are 3D polygons. Project to 2D viewport canvas."</comment></pre><pre><b>renderSceneAsWireFrame</b><comment>   "Render solids in my scene as polygons projected onto my canvas."</comment><comment>   "Solid faces are 3D polygons. Project to 2D viewport canvas."</comment></pre><pre><b>repaint</b><comment>   "Repaint using stored block."</comment></pre><pre><b>repaint: aBlock</b><comment>   "Which method to use when repainting?"</comment></pre><pre><b>scalePixelsPerMillimeter</b><return>   ^pixelsPerMillimeter ifNil: [ pixelsPerMillimeter := (5 px) / (1 millimeter) ].</return></pre><pre><b>scalePoint: aScenePoint scaleRatio: pxPerMeter </b><comment>   "Return a x@y point by scaling the given scene point"</comment><return>   ^ canvasX @ canvasY.</return><r>***21 lines of code ***</r></pre><pre><b>scene: aScene </b></pre><pre><b>selectSolidsInFrontOfCamera</b><comment>   "Return collection of solids whose centers are in front of camera."</comment><comment>    "Explode each assembly to get constituent solids."</comment><return>   ^cameraSolids.</return></pre><pre><b>transformPointIntoCameraFrame: aPoint3D </b><comment>   "Transform the point into the camera`s coordinate system."</comment><comment>   "Translate"</comment><comment>   "Rotate"</comment><comment>   "Tilt"</comment><return>   ^HumVector newFrom: { cameraX. cameraY. cameraZ. }.</return><r>***42 lines of code ***</r></pre><pre><b>transformPolygonToCameraFrame: aScenePolygon </b><comment>   "Return a new polygon with the points transformed into camera`s coordinate system."</comment><comment>   "Initialize polygon colors"</comment><comment>   "Get camera depth"</comment><return>   ^transformedPolygon.</return></pre><pre><b>update: anObject </b><comment>   "Something in my model has been changed."</comment><comment>   "Transcript cr; show: 'Scene changed.'."</comment></pre><pre><b>zmapPolygonsFrom3Dto2D</b><comment>   "Each solid in the scene provides a collection of polygons with points in 3D scene coordinates. </comment><comment>   "Define the function we use to may from 3D to camera pixel point."</comment><comment>   "Paint distant objects before those that are near."</comment><return>   ^viewportPolygons.</return><r>***23 lines of code ***</r></pre><pre><b>zrenderScene</b><comment>   "Render solids in my scene as polygons projected onto my canvas."</comment><comment>   "Solid faces are 3D polygons. Project to 2D viewport canvas."</comment></pre><hr/><h3>Hum-UI -- HumView</h3><pre><b>asWidget</b><comment>   "Initialize a HumFormWidget for this view"</comment><return>   ^formWidget ifNil: [ formWidget := HumFormWidget onView: self]</return></pre><pre><b>blackboard</b><return>   ^ blackboard ifNil: [ Error signal: 'No blackboard has been assigned to this view.'].</return></pre><pre><b>blackboard: aHumBlackBoard</b></pre><pre><b>calc</b><comment>   "Create a calculator to be shared . . ."</comment><return>   ^ calc ifNil: [ calc := HumCalculator new ].</return></pre><pre><b>checkRenderOn: html</b></pre><pre><b>entityName</b><return>   ^entityName ifNil: [Error signal: 'No entity name has been set for this view.']</return></pre><pre><b>entityName: aString</b><comment>   "Set"</comment></pre><pre><b>interpretEmphasisIn: aString on: aWAHtmlCanvas </b><comment>   "Stub"</comment></pre><pre><b>ontology: aHumOntology </b></pre><pre><b>renderFrameLine: aHumMarkupLine viaSeasideCanvas: aWAHtmlCanvas </b><comment>   "Maintain spacing."</comment><comment>   "Is this markup line a heading?"</comment><comment>   "If this is a heading, render the whole line as a heading. "   </comment><comment>   "Call self recursively to catch any additional emphasis (e.g. italics)"</comment><comment>   "Is this markup line a bullet/numbered list item."   </comment><todo>            "TODO: Figure out how to emit '&lt;/ul&gt;' and '&lt;/ol&gt;.' -- Might need MODES. (heavens)"</todo><return>            ^html.   </return><todo>   "TODO: AT THIS POINT - OUTPUT UP TO NEXT MARK-UP"</todo><comment>               "Default type is a simple string"</comment><comment>               "Check for special types"</comment><r>***93 lines of code ***</r></pre><pre><b>renderMarkupLinesViaSeasideOn: aWAHtmlCanvas </b><comment>   "Render the ontology view frame lines via Seaside"</comment></pre><pre><b>renderUpToNextWidget: aMarkupString on: html</b><comment>   "Render mark-up that does not involve heading/list/widget"</comment><comment>   "Precondition: Caller has already handled and removed markup for header or list."</comment><comment>   "Break up the line. We will only render non-widget stuff."</comment><todo>   "TODO: Interpret emphasis -- if any"</todo><return>   ^remainder.</return></pre><pre><b>view</b><return>   ^ viewFrame ifNil: [Error signal: (self class asString),' not initialized']</return></pre><pre><b>view: aViewNameString </b><comment>   "Fetch the view frame of that name."</comment></pre><hr/><h3>Hum-UI -- HumWidget</h3><pre><b>about</b><comment>" The traditional idea of a widget is that it is a component in a view. (MVC concept)</comment><comment>"</comment><comment>"</comment><comment>"</comment><comment>"</comment><comment>"</comment><comment>" Note: An Avatar may be a kind of widget. </comment><comment>"</comment><comment>" A Scene is mostly decoration, but it may also trigger interaction via proximity triggers.</comment><r>***26 lines of code ***</r></pre><pre><b>asGlamorBrick</b><comment>   "Render widget and data as Glamor Brick object"</comment></pre><pre><b>asHTML</b><comment>   "Render widget and data as HTML code"</comment></pre><pre><b>asJSF</b><comment>   "Render widget and data as Jave Server Face code"</comment></pre><pre><b>asMagritteMorph</b><comment>   "Render widget and data as Magritte Morph object"</comment></pre><pre><b>asMorph</b><comment>   "Render widget and data as Morph object  </comment></pre><pre><b>asXUL</b><comment>   "Render widget and data as XUL code"</comment></pre><pre><b>attributeName</b><return>   ^attributeName</return></pre><pre><b>attributeName: aString</b><comment>   "name of attribute"</comment></pre><pre><b>attributeValue</b><return>   ^ attributeValue ifNil: [ '' ].</return></pre><pre><b>attributeValue: aString</b><comment>   "Set current value of attribute -- in display/input format."</comment><comment>   "See &gt;&gt;store: -- which sets the value and also notifies the blackboard."</comment></pre><pre><b>blackboard: aHumBlackBoard </b></pre><pre><b>canvas</b><comment>   "Canvas on which to draw the widget - "</comment><return>   ^canvas ifNil: [ canvas := HumCanvas new. ].</return><comment>"</comment></pre><pre><b>canvas: aHumCanvas </b><comment>   "Canvas on which to draw the widget - "</comment></pre><pre><b>entityName: aString </b></pre><pre><b>formCanvas</b><return>   ^self canvas formCanvas.</return></pre><pre><b>renderContentOn: aWAHtmlCanvas</b><comment>   "Default: Render self via a simple input tag"</comment></pre><pre><b>store: anObject </b><comment>   "Set my attribute value and store it on my blackboard."</comment><todo>   "TODO: Perhaps this should be #update: method to correspond with other UI controller conventions."</todo><comment>   "Note: The blackboard might send the value to it`s world-base, if it has a world-base."</comment></pre><hr/><hr/><h2>Hum-X</h2><hr/><h3>Hum-X -- H3dCamera</h3><pre><b>depth</b><comment>   "Distance from eye point to viewport rectangle."</comment><return>   ^ depth</return></pre><pre><b>depth: aHumMeasure </b><comment>   "Distance from eye point to viewport rectangle."</comment></pre><pre><b>projectScenePointToScreenPoint: aScenePoint</b><comment>   "Map a scene point onto a screen point ( x y z ) ==&gt; ( x' y' z').</comment><comment>   "Filter points that are behind the screen."</comment><comment>   "Get the rise over run (tangent of angle)."</comment><comment>   "Filter points that are not visible."</comment><comment>   "Calculate the offset in meters."</comment><comment>   "Original y is kept so that we can render overlaping points correctly. "</comment><return>   ^screenPoint.</return><r>***24 lines of code ***</r></pre><pre><b>scene: aScene</b><comment>   "Scene (or layer) the camera is viewing."</comment></pre><hr/><h3>Hum-X -- H3dObjectTests</h3><pre><b>test110buildBox</b><comment>   "Check that dimension were stored."</comment><comment>   "Volume"</comment><comment>   "Polygons ==&gt; cube faces in this case"</comment></pre><pre><b>test120yawBox90degrees</b><comment>   "90 degree yaw exchanges X and Y"</comment></pre><pre><b>test122yawBox90degreesAroundPivot</b><comment>   "90 degree yaw exchanges X and Y"</comment><r>***22 lines of code ***</r></pre><pre><b>test125yawBox180degrees</b><comment>   "180 degree rotations should leave bounds the same."</comment></pre><pre><b>test130pitchBox90degrees</b><comment>   "90 degree pitch exchanges Y and Z"</comment></pre><pre><b>test132pitchBox90degreesAboutPivot</b><comment>   "90 degree pitch exchanges Y and Z"</comment></pre><pre><b>test135pitchBox180degrees</b><comment>   "180 degree rotations should leave bounds the same."</comment></pre><pre><b>test140rollBox90degrees</b><comment>   "90 degree roll exchanges X and Z"</comment></pre><pre><b>test142rollBox90degreesAboutPivot</b><comment>   "90 degree roll exchanges X and Z"</comment></pre><pre><b>test143rollBox90degreesAboutPivot</b><comment>   "90 degree roll exchanges X and Z"</comment></pre><pre><b>test145rollBox180degrees</b><comment>   "180 degree rotations should leave bounds the same."</comment></pre><pre><b>test150yawPitchRollBox</b><comment>   "180 degree rotations should leave it looking the same."</comment></pre><pre><b>test220moveBoxEast</b></pre><pre><b>test225moveBoxWest</b></pre><pre><b>test230moveBoxNorth</b></pre><pre><b>test235moveBoxSouth</b></pre><pre><b>test240moveBoxTop</b></pre><pre><b>test245moveBoxBottom</b></pre><pre><b>test310stepVelocity</b></pre><pre><b>test320stepYawRate</b><comment>   "Expect X and Y bounds to exchange."</comment></pre><pre><b>test325stepVelocityAndYawRate</b><comment>   "Expect X and Y bounds to exchange."</comment></pre><pre><b>test330stepPitchRate</b><comment>   "Expect Y and Z bounds to exchange."</comment></pre><pre><b>test335stepVelocityAndPitchRate</b><comment>   "Expect Y and Z bounds to exchange."</comment></pre><pre><b>test340stepRollRate</b><comment>   "Expect X and Z bounds to exchange."</comment></pre><pre><b>test345stepVelocityAndRollRate</b><comment>   "Expect X and Z bounds to exchange."</comment></pre><pre><b>test350stepEverything</b><comment>   "Expect X and Z bounds to exchange."</comment><r>***23 lines of code ***</r></pre><pre><b>test610buildElipsoid</b><comment>   "Check that dimensions were stored."</comment><comment>   "The number of polygons should be the square of the numberOfWedges."</comment><comment>   "Check that the polygons are in range."</comment></pre><pre><b>test620yawElipsoid90degrees</b><comment>   "90 degree yaw exchanges X and Y"</comment></pre><pre><b>test630pitchElipsoid90degrees</b><comment>   "90 degree pitch exchanges Y and Z"</comment></pre><pre><b>test640rollElipsoid90degrees</b><comment>   "90 degree roll exchanges X and Z bounds"</comment></pre><pre><b>test710buildRotation</b><comment>   "Check that dimension were stored."</comment><comment>   "Check expected bounds"</comment></pre><pre><b>test711buildRotationAroundX</b><comment>   "Check that dimension were stored."</comment><comment>   "Check expected bounds"</comment></pre><pre><b>test712buildRotationAroundY</b><comment>   "Check that dimension were stored."</comment><comment>   "Check expected bounds"</comment></pre><pre><b>test810buildAssembly</b></pre><pre><b>test820stackBoxes</b><comment>   "Part positions are relative to the assembly center."</comment><comment>   "Check resulting positions in CONTAINER coordinates."</comment><comment>   "Check resulting positions in SCENE coordinates"</comment><r>***33 lines of code ***</r></pre><pre><b>test821stackAndYaw90</b><comment>   "Part positions are relative to the assembly center."</comment><comment>   "Check resulting positions in CONTAINER coordinates."</comment><comment>   "Check resulting positions in SCENE coordinates"</comment><comment>   "Zero yaw should have no effect."   </comment><comment>   "Yaw 90 degrees and see . . ."</comment><comment>   "x and y offsets should exchange"</comment><r>***49 lines of code ***</r></pre><pre><b>test822stackAndPitch90</b><comment>   "Part positions are relative to the assembly center."</comment><comment>   "Check resulting positions in CONTAINER coordinates."</comment><comment>   "Check resulting positions in SCENE coordinates"</comment><comment>   "Zero pitch should have no effect."   </comment><comment>   "Pitch 90 degrees up and see . . ."</comment><comment>   "y and z offsets should exchange"</comment><r>***49 lines of code ***</r></pre><pre><b>test824stackAndRoll90</b><comment>   "Part positions are relative to the assembly center."</comment><comment>   "Check resulting positions in CONTAINER coordinates."</comment><comment>   "Check resulting positions in SCENE coordinates"</comment><comment>   "Zero roll should have no effect."   </comment><comment>   "Roll 90 degrees and see . . ."</comment><comment>   "x and z offsets should exchange"</comment><r>***49 lines of code ***</r></pre><hr/><h3>Hum-X -- H3dObject</h3><pre><b>addPart: anH3dObject</b><comment>   "Add a part (or subassembly) to my assembly."</comment></pre><pre><b>addParts: aPartsList</b><comment>   "Add each part to my set of parts."</comment></pre><pre><b>assertRadians: anAngleInRadians</b></pre><pre><b>assertRadiansPerSecond: radiansPerSecond</b></pre><pre><b>axis: anAxisSymbol</b><comment>   "Which axis is rotation around? </comment><return>   ^ axis := anAxisSymbol.</return></pre><pre><b>borderColor</b><return>   ^ borderColor ifNil: [ borderColor := (self fillColor) lighter. ].</return></pre><pre><b>bottom</b><comment>   "Value without yaw, pitch, roll - Use minZ to see value with yaw, pitch, roll."</comment><return>   ^  ( center z ) - ( height / 2.0 ).</return></pre><pre><b>bottom: aMeasure</b><comment>   "Move so that bottom is at given z value."</comment></pre><pre><b>buildAndOrient</b><comment>   "Return polygons in scene coordinates.</comment><comment>      "To assure consistent results, alway apply in order: yaw, pitch, roll. "</comment><return>   ^adjustedPolygons.</return></pre><pre><b>buildAssembly</b><comment>   "Build the polygons for the assembly by aggregating and translating polygons from the parts."</comment><return>   ^translatedPolygons.</return></pre><pre><b>buildBasePolygons</b><comment>   "Return my base polygons. Polygons before pitch, yaw, roll."</comment><return>   ^polygons.</return></pre><pre><b>buildBox</b><comment>   "Create polygons for a box"</comment><comment>   "assemble faces"         </comment><comment>   "color"</comment><return>   ^ polygons.</return><r>***53 lines of code ***</r></pre><pre><b>buildElipsoid</b><comment>   "Create polygons forming the elipsoid."</comment><comment>   "Work from bottom to top"</comment><comment>   "color"</comment><return>   ^polygons.</return><r>***38 lines of code ***</r></pre><pre><b>buildRotation</b><comment>   "Given curve and an axis, build a rotation as a collection of polygons."</comment><comment>   "Adjust for non-default axis of rotation."</comment><comment>   "color"</comment><return>    ^adjustedPolygons. </return><r>***39 lines of code ***</r></pre><pre><b>center</b><return>   ^ center ifNil: [ center := (HumVector newFrom: { 0.0 meter. 0.0 meter. 0.0 meter. } ) ].</return></pre><pre><b>center: aVector</b><comment>   "Set my center in container coordinates."</comment></pre><pre><b>clearance</b><comment>   "Default value for clearance is one millimeter."</comment><return>   ^clearance ifNil: [ clearance := 0.001 meter ].</return></pre><pre><b>curve: xyPoints</b><comment>   "Curve to use when building a rotation.</comment></pre><pre><b>east</b><comment>   "Value without yaw, pitch, roll - Use maxX to see value with yaw, pitch, roll."</comment><return>   ^  ( center x ) + ( width / 2.0 ).</return></pre><pre><b>east: aMeasure</b><comment>   "Move so that east edge is at the given value."</comment></pre><pre><b>fillColor</b><return>   ^ fillColor ifNil: [ fillColor := Color gray. ].</return></pre><pre><b>height</b><comment>   "What is my Up-Down height? (prior to pitch, yaw, roll).</comment><return>   ^ height ifNil: [ Error signal: 'height dimension has not been set' ].</return></pre><pre><b>height: aHeight</b><comment>   "What is my Up-Down height? (prior to pitch, yaw, roll).</comment></pre><pre><b>initialize</b><comment>   "Set initial position, orientation, velocity, and rotation rates to zero."</comment></pre><pre><b>length</b><comment>   "What is my North-South length? (prior to pitch, yaw, roll)</comment><return>   ^ length ifNil: [ Error signal: 'length dimesion has not been set' ].</return></pre><pre><b>length: aLength</b><comment>   "What is my North-South length? (prior to pitch, yaw, roll)</comment></pre><pre><b>maxX</b><return>   ^ v.</return></pre><pre><b>maxY</b><return>   ^ v.</return></pre><pre><b>maxZ</b><return>   ^ v.</return></pre><pre><b>minX</b><return>   ^ v.</return></pre><pre><b>minY</b><return>   ^ v.</return></pre><pre><b>minZ</b><return>   ^ v.</return></pre><pre><b>move: aH3dObject toMyCoordinate: aHumVector </b></pre><pre><b>north</b><comment>   "Value without yaw, pitch, roll - Use maxY to see value with yaw, pitch, roll."</comment><return>   ^  ( center y ) + ( length / 2.0 ).</return></pre><pre><b>north: aMeasure</b><comment>   "Move so that north edge is at given value."</comment></pre><pre><b>numberOfWedges</b><comment>   "Number of wedges to produce when drawing rotation or elipsoid."</comment><return>   ^ numberOfWedges ifNil: [ numberOfWedges := 12 ].</return></pre><pre><b>numberOfWedges: anInteger </b></pre><pre><b>parts</b><comment>   "Return my set of parts/subassemblies - each part is unique - hence a member of a set."</comment><return>   ^ parts ifNil: [  parts := Set new. ].</return></pre><pre><b>pitch</b><comment>   "Amount of current pitch = rotation about x-axis"</comment><return>   ^ pitch ifNil: [ pitch := 0.0 radian ].</return></pre><pre><b>pitch: anAngleInRadians</b><comment>   "Amount of current pitch = rotation about x-axis"</comment></pre><pre><b>pitchRate: randiansPerSecond</b><comment>   "pitch rate (angular velocity) "</comment></pre><pre><b>pivot</b><comment>   "Return the pivot in scene coordinates."</comment><return>   ^pivot</return></pre><pre><b>pivotPoint</b><comment>   "Pivot-point is relative to object`s center. </comment><return>   ^pivotPoint ifNil: [ pivotPoint := HumVector zeroVector: #meter ].</return></pre><pre><b>pivotPoint: aVector</b><comment>   "Pivot-point is relative to object`s center.</comment></pre><pre><b>place: aH3dObjectA onTopOf: aH3dObjectB </b><comment>   "Position so that  bottom matches top with a little clearance."</comment></pre><pre><b>polygons</b><return>   ^polygons</return></pre><pre><b>roll</b><comment>   "Amount of current roll. = rotation about y-axis"</comment><return>   ^roll ifNil: [ roll := 0.0 radian ].</return></pre><pre><b>roll: anAngleInRadians</b><comment>   "Amount of current roll. = rotation about y-axis"</comment></pre><pre><b>rollRate: randiansPerSecond</b><comment>   "roll rate (angular velocity) "</comment></pre><pre><b>south</b><comment>   "Value without yaw, pitch, roll - Use minY to see value with yaw, pitch, roll."</comment><return>   ^  ( center y ) - ( length / 2.0 ).</return></pre><pre><b>south: aMeasure</b><comment>   "Move so that south edge is at given value."</comment></pre><pre><b>step: aTimeIncrement</b><comment>   "Step the position and orientation."</comment><comment>   "self assert: ((aTimeIncrement isKindOf: HumMeasure) and: [ aTimeIncrement dimensions = { #second-&gt;1. } ] )."</comment><comment>   "Always do yaw, pitch, roll in that order."</comment><comment>   "Update:"</comment></pre><pre><b>top</b><comment>   "Value without yaw, pitch, roll - Use maxZ to see value with yaw, pitch, roll."</comment><return>   ^  ( center z ) + ( height / 2.0 ).</return></pre><pre><b>top: aMeasure</b><comment>   "Move so that top is at given z value."</comment></pre><pre><b>type: aType</b><comment>   "What type of 3D object am I?"</comment></pre><pre><b>velocity: aVector</b><comment>   "Set my velocity in container coordinates."</comment></pre><pre><b>volume</b><comment>   "Return volume of box."</comment><return>    ^volume.</return></pre><pre><b>west</b><comment>   "Value without yaw, pitch, roll - Use minX to see value with yaw, pitch, roll."</comment><return>   ^  ( center x ) - ( width / 2.0 ).</return></pre><pre><b>west: aMeasure</b><comment>   "Move so that west edge is at the given value."</comment></pre><pre><b>width</b><return>   ^ width ifNil: [ Error signal: 'width has not been set' ].</return></pre><pre><b>width: aWidth</b><comment>   "What is my East-West width? (prior to pitch, yaw, roll)</comment></pre><pre><b>yaw</b><comment>   "Amount of current yaw. = rotation about z-axis"</comment><return>   ^ yaw ifNil: [ yaw := 0.0 radian ].</return></pre><pre><b>yaw: anAngleInRadians</b><comment>   "Amount of current yaw. = rotation about z-axis"</comment></pre><pre><b>yawRate: randiansPerSecond</b><comment>   "yaw rate (angular velocity) = rotation about z-axis"</comment></pre><hr/><h3>Hum-X -- H3dPath</h3><pre><b>= anotherPath</b><comment>   "Are the two paths equal."</comment><comment>   "Are they the same size?"</comment><return>   ^result.</return></pre><pre><b>addVertex: xyzCoordinates </b></pre><pre><b>allButFirstDo: aBlockClosure </b><return>   ^self vertices allButFirstDo: aBlockClosure.</return></pre><pre><b>borderColor</b><return>   ^ borderColor ifNil: [ borderColor := (self fillColor) lighter ].</return></pre><pre><b>borderColor: aColor </b><comment>   "Color to use when rendering path (polygon edges)."</comment></pre><pre><b>do: aBlockClosure </b><return>   ^self vertices do: aBlockClosure.</return></pre><pre><b>fillColor</b><return>   ^ fillColor ifNil: [ fillColor := Color gray ].</return></pre><pre><b>fillColor: aColor </b><comment>   "Color to use when rendering path as a polygon"</comment></pre><pre><b>first</b><return>   ^ points at: 1.</return></pre><pre><b>last</b><return>   ^ points last.</return></pre><pre><b>max: aBlockClosure </b><return>   ^self vertices max: aBlockClosure.</return></pre><pre><b>pitch: pitchAngle </b><comment>   "Return a new path with my points adjusted by pitch about origin."</comment><return>   ^newPath</return></pre><pre><b>pitch: pitchAngle aboutPivot: aPivot</b><comment>   "Return a new path with my points adjusted by pitch about origin."</comment><return>   ^newPath</return></pre><pre><b>roll: rollAngle </b><comment>   "Return a new path with my points adjusted by roll about origin."</comment><return>   ^newPath</return></pre><pre><b>roll: rollAngle aboutPivot: aPivot</b><comment>   "Return a new path with my points adjusted by roll about origin."</comment><return>   ^newPath</return></pre><pre><b>size</b><return>   ^ self vertices size.</return></pre><pre><b>translateBy: aHumVector </b><comment>   "Return a path with vertices translated by the given vector."</comment><return>   ^instance.</return></pre><pre><b>vertices</b><return>   ^ vertices ifNil: [ vertices := OrderedCollection new ].</return></pre><pre><b>yaw: yawAngle </b><comment>   "Return a new path with my points adjusted by yaw about origin."</comment><return>   ^newPath</return></pre><pre><b>yaw: yawAngle aboutPivot: pivot</b><comment>   "Return a new path with my points adjusted by yaw about origin."</comment><return>   ^newPath</return></pre><hr/><h3>Hum-X -- H3dViewPortTests</h3><pre><b>test110CreateCamera</b><comment>   "A camera is a 3d-object. Dimensions refer to virtual viewport and eye-point."</comment><comment>   "A camera has a position in a scene."</comment><comment>   "A camera has an orientation."</comment><comment>   "Camera views scene"</comment></pre><pre><b>test120ProjectScenePointToCameraViewPort</b><comment>   "A camera is a 3d-object with dimensions of ..."</comment><comment>   "For this test the orientation is level with no yaw."</comment><comment>   "Test private method ..."</comment></pre><pre><b>test130PitchCamera</b><comment>   "A camera is a 3d-object with dimensions of ..."</comment><comment>   "For this test the orientation is level with no yaw."</comment><comment>   "Test private method ..."</comment><comment>   "Pitch the camera up a little."</comment></pre><pre><b>test140RollCamera</b><comment>   "A camera is a 3d-object with dimensions of ..."</comment><comment>   "For this test the orientation is level with no yaw."</comment><comment>   "Test private method ..."</comment><comment>   "Roll the camera 90 degrees."</comment></pre><pre><b>test150YawCamera</b><comment>   "A camera is a 3d-object with dimensions of ..."</comment><comment>   "For this test the orientation is level with no yaw."</comment><comment>   "Test private method ..."</comment><comment>   "Yaw the camera a little."</comment></pre><pre><b>test160TranslateCamera</b><comment>   "A camera is a 3d-object with dimensions of ..."</comment><comment>   "For this test the orientation is level with no yaw."</comment><comment>   "Test private method ..."</comment><comment>   "Yaw the camera a little."</comment></pre><pre><b>test210CreateViewPort</b><comment>   "A viewport is a view on a scene via a camera in the scene."</comment><comment>   "A viewport is mapped onto a surface."</comment><comment>   "A viewport scales the camera image."</comment><comment>   "A viewport is attached to a camera in a scene."</comment><comment>   "A viewport maps points in the camera image to points in the viewport image."</comment><comment>   "How much distance does a pixel cover at y distance?"</comment><r>***21 lines of code ***</r></pre><hr/><h3>Hum-X -- H3dViewPort</h3><pre><b>camera: anH3dCamera </b><comment>   "The viewport is attached to this camera."</comment></pre><pre><b>mapScenePoint: aScenePoint </b><comment>   "Map scene point to camera image, camera image to my image."</comment><comment>   "The camera returns nil if the point is not visible on its screen, and so do we."</comment><todo>   "TODO: Returning nil as a signal is generally a bad idea."</todo><comment>   "One of the problems with returning nil, is that the point may be the start of a line."</comment><comment>   "Another problem is that I will have to screen for nils in all of the down-stream code."</comment><return>   ^viewPoint.</return></pre><pre><b>origin: pointOrigin extent: pointExtent  </b><comment>   "What is my origin and extent in container coordinates and pixel metrics?"</comment><comment>   "As a practival matter, viewports dimensions need to be in the hundreds."   </comment></pre><pre><b>resolutionAt: aDistance</b><comment>   "What is the resolution per pixel at given distance"</comment><return>   ^resolution.</return></pre><pre><b>scale</b><return>   ^scale ifNil: [ Error signal: 'This viewport`s scale has not been set yet.' ].</return></pre><pre><b>scale: measureNumerator per: measureDenominator </b><comment>   "Multiply camera screen coordinates by scale to get my coordinates."</comment><comment>   "Expect the numerator to be pixels </comment></pre><hr/><h3>Hum-X -- HApplication</h3><pre><b>handleRequest: aZnRequest </b><comment>   "Return a response for given request"</comment><return>   ^response.</return></pre><pre><b>handler: aBlockClosure </b><comment>   "Use the block to handle request"</comment></pre><hr/><h3>Hum-X -- HBaseTests</h3><pre><b>test240WorldBaseBacksBlackBoard</b><comment>   "Blackboard calls on World Base to persist events, state-changes."</comment><comment>   "Put first name, last name"</comment></pre><hr/><h3>Hum-X -- HBase</h3><pre><b>entities</b><comment>   "Dictionary of (id -&gt; entity)"</comment><return>   ^ entities ifNil: [ entities := Dictionary new ].</return></pre><pre><b>events</b><return>   ^events ifNil: [ events := Dictionary new ].</return></pre><pre><b>putEntity: anEntity attribute: anAttribute value: aValue event: anEvent </b><comment>   "Record entity attribute value"</comment></pre><pre><b>putEvent: anEvent </b><comment>   "Record the given event in my store."</comment></pre><hr/><h3>Hum-X -- HBlackboardTests</h3><pre><b>test140BlackboardSaveFetch</b><comment>   "A blackboard records events, noun values"</comment><comment>   "Put first name"</comment><comment>   "Put last name"</comment><comment>   "First name is still there"</comment><r>***24 lines of code ***</r></pre><pre><b>test145BlackboardSaveFetchNouns</b><comment>   "A blackboard records events, noun values"</comment><comment>   "Put first name"</comment><comment>   "Put last name"</comment><comment>   "First name is still there"</comment><r>***26 lines of code ***</r></pre><pre><b>test150BlackboardSaveFetchUpdate</b><comment>   "A blackboard records events, noun values"</comment><comment>   "Put first name"</comment><comment>   "Put last name"</comment><comment>   "First name is still there"</comment><comment>   "==========="</comment><comment>   "Put first name"</comment><comment>   "Put last name"</comment><comment>   "First name is still there"</comment><r>***45 lines of code ***</r></pre><pre><b>test160BlackboardToStream</b><comment>   "A blackboard records events, noun values"</comment><comment>   "Put first name"</comment><r>***23 lines of code ***</r></pre><hr/><h3>Hum-X -- HBlackboard</h3><pre><b>asStream</b><comment>   "Show the values in the blackboard on a stream."</comment><return>   ^stream.</return></pre><pre><b>events</b><return>   ^ events ifNil: [ events := OrderedCollection new.]</return></pre><pre><b>getEntity: anEntity attribute: anAttribute </b><return>   ^result.</return></pre><pre><b>getEntityNamed: aNoun </b><return>   ^ entity.</return></pre><pre><b>getNoun: aNoun </b><return>   ^value.</return></pre><pre><b>nouns</b><return>   ^ nouns ifNil: [ nouns := Dictionary new ].</return></pre><pre><b>putEntity: anEntity attribute: anAttribute value: aValue event: anEvent </b></pre><pre><b>putEntityNamed: aNoun </b><return>   ^entity.</return></pre><pre><b>putEvent: anEvent </b></pre><pre><b>worldBase: aWorldBase </b><comment>   "MOCK: Pretend we are persisting values on world base.</comment><comment>   "</comment></pre><hr/><h3>Hum-X -- HClientServerTests</h3><pre><b>setUp</b></pre><pre><b>tearDown</b></pre><pre><b>test110CharacterizeZnHttpClient</b><comment>   "Characterize ZnHttpClient"</comment><comment>   "At this point the client has nothing much going on." </comment></pre><pre><b>test112CharacterizeZnHttpClientNotFound</b><comment>   "Characterize ZnHttpClient"</comment><comment>   "At this point the client has nothing much going on." </comment><r>***47 lines of code ***</r></pre><pre><b>test114CharacterizeZnHttpConnected</b><comment>   "Characterize ZnHttpClient"</comment><comment>   "At this point the client has nothing much going on." </comment><comment>   "Happens to be there even though I try to shut it down."</comment><r>***48 lines of code ***</r></pre><pre><b>test115CharacterizeZnHttpHead</b><comment>   "Characterize ZnHttpClient"</comment><comment>   "At this point the client has nothing much going on." </comment><r>***46 lines of code ***</r></pre><pre><b>test116CharacterizeZnHttpConnectExternal</b><comment>   "Characterize ZnHttpClient"</comment><return>         ^self].</return><comment>   "At this point the client has nothing much going on." </comment><comment>   "Happens to be there even though I try to shut it down."</comment><r>***52 lines of code ***</r></pre><pre><b>test120CharacterizeZnHTTPSocketFacade</b><comment>   "Characterize ZnHttpClient"</comment><comment>   "ZnHTTPSocketFacade is stateless. </comment></pre><pre><b>test190CharacterizeHClient</b><comment>   "HClient is light wrapper on ZnHTTPSocketFacade."</comment><comment>   "At this point the client has nothing much going on." </comment><comment>   "That`s all folks!"</comment></pre><pre><b>test210CharacterizeZnServer</b></pre><pre><b>test211CharacterizeZnServer</b></pre><pre><b>test212CharacterizeZnHTTPSocketFacadeNotFound</b><comment>   "Characterize ZnHttpClient"</comment></pre><pre><b>test212CharacterizeZnServer</b></pre><pre><b>test214CharacterizeZnHTTPSocketFacadeConnected</b><comment>   "Characterize ZnHttpClient"</comment></pre><pre><b>test216CharacterizeZnHTTPSocketFacadePost</b><comment>   "Characterize ZnHttpClient"</comment></pre><pre><b>test220CharacterizeZnServerGetResponse</b><comment>   "client := ZnHttpClient new."</comment><r>***30 lines of code ***</r></pre><pre><b>test221CharacterizeZnServerPutResponse</b><comment>   "client := ZnHttpClient new."</comment><r>***30 lines of code ***</r></pre><pre><b>test222CharacterizeZnServerPostResponse</b><comment>   "client := ZnHttpClient new."</comment><r>***30 lines of code ***</r></pre><pre><b>test223CharacterizeZnServerDeleteResponse</b><comment>   "client := ZnHttpClient new."</comment><r>***30 lines of code ***</r></pre><pre><b>test224CharacterizeZnServerHeadResponse</b><r>***27 lines of code ***</r></pre><pre><b>test226CharacterizeZnHTTPSocketFacadePost</b><comment>   "Characterize ZnHttpClient"</comment><r>***30 lines of code ***</r></pre><pre><b>test310CharacterizeZnRequest</b><comment>   ""</comment><r>***22 lines of code ***</r></pre><pre><b>test324CharacterizeZnServerGetResponse</b><comment>   "Use Case: (Single Threaded) Server with HApplication responds to client GET request."</comment><r>***32 lines of code ***</r></pre><pre><b>test325CharacterizeZnServerGetResponse</b><comment>   "Use Case: (Multi-Threaded) Server with HApplication responds to client GET request."</comment><r>***32 lines of code ***</r></pre><pre><b>test326CharacterizeZnServerGetResponse</b><comment>   "Use Case: (Multi-Threaded) Server with HApplication responds to HClient GET request."</comment><r>***32 lines of code ***</r></pre><hr/><h3>Hum-X -- HClient</h3><pre><b>clientSettings</b><return>   ^ super settings settings.</return></pre><hr/><h3>Hum-X -- HEntityTests</h3><pre><b>test110EntityHasAttributes</b><comment>   "An entity has one or more attributes"</comment><comment>   "Put first name"</comment><comment>   "Put last name"</comment><comment>   "First name is still there"</comment></pre><pre><b>test120SetAttributeValueInEvent</b><comment>   "An entity has one or more attributes"</comment><comment>   "Put first name"</comment><comment>   "Put last name"</comment><comment>   "First name is still there"</comment><r>***22 lines of code ***</r></pre><pre><b>test125EntityPrintOn</b><comment>   "An entity has one or more attributes"</comment><comment>   "Put first name"</comment><r>***21 lines of code ***</r></pre><pre><b>test130UpdateAttributeValueInEvent</b><comment>   "An entity has one or more attributes"</comment><comment>   "Put first name"</comment><comment>   "Put last name"</comment><comment>   "First name is still there"</comment><comment>   "============"</comment><comment>   "Put first name"</comment><comment>   "Put last name"</comment><comment>   "First name is still there"</comment><r>***41 lines of code ***</r></pre><hr/><h3>Hum-X -- HEntity</h3><pre><b>attribute: anAttributeName value: anAttributeValue </b><comment>   "Initialize entity-attribute value. (No event, no history)</comment><comment>   "</comment></pre><pre><b>attribute: anAttributeType value: aValue event: anEvent </b><comment>   "Record a state-change associated with the given event."</comment></pre><pre><b>attributes</b><comment>   "Return my dictionary of current attribute values."</comment><return>   ^ attributes ifNil: [ attributes := Dictionary new ].</return></pre><pre><b>getAttribute: anAttributeName </b><comment>   "What is the value of the given attribute?"</comment><return>   ^result.</return></pre><pre><b>history</b><comment>   "Return history of state-changes."</comment><return>   ^ history ifNil: [ history := OrderedCollection new].</return></pre><pre><b>id</b><return>   ^ id</return></pre><pre><b>id: aLargePositiveInteger </b><comment>   "Set unique identifier.</comment></pre><pre><b>printOn: aStream</b><comment>   "Format my data for easy reading. </comment><comment>   "</comment><comment>   "Put my name/title on the stream"</comment><comment>   "Append indented list of my attribute values to stream."</comment><todo>            "TODO: Handle attributes that refer to other entities."</todo></pre><pre><b>title</b><comment>   "Entity should be given a contextually unique name (noun)"</comment><return>   ^ title ifNil: [ Error signal: 'unknown entity'].</return></pre><pre><b>title: aString </b><comment>   "Set my title - something appropriate to usage and unique within the context.</comment><comment>   "</comment></pre><hr/><h3>Hum-X -- HEvent</h3><pre><b>&gt; otherEvent </b><return>   ^result.</return></pre><pre><b>attributes</b></pre><pre><b>id: aLargePositiveInteger </b></pre><pre><b>what: aWhat </b><comment>   "What happened? (Relate to business process event.)"</comment></pre><pre><b>when</b><return>   ^ when</return></pre><pre><b>when: aTimeStamp </b><comment>   "When did the event occur? Real clock or simulated clock"</comment></pre><pre><b>where: aWhere </b><comment>   "Where did event occur? - Test/Simulation/Host/Application/Service"</comment></pre><pre><b>who: aWho </b><comment>   "Who caused the event? - User/Robot/Actor/Test"</comment></pre><pre><b>why: aWhy </b><comment>   "Why did the event occur? - Authorization/JobTicket"</comment></pre><hr/><h3>Hum-X -- HGlamourTest</h3><pre><b>test100ReadMe</b><comment>   "This group of tests follows 'Deep into Pharo - chapter 10' "</comment></pre><pre><b>test110Page192</b><comment>   "Example at page 192"</comment></pre><pre><b>test110Page193a</b><comment>   "Example at page 193"</comment></pre><pre><b>test110Page193b</b><comment>   "Example at page 193"</comment></pre><pre><b>test110Page194</b><comment>   "Example at page 194"</comment><r>***23 lines of code ***</r></pre><hr/><h3>Hum-X -- HTimeTests</h3><pre><b>test110timestampIsBigInteger</b><comment>   ""</comment></pre><pre><b>test120timestampIsUnique</b><comment>   ""</comment><comment>   "n = 1e4 resembles a database transaction rate.</comment></pre>