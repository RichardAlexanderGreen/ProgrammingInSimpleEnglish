Object subclass: #HumCodeStream	instanceVariableNames: 'stream limit'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-IDE'!!HumCodeStream commentStamp: 'RichardAlexanderGreen 4/14/2014 08:15' prior: 0!HumCodeStream is a wrapper on a ReadWriteStream. It adds a limit to catch looping code generator logic.Instance Variables:	stream	<Stream>	limit	<Integer>!!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/15/2014 13:13'!<< aString 	self assert: (aString isKindOf: String).	(self stream) << aString.	! !!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2014 20:41'!asString	^self printString.! !!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2014 13:06'!contents	^(self stream) contents.! !!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2014 13:03'!limit	"At what point do we assume code generation has run amock?"	^ limit ifNil: [ limit := 200 ].! !!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2014 13:05'!limit: aSmallInteger 	limit := aSmallInteger! !!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2014 14:09'!printString	^(self stream) contents.! !!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2014 13:02'!stream	stream ifNil: [ stream := ReadWriteStream on: ''].	((stream contents) size > (self limit))		ifTrue: [Error signal: 'Code stream limit exceeded.'].	^stream.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumCodeStream class	instanceVariableNames: ''!!HumCodeStream class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/9/2014 12:58'!on: aString 	| instance |	instance := self basicNew.	instance << aString.	^instance.! !!HumCodeStream class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/9/2014 13:05'!limit: aSmallInteger 	| instance |	instance := self basicNew.	instance limit: aSmallInteger.	^instance.! !Object subclass: #HumFrameUpdater	instanceVariableNames: 'frame lines ontology'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-IDE'!!HumFrameUpdater commentStamp: 'RichardAlexanderGreen 9/28/2012 14:15' prior: 0!The frame editor is a component of the IDE -- of the programmers assistant.It is a mediator between a specific UI and an ontology frame object.It implements actions on the frame without implementing the UI.(It might be less confusing to call the frame editor a frame updater -- TBD ).Instance Variables:	frame	<HumFrame>	lines	<OrderedCollection>	ontology	<ProtoObject | PseudoContext>!!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/9/2012 14:24'!addDictionaryLine: aSourceString 	self frame addDictionaryLine: aSourceString.! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 18:04'!addInstructionRole: aRole statement: aStatement 	self frame addInstructionRole: aRole statement: aStatement.! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/6/2012 15:38'!addInstructionStatement: aStatement 	|  |	self frame addInstructionStatement: aStatement.! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/15/2012 10:58'!addMarkUp: aSourceString 	self frame addMarkUp: ( ( HumMarkupLine new ) source:  aSourceString) .! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/22/2014 16:56'!addPrecondition: aPreconditionStatement 	self assert: ( self frame isKindOf: HumFrame4Plan ).	self frame addPrecondition: aPreconditionStatement .! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/23/2013 11:08'!addRole: aRole action: aStatement 	"Pass through to frame."	self frame addInstructionRole: aRole statement: aStatement.! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/16/2012 11:50'!addVignetteInstruction: anInstructionLine 	( self frame ) addVignetteInstruction: anInstructionLine. ! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/16/2012 11:46'!addVignetteResponse: aResponseString 	(self frame) addVignetteResponse: aResponseString.! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 13:40'!frame	"If frame is not initialized before this call, we have a logic error."	^frame ifNil: [ Error signal: 'frame has not bee initialized in FrameEditor instance.'].! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 13:39'!frame: aFrame 	"What frame am I editing ?"	frame := aFrame! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/2/2012 17:03'!getInstructionAt: aSmallInteger 	^self lines at: aSmallInteger .! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/2/2012 16:43'!lines	^ lines ifNil: [ lines := OrderedCollection new. ].! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/16/2012 13:41'!nextVignetteContext: aContextName 	(self frame) nextVignetteContext: aContextName. ! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/11/2012 13:18'!ontology	^ (self frame ontology) ifNil: [ Error signal: 'FrameEditor instance must have an ontology.']! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/2/2012 17:18'!ontology: aHumOntology 	ontology := aHumOntology.! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/15/2012 10:56'!ontology: aHumOntology dictionaryTitle: aTitleString 	frame := HumFrame4Dictionary new. 	self frame ontology: aHumOntology;		               titleLine: aTitleString.! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/2/2012 16:46'!putInstruction: aHumInstruction at: aSmallInteger 	| myLines |	myLines :=  (self lines).	( myLines isEmpty) 		ifFalse: [ myLines  at: aSmallInteger put: aHumInstruction .]		ifTrue: [ myLines add: aHumInstruction ].		! !!HumFrameUpdater methodsFor: 'updating' stamp: 'RichardAlexanderGreen 1/6/2012 15:24'!addInstructionRole: aRole statement: aStatement comment: aComment 	self frame addInstructionRole: aRole statement: aStatement comment: aComment .! !!HumFrameUpdater methodsFor: 'updating' stamp: 'RichardAlexanderGreen 1/15/2012 10:01'!storeFrameInOntology	"Store my frame in my ontology"	| |	"The frame must have a title."	self assert: ( frame titleLine notNil ).	(self ontology) storeFrame: frame.! !!HumFrameUpdater methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 1/11/2012 13:23'!checkFrameSyntax	| errors |	errors := self frame checkSyntaxWithOntology: self ontology.	^errors.! !!HumFrameUpdater methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 8/22/2013 15:25'!compileToOntology: aHumOntology 	"Delegate to the frame."	| errors |	errors := self frame compileToOntology: aHumOntology.	^errors.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrameUpdater class	instanceVariableNames: ''!!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 7/18/2013 15:11'!ontology: aHumOntology dictionaryTitle: aTitleString 	| frameEditor |	frameEditor := HumFrameUpdater new.	frameEditor ontology: aHumOntology dictionaryTitle: aTitleString.	^frameEditor ! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 9/15/2012 10:56'!ontology: aHumOntology goal: goalStatement 	| frameEditor |	frameEditor := self new.	frameEditor frame:( HumFrame4Plan ontology: aHumOntology goal: goalStatement).	^frameEditor.! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 1/15/2012 09:20'!ontology: aHumOntology loadFrameByIdentifier: aPrimaryKey 		| frameEditor |	frameEditor := self new.	frameEditor ontology: aHumOntology.	frameEditor frame: ( aHumOntology fetchFrameByIdentifier:  aPrimaryKey ).	^frameEditor.! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 7/18/2013 15:11'!ontology: aHumOntology loadFrameByName: aString 	| frame frameEditor |	frame := aHumOntology fetchFrameByName: aString.	frameEditor :=  HumFrameUpdater new.	frameEditor ontology: aHumOntology; 	                          frame: frame.	^ frameEditor! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 9/15/2012 10:55'!ontology: aHumOntology role: aRole action: anActionStatement 	| frameEditor |	frameEditor := self new.	frameEditor frame: ( HumFrame4Action ontology: aHumOntology role: aRole action: anActionStatement ).	^frameEditor.	! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 9/15/2012 10:56'!ontology: aHumOntology viewEntity: anEntity 	| frameEditor |	frameEditor := self new.	frameEditor frame: (  HumFrame4View ontology: aHumOntology viewEntity: anEntity ).	^frameEditor.		! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 9/15/2012 10:56'!ontology: aHumOntology vignetteContext: aContextString pattern: aPatternString 	| frame  frameEditor |	frame := HumFrame4Vignette ontology: aHumOntology vignetteContext: aContextString pattern: aPatternString.	frameEditor := self new.	frameEditor ontology: aHumOntology; frame: frame.	^frameEditor. ! !!HumFrameUpdater class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2012 10:31'!ontology: aHumOntology fetchFrameByName: aString 	| frame frameEditor |	frame := aHumOntology fetchFrameByName: aString.	frameEditor := self new.	frameEditor ontology: aHumOntology; frame: frame.	^ frameEditor.! !Object subclass: #HumProgrammersAssistant	instanceVariableNames: 'ontology'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-IDE'!!HumProgrammersAssistant commentStamp: 'RichardAlexanderGreen 1/22/2014 16:12' prior: 0!The Programmer`s Assistant (PA) provides the Interactive Development Environment (IDE) for Hum.While Smalltalk maintains source code in the image file, Hum maintains code in an ontology file.Each type of frame expects a notation meant to be used in that type of frame.See the class category 'Hum-Language' and the on-line manual for more detail.The Assistant is a user interface (a UI model actually) constructed as a set of views on the ontology.The ontology is the model.A Frame Editor is a viewer and a controller that may modify the ontologies frames.Diagrams provide a views of the ontology`s structure (relationships between various elements).Diagrams are read-only, but they may support mouse (hand) actions such as mouse-over and click.The plan diagram shows the precedence relationships implied by the plan frames.The noun diagram shows the structure of the dictionary with attributes and supertype relations as connectors.The dialog context diagram shows the connections between dialog vignette contexts.The delegation diagram shows the dependencies between roles.The programmers assistant provides an intermediary between a UI implementation and the ontology object.The programmers assistant is the model of the IDE.The UI interacts with the programmers assistant to provide a specific implementation.See Hum-Seaside class category.See: HumSeasideProgrammersAssistantTests.   !!HumProgrammersAssistant methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/2/2012 13:58'!clearOntology	ontology := HumOntology new.! !!HumProgrammersAssistant methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/2/2012 14:26'!loadOntologyFromFileNamed: aFileName 	"Load my ontology from the given file."	"Note: This method  does not provide any kind of versioning."	| referenceStream |		"Open the file."	referenceStream := ReferenceStream fileNamed: aFileName.	"Write the various data structures to the file."	ontology := referenceStream next.	referenceStream close.	! !!HumProgrammersAssistant methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/2/2012 13:59'!ontology	"Return the ontolgy. If nil initialize one."	^ ontology ifNil: [ ontology := HumOntology new. ].! !!HumProgrammersAssistant methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/12/2012 11:34'!saveOntologyOnFileNamed: aFileName 	"Save my ontology on the given file."	"Note: This method  does not provide any kind of versioning."	"If we save ontology in a WorldBase instead, 	  the WorldBase can provide versioning."	| referenceStream |		"Open the file for write -- clear it if necessary."	referenceStream := ReferenceStream fileNamed: aFileName.	"Write the various data structures to the file."	referenceStream nextPut: ontology.	referenceStream close.	! !!HumProgrammersAssistant methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/5/2014 16:20'!getCommentFromSource: aSourceString 	"Match '(...)' if any, and extract it from source."	| comment  |	comment := HumCalculator substringFrom: aSourceString includingMatching: '()'. 	^comment.! !!HumProgrammersAssistant methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/30/2014 10:57'!getLabelFromSource: aSourceString	"Match 'word:' at the front of the string.	Note: word may be hyphenated. "	| label tokenTypePairs |	tokenTypePairs := self parseSource: aSourceString keywords: {}.	"If the second token is a colon, the first token is a label."	((( tokenTypePairs at: 2 ) key) = ':')		ifTrue: [ label := (( tokenTypePairs at: 1 ) key )]		ifFalse: [ label := nil].	^label.! !!HumProgrammersAssistant methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/30/2014 10:54'!parseSource: source keywords: keywords	"Parse the source -- Return a list of token-type pairs: ( token -> tokenType ).	TODO: Fix this up so that it returns comment and annotation as types."	| whitespace punctuation quote tokens tokenTypePairs tokenType i |	whitespace := String space, String tab, String crlf.	quote := $' asString.	punctuation := '~!!@#$%^&*()_+`={}|[]\:";<>?,./', quote.	"Note: Preserve uppercase in tokens so that first word of a sentence is capitalized."	tokens := source  findTokens: ( punctuation, whitespace ) keep: punctuation.	tokenTypePairs := OrderedCollection new.	"QUESTION: Is the role-label part of the statement? 	(I think it is part of an instruction, but the statement is separated.)"	i := 1.	[ i <= tokens size ]			whileTrue: [ 			| token |			token := tokens at: i.			tokenType := #word.			"( self isNoun: token ) ifTrue: [ tokenType := #noun ]."			( keywords include: token ) ifTrue: [ tokenType := #keyword ].			( punctuation includes: (token at: 1) ) 				ifTrue: [ tokenType := #punctuation. "Until proven otherwise."					"Does the source have a comment?"					(((token at: 1) = '(') and: ['*(*)*' matches: (source source) ] )						ifTrue: [ "Advance index to closing parend"							| commentString |							commentString := '('.							[ i <= (tokens size) and:[( token at: 1) =')']] 								whileFalse: [ i := i+1. token := tokens at: i. commentString := commentString, ' ', token. ].								token := commentString.								tokenType := #comment.								]. 					"Does the source have annotation?"					(((token at: 1) = '[') and: ['*[*]*' matches: (source source) ] )						ifTrue: [ "Advance index to closing parend"							| annotationString |							annotationString := '['.							[ i <= (tokens size) and: [( token at: 1) =']']] 								whileFalse: [ i := i+1. token := tokens at: i. annotationString := annotationString, ' ', token. ].								token := annotationString.								tokenType := #annotation.								]. 					].			tokenTypePairs add: ( token -> tokenType ).			i := i + 1.			].	^ tokenTypePairs.! !!HumProgrammersAssistant methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/30/2014 11:05'!removeLabelFromSource: aSourceString 	"If there is a label, remove it and return the remainder."	| label remainder calc|	label :=  self getLabelFromSource: aSourceString.	(label isNil)		ifTrue: [remainder := aSourceString ]		ifFalse: [ "Return the remainder after first colon"			calc := HumCalculator new.			remainder := (calc given: aSourceString extractAfter: ':') trimBoth. 			].	^remainder.! !!HumProgrammersAssistant methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 2/5/2014 16:28'!removeCommentFromSource: aSourceString 	| remainderBefore remainderAfter comment |	comment := self getCommentFromSource: aSourceString.	remainderBefore := HumCalculator substringFrom: aSourceString before: comment.	remainderAfter := HumCalculator substringFrom: aSourceString after: comment.	^(remainderBefore,remainderAfter) trimBoth.! !