Object subclass: #HumCodeStream	instanceVariableNames: 'stream limit'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-IDE'!!HumCodeStream commentStamp: 'RichardAlexanderGreen 4/14/2014 08:15' prior: 0!HumCodeStream is a wrapper on a ReadWriteStream. It adds a limit to catch looping code generator logic.Instance Variables:	stream	<Stream>	limit	<Integer>!!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/15/2014 13:13'!<< aString 	self assert: (aString isKindOf: String).	(self stream) << aString.	! !!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2014 20:41'!asString	^self printString.! !!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2014 13:06'!contents	^(self stream) contents.! !!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2014 13:03'!limit	"At what point do we assume code generation has run amock?"	^ limit ifNil: [ limit := 200 ].! !!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2014 13:05'!limit: aSmallInteger 	limit := aSmallInteger! !!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2014 14:09'!printString	^(self stream) contents.! !!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2014 13:02'!stream	stream ifNil: [ stream := ReadWriteStream on: ''].	((stream contents) size > (self limit))		ifTrue: [Error signal: 'Code stream limit exceeded.'].	^stream.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumCodeStream class	instanceVariableNames: ''!!HumCodeStream class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/9/2014 12:58'!on: aString 	| instance |	instance := self basicNew.	instance << aString.	^instance.! !!HumCodeStream class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/9/2014 13:05'!limit: aSmallInteger 	| instance |	instance := self basicNew.	instance limit: aSmallInteger.	^instance.! !Object subclass: #HumFrameUpdater	instanceVariableNames: 'frame ontology mode programmersAssistant currentRole vignetteMode vignetteContext'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-IDE'!!HumFrameUpdater commentStamp: 'RichardAlexanderGreen 10/8/2014 10:36' prior: 0!The frame updater is a component of the IDE -- of the Programmers Assistant.It is a mediator between a specific UI and an ontology frame object.It implements actions on the frame without implementing the UI.Instance Variables:	frame	<HumFrame>	lines	<OrderedCollection>	ontology	<ProtoObject | PseudoContext>!!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 12/14/2014 09:47'!addActionLine: aSourceString 	| source calc |	source := aSourceString.	calc := HumCalculator new.	calc cases;		when: [source beginsWith: 'Action:'] 		      then: [frame ifNotNil:[ self storeFrameInOntology ]. "Save prior frame, if any."			          "Start a new action frame. This action is in the role`s PUBLIC API."        
                 self frame: (HumFrame4Action ontology: ontology 			                                           role: currentRole 			                                          action: (calc given: source extractAfter: 'Action:')) ];		when: [source beginsWith: 'To:'] 		      then: [frame ifNotNil:[ self storeFrameInOntology ]. "Save prior frame, if any."			          "Start a new action frame. This action is in the role`s PRIVATE API."                         self frame: (HumFrame4Action ontology: ontology 			                                           role: currentRole 			                                          action: (calc given: source extractAfter: 'To:')) ];		otherwise: [self frame addFrameLine: (self parseInstruction: source)].			! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 6/12/2014 21:32'!addDictionaryLine: aSourceString 	self frame addDictionaryLine: (self stripLeaderFrom: aSourceString).! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 12/11/2014 10:02'!addFrameLine: aSourceString 	"Create appropriate frameLine type and append to frame."	| calc source |	self assert: (aSourceString isKindOf: String).	source := self stripLeaderFrom: aSourceString.	calc := HumCalculator new.	calc cases;		when: [self frame isKindOf: HumFrame4Plan] then: [ self addPlanLine: source ];		when: [self frame isKindOf: HumFrame4View] then: [ frame addMarkUp: source ];		when: [self frame isKindOf: HumFrame4Action] then: [ self addActionLine: source ];		when: [self frame isKindOf: HumFrame4Comment] then: [ frame addFrameLine: (HumCommentLine source: source) ];		when: [self frame isKindOf: HumFrame4Dictionary] then: [ frame addDictionaryLine: source ];		"For vignette lines, we want to preserve leading dot because it identifies instruction lines."		when: [self frame isKindOf: HumFrame4Vignette] then: [ self addVignetteLine: aSourceString ];		otherwise: [ Error signal: 'Unknown frame type.'].	! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 1/4/2012 18:04'!addInstructionRole: aRole statement: aStatement 	self frame addInstructionRole: aRole statement: aStatement.! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 1/6/2012 15:24'!addInstructionRole: aRole statement: aStatement comment: aComment 	self frame addInstructionRole: aRole statement: aStatement comment: aComment .! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 1/6/2012 15:38'!addInstructionStatement: aStatement 	|  |	self frame addInstructionStatement: aStatement.! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 9/15/2012 10:58'!addMarkUp: aSourceString 	self frame addMarkUp: ( ( HumMarkupLine new ) source:  aSourceString) .! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 12/11/2014 13:53'!addPlanLine: aSourceString 	"The kind of line is modal."	"Look for lines that reset the mode."	( (aSourceString asLowercase beginsWith: 'precondition')	  or: [aSourceString asLowercase beginsWith: 'pre:']	)		ifTrue: [mode := #preconditions.			frame addFrameLine: (HumFrameLine source: aSourceString).			^self.			].	( (aSourceString beginsWith: 'Action:') or: [aSourceString beginsWith: 'Actions:'])		ifTrue: [mode := #actions.			frame addFrameLine: (HumFrameLine source: aSourceString).			^self.			].	"Process the source line according to mode set by prior source line."		(mode = #preconditions)		ifTrue: [			self addPrecondition: aSourceString.			^self			].	(mode = #actions)		ifTrue: [ | aRole sourceMinusComment |			sourceMinusComment := self programmersAssistant removeCommentFromSource: aSourceString.			(sourceMinusComment sameAs: '') 				ifTrue: [frame addFrameLine: (HumCommentLine source: aSourceString).]				ifFalse: [					aRole := self programmersAssistant getLabelFromSource: aSourceString.					aRole ifNil: [Error signal: 'Plan actions must have roles.'].					self addRole: aRole action: (self programmersAssistant removeLabelFromSource: aSourceString).					].				^self.			].	(mode isNil)		ifTrue: [ "Default mode is preconditions -- Allows 'Preconditions:' label to be omitted in source file."			mode := #preconditions. 			self addPrecondition: aSourceString.			^self			].	Error signal: 'How did we fall through addPlanLine: ...?'.		 ! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 6/12/2014 21:31'!addPrecondition: aPreconditionStatement 	self assert: ( self frame isKindOf: HumFrame4Plan ).	self frame addPrecondition: (self stripLeaderFrom: aPreconditionStatement) .! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 7/23/2013 11:08'!addRole: aRole action: aStatement 	"Pass through to frame."	self frame addInstructionRole: aRole statement: aStatement.! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 1/2/2012 17:03'!getInstructionAt: aSmallInteger 	^self lines at: aSmallInteger .! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 12/14/2014 09:46'!parseInstruction: sourceWith 	|  resultLine source comment role stmt |	self assert: (sourceWith isKindOf: String).	resultLine := HumInstructionLine source: sourceWith.	source := self stripLeaderFrom: sourceWith.	comment := HumCalculator given: source extractIncludingMatching: '()'.	(comment isNil) 		ifFalse: [ | beforeComment afterComment |			beforeComment := HumCalculator given: source extractUpto: comment.			afterComment := HumCalculator given: source extractAfter: comment.			source := beforeComment, afterComment.			resultLine comment: comment.			].	"Allow blank lines for readability."	(source sameAs: ' ') ifTrue: [^resultLine].	"Identify pattern and parse accordingly."	role := HumProgrammersAssistant getLabelFromSource: source.	stmt := HumProgrammersAssistant removeLabelFromSource: source.	resultLine := HumInstructionLine role: role statement: stmt.	(comment isNil) ifFalse: [resultLine comment: comment].	^resultLine.! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 1/2/2012 16:46'!putInstruction: aHumInstruction at: aSmallInteger 	| myLines |	myLines :=  (self lines).	( myLines isEmpty) 		ifFalse: [ myLines  at: aSmallInteger put: aHumInstruction .]		ifTrue: [ myLines add: aHumInstruction ].		! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 12/29/2014 09:11'!stripLeaderFrom: aLine 	| stmt calc |	(aLine = '.') ifTrue: ["Assume blank instruction line." ^''].	stmt := aLine.	calc := HumCalculator new.	[stmt beginsWith: '. ']		whileTrue: [ stmt := calc given: stmt extractAfter: '. '].	^stmt! !!HumFrameUpdater methodsFor: 'ontology operations' stamp: 'RichardAlexanderGreen 1/11/2012 13:23'!checkFrameSyntax	| errors |	errors := self frame checkSyntaxWithOntology: self ontology.	^errors.! !!HumFrameUpdater methodsFor: 'ontology operations' stamp: 'RichardAlexanderGreen 8/22/2013 15:25'!compileToOntology: aHumOntology 	"Delegate to the frame."	| errors |	errors := self frame compileToOntology: aHumOntology.	^errors.! !!HumFrameUpdater methodsFor: 'ontology operations' stamp: 'RichardAlexanderGreen 1/15/2012 10:01'!storeFrameInOntology	"Store my frame in my ontology"	| |	"The frame must have a title."	self assert: ( frame titleLine notNil ).	(self ontology) storeFrame: frame.! !!HumFrameUpdater methodsFor: 'add vignette line' stamp: 'RichardAlexanderGreen 1/16/2012 11:50'!addVignetteInstruction: anInstructionLine 	( self frame ) addVignetteInstruction: anInstructionLine. ! !!HumFrameUpdater methodsFor: 'add vignette line' stamp: 'RichardAlexanderGreen 12/11/2014 12:01'!addVignetteLine: aSourceString 	| source calc |	source := aSourceString.	calc := HumCalculator new.	"DEBUG	(aSourceString endsWith: '].') 		ifTrue: [ 			Transcript cr; 				show: aSourceString; 				show: ' ';					show: vignetteMode;				show: ' ';				show: (frame patterns at: 1) asString.			].	"	calc cases;		when: [(source beginsWith: 'U:')				and: [self vignetteMode = #pattern]]			then: [frame addVignettePattern: (calc given: source extractAfter: 'U:')				];		when: [(source beginsWith: 'U:')				and: [self vignetteMode = #response]]			then: [| pattern |				"Store prior vignette frame and Start a new vignette frame."				frame patterns size > 0					ifTrue: ["Store prior vignette frame and Start a new vignette frame."						self storeFrameInOntology. ].				pattern := calc given: source extractAfter: 'U:'.				frame := HumFrame4Vignette						ontology: self ontology						vignetteContext: self vignetteContext						pattern: pattern.				self vignetteMode: #pattern.				frame addVignettePattern: pattern				];		when: [source beginsWith: 'S:']			then: ["Starting response."				self vignetteMode: #response.				frame addVignetteResponse: (calc given: source extractAfter: 'S:')				];		when: [source sameAs: '']			then: ["Ignore blank line."			];		when: [ source beginsWith: ' ' ]			then: ["Should be response line." 				frame addVignetteResponse: source.				];		when: [source beginsWith: '.']			then: ["Add instruction line."				frame addVignetteInstruction: (calc given: source extractAfter: '.')				];		otherwise: [Error signal: 'Vignette line type not recognized.']! !!HumFrameUpdater methodsFor: 'add vignette line' stamp: 'RichardAlexanderGreen 1/16/2012 11:46'!addVignetteResponse: aResponseString 	(self frame) addVignetteResponse: aResponseString.! !!HumFrameUpdater methodsFor: 'add vignette line' stamp: 'RichardAlexanderGreen 12/6/2014 09:13'!nextVignetteContext: aString 	frame nextVignetteContext: aString! !!HumFrameUpdater methodsFor: 'add vignette line' stamp: 'RichardAlexanderGreen 12/6/2014 09:43'!vignetteContext	| result |	result := frame vignetteContext.	^result.! !!HumFrameUpdater methodsFor: 'add vignette line' stamp: 'RichardAlexanderGreen 12/11/2014 10:24'!vignetteMode	"What mode is the vignette parser in?"	vignetteMode ifNil: [ vignetteMode := #pattern ].	self assert: ( vignetteMode = #pattern or: [ vignetteMode = #response ]).	^vignetteMode! !!HumFrameUpdater methodsFor: 'add vignette line' stamp: 'RichardAlexanderGreen 12/6/2014 09:25'!vignetteMode: newMode	"What mode is the vignette parser in?"	self assert: ( newMode = #pattern or: [ newMode = #response ]).	vignetteMode := newMode.! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 13:40'!frame	"If frame is not initialized before this call, we have a logic error."	^frame ifNil: [ Error signal: 'frame has not bee initialized in FrameEditor instance.'].! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 13:39'!frame: aFrame 	"What frame am I editing ?"	frame := aFrame! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/11/2014 12:42'!isEmpty	^ (frame isNil) or: [frame isEmpty].! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/11/2014 11:49'!lines	^ (self frame) lines.! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/11/2014 13:08'!ontology	^ (ontology) ifNil: [ Error signal: 'Frame Updater instance must have an ontology.']! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/2/2012 17:18'!ontology: aHumOntology 	ontology := aHumOntology.! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/11/2014 14:25'!programmersAssistant	^ programmersAssistant ifNil: [programmersAssistant := HumProgrammersAssistant new].! !!HumFrameUpdater methodsFor: 'printing' stamp: 'RichardAlexanderGreen 12/14/2014 10:44'!prettyPrint	"Pretty print the frame content (rendering as HTML)."	| html |	html := ontology view renderFrame: frame.	^html! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrameUpdater class	instanceVariableNames: ''!!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/11/2014 13:13'!ontology: aHumOntology dictionaryTitle: aTitleString 	| frameUpdater |	frameUpdater := self new.	frameUpdater ontology: aHumOntology.	frameUpdater frame:( (HumFrame4Dictionary new) ontology: aHumOntology; titleLine: aTitleString).		^frameUpdater ! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/11/2014 13:13'!ontology: aHumOntology goal: goalStatement 	| frameUpdater |	frameUpdater := self new.	frameUpdater ontology: aHumOntology.	frameUpdater frame:( HumFrame4Plan ontology: aHumOntology goal: goalStatement).	^frameUpdater.! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/11/2014 13:11'!ontology: aHumOntology loadFrameByIdentifier: aPrimaryKey 		| frameUpdater |	frameUpdater := self new.	frameUpdater ontology: aHumOntology.	frameUpdater frame: ( aHumOntology fetchFrameByIdentifier:  aPrimaryKey ).	^frameUpdater.! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/11/2014 13:14'!ontology: aHumOntology loadFrameByName: aString 	| frame frameUpdater |	frame := aHumOntology fetchFrameByName: aString.	frameUpdater :=  self new.	frameUpdater ontology: aHumOntology; 	                frame: frame.	^ frameUpdater! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/11/2014 13:11'!ontology: aHumOntology role: aRole action: anActionStatement 	| frameUpdater |	frameUpdater := self new.	frameUpdater ontology: aHumOntology.	frameUpdater frame: ( HumFrame4Action ontology: aHumOntology role: aRole action: anActionStatement ).	^frameUpdater.	! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/11/2014 13:14'!ontology: aHumOntology viewEntity: anEntity 	| frameUpdater |	frameUpdater := self new.	frameUpdater ontology: aHumOntology.	frameUpdater frame: (  HumFrame4View ontology: aHumOntology viewEntity: anEntity ).	^frameUpdater.		! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/11/2014 13:14'!ontology: aHumOntology vignetteContext: aContextString pattern: aPatternString 	| frame  frameUpdater |	frame := HumFrame4Vignette ontology: aHumOntology vignetteContext: aContextString pattern: aPatternString.	frameUpdater := self new.	frameUpdater ontology: aHumOntology; 	                frame: frame.	^frameUpdater. ! !!HumFrameUpdater class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/11/2014 13:13'!ontology: aHumOntology fetchFrameByName: aString 	| frame frameUpdater |	frame := aHumOntology fetchFrameByName: aString.	frameUpdater := self new.	frameUpdater ontology: aHumOntology; frame: frame.	^ frameUpdater.! !Object subclass: #HumProgrammersAssistant	instanceVariableNames: 'ontology currentRole frame'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-IDE'!!HumProgrammersAssistant commentStamp: 'RichardAlexanderGreen 1/22/2014 16:12' prior: 0!The Programmer`s Assistant (PA) provides the Interactive Development Environment (IDE) for Hum.While Smalltalk maintains source code in the image file, Hum maintains code in an ontology file.Each type of frame expects a notation meant to be used in that type of frame.See the class category 'Hum-Language' and the on-line manual for more detail.The Assistant is a user interface (a UI model actually) constructed as a set of views on the ontology.The ontology is the model.A Frame Editor is a viewer and a controller that may modify the ontologies frames.Diagrams provide a views of the ontology`s structure (relationships between various elements).Diagrams are read-only, but they may support mouse (hand) actions such as mouse-over and click.The plan diagram shows the precedence relationships implied by the plan frames.The noun diagram shows the structure of the dictionary with attributes and supertype relations as connectors.The dialog context diagram shows the connections between dialog vignette contexts.The delegation diagram shows the dependencies between roles.The programmers assistant provides an intermediary between a UI implementation and the ontology object.The programmers assistant is the model of the IDE.The UI interacts with the programmers assistant to provide a specific implementation.See Hum-Seaside class category.See: HumSeasideProgrammersAssistantTests.   !!HumProgrammersAssistant methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/2/2012 13:58'!clearOntology	ontology := HumOntology new.! !!HumProgrammersAssistant methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/2/2012 13:59'!ontology	"Return the ontolgy. If nil initialize one."	^ ontology ifNil: [ ontology := HumOntology new. ].! !!HumProgrammersAssistant methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/12/2014 16:26'!ontology: aHumOntology	ontology := aHumOntology! !!HumProgrammersAssistant methodsFor: 'file operations' stamp: 'RichardAlexanderGreen 12/29/2014 08:19'!loadOntologyFromFileNamed: aFileName 	"Load my ontology from the given ReferenceStream file.  	 See also: loadOntologyFromTextFileNamed: ..."	"Note: This method  does not provide any kind of versioning."	| referenceStream |		"Open the file."	referenceStream := ReferenceStream fileNamed: aFileName.	"Write the various data structures to the file."	ontology := referenceStream next.	referenceStream close.	^ontology.	! !!HumProgrammersAssistant methodsFor: 'file operations' stamp: 'RichardAlexanderGreen 12/29/2014 08:19'!loadOntologyFromTextFileNamed: fileName	| stream |	self ontology: (HumOntology new).	ontology file: fileName.	ontology title: fileName.	stream := MultiByteFileStream readOnlyFileNamed: fileName.	self loadOntologyFromTextStream: stream.	^ontology.	! !!HumProgrammersAssistant methodsFor: 'file operations' stamp: 'RichardAlexanderGreen 12/29/2014 08:29'!loadOntologyFromTextStream: aReadWriteStream 	"Discover frame type and store each frame in ontology."	| stream sourceLine frameUpdater  isActionSubFrameCase |	"Use ontology provided by caller or lazy initialization."	frameUpdater := (HumFrameUpdater new) ontology: (self ontology).	"Define a function to detect action subframe case."	sourceLine := String new. "This satisfies compiler that sourceLine is defined before lambda uses it."	isActionSubFrameCase := [(frameUpdater frame isKindOf: HumFrame4Action) 		                       and: [(sourceLine beginsWith: 'Action:') or: [sourceLine beginsWith: 'To:']]].	"Read frames from the stream."	stream := aReadWriteStream.	stream position: 0.  "<<< Does this belong here? Caller might want to position stream."	[(sourceLine := stream nextLine) notNil]		whileTrue: ["For each line in the stream:"			((sourceLine beginsWith: '===') or: [frameUpdater isEmpty or: [isActionSubFrameCase value]]) 				ifTrue: [ "Store prior frame, if any. Start new frame."					(frameUpdater isEmpty) ifFalse: [ frameUpdater storeFrameInOntology ].					"Get a fresh frameUpdater."					frameUpdater := (HumFrameUpdater new) ontology: ontology..					"Get the title line and discover what kind of frame comes next."					(sourceLine beginsWith: '===') ifTrue: [sourceLine := stream nextLine].					frameUpdater frame: (self makeFramePerTitleLine: sourceLine).					]				ifFalse: [frameUpdater addFrameLine: sourceLine]			].	"Clean-up unless frame is empty."		(frameUpdater isEmpty) ifFalse: [ frameUpdater storeFrameInOntology ].	^ontology.	! !!HumProgrammersAssistant methodsFor: 'file operations' stamp: 'RichardAlexanderGreen 6/11/2014 10:17'!saveOntologyOnFileNamed: aFileName 	"Save my ontology on the given ReferenceStream file."	"Note: This method  does not provide any kind of versioning."	"ToDo: If we save ontology in a WorldBase instead, 	       the WorldBase could provide versioning."	| referenceStream |		"Open the file for write -- clear it if necessary."	referenceStream := ReferenceStream fileNamed: aFileName.	"Write the various data structures to the file."	referenceStream nextPut: ontology.	referenceStream close.	! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 10/8/2014 10:08'!getAnnotationFromSource: aSourceString 	"Match '[...]' if any, and extract it from source."	| comment  |	comment := self class getAnnotationFromSource: aSourceString.	^comment.! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 6/13/2014 19:55'!getCommentFromSource: aSourceString 	"Match '(...)' if any, and extract it from source."	| comment  |	comment := self class getCommentFromSource: aSourceString.	^comment.! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 6/13/2014 19:55'!getLabelFromSource: aSourceString	"Match 'word:' at the front of the string.	Note: word may be hyphenated. "	| label |	label := self class getLabelFromSource: aSourceString.	^label.! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/11/2014 10:06'!makeFramePerTitleLine: source 	"The label on the title line indicates the kind of frame."	| label calc |	source ifNil: [^nil].	self assert: (source isKindOf: String).	label := self getLabelFromSource: source.	label ifNil: [^nil].	calc := HumCalculator new.	calc cases;		when: [(label sameAs: 'View') or: [label sameAs: 'Pane']] then: [ frame := (HumFrame4View new) titleLine: source ];		when: [label sameAs: 'Comment'] then: [ frame := (HumFrame4Comment new) titleLine: source ];		when: [label sameAs: 'Questions'] then: [ frame := (HumFrame4Comment new) titleLine: source ];	  when: [label sameAs: 'Dictionary'] then: [ frame := (HumFrame4Dictionary ontology: ontology title: source)];		when: [label sameAs: 'Goal'] 		      then: [ frame := HumFrame4Plan ontology: ontology 			                                       goal: (calc given: source extractAfter: (label,':') ) ];		when: [label sameAs: 'Role'] 		      then: [ currentRole := (calc given: source extractBetween: (label,':') and: '.') trimBoth. 			            frame := HumFrame4Action new. 			       		];		when: [(label sameAs: 'Action') and: [frame isKindOf:HumFrame4Action ]] 		      then: [ (frame isEmpty) ifFalse: [frame compileToOntology: ontology ].			            frame := HumFrame4Action ontology: ontology 			                                         role: currentRole			                                       action: (calc given: source extractAfter: (label,':')).			            frame addFrameLine: (HumFrameLine source: source).			          ];		when: [label sameAs: 'To'] 		      then: [ (frame isEmpty) ifFalse: [frame compileToOntology: ontology ].			            frame := HumFrame4Action ontology: ontology 			                                         role: currentRole			                                       action: (calc given: source extractAfter: (label,':')).			            frame addFrameLine: (HumFrameLine source: source).			          ];		when: [(label sameAs: 'Context') or: [label sameAs: 'Dialog']]		      then: [ frame := HumFrame4Vignette ontology: ontology 			                                vignetteContext: (calc given: source extractBetween: (label,':') and: '.') 			                                        pattern: nil ];	  otherwise: [Error signal: 'Fell thru cases in makeFramePerTitleLine.'].	^frame.! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 6/13/2014 19:57'!parseSource: source keywords: keywords	"Parse the source -- Return a list of token-type pairs: ( token -> tokenType ).	TODO: Fix this up so that it returns comment and annotation as types."	|tokenTypePairs |	tokenTypePairs := self class parseSource: source keywords: keywords.	^ tokenTypePairs.! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 10/8/2014 10:12'!removeAnnotationFromSource: aSourceString 	| cleanerSource |	cleanerSource := self class removeAnnotationFromSource: aSourceString.	^cleanerSource. ! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 6/13/2014 19:59'!removeCommentFromSource: aSourceString 	| cleanerSource |	cleanerSource := self class removeCommentFromSource: aSourceString.	^cleanerSource. ! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 6/13/2014 19:59'!removeLabelFromSource: aSourceString 	"If there is a label, remove it and return the remainder."	| remainder |	remainder := self class removeLabelFromSource: aSourceString.	^remainder.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumProgrammersAssistant class	instanceVariableNames: ''!!HumProgrammersAssistant class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/8/2014 10:08'!getAnnotationFromSource: aSourceString 	"Match '(...)' if any, and extract it from source."	| comment  |	comment := HumCalculator given: aSourceString extractIncludingMatching: '[]'. 	^comment.! !!HumProgrammersAssistant class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 6/13/2014 19:43'!getCommentFromSource: aSourceString 	"Match '(...)' if any, and extract it from source."	| comment  |	comment := HumCalculator given: aSourceString extractIncludingMatching: '()'. 	^comment.! !!HumProgrammersAssistant class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/15/2014 07:49'!getLabelFromSource: aSourceString	"Match 'word:' at the front of the string.	Note: word may be hyphenated. "	| label tokenTypePairs |	((aSourceString isNil) or: [aSourceString trimBoth = '']) ifTrue: [^nil].	tokenTypePairs := self parseSource: aSourceString keywords: {}.	((( tokenTypePairs at: 1 ) key) = '.')		ifTrue: [ tokenTypePairs removeFirst].	"If the second token is a colon, the first token is a label."	((( tokenTypePairs at: 2 ) key) = ':')		ifTrue: [ label := (( tokenTypePairs at: 1 ) key ).				"Do not mistake 'Else:' for a label."				(label asLowercase sameAs: 'else') ifTrue: [ label := nil. ].			]		ifFalse: [ label := nil ].	^label.! !!HumProgrammersAssistant class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 10/8/2014 10:34'!parseSource: source keywords: keywords	"Parse the source -- Return a list of token-type pairs: ( token -> tokenType ).	DONE: Fix this up so that it returns comment and annotation as types."	| whitespace punctuation quote tokens tokenTypePairs tokenType i |	whitespace := String space, String tab, String crlf.	quote := $' asString.	punctuation := '~!!@#$%^&*()_+`={}|[]\:";<>?,./', quote.	"Note: Preserve uppercase in tokens so that first word of a sentence is capitalized."	tokens := source  findTokens: ( punctuation, whitespace ) keep: punctuation.	tokenTypePairs := OrderedCollection new.	"QUESTION: Is the role-label part of the statement? 	(I think it is part of an instruction, but the statement is separated.)"	i := 1.	[ i <= tokens size ]			whileTrue: [ 			| token |			token := tokens at: i.			tokenType := #word.			"( self isNoun: token ) ifTrue: [ tokenType := #noun ]."			( keywords include: token ) ifTrue: [ tokenType := #keyword ].			( punctuation includes: (token at: 1) ) 				ifTrue: [ tokenType := #punctuation. "Until proven otherwise."					"Does the source have a comment?"					(((token at: 1) = '(') and: ['*(*)*' matches: (source source) ] )						ifTrue: [ "Advance index to closing parend"							| commentString |							commentString := '('.							[ i <= (tokens size) and:[( token at: 1) =')']] 								whileFalse: [ i := i+1. token := tokens at: i. commentString := commentString, ' ', token. ].								token := commentString.								tokenType := #comment.								]. 					"Does the source have annotation?"					(((token at: 1) = '[') and: ['*[*]*' matches: (source source) ] )						ifTrue: [ "Advance index to closing bracket"							| annotationString |							annotationString := '['.							[ i <= (tokens size) and: [( token at: 1) =']']] 								whileFalse: [ i := i+1. token := tokens at: i. annotationString := annotationString, ' ', token. ].								token := annotationString.								tokenType := #annotation.								]. 					].			tokenTypePairs add: ( token -> tokenType ).			i := i + 1.			].	^ tokenTypePairs.! !!HumProgrammersAssistant class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 10/8/2014 10:19'!removeAnnotationFromSource: aSourceString 	| remainderBefore remainderAfter annotation |	annotation := self getAnnotationFromSource: aSourceString.	annotation ifNil: [^aSourceString trimBoth].	remainderBefore := HumCalculator given: aSourceString extractUpto: annotation.	remainderAfter := HumCalculator given: aSourceString extractAfter: annotation.	^(remainderBefore,remainderAfter) trimBoth.! !!HumProgrammersAssistant class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 10/8/2014 10:24'!removeCommentFromSource: aSourceString 	| remainderBefore remainderAfter comment |	comment := self getCommentFromSource: aSourceString.	comment ifNil: [^aSourceString trimBoth].	remainderBefore := HumCalculator given: aSourceString extractUpto: comment.	remainderAfter := HumCalculator given: aSourceString extractAfter: comment.	^(remainderBefore,remainderAfter) trimBoth.! !!HumProgrammersAssistant class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 6/13/2014 19:45'!removeLabelFromSource: aSourceString 	"If there is a label, remove it and return the remainder."	| label remainder calc|	label :=  self getLabelFromSource: aSourceString.	(label isNil)		ifTrue: [remainder := aSourceString ]		ifFalse: [ "Return the remainder after first colon"			calc := HumCalculator new.			remainder := (calc given: aSourceString extractAfter: ':') trimBoth. 			].	^remainder.! !