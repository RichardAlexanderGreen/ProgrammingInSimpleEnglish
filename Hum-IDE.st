Object subclass: #HumCodeBase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-IDE'!!HumCodeBase commentStamp: 'RichardAlexanderGreen 7/29/2015 10:56' prior: 0!HumCodeBase provides a wrapper on SystemOrganizationand other Smalltalk introspection facilitiesto enable scanning of the Hum Smalltalk Packages.It is a singleton with all of its methods on the class side.!!HumCodeBase methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 7/25/2015 10:47'!everythingIsClassSide	"This is organized as a singleton - all the methods are on the class side."! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumCodeBase class	instanceVariableNames: 'myPackages'!!HumCodeBase class methodsFor: 'printing' stamp: 'RichardAlexanderGreen 8/5/2016 10:28'!listOnHTML2Lines	"Show the first two lines of each method."	| packageClassMethodSources sortedTuples  html lineCount priorString sayOnce |	html := ReadWriteStream on: String new.	html nextPutAll: (HumCalculator new xml: 'head' with: [ self css ] ).	html nextPutAll: '<body>'.	html nextPutAll: '<h1>Hum Code Base</h1>'.	packageClassMethodSources := self getPackageClassMethodCode.    sortedTuples := packageClassMethodSources 								sorted: [ :tupleA :tupleB | 									| keyA keyB |									keyA := (tupleA at: 1), (tupleA at: 2),(tupleA at: 3). 									keyB := (tupleB at: 1), (tupleB at: 2),(tupleB at: 3). 									keyA <= keyB.									].	priorString := ''.
    sayOnce := [ :string |  (string = priorString) ifFalse: [ html nextPutAll: string ]. priorString := string ].	sortedTuples		do: [ :packageClassMethodSource |			| packageName className methodName source stream  |			packageName := packageClassMethodSource at: 1.			className := packageClassMethodSource at: 2.			methodName := packageClassMethodSource at: 3.			source := packageClassMethodSource at: 4.			sayOnce value: String cr, '<h3>', packageName, ' -- ', className, '</h3>'.			html nextPutAll: (String cr,'<pre>').			stream := ReadStream on: source.			lineCount := 0.			stream position: 0.			[ ( stream atEnd not ) and: [ lineCount < 2 ] ]				whileTrue: [ 					|  aLine htmlLine | 					lineCount := lineCount + 1.					aLine := stream upTo: (Character cr).					( lineCount < 2 or: [ |s| s := aLine trimBoth,'!!'. '"^' includes: (s first) ]  )						ifTrue: [ 							htmlLine := aLine copyReplaceAll: (String tab) with: '   ' asTokens: false.							htmlLine := htmlLine copyReplaceAll: '<' with: '&lt;' asTokens: false.							htmlLine := htmlLine copyReplaceAll: '>' with: '&gt;' asTokens: false.                    		html nextPutAll: (String cr, htmlLine).							].					].			html nextPutAll: '</pre>'.			 ].	^ html.    ! !!HumCodeBase class methodsFor: 'printing' stamp: 'RichardAlexanderGreen 8/5/2016 10:29'!listOnHTML	| packageClassMethodSources sortedTuples  html |	html := ReadWriteStream on: String new.
	html nextPutAll: (HumCalculator new xml: 'head' with: [ self css ] ).
	html nextPutAll: '<body>'.
	html nextPutAll: '<h1>Hum Code Base</h1>'.	packageClassMethodSources := self getPackageClassMethodCode.    sortedTuples := packageClassMethodSources 								sorted: [ :tupleA :tupleB | 									| keyA keyB |									keyA := (tupleA at: 1), (tupleA at: 2),(tupleA at: 3). 									keyB := (tupleB at: 1), (tupleB at: 2),(tupleB at: 3). 									keyA <= keyB.									].	sortedTuples		do: [ :packageClassMethodSource |			| packageName className methodName source stream subtitle |			packageName := packageClassMethodSource at: 1.			className := packageClassMethodSource at: 2.			methodName := packageClassMethodSource at: 3.			source := packageClassMethodSource at: 4.			subtitle := String cr, '<h3>', packageName, ' -- ', className, ' &gt;&gt; ', methodName, '</h3>'.			html nextPutAll: subtitle.			html nextPutAll: (String cr,'<pre>').			stream := ReadStream on: source.			stream position: 0.			[ stream atEnd ] 				whileFalse: [ 					|  aLine htmlLine | 					aLine := stream upTo: (Character cr).					htmlLine := aLine copyReplaceAll: (String tab) with: '   ' asTokens: false.					htmlLine := htmlLine copyReplaceAll: '<' with: '&lt;' asTokens: false.					htmlLine := htmlLine copyReplaceAll: '>' with: '&gt;' asTokens: false.					html nextPutAll: (String cr, htmlLine).					].			html nextPutAll: '</pre>'.			 ].	^ html.    ! !!HumCodeBase class methodsFor: 'printing' stamp: 'RichardAlexanderGreen 8/29/2016 19:17'!listOnHTMLcomments	"Show the first two lines of each method."	| packageClassMethodSources sortedTuples  html lineCount priorString  oneTimeDict sayOneTime |	html := ReadWriteStream on: String new.	html nextPutAll: (HumCalculator new xml: 'head' with: [ self css ] ).	html nextPutAll: (String cr, '<body>').	html nextPutAll: '<h1>Hum Code Base</h1>'.	packageClassMethodSources := self getPackageClassMethodCode.    sortedTuples := packageClassMethodSources 								sorted: [ :tupleA :tupleB | 									| keyA keyB |									keyA := (tupleA at: 1), (tupleA at: 2),(tupleA at: 3). 									keyB := (tupleB at: 1), (tupleB at: 2),(tupleB at: 3). 									keyA <= keyB.									].	priorString := ''.
  oneTimeDict := Dictionary newFrom: { 'pkg'->''. 'class'->''. }.	sayOneTime := [ :topic :s | 									( s = (oneTimeDict at: topic) ) ifFalse: [html nextPutAll: s]. 									oneTimeDict at: topic put: s 									]. 	sortedTuples		do: [ :packageClassMethodSource |			| packageName className methodName source stream  |			packageName := packageClassMethodSource at: 1.			className := packageClassMethodSource at: 2.			methodName := packageClassMethodSource at: 3.			source := packageClassMethodSource at: 4.			sayOneTime value: 'pkg' value: (String cr,'<hr/><hr/>',String cr,'<h2>',packageName,'</h2>').			sayOneTime value: 'class' value: (String cr,'<hr/>',String cr,'<h3>',packageName,' -- ',className,'</h3>').			html nextPutAll: (String cr, '<pre>').			stream := ReadStream on: source.			lineCount := 0.			stream position: 0.			[ ( stream atEnd not )  ]				whileTrue: [ 					|  aLine htmlLine | 					lineCount := lineCount + 1.					aLine := stream upTo: (Character cr).					( lineCount < 2 or: [ |s| s := aLine trimBoth,'!!'. '"^' includes: (s first) ]  )						ifTrue: [ 							| ss calc |							htmlLine := aLine copyReplaceAll: (String tab) with: '   ' asTokens: false.							htmlLine := htmlLine copyReplaceAll: '<' with: '&lt;' asTokens: false.							htmlLine := htmlLine copyReplaceAll: '>' with: '&gt;' asTokens: false.							ss := htmlLine trimBoth asLowercase .							calc := HumCalculator new.							calc cases;								when: [ ss beginsWith: '"todo:'  ] then: [ html nextPutAll: (String cr, '<todo>',htmlLine,'</todo>' ) ];								when: [ ss beginsWith: '"'  ] then: [ html nextPutAll: (String cr, '<comment>',htmlLine,'</comment>' ) ];								when: [ ss beginsWith: '^'  ] then: [ html nextPutAll: (String cr, '<return>',htmlLine,'</return>' ) ];								when: [ lineCount = 1 ] then: [ html nextPutAll: (String cr, '<b>',htmlLine,'</b>') ];								otherwise: [ Error signal: 'How did we get here?'  ].							]. "ifTrue: "					]. "whileTrue:"				(lineCount > 20) ifTrue: [ html nextPutAll: (String cr, '<r>***', lineCount asString, ' lines of code ***</r>') ].				html nextPutAll: (String cr, '</pre>').		 ]. "sortedTuples do:"	^ html.       ! !!HumCodeBase class methodsFor: 'printing' stamp: 'RichardAlexanderGreen 8/8/2016 09:19'!css	| html |	html := HumCalculator new xml: 'style' with: '		body {font-family: MONOSPACE;}				method {   }		comment { color: DarkGreen; }		todo { color: Red; }		r { color: Red; }		return { color: Blue; }	'.	^html.! !!HumCodeBase class methodsFor: 'quality queries' stamp: 'RichardAlexanderGreen 4/4/2016 08:54'!findAssertLines	| packageClassMethodSources toDoLines calc |	toDoLines := OrderedCollection new.	packageClassMethodSources := self getPackageClassMethodCode.	calc := HumCalculator new.	packageClassMethodSources		do: [ :packageClassMethodSource |			| packageName className methodName source stream  |			packageName := packageClassMethodSource at: 1.			className := packageClassMethodSource at: 2.			methodName := packageClassMethodSource at: 3.			source := packageClassMethodSource at: 4.			stream := ReadStream on: source.			stream position: 0.			[ stream atEnd ] 				whileFalse: [ 					|  aLine | 					aLine := stream upTo: (Character cr).					calc cases;						when: [ '*self assert:*' match: aLine  ] 							then: [ toDoLines add: { packageName. className. methodName.  aLine. } ];						when: [ '*self expect:*actual:*' match: aLine  ] 							then: [ toDoLines add: { packageName. className. methodName.  aLine. } ];						when: [ '*self deny:*' match: aLine  ] 							then: [ toDoLines add: { packageName. className. methodName.  aLine. } ].					].			 ].		^ toDoLines.! !!HumCodeBase class methodsFor: 'quality queries' stamp: 'RichardAlexanderGreen 7/29/2015 10:31'!findCommentLines	| packageClassMethodSources commentLines |	commentLines := OrderedCollection new.	packageClassMethodSources := self getPackageClassMethodCode.	packageClassMethodSources		do: [ :packageClassMethodSource |			| packageName className methodName source stream  |			packageName := packageClassMethodSource at: 1.			className := packageClassMethodSource at: 2.			methodName := packageClassMethodSource at: 3.			source := packageClassMethodSource at: 4.			stream := ReadStream on: source.			stream position: 0.			[ stream atEnd ] 				whileFalse: [ 					|  aLine | 					aLine := stream upTo: (Character cr).					( '*"*"*' match: aLine ) ifTrue: [ commentLines add: { packageName. className. methodName.  aLine. } ].					].			 ].		^ commentLines.! !!HumCodeBase class methodsFor: 'quality queries' stamp: 'RichardAlexanderGreen 10/9/2015 11:14'!findMatch: aPattern	| packageClassMethodSources toDoLines |	toDoLines := OrderedCollection new.	packageClassMethodSources := self getPackageClassMethodCode.	packageClassMethodSources		do: [ :packageClassMethodSource |			| packageName className methodName source stream  |			packageName := packageClassMethodSource at: 1.			className := packageClassMethodSource at: 2.			methodName := packageClassMethodSource at: 3.			source := packageClassMethodSource at: 4.			stream := ReadStream on: source.			stream position: 0.			[ stream atEnd ] 				whileFalse: [ 					|  aLine | 					aLine := stream upTo: (Character cr).					( aPattern match: aLine ) ifTrue: [ toDoLines add: { packageName. className. methodName.  aLine. } ].					].			 ].		^ toDoLines.! !!HumCodeBase class methodsFor: 'quality queries' stamp: 'RichardAlexanderGreen 7/27/2015 10:54'!countLinesOfCode	| nLines packageClasses |	packageClasses := self getPackageClassTuples.	nLines := 0.	packageClasses		do: [ :packageClass |			| package class |			package := packageClass at: 1.			class := packageClass at: 2.			nLines := nLines + ( class linesOfCode ).			 ].	^ nLines.! !!HumCodeBase class methodsFor: 'quality queries' stamp: 'RichardAlexanderGreen 7/29/2015 10:23'!countTestModules	"Count the methods whose name begins with 'test'. "	| packageClassMethodTree nTestModules |	packageClassMethodTree := HumCodeBase getPackageClassMethodTuples.	nTestModules := ( packageClassMethodTree count: [ :tuple | (tuple at: 3) selector beginsWith: 'test' ] ).	^nTestModules! !!HumCodeBase class methodsFor: 'quality queries' stamp: 'RichardAlexanderGreen 8/8/2016 09:08'!countLongModules: lineLimit	"Count modules that contain more than (lineLimit) lines of code."	"Twenty lines is roughly the amount of code that can be viewed without scrolling."	| packageClassMethodSources nLongModules calc cr  |	nLongModules := 0.	cr := Character cr.	packageClassMethodSources := self getPackageClassMethodCode.	calc := HumCalculator new.	packageClassMethodSources		do: [ :packageClassMethodSource |			| packageName className methodName source   |			packageName := packageClassMethodSource at: 1.			className := packageClassMethodSource at: 2.			methodName := packageClassMethodSource at: 3.			source := packageClassMethodSource at: 4.			(( source count: [ :ch | ch =  cr ] ) > lineLimit) ifTrue: [ nLongModules := nLongModules + 1. ]			 ].	^ nLongModules.! !!HumCodeBase class methodsFor: 'quality queries' stamp: 'RichardAlexanderGreen 8/8/2016 09:08'!countLongModules	"Count modules that contain more than xx lines of code."	"Twenty lines is roughly the amount of code that can be viewed without scrolling."	|  nLongModules    |	nLongModules := self countLongModules: 20.	^ nLongModules.! !!HumCodeBase class methodsFor: 'quality queries' stamp: 'RichardAlexanderGreen 10/9/2015 11:15'!findToDoLines		| toDoLines |		toDoLines := self findMatch: '*TODO*'.		^ toDoLines.! !!HumCodeBase class methodsFor: 'package queries' stamp: 'RichardAlexanderGreen 7/27/2015 19:49'!getPackageClassTuples	| packageClassTree packageList classList |	packageClassTree := OrderedCollection new.		packageList := self myPackages.	self assert: (packageList includes: 'Hum-X').	classList := OrderedCollection new.	packageList 		do: [ :package |			classList := (self classesInPackage: package).			classList do: [ :class |				 packageClassTree add: { package. class. }.  "Note: class points to a class, not a string." 				].			].	^packageClassTree.! !!HumCodeBase class methodsFor: 'package queries' stamp: 'RichardAlexanderGreen 8/21/2015 08:43'!myPackages	"Collect packages in Hum implementation."	| |	^myPackages ifNil: [ myPackages := SystemOrganizer default categoriesMatching: 'Hum*'.].	! !!HumCodeBase class methodsFor: 'package queries' stamp: 'RichardAlexanderGreen 7/27/2015 19:36'!getPackageClassMethodCode	| packageClassMethods packageClassMethodSources |	packageClassMethodSources := OrderedCollection new.	packageClassMethods := self getPackageClassMethodTuples.	packageClassMethods		do: [  :packageClassMethod |			| tuple package class method source |				package := packageClassMethod at: 1.			class      := packageClassMethod at: 2.			method := packageClassMethod at: 3.			source := method sourceCode. 			tuple := { package. class name. method selector. source. }.			packageClassMethodSources add: tuple.			 ].	^packageClassMethodSources.! !!HumCodeBase class methodsFor: 'package queries' stamp: 'RichardAlexanderGreen 7/27/2015 19:36'!getPackageClassMethodTuples	| tuples packageClassTuples |	tuples := OrderedCollection new.	packageClassTuples := self getPackageClassTuples.	packageClassTuples		do: [ :packageClass | 			| packageName class methods |			packageName := packageClass at: 1.			class               := packageClass at: 2.			methods  := class methods.			methods				do: [ :method |					 tuples add: { packageName. class. method. }.						].			].	^tuples. ! !!HumCodeBase class methodsFor: 'package queries' stamp: 'RichardAlexanderGreen 7/25/2015 10:37'!classesInPackage: aPackageNameSymbol 	| myClasses |	myClasses := SystemOrganizer default classesInCategory: aPackageNameSymbol.	^myClasses.! !Object subclass: #HumCodeStream	instanceVariableNames: 'stream limit'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-IDE'!!HumCodeStream commentStamp: 'RichardAlexanderGreen 4/14/2014 08:15' prior: 0!HumCodeStream is a wrapper on a ReadWriteStream. It adds a limit to catch looping code generator logic.Instance Variables:	stream	<Stream>	limit	<Integer>!!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2014 13:03'!limit	"At what point do we assume code generation has run amock?"	^ limit ifNil: [ limit := 200 ].! !!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/15/2014 13:13'!<< aString 	self assert: (aString isKindOf: String).	(self stream) << aString.	! !!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2014 20:41'!asString	^self printString.! !!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2014 13:05'!limit: aSmallInteger 	limit := aSmallInteger! !!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2014 13:06'!contents	^(self stream) contents.! !!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2014 14:09'!printString	^(self stream) contents.! !!HumCodeStream methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2014 13:02'!stream	stream ifNil: [ stream := ReadWriteStream on: ''].	((stream contents) size > (self limit))		ifTrue: [Error signal: 'Code stream limit exceeded.'].	^stream.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumCodeStream class	instanceVariableNames: ''!!HumCodeStream class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/9/2014 13:05'!limit: aSmallInteger 	| instance |	instance := self basicNew.	instance limit: aSmallInteger.	^instance.! !!HumCodeStream class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/9/2014 12:58'!on: aString 	| instance |	instance := self basicNew.	instance << aString.	^instance.! !Object subclass: #HumFrameUpdater	instanceVariableNames: 'frame ontology mode programmersAssistant currentRole vignetteMode vignetteContext'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-IDE'!!HumFrameUpdater commentStamp: 'RichardAlexanderGreen 10/8/2014 10:36' prior: 0!The frame updater is a component of the IDE -- of the Programmers Assistant.It is a mediator between a specific UI and an ontology frame object.It implements actions on the frame without implementing the UI.Instance Variables:	frame	<HumFrame>	lines	<OrderedCollection>	ontology	<ProtoObject | PseudoContext>!!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 13:39'!frame: aFrame 	"What frame am I editing ?"	frame := aFrame! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/11/2014 13:08'!ontology	^ (ontology) ifNil: [ Error signal: 'Frame Updater instance must have an ontology.']! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/2/2012 17:18'!ontology: aHumOntology 	ontology := aHumOntology.! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/11/2014 14:25'!programmersAssistant	^ programmersAssistant ifNil: [programmersAssistant := HumProgrammersAssistant new].! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/11/2014 11:49'!lines	^ (self frame) lines.! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 13:40'!frame	"If frame is not initialized before this call, we have a logic error."	^frame ifNil: [ Error signal: 'frame has not bee initialized in FrameEditor instance.'].! !!HumFrameUpdater methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/11/2014 12:42'!isEmpty	^ (frame isNil) or: [frame isEmpty].! !!HumFrameUpdater methodsFor: 'ontology operations' stamp: 'RichardAlexanderGreen 1/11/2012 13:23'!checkFrameSyntax	| errors |	errors := self frame checkSyntaxWithOntology: self ontology.	^errors.! !!HumFrameUpdater methodsFor: 'ontology operations' stamp: 'RichardAlexanderGreen 1/15/2012 10:01'!storeFrameInOntology	"Store my frame in my ontology"	| |	"The frame must have a title."	self assert: ( frame titleLine notNil ).	(self ontology) storeFrame: frame.! !!HumFrameUpdater methodsFor: 'ontology operations' stamp: 'RichardAlexanderGreen 8/22/2013 15:25'!compileToOntology: aHumOntology 	"Delegate to the frame."	| errors |	errors := self frame compileToOntology: aHumOntology.	^errors.! !!HumFrameUpdater methodsFor: 'printing' stamp: 'RichardAlexanderGreen 7/25/2016 10:57'!prettyPrint	"Pretty print the frame content (rendering as HTML)."	| html |	html := ontology view renderFrame: frame withCritique: false withBase: false.	^html! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 5/20/2016 09:54'!addActionLine: aSourceString 	| source calc |	source := aSourceString.	calc := HumCalculator new.	calc cases;		when: [source beginsWith: 'Action:'] 		      then: [frame ifNotNil:[ self storeFrameInOntology ]. "Save prior frame, if any."			          "Start a new action frame. This action is in the role`s PUBLIC API."        
                 self frame: (HumFrame4Action ontology: ontology 			                                           role: currentRole 			                                          action: (calc given: source extractAfter: 'Action:')) ];		when: [source beginsWith: 'To:'] 		      then: [frame ifNotNil:[ self storeFrameInOntology ]. "Save prior frame, if any."			          "Start a new action frame. This action is in the role`s PRIVATE API."                         self frame: (HumFrame4Action ontology: ontology 			                                           role: currentRole 			                                          action: (calc given: source extractAfter: 'To:')) ];		otherwise: [ | instructionLine |								instructionLine := self parseInstruction: source.								self frame appendFrameLine: instructionLine.								self frame instructionLines add: instructionLine.].			! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 12/14/2014 09:46'!parseInstruction: sourceWith 	|  resultLine source comment role stmt |	self assert: (sourceWith isKindOf: String).	resultLine := HumInstructionLine source: sourceWith.	source := self stripLeaderFrom: sourceWith.	comment := HumCalculator given: source extractIncludingMatching: '()'.	(comment isNil) 		ifFalse: [ | beforeComment afterComment |			beforeComment := HumCalculator given: source extractUpto: comment.			afterComment := HumCalculator given: source extractAfter: comment.			source := beforeComment, afterComment.			resultLine comment: comment.			].	"Allow blank lines for readability."	(source sameAs: ' ') ifTrue: [^resultLine].	"Identify pattern and parse accordingly."	role := HumProgrammersAssistant getLabelFromSource: source.	stmt := HumProgrammersAssistant removeLabelFromSource: source.	resultLine := HumInstructionLine role: role statement: stmt.	(comment isNil) ifFalse: [resultLine comment: comment].	^resultLine.! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 9/15/2012 10:58'!addMarkUp: aSourceString 	self frame addMarkUp: ( ( HumMarkupLine new ) source:  aSourceString) .! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 1/2/2012 17:03'!getInstructionAt: aSmallInteger 	^self lines at: aSmallInteger .! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 6/12/2014 21:32'!addDictionaryLine: aSourceString 	self frame addDictionaryLine: (self stripLeaderFrom: aSourceString).! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!appendRole: aRole action: aStatement 	"Pass through to frame."	self frame appendInstructionRole: aRole statement: aStatement.! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!appendPrecondition: aPreconditionStatement 	self assert: ( self frame isKindOf: HumFrame4Plan ).	self frame appendPrecondition: (self stripLeaderFrom: aPreconditionStatement) .! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 12/30/2015 11:39'!appendInstructionStatement: aStatement 	"Append a simple instruction (no delegation, no comment) to the frame."	|  |	self frame appendInstructionStatement: aStatement.! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 3/17/2015 12:07'!appendInstructionRole: aRole statement: aStatement comment: aComment 	self frame appendInstructionRole: aRole statement: aStatement comment: aComment .! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 3/17/2015 12:04'!appendFrameLine: aSourceString 	"Create appropriate frameLine type and append to frame."	| calc source |	self assert: (aSourceString isKindOf: String).	source := self stripLeaderFrom: aSourceString.	calc := HumCalculator new.	calc cases;		when: [self frame isKindOf: HumFrame4Plan] then: [ self addPlanLine: source ];		when: [self frame isKindOf: HumFrame4View] then: [ frame addMarkUp: source ];		when: [self frame isKindOf: HumFrame4Action] then: [ self addActionLine: source ];		when: [self frame isKindOf: HumFrame4Comment] then: [ frame appendFrameLine: (HumCommentLine source: source) ];		when: [self frame isKindOf: HumFrame4Dictionary] then: [ frame addDictionaryLine: source ];		"For vignette lines, we want to preserve leading dot because it identifies instruction lines."		when: [self frame isKindOf: HumFrame4Vignette] then: [ self addVignetteLine: aSourceString ];		otherwise: [ Error signal: 'Unknown frame type.'].	! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 3/17/2015 12:06'!appendInstructionRole: aRole statement: aStatement 	self frame appendInstructionRole: aRole statement: aStatement.! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 12/29/2014 09:11'!stripLeaderFrom: aLine 	| stmt calc |	(aLine = '.') ifTrue: ["Assume blank instruction line." ^''].	stmt := aLine.	calc := HumCalculator new.	[stmt beginsWith: '. ']		whileTrue: [ stmt := calc given: stmt extractAfter: '. '].	^stmt! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!addPlanLine: aSourceString 	"The kind of line is modal."	"Look for lines that reset the mode."	( (aSourceString asLowercase beginsWith: 'precondition')	  or: [aSourceString asLowercase beginsWith: 'pre:']	)		ifTrue: [mode := #preconditions.			frame appendFrameLine: (HumFrameLine source: aSourceString).			^self.			].	( (aSourceString beginsWith: 'Action:') or: [aSourceString beginsWith: 'Actions:'])		ifTrue: [mode := #actions.			frame appendFrameLine: (HumFrameLine source: aSourceString).			^self.			].	"Process the source line according to mode set by prior source line."		(mode = #preconditions)		ifTrue: [			self appendPrecondition: aSourceString.			^self			].	(mode = #actions)		ifTrue: [ | aRole sourceMinusComment |			sourceMinusComment := self programmersAssistant removeCommentFromSource: aSourceString.			(sourceMinusComment sameAs: '') 				ifTrue: [frame appendFrameLine: (HumCommentLine source: aSourceString).]				ifFalse: [					aRole := self programmersAssistant getLabelFromSource: aSourceString.					aRole ifNil: [Error signal: 'Plan actions must have roles.'].					self appendRole: aRole action: (self programmersAssistant removeLabelFromSource: aSourceString).					].				^self.			].	(mode isNil)		ifTrue: [ "Default mode is preconditions -- Allows 'Preconditions:' label to be omitted in source file."			mode := #preconditions. 			self appendPrecondition: aSourceString.			^self			].	Error signal: 'How did we fall through addPlanLine: ...?'.		 ! !!HumFrameUpdater methodsFor: 'add frame line' stamp: 'RichardAlexanderGreen 1/2/2012 16:46'!putInstruction: aHumInstruction at: aSmallInteger 	| myLines |	myLines :=  (self lines).	( myLines isEmpty) 		ifFalse: [ myLines  at: aSmallInteger put: aHumInstruction .]		ifTrue: [ myLines add: aHumInstruction ].		! !!HumFrameUpdater methodsFor: 'add vignette line' stamp: 'RichardAlexanderGreen 12/11/2014 12:01'!addVignetteLine: aSourceString 	| source calc |	source := aSourceString.	calc := HumCalculator new.	"DEBUG	(aSourceString endsWith: '].') 		ifTrue: [ 			Transcript cr; 				show: aSourceString; 				show: ' ';					show: vignetteMode;				show: ' ';				show: (frame patterns at: 1) asString.			].	"	calc cases;		when: [(source beginsWith: 'U:')				and: [self vignetteMode = #pattern]]			then: [frame addVignettePattern: (calc given: source extractAfter: 'U:')				];		when: [(source beginsWith: 'U:')				and: [self vignetteMode = #response]]			then: [| pattern |				"Store prior vignette frame and Start a new vignette frame."				frame patterns size > 0					ifTrue: ["Store prior vignette frame and Start a new vignette frame."						self storeFrameInOntology. ].				pattern := calc given: source extractAfter: 'U:'.				frame := HumFrame4Vignette						ontology: self ontology						vignetteContext: self vignetteContext						pattern: pattern.				self vignetteMode: #pattern.				frame addVignettePattern: pattern				];		when: [source beginsWith: 'S:']			then: ["Starting response."				self vignetteMode: #response.				frame addVignetteResponse: (calc given: source extractAfter: 'S:')				];		when: [source sameAs: '']			then: ["Ignore blank line."			];		when: [ source beginsWith: ' ' ]			then: ["Should be response line." 				frame addVignetteResponse: source.				];		when: [source beginsWith: '.']			then: ["Add instruction line."				frame addVignetteInstruction: (calc given: source extractAfter: '.')				];		otherwise: [Error signal: 'Vignette line type not recognized.']! !!HumFrameUpdater methodsFor: 'add vignette line' stamp: 'RichardAlexanderGreen 12/11/2014 10:24'!vignetteMode	"What mode is the vignette parser in?"	vignetteMode ifNil: [ vignetteMode := #pattern ].	self assert: ( vignetteMode = #pattern or: [ vignetteMode = #response ]).	^vignetteMode! !!HumFrameUpdater methodsFor: 'add vignette line' stamp: 'RichardAlexanderGreen 12/6/2014 09:13'!nextVignetteContext: aString 	frame nextVignetteContext: aString! !!HumFrameUpdater methodsFor: 'add vignette line' stamp: 'RichardAlexanderGreen 12/6/2014 09:25'!vignetteMode: newMode	"What mode is the vignette parser in?"	self assert: ( newMode = #pattern or: [ newMode = #response ]).	vignetteMode := newMode.! !!HumFrameUpdater methodsFor: 'add vignette line' stamp: 'RichardAlexanderGreen 1/16/2012 11:50'!addVignetteInstruction: anInstructionLine 	( self frame ) addVignetteInstruction: anInstructionLine. ! !!HumFrameUpdater methodsFor: 'add vignette line' stamp: 'RichardAlexanderGreen 12/6/2014 09:43'!vignetteContext	| result |	result := frame vignetteContext.	^result.! !!HumFrameUpdater methodsFor: 'add vignette line' stamp: 'RichardAlexanderGreen 1/16/2012 11:46'!addVignetteResponse: aResponseString 	(self frame) addVignetteResponse: aResponseString.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrameUpdater class	instanceVariableNames: ''!!HumFrameUpdater class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/11/2014 13:13'!ontology: aHumOntology fetchFrameByName: aString 	| frame frameUpdater |	frame := aHumOntology fetchFrameByName: aString.	frameUpdater := self new.	frameUpdater ontology: aHumOntology; frame: frame.	^ frameUpdater.! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/11/2014 13:11'!ontology: aHumOntology role: aRole action: anActionStatement 	| frameUpdater |	frameUpdater := self new.	frameUpdater ontology: aHumOntology.	frameUpdater frame: ( HumFrame4Action ontology: aHumOntology role: aRole action: anActionStatement ).	^frameUpdater.	! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/11/2014 13:14'!ontology: aHumOntology vignetteContext: aContextString pattern: aPatternString 	| frame  frameUpdater |	frame := HumFrame4Vignette ontology: aHumOntology vignetteContext: aContextString pattern: aPatternString.	frameUpdater := self new.	frameUpdater ontology: aHumOntology; 	                frame: frame.	^frameUpdater. ! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/11/2014 13:11'!ontology: aHumOntology loadFrameByIdentifier: aPrimaryKey 		| frameUpdater |	frameUpdater := self new.	frameUpdater ontology: aHumOntology.	frameUpdater frame: ( aHumOntology fetchFrameByIdentifier:  aPrimaryKey ).	^frameUpdater.! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 12/21/2015 09:37'!ontology: aHumOntology commentTitle: aTitleString 	"Instantiate with a new comment frame."	| frameUpdater |	frameUpdater := self new.	frameUpdater ontology: aHumOntology.	frameUpdater frame:( (HumFrame4Comment new) ontology: aHumOntology; titleLine: aTitleString ).		^frameUpdater ! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/11/2014 13:14'!ontology: aHumOntology viewEntity: anEntity 	| frameUpdater |	frameUpdater := self new.	frameUpdater ontology: aHumOntology.	frameUpdater frame: (  HumFrame4View ontology: aHumOntology viewEntity: anEntity ).	^frameUpdater.		! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 12/21/2015 09:37'!ontology: aHumOntology dictionaryTitle: aTitleString 	"Instantiate with a new dictionary frame."	| frameUpdater |	frameUpdater := self new.	frameUpdater ontology: aHumOntology.	frameUpdater frame:( (HumFrame4Dictionary new) ontology: aHumOntology; titleLine: aTitleString ).		^frameUpdater ! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/11/2014 13:13'!ontology: aHumOntology goal: goalStatement 	| frameUpdater |	frameUpdater := self new.	frameUpdater ontology: aHumOntology.	frameUpdater frame:( HumFrame4Plan ontology: aHumOntology goal: goalStatement).	^frameUpdater.! !!HumFrameUpdater class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/11/2014 13:14'!ontology: aHumOntology loadFrameByName: aString 	| frame frameUpdater |	frame := aHumOntology fetchFrameByName: aString.	frameUpdater :=  self new.	frameUpdater ontology: aHumOntology; 	                frame: frame.	^ frameUpdater! !Object subclass: #HumProgrammersAssistant	instanceVariableNames: 'ontology currentRole frame'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-IDE'!!HumProgrammersAssistant commentStamp: 'RichardAlexanderGreen 12/27/2016 12:55' prior: 0!TODO: Should parsing methods be in Ontology or Programmers Assistant?The Programmer`s Assistant (PA) provides the Interactive Development Environment (IDE) for Hum.While Smalltalk maintains source code in the image file, Hum maintains code in an ontology file.Each type of frame expects a notation meant to be used in that type of frame.See the class category 'Hum-Language' and the on-line manual for more detail.The Assistant is a user interface (a UI model actually) constructed as a set of views on the ontology.The ontology is the model.A Frame Editor is a viewer and a controller that may modify ontology frames.Diagrams provide a views of an ontology`s structure (relationships between various elements).Diagrams are read-only, but they may support mouse (hand) actions such as mouse-over and click.The Plan Diagram shows the precedence relationships implied by the plan frames.The Noun Diagram shows the structure of the dictionary with attributes and supertype relations as connectors.The Dialog Context Diagram shows the connections between dialog vignette contexts.The Delegation Diagram shows the dependencies between roles.The Programmers Assistant provides an intermediary between a UI implementation and the ontology object.The programmers assistant is the model of the IDE.See: HumProgrammersAssistantTests.The UI interacts with the Programmers Assistant to provide a specific implementation.See Hum-Seaside class category. (HumOntologyBrowser)   !!HumProgrammersAssistant methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/2/2012 13:58'!clearOntology	ontology := HumOntology new.! !!HumProgrammersAssistant methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/2/2012 13:59'!ontology	"Return the ontolgy. If nil initialize one."	^ ontology ifNil: [ ontology := HumOntology new. ].! !!HumProgrammersAssistant methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/12/2014 16:26'!ontology: aHumOntology	ontology := aHumOntology! !!HumProgrammersAssistant methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 6/13/2016 08:22'!loadOntologyFromSaveFileNamed: aFileNameString 	"Reload an ontology from the given save file."	|  |	self ontology: (HumOntology new).	self loadOntology: (ontology) fromTextFileNamed: aFileNameString.	^ontology.! !!HumProgrammersAssistant methodsFor: 'file operations' stamp: 'RichardAlexanderGreen 12/28/2015 13:11'!writeOntologyVFrame: aFrame onStream: aStream	"Write UI frames: Vignette and View frames only use dot-leader for instruction lines."	|  cr dotLeader |	cr := String cr.	dotLeader := '. '.	( aFrame frameLines )			do: [ :frameLine |				"My indent convention involves dot leader"				( frameLine isKindOf: HumInstructionLine )  						ifTrue: [ (1 to: frameLine indent) do: [ :i |  aStream nextPutAll: dotLeader ] ].										aStream nextPutAll: ( (frameLine source ), cr).					 				].	! !!HumProgrammersAssistant methodsFor: 'file operations' stamp: 'RichardAlexanderGreen 4/30/2015 10:28'!writeOntologyContextVignettesOnStream: aStream	| contexts vignettes cr |	cr := String cr.	contexts := ontology contexts sorted.	contexts		do: [ :aContext |			aStream nextPutAll: '===', cr.			aStream nextPutAll: 'Context: ', aContext, '.', cr.			vignettes := (ontology vignettesForContext: aContext) sorted: [ :aFrame :bFrame | (aFrame title) < (bFrame title) ].			vignettes				do: [ :aVignetteFrame |						aStream nextPutAll: cr.						self writeOntologyVFrame: aVignetteFrame onStream: aStream.					 ].			 ].! !!HumProgrammersAssistant methodsFor: 'file operations' stamp: 'RichardAlexanderGreen 12/28/2015 12:59'!writeOntologyFramesOfType: aFrameClass onStream: aStream	"Select frames of given class and write them on the stream."	| selectedFrames sortedFrames dotLeader cr |	dotLeader := '. '.	cr := String cr.	selectedFrames := (ontology frames) select: [ :frameX | frameX isKindOf: aFrameClass ].	sortedFrames := selectedFrames sorted: [ :frameA :frameB | (frameA title) < (frameB title) ]. 	sortedFrames 		do: [ :aFrame | self writeOntologyFrame: aFrame onStream: aStream. ].! !!HumProgrammersAssistant methodsFor: 'file operations' stamp: 'RichardAlexanderGreen 7/25/2016 08:39'!loadOntology: anOntology fromTextFileNamed: fileName	"Load an ontology from the given text file."	| stream |	self ontology: anOntology.	ontology file: fileName.	ontology title: fileName.	stream := StandardFileStream readOnlyFileNamed: fileName.	stream position: 0. "Just in case."	self loadOntologyFromTextStream: stream.	^ontology.	! !!HumProgrammersAssistant methodsFor: 'file operations' stamp: 'RichardAlexanderGreen 12/28/2015 12:45'!saveOntologyOnFileNamed: aFileName 	"Save my ontology on the given ReferenceStream file."	"Note: This method  does not provide any kind of versioning."	"ToDo: If we save ontology in a WorldBase instead, 	       the WorldBase could provide versioning."	| referenceStream |	self shouldNotImplement. "This version of Smalltalk does not provide the needed ReferenceStream class."	"Open the file for write -- clear it if necessary."	referenceStream := nil. "ReferenceStream fileNamed: aFileName."	"Write the various data structures to the file."	referenceStream nextPut: ontology.	referenceStream close.	! !!HumProgrammersAssistant methodsFor: 'file operations' stamp: 'RichardAlexanderGreen 12/28/2015 13:02'!writeOntologyFrameWithIndents: aSubFrame onStream: aStream	"Vignette and View frames use dot-leader only for instruction lines."	|  cr dotLeader |	cr := String cr.	dotLeader := '. '.	( aSubFrame frameLines )			do: [ :frameLine |				"My indent convention involves dot leader"				( (frameLine isKindOf: HumInstructionLine) and: [ frameLine indent > 1 ] ) 						ifTrue: [ (1 to: frameLine indent) do: [ :i |  aStream nextPutAll: dotLeader ] ].				"NOTE: This assumes the source does not contain its own dot-leader."						aStream nextPutAll: ( (frameLine source ), cr ).					 				].	! !!HumProgrammersAssistant methodsFor: 'file operations' stamp: 'RichardAlexanderGreen 12/28/2015 13:08'!writeOntologyOnTextFileNamed: aFileName 	"Save my ontology in text format on the file with the given name. "	| fileStream  |	self assert: ( aFileName isKindOf: String ).	self assert: ( ontology isKindOf: HumOntology ).	fileStream := FileStream forceNewFileNamed: aFileName. 	"Order: Comment, Dictionary, Vignette, Role-Action, Plan, View"	" -- NOTE: Original file order (if any) is not maintained. That means that comment frames may lack original context."	self writeOntologyFramesOfType: HumFrame4Comment onStream: fileStream.	self writeOntologyFramesOfType: HumFrame4Dictionary onStream: fileStream.	"Write context vignettes in consolidated frames."	self writeOntologyContextVignettesOnStream: fileStream.	"Write role-actions in consolidated frames."	self writeOntologyRoleActionsOnStream: fileStream.	"Write the remaining frames. ( Plan, View )"	self writeOntologyFramesOfType: HumFrame4Plan onStream: fileStream.	self writeOntologyFramesOfType: HumFrame4View onStream: fileStream.		fileStream nextPutAll: ( '===', String cr ).	fileStream close.! !!HumProgrammersAssistant methodsFor: 'file operations' stamp: 'RichardAlexanderGreen 5/20/2016 09:55'!loadOntologyFromTextStream: aStream 	"Discover frame type and store each frame in ontology."	|  sourceLine frameUpdater  isActionSubFrameCase |	"Use ontology provided by caller or lazy initialization."	frameUpdater := (HumFrameUpdater new) ontology: (self ontology).	"Define a function to detect action subframe case."	sourceLine := String new. "This satisfies compiler that sourceLine is defined before lambda uses it."	isActionSubFrameCase := [(frameUpdater frame isKindOf: HumFrame4Action) 		                       and: [(sourceLine beginsWith: 'Action:') or: [sourceLine beginsWith: 'To:']]].	"Read frames from the stream."	[(sourceLine := aStream nextLine) notNil]		whileTrue: ["For each line in the stream:"			((sourceLine beginsWith: '===') or: [frameUpdater isEmpty or: [isActionSubFrameCase value]]) 				ifTrue: [ "Store prior frame, if any. Start new frame."					(frameUpdater isEmpty) ifFalse: [ frameUpdater storeFrameInOntology ].					"Get a fresh frameUpdater."					frameUpdater := (HumFrameUpdater new) ontology: ontology..					"Get the title line and discover what kind of frame comes next."					(sourceLine beginsWith: '===') ifTrue: [sourceLine := aStream nextLine].					frameUpdater frame: (self makeFramePerTitleLine: sourceLine).					]				ifFalse: ["self haltIf: ('*Smalltalk*' match: sourceLine asString)."					frameUpdater appendFrameLine: sourceLine]			].	"Strore frame - unless frame is empty."		(frameUpdater isEmpty) ifFalse: [ frameUpdater storeFrameInOntology ].	^ontology.	! !!HumProgrammersAssistant methodsFor: 'file operations' stamp: 'RichardAlexanderGreen 6/13/2016 08:21'!loadOntologyFromTextFileNamed: fileName	"Load an ontology from the given text file."	|  |	ontology ifNil: [ self ontology: (HumOntology baseOntology) ].	self loadOntology: (ontology) fromTextFileNamed: fileName.	^ontology.	! !!HumProgrammersAssistant methodsFor: 'file operations' stamp: 'RichardAlexanderGreen 12/28/2015 13:01'!writeOntologyFrame: aFrame onStream: aStream	"Write to given stream - customize per frame-type as needed."	|  cr dotLeader |	cr := String cr.	dotLeader := '. '.	aStream nextPutAll: ( '===', cr ).	aStream nextPutAll: (( aFrame title ), cr ).	( aFrame frameLines )			do: [ :frameLine |				"Eh? - All lines have the same dotLeader ???  What was I thinking???"				aStream nextPutAll: dotLeader, (frameLine source ), cr.								"See also: writeOntologyFrameWithIndents:onStream:"	 				].	! !!HumProgrammersAssistant methodsFor: 'file operations' stamp: 'RichardAlexanderGreen 12/28/2015 13:09'!writeOntologyRoleActionsOnStream: aStream	"Write role-action frames ordered by role and action."	| roles  cr |	cr := String cr.	roles := ontology roles sorted.	roles		do: [ :aRole |			| actionStatements actionStatementsSorted |			aStream nextPutAll: '===', cr.			aStream nextPutAll: 'Role: ', aRole, cr.			actionStatements := (ontology actionsOf: aRole). "Returns a set of HumStatement"			actionStatementsSorted := actionStatements sorted: [ :aStatement :bStatement | (aStatement source) < (bStatement source) ].			actionStatementsSorted				do: [ :anActionStatement |						| anActionFrame |						aStream nextPutAll: cr.						anActionFrame := ontology getFrameForRole: aRole action: anActionStatement.						self writeOntologyFrame: anActionFrame onStream: aStream.					 ].			 ].! !!HumProgrammersAssistant methodsFor: 'file operations' stamp: 'RichardAlexanderGreen 12/28/2015 13:00'!writeFrame: aFrame onStream: aStream	"Write frame-lines to given stream in canonical format.    *** NO SENDERS ***	- Lines have canonical format to simplify reading them back. 	- Customize per frame-type as needed.	See also: writeOntolgyFrame:onStream: - which appears to do the same thing."	|  cr dotLeader |	cr := String cr.	dotLeader := '. '.	aStream nextPutAll: ( '===', cr ).	aStream nextPutAll: (( aFrame title ), cr ).	( aFrame frameLines )			do: [ :frameLine |				"My indent convention involves dot leader"				( (frameLine isKindOf: HumInstructionLine) and: [ frameLine indent > 1 ] ) 						ifTrue: [ (1 to: frameLine indent) do: [ :i |  aStream nextPutAll: dotLeader ] ].										aStream nextPutAll: ( dotLeader, (frameLine source ), cr).					 				].	! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 10/8/2014 10:12'!removeAnnotationFromSource: aSourceString 	| cleanerSource |	cleanerSource := self class removeAnnotationFromSource: aSourceString.	^cleanerSource. ! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/8/2015 12:36'!parseInstructionSource: source keywords: keywords	"Parse the source -- Return a list of token-type pairs: ( token -> tokenType ).	Parse the source -- Return a list of token-type pairs: ( token -> tokenType ).	tokenType is one of: #word #keyword #punctuation #comment #annotation.	"	| tokenTypePairs tokenPairsWithNounsMarked secondToken firstToken firstTokenType calc |	tokenTypePairs := self class parseInstructionSource: source keywords: keywords.		"Look-up #word types to see if they are #noun types."	tokenPairsWithNounsMarked := OrderedCollection new.	tokenTypePairs do: [ :association |  		| token tokenType |		token := association key.		tokenType := association value.		( tokenType = #word ) 			ifFalse: [ tokenPairsWithNounsMarked add: association ]			ifTrue: [ "Is this word a noun?" 				(self ontology isNoun: token)					ifFalse:  [ tokenPairsWithNounsMarked add: association ]					ifTrue: [  tokenPairsWithNounsMarked add: ( token -> #noun ) ].				].		].	"If second token is colon, first token is a role."		firstToken := (tokenPairsWithNounsMarked at: 1) key.	firstTokenType := (tokenPairsWithNounsMarked at: 1) value.	secondToken := (tokenPairsWithNounsMarked at: 2) key.	calc := HumCalculator new.	calc cases;		when: [ (secondToken = ':' and: [ firstTokenType = #keyword])  ] 			then: [ "Do nothing" ];		when: [ (secondToken = ':' and: [ firstTokenType = #word])  ] 			then: [ tokenPairsWithNounsMarked at: 1 put: ( firstToken -> #role ).].	^ tokenPairsWithNounsMarked.! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 6/13/2014 19:59'!removeLabelFromSource: aSourceString 	"If there is a label, remove it and return the remainder."	| remainder |	remainder := self class removeLabelFromSource: aSourceString.	^remainder.! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 6/13/2014 19:59'!removeCommentFromSource: aSourceString 	| cleanerSource |	cleanerSource := self class removeCommentFromSource: aSourceString.	^cleanerSource. ! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/8/2015 12:34'!parseSource: source keywords: keywords	"Parse the source -- Return a list of token-type pairs: ( token -> tokenType ).	Parse the source -- Return a list of token-type pairs: ( token -> tokenType ).	tokenType is one of: #word #keyword #punctuation.	See also: >>parseInstructionSource: keywords:	"	| tokenTypePairs tokenPairsWithNounsMarked     |	self assert: ( keywords isKindOf: Collection ).	tokenTypePairs := self class parseSource: source keywords: keywords.		"Look-up #word types to see if they are #noun types."	tokenPairsWithNounsMarked := OrderedCollection new.	tokenTypePairs do: [ :association |  		| token tokenType |		token := association key.		tokenType := association value.		( tokenType = #word ) 			ifFalse: [ tokenPairsWithNounsMarked add: association ]			ifTrue: [ "Is this word a noun?" 				(self ontology isNoun: token)					ifFalse:  [ tokenPairsWithNounsMarked add: association ]					ifTrue: [  tokenPairsWithNounsMarked add: ( token -> #noun ) ].				].		].	^ tokenPairsWithNounsMarked.! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/9/2015 08:32'!parseMarkupSource: aSourceString 	| result |	result := self class parseMarkupSource: aSourceString.	^result.! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/27/2016 12:32'!parseActionLine: aString keywords: aCollection 	"An action line begins with 'Action:' or 'To:' keyword.	It may also include a comment and/or annotation."
	self shouldBeImplemented ! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 6/13/2014 19:55'!getLabelFromSource: aSourceString	"Match 'word:' at the front of the string.	Note: word may be hyphenated. "	| label |	label := self class getLabelFromSource: aSourceString.	^label.! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/29/2016 17:52'!makeFramePerTitleLine: source 	"The label on the title line indicates the kind of frame."	| label calc |	source ifNil: [^nil].	self assert: (source isKindOf: String).	label := self getLabelFromSource: source.	label ifNil: [^nil].	calc := HumCalculator new.	calc cases;		when: [label sameAs: 'View'] then: [ frame := ( HumFrame4View ontology: ontology title: source ) ];		when: [label sameAs: 'Pane'] then: [ frame := ( HumFrame4View ontology: ontology title: source ) ];		when: [label sameAs: 'Layout'] then: [ frame := ( HumFrame4View ontology: ontology title: source ) ];		when: [label sameAs: 'Comment'] then: [ frame := (HumFrame4Comment new) titleLine: source; ontology: ontology. ];		when: [label sameAs: 'Questions'] then: [ frame := (HumFrame4Comment new) titleLine: source ];	  when: [label sameAs: 'Dictionary'] then: [ frame := (HumFrame4Dictionary ontology: ontology title: source)];		when: [label sameAs: 'Goal'] 		      then: [ frame := HumFrame4Plan ontology: ontology 			                                       goal: (calc given: source extractAfter: (label,':') ) ];		when: [label sameAs: 'Role'] 		      then: [ currentRole := (calc given: source extractBetween: (label,':') and: '.') trimBoth. 			            frame := HumFrame4Action new. 			       		];		when: [(label sameAs: 'Action') and: [frame isKindOf:HumFrame4Action ]] 		      then: [ (frame isEmpty) ifFalse: [frame compileToOntology: ontology ].			            frame := HumFrame4Action ontology: ontology 			                                         role: currentRole			                                       action: (calc given: source extractAfter: (label,':')).			            frame appendFrameLine: (HumFrameLine source: source).			          ];		when: [label sameAs: 'To'] 		      then: [ (frame isEmpty) ifFalse: [frame compileToOntology: ontology ].			            frame := HumFrame4Action ontology: ontology 			                                         role: currentRole			                                       action: (calc given: source extractAfter: (label,':')).			            frame appendFrameLine: (HumFrameLine source: source).			          ];		when: [(label sameAs: 'Context') or: [label sameAs: 'Dialog']]		      then: [ frame := HumFrame4Vignette ontology: ontology 			                                vignetteContext: (calc given: source extractBetween: (label,':') and: '.') 			                                        pattern: nil ];	  otherwise: [Error signal: 'Fell thru cases in makeFramePerTitleLine.'].	"Track which ontology the frame was defined in."	frame origin: ontology title copy.	^frame.! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/27/2016 07:56'!getAnnotationFromSource: aSourceString 	"Match '[...]' if any, and extract it from source."	| annotation  |	annotation := self class getAnnotationFromSource: aSourceString.	^annotation.! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/8/2015 13:34'!parseActionLine: source 	"An action line begins with 'Action:' or 'To:' label.	An action line may include a comment and/or annotation.	"	| tokenTypePairs tokenPairsWithNounsMarked     |	tokenTypePairs := self class parseActionLine: source.		"Look-up #word types to see if they are #noun types."	tokenPairsWithNounsMarked := OrderedCollection new.	tokenTypePairs do: [ :association |  		| token tokenType |		token := association key.		tokenType := association value.		( tokenType = #word ) 			ifFalse: [ tokenPairsWithNounsMarked add: association ]			ifTrue: [ "Is this word a noun?" 				(self ontology isNoun: token)					ifFalse:  [ tokenPairsWithNounsMarked add: association ]					ifTrue: [  tokenPairsWithNounsMarked add: ( token -> #noun ) ].				].		].	^ tokenPairsWithNounsMarked.! !!HumProgrammersAssistant methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 6/13/2014 19:55'!getCommentFromSource: aSourceString 	"Match '(...)' if any, and extract it from source."	| comment  |	comment := self class getCommentFromSource: aSourceString.	^comment.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumProgrammersAssistant class	instanceVariableNames: ''!!HumProgrammersAssistant class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/29/2016 10:01'!removeAnnotationFromSource: aSourceString 	"Return the source string with the annotation, if any, removed."	| remainderBefore remainderAfter annotation |	annotation := self getAnnotationFromSource: aSourceString.	annotation ifNil: [^aSourceString trimBoth].	remainderBefore := HumCalculator given: aSourceString extractUpto: annotation.	remainderAfter := HumCalculator given: aSourceString extractAfter: annotation.	^( remainderBefore, remainderAfter ) trimBoth.! !!HumProgrammersAssistant class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/9/2015 08:03'!parseInstructionSource: source keywords: keywords	"Parse the source -- Return a list of token-type pairs: ( token -> tokenType ).	tokenType is one of: #word #keyword #punctuation #comment."	| whitespace punctuation quote tokens tokenTypePairs tokenType i calc remainingSource |	whitespace := String space, String tab, String crlf.	quote := $' asString.	punctuation := '~!!@#$%^&*()_+`={}|[]\:";<>?,./', quote.	"Note: Preserve uppercase in tokens so that first word of a sentence is capitalized."	tokens := source  findTokens: ( punctuation, whitespace ) keep: ( punctuation, whitespace ).	remainingSource := source.	tokenTypePairs := OrderedCollection new.	calc := HumCalculator new.	i := 1.	[ i <= tokens size ]			whileTrue: [ 			| token |			token := tokens at: i.			tokenType := #word.			"( self isNoun: token ) ifTrue: [ tokenType := #noun ]."			calc cases;				when: [ keywords include: token asLowercase  ] then: [ tokenType := #keyword ];				when: [ ( token size = 1 ) and: [ whitespace includes: token first]  ] then:  [ tokenType := #whitespace ];				when: [ ( token size = 1 ) and: [ punctuation includes: token first] ]					then: [ | calc2 gatherThru append | 						calc2 := HumCalculator new.						tokenType := #punctuation. "Until proven otherwise."						append := [ token := token, (tokens at: i) ].						gatherThru := [ :stop |  [( i := i+1)<= (tokens size) and: [ ((tokens at: i ) = stop) ] ] whileFalse: [ append value ].  append value ].						calc2 cases;							"Does the source have a comment?"							when: [ (token = '(') and: ['*(*)*' match: remainingSource ]  ] then: [ gatherThru value: ')'. tokenType := #comment.  ]; 							"Does the source have annotation?"							when: [ (token = '[') and: ['*[*]*' match: remainingSource ] ] then: [ gatherThru value: ']'. tokenType := #annotation. ];							when: [ (token = '"') and: ['*"*"*' match: remainingSource ] ] then: [ gatherThru value: '"'. tokenType := #string. ].					].			( tokenType = #whitespace ) ifFalse: [tokenTypePairs add: ( token -> tokenType )].			remainingSource := calc given: remainingSource extractAfter: token.			i := i + 1.			].	^ tokenTypePairs.! !!HumProgrammersAssistant class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 6/13/2014 19:45'!removeLabelFromSource: aSourceString 	"If there is a label, remove it and return the remainder."	| label remainder calc|	label :=  self getLabelFromSource: aSourceString.	(label isNil)		ifTrue: [remainder := aSourceString ]		ifFalse: [ "Return the remainder after first colon"			calc := HumCalculator new.			remainder := (calc given: aSourceString extractAfter: ':') trimBoth. 			].	^remainder.! !!HumProgrammersAssistant class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/29/2016 10:01'!removeLeaderFromSource: aSource	"Strip dot-leader, if any. "	| s |	self assert: (aSource isKindOf: String).	s := aSource.	[s beginsWith: '. ']		whileTrue: [s := s copyFrom: 3 to: s size].	^s.! !!HumProgrammersAssistant class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/29/2016 10:00'!removeCommentFromSource: aSourceString 	"Return the source string with comment, if any, removed."	| remainderBefore remainderAfter comment |	comment := self getCommentFromSource: aSourceString.	comment ifNil: [^aSourceString trimBoth].	remainderBefore := HumCalculator given: aSourceString extractUpto: comment.	remainderAfter := HumCalculator given: aSourceString extractAfter: comment.	^( remainderBefore, remainderAfter ) trimBoth.! !!HumProgrammersAssistant class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/9/2015 10:01'!parseMarkupSource: source 	"Parse the source -- Return a list of token-type pairs: ( token -> tokenType ).	tokenType is one of: #word #punctuation #markup #whitespace #widget"	| whitespace punctuation quote tokens tokenTypePairs tokenType i calc remainingSource markup addHeading |	whitespace := String space, String tab, String crlf.	quote := $' asString.	punctuation := '~!!@#$%^&*()_+`={}|[]\:";<>?,./', quote.	markup := '*~_^'.	tokenTypePairs := OrderedCollection new.	"First handle and remove outline markup"	calc := HumCalculator new.	addHeading := [ :heading | tokenTypePairs add: (heading->#markup). remainingSource := calc given: source extractAfter: heading. ].	calc cases;		when: [ source beginsWith: '!!!!!!!!' ] then: [ addHeading value: '!!!!!!!!' ];		when: [ source beginsWith: '!!!!!!' ] then: [ addHeading value: '!!!!!!' ];		when: [ source beginsWith: '!!!!' ] then: [ addHeading value: '!!!!' ];		when: [ source beginsWith: '!!' ] then: [ addHeading value: '!!' ];		when: [ source beginsWith: '----' ] then: [ addHeading value: '----' ];		when: [ source beginsWith: '---' ] then: [ addHeading value: '---' ];		when: [ source beginsWith: '--' ] then: [ addHeading value: '--' ];		when: [ source beginsWith: '-' ] then: [ addHeading value: '-' ];		when: [ source beginsWith: '####' ] then: [ addHeading value: '####' ];		when: [ source beginsWith: '###' ] then: [ addHeading value: '###' ];		when: [ source beginsWith: '##' ] then: [ addHeading value: '##' ];		when: [ source beginsWith: '#' ] then: [ addHeading value: '#' ];		otherwise: [ remainingSource := source ].		"Note: Preserve uppercase in tokens so that first word of a sentence is capitalized."	tokens := remainingSource  findTokens: ( punctuation, whitespace ) keep: ( punctuation, whitespace ).	i := 1.	[ i <= tokens size ]			whileTrue: [ 			| token |			token := tokens at: i.			tokenType := #word.			"( self isNoun: token ) ifTrue: [ tokenType := #noun ]."			calc cases;				when: [ ( token size = 1 ) and: [ whitespace includes: token first]  ] then:  [ tokenType := #whitespace ];				when: [ ( token size = 1 ) and: [ markup includes: token first]  ] then:  [ tokenType := #markup ];				when: [ ( token size = 1 ) and: [ punctuation includes: token first] ]					then: [ | calc2 gatherThru append | 						calc2 := HumCalculator new.						tokenType := #punctuation. "Until proven otherwise."						append := [ token := token, (tokens at: i) ].						gatherThru := [ :stop |  [( i := i+1)<= (tokens size) and: [ ((tokens at: i ) = stop) ] ] whileFalse: [ append value ].  append value ].						calc2 cases;							"Does the source have a radio-button widget?"							when: [ (token = '(') and: ['*(#)*' match: remainingSource ]  ] then: [ gatherThru value: ')'. tokenType := #widget.  ]; 							"Does the source contain an action button?  Need to get this before other bracket widgets."							when: [ (token = '[') and: ['[[*]]*' match: remainingSource ] ] 								then: [ tokenType := #widget. 										gatherThru value: ']'. 										gatherThru value: ']'. 										];							"Does the source have a bracket-notation widget?"							when: [ (token = '[') and: ['*[*]*' match: remainingSource ] ] then: [ gatherThru value: ']'. tokenType := #widget. ];							when: [ (token = '"') and: ['*"*"*' match: remainingSource ] ] then: [ gatherThru value: '"'. tokenType := #string. ].					].			tokenTypePairs add: ( token -> tokenType ).			remainingSource := calc given: remainingSource extractAfter: token.			i := i + 1.			].	^ tokenTypePairs.! !!HumProgrammersAssistant class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/8/2015 18:16'!getLabelFromSource: aSourceString	"Match 'word:' at the front of the string.	Note: word may be hyphenated. "	| label tokenTypePairs |	((aSourceString isNil) or: [aSourceString trimBoth = '']) ifTrue: [^nil].	tokenTypePairs := self parseInstructionSource: aSourceString keywords: {}.	((( tokenTypePairs at: 1 ) key) = '.')		ifTrue: [ tokenTypePairs removeFirst].	"If the second token is a colon, the first token is a label."	((tokenTypePairs size >= 2) and: [(( tokenTypePairs at: 2 ) key) = ':'])		ifTrue: [ label := (( tokenTypePairs at: 1 ) key ).				"Do not mistake 'Else:' for a label."				(label asLowercase sameAs: 'else') ifTrue: [ label := nil. ].			]		ifFalse: [ label := nil ].	^label.! !!HumProgrammersAssistant class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 1/5/2015 10:46'!getAnnotationFromSource: aSourceString 	"Match '[...]' if any, and extract it from source."	| annotation  |	annotation := HumCalculator given: aSourceString extractIncludingMatching: '[]'. 	^annotation.! !!HumProgrammersAssistant class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/8/2015 18:02'!parseActionLine: source 	"Parse the source -- Return a list of token-type pairs: ( token -> tokenType ).	tokenType is one of: #word #keyword #punctuation #comment."	| tokenTypePairs firstToken |	tokenTypePairs := self parseInstructionSource: source keywords: #().	firstToken := (tokenTypePairs first) key.	( #('action' 'to') includes: (firstToken asLowercase) )		ifTrue: [ tokenTypePairs at: 1 put: (firstToken -> #keyword) ].	^tokenTypePairs	! !!HumProgrammersAssistant class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/9/2015 08:12'!getCommentFromSource: aSourceString 	"Match '(...)' if any, and extract it from source."	| comment  |	"Note: Following assumes there is just one comment in the source.	If there is more than one comment, only the first one is returned."	comment := HumCalculator given: aSourceString extractIncludingMatching: '()'. 	^comment.! !!HumProgrammersAssistant class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 12/28/2015 13:14'!loadAndRenderFileNamed: aFilename	"Load ontology from text file, compile all frames, render as HTML.   *** NO SENDERS ***"	| pa html |	pa := self new.	pa loadOntologyFromTextFileNamed: aFilename.	pa ontology compileAllFrames.	html := pa ontology view renderAsHTMLonFileNamed: (aFilename, '.html').	^pa! !Object subclass: #HumTextEditor	instanceVariableNames: 'row column lines hasNewContent'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-IDE'!!HumTextEditor commentStamp: 'RichardAlexanderGreen 12/10/2015 10:59' prior: 0!Intended as a very simple, easy-to-understand, text editor.This editor is simpler than HumEditor. But, it does not (2015-12-10) support select operations, undo, redo.See: >>keyStroke: aCharacter for a summary of UI features.See Also: HumEditor HumText HumTextLine HumTextTokenNavigation Features:. Responds to up/down/left/right by moving cursor.. Beep if user attempts to move cursor beyond left margin or top row.Editing Features:. Respond to normal character by inserting character to left of cursor. . Respond to return by splitting the current line.. Respond to delete key by deleting character, if any, to left of cursor.. If cursor is at beginning of line, . . delete key will merge current line with prior line,. . and move remaining rows up.. Cursor is repositioned appropriately.Integration Features:. #keyStroke: responds to Character codes (ASCII-7 conventions).. Set "hasNewContent" flag when content has changed.. TODO: Add Announcement features.. TODO: Add MVC integration features.!!HumTextEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/19/2015 12:16'!currentLine	^self lineAt: (self row).! !!HumTextEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/19/2015 12:57'!column: anInteger 	"Move cursor to given column position."	column := anInteger.	(column < 1) ifTrue: [ column := 1.  self beep. ].! !!HumTextEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/19/2015 13:20'!lines	"PRIVATE: My text lines. 	Use '... lineAt: row' or 'currentLine' to access lines as strings."	^lines ifNil: [ lines := Dictionary new ].	! !!HumTextEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/19/2015 08:28'!lineAt: anInteger 	"Get string for given row"	| aLine |	aLine := (self lines) at: anInteger ifAbsent: [ '' ].	^aLine.! !!HumTextEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/19/2015 13:03'!currentLine: aString 	self lines at: (self row) put: aString.	self hasNewContent: true.! !!HumTextEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/19/2015 12:58'!cursorPosition	"Where is the insert point?"	^ (self row)@(self column).! !!HumTextEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/10/2015 10:42'!row: anInteger 	"Move cursor to given row position."	row := anInteger.	(row < 1) ifTrue: [ row := 1. self beep. ].	"Note: You can move row beyond current lines."! !!HumTextEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/19/2015 12:56'!row	"What is the current row position of the cursor?"	^row ifNil: [ row := 1 ].! !!HumTextEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/19/2015 12:56'!column	"What is the current column position of the cursor?"	^column ifNil: [ column := 1 ].! !!HumTextEditor methodsFor: 'navigating' stamp: 'RichardAlexanderGreen 5/19/2015 07:58'!bumpRow: anInteger 	self row: (self row) + anInteger.! !!HumTextEditor methodsFor: 'navigating' stamp: 'RichardAlexanderGreen 5/19/2015 12:15'!beep	"Signal that cursor is out-of-bounds."	Beeper beep.! !!HumTextEditor methodsFor: 'navigating' stamp: 'RichardAlexanderGreen 5/19/2015 08:07'!bumpColumn: anInteger 	self column: (self column) + anInteger.! !!HumTextEditor methodsFor: 'navigating' stamp: 'RichardAlexanderGreen 12/28/2015 13:25'!keyStroke: aCharacter	"Respond to simple keyboard input. (KISS: a character)	NOTE simplification: Input is a character, not an event."	| calc |	self assert: (aCharacter isKindOf: Character).	calc := HumCalculator new.	calc 		switch: aCharacter;		on: Character arrowUp do: [ self bumpRow: -1 ];				on: Character arrowDown do: [ self bumpRow:  1 ];		on: Character arrowLeft do: [ self bumpColumn: -1 ];		on: Character arrowRight do: [ self bumpColumn: 1 ];		on: Character cr do: [ self splitRow ];		on: Character delete do: [ self deleteOrMerge ];		otherwise: [ self insertCharacter: aCharacter ].	"NOTE: Character does not support control, command, or shift modes."		! !!HumTextEditor methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 7/23/2015 12:04'!drawTextOnPane: aHumPane font: aFont 	self assert: ( aHumPane isKindOf: HumPane).	self assert: ( aFont isKindOf: AbstractFont).  "I would prefer a vector-based font."	aHumPane textChanged: self.	! !!HumTextEditor methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 8/26/2015 21:49'!drawTextOnCanvas: aHumCanvas font: aFont 		aHumCanvas drawTextLines: (self lines) withFont: aFont	! !!HumTextEditor methodsFor: 'editing' stamp: 'RichardAlexanderGreen 5/19/2015 13:24'!hasNewContent: aBoolean 	"Set true whenever the content has been changed."	self assert: (aBoolean isKindOf: Boolean).	hasNewContent := aBoolean	"TODO: Notify watchers if the boolean is true."! !!HumTextEditor methodsFor: 'editing' stamp: 'RichardAlexanderGreen 5/19/2015 12:26'!splitRow	| currentLine linesAfter stringBefore stringAfter |	linesAfter := Dictionary new.	"Everything after the current row is moved down one."	(self lines)		keysAndValuesDo: [ :key :value |			(key > (self row))				ifTrue: [ linesAfter at: (key + 1) put: value ]				ifFalse: [ linesAfter at: key put: value ].			 ].	"Split the current line."	currentLine := self lineAt: (self row).	(self column > currentLine size)		ifTrue: [ currentLine := currentLine padRightTo: (self column - 1) ].	stringBefore := currentLine copyFrom: 1 to: (self column - 1).	stringAfter := currentLine copyFrom: (self column) to: (currentLine size).	self currentLine: stringBefore.	self bumpRow: 1.	self currentLine: stringAfter.	self column: 1.	self hasNewContent: true.! !!HumTextEditor methodsFor: 'editing' stamp: 'RichardAlexanderGreen 5/19/2015 12:30'!deleteOrMerge	"Delete character to left of cursor.	If cursor is at beginning of line, 	append current line to prior line and move everything up."	|  currentLine calc |	currentLine := self currentLine.	calc := HumCalculator new.	calc cases;		when: [ self cursorPosition = (1@1) ]			then: [ self beep ];		when: [ (column > 1) and: [ column > currentLine size ] ]			then: [ self bumpColumn: -1 ];			 when: [ column > 1 ]			then: [ |  stringBefore stringAfter  |				stringBefore := currentLine copyFrom: 1 to: ( column - 2 ).				stringAfter := currentLine copyFrom: column to: currentLine size.				self currentLine: (stringBefore, stringAfter).				];		when: [ column = 1 ] 			then: [ | stringBefore stringAfter linesAfter | 				stringBefore := self lineAt: (row-1).				stringAfter := currentLine.				self currentLine: ''.				self bumpRow: -1.				self currentLine: (stringBefore,stringAfter).				self column: stringBefore size + 1.				"Move remaining lines up"				linesAfter := Dictionary new.				(self lines)					keysAndValuesDo: [ :key :value |						(key > (row+1))							ifTrue: [ linesAfter at: (key - 1) put: value ]							ifFalse: [ linesAfter at: key put: value ].			 			].				lines := linesAfter.				];		otherwise: [ Error signal: 'How did we get here?' ].	! !!HumTextEditor methodsFor: 'editing' stamp: 'RichardAlexanderGreen 5/19/2015 13:21'!hasNewContent	"Has the content been changed? -- (Dirty data flag)"	^hasNewContent ifNil: [ hasNewContent := false ].! !!HumTextEditor methodsFor: 'editing' stamp: 'RichardAlexanderGreen 7/23/2015 17:40'!insertCharacter: aCharacter 	| currentLine stringBefore stringAfter |	currentLine := self lineAt: (self row).	(self column > currentLine size)		ifTrue: [ currentLine := currentLine padRightTo: (self column - 1) ].	stringBefore := currentLine copyFrom: 1 to: (self column - 1).	stringAfter := currentLine copyFrom: (self column) to: (currentLine size).	self currentLine: (stringBefore, aCharacter asString, stringAfter).	self bumpColumn: 1.	self hasNewContent: true.! !