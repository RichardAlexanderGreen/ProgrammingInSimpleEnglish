WAComponent subclass: #HumDialog	instanceVariableNames: 'attributes'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Seaside'!!HumDialog commentStamp: 'RichardAlexanderGreen 9/19/2012 10:37' prior: 0!HumDialog - provides a light-weight wrapper on the Seaside dialog facilities.- Logs interactions for debug / simulation / analysis.Instance Variables:	attributes	<Dictionary>!!HumDialog methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 9/30/2012 10:21'!ask: aSymbol 	"Ask, set, and return the requested attrbute."	| result |	"STUB"	^ 'HERE IS STUB ANSWER'	! !!HumDialog methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 9/11/2012 15:10'!ask: aString choice: anArrayOfSymbol	"The array of symbols liimits the user's choices"	self logDialogAction: 'Ask user to choose between: ', ( anArrayOfSymbol asString).	"*** THIS IS A STUB ***"	^ (anArrayOfSymbol at: 1).! !!HumDialog methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 9/6/2012 13:27'!askFile: aString 	"Initiate a file spec dialog."	| result |	self logDialogAction: 'Ask filename: ', aString.	result := self ask: #File.	^result.! !!HumDialog methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 9/30/2012 10:03'!askV00: aSymbol 	"Ask, set, and return the requested attrbute."	| result |	"*** THIS IS A MOCK ***"	result := aSymbol asString, ' - value'.	self attributes at: aSymbol put: result.	^result.! !!HumDialog methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 9/25/2012 10:03'!get: aSymbol 	"Return the requested attrbute."	| result |	result :=  self attributes at: aSymbol.	^result.! !!HumDialog methodsFor: 'test' stamp: 'RichardAlexanderGreen 8/16/2013 15:21'!renderView: anEntityID onCanvas: html	"Check generated code by pasting it below.	self halt.	TODO: Move this to Hum-Seaside."		html form with: [ 		html break. html heading level: 2; with: '!!!! Recipe'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #name toValue: datum ]; value: 'name'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #description toValue: datum ]; value: 'description'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #ingredients toValue: datum ]; value: 'ingredients'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #steps toValue: datum ]; value: 'steps'.		].	! !!HumDialog methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/19/2012 10:31'!attributes	^ attributes ifNil: [ attributes := Dictionary new. ].! !!HumDialog methodsFor: 'logging' stamp: 'RichardAlexanderGreen 9/6/2012 13:44'!logDialogAction: aString 	Transcript show: 'Dialog: ', aString; cr.! !WAComponent subclass: #HumBrowser	instanceVariableNames: 'dialog ontology contextDiagram nounDiagram planDiagram roleDiagram currentFrame layout hideDiagrams programmersAssistant worldBase'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Seaside'!!HumBrowser commentStamp: 'RichardAlexanderGreen 9/19/2012 10:28' prior: 0!HumBrowser - Seaside implementation of the Hum IDE (Interactive Development Environment).Instance Variables:	dialog	<HumDialog>	ontology	<HumOntology>	contextDiagram	<HumDiagram>	nounDiagram	<HumDiagram>	planDiagram	<HumDiagram>	roleDiagram	<HumDiagram>	currentFrame	<HumBrowserEditFrame>	layout	<Symbol>	hideDiagrams	<Boolean>!!HumBrowser methodsFor: 'rendering layout' stamp: 'RichardAlexanderGreen 9/12/2012 10:16'!hideDiagrams	^ hideDiagrams ifNil: [ hideDiagrams = False ].! !!HumBrowser methodsFor: 'rendering layout' stamp: 'RichardAlexanderGreen 9/12/2012 10:20'!hideDiagrams: aBoolean	^ hideDiagrams := aBoolean.! !!HumBrowser methodsFor: 'rendering layout' stamp: 'RichardAlexanderGreen 5/6/2013 07:21'!layout	"What style of browser layout (#rows or #columns)?	#rows ==> Diagrams, if present, are in a row. 	          Editor panes are in a row.	#columns ==> Diagrams, if present, are in a column. 	             Editor panes are in a column. 	"	^ layout ifNil: [ layout = #rows ].! !!HumBrowser methodsFor: 'rendering layout' stamp: 'RichardAlexanderGreen 5/6/2013 07:18'!layout: aSymbol	"What style of browser layout (#rows or #columns)?	#rows ==> Diagrams, if present, are in a row. 	          Editor panes are in a row.	#columns ==> Diagrams, if present, are in a column. 	             Editor panes are in a column. 	"	^ layout := aSymbol.! !!HumBrowser methodsFor: 'rendering layout' stamp: 'RichardAlexanderGreen 5/6/2013 07:53'!layoutWindowAsColumns	"*** This is a design document defining layout in Hum markup. ***	This layout is visually two columns with editor on left and diagrams on right."	| layoutWindow layoutEditorColumn layoutDiagramColumn layoutStatusBar layoutMenuBar |	"Hum view mark-up for the window layout.	This is like the traditional Smalltalk browser, 	but with a navigation column on left instead of a navigation row on top.	Since Hum relationships are not necessarily hierarchies, 	the navigation diagrams are not simple trees.	"	layoutWindow := '---View: Browser Window.. table|  [pane: Menu Bar]                                  |. table|  [pane: Editor Column]  |  [pane: Diagram Column]  |. table|  [pane: Status Bar]                                |'.	"The Source Frame Tabs are similar to Eclipse source code navigation.	The Frame Editor provides a syntax-aware and ontology-aware editor.	Syntax-aware means that it knows how to pretty-priint.	Ontology-aware means that it knows	- which words are nouns,	- which sentences have definitions (filled-in frames) 	- which views (panes) have definitions.	The Source Frame Critic identifies syntax and semantic problems	that are related to the current frame.	"	layoutEditorColumn := '[pane: Source Frame Tabs][pane: Source Frame Editor][pane: Source Frame Critic]'.	"The Diagram Column shows a set of diagram viewers.	A diagram can be brought full-screen (How? TBD).	Clicking on a diagram node causes the corresponding definition frame to be brought into the editor.	The Plan Tree diagram is like a precedence diagram. (It is not, strictly speaking, a tree but tends to have a similar branching structure.)	The Role Dependencies diagram has arrows showing which roles delegate actions to other roles.	The Noun Releations diagram arrows showing supertype, synonym, and attribute relations between nouns.	The Dialog Relations diagram arrows indicate when one dialog context raises another context.	(Dialogs have a context 'stack' that prioritizes pattern matching. 	A dialog may tell the dialog interpreter to raise another context to the top of the stack.)	"	layoutDiagramColumn := '[canvas: Plan Tree][canvas: Role Dependencies][canvas: Noun Relations][canvas: Dialog Relations]'.	"The menu bar is a row of tabs identical to common desktop window menus in operation.	See: #menuActions method for further definition and documentation."	layoutMenuBar := '[menu: Ontology]  [menu: edit]  [menu: view]  [menu: tools]  [menu: simulator]'.	"What does the user/programmer need in the status bar?	I am just guessing that we should answer:	- What ontology is being edited?  (name + file)	- What is the current status of the ontology?  (Is the ontology fully defined? )	- What hint/suggestion might we provide to the programmer? (But, what is the question?)	"	layoutStatusBar := 'Ontology: [ontology name] File: [ontology file] State: [ontology state] [IDE hint]'.! !!HumBrowser methodsFor: 'rendering layout' stamp: 'RichardAlexanderGreen 9/6/2012 10:30'!layoutWindowAsRows	"This layout is visually two rows with editor on bottom row and diagrams on top row."	| layoutWindow layoutEditorRow layoutDiagramRow layoutStatusBar layoutMenuBar |	"Hum view mark-up for the window layout.	This is like the traditional Smalltalk browser, 	 with a navigation row on top and a editor row on bottom.	Since Hum relationships are not necessarily hierarchies, 	the navigation diagrams are not simple trees.	"	layoutWindow := '[pane: Menu Bar][pane: Diagram Row][pane: Status Bar][pane: Editor Row]'.	"The Source Frame Tabs are similar to Eclipse source code navigation.	But in this case, the module names appear as a list on the left.	The Frame Editor provides a syntax-aware and ontology-aware editor.	Syntax-aware means that it knows how to pretty-priint.	Ontology-aware means that it knows	- which words are nouns,	- which sentences have definitions (filled-in frames) 	- which views (panes) have definitions.	The Source Frame Critic identifies syntax and semantic problems	that are related to the current frame.	"	layoutEditorRow := '[pane: Source Frame Tabs]  [pane: Source Frame Editor]  [pane: Source Frame Critic]'.	"The Diagram Row shows a set of diagram viewers.	A diagram can be brought full-screen (How? TBD).	Clicking on a diagram node causes the corresponding definition frame to be brought into the editor.	The Plan Tree diagram is like a precedence diagram. (It is not, strictly speaking, a tree but tends to have a similar branching structure.)	The Role Dependencies diagram has arrows showing which roles delegate actions to other roles.	The Noun Releations diagram arrows showing supertype, synonym, and attribute relations between nouns.	The Dialog Relations diagram arrows indicate when one dialog context raises another context.	(Dialogs have a context 'stack' that prioritizes pattern matching. 	A dialog may tell the dialog interpreter to raise another context to the top of the stack.)	"	layoutDiagramRow := '[canvas: Plan Tree]  [canvas: Role Dependencies]  [canvas: Noun Relations]  [canvas: Dialog Relations]'.	"The menu bar is a row of tabs identical to common desktop window menus in operation.	See: #menuActions method for further definition and documentation."	layoutMenuBar := '[menu: Ontology]  [menu: edit]  [menu: view]  [menu: tools]  [menu: simulator]'.	"What does the user/programmer need in the status bar?	I am just guessing that we should answer:	- What ontology is being edited?  (name + file)	- What is the current status of the ontology?  (Is the ontology fully defined? )	- What hint/suggestion might we provide to the programmer? (But, what is the question?)	"	layoutStatusBar := 'Ontology: [ontology name] File: [ontology file] State: [ontology state] [IDE hint]'.! !!HumBrowser methodsFor: 'rendering layout' stamp: 'RichardAlexanderGreen 9/25/2012 10:04'!menuActions	"Identify the actions that the user may invoke via menu navigation."	| mainMenu ontologyMenu editMenu layoutMenu force combinedMenu |	"A menu is a sequence of name -> action pairs.	We will store each menu in a Smalltalk OrderedCollection"	mainMenu := OrderedCollection new.	ontologyMenu := OrderedCollection new.	editMenu  := OrderedCollection new.	layoutMenu := OrderedCollection new.	"	The main menu simply provides a way to navigate to each sub-menu.	In main menu might be displayed on a top-navigation menu bar or on a (left) side navigation stub.	"	mainMenu 		add: 'Ontology' ->  [ self showSubMenu: ontologyMenu ];		add: 'Edit' -> [ self showSubMenu: editMenu ];		add: 'Layout' -> [ self showSubMenu: layoutMenu ].	"	The ontology menu provides actions affecting the ontology that is currently the subject/context of the Browser instance.	Content in parentheses below may be displayed or reserved as 'help hints'. (That could be a user preference option.)	Navigation via keyboard may follow the convention that the first letter of each menu entry is the key.	If the first letter of the first word is not unique, the first letter of the second word may be used.	Conventionally, the navigation letter may be indicated by underlining it in the menu list.	"	ontologyMenu		add: 'New Ontology (Start a new ontology.)' -> [ self clearOntology.  self ontology title: (self dialog ask: 'What is the new ontology`s name?' ) ];		add: 'Open Ontology (Open an existing ontology.)' -> [ self clearOntology.  self loadOntologyFile: (self dialog askFile: 'Where (what file/URI) is the ontology?')];		add: 'Save Ontology (Save the current state of this ontology.)' -> [ self saveOntology. ]; 		"* Save will overwrite an existing file without asking If file is not known, it will dialog for a file name. (Relatively harmless if we have infinite undo.)"		add: 'Save As . . .  (Save this ontology in a specific file.)' -> [ self ontology file: ( self dialog askFile: 'What file?')];		"* I expect Save-As to be used like it is in Smalltalk - as a kind of poor-man's source code label mechanism."		add: '---' -> [];		add: 'Render as . . . (Document the ontology in PDF or HTML? )' -> [ self ontology renderAs: ( self dialog ask: 'Document the ontology in PDF or HTML format?' choice: #( #PDF #HTML )  )  ].		"	The edit menu provides a way to open the editor on new frames.	The edit menu provides an additional way to navigate to existing frames.	The general idea is that the programmer identifies the type of frame	and then the resulting dialog identifies the particular frame.	"	editMenu		add: 'Plan (Edit a plan frame.)' -> [self editPlanFrame: ( self dialog ask: #Plan) ];		add: 'Action (Edit a role-action frame.)' -> [self dialog ask: #( #Role #Action ). 													self editActionFrame: (self dialog get: #Action) forRole: (self dialog get: #Role) ];		add: 'Dictionary (Edit a dictionary frame.)' -> [ self editDictionaryFrame: ( self dialog ask: #Dictionary ).];		add: 'Dialog Context (Edit a dialog-context frame.)' -> [self editDialogFrame: ( self dialog ask: #( #Dialog #Context ) )];		add: 'View Pane (Edit a view-pane frame.)' -> [self editViewFrame: ( self dialog ask: #Pane )  ].	"	The layout menu provides the means for the user to change the layout of the browser window.	The user may switch between column and row layouts. (See: #layoutWindowAsColumns and #layoutWindowAsRows. )	The user may toggle to and from a full-screen for the browser window itself.	In some situations, the user may wish to hide/suppress the diagrams.	"	layoutMenu 		add: 'Full Screen (Toggle this browser window to/from full-sceen.)' -> [ self toggleFullScreen ];		add: 'Transpose Layout (Tranpose the browser layout between row mode and column mode.)' -> [ self transposeLayout ];		add: 'Hide Diagrams (Hide or Un-hide the diagram panes.)' -> [ self toggleDiagramView ]. 	"The following will force each menu action to be defined, if not implemented."	force := [ :menu | 		menu do: [ :menuItem | 			| action |			action := menuItem value.			"Evaluate the block to force the selectors it references to be created."			action value.			]		].	"force value: ontologyMenu."	combinedMenu := ( ontologyMenu, editMenu, layoutMenu ).	^ combinedMenu.! !!HumBrowser methodsFor: 'rendering layout' stamp: 'RichardAlexanderGreen 9/12/2012 10:20'!toggleDiagramView	self logUserAction: 'Toggle Diagrams (Hide / Un-Hide)'.	self hideDiagrams: ( self hideDiagrams not ).! !!HumBrowser methodsFor: 'rendering layout' stamp: 'RichardAlexanderGreen 9/6/2012 13:08'!toggleFullScreen	self logUserAction: 'Toggle full screen.'! !!HumBrowser methodsFor: 'rendering layout' stamp: 'RichardAlexanderGreen 9/14/2012 13:06'!transposeLayout	self logUserAction: 'Transpose browser layout'.	(self layout = #rows ) 		ifTrue: [ self layout: #columns] 		ifFalse: [self layout: #rows ].! !!HumBrowser methodsFor: 'logging' stamp: 'RichardAlexanderGreen 9/6/2012 13:13'!log: aString	"Use #logUserAction instead."	self shouldNotImplement.! !!HumBrowser methodsFor: 'logging' stamp: 'RichardAlexanderGreen 9/6/2012 13:27'!logUserAction: aString	"Log the user action for potential analysis / diagnosis.	Currently this is a dummy that just sends to the trarnscript."	Transcript show: 'User Action: ', aString; cr.! !!HumBrowser methodsFor: 'diagrams' stamp: 'RichardAlexanderGreen 9/10/2012 13:04'!contextDiagram	^ contextDiagram ifNil: [ contextDiagram := HumDiagram new title: 'Context Diagram '].! !!HumBrowser methodsFor: 'diagrams' stamp: 'RichardAlexanderGreen 9/10/2012 13:05'!nounDiagram	^ nounDiagram ifNil: [ nounDiagram := HumDiagram new title: 'Noun Diagram '].! !!HumBrowser methodsFor: 'diagrams' stamp: 'RichardAlexanderGreen 9/10/2012 13:05'!planDiagram	^ planDiagram ifNil: [ planDiagram := HumDiagram new title: 'Plan Diagram '].! !!HumBrowser methodsFor: 'diagrams' stamp: 'RichardAlexanderGreen 9/10/2012 13:06'!roleDiagram	^ roleDiagram ifNil: [ roleDiagram := HumDiagram new title: 'Role Diagram '].! !!HumBrowser methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 5/6/2013 07:38'!layoutDiagramsAsColumnOnCanvas: aWAHtmlhtml	| html |	html := aWAHtmlhtml.	^ html div		class: 'DiagramColumn';		with: [ 					"html label: 'Diagram Column'.			html break."					html table						with: [ 							| diagramWidth "Table with one column and four rows. Each row has a diagram" diagramHeight |							diagramWidth := 400.							diagramHeight := 160.								"Draw plan diagram on this html."							{ self planDiagram. self roleDiagram. self nounDiagram. self contextDiagram.}								do: [ :diagram | "For each diagram:"									   html tableRow "<tr>" 														with: [ html tableData "<td>"																					with: [ diagram asSVGonHtmlCanvas: html 																														 				 width: diagramWidth 																																		height: diagramHeight ] 																				]. "tableData"																	]. "tableRow"							]. "table"						]. "div"! !!HumBrowser methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 5/6/2013 07:42'!layoutDiagramsAsRowOnCanvas: aWAHtmlCanvas	| html |	html := aWAHtmlCanvas.	html div 			class: 'DiagramRow'; 			with: [				"html label: 'Diagram Row'.				html break."				html table with: [ "Table with one Row and four rows. Each row has a diagram"					| diagramWidth diagramHeight |					diagramWidth := 320.					diagramHeight := 320.										html tableRow with: [ "<tr>"						{ self planDiagram. self roleDiagram. self nounDiagram. self contextDiagram. }							do: [ :diagram | "For each diagram:"								html tableData "<td>"								         with: [ self planDiagram asSVGonHtmlCanvas: html  																														width: diagramWidth 																														height: diagramHeight. 															]. "end tableData"								]. "end do"						].  "end table row"					].  "end table"				]. "end with"! !!HumBrowser methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 5/6/2013 07:49'!layoutMenuActionsAsColumnOnCanvas: html	"Identify the actions that the user may invoke via menu navigation."	| mainMenu ontologyMenu editMenu layoutMenu force combinedMenu verb |	"A menu is a sequence of name -> action pairs.	We will store each menu in a Smalltalk OrderedCollection"	mainMenu := OrderedCollection new.	ontologyMenu := OrderedCollection new.	editMenu  := OrderedCollection new.	layoutMenu := OrderedCollection new.	"	The main menu simply provides a way to navigate to each sub-menu.	In main menu might be displayed on a top-navigation menu bar or on a (left) side navigation stub.	"	mainMenu 		add: 'Ontology' -> [ self showSubMenu: ontologyMenu title: 'Ontology' onCanvas: html ];		add: 'Edit'     -> [ self showSubMenu: editMenu     title: 'Edit'     onCanvas: html ];		add: 'Layout'   -> [ self showSubMenu: layoutMenu   title: 'Layout'   onCanvas: html ].	"	The ontology menu provides actions affecting the ontology that is currently the subject/context of the Browser instance.	Content in parentheses below may be displayed or reserved as 'help hints'. (That could be a user preference option.)	Navigation via keyboard may follow the convention that the first letter of each menu entry is the key.	If the first letter of the first word is not unique, the first letter of the second word may be used.	Conventionally, the navigation letter may be indicated by underlining it in the menu list.	"	ontologyMenu		add: 'New Ontology (Start a new ontology.)' 					-> [ self clearOntology.  self ontology title: (self dialog ask: 'What is the new ontology`s name?' ) ];		add: 'Open Ontology (Open an existing ontology.)' 					-> [ self clearOntology.  self loadOntologyFile: (self dialog askFile: 'Where (what file/URI) is the ontology?')];		add: 'Save Ontology (Save the current state of this ontology.)' 					-> [ self saveOntology. ]; 		"* Save will overwrite an existing file without asking. 		   If file is not known, it will dialog for a file name. 		   (Relatively harmless if we have infinite undo.)"		add: 'Save As . . .  (Save this ontology in a specific file.)' 					-> [ self ontology file: ( self dialog askFile: 'What file?')];		"* I expect Save-As to be used like it is in Smalltalk 				- as a kind of poor-man's source code label mechanism."		add: '---' -> [];		add: 'Render as . . . (Document the ontology in PDF or HTML? )' 					-> [ self ontology renderAs: ( self dialog ask: 'Document the ontology in PDF or HTML format?' 																								choice: #( #PDF #HTML )  )  ].		"	The edit menu provides a way to open the editor on new frames.	The edit menu provides an additional way to navigate to existing frames.	The general idea is that the programmer identifies the type of frame	and then the resulting dialog identifies the particular frame.	"	editMenu		add: 'Plan (Edit a plan frame.)' 					-> [self editPlanFrame: ( self dialog ask: #Plan) ];		add: 'Action (Edit a role-action frame.)' 					-> [self editActionFrame: ( self dialog ask: #( #Role  #Action )  ) ];		add: 'Dictionary (Edit a dictionary frame.)' 					-> [ self editDictionaryFrame: ( self dialog ask: #Dictionary ).];		add: 'Dialog Context (Edit a dialog-context frame.)' 					-> [self editDialogFrame: ( self dialog ask: #( #Dialog #Context ) )];		add: 'View Pane (Edit a view-pane frame.)' 					-> [self editViewFrame: ( self dialog ask: #Pane )  ].	"	The layout menu provides the means for the user to change the layout of the browser window.	The user may switch between column and row layouts. (See: #layoutWindowAsColumns and #layoutWindowAsRows. )	The user may toggle to and from a full-screen for the browser window itself.	In some situations, the user may wish to hide/suppress the diagrams.	"	"Hide or UnHide"	( self hideDiagrams ) 		ifTrue: [  verb := 'Show ' ] 		ifFalse: [ verb := 'Hide '].	layoutMenu 		add: 'Full Screen (Toggle this browser window to/from full-sceen.)' 					-> [ self toggleFullScreen ];		add: 'Transpose Layout (Tranpose the browser layout between row mode and column mode.)' 					-> [ self transposeLayout ];				add: (verb, ' Diagrams (Hide or Un-hide the diagram panes.)') 					-> [ self toggleDiagramView ]. 	"Render the main menu"      html div 		class: 'MenuColumn'; 		style: 'background: LightYellow; padding: 1em;';		with: [		html strong: 'Menu'.		self showSubMenu: ontologyMenu 	title: 'Ontology' 	onCanvas: html.		self showSubMenu: editMenu 			title: 'Edit' 			onCanvas: html.		self showSubMenu: layoutMenu 		title: 'Layout' 		onCanvas: html.		].! !!HumBrowser methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 5/6/2013 07:58'!layoutWindowAsColumnsOnCanvas: aWAHtmlCanvas	"This layout is visually two columns with editor on left and diagrams on right."	| layoutWindow layoutEditorColumn layoutDiagramColumn layoutStatusBar layoutMenuBar html  htmlStatusBar |	"Layout the Window as a table with three rows."	html := aWAHtmlCanvas.	htmlStatusBar := [ :canvas | 	canvas div		class: 'StatusBar';		with: 'Ontology title: " ' , self ontology title , ' " file: ' , self ontology file ].		"Finally we generate the window contents by calling the functions [blocks] that we defined above."		"html render: [ htmlMenuBar value: html ].	html break."	html table		with: [ 			html tableRow				with: [ 					"Editor Column and Diagram Column"					html tableData						attributeAt: 'valign' put: 'TOP';						with: [ self layoutMenuActionsAsColumnOnCanvas: html ].					html tableData						attributeAt: 'valign' put: 'TOP';						with: [ 									htmlStatusBar value: html.									html break.									self currentFrame layoutFrameAsColumnsOnCanvas: html ].					self hideDiagrams						ifFalse: [ 							html tableData								attributeAt: 'valign' put: 'TOP';								with: [ self layoutDiagramsAsColumnOnCanvas: html ] ] ] ]! !!HumBrowser methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 10/6/2012 11:18'!layoutWindowAsRowsOnCanvas: aWAHtmlCanvas	"This layout is visually two Rows with diagrams in top row and editor in lower row."	| layoutWindow layoutEditorPane layoutDiagramRow  layoutMenuBar 	  html    htmlOntologyLabel  cr  |	"Layout the Window as a table with three rows."	cr := String cr.	html := aWAHtmlCanvas.		htmlOntologyLabel := [ :canvas |  		canvas div class: 'OntologyLabel'; 			with: ('Ontology title: " ', self ontology title, ' " file: ', (self ontology file) )].		"Finally we generate the window contents by calling the functions [blocks] that we defined above."	"html render: [ htmlMenuBar value: html ].	html break."	html table 		with: [ 			self hideDiagrams 				ifFalse: [html tableRow with: [ html tableData attributeAt: 'valign' put: 'TOP'; with: [ self layoutDiagramsAsRowOnCanvas: html ].].].						html tableRow 				with: [ "Editor Pane and Diagram Row"				   html table with: [ 					html tableRow					with: [						html tableData							attributeAt: 'valign' put: 'TOP';							with: [ self layoutMenuActionsAsColumnOnCanvas: html ].				   		html tableData  							attributeAt: 'valign' put: 'TOP';							with: [ htmlOntologyLabel value: html.								html break.								self currentFrame layoutFrameAsRowsOnCanvas: html ]. "tableData with"						]. "inner tableRow"					 ]. "inner table"				].	"outer tableRow"				]. "outer table"		! !!HumBrowser methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 9/12/2012 09:54'!renderContentOn: html	( self layout = #columns ) 		ifTrue:  [ self layoutWindowAsColumnsOnCanvas: html.]		ifFalse: [ self layoutWindowAsRowsOnCanvas: html].	! !!HumBrowser methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 9/11/2012 15:57'!showSubMenu: aMenu title: aString onCanvas: html	"aMenu is an OrderedCollection of ( name -> action ).	To display it we need only show the list of names.	The question is where and how do we show the list?	"	html break; break; emphasis: aString.	aMenu do: [ :menuItem | "Make an anchor for each menu item."				| x commandWithHelp command action |		commandWithHelp := menuItem key.		action := menuItem value.		x := commandWithHelp indexOf: $(.		( x > 0 )			ifTrue: [				command := commandWithHelp copyFrom: 1 to: (x - 1).				html break.  html anchor class: 'menu'; callback: action; with: command. 				]			ifFalse: ["Assume its a separator"				html break; text: '---'.				].		].! !!HumBrowser methodsFor: 'ontology' stamp: 'RichardAlexanderGreen 9/6/2012 13:10'!clearOntology	self logUserAction: 'Clear ontology: ', (self ontology title).! !!HumBrowser methodsFor: 'ontology' stamp: 'RichardAlexanderGreen 10/12/2012 10:49'!loadOntologyFile: aFileSpec 	self logUserAction: 'Load ontology from file: ', aFileSpec.	"To be consistent with Hum design ideas, we will use a WorldBase instead of local file."	self deprecated.! !!HumBrowser methodsFor: 'ontology' stamp: 'RichardAlexanderGreen 10/18/2012 08:14'!loadOntologyInstance: ontologyTitle 	|   |	self logUserAction: 'Load ontology instance: ', ontologyTitle.	self assert: (self worldBase isKindOf: HumWorldBase).    "Initialize / Replace my ontology instance."	ontology := (self worldBase) getEntityID: ontologyTitle attribute: #title.	(ontology isNil)		ifTrue: [ontology := HumOntology new.				ontology title: ontologyTitle. ].	^ontology.! !!HumBrowser methodsFor: 'ontology' stamp: 'RichardAlexanderGreen 9/24/2012 18:58'!newOntology	"Start with a fresh new ontology and clear any related views."	self logUserAction: 'New ontology'.	self ontology: ( HumOntology new ).! !!HumBrowser methodsFor: 'ontology' stamp: 'RichardAlexanderGreen 10/12/2012 09:53'!openOntology	"Clear all views and load an ontology from a save file."	| fileName |	self logUserAction: 'Open ontology'.	fileName := self openOntologyDialog.! !!HumBrowser methodsFor: 'ontology' stamp: 'RichardAlexanderGreen 9/11/2012 10:40'!printOntology	"Document the current ontology in a HTML document"	self logUserAction: 'Print ontology'.! !!HumBrowser methodsFor: 'ontology' stamp: 'RichardAlexanderGreen 9/25/2012 09:38'!saveOntology	"Write the current ontology into a save file."	self logUserAction: 'Save ontology'.	( self programmersAssistant ) saveOntologyOnFileNamed: ( self ontology file ).! !!HumBrowser methodsFor: 'frames' stamp: 'RichardAlexanderGreen 9/25/2012 09:58'!editActionFrame: aTitleString forRole: aRoleString	"Create / View / Edit the frame with the given title."	self logUserAction: 'Edit action frame: {', aRoleString, ':', aTitleString,'}'.! !!HumBrowser methodsFor: 'frames' stamp: 'RichardAlexanderGreen 9/6/2012 20:34'!editDialogFrame: aString 	"Create / View / Edit the frame with the given title."	|   |	self logUserAction: 'Edit dialog frame: ', aString.! !!HumBrowser methodsFor: 'frames' stamp: 'RichardAlexanderGreen 9/11/2012 13:13'!editDictionaryFrame: aString 	"Create / View / Edit the frame with the given title."	|   |		self logUserAction: 'Edit dictionary frame: ', aString.! !!HumBrowser methodsFor: 'frames' stamp: 'RichardAlexanderGreen 9/30/2012 11:13'!editPlanFrame: aString 	"Create / View / Edit the frame with the given title. (Use goal statement as title.)"	|  result |	self currentFrame title: 'Enter the goal statement for the frame.'! !!HumBrowser methodsFor: 'frames' stamp: 'RichardAlexanderGreen 9/6/2012 20:35'!editViewFrame: aString 	"Create / View / Edit the frame with the given title."	|   |		self logUserAction: 'Edit View Frame: ', aString.! !!HumBrowser methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/3/2012 17:42'!currentFrame	"What frame is currently being editted?"	^ self session currentFrame.! !!HumBrowser methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/6/2012 12:50'!dialog	^ dialog ifNil: [ dialog := HumDialog new. ].! !!HumBrowser methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/6/2012 13:15'!ontology	^ ontology ifNil: [ ontology := HumOntology new. ].! !!HumBrowser methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/25/2012 09:35'!programmersAssistant	^ programmersAssistant ifNil: [ programmersAssistant := HumProgrammersAssistant new ].! !!HumBrowser methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/18/2012 07:27'!worldBase	"Default is a TEST world base."	^ worldBase ifNil: [ worldBase := HumWorldBase openWorldBase: 'Test'. ].! !!HumBrowser methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/18/2012 07:44'!worldBase: aHumWorldBase 	"Initialize / Replace my world base reference."	worldBase := aHumWorldBase.! !!HumBrowser methodsFor: 'initialization' stamp: 'RichardAlexanderGreen 9/10/2012 11:14'!initialize	super initialize.! !!HumBrowser methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 10/12/2012 09:55'!openOntologyDialog	self shouldBeImplemented.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumBrowser class	instanceVariableNames: ''!!HumBrowser class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/3/2012 17:39'!initialize	|application|	application := WAAdmin register: self asApplicationAt: 'HumBrowser'.	application preferenceAt: #sessionClass put: HumBrowserSession.	! !!HumBrowser class methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 9/11/2012 12:51'!newFrame	self shouldBeImplemented.! !!HumBrowser class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/11/2012 13:13'!dialog	self shouldBeImplemented.! !WASession subclass: #HumBrowserSession	instanceVariableNames: 'currentFrame'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Seaside'!!HumBrowserSession methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/3/2012 17:41'!currentFrame	"What frame is currently being editted?"	^ currentFrame ifNil: [ currentFrame :=  HumBrowserEditFrame new. ].! !WAComponent subclass: #HumBrowserEditFrame	instanceVariableNames: 'frameCode title lastSaved critic frameType'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Seaside'!!HumBrowserEditFrame commentStamp: 'RichardAlexanderGreen 10/26/2012 08:40' prior: 0!HumBrowserEditFrame is a component of a HumBrowser.It implements the UI for a code editor on an ontology frame.See also: HumFrameEditor.See also: HumFrame and its subtypes.Instance Variables:	frameCode	<String>	title			<String>	lastSaved	<String>	critic			<String>!!HumBrowserEditFrame methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 10/6/2012 10:56'!layoutFrameAsColumnsOnCanvas: aWAHtmlCanvas	"Generate the column style layout"	| canvas |	canvas := aWAHtmlCanvas.	canvas div 			class: 'EditorPane'; 			with: [				canvas form with: [					canvas label: ' Frame: '.					canvas textInput "readonly: False;" size: ( 5+ (self  title size ) ); on: #title of: (self ).					canvas label: ' Last Saved: '.					canvas textInput  readonly: True; size: 35; on: #lastSaved of: (self ).					canvas submitButton callback: [ self  lastSaved: (TimeStamp now asString). ]; value: ' Save '.					canvas table with: [ "Rows for editor and critc."					   canvas tableRow						with: [ canvas tableData 								attributeAt: 'valign' put: 'TOP';								with: [ canvas textArea rows: 40; columns: 80; 										             on: #frameCode of: (self ).									   ] . "tableData"						]. "tableRow"					canvas tableRow						with: [ canvas tableData 								attributeAt: 'valign' put: 'TOP';								with: [ canvas textArea rows: 10; columns: 80; readonly: True; 									                 on: #critic of: (self)  . 									]. "tableData"							 ].	"tableRow"						]. "table"				]. "form"			]. "div"	! !!HumBrowserEditFrame methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 10/6/2012 11:30'!layoutFrameAsRowsOnCanvas: aWAHtmlCanvas	"Generate the row style layout."	| canvas |	canvas := aWAHtmlCanvas.	canvas div 		class: 'EditorPane'; 		with: [			canvas form with: 				[				canvas label: ' Frame: '.				canvas textInput 					"readonly: False; " 					size: ( 5+ (self title size ) ); 					on: #title of: (self).				canvas label: ' Last Saved: '.				canvas textInput  					readonly: True; size: 35; 					on: #lastSaved of: (self).				canvas submitButton 					callback: [ self lastSaved: (TimeStamp now asString). ]; 					value: ' Save '.				canvas table with: [ "Rows for editor and critic."				   canvas tableRow					with: [ "Editor pane contains two columns with editor on left and critic on right."							canvas tableData 								attributeAt: 'valign' put: 'TOP';								with: [ canvas textArea rows: 25; columns: 80;  													on: #frameCode of: (self). 													] . "tableData"							canvas tableData 								attributeAt: 'valign' put: 'TOP';								with: [ canvas textArea rows: 25; columns: 40; readonly: True; 													on: #critic of: (self)  . 													]. "tableData"							 ].	"end row"								]. "end table"	 			] .  "end form"			] "end div"! !!HumBrowserEditFrame methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 10/6/2012 09:57'!renderContentOn: html	( self parent layout = #columns ) 		ifTrue:  [ self layoutFrameAsColumnsOnCanvas: html.]		ifFalse: [ self layoutFrameAsRowsOnCanvas: html].	! !!HumBrowserEditFrame methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 10/3/2012 14:39'!trace: aString	Transcript show: 'HumBrowereEditFrame - trace: ', aString; cr.! !!HumBrowserEditFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/3/2012 17:04'!critic	^ critic ifNil: [ critic := '*** No frame critique yet ***' ].! !!HumBrowserEditFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/3/2012 18:07'!critic: aTextString	"This is a dummy to accomodate a side-effect of using a TextArea to display the critique.	A client or internal that wants to reset the critic should call #setCritique: instead.	"	|  |		"self trace: 'critc called with: ', aTextString. "	self setCritique: aTextString.! !!HumBrowserEditFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/3/2012 16:46'!fetchCodeForTitle: aString	| cr indent |	cr := String cr.	indent := '. ', cr.	self frameCode: 'Goal: ', aString, cr, 'Preconditions: ', cr, indent, indent, indent, 'Action: ', cr, indent.! !!HumBrowserEditFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/3/2012 18:06'!firstLine	| result |	result := (self frameCode) copyUpTo: (Character cr).	^ result.	! !!HumBrowserEditFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2012 10:59'!frameCode	^ frameCode ifNil: [ frameCode := '*** No frame code yet. ***']! !!HumBrowserEditFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/3/2012 16:41'!frameCode: aTextString	| border |	border := String cr, '---', String cr.	self assert: (aTextString isKindOf: String).	frameCode := aTextString.	self trace: 'frameCode reset to: ', border, frameCode, border.	self runCritic.! !!HumBrowserEditFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/3/2012 17:48'!initialize	| |	super initialize.	self trace: 'edit frame initialized.'! !!HumBrowserEditFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2012 12:03'!lastSaved	^ lastSaved ifNil: [ lastSaved := '*** NOT SAVED YET ***' ].! !!HumBrowserEditFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2012 12:27'!lastSaved:  anObject	(anObject isKindOf: String ) 		ifTrue: [ lastSaved := anObject ]		ifFalse: [ lastSaved := anObject asString ].	! !!HumBrowserEditFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/3/2012 18:04'!runCritic	"Run the ontology critic that is appropriate to this type of frame."	self critic: ('Critic does not know how to critique: ', (self firstLine) ).! !!HumBrowserEditFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/3/2012 14:45'!setCritique: aTextString	"Set the critique value.	"	critic := aTextString.	self trace: 'critique reset to: ', critic .! !!HumBrowserEditFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/30/2012 11:01'!title	^ title ifNil: [ title := 'TBD']! !!HumBrowserEditFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/3/2012 16:59'!title: aString	| oldTitle cr indent |	oldTitle := (self title).	( aString = oldTitle ) ifTrue: [^self].	self halt.	self trace: 'title reset to: ', aString.	"Otherwise -- fetch the code for the new title."	self fetchCodeForTitle: aString.! !HumBrowser initialize!