Object subclass: #HumGraph	instanceVariableNames: 'connectionLabels nodeLabels'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Graph'!!HumGraph commentStamp: 'RichardAlexanderGreen 3/26/2015 10:22' prior: 0!HumGraph is a simple directed graph.Instance Variables:	connectionLabels	<Set>	nodeLabels	<(Collection of: Object)>!!HumGraph methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 5/5/2015 11:50'!countNeighborsOfNode: aNode	"Return the number of neighbors of this node.	 (Count nodes that are directly connected to this node)"	| count |	count := 0.	( self connections ) 		do: [ :map | (((map key) = aNode) or: [(map value) = aNode]) 			ifTrue: [ count := count + 1 ] ].	^ count! !!HumGraph methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 8/8/2016 11:09'!hasCycle	"Does the graph contain at least one cycle?"	| |	nodeLabels		do: [:nodeLabel |			| label rootNode downStream |			label := nodeLabel at: 1.			rootNode := nodeLabel at: 2.			"downStreamFrom: will not extend leafs that match root"			downStream := self nodesDownStreamFrom: rootNode.			((downStream leafNodes) include: rootNode) ifTrue: [^true].			].	^false.! !!HumGraph methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 8/8/2016 11:33'!nodesDownStreamFrom: aRootNode 	"Collect the nodes that are down-stream from a root node."	| upStream downStream |	"Set up recursive loop."	upStream := Set new.	"Avoid cycles."	downStream := self nodesDownStreamFrom: aRootNode butNotIn: upStream.	^downStream.	! !!HumGraph methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 8/8/2016 11:34'!nodesDownStreamFrom: aRootNode butNotIn: upStreamNodes 	"Find nodes that are down-stream from the root node but not in the upStreamNodes."	| downStreamNodes immediateBranchNodes |	"Note: It is possible for a pair of nodes to have more than one relationship."	immediateBranchNodes := Set new.	(self connectionLabels)		do: [ :connectionLabel |			| association label fromNode toNode | 			"Unpack the tuple."			association := connectionLabel at: 1.			label := connectionLabel at: 2.			fromNode := association key.			toNode := association value.			(fromNode = aRootNode) ifTrue: [ immediateBranchNodes add: toNode ].			].	downStreamNodes := immediateBranchNodes.	"TODO: ADD RECURSION AFTER THIS IS DEBUGGED."	^downStreamNodes.	! !!HumGraph methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/22/2013 19:45'!nodes	"Return the nodes in this graph."	| bagNodes |	bagNodes := Bag new.	(self nodeLabels)		do: [ :entry |			"entry looks like {  label. object. }"			bagNodes add: (entry at: 2 ).			].	^bagNodes.! !!HumGraph methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/22/2013 19:36'!addNode: anObject label: aString	"Add the given object to the set of nodes"	" Note that each object / node is unique"	( self nodeLabels ) add: { aString. anObject. }! !!HumGraph methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/8/2016 10:33'!addNode: anObject 	"Add the given object to the set of nodes"	" Note that each object / node is unique"	self addNode: anObject label: (anObject asString).! !!HumGraph methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/8/2016 10:05'!connectionLabels	"Note: A pair of nodes may have more than one relation."	"See: #addConnection:label:"	^ connectionLabels ifNil: [ connectionLabels := Set new ].! !!HumGraph methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/8/2016 10:34'!addConnection: anAssociation 	Error signal: 'a connection without a label is bad practice.'.	self addConnection: anAssociation label: 'unknown'.! !!HumGraph methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/22/2013 19:38'!nodeLabels	^nodeLabels ifNil: [ nodeLabels := Set new ].! !!HumGraph methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/10/2016 11:04'!addConnection: anAssociation label: aString	"Note: A pair of nodes may have more than one relation."	| fromNode toNode |	"Make sure the nodes are in the node set."	fromNode := anAssociation key.	toNode := anAssociation value.	self addNode: fromNode.	self addNode: toNode.	"In this set, there can be more than one per association."	( self connectionLabels ) add: { anAssociation. aString. }.! !!HumGraph methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/10/2016 10:55'!connections	"Return the connections (associations) in this graph."	| bagConnections |	bagConnections := Bag new.	(self connectionLabels)		do: [ :entry |			"entry looks like {  association. label.  }"			bagConnections add: (entry at: 1 ).			].	^bagConnections.! !!HumGraph methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 8/8/2016 11:30'!connectionsFrom: aNode 	"Get the outbound connections from this node. "	| outboundConnections |	outboundConnections := Set new.	(self connectionLabels)		do: [ :connectionLabel |				| association label fromNode toNode |				association := connectionLabel at: 1.				label := connectionLabel at: 2.				fromNode := association key.				toNode := association value.				(fromNode = aNode) 						ifTrue: [ outboundConnections add: connectionLabel ].			 ].	^outboundConnections.! !HumTestCase subclass: #HumGraphTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Graph'!!HumGraphTests methodsFor: 'access tests' stamp: 'RichardAlexanderGreen 4/17/2015 21:22'!test160DetectCycle	"A graph has a collection (set) of nodes"	| graph nodeA nodeB nodeC |	false ifFalse: [ Transcript cr; show: 'test160DetectCycle is turned off.'. ^self.].	graph := HumGraph new.	self assert: ( graph nodes isEmpty ).		nodeA := 'A'.	graph addNode: nodeA label: 'nodeA'.	nodeB := 'B'.	graph addNode: nodeB label: 'nodeB'.	nodeC := 'C'.	graph addNode: nodeC label: 'nodeC'.	graph addConnection: ( nodeA -> nodeB ) label: 'A to B'.	graph addConnection: ( nodeB -> nodeC ) label: 'B to C'.	self assert: (graph hasCycle) not.	graph addConnection: ( nodeC -> nodeA ) label: 'C to A creates cycle'.	self assert: (graph hasCycle).		! !!HumGraphTests methodsFor: 'access tests' stamp: 'RichardAlexanderGreen 8/8/2016 10:29'!test120GraphHasConnections	"A graph has a collection (set) of connections."	| graph |	graph := HumGraph new.	self assert: ( graph connections isEmpty ).! !!HumGraphTests methodsFor: 'access tests' stamp: 'RichardAlexanderGreen 8/8/2016 10:28'!test150PutGetLabeledConnections	"A graph has a collection (set) of connections"	| graph nodeA nodeB |	graph := HumGraph new.	self assert: ( graph nodes isEmpty ).		nodeA := 'My content just happens to be a string but I could be any kind of object'.	graph addNode: nodeA.	self assert: ( graph nodes size = 1 ).		nodeB := 'My content also just happens to be a string but I could be any kind of object'.	graph addNode: nodeB.	self assert: ( graph nodes size = 2 ).		graph addConnection: ( nodeA -> nodeB ) label: 'A to B'.	self assert: ( graph connections size = 1 ).		graph addConnection: ( nodeB -> nodeA ) label: 'B to A'.	self assert: ( graph connections size = 2 ).		graph addConnection: ( nodeA -> nodeB ) label: 'A to B again'.	self assert: ( graph connections size = 3 ).! !!HumGraphTests methodsFor: 'access tests' stamp: 'RichardAlexanderGreen 1/22/2014 17:31'!test110GraphHasNodes	"A graph has a collection (set) of nodes"	| graph |	graph := HumGraph new.	self assert: ( graph nodes isEmpty ).! !!HumGraphTests methodsFor: 'access tests' stamp: 'RichardAlexanderGreen 8/8/2016 10:36'!test140PutGetConnector	"A graph has a collection (set) of connections."	| graph node node2 |	graph := HumGraph new.	self assert: ( graph nodes isEmpty ).		node := 'My content just happens to be a string but I could be any kind of object'.	graph addNode: node.	self assert: ( graph nodes size = 1 ).		node2 := 'My content also just happens to be a string but I could be any kind of object'.	graph addNode: node2.	self assert: ( graph nodes size = 2 ).		graph addConnection: ( node -> node2 ) label: 'A connection represents some kind of relationship.'.	self assert: ( graph connections size = 1 ).! !!HumGraphTests methodsFor: 'access tests' stamp: 'RichardAlexanderGreen 8/8/2016 11:37'!test152PutGetParallelConnections	"A graph has a collection (set) of nodes"	| graph nodeA nodeB nodeC nDownStream downStreamNodes connectionsFromA nConnections |	graph := HumGraph new.	self assert: ( graph nodes isEmpty ).		nodeA := 'A'.	graph addNode: nodeA.	self assert: ( graph nodes size = 1 ).		nodeB := 'B'.	graph addNode: nodeB.	self assert: ( graph nodes size = 2 ).		nodeC := 'C'.	graph addNode: nodeC.	self assert: ( graph nodes size = 3 ).	graph addConnection: ( nodeA -> nodeB ) label: 'A to B'.	self assert: ( graph connections size = 1 ).		graph addConnection: ( nodeB -> nodeA ) label: 'B to A'. "creates a CYCLE"	self assert: ( graph connections size = 2 ).		graph addConnection: ( nodeA -> nodeB ) label: 'A to B again'.	self assert: ( graph connections size = 3 ).		graph addConnection: ( nodeA -> nodeC ) label: 'A to C'.	self assert: ( graph connections size = 4 ).		connectionsFromA := graph connectionsFrom: nodeA.	nConnections := connectionsFromA size.	self expect: 3 actual: nConnections description: 'Node A has 3 outbound connections.'.		downStreamNodes := graph nodesDownStreamFrom: nodeA.	nDownStream := downStreamNodes size.	self expect: 2 actual: nDownStream description: 'Expect two nodes down-stream from nodeA.'.	self assert: (downStreamNodes includes: nodeB). "But it includes it just once."	self assert: (downStreamNodes includes: nodeC).	! !!HumGraphTests methodsFor: 'access tests' stamp: 'RichardAlexanderGreen 1/22/2014 17:31'!test130PutGetNode	"A graph has a collection (set) of nodes"	| graph node node2 |	graph := HumGraph new.	self assert: ( graph nodes isEmpty ).		node := 'My content just happens to be a string but I could be any kind of object'.	graph addNode: node.	self assert: ( graph nodes size = 1 ).		graph nodes do: [ :entry | self assert: (entry == node )].! !