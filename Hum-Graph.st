TestCase subclass: #HumGraphTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Graph'!!HumGraphTests methodsFor: 'access tests' stamp: 'RichardAlexanderGreen 1/22/2014 17:31'!test110GraphHasNodes	"A graph has a collection (set) of nodes"	| graph |	graph := HumGraph new.	self assert: ( graph nodes isEmpty ).! !!HumGraphTests methodsFor: 'access tests' stamp: 'RichardAlexanderGreen 1/22/2014 17:31'!test120GraphHasConnections	"A graph has a collection (set) of nodes"	| graph |	graph := HumGraph new.	self assert: ( graph connections isEmpty ).! !!HumGraphTests methodsFor: 'access tests' stamp: 'RichardAlexanderGreen 1/22/2014 17:31'!test130PutGetNode	"A graph has a collection (set) of nodes"	| graph node node2 |	graph := HumGraph new.	self assert: ( graph nodes isEmpty ).		node := 'My content just happens to be a string but I could be any kind of object'.	graph addNode: node.	self assert: ( graph nodes size = 1 ).		graph nodes do: [ :entry | self assert: (entry == node )].! !!HumGraphTests methodsFor: 'access tests' stamp: 'RichardAlexanderGreen 1/22/2014 17:31'!test140PutGetConnector	"A graph has a collection (set) of nodes"	| graph node node2 |	graph := HumGraph new.	self assert: ( graph nodes isEmpty ).		node := 'My content just happens to be a string but I could be any kind of object'.	graph addNode: node.	self assert: ( graph nodes size = 1 ).		node2 := 'My content also just happens to be a string but I could be any kind of object'.	graph addNode: node2.	self assert: ( graph nodes size = 2 ).		graph addConnection: ( node -> node2 ).	self assert: ( graph connections size = 1 ).! !!HumGraphTests methodsFor: 'access tests' stamp: 'RichardAlexanderGreen 1/22/2014 17:31'!test150PutGetLabeledConnections	"A graph has a collection (set) of nodes"	| graph nodeA nodeB |	graph := HumGraph new.	self assert: ( graph nodes isEmpty ).		nodeA := 'My content just happens to be a string but I could be any kind of object'.	graph addNode: nodeA.	self assert: ( graph nodes size = 1 ).		nodeB := 'My content also just happens to be a string but I could be any kind of object'.	graph addNode: nodeB.	self assert: ( graph nodes size = 2 ).		graph addConnection: ( nodeA -> nodeB ) label: 'A to B'.	self assert: ( graph connections size = 1 ).		graph addConnection: ( nodeB -> nodeA ) label: 'B to A'.	self assert: ( graph connections size = 2 ).		graph addConnection: ( nodeA -> nodeB ) label: 'A to B again'.	self assert: ( graph connections size = 3 ).! !!HumGraphTests methodsFor: 'access tests' stamp: 'RichardAlexanderGreen 1/21/2015 07:17'!test160DetectCycle	"A graph has a collection (set) of nodes"	| graph nodeA nodeB nodeC |	false ifFalse: [ Trascript cr; show: 'test160DetectCycle is turned off.'. ^self.].	graph := HumGraph new.	self assert: ( graph nodes isEmpty ).		nodeA := 'A'.	graph addNode: nodeA label: 'nodeA'.	nodeB := 'B'.	graph addNode: nodeB label: 'nodeB'.	nodeC := 'C'.	graph addNode: nodeC label: 'nodeC'.	graph addConnection: ( nodeA -> nodeB ) label: 'A to B'.	graph addConnection: ( nodeB -> nodeC ) label: 'B to C'.	self assert: (graph hasCycle) not.	graph addConnection: ( nodeC -> nodeA ) label: 'C to A creates cycle'.	self assert: (graph hasCycle).		! !Object subclass: #HumBase	instanceVariableNames: 'entitiesOfType entitiesWithValue entityAttributeValue events'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Graph'!!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/9/2015 08:49'!entitiesOfType	^ entitiesOfType ifNil: [ entitiesOfType := Dictionary new ].! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/9/2015 08:50'!entitiesWithValue	^ entitiesWithValue ifNil: [ entitiesWithValue := Dictionary new].! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/9/2015 08:50'!entityAttributeValue	^ entityAttributeValue ifNil: [ entityAttributeValue := Dictionary new ].! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/10/2015 11:03'!entityID: anID entityType: aType attribute: anAttribute value: aValue event: anEvent	"Create a record of entity-attribute-value from event."	|  |		"Add entity to list of that type."	self insert: anID at: aType into: (self entitiesOfType).		"Add entity to index by value."	self insert: anID at: { anAttribute. aValue. } into: ( self entitiesWithValue ).		"Add record."	self push: { aValue. anEvent. } at: { anID. anAttribute. } onto: (self entityAttributeValue ).	"( self entityAttributeValue ) at: { anID. anAttribute. } put: { aValue. anEvent. }."	 ! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/10/2015 10:40'!eventWho: aWho what: aWhat where: aWhere why: aWhy 	| stamp yyyy mo day hh mm ss nn when eventID event |	stamp := TimeStamp current.	yyyy := stamp year.	mo   := stamp month.	day  := stamp day.	hh   := stamp hour.	mm   := stamp minute.	ss   := stamp seconds.	nn   := stamp asNanoSeconds / 1e9.	when := yyyy*100+mo*100+day*100+hh*100+mm*100+ss*1e6+nn.	eventID := when.	event := { when. aWho. aWhat. aWhere. aWhy. }.	(self events) at: eventID put: event.	^eventID.	! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/10/2015 09:48'!events	^ events ifNil: [ events := Dictionary new].! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/10/2015 09:11'!findEntitiesOfType: anEntityType 	| listOfEntities |	listOfEntities := (self entitiesOfType) at: anEntityType ifAbsent: [ Set new ].	^listOfEntities.! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/10/2015 11:07'!findEntitiesWhereAttribute: anAttributeType satisfies: aBlockClosure 	"Get collections of entities where current attribute value satisfies condition"	| listOfEntities |	listOfEntities := Set new.	( self entityAttributeValue )		keysAndValuesDo: [ :k :v |			| entityID attributeType attributeValue stack tuple |			entityID       := k at: 1.			attributeType  := k at: 2.			stack := v. 			tuple := stack top.			attributeValue := tuple at: 1.			( attributeType = anAttributeType )				ifTrue: [ 					( aBlockClosure value: attributeValue ) 						ifTrue: [ listOfEntities add: entityID ]					]			].	^listOfEntities.	! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/10/2015 11:05'!getEntityID: anEntityID attribute: anAttributeType 	"Get the current value for given entityID attributeType"	| result tuple stack |	stack := ( self entityAttributeValue ) at: { anEntityID. anAttributeType } ifAbsent: [ ^nil ].	tuple := stack top.	result := tuple at: 1. 	^result.! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/10/2015 10:52'!insert: anItem at: aKey into: aDictionaryOfLists	"Insert the item into a list at the given key."	| listOfEntities  |	"Add entity to list of that type."	listOfEntities := aDictionaryOfLists  at: aKey ifAbsent: [ Set new ].	listOfEntities add: anItem.	aDictionaryOfLists at: aKey put: listOfEntities.! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/10/2015 11:02'!push: anItem at: aKey onto: aDictionaryOfStacks	"Insert the item into a list at the given key."	| listOfEntities  |	"Add entity to list of that type."	listOfEntities := aDictionaryOfStacks  at: aKey ifAbsent: [ Stack new ].	listOfEntities push: anItem.	aDictionaryOfStacks at: aKey put: listOfEntities.! !Object subclass: #HumGraph	instanceVariableNames: 'connectionLabels nodeLabels'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Graph'!!HumGraph methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/22/2013 19:32'!addConnection: anAssociation 	self addConnection: anAssociation label: 'unknown'.! !!HumGraph methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/22/2013 19:36'!addConnection: anAssociation label: aString	( self connections ) add: anAssociation.	( self connectionLabels ) add: { aString. anAssociation.  }.! !!HumGraph methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/22/2013 19:35'!addNode: anObject 	"Add the given object to the set of nodes"	" Note that each object / node is unique"	self addNode: anObject label: 'unknown'.! !!HumGraph methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/22/2013 19:36'!addNode: anObject label: aString	"Add the given object to the set of nodes"	" Note that each object / node is unique"	( self nodeLabels ) add: { aString. anObject. }! !!HumGraph methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/22/2013 19:18'!connectionLabels	^ connectionLabels ifNil: [ connectionLabels := Set new ].! !!HumGraph methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/22/2013 19:37'!connections	"Return the connections (associations) in this graph."	| bagConnections |	bagConnections := Bag new.	(self connectionLabels)		do: [ :entry |			"entry looks like {  label. association. }"			bagConnections add: (entry at: 2 ).			].	^bagConnections.! !!HumGraph methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/22/2013 19:38'!nodeLabels	^nodeLabels ifNil: [ nodeLabels := Set new ].! !!HumGraph methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/22/2013 19:45'!nodes	"Return the nodes in this graph."	| bagNodes |	bagNodes := Bag new.	(self nodeLabels)		do: [ :entry |			"entry looks like {  label. object. }"			bagNodes add: (entry at: 2 ).			].	^bagNodes.! !!HumGraph methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 1/19/2015 10:26'!downStreamFrom: aRootNode 	"Collect the nodes that are down-stream from a root node."	| upStream downStream |	"Set up recursive loop."	upStream := Set new.	downStream := self downStreamFrom: aRootNode butNotIn: upStream.	^downStream.	! !!HumGraph methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 1/19/2015 10:30'!downStreamFrom: aRootNode butNotIn: upStreamNodes 	"Find nodes that are down-stream from the root node but not in the upStreamNodes."	| |	self shouldBeImplemented.	! !!HumGraph methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 1/19/2015 10:20'!hasCycle	"Does the graph contain at least one cycle?"	| |	nodeLabels		do: [:nodeLabel |			| label rootNode downStream |			label := nodeLabel at: 1.			rootNode := nodeLabel at: 2.			"downStreamFrom: will not extend leafs that match root"			downStream := self downStreamFrom: rootNode.			((downStream leafNodes) include: rootNode) ifTrue: [^true].			].	^false.! !TestCase subclass: #HumBaseTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Graph'!!HumBaseTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/10/2015 10:58'!test110putGetValue	"Save entity-attribute-value and fetch."	|  id type event value wb n |	n := 9.	wb := HumBase new.	( 1 to: n )		do: [ :i |			id := i.			type := #entityType.			event := i * 11.			value := i * 111.			wb entityID: id entityType: type attribute: #attributeType value: value event: event.			].		self expect: n actual: (wb entitiesOfType at: type) size.	self expect: 0 actual: (wb entitiesOfType at: #noneSuch ifAbsent: [Set new]) size.		( 1 to: n )		do: [ :j |			self expect: 1 actual: ( wb entitiesWithValue at: { #attributeType. j*111. } ) size.			self expect: {{ j*111. j*11. } } actual: ( wb entityAttributeValue at: { j. #attributeType. } ) asArray.			].		( 1 to: n )		do: [ :k |			self expect: k*111 actual: ( wb getEntityID: k attribute: #attributeType ).			self expect: { k. } actual: ( wb findEntitiesWhereAttribute: #attributeType satisfies: [:x | x = (k * 111)]) asArray.			].	! !!HumBaseTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/10/2015 11:08'!test120updateGetValue	"Save entity-attribute-value and fetch."	|  id type event value wb n |	n := 9.	wb := HumBase new.	( 1 to: n )		do: [ :i |			id := i.			type := #entityType.			event := i * 11.			value := i * 111.			wb entityID: id entityType: type attribute: #attributeType value: value event: event.			].		( 1 to: n )		do: [ :i |			id := i.			type := #entityType.			event := i * 111.			value := i * 1111.			wb entityID: id entityType: type attribute: #attributeType value: value event: event.			].		self expect: n actual: (wb entitiesOfType at: type) size.	self expect: 0 actual: (wb entitiesOfType at: #noneSuch ifAbsent: [Set new]) size.	self expect: n actual: ( wb findEntitiesOfType: type ) size.	self expect: 0 actual: ( wb findEntitiesOfType: #noneSuch ) size.		( 1 to: n )		do: [ :j |			self expect: 1 actual: ( wb entitiesWithValue at: { #attributeType. j*111. } ) size.			self expect: { j*1111. j*111. } actual: ( wb entityAttributeValue at: { j. #attributeType. } ) top.			].		( 1 to: n )		do: [ :k |			self expect: k*1111 actual: ( wb getEntityID: k attribute: #attributeType ).			self expect: { k. } 			     actual: ( wb findEntitiesWhereAttribute: #attributeType satisfies: [:x | x = ( k * 1111)] ) asArray.			].	! !!HumBaseTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/10/2015 09:49'!test130putGetEvent	"put get event"	| wb eventID |	wb := HumBase new.	eventID := wb eventWho: 'who' what: 'what' where: 'where' why: 'why not'.	self assert: (eventID isKindOf: LargePositiveInteger ).! !