Object subclass: #HumCalculator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumCalculator commentStamp: 'RichardAlexanderGreen 1/13/2012 15:18' prior: 0!The Calculator role (agent) provides - base level arithmetic (using measures)- string utilities used to parse Hum source code.!!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 10/30/2012 13:42'!xml: aTagString attributes: aMap 	"Create a stand-alone tag (ending with '/>') with the given attribute values."	| xml space equals quote |      self assert: ( aMap isKindOf:  OrderedCollection ).	space := String space.	equals := '='.	quote := $" asString.	xml := '<', aTagString.	aMap 		do: [ :map | 			xml := xml, space, map key, equals, quote, map value, quote.			].	xml := xml, ' />'.	^xml.! !!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 10/30/2012 14:11'!xml: aTagString attributes: aMap with: aBlockClosure 	"Generate the front tag and the end tag with block to produce the middle"	| frontTag xml cr indent calc |	calc := HumCalculator new.	self assert: ( aMap isKindOf: OrderedCollection ).	cr := String cr.	indent := '  '.		frontTag :=  calc xmlOpen: aTagString attributes: aMap.	xml := frontTag, cr, 	             indent, ( aBlockClosure value ), cr,			'</', aTagString, '>'.	^xml.! !!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 10/30/2012 13:43'!xml: aTag with: aBlock 	"Fix up the indent after we get this working."	| xml cr indent |	cr := String cr.	indent := '  '.		xml  := '<', aTag, '>', cr			,  indent, ( aBlock value  ) asString, cr			,'</', aTag, '>', cr.	^xml.! !!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 11/22/2012 18:28'!xmlOpen: aTagString attributes: aMap 	"Create an opening tag ( NOT ending with '/>' ) with the given attribute values."	| xml space equals quote |	self assert: ( aMap isKindOf: OrderedCollection ).	space := String space.	equals := '='.	quote := $" asString.	xml := '<', aTagString.	aMap 		do: [:map | 			xml := xml, space, map key, equals, quote, map value, quote.			].		xml := xml, ' >'.	^xml.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumCalculator class	instanceVariableNames: ''!!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 1/13/2012 09:57'!substringFrom: stringIn after: stringA 	"Get the substring that is between the two given."	| x1 stringOut s |	s := stringIn.	stringOut := ''.	x1 := s findString: stringA startingAt: 1.	(x1 > 0 ) 		ifTrue: [ stringOut := stringIn copyFrom: (x1+  stringA size) to: (stringIn size). 			 ].	^stringOut.! !!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 1/13/2012 10:01'!substringFrom: stringIn after: stringA before: stringB	"Get the substring that is between the two given."	| x1 x2 stringOut s |	s := stringIn.	stringOut := ''.	x1 := s findString: stringA startingAt: 1.	(x1 > 0 ) 		ifTrue: [ x2 := s findString: stringB startingAt: x1. 			(x2 > x1)				 ifTrue: [ stringOut := s copyFrom: x1+1 to: x2-1.]. 			 ].	^stringOut.! !!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 1/13/2012 10:12'!substringFrom: stringIn before: stringA 	"Get the substring that is between the two given."	| x1 stringOut s |	s := stringIn.	stringOut := ''.	x1 := s findString: stringA startingAt: 1.	(x1 > 0 ) 		ifTrue: [ stringOut := stringIn copyFrom: 1 to: (x1-1). 			 ].	^stringOut.! !!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 12/19/2012 12:19'!substringFrom: aString includingMatching: pairString	"	s = 'this is before [[blah]] this is after'.	self assert: ( HumCalculator substringFrom: s betweenMatching: '[]' ) = '[[blah]]'.	 "	| startPos pos nestLevel pairStart pairStop |	pairStart := pairString at: 1.	pairStop  := pairString at: 2.	self assert: (pairStart isKindOf: Character ).	self assert: (pairStop isKindOf: Character ).	"Find the start of the substring."	startPos := aString indexOf: pairStart.	"TODO: If there is no starting character, what should we return?"	(startPos > 0 ) 		ifFalse: [ ^nil ].	"Following assumes we have found the starting position."	self assert: startPos > 0.	pos := startPos + 1.	nestLevel := 1.	[ pos <= aString size ] whileTrue: [		| aCharacter |		aCharacter := aString at: pos.		( aCharacter = pairStart ) 			ifTrue: [ nestLevel := nestLevel + 1 ].		( aCharacter = pairStop )  			ifTrue: [ nestLevel := nestLevel - 1 ].		(nestLevel = 0) 			ifTrue: [ |result| result := ( aString copyFrom:startPos to: pos ). ^result. ].		pos := pos + 1.	].	"If we come here, the matching closing character is missing."	Error signal: 'String does not contain a balanced pair: ', pairString.	^nil.! !Object subclass: #HumBlackBoard	instanceVariableNames: 'quads'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumBlackBoard commentStamp: 'RichardAlexanderGreen 9/20/2012 07:21' prior: 0!The blackboard holds the values for nouns in memory that are currently being referenced by an agent.In addition, the blackboard operates the persistence mechanism so that new noun values are recorded on the world-base (database). !!HumBlackBoard methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/18/2012 11:49'!getEntityID: entityID attribute: attributeType 	" Get requested value (if any) from the world base instance "	| tau value |	self assert: (entityID isKindOf: String ).	self assert: (attributeType isKindOf: Symbol ).	"Ignore temporal features for now."		value := (self quads ) at: ( entityID -> attributeType ) ifAbsent: [ nil ].	^ value.! !!HumBlackBoard methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/18/2012 11:48'!quads	^ quads ifNil: [ quads := Dictionary new. ].! !!HumBlackBoard methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/26/2012 11:40'!setEntityID: entityID attribute: attributeType toValue: aValue	" Get requested value (if any) from the world base instance "	| tau quad value |	self assert: (entityID isKindOf: String ).	self assert: (attributeType isKindOf: Symbol ).	self assert: ( aValue notNil ).	"Ignore temporal features for now."	"Get value of reqested entity attribute."	(self quads ) at: ( entityID -> attributeType ) put: aValue.		"TODO: Update the world base also."! !Object subclass: #HumVM	instanceVariableNames: 'slots transferVector measure'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumVM commentStamp: 'RichardAlexanderGreen 9/20/2012 07:57' prior: 0!HumVM is a thought experiment for a virtural machine and byte code.After some consideration, I (Richard Alexander Green) decided that a byte code is not a good idea at this time.If compiled code is necessary for efficiency, it would make more sense at this time to translate to a language that has a compiler. Byte Code Advantages:- The resulting code may be more compact than the source and therefore it would require less delivery time.- - counter: Delivery time for an agent`s code is generally not an important factor except possibly for a dialog agent.- A byte code might be more easily compiled to a native ISA.- - counter: It is easier to translate to another language.Disadvantages:- If the normal delivery is byte code the ecology may discourage transparency.- An existing VM such as JVM or BEAM would be more acceptable to many audiences.Instance Variables:	slots	<Dictionary>	transferVector	<Dictionary>	measure	<HumMeasure>!!HumVM methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2012 10:30'!measureRegister	^ measure ifNil: [ measure := HumMeasure new. ].! !!HumVM methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2012 10:10'!setSlot: slotIndex to: aHumObject 	(self slots) at: slotIndex put: aHumObject.! !!HumVM methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2012 10:11'!slots	"slots allow objects to be referenced by byte-code indices."	^ slots ifNil: [slots := Dictionary new. ].! !!HumVM methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2012 10:39'!transferVector	transferVector ifNil: [ transferVector := Dictionary new.		transferVector 			at: 001 put: [ :x | measure := x  ];			at: 002 put: [ :x | measure := measure + x ];			at: 003 put: [ :x | measure := measure - x ];			at: 000 put: [ :x | self halt ].		].	^transferVector.! !!HumVM methodsFor: 'self evaluating' stamp: 'RichardAlexanderGreen 7/26/2012 10:41'!run: aHumInstruction 	| microCode |	"Get the microCode. (a block)"	microCode := ( self transferVector ) at: (aHumInstruction operation) 	                                                     ifAbsent: [ Error signal: 'No such opCode: ', (aHumInstruction operation)].	"Run the microCode. (a block)"	microCode value: ( self slots at: (aHumInstruction operand)).	"Assure cascade."	^self. ! !HumFrame4Data subclass: #HumJobTicket	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumJobTicket commentStamp: 'RichardAlexanderGreen 9/28/2012 14:04' prior: 0!A job ticket records the resources consumed by a job.A job is initiated when a goal is set running.When actions are delegated by the one actor to other actors, they get jobtickets also.The resulting resource data is consolidated on the parent-level job-ticketsso that the costs are rolled-up to each level and eventually to the job as a whole.When each action is completed, the resource manager reports new resource entries to the Bookkeeper.Hence a running account is maintained for the job, for each resource, for each actor, for each role, for each action.Note that resource accounting only sums resource quantities.It does not attempt to monetize (price) the resources used because that is a very specialized process.For example, withdrawals from inventory might be priced using LIFO, FIFO, or some other accounting practice.!!HumJobTicket methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 12:47'!appendCharge: aHumMeasure forAction: action byActor: anID inRole: aRoleName onJob: aJobID 	"A job ticket is a data frame. Place these items into a data group."	self appendEntity: 'Charge' attrribute: 'measure' value: aHumMeasure asString.	self appendEntity: 'Charge' attrribute: 'action' value: action asString.	self appendEntity: 'Charge' attrribute: 'ID' value: anID asString.	self appendEntity: 'Charge' attrribute: 'role' value: aRoleName asString.	self appendEntity: 'Charge' attrribute: 'job' value: aJobID asString.	! !!HumJobTicket methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/3/2012 14:31'!appendCharge: aHumMeasure forResource: actorName 	| s |	s := 'actor: {', actorName, '} charges: ', aHumMeasure asString.	self addFrameLine: s.! !Object subclass: #HumVMInstruction	instanceVariableNames: 'operation operand'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumVMInstruction commentStamp: 'RichardAlexanderGreen 9/20/2012 07:59' prior: 0!HumVM and HumVMInstruction are artifacts of a thought experiment for a virtural machine and byte code.See the HumVM class comment for further information.Instance Variables:	operation	<Integer>	operand	<Integer>Class Instance Variables:	codeNames	<Dictionary>!!HumVMInstruction methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:12'!operand	^ operand ifNil: [ Error signal: 'operand not set in HumInstruction'.  operand := 000].! !!HumVMInstruction methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:10'!operand: objectIndex 	operand := objectIndex! !!HumVMInstruction methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:11'!operation	^ operation ifNil: [ Error signal: 'op code not set in HumInstruction'.  operation := 000].! !!HumVMInstruction methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:09'!operation: opCode 	self assert: ( opCode < 256 ).	self assert: ( opCode >= 0 ).	operation := opCode.! !!HumVMInstruction methodsFor: 'associating' stamp: 'RichardAlexanderGreen 9/20/2012 07:37'!opCodeName	| name |	name := ( HumVMInstruction codeNames ) at: (self operation) ifAbsent: ['Unknown'].	^name.! !!HumVMInstruction methodsFor: 'associating' stamp: 'RichardAlexanderGreen 7/25/2012 10:18'!slotName	( (self operand) = 000 ) ifTrue: [^ 'None' ].	Error signal: 'Instruction slot name is not defined.'.	^'Undefined.'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumVMInstruction class	instanceVariableNames: 'codeNames'!!HumVMInstruction class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 7/24/2012 16:27'!opCode: opCode value: objectIndex 	| instruction |	instruction := self basicNew.	instruction operation: opCode.	instruction operand: objectIndex.	^instruction.! !!HumVMInstruction class methodsFor: 'associating' stamp: 'RichardAlexanderGreen 7/24/2012 16:26'!opCodeName	name := (self codeNames ) at: (self operation).	^name.! !!HumVMInstruction class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:33'!codeNames	codeNames ifNotNil: [ ^codeNames ].	"Otherwise, initialize . . ."	codeNames := Dictionary new.	codeNames at: 000 put: 'Halt'.! !Magnitude subclass: #HumMeasure	instanceVariableNames: 'quantity units upperControlLimit lowerControlLimit'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumMeasure commentStamp: 'RichardAlexanderGreen 9/20/2012 07:39' prior: 0!A measure has a quantity with upper and lower control limits and a unit of measure.Instance Variables:	quantity	<Object>	units	<ProtoObject>!!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 21:33'!negated	| zero result |	zero := HumMeasure quantity: 0 units: (self units).	result := zero - self.	^result. ! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2012 20:25'!quantity		^ quantity ifNil: [ Error message: 'HumMeasure quantity was not set.' ].! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/20/2012 07:42'!quantity: aQuantity plusOrMinus: aVariance units: aString	self assert: ( aQuantity isKindOf: Number ).	self assert: ( aVariance isKindOf: Number ).	quantity := aQuantity.	upperControlLimit := quantity + aVariance.	lowerControlLimit := quantity - aVariance.	units := aString. 	! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/3/2012 13:39'!quantity: aNumber units: aString	quantity := aNumber.	units := aString. 	! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2012 20:24'!units	^ units ifNil: [ Error message: 'HumMeasure units were not set'].! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 22:03'!units: aString 	self assert: ( aString isKindOf: String ).	units := aString! !!HumMeasure methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/3/2012 14:30'!asString	^( quantity asString, ' ', units ).! !!HumMeasure methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/14/2012 21:57'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		nextPutAll: title;		nextPutAll: ( '( ', quantity asString, ' ', units, ' )' ).! !!HumMeasure methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 3/8/2012 20:34'!* aMeasure 	| result |	self assert: ( aMeasure isKindOf:  HumMeasure ).	(( self units = '%' ) and: [ aMeasure units = '%'])		ifFalse: [ Error message: 'This version can only multiply measures where units = (%).' ].	result := HumMeasure quantity: ( (self quantity / 100.0) * ( aMeasure quantity /100.0 ) * 100.0 )units: ( self units ).	^result.! !!HumMeasure methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 3/14/2012 22:01'!+ aMeasure 	| measure result |	( aMeasure isKindOf:  HumMeasure )		ifTrue: [ measure := aMeasure ]		ifFalse: [ measure := HumMeasure quantity: aMeasure units: (self units)].	( self units = measure units )		ifFalse: [ 			(self units = '')				ifTrue: [ self units: aMeasure units ]				ifFalse: [ Error signal: 'This version can only perform arithmetic on measures with matching units.'. self halt. ].				].	result := HumMeasure quantity: (self quantity + measure quantity ) units: ( self units ).	^result.! !!HumMeasure methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 3/14/2012 21:50'!- aMeasure 	| measure result |	( aMeasure isKindOf:  HumMeasure )		ifTrue: [ measure := aMeasure ]		ifFalse: [ measure := HumMeasure quantity: aMeasure units: (self units)].	( self units = measure units )		ifFalse: [ Error signal: 'This version can only perform arithmetic on measures with matching units.' ].	result := HumMeasure quantity: (self quantity - measure quantity ) units: ( self units ).	^result.! !!HumMeasure methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 3/14/2012 20:50'!= aMeasure 	| measure result |	( aMeasure isKindOf:  HumMeasure )		ifTrue: [ measure := aMeasure ]		ifFalse: [ measure := HumMeasure quantity: aMeasure units: (self units)].	( self units = measure units )		ifFalse: [ Error message: 'This version can only perform arithmetic on measures with matching units.' ].	result := (self quantity = measure quantity ).	^result.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumMeasure class	instanceVariableNames: ''!!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 3/14/2012 21:48'!fromString: aString	| measure |	self assert: ( aString isKindOf: String ).	measure := self basicNew.	( aString includes: $% )		ifTrue: [measure quantity: ( aString asNumber )    units: '%'. ]		ifFalse: [ measure quantity: ( aString asNumber )  units: ( aString copyAfter: $  ).].	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/3/2012 13:38'!quantity: aNumber units: aString 	| measure |	measure := self basicNew.	measure quantity: aNumber units: aString.	^measure.! !Object subclass: #HumBus	instanceVariableNames: 'uri uriActor'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumBus commentStamp: 'RichardAlexanderGreen 9/20/2012 07:34' prior: 0!The communication bus provides a message store and forward service with optional logging.If an actor is temporarily not available, a message will be held for some (TBD) time.The messages to a role may be replayed later.Instance Variables:	uri			<URI>	uriActor	<Dictionary>!!HumBus methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/10/2012 13:51'!uri	"Return my URI"	^ uri! !!HumBus methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/10/2012 13:50'!uri: aString 	uri := aString.! !!HumBus methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/10/2012 15:27'!uriActor	^ uriActor ifNil: [ uriActor := Dictionary new. ].! !!HumBus methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 2/13/2012 10:52'!ping: aURI	^ ( self uriActor ) at: aURI ifAbsent: [ Error signal: 'Messenger has no entry for URI: ', aURI ].! !!HumBus methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 3/11/2013 07:52'!registerActor: anActor atActorURL: aURI 	"Track actor."	self assert: ( anActor isKindOf: HumActor ).	self assert: ( aURI isKindOf: String ).	"Track URI->actor association."	(self uriActor) at: aURI put: anActor.	"TODO: Track actor->URI also."! !!HumBus methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 3/11/2013 07:54'!send: aHumStatement to: recipientURI from: senderURI	| actorInstance |	actorInstance := (self uriActor) at: recipientURI 								 ifAbsent: [ Error signal: 'Messenger does not know recipient: ', recipientURI ].	"This works when actor is local."	actorInstance run: aHumStatement	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumBus class	instanceVariableNames: ''!!HumBus class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/10/2012 13:49'!uri: aString 	| instance |	instance := self basicNew.	instance uri: aString.	^instance.! !Object subclass: #HumActor	instanceVariableNames: 'myID myURI messengerURI bookkeeperURI roles worldbaseURI managerURI configuration blackboard'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumActor commentStamp: 'RichardAlexanderGreen 9/19/2012 11:32' prior: 0!An actor is capable of performing one or more roles.Some actors are part of the run-time systems and have particular configuration requirements.In general, an actor needs a connection to a messenger in order to communicate with the system.Most actors also need a connection to a manager so that the manager can assign actions to the actor.Some actors also need a connection to a bookkeeper so that the actor can record utilization.Instance Variables:	myID	<String>	myURI	<String>	messengerURI	<URI>	bookkeeperURI	<URI>	roles			<Collection of: String>	managerURI	<URI>	configuration	<HumConfiguration>!!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/18/2012 10:40'!blackboard	^ blackboard ifNil: [ blackboard := HumBlackBoard new. ].! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 10:39'!bookkeeper	^ bookkeeperURI ifNil: [ (self configuration) bookkeeper ].! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 10:38'!bookkeeper: aURI 	self checkURI: aURI.	bookkeeperURI := aURI.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:00'!configuration	^ configuration ifNil: [ Error signal: 'Actor {',myID,'} is not configured.']! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/6/2012 19:50'!configuration: aHumConfiguration 	configuration := aHumConfiguration.	self messenger: ( configuration messengerURI ).! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:00'!id	^myID! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:00'!id: aString 	self assert: (aString isKindOf: String ).	myID := aString.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/10/2012 16:11'!manager	^(self configuration ) managerURI .! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:01'!manager: aURI 	self assert: ( aURI isKindOf: String ).	managerURI := aURI.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:49'!manager: anID uri: aURI configuration: aHumConfiguration 	self configuration: aHumConfiguration.	self id: anID.	self uri: aURI.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:29'!managerURI	managerURI ifNil: [ managerURI := self configuration managerURI ].	self assert: ( managerURI isKindOf: String ).	^managerURI.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/10/2012 15:31'!messenger	^( self configuration ) messenger.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:04'!messenger: aMessengerURI 	self assert: ( aMessengerURI isKindOf: String ).	messengerURI := aMessengerURI.	! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:04'!roles		^ roles  ifNil: [ Error signal: 'Actor {', myID,'} has no role.' ].! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/26/2012 20:10'!roles: anArray 	self assert: ( anArray isKindOf: Array ).	roles := anArray.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 08:59'!uri	^myURI! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:50'!uri: aURI	self assert: ( aURI isKindOf: String ).	myURI := aURI.	"My identifier (myID) should be established at this point also."	self assert: (myID isKindOf: String ).	"Because I need it to check-in with the messenger."	self assert: (self messenger isKindOf: HumBus ).	self messenger registerActor: self atActorURL: myURI. ! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 10:58'!worker: anID uri: aURI roles: arrayOfRoleNames configuration: aHumConfiguration	configuration :=  aHumConfiguration.      self id: anID.	self uri: aURI.	roles := arrayOfRoleNames.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:07'!worldbase: aURI 	self assert: ( aURI isKindOf: String ).	worldbaseURI := aURI.! !!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 2/13/2012 09:27'!checkIn	| message quotedRoles |	"First, check-in with the messenger."	( self messenger ) registerActor: self atActorURL: (self uri).	"Send check-in message to my resource manager."	quotedRoles := ''.	roles		do: [ :role | quotedRoles := quotedRoles, ' ', role quoted ].	message := 'self checkInActor: ', myID quoted, ' at: ', myURI quoted, ' withRoles: #(', quotedRoles, ').'.	self assert: (self managerURI isKindOf: String ).	self sendMessage: message to: (self managerURI).! !!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 3/11/2013 08:00'!run: aStatement 	"Execute, simulate, or log the given statement"	( aStatement isKindOf: String )		ifTrue: [ Compiler evaluate: aStatement for: self logged: false.				"No charge in this context."				^self				] .	( aStatement isKindOf: HumStatement ) 		ifTrue: [ "Simulate execution"			"Append to transcript"			Transcript cr; show: 'Actor: ', myID, ' is doing: ', aStatement source; cr.			( aStatement nounValues )				keysAndValuesDo:  [ :noun :value | 					Transcript show: 'with: ', noun, ' = ', value asString ].			"Change to job ticket"				^self chargeTo: (aStatement jobTicket). 			].	( aStatement isKindOf: HumJobTicket )		ifTrue: [ ( self isKindOf: HumResourceManager )						ifTrue: [self sendMessage: aStatement to: (self bookkeeper). 							^self. ].					( self isKindOf: HumBookkeeper )						ifTrue: [ (self jobTickets) add: aStatement.							^self.].				] .	Error signal: 'Statement type not handled.'.! !!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 2/13/2012 10:36'!sendMessage: aMessageObject to: recipientURI.	self checkURI: recipientURI. 	( self messenger ) send: aMessageObject to: recipientURI from: myURI.		! !!HumActor methodsFor: 'logging' stamp: 'RichardAlexanderGreen 3/11/2013 08:03'!chargeTo: aHumJobTicket 	"Compute the charge."	| charge |	charge := HumMeasure quantity: 1 units: 'step'.	"Append to the job ticket."	aHumJobTicket appendCharge: charge forResource: myID.	"Send to the manager. 	 The manager will call bookkeeper and update Supervisor."	self sendMessage: aHumJobTicket to: (self managerURI).! !!HumActor methodsFor: 'testing' stamp: 'RichardAlexanderGreen 2/13/2012 10:36'!checkURI: aString 	self assert: ( '*URI' matches: aString ).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumActor class	instanceVariableNames: ''!!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/6/2012 17:26'!bookkeeper: myID uri: myURI configuration: aHumConfiguration 	| instance |	instance := HumBookkeeper new.	instance bookkeeper: myID uri: myURI configuration: aHumConfiguration.	^instance. ! !!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/6/2012 20:05'!dialog: myID uri: myURI client: clientURI configuration: aHumConfiguration	| instance |	instance := HumDialogAgent new.	instance  dialog: myID uri: myURI client: clientURI configuration: aHumConfiguration.	^instance.	! !!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/6/2012 17:24'!manager: myID uri: myURI configuration: aHumConfiguration 	| instance |	instance := HumResourceManager new.	instance manager: myID uri: myURI configuration: aHumConfiguration.	^instance. ! !!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/10/2012 16:31'!supervisor: myID uri: myURI goal: aGoalStatementString dialog: aHumDialogAgent configuration: aHumConfiguration 	| instance |	instance := HumSupervisor new.	instance  supervisor: myID 	                              uri: myURI 	                           goal: aGoalStatementString 	                        dialog: aHumDialogAgent 	          configuration: aHumConfiguration .	^instance.! !!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 10/31/2012 10:39'!worker: id uri: aURI messenger: messengerURI manager: managerURI roles: anArray 	| worker |	worker := self basicNew.	worker configuration: ( (HumConfiguration new) messengerURI: messengerURI; yourself).	worker id: id;			messenger: messengerURI;			uri: aURI;			manager: managerURI;			roles: anArray.	^ worker.! !!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/13/2012 08:43'!worker: workerID uri: workerURI roles: arrayOfRoleNames configuration: aHumConfiguration 	| instance |	instance := self basicNew.	instance worker: workerID uri: workerURI roles: arrayOfRoleNames configuration: aHumConfiguration.	^instance.! !HumActor subclass: #HumSupervisor	instanceVariableNames: 'ontology goal context remainingConditions dialogAgent planFrames'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumSupervisor commentStamp: 'RichardAlexanderGreen 9/19/2012 11:43' prior: 0!The supervisor tracks the execution state of a plan.The state includes which conditions are satisfied, which plan frames have been completed, the accumulated resource utilization associated with the execution, and any exceptions that were encounterd or are currently pending resolution.Instance Variables:	ontology	<HumOntology>	goal	<ProtoObject | PseudoContext>	context	<Object>	remainingConditions	<Integer>	dialogAgent	<ProtoObject | PseudoContext>	planFrames	<Collection | PTEnumerable | PragmaCollector>!!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/3/2012 17:33'!context: aHumActor	context := aHumActor.! !!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 10:02'!dialogAgent: aHumDialogAgent 	self assert: ( aHumDialogAgent isKindOf: HumDialogAgent ).	dialogAgent := aHumDialogAgent.! !!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/8/2012 13:36'!goal: aString 	goal := aString.	planFrames := ( self ontology ) collectPlanFramesForGoal: goal.! !!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/8/2012 13:41'!ontology	^ ontology ifNil: [ (self configuration) ontology.].! !!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/3/2012 17:31'!ontology: aHumOntology 	ontology := aHumOntology.! !!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/3/2012 17:35'!remainingConditions	^ remainingConditions ifNil: [ remainingConditions := 0.] .! !!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 10:01'!supervisor: anID uri: aURI goal: aGoalStatementString dialog: aHumDialogAgent configuration: aHumConfiguration	self configuration: aHumConfiguration.		self id: anID.	self uri: aURI.	self goal: aGoalStatementString.	self dialogAgent: aHumDialogAgent.			^self.	! !!HumSupervisor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 2/13/2012 10:17'!runAction: anInstructionLine 	"Run the given action statement."	Transcript cr; show: 'Actor: ',myID,' is running { ', anInstructionLine source, ' }'; cr.	"After the action is run, the corresponding post-condition is satisfied."	"	REFACTOR -- MORE CONTEXT IS NEEDED TO MAKE THIS POSSIBLE. "	! !!HumSupervisor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 2/10/2012 12:29'!runPlan	"Run my plan.	"	|  aRunnableFrame runnableActionStatements aPostCondition |	self assert: ( context isKindOf: HumDialogAgent ).	"		Additional Preconditions:	. All nouns in the goal statement have values on the dialog agent's' blackboard.	. The frame collection is complete.	. All the roles in the action statements are known (checked-in) to the resource manager.	. All action statements are defined in the ontology.	"	self planIsRunnable ifFalse: [ Error signal: 'Plan is not runnable for goal: ', goal ].	planFrames := ontology collectPlanFramesForGoal: goal.	"Find a plan frame that is ready to run. (All its preconditions are satisfied and it has not already run.)"	aRunnableFrame := planFrames detect: [ :frame | frame isRunnable ].	"Run it's action statements."	runnableActionStatements := aRunnableFrame actionStatements.	runnableActionStatements		do: [ :actionStatement |			actionStatement runInContext: context.			].	"Assert it's post condition."	aPostCondition := aRunnableFrame postCondition.	self conditionIsSatisfied: aPostCondition.	"Needs more work -- to loop until goal is satisfied."	self halt.		! !HumActor subclass: #HumDialogAgent	instanceVariableNames: 'clientURI'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumDialogAgent commentStamp: 'RichardAlexanderGreen 9/19/2012 11:37' prior: 0!A dialog agent provides the interface between a Dialog and a user interface framework.For example, an implementation of a dialog agent could communicate with a user via HTML forms.Another implementation might be designed to communicate via a chat-room interface such as Jabber.We anticipate that some implementations will use virtual-world avatars.Instance Variables:	clientURI	<ProtoObject | PseudoContext>!!HumDialogAgent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/6/2012 20:06'!dialog: myID uri: myURI client: uriClient configuration: aHumConfiguration	actorName := myID.	url := myURI.	clientURI := uriClient.	self configuration: aHumConfiguration.! !!HumDialogAgent methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/26/2012 11:57'!renderView: anEntityID onCanvas: html	"Check generated code by pasting it below"		html form with: [ 		html break. html heading level: 2; with: '!!!! Recipe'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #name toValue: datum ]; value: 'name'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #description toValue: datum ]; value: 'description'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #ingredients toValue: datum ]; value: 'ingredients'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #steps toValue: datum ]; value: 'steps'.		].	! !HumActor subclass: #HumBookkeeper	instanceVariableNames: 'jobTickets'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumBookkeeper commentStamp: 'RichardAlexanderGreen 9/19/2012 11:34' prior: 0!The bookkeeper records resource utilization and expenditure statistics.It provides the basic data needed for cost accounting and system utilization analysis.Instance Variables:	jobTickets	<OrderedCollection>!!HumBookkeeper methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 10:56'!bookkeeper: anID uri: aURI configuration: aHumConfiguration 	configuration := aHumConfiguration.	self id: anID.	self uri: aURI.! !!HumBookkeeper methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 11:02'!jobTickets	^ jobTickets ifNil: [ jobTickets := OrderedCollection new. ].! !HumActor subclass: #HumResourceManager	instanceVariableNames: 'roleActor actorURI'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumResourceManager commentStamp: 'RichardAlexanderGreen 9/19/2012 11:40' prior: 0!The resource manager assigns actors to perform actions.An actor registers itself with a resource manager and identifies the roles that it knows.When a running plan or dialog requires that an action be performed, the resource manager finds an available actor that knows that role (has that capability) and assigns the requested action to that actor.When the actor has completed the role, it becomes available for further assignments.Instance Variables:	roleActor	<Set>	actorURI	<Dictionary>!!HumResourceManager methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:22'!actorURI	^ actorURI ifNil: [ actorURI := Dictionary new. ].! !!HumResourceManager methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:25'!checkInActor: actorID at: aURI withRoles: actorKnowsRoles 	"Remember actor's URI"	(self actorURI ) at: actorID put: aURI.	"For each actor role: 	. Add the actor to those that know that role."	self assert: ( actorKnowsRoles isKindOf: Array ).	actorKnowsRoles do: [ :aRole |		( self roleActor )  add: ( aRole -> actorID )		].		! !!HumResourceManager methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/10/2012 15:09'!messenger	^ ( self configuration ) messenger.! !!HumResourceManager methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/27/2012 14:00'!roleActor	^ roleActor ifNil: [ roleActor := Set new. ].! !!HumResourceManager methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 2/13/2012 10:26'!assignRole: roleString action: actionStatement 	"Assign the given action to an actor advertising the given role."	| actor actorAddress |	self assert: ( roleString isKindOf: String ).	self assert: ( actionStatement isKindOf: HumStatement ).	"Find an actor that knows the role."	( self roleActor ) 		do: [ :map | 			map key = roleString asLowercase  				ifTrue: [ actor := map value. ].			].	"Get the actor's URI."	actorAddress := (self actorURI ) at: actor ifAbsent: [ Error signal: 'No URI for actor?' ].	"Send the action to the actor."	self sendMessage: actionStatement to: actorAddress.		! !Object subclass: #HumWorldBase	instanceVariableNames: 'title quads'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumWorldBase commentStamp: 'RichardAlexanderGreen 2/19/2013 09:29' prior: 0!The world base is a data base for a "world".Typically, a "world" is an enterprise.But, it could be a game or a simulation.A world base is a temporal database.All stored values are versioned.For an entity, each stored attribute has a value and a time-span.The time-span, in turn, has two event-stamps corresponding to the event which populated or updated the value and the event which changed the value.A world base entry is a quad (4-tuple) of pointers:. ( entity, attribute, value, time-span ).Entity Schema:. Entity has attributes.. Attribute has value and time-span.. Time-span has start-event, stop-event.Event Schema:. Event has client, portal, context, date-time.. . . . . . . who . where . . why . . . when (what is the data affected). Client has identifier, client-type, credentials, ongoing-dialog.. Client-type categories include person, robot.. Context has job, ontology, frame, statement.!!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/18/2012 08:11'!getEntityID: entityID attribute: attributeType 	" Get requested value (if any) from the world base instance "	| tau value |	self assert: (entityID isKindOf: String ).	self assert: (attributeType isKindOf: Symbol ).	"Ignore temporal features for now."		value := (self quads ) at: ( entityID -> attributeType ) ifAbsent: [ nil ].	^ value.! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/18/2012 07:37'!quads	^ quads ifNil: [ quads := Dictionary new. ].! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/18/2012 08:05'!setEntityID: entityID attribute: attributeType value: aValue	" Get requested value (if any) from the world base instance "	| tau quad value |	self assert: (entityID isKindOf: String ).	self assert: (attributeType isKindOf: Symbol ).	self assert: ( aValue notNil ).	"Ignore temporal features for now."	"Get value of reqested entity attribute."	(self quads ) at: ( entityID -> attributeType ) put: aValue.! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/12/2012 10:32'!title	^ title ifNil: [ Error signal: 'A world base instance must have a title.'].! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/12/2012 10:34'!title: aWorldBaseName 	self assert: ( aWorldBaseName isKindOf: String ).	title := aWorldBaseName.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumWorldBase class	instanceVariableNames: ''!!HumWorldBase class methodsFor: 'accessing instances and variables' stamp: 'RichardAlexanderGreen 10/12/2012 10:33'!openWorldBase: aWorldBaseName	"Open the world base instance with the given name.	If it does not already exist, create a new instance." 	| instance |	self assert: ( aWorldBaseName isKindOf: String ).	instance := self basicNew.	instance title: aWorldBaseName.	^instance.! !Object subclass: #HumConfiguration	instanceVariableNames: 'messengerURI managerURI bookkeeperURI worldbaseURI ontology messengerProxy'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumConfiguration commentStamp: 'RichardAlexanderGreen 9/20/2012 07:36' prior: 0!A configuration holds the information about how an agent is connected to other agents.Instance Variables:	messengerURI	<URI>	managerURI	<URI>	bookkeeperURI	<URI>	worldbaseURI	<URI>	ontology	<HumOntology>	messengerProxy	<HumBus>!!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 10:42'!bookkeeper	^ bookkeeperURI ifNil: [ Error signal: 'Bookkeeper is missing!!' ].! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/6/2012 19:44'!bookkeeperURI	^ bookkeeperURI! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/6/2012 19:44'!bookkeeperURI: anObject	bookkeeperURI := anObject! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/10/2012 16:10'!managerURI	^ managerURI ifNil: [ Error signal: 'A configuration must have a manager.']! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/6/2012 19:44'!managerURI: anObject	managerURI := anObject! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/31/2012 10:42'!messenger	"FAKE IT."	^ messengerProxy ifNil: [ messengerProxy := HumBus new. ].! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:35'!messenger: uriMessenger manager: uriManager bookkeeper: uriBookkeeper worldbase: uriWorldbase	messengerURI := uriMessenger.	managerURI := uriManager.      bookkeeperURI := uriBookkeeper.       worldbaseURI := uriWorldbase.	"Create the MOCK messenger."	messengerProxy := HumBus new.! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/6/2012 19:44'!messengerURI	^ messengerURI! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:33'!messengerURI: aString	messengerURI := aString.	('*URL*' matches: aString) ifTrue: [self halt].	('*URI' matches: aString ) ifFalse: [ Error signal: 'URI is not in expected (MOCK) format.' ].! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/8/2012 13:42'!ontology	^ ontology ifNil: [ Error signal: 'ontology is missing from configuration']! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/8/2012 13:51'!ontology: aHumOntology 	ontology := aHumOntology.! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/6/2012 19:44'!worldbaseURI	^ worldbaseURI! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/6/2012 19:44'!worldbaseURI: anObject	worldbaseURI := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumConfiguration class	instanceVariableNames: ''!!HumConfiguration class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/6/2012 17:15'!messenger: uriMessenger manager: uriManager bookkeeper: uriBookkeeper worldbase: uriWorldbase 	| instance |	instance := self basicNew.	instance messenger: uriMessenger manager: uriManager bookkeeper: uriBookkeeper worldbase: uriWorldbase.	^instance.! !