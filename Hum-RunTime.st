Object subclass: #HumCalculator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumCalculator commentStamp: 'RichardAlexanderGreen 6/7/2013 15:13' prior: 0!The Calculator role (agent) provides - base level arithmetic (using measures)- string utilities used to parse Hum source code.The Calculator provides compute operations.When a Hum procedure (or Hum Run-Time) needs an interface to the host computer, the Calculator provides it.See also: HumMeasure. -- In the Hum framework, all numbers are measures.TODO: Integrate HumMeasure and HumCalculator.!!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 10/30/2012 13:42'!xml: aTagString attributes: aMap 	"Create a stand-alone tag (ending with '/>') with the given attribute values."	| xml space equals quote |      self assert: ( aMap isKindOf:  OrderedCollection ).	space := String space.	equals := '='.	quote := $" asString.	xml := '<', aTagString.	aMap 		do: [ :map | 			xml := xml, space, map key, equals, quote, map value, quote.			].	xml := xml, ' />'.	^xml.! !!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 10/30/2012 14:11'!xml: aTagString attributes: aMap with: aBlockClosure 	"Generate the front tag and the end tag with block to produce the middle"	| frontTag xml cr indent calc |	calc := HumCalculator new.	self assert: ( aMap isKindOf: OrderedCollection ).	cr := String cr.	indent := '  '.		frontTag :=  calc xmlOpen: aTagString attributes: aMap.	xml := frontTag, cr, 	             indent, ( aBlockClosure value ), cr,			'</', aTagString, '>'.	^xml.! !!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 10/30/2012 13:43'!xml: aTag with: aBlock 	"Fix up the indent after we get this working."	| xml cr indent |	cr := String cr.	indent := '  '.		xml  := '<', aTag, '>', cr			,  indent, ( aBlock value  ) asString, cr			,'</', aTag, '>', cr.	^xml.! !!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 11/22/2012 18:28'!xmlOpen: aTagString attributes: aMap 	"Create an opening tag ( NOT ending with '/>' ) with the given attribute values."	| xml space equals quote |	self assert: ( aMap isKindOf: OrderedCollection ).	space := String space.	equals := '='.	quote := $" asString.	xml := '<', aTagString.	aMap 		do: [:map | 			xml := xml, space, map key, equals, quote, map value, quote.			].		xml := xml, ' >'.	^xml.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumCalculator class	instanceVariableNames: ''!!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 1/13/2012 09:57'!substringFrom: stringIn after: stringA 	"Get the substring that is between the two given."	| x1 stringOut s |	s := stringIn.	stringOut := ''.	x1 := s findString: stringA startingAt: 1.	(x1 > 0 ) 		ifTrue: [ stringOut := stringIn copyFrom: (x1+  stringA size) to: (stringIn size). 			 ].	^stringOut.! !!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 1/13/2012 10:01'!substringFrom: stringIn after: stringA before: stringB	"Get the substring that is between the two given."	| x1 x2 stringOut s |	s := stringIn.	stringOut := ''.	x1 := s findString: stringA startingAt: 1.	(x1 > 0 ) 		ifTrue: [ x2 := s findString: stringB startingAt: x1. 			(x2 > x1)				 ifTrue: [ stringOut := s copyFrom: x1+1 to: x2-1.]. 			 ].	^stringOut.! !!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 1/13/2012 10:12'!substringFrom: stringIn before: stringA 	"Get the substring that is between the two given."	| x1 stringOut s |	s := stringIn.	stringOut := ''.	x1 := s findString: stringA startingAt: 1.	(x1 > 0 ) 		ifTrue: [ stringOut := stringIn copyFrom: 1 to: (x1-1). 			 ].	^stringOut.! !!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 12/19/2012 12:19'!substringFrom: aString includingMatching: pairString	"	s = 'this is before [[blah]] this is after'.	self assert: ( HumCalculator substringFrom: s betweenMatching: '[]' ) = '[[blah]]'.	 "	| startPos pos nestLevel pairStart pairStop |	pairStart := pairString at: 1.	pairStop  := pairString at: 2.	self assert: (pairStart isKindOf: Character ).	self assert: (pairStop isKindOf: Character ).	"Find the start of the substring."	startPos := aString indexOf: pairStart.	"TODO: If there is no starting character, what should we return?"	(startPos > 0 ) 		ifFalse: [ ^nil ].	"Following assumes we have found the starting position."	self assert: startPos > 0.	pos := startPos + 1.	nestLevel := 1.	[ pos <= aString size ] whileTrue: [		| aCharacter |		aCharacter := aString at: pos.		( aCharacter = pairStart ) 			ifTrue: [ nestLevel := nestLevel + 1 ].		( aCharacter = pairStop )  			ifTrue: [ nestLevel := nestLevel - 1 ].		(nestLevel = 0) 			ifTrue: [ |result| result := ( aString copyFrom:startPos to: pos ). ^result. ].		pos := pos + 1.	].	"If we come here, the matching closing character is missing."	Error signal: 'String does not contain a balanced pair: ', pairString.	^nil.! !Object subclass: #HumBlackBoard	instanceVariableNames: 'quads'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumBlackBoard commentStamp: 'RichardAlexanderGreen 9/20/2012 07:21' prior: 0!The blackboard holds the values for nouns in memory that are currently being referenced by an agent.In addition, the blackboard operates the persistence mechanism so that new noun values are recorded on the world-base (database). !!HumBlackBoard methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/18/2012 11:49'!getEntityID: entityID attribute: attributeType 	" Get requested value (if any) from the world base instance "	| tau value |	self assert: (entityID isKindOf: String ).	self assert: (attributeType isKindOf: Symbol ).	"Ignore temporal features for now."		value := (self quads ) at: ( entityID -> attributeType ) ifAbsent: [ nil ].	^ value.! !!HumBlackBoard methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/18/2012 11:48'!quads	^ quads ifNil: [ quads := Dictionary new. ].! !!HumBlackBoard methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 6/7/2013 15:20'!setEntityID: entityID attribute: attributeType toValue: aValue	" Get requested value (if any) from the world base instance "	| tau quad value |	self assert: (entityID isKindOf: String ).	self assert: (attributeType isKindOf: Symbol ).	self assert: ( aValue notNil ).	"Ignore temporal features for now."	"Get value of reqested entity attribute."	(self quads ) at: ( entityID -> attributeType ) put: aValue.		"TODO: Update the world base also."	"TODO: Detect mutations ?"	"TODO: Timestamp (Event-stamp) values."! !Object subclass: #HumVM	instanceVariableNames: 'slots transferVector measure'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumVM commentStamp: 'RichardAlexanderGreen 9/20/2012 07:57' prior: 0!HumVM is a thought experiment for a virtural machine and byte code.After some consideration, I (Richard Alexander Green) decided that a byte code is not a good idea at this time.If compiled code is necessary for efficiency, it would make more sense at this time to translate to a language that has a compiler. Byte Code Advantages:- The resulting code may be more compact than the source and therefore it would require less delivery time.- - counter: Delivery time for an agent`s code is generally not an important factor except possibly for a dialog agent.- A byte code might be more easily compiled to a native ISA.- - counter: It is easier to translate to another language.Disadvantages:- If the normal delivery is byte code the ecology may discourage transparency.- An existing VM such as JVM or BEAM would be more acceptable to many audiences.Instance Variables:	slots	<Dictionary>	transferVector	<Dictionary>	measure	<HumMeasure>!!HumVM methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2012 10:30'!measureRegister	^ measure ifNil: [ measure := HumMeasure new. ].! !!HumVM methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2012 10:10'!setSlot: slotIndex to: aHumObject 	(self slots) at: slotIndex put: aHumObject.! !!HumVM methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2012 10:11'!slots	"slots allow objects to be referenced by byte-code indices."	^ slots ifNil: [slots := Dictionary new. ].! !!HumVM methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2012 10:39'!transferVector	transferVector ifNil: [ transferVector := Dictionary new.		transferVector 			at: 001 put: [ :x | measure := x  ];			at: 002 put: [ :x | measure := measure + x ];			at: 003 put: [ :x | measure := measure - x ];			at: 000 put: [ :x | self halt ].		].	^transferVector.! !!HumVM methodsFor: 'self evaluating' stamp: 'RichardAlexanderGreen 6/20/2013 09:41'!runInstruction: aHumInstruction 	| microCode |	"Get the microCode. (a block)"	microCode := ( self transferVector ) at: (aHumInstruction operation) 	                                                     ifAbsent: [ Error signal: 'No such opCode: ', (aHumInstruction operation)].	"Run the microCode. (a block)"	microCode value: ( self slots at: (aHumInstruction operand)).	"Assure cascade."	^self. ! !Object subclass: #HumVMInstruction	instanceVariableNames: 'operation operand'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumVMInstruction commentStamp: 'RichardAlexanderGreen 9/20/2012 07:59' prior: 0!HumVM and HumVMInstruction are artifacts of a thought experiment for a virtural machine and byte code.See the HumVM class comment for further information.Instance Variables:	operation	<Integer>	operand	<Integer>Class Instance Variables:	codeNames	<Dictionary>!!HumVMInstruction methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:12'!operand	^ operand ifNil: [ Error signal: 'operand not set in HumInstruction'.  operand := 000].! !!HumVMInstruction methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:10'!operand: objectIndex 	operand := objectIndex! !!HumVMInstruction methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:11'!operation	^ operation ifNil: [ Error signal: 'op code not set in HumInstruction'.  operation := 000].! !!HumVMInstruction methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:09'!operation: opCode 	self assert: ( opCode < 256 ).	self assert: ( opCode >= 0 ).	operation := opCode.! !!HumVMInstruction methodsFor: 'associating' stamp: 'RichardAlexanderGreen 9/20/2012 07:37'!opCodeName	| name |	name := ( HumVMInstruction codeNames ) at: (self operation) ifAbsent: ['Unknown'].	^name.! !!HumVMInstruction methodsFor: 'associating' stamp: 'RichardAlexanderGreen 7/25/2012 10:18'!slotName	( (self operand) = 000 ) ifTrue: [^ 'None' ].	Error signal: 'Instruction slot name is not defined.'.	^'Undefined.'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumVMInstruction class	instanceVariableNames: 'codeNames'!!HumVMInstruction class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 7/24/2012 16:27'!opCode: opCode value: objectIndex 	| instruction |	instruction := self basicNew.	instruction operation: opCode.	instruction operand: objectIndex.	^instruction.! !!HumVMInstruction class methodsFor: 'associating' stamp: 'RichardAlexanderGreen 7/24/2012 16:26'!opCodeName	name := (self codeNames ) at: (self operation).	^name.! !!HumVMInstruction class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:33'!codeNames	codeNames ifNotNil: [ ^codeNames ].	"Otherwise, initialize . . ."	codeNames := Dictionary new.	codeNames at: 000 put: 'Halt'.! !Magnitude subclass: #HumFuzzy	instanceVariableNames: 'distribution sampleSize'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumFuzzy commentStamp: 'RichardAlexanderGreen 4/9/2013 09:48' prior: 0!This class implements fuzzy arithmetic using Monte Carlo sampling of the distributions.!!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2013 11:14'!atP: aFloat 	"Return the appropriate value from the distribution.	Iterpolate when necessary. 	This version uses linear interpolation.	Future versions might use a spline or something."	| result |	"Check that aFloat is between zero and one"	self assert: ( aFloat isKindOf: Float ).	self assert: ( aFloat >= 0.0 ).	self assert: ( aFloat <= 1.00).	"Look up value or interpolate to get a result."	result := distribution at: aFloat ifAbsent: [ self interpolate: aFloat ].	^ result.! !!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/22/2013 10:05'!distribution: aDictionary 	self assert: ( aDictionary isKindOf: Dictionary ).	distribution := aDictionary.! !!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2013 13:41'!initialize	sampleSize := 10000.! !!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2013 11:20'!interpolate: aProbability	"Interpolate the predicted value at aProbability"	| lowerP lowerF upperP upperF slope intercept result |	self assert: (aProbability isKindOf: Float ).	"Following depends on Dictionary semantics"	self assert: ( distribution isKindOf: Dictionary ).	lowerP := 0.0.	lowerF := distribution at: lowerP.	upperP := 1.0.	upperF := distribution at: upperP.	distribution keysAndValuesDo: [ :k :v |		( k > lowerP and: [ k < aProbability ] ) ifTrue: [ lowerP := k. lowerF := v. ].		( k < upperP and: [ k > aProbability ] ) ifTrue: [ upperP := k. upperF := v. ].		].	"Do simple linear interpolation."	slope :=  ( upperF - lowerF ) / ( upperP - lowerP ).	"Check: for an S-Curve the slope is always positive."	self assert: ( slope > 0.0 ).		result := lowerF + ( (aProbability - lowerP) * ( slope) ).	"Check: the result must be between upper and lower function values"	self assert: ( result > lowerF ).	self assert: ( result < upperF ).	^result.! !!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2013 13:14'!median	"find the point that represents the median"	|  medianPoint |	"Distribution is list of f->p".	"Look for f@0.50"	medianPoint := self atP: 0.50.	^medianPoint.! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/9/2013 14:15'!* aHumFuzzy 	| times result |	times := #*.	result := self op: times with: aHumFuzzy.	^result.! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/9/2013 13:42'!+ aHumFuzzy "Add two fuzzy distibutions using Monte Carlo sampling"	| resultSet random  vC sortedSet distributionC tick count fuzzyC |	resultSet := Set new.	random := Random new.	( 1 to: sampleSize )		do: [ :i |			| rA rB vA vB |			rA := random next.			vA := self atP: rA.			rB := random next.			vB := aHumFuzzy atP: rB.			vC := vA + vB.			resultSet add: vC.			].	"Create a new distribution with points every 10%"	sortedSet := resultSet asSortedCollection.	self assert: ( sortedSet size = sampleSize ).	distributionC := Dictionary new.	distributionC at: 0.0 put: ( sortedSet first ). "TODO: Should be a calculated intercept."	tick := sampleSize / 10.	count := 0.	sortedSet		do: [ :x | 				| modulo |			  count := count + 1.				modulo := ( count \\ tick ).				( modulo = 0 )					ifTrue: [ distributionC at: ( (count/sampleSize) asFloat )  put: x ].			 ].	self assert: ( distributionC size = 11 ).	fuzzyC := HumFuzzy distribution: distributionC.	^fuzzyC.		! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/9/2013 14:11'!- aHumFuzzy 	| minus result |	minus := #-.	result := self op: minus with: aHumFuzzy.	^result.! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/9/2013 14:13'!/ aHumFuzzy 	| divide result |	divide := #/.	result := self op: divide with: aHumFuzzy.	^result.! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/22/2013 09:59'!mean	| sum n result |	sum := 0.0.	n := 0.	self sampleWithBlock: [ :x | n := n + 1. sum := sum + x.].	result := sum / n.	^result.! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/22/2013 12:09'!op: aSymbol with: aHumFuzzy "Add two fuzzy distibutions using Monte Carlo sampling"	| resultSet random  vC sortedSet distributionC tick count fuzzyC |	resultSet := Set new.	random := Random new.	( 1 to: sampleSize )		do: [ :i |			| rA rB vA vB |			rA := random next.			vA := self atP: rA.			rB := random next.			vB := aHumFuzzy atP: rB.			vC := vA perform: aSymbol with: vB.			resultSet add: vC.			].	"Create a new distribution with points every 10%"	sortedSet := resultSet asSortedCollection.	self assert: ( sortedSet size = sampleSize ).	"Note: Assertion above occasionally fails (size = is off by one) for an unknown reason.	TODO: Figure out why that occurs."	distributionC := Dictionary new.	distributionC at: 0.0 put: ( sortedSet first ). "TODO: Should be a calculated intercept."	tick := sampleSize / 10.	count := 0.	sortedSet		do: [ :x | 				| modulo |			  count := count + 1.				modulo := ( count \\ tick ).				( modulo = 0 )					ifTrue: [ distributionC at: ( (count/sampleSize) asFloat )  put: x ].			 ].	self assert: ( distributionC size = 11 ).	fuzzyC := HumFuzzy distribution: distributionC.	^fuzzyC.		! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/22/2013 10:01'!sampleWithBlock: aBlock "Operate on fuzzy distibution using Monte Carlo sampling"	| resultSet random |	resultSet := Set new.	random := Random new.	( 1 to: sampleSize )		do: [ :i |			| rA  vA  |			rA := random next.			vA := self atP: rA.			aBlock value: vA.			].		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFuzzy class	instanceVariableNames: ''!!HumFuzzy class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/9/2013 13:43'!distribution: aDistribution	"Create a new instance from the given distribution."	| fuzzy |	fuzzy := self basicNew.	fuzzy initialize.	fuzzy distribution: aDistribution.	^fuzzy.! !!HumFuzzy class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/22/2013 10:24'!quantity: aQuantity plusOrMinus: aLimit 	"Create a distribution with given limits."	| fuzzy stats |	self assert: ( aQuantity isKindOf: Number ).	self assert: (    aLimit isKindOf: Number ).	"Assume upper and lower will not be exceeded.	The idea is that cases exceeding those measures would be rejected.	"	fuzzy := self basicNew.	fuzzy initialize.	stats := Dictionary new.	stats		at: 0.50  put: aQuantity;		at: 0.00  put: (aQuantity - aLimit );		at: 1.00  put: (aQuantity + aLimit ).	fuzzy distribution: stats.	^fuzzy.! !Magnitude subclass: #HumMeasure	instanceVariableNames: 'dimensions quantity'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumMeasure commentStamp: 'RichardAlexanderGreen 4/28/2013 09:42' prior: 0!HumMeasure2 (experiment) extends HumMeasure to track non-KMS units and cancel units when they both appear in the numerator and denominator.If it works out, the mechanism may be merged into HumMeasure.!!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/28/2013 10:12'!dimensions	^ dimensions ifNil: [ dimensions := Dictionary new.]! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/29/2013 10:59'!dimensions: aDictionary 	dimensions := aDictionary! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/28/2013 10:28'!quantity	^ quantity ifNil: [ quantity := 0.0 ].! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/28/2013 10:30'!quantity: aNumber 	quantity := aNumber! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/28/2013 13:14'!quantity: aNumber units: numeratorUnits 	"Set instance numerator units	"	| unitsString exponent |	quantity := aNumber.		exponent := 1.	(numeratorUnits beginsWith: 'square' ) ifTrue: [ exponent := 2 ].	(numeratorUnits beginsWith: 'cubic' ) ifTrue: [ exponent := 3 ].	(self dimensions) at: (self standardNameFor: numeratorUnits ) put: ( exponent ).	 	 ! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/4/2013 11:04'!quantity: aNumber units: numeratorUnits per: denominatorUnits	"Set instance numerator and denominator units.	Example1:	   milesPerHour := HumMeasure2 quantity: 65 units: 'miles' per: 'hour'.	   feetPerMile := HumMeasure2 quantity: 5280 units: 'feet' per: 'mile'.	   feetPerHour := milesPerHour * feetPerMile.		 secondsPerHour := HumMeasure2 quantity: 3600 units: 'seconds' per: 'hour'.		 feetPerSecond := feetPerHour / secondsPerHour.	"	| exponent standardName numeratorExponent |	quantity := aNumber.	exponent := 1.	(numeratorUnits beginsWith: 'square' ) ifTrue: [ exponent := 2 ].	(numeratorUnits beginsWith: 'cubic' ) ifTrue: [ exponent := 3 ].	(self dimensions) at: (self standardNameFor: numeratorUnits) put: ( exponent ).		exponent := -1.	(denominatorUnits beginsWith: 'square' ) ifTrue: [ exponent := -2 ].	(denominatorUnits beginsWith: 'cubic' ) ifTrue: [ exponent := -3 ].	standardName := self standardNameFor: denominatorUnits.	"Get matching numerator exponent, if any, so that we correctly handle ratios 	 such as 'length per length' and 'dollars per dollar' "	numeratorExponent := (self dimensions) at: standardName ifAbsent: [0].	(self dimensions) at: standardName put: ( numeratorExponent + exponent ).	 	 ! !!HumMeasure methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 5/8/2013 18:43'!* multiplier 	| result |	result := self deepCopy.	(multiplier isKindOf: Number) 		ifTrue: [ result := self deepCopy. 							result quantity: (self quantity * multiplier).							^result.							].	result quantity: (self quantity) * (multiplier quantity).	(multiplier dimensions)		keysAndValuesDo: [ :unit :exponent | 			"Increment and net-out the dimensions."			result incrementDimensionsAt: unit by: exponent.			].	^result.	! !!HumMeasure methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/29/2013 09:45'!+ operand 	| result |	"The units of measure must be the same."	self assert: (operand dimensions) = (self dimensions).	"Make a deep copy to get fresh dimensions and quantity."	result := self deepCopy.	result quantity: (self quantity) + (operand quantity).	^result.	! !!HumMeasure methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/29/2013 09:43'!- operand 	| result |	self assert: (operand dimensions) = (self dimensions).	result := self deepCopy.	result quantity: (self quantity) - (operand quantity).	^result.	! !!HumMeasure methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 5/8/2013 18:43'!/ aDivisor 	| result divisor |	result := self deepCopy.	( aDivisor isKindOf: HumMeasure )		ifTrue: [divisor := aDivisor].	( aDivisor isKindOf: Duration )		ifTrue: [divisor := HumMeasure quantity: (aDivisor asSeconds) units: 'second'. ].	( aDivisor isKindOf: Number )		ifTrue: [ result quantity: (self quantity / aDivisor). ^ result. ].					result quantity: (self quantity) / (divisor quantity).	(divisor dimensions)		keysAndValuesDo: [ :unit :exponent |			"Decrement and net-out the dimensions."			result incrementDimensionsAt: unit by: (exponent negated).			].	^result.	! !!HumMeasure methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 5/4/2013 20:14'!= operand 	| result |	"The units of measure must be the same."	((operand dimensions) = (self dimensions)) ifFalse: [^false].		result := (self quantity) closeTo: (operand quantity).	^result.	! !!HumMeasure methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 5/8/2013 18:48'!incrementDimensionsAt: aUnit by: anIncrement	"Increment / Decrement dimension exponent by given increment (negative when decrementing).	"	| x |	self assert: (anIncrement isKindOf: SmallInteger ).	x := (self dimensions) at: aUnit ifAbsent: [0].	"Remove zeroed dimensions."	"TODO: THINK: This discards potentially useful information." 	(( x + anIncrement ) = 0)				ifTrue:  [ (self dimensions) removeKey: aUnit ]  				ifFalse: [ (self dimensions) at: aUnit put: ( x + anIncrement )].					"TODO: When units cancel (e.g. length/length), find some way to preserve information.	Example: L^0 Degree^-1 should find L^1 Degree^1 in a multiplier.	"	! !!HumMeasure methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 5/4/2013 20:55'!negated	| result |	result := self deepCopy.	result quantity: (self quantity) negated.	^result.! !!HumMeasure methodsFor: 'converting' stamp: 'RichardAlexanderGreen 5/4/2013 20:09'!as: aSymbol	"Convert to the unit of measure indicated by aSymbol"	| result qty divisor string displayUnits|	divisor := 1.0 perform: aSymbol.	self assert: (self dimensions) = (divisor dimensions).	result := self / divisor.	qty := result quantity.	displayUnits := aSymbol asString.	((qty abs) between: 0.1 and: 99999.0 )		ifTrue:  [ string := ( ( qty printShowingDecimalPlaces: 3), ' ', displayUnits )]		ifFalse: [ string := ( ( qty asString                    ), ' ', displayUnits )].	^string.! !!HumMeasure methodsFor: 'converting' stamp: 'RichardAlexanderGreen 4/28/2013 13:29'!units	"Render dimensions as a string"	| string append prefix  secondPassNeeded |	append := Dictionary new.	append 		at: 2 put: 'square ';		at: 3 put: 'cubic '.	string := String new.	secondPassNeeded := false.	(self dimensions)		keysAndValuesDo: [ :unit :exponent |					( exponent > 0 ) 						ifTrue: [ 							prefix := append at: exponent ifAbsent: [''].							string := string, prefix, unit, ' '.									]						ifFalse: [ (exponent < 0 ) ifTrue: [ secondPassNeeded := true ] ].					].	secondPassNeeded 		ifTrue: [ 			string := string, 'per '.			(self dimensions)				keysAndValuesDo: [ :unit :exponent |					( exponent < 0 ) 						ifTrue: [ 							prefix := append at: (exponent negated) ifAbsent: [''].							string := string, prefix, unit, ' '.									]					].			].		^string trimBoth.	! !!HumMeasure methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 4/29/2013 10:46'!asString	| result displayUnits |	displayUnits := (self units).	(self dimensions = (Dictionary newFrom: {'kilogram'->1. 'meter'->1. 'second'->(-2).}) )			ifTrue: [displayUnits := 'Newton'].	(self dimensions = (Dictionary newFrom: {'kilogram'->1. 'meter'->(-1). 'second'->(-2).}) )			ifTrue: [displayUnits := 'Pascal'].	(self dimensions = (Dictionary newFrom: {'kilogram'->1. 'meter'->2. 'second'->(-2).}) )		ifTrue: [displayUnits := 'Joule'].	(self dimensions = (Dictionary newFrom: {'kilogram'->1. 'meter'->2. 'second'->(-3).}) )		ifTrue: [displayUnits := 'Watt'].	( quantity = (quantity truncated) ) 		ifTrue:[ result := ((quantity truncated) asString), ' ', displayUnits. 						  ^result. 					 ].	((quantity abs) between: 0.1 and: 99999.0 )		ifTrue:  [ result := ( ( quantity printShowingDecimalPlaces: 3), ' ', displayUnits )]		ifFalse: [ result := ( ( quantity asString                    ), ' ', displayUnits )].	^result.! !!HumMeasure methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 4/28/2013 13:18'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		nextPutAll: title;		nextPutAll: ( '( ', (self asString), ' )' ).! !!HumMeasure methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 4/28/2013 12:59'!standardNameFor: aString 	| unitsString |	unitsString := aString trimBoth.	"Remove square- cubic-"	(unitsString beginsWith: 'square' ) ifTrue: [ unitsString := unitsString copyReplaceTokens: 'square' with: ''].	(unitsString beginsWith: 'cubic' ) ifTrue: [ unitsString := unitsString copyReplaceTokens: 'cubic' with: ''].	unitsString := unitsString trimBoth.	"Standardize terms"	(unitsString = 'feet') ifTrue: [ unitsString = 'foot' ].	(unitsString = 'miles') ifTrue: [ unitsString = 'mile' ].	(unitsString = 'meters') ifTrue: [ unitsString = 'meter' ].	(unitsString = 'kg') ifTrue: [ unitsString = 'kilogram' ].	(unitsString = 'km') ifTrue: [ unitsString = 'kilometer' ].	(unitsString = 'inches') ifTrue: [ unitsString = 'inch' ].		self assert: ( unitsString endsWith: 's' ) not.	^unitsString.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumMeasure class	instanceVariableNames: ''!!HumMeasure class methodsFor: 'examples' stamp: 'RichardAlexanderGreen 5/4/2013 10:53'!example3	"How much power is required to lift water from Missippi / Missouri to High Plains.	"	| density acre foot acreFoot mass gravity weight lift energy timePeriod watts irrigatedAcres totalWatts |		density := HumMeasure quantity: 1000 units: 'kilogram' per: 'cubic meter'.			" HumMeasure2( 1000 kilogram per cubic meter )"		acre := HumMeasure quantity: 4046.873 units: 'square meter'.		" HumMeasure2( 4046.873 square meter )"			foot := HumMeasure quantity: 0.3048 units: 'meter'.						" HumMeasure2( 0.305 meter )"						acreFoot := acre * foot.																			" HumMeasure2( 1233.487 cubic meter )"				mass := acreFoot * density.																		" HumMeasure2( 1.2334868904e6 kilogram )"																					gravity := HumMeasure quantity: 9.80665 units: 'meter' per: 'square second'.																														" HumMeasure2( 9.807 meter per square second )" 	weight := mass * gravity.																			" HumMeasure2( 1.2096374213741159e7 Newton )"																				lift := HumMeasure quantity: (5000*0.3048) units: 'meter'.		" HumMeasure2( 1524 meter )"	energy := weight * lift.																			" HumMeasure2( 1.8434874301741528e10 Joule )"	timePeriod := HumMeasure quantity: 31449600 units: 'second'.		" HumMeasure2( 31449600 second )"	watts := energy / timePeriod.																	" HumMeasure2( 586.172 Watt )"	irrigatedAcres := 13.6e6." 1.36e7"	totalWatts := watts * irrigatedAcres.		" HumMeasure2( 7.971938927798279e9 Watt ) ==> 8 GigaWatt"	^totalWatts asString.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/29/2013 10:32'!acre: aNumber	| measure |	measure := self quantity: (4046.873 * aNumber) units: 'square meter'.		^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 5/4/2013 10:41'!astronomicalUnit: aNumber	| measure |	measure := self quantity: ( aNumber * 149597870700 ) units: 'meter'.		^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 5/4/2013 10:42'!au: aNumber	| measure |	measure := self astronomicalUnit: aNumber.	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 5/4/2013 10:42'!britishThermalUnit: aNumber	"Energy - British Thermal Unit (ISO)"	| measure |	measure := self quantity: ( aNumber * 1.0545) units: 'Joule'.	measure dimensions: (Dictionary newFrom: {'kilogram'->1. 'meter'->2. 'second'->(-2).}). 	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 5/4/2013 10:42'!btu: aNumber	"Energy - British Thermal Unit (ISO)"	| measure |	measure := self britishThermalUnit: aNumber.	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/29/2013 10:34'!foot: aNumber	| measure |	measure := self quantity: (0.3048 * aNumber) units: 'meter'.		^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 5/4/2013 10:32'!footH2O: aNumber	"foot of water - pressure"	| measure |	measure := HumMeasure quantity: ( aNumber * 2.98898e3 ) units: 'Pascal'.	measure dimensions: (Dictionary newFrom: { }).	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/29/2013 11:01'!gravity: aNumber	| measure |	measure := self quantity: (9.80665 * aNumber) units: 'meter' per: 'square second'.	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/29/2013 11:45'!horsePower: aNumber	| measure |	measure := self quantity: ( aNumber * 735.49875 ) units: 'Watt'.	measure dimensions: (Dictionary newFrom: {'kilogram'->1. 'meter'->2. 'second'->(-3).}).	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 5/4/2013 10:34'!joule: aNumber	"Energy - British Thermal Unit (ISO)"	| measure |	measure := self quantity: ( aNumber ) units: 'Joule'.	measure dimensions: (Dictionary newFrom: {'kilogram'->1. 'meter'->2. 'second'->(-2).}). 	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/29/2013 11:39'!lightSpeed	| measure |	measure := self quantity: (1e8) units: 'meter' per: 'second'.	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/29/2013 11:41'!lightSpeed: aNumber	"Only makes sense if aNumber < 1."	| measure |	measure := self quantity: (1e8 * aNumber) units: 'meter' per: 'second'.	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 5/4/2013 10:40'!meter: aNumber	| measure |	measure := self quantity: (aNumber) units: 'meter'.		^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 5/4/2013 10:33'!pascal: aNumber	"foot of water - pressure"	| measure |	measure := HumMeasure quantity: ( aNumber ) units: 'Pascal'.	measure dimensions: (Dictionary newFrom: {'kilogram'->1. 'meter'->(-1). 'second'->(-2). }).	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/29/2013 11:47'!psi: aNumber	"pound per square inch - pressure"	| measure |	measure := self quantity: ( aNumber * 6.894757e3 ) units: 'Pascal'.	measure dimensions: (Dictionary newFrom: {'kilogram'->1. 'meter'->(-1). 'second'->(-2).}). 	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/28/2013 10:47'!quantity: aNumber units: aString 	| instance |	instance := self basicNew.	instance quantity: aNumber units: aString.	^instance.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/28/2013 10:11'!quantity: aNumber units: numeratorUnits per: denominatorUnits	"Create instance with given numerator and denominator units.	Example1:	   milesPerHour := HumMeasure2 quantity: 65 units: 'miles' per: 'hour'.	   feetPerMile := HumMeasure2 quantity: 5280 units: 'feet' per: 'mile'.	   feetPerHour := milesPerHour * feetPerMile.		 secondsPerHour := HumMeasure2 quantity: 3600 units: 'seconds' per: 'hour'.		 feetPerSecond := feetPerHour / secondsPerHour.	"	| instance |	instance := self basicNew.	instance quantity: aNumber units: numeratorUnits per: denominatorUnits.	^instance.		 	 	 	 ! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 5/4/2013 10:35'!watt: aNumber	"Energy - British Thermal Unit (ISO)"	| measure |	measure := self quantity: ( aNumber ) units: 'Watt'.	measure dimensions: (Dictionary newFrom: {'kilogram'->1. 'meter'->2. 'second'->(-3).}). 	^measure.! !FloatArray variableWordSubclass: #HumVector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumVector commentStamp: 'RichardAlexanderGreen 4/26/2013 14:23' prior: 0!A vector to be used in geometry and Physics. Also implements functional programming concepts that enable cascading operations on large arrays.Extends FloatArray.Uses FloatArray dot: for dot product.Adds cross product:The three scalar components of the vector s=s1i+s2j+s3k = u×v are:s1 = u2*v3 - u3*v2s2 = u3*v1 - u1*v3s3 = u1*v2 - u2*v1!!HumVector methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/26/2013 14:49'!cross: v	"Return the 3-dimensional vector cross product U x V	where U is self and V is the argument.	The three scalar components 		of the vector s=s1i+s2j+s3k = u×v 		are:			s1 = u2*v3 - u3*v2			s2 = u3*v1 - u1*v3			s3 = u1*v2 - u2*v1	"	| u s |	self assert: ( self size = 3 ).	self assert: ( v size = 3 ).	u := self copy.	s := self class ofSize: 3.	s at: 1 put: ((u at: 2)*(v at: 3)) - ((u at: 3)*(v at: 2)).	s at: 2 put: ((u at: 3)*(v at: 1)) - ((u at: 1)*(v at: 3)).	s at: 3 put: ((u at: 1)*(v at: 2)) - ((u at: 2)*(v at: 1)).	^s.		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumVector class	instanceVariableNames: ''!!HumVector class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/26/2013 15:12'!ones: n	"Create a unit vector (all ones) of given size"
	| v  |	v := self new: n withAll: 1.0.	^v.! !!HumVector class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/26/2013 15:17'!zero: n	"Create a unit vector (all ones) of given size"
	| v  |	v := self new: n withAll: 0.0.	^v.! !Object subclass: #HumEntity	instanceVariableNames: 'title id'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/16/2013 10:01'!asString	^title.! !!HumEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/18/2013 10:38'!id	^ id ifNil: [ id := (UUID new) asString36 ].! !!HumEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/18/2013 10:40'!printOn: aStream	| myClassName |	myClassName := self class name.	aStream nextPutAll: ( myClassName,'(',id,')' ).! !!HumEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/13/2013 08:47'!title	"a display string describing this entity" 	^ title.! !!HumEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/13/2013 08:47'!title: aString	"a display string describing this entity" 	title := aString.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumEntity class	instanceVariableNames: ''!!HumEntity class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/13/2013 08:44'!title: aString	| instance |	instance := self basicNew.	instance title: aString.	^instance.! !HumEntity subclass: #HumJobTicket	instanceVariableNames: 'ontology titleLine charges'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumJobTicket commentStamp: 'RichardAlexanderGreen 6/7/2013 16:02' prior: 0!A job ticket records the resources consumed by a job.A job is initiated when a goal is set running.When actions are delegated by the one actor to other actors, they get jobtickets also.The resulting resource data is consolidated on the parent-level job-ticketsso that the costs are rolled-up to each level and eventually to the job as a whole.When each action is completed, the resource manager reports new resource entries to the Bookkeeper.Hence a running account is maintained for the job, for each resource, for each actor, for each role, for each action.---Dictionary: Job Vocabulary.Job attributes include goal-invocation, resource-usage.Goal-invocation attributes include invocation-event, goal.Resource-usage has a list of usage-notes.Usage-note attributes include resource, quantity-used, by-actor, in-role, performing-action.---Note that resource accounting only sums resource quantities.It does not attempt to monetize (price) the resources used because that is a very specialized process.For example, withdrawals from inventory might be priced using LIFO, FIFO, or some other accounting practice.TODO: Refactor job ticket so that it is not a subtype of data frame.      (2013-06-07) A job ticket is currently a subtype of HumDataFrame.       That is a bad idea because it mixes ticket concept with serialization process.!!HumJobTicket methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/18/2013 10:22'!appendCharge: aHumMeasure forAction: action byActor: anID inRole: aRoleName onJob: aJobID 	| charge |	"Use a dictionary to represent a charge."	charge := Dictionary new.	charge 		at: 'measure' put: aHumMeasure asString;		at: 'action'  put: action asString;		at: 'ID'      put: anID asString;		at: 'role'    put: aRoleName asString;		at: 'job'     put: aJobID asString.			"Append this charge to ticket`s charges."	
  ( self charges ) add: charge.	! !!HumJobTicket methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/10/2013 09:11'!appendCharge: aHumMeasure forResource: actorName 	| s |  "Use #appendCharge:forAction:byActor:inRole:onJob: instead"		self halt.	s := 'actor: {', actorName, '} charges: ', aHumMeasure asString.	self addFrameLine: s.! !!HumJobTicket methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/10/2013 10:07'!charges	^charges ifNil: [ charges := OrderedCollection new.]! !!HumJobTicket methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/10/2013 09:47'!ontology: aHumOntology 	"TODO: Why does job ticket need to know?	Is job ticket a subtype of something?"	ontology := aHumOntology.! !!HumJobTicket methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/10/2013 09:48'!titleLine: aString 	titleLine := aString.! !Object subclass: #HumWorldBase	instanceVariableNames: 'title quads'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumWorldBase commentStamp: 'RichardAlexanderGreen 2/19/2013 09:29' prior: 0!The world base is a data base for a "world".Typically, a "world" is an enterprise.But, it could be a game or a simulation.A world base is a temporal database.All stored values are versioned.For an entity, each stored attribute has a value and a time-span.The time-span, in turn, has two event-stamps corresponding to the event which populated or updated the value and the event which changed the value.A world base entry is a quad (4-tuple) of pointers:. ( entity, attribute, value, time-span ).Entity Schema:. Entity has attributes.. Attribute has value and time-span.. Time-span has start-event, stop-event.Event Schema:. Event has client, portal, context, date-time.. . . . . . . who . where . . why . . . when (what is the data affected). Client has identifier, client-type, credentials, ongoing-dialog.. Client-type categories include person, robot.. Context has job, ontology, frame, statement.!!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/18/2012 08:11'!getEntityID: entityID attribute: attributeType 	" Get requested value (if any) from the world base instance "	| tau value |	self assert: (entityID isKindOf: String ).	self assert: (attributeType isKindOf: Symbol ).	"Ignore temporal features for now."		value := (self quads ) at: ( entityID -> attributeType ) ifAbsent: [ nil ].	^ value.! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/18/2012 07:37'!quads	^ quads ifNil: [ quads := Dictionary new. ].! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/7/2013 15:11'!setEntityID: entityID attribute: attributeType value: aValue	" Get requested value (if any) from the world base instance "	| tau quad value |	self assert: (entityID isKindOf: String ).	self assert: (attributeType isKindOf: Symbol ).	self assert: ( aValue notNil ).	"Ignore temporal features for now."	"Get value of reqested entity attribute."	(self quads ) at: ( entityID -> attributeType ) put: aValue.	"TODO: Add temporal feature/s to WorldBase."! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/12/2012 10:32'!title	^ title ifNil: [ Error signal: 'A world base instance must have a title.'].! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/12/2012 10:34'!title: aWorldBaseName 	self assert: ( aWorldBaseName isKindOf: String ).	title := aWorldBaseName.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumWorldBase class	instanceVariableNames: ''!!HumWorldBase class methodsFor: 'accessing instances and variables' stamp: 'RichardAlexanderGreen 10/12/2012 10:33'!openWorldBase: aWorldBaseName	"Open the world base instance with the given name.	If it does not already exist, create a new instance." 	| instance |	self assert: ( aWorldBaseName isKindOf: String ).	instance := self basicNew.	instance title: aWorldBaseName.	^instance.! !Object subclass: #HumConfiguration	instanceVariableNames: 'messengerID managerID bookkeeperID worldbaseID ontology messengerProxy'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumConfiguration commentStamp: 'RichardAlexanderGreen 9/20/2012 07:36' prior: 0!A configuration holds the information about how an agent is connected to other agents.Instance Variables:	messengerURI	<URI>	managerURI	<URI>	bookkeeperURI	<URI>	worldbaseURI	<URI>	ontology	<HumOntology>	messengerProxy	<HumBus>!!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 10:42'!bookkeeper	^ bookkeeperURI ifNil: [ Error signal: 'Bookkeeper is missing!!' ].! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/24/2013 17:51'!bookkeeperID	^ bookkeeperID! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/24/2013 17:52'!bookkeeperID: anObject	bookkeeperID := anObject! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/24/2013 17:52'!managerID	^ managerID ifNil: [ Error signal: 'A configuration must have a manager.']! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/24/2013 17:52'!managerID: anObject	managerID := anObject! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/21/2013 15:49'!messenger	^ messengerProxy ifNil: [ Error signal: 'Messenger not configured yet.' ].! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/21/2013 15:50'!messenger: aHumMessenger	"Set the messenger -- Use to configure mocks when needed."  messengerProxy := aHumMessenger! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/24/2013 17:53'!messenger: IDMessenger manager: IDManager bookkeeper: IDBookkeeper worldbase: IDWorldbase	messengerID := IDMessenger.	managerID := IDManager.  bookkeeperID := IDBookkeeper.   worldbaseID := IDWorldbase.! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/24/2013 17:53'!messengerID	^ messengerID! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/24/2013 17:53'!messengerID: aString	messengerID := aString.	('*URL*' matches: aString) ifTrue: [self halt].	('*ID' matches: aString ) ifFalse: [ Error signal: 'ID is not in expected (MOCK) format.' ].! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/8/2012 13:42'!ontology	^ ontology ifNil: [ Error signal: 'ontology is missing from configuration']! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/8/2012 13:51'!ontology: aHumOntology 	ontology := aHumOntology.! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/24/2013 17:54'!worldbaseID	^ worldbaseID! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/24/2013 17:54'!worldbaseID: anObject	worldbaseID := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumConfiguration class	instanceVariableNames: ''!!HumConfiguration class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/25/2013 09:45'!configuration: aHumConfiguration	"Create an instance with the same configuration as the given configuration."	 | c instance |	 c := aHumConfiguration.   instance := self messenger: c messengerID                       manager: c managerID                    bookkeeper: c bookkeeperID                     worldbase: c worldbaseID.   instance messenger: c messenger.	instance ontology: c ontology.	^ instance.! !!HumConfiguration class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/25/2013 09:53'!messenger: IDMessenger manager: IDManager bookkeeper: IDBookkeeper worldbase: IDWorldbase 	| instance |	instance := self basicNew.	instance messenger: IDMessenger manager: IDManager bookkeeper: IDBookkeeper worldbase: IDWorldbase.	instance ontology: HumOntology baseOntology.	^instance.! !HumConfiguration subclass: #HumActor	instanceVariableNames: 'myID myURI roles blackboard'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumActor commentStamp: 'RichardAlexanderGreen 9/19/2012 11:32' prior: 0!An actor is capable of performing one or more roles.Some actors are part of the run-time systems and have particular configuration requirements.In general, an actor needs a connection to a messenger in order to communicate with the system.Most actors also need a connection to a manager so that the manager can assign actions to the actor.Some actors also need a connection to a bookkeeper so that the actor can record utilization.Instance Variables:	myID	<String>	myURI	<String>	messengerURI	<URI>	bookkeeperURI	<URI>	roles			<Collection of: String>	managerURI	<URI>	configuration	<HumConfiguration>!!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/18/2012 10:40'!blackboard	^ blackboard ifNil: [ blackboard := HumBlackBoard new. ].! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:00'!id	^myID! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:00'!id: aString 	self assert: (aString isKindOf: String ).	myID := aString.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:49'!manager: anID uri: aURI configuration: aHumConfiguration 	self configuration: aHumConfiguration.	self id: anID.	self uri: aURI.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/21/2013 16:04'!roles	(roles isNil and: [self class = HumActor]) ifNil: [ Error signal: 'Actor {', myID,'} has no role.' ].	^roles ifNil: [ roles := { self class name. }].! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/26/2012 20:10'!roles: anArray 	self assert: ( anArray isKindOf: Array ).	roles := anArray.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 08:59'!uri	^myURI! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/21/2013 16:21'!uri: aURI	self assert: ( aURI isKindOf: String ).	myURI := aURI.	"My identifier (myID) should be established at this point also."	"Because I need it to check-in with the messenger."	self assert: (myID isKindOf: String ).! !!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 6/25/2013 10:34'!checkIn	| statement quotedRoles |	"First, check-in with the messenger."	( self messenger ) registerActor: self atActorURL: (self uri).	"Send check-in message to my resource manager."	quotedRoles := ''.	(self roles)		do: [ :role | quotedRoles := quotedRoles, ' ', role quoted ].	statement := HumStatement source: 'Check-in actor with roles.'.	statement role: 'Resource-Manager'.	statement noun: 'actor' value: myURI.	statement noun: 'roles' value: quotedRoles.	statement jobTicket: (HumJobTicket new).	statement translation: ('self checkInActor: ', myID quoted, ' at: ', myURI quoted, 'withRoles: #(', quotedRoles, ')').	self delegateAction: statement to: (self managerID).	! !!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 6/26/2013 09:53'!completedStatement: aHumStatement inRole: aRoleString onJob: aHumJobTicket 	"Following is first-cut direct call.	When this is debugged, put an asynch wrapper on it.	"	| manager   |	manager := (self messenger) getActorInstanceFromID: (self managerID).	self assert: (manager isKindOf: HumResourceManager ).	manager actor: (self id) completedAction: aHumStatement.! !!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 6/24/2013 17:49'!delegateAction: aStatement to: aRole	"Send request to resource manager via my messenger.	My resource manager will send to an actor that registered in that role and is currently available.	My bookkeeper will be informed of accumulated charges.	"	(self messenger) sendStatement: aStatement toID: (self managerID) fromID: myID.! !!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 6/25/2013 10:28'!runStatement: aStatement inRole: aRole onJob: aJobID	"Execute, simulate, or log the given statement"	| charge |	( aStatement isKindOf: String )		ifTrue: [ Compiler evaluate: aStatement for: self logged: false.				"No charge in this context. (e.g. actor checkin)"				^self				] .	"TODO: If statement has a translation (assume Smalltalk), run the translation."			( (aStatement isKindOf: HumStatement) and: [aStatement translation notNil] ) 		ifTrue: ["Execute in Smalltalk "			Compiler evaluate: (aStatement translation) for: self logged: false.			"Charge to job ticket"				charge := HumMeasure quantity: 1 units: #step.   			(aStatement jobTicket) appendCharge: charge forAction: aStatement byActor: myID inRole: aRole onJob: aJobID.			"Tell resource manager that we completed action normally."			self completedStatement: aStatement inRole: aRole onJob: aJobID.			^self.			]		ifFalse: [ "Simulate execution"			"Append to transcript"			Transcript cr; show: 'Actor: ', myID, ' is doing: ', aStatement source; cr.			( aStatement nounValues )				keysAndValuesDo:  [ :noun :value | 					Transcript show: 'with: ', noun, ' = ', value asString ].			"Charge to job ticket"				charge := HumMeasure quantity: 1 units: #step.   			(aStatement jobTicket) appendCharge: charge forAction: aStatement byActor: myID inRole: aRole onJob: aJobID.			"Tell resource manager that we completed action normally."			self completedStatement: aStatement inRole: aRole onJob: aJobID.			^ self.			].	"TODO: Why is this here?"	( aStatement isKindOf: HumJobTicket )		ifTrue: [ self halt. "Why is this here?" 			    ( self isKindOf: HumResourceManager )						ifTrue: [self sendMessage: aStatement to: (self bookkeeper). 
							"TODO: REFACTOR TO: self delegateAction: aStatement to: aRole.							statement := HumStatement: 'Bookkeeper: Register job-ticket.'.							self delegateAction: statement to: (self bookkeeper).							"							^self. ].					( self isKindOf: HumBookkeeper )						ifTrue: [ (self jobTickets) add: aStatement.							^self.].				] .	Error signal: 'Statement type not handled.'.! !!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 6/24/2013 17:50'!sendMessage: aMessageObject to: recipientID.	"TODO: HumActor does not need to know that delegating a statement is a message send.	 Replace this with something like: self delegateAction: aStatement to: aRole.	"	"self checkID: recipientID." 	( self messenger ) sendStatement: aMessageObject toID: recipientID fromID: myID.		! !!HumActor methodsFor: 'logging' stamp: 'RichardAlexanderGreen 6/19/2013 12:47'!chargeTo: aHumJobTicket 	"Compute the charge."	| charge |	charge := HumMeasure quantity: 1 units: #step.	"Append to the job ticket."	aHumJobTicket appendCharge: charge forResource: myID.	"aHumJobTicket appendCharge: charge forAction: action byActor: myID inRole: aRoleName onJob: aJobID." 	"Send to the manager. 	 The manager will call bookkeeper and update Supervisor."	self sendMessage: aHumJobTicket to: (self managerURI).	"	TODO: REPLACE ABOVE WITH: self delegateAction: aStatement to: aRole.	statement := HumStatement source: 'Bookkeeper: Register job-ticket.'.	self delegateAction: statement to: 'Bookkeeper'.	"! !!HumActor methodsFor: 'testing' stamp: 'RichardAlexanderGreen 2/13/2012 10:36'!checkURI: aString 	self assert: ( '*URI' matches: aString ).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumActor class	instanceVariableNames: ''!!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/21/2013 15:24'!bookkeeper: myID uri: myURI configuration: aHumConfiguration 	| instance |	instance := HumBookkeeper configuration: aHumConfiguration.	instance id: myID; uri: myURI.	^instance. ! !!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/25/2013 09:34'!dialog: myID uri: myURI client: clientURI configuration: aHumConfiguration	| instance |	instance := HumDialogAgent configuration: aHumConfiguration.	instance  id: myID; 					 uri: myURI; 				 client: clientURI.	^instance.	! !!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/21/2013 15:06'!manager: myID uri: myURI configuration: aHumConfiguration 	| instance |	instance := HumResourceManager configuration: aHumConfiguration.	instance id: myID; uri: myURI. 	^instance. ! !!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/25/2013 09:54'!supervisor: myID uri: myURI goal: aGoalStatementString dialog: aHumDialogAgent configuration: aHumConfiguration 	| instance |	instance := HumSupervisor configuration: aHumConfiguration.	instance  id: myID; 	          uri: myURI; 					 goal: aGoalStatementString; 	    dialogAgent: aHumDialogAgent.	^instance.! !!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/21/2013 15:26'!worker: workerID uri: workerURI roles: arrayOfRoleNames configuration: aHumConfiguration 	| instance |	instance := self configuration: aHumConfiguration.	instance id: workerID; 					uri: workerURI; 					roles: arrayOfRoleNames.	^instance.! !HumActor subclass: #HumDialogAgent	instanceVariableNames: 'clientURI clientID'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumDialogAgent commentStamp: 'RichardAlexanderGreen 9/19/2012 11:37' prior: 0!A dialog agent provides the interface between a Dialog and a user interface framework.For example, an implementation of a dialog agent could communicate with a user via HTML forms.Another implementation might be designed to communicate via a chat-room interface such as Jabber.We anticipate that some implementations will use virtual-world avatars.Instance Variables:	clientURI	<ProtoObject | PseudoContext>!!HumDialogAgent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/25/2013 09:36'!client: aString 	clientID := aString! !!HumDialogAgent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/6/2012 20:06'!dialog: myID uri: myURI client: uriClient configuration: aHumConfiguration	actorName := myID.	url := myURI.	clientURI := uriClient.	self configuration: aHumConfiguration.! !!HumDialogAgent methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/26/2012 11:57'!renderView: anEntityID onCanvas: html	"Check generated code by pasting it below"		html form with: [ 		html break. html heading level: 2; with: '!!!! Recipe'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #name toValue: datum ]; value: 'name'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #description toValue: datum ]; value: 'description'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #ingredients toValue: datum ]; value: 'ingredients'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #steps toValue: datum ]; value: 'steps'.		].	! !HumActor subclass: #HumMessenger	instanceVariableNames: 'uriActor actorURI uriActorID'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumMessenger commentStamp: 'RichardAlexanderGreen 9/20/2012 07:34' prior: 0!The communication bus provides a message store and forward service with optional logging.If an actor is temporarily not available, a message will be held for some (TBD) time.The messages to a role may be replayed later.Instance Variables:	uri			<URI>	uriActor	<Dictionary>!!HumMessenger methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/21/2013 09:29'!actorURI	"actorURI contains (actor->URI) maps"	^ actorURI ifNil: [ actorURI := Dictionary new ].! !!HumMessenger methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/26/2013 10:07'!getActorInstanceFromID: actorID	"Backdoor during debug to bypass the messenger"	| actorInstance someURI |	someURI := (self actorURI) at: actorID ifAbsent: [Error signal: 'Trouble getting actorURI for: ', actorID ].	actorInstance := (self uriActor) at: someURI ifAbsent: [Error signal: 'Trouble getting actorInstance for: ', actorID ].	^actorInstance.! !!HumMessenger methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/10/2012 13:51'!uri	"Return my URI"	^ uri! !!HumMessenger methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/10/2012 13:50'!uri: aString 	uri := aString.! !!HumMessenger methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/10/2012 15:27'!uriActor	^ uriActor ifNil: [ uriActor := Dictionary new. ].! !!HumMessenger methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/21/2013 09:50'!uriActorID	"What actor ID is associated with URI?"	^ uriActorID ifNil: [ uriActorID := Dictionary new]! !!HumMessenger methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 6/25/2013 09:58'!ping: aURI	"MOCK: Return the ID of the given URI"	^ ( self uriActorID ) at: aURI ifAbsent: [ Error signal: 'Messenger has no ID entry for URI: ', aURI ].! !!HumMessenger methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 6/21/2013 09:48'!registerActor: anActor atActorURL: aURI 	"Track actor."	self assert: ( anActor isKindOf: HumActor ).	self assert: ( aURI isKindOf: String ).	"Track URI->actor association."	(self uriActor) at: aURI put: anActor.	(self uriActorID) at: aURI put: (anActor id).	(self actorURI) at: (anActor id) put: aURI.	"TODO: Track actor->URI also."! !!HumMessenger methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 6/22/2013 13:10'!sendStatement: aHumStatement toID: recipientID fromID: senderID	"This method is called by Resource Managers.	Resource managers know an actor`s ID but not their URI.	(This strategy allows the URI to change. 	[e.g. Restart actor on a different host.] 	Strategy may be of dubious utility.)	 "	| recipientURI senderURI|	"Translate ID to URI."	recipientURI := ( self actorURI ) at: recipientID 														ifAbsent: [Error signal: 'Messenger has no URI for actor ID: ', recipientID].													senderURI := ( self actorURI ) at: senderID 														ifAbsent: [Error signal: 'Messenger has no URI for actor ID: ', senderID].	"Send  . . ."	self sendStatement: aHumStatement toURI: recipientURI fromURI: senderURI.	! !!HumMessenger methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 6/25/2013 09:16'!sendStatement: aHumStatement toURI: recipientURI fromURI: senderURI	| actorInstance |	actoInstance := ( self uriActor ) at: recipientURI ifAbsent: [ Error signal: 'Messenger has no actor for URI: ', recipientURI ].	"Following only works when actor is local."	actorInstance runStatement: aHumStatement inRole: (aHumStatement role) onJob: (aHumStatement jobTicket).	"TODO: Need a better simulation of async."	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumMessenger class	instanceVariableNames: ''!!HumMessenger class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/10/2012 13:49'!uri: aString 	| instance |	instance := self basicNew.	instance uri: aString.	^instance.! !HumActor subclass: #HumBookkeeper	instanceVariableNames: 'jobTickets'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumBookkeeper commentStamp: 'RichardAlexanderGreen 9/19/2012 11:34' prior: 0!The bookkeeper records resource utilization and expenditure statistics.It provides the basic data needed for cost accounting and system utilization analysis.Instance Variables:	jobTickets	<OrderedCollection>!!HumBookkeeper methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 10:56'!bookkeeper: anID uri: aURI configuration: aHumConfiguration 	configuration := aHumConfiguration.	self id: anID.	self uri: aURI.! !!HumBookkeeper methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 11:02'!jobTickets	^ jobTickets ifNil: [ jobTickets := OrderedCollection new. ].! !!HumBookkeeper methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2013 11:11'!recordJobTicket: aHumJobTicket 	(self jobTickets) add: aHumJobTicket.! !HumActor subclass: #HumResourceManager	instanceVariableNames: 'roleActor actorURI availableActors busyActors'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumResourceManager commentStamp: 'RichardAlexanderGreen 9/19/2012 11:40' prior: 0!The resource manager assigns actors to perform actions.An actor registers itself with a resource manager and identifies the roles that it knows.When a running plan or dialog requires that an action be performed, the resource manager finds an available actor that knows that role (has that capability) and assigns the requested action to that actor.When the actor has completed the role, it becomes available for further assignments.Instance Variables:	roleActor	<Set>	actorURI	<Dictionary>!!HumResourceManager methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2013 10:43'!availableActors	^ availableActors ifNil: [ availableActors := Set new. ].! !!HumResourceManager methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2013 10:55'!busyActors	^ busyActors ifNil: [ busyActors := Set new ].! !!HumResourceManager methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/21/2013 09:39'!checkInActor: actorID at: aURI withRoles: actorKnowsRoles 	"The resource manager should delegate finding the URI to messenger."	"For each actor role: 	. Add the actor to those that know that role."	self assert: ( actorKnowsRoles isKindOf: Array ).	actorKnowsRoles do: [ :aRole |		( self roleActor )  add: ( aRole -> actorID ).		( self availableActors ) add: actorID.		].		! !!HumResourceManager methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/21/2013 09:53'!checkInActor: actorID withRoles: actorKnowsRoles 	"For each actor role: 	. Add the actor to those that know that role."	self halt. "Obsolete"	self assert: ( actorKnowsRoles isKindOf: Array ).	actorKnowsRoles do: [ :aRole |		( self roleActor )  add: ( aRole -> actorID ).		( self availableActors ) add: actorID.		].		! !!HumResourceManager methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2013 10:40'!roleActor	"Return the role->actor map set."	^ roleActor ifNil: [ roleActor := Set new. ].! !!HumResourceManager methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 6/26/2013 09:57'!actor: anActor completedAction: aHumStatement	"Resource manager is informed that the actor completed the assigned action.	See: #assignRole: roleString action: actionStatement	"		| bookkeeperInstance |	(anActor sameAs: myID)		ifTrue: ["Manager (self) cannot be busy and must always be available."]		ifFalse: [	"Actor is no longer busy."							( self busyActors ) remove: anActor.							( self availableActors ) add: anActor.							].	"Send charges to bookkeeper."	"For now, just call direct.	TODO: Make asynch call to bookkeeper.	"	bookkeeperInstance := (self messenger) getActorInstanceFromID: bookkeeperID.	bookkeeperInstance recordJobTicket: ( aHumStatement jobTicket ) .	! !!HumResourceManager methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 6/26/2013 09:44'!assignRole: roleString action: actionStatement 	"Assign the given action to an actor advertising the given role."	| actor potentialActors assignableActors  |	self assert: ( roleString isKindOf: String ).	self assert: ( actionStatement isKindOf: HumStatement ).	potentialActors := Set new.	"Find an actor that knows the role."	( self roleActor ) 		do: [ :map | 			map key = roleString asLowercase  				ifTrue: [ potentialActors add: map value. ].			].	"Filter potential actors to include only available actors."	assignableActors := potentialActors intersection: (self availableActors).	"Assign an actor at random."	actor := assignableActors atRandom.	(actor sameAs: myID)		ifTrue: ["Manager (self) cannot be busy and must always be available."]		ifFalse: ["Mark actor busy and not available."							(self busyActors) add: actor.							(self availableActors) remove: actor.							].			"Send the action to the actor."	self sendMessage: actionStatement to: actor.	"Simulating asynch: The completion comes back via #actor: anActor completedAction: aStatement"		! !HumActor subclass: #HumSupervisor	instanceVariableNames: 'goal context remainingConditions dialogAgent planFrames jobTicket'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumSupervisor commentStamp: 'RichardAlexanderGreen 9/19/2012 11:43' prior: 0!The supervisor tracks the execution state of a plan.The state includes which conditions are satisfied, which plan frames have been completed, the accumulated resource utilization associated with the execution, and any exceptions that were encounterd or are currently pending resolution.Instance Variables:	ontology	<HumOntology>	goal	<ProtoObject | PseudoContext>	context	<Object>	remainingConditions	<Integer>	dialogAgent	<ProtoObject | PseudoContext>	planFrames	<Collection | PTEnumerable | PragmaCollector>!!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/3/2012 17:33'!context: aHumActor	context := aHumActor.! !!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 10:02'!dialogAgent: aHumDialogAgent 	self assert: ( aHumDialogAgent isKindOf: HumDialogAgent ).	dialogAgent := aHumDialogAgent.! !!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/17/2013 12:55'!goal: aStatement	goal := nil.	(aStatement isKindOf: HumStatement ) ifTrue: [ goal := aStatement. ^self ].	( aStatement isKindOf: String )		ifTrue: [ "Get the goal statement from the root frame."			| rootFrame statement |			rootFrame := (self ontology) getPlanFrameForGoal: aStatement.			statement := rootFrame goal.			self assert: (statement isKindOf: HumStatement).			goal := statement.			^self.			].	! !!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/17/2013 10:56'!goalStatement	"Translate goal string to goal statement"	"TODO: THERE IS SOMETHING WRONG HERE."	| rootFrame statement |	rootFrame := ((self ontology) getPlanFrameForGoal: goal).	statement := rootFrame goal.	^ statement. ! !!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/7/2013 15:30'!jobTicket	^ jobTicket ifNil: [ jobTicket := HumJobTicket new ].! !!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/8/2013 11:07'!remainingConditions	^ remainingConditions ifNil: [ remainingConditions := Set new.] .! !!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 10:01'!supervisor: anID uri: aURI goal: aGoalStatementString dialog: aHumDialogAgent configuration: aHumConfiguration	self configuration: aHumConfiguration.		self id: anID.	self uri: aURI.	self goal: aGoalStatementString.	self dialogAgent: aHumDialogAgent.			^self.	! !!HumSupervisor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 6/26/2013 10:33'!runAction: anInstructionLine 	"Run the given action statement."	Transcript cr; show: 'Actor: ',myID,' is running { ', anInstructionLine source, ' }'; cr.	"After the action is run, the corresponding post-condition is satisfied."	"	REFACTOR -- MORE CONTEXT IS NEEDED TO MAKE THIS POSSIBLE. "	self shouldBeImplemented.	! !!HumSupervisor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 7/17/2013 10:33'!runPlan	"Run my plan.	"	|  result |	self runPlanSetup.	result := self runPlanFrameForCondition: goal.	result 		ifFalse: [ Error signal: 'Attempt to run plan for goal: {',goal,'} has failed.'].! !!HumSupervisor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 7/17/2013 11:01'!runPlanFrameForCondition: aGoalString	""	| rootFrame result |	"Get the root of this subtree."	rootFrame := (self ontology) getPlanFrameForGoal: aGoalString.	(rootFrame isRunnable)		ifTrue: ["Run its actions and then declare the goal satisfied"			"Run actions"			(rootFrame actionStatements) 				do: [ :action | action runInContext: self ].			"Declare goal satisfied"			self conditionIsSatisfied: rootFrame goal.			^true.	 "Indicates something was runnable. See check below."			] "ifTrue"		ifFalse: [ "Try to satisfy the preconditions."			result := false.			( rootFrame preconditions )					do: [ :precondition |						| preconditionString stepResult |						preconditionString := precondition statement source.						"Call recursively on preconditions."						stepResult := self runPlanFrameForCondition: preconditionString.						result := result | stepResult.  "Boolean"						]. "do"					"Check post condition 					-- At least one precondition in the tree should be runnable on each iteration."					result ifFalse: [ Error signal: 'Nothing in the subtree was runnable!!']					]."ifFalse"						"Fall through to here when goal frame is not runnable and we ran preconditions.		Now try again."		((self remainingConditions ) isEmpty) 			ifTrue: [ Error signal: 'Remaining conditions should not be empty in this recursive loop.'.				"In this context,				 the remaining conditions should include the original goal, 				 and therfore, not be empty yet."				].		result := self runPlanFrameForCondition: aGoalString.		^result.			! !!HumSupervisor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 7/17/2013 10:56'!runPlanSetup	"Setup to run a plan:	1. Assure plan is runnable.	2. Populate the remaining conditions collection. ()	3. Initialize the job ticket?	TODO: WATCH OUT: instance variables passed via the back-door 	"	| remaining |	self planIsRunnable ifFalse: [ Error signal: 'Plan is not runnable for goal: ', goal ].	planFrames := ontology collectPlanFramesForGoal: (self goalStatement).  "Populate the remaining conditions collection"	remaining := self remainingConditions.	remaining add: goal.	planFrames		do: [ :frame |				( frame preconditions )						do: [ :precondition |								remaining add: precondition.							].			].! !!HumSupervisor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 7/17/2013 10:25'!runPlanV01	"Run my plan.	TODO: Rewrite this to be recursive.	"	|  aRunnableFrame runnableActionStatements aPostCondition |	context := dialogAgent.	self assert: ( context isKindOf: HumDialogAgent ).	"		Additional Preconditions:	. All nouns in the goal statement have values on the dialog agent's' blackboard.	. The frame collection is complete.	. All the roles in the action statements are known (checked-in) to the resource manager.	. All action statements are defined in the ontology.	"	self planIsRunnable ifFalse: [ Error signal: 'Plan is not runnable for goal: ', goal ].	planFrames := ontology collectPlanFramesForGoal: goal.	"Find a plan frame that is ready to run. 	(All its preconditions are satisfied and it has not already run.)	TODO: Eventually, all runnable frames can be run in parallel."	aRunnableFrame := planFrames detect: [ :frame | frame isRunnable ]														ifNone: [ Error signal: 'None of my plan frames are runnable.'].	"Run it's action statements."	runnableActionStatements := aRunnableFrame actionStatements.	runnableActionStatements		do: [ :actionStatement |			actionStatement runInContext: context.			].	"Assert it's post condition."	aPostCondition := aRunnableFrame goal.	self conditionIsSatisfied: aPostCondition.	"TODO: Needs more work -- to loop or recurse until goal is satisfied."	"TODO: There should be a job ticket in here someplace."	self halt.		! !!HumSupervisor methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 7/17/2013 11:10'!planIsRunnable	"TODO: ADD NEEDED CHECKS TO THIS STUB."	| |	context := dialogAgent.	self assert: ( context isKindOf: HumDialogAgent ).	self assert: ( goal isKindOf: HumStatement ).	"		Additional Preconditions:	. All nouns in the goal statement have values on the dialog agent's' blackboard.	. The frame collection is complete.	. All the roles in the action statements are known (checked-in) to the resource manager.	. All action statements are defined in the ontology.	"	^true.! !!HumSupervisor methodsFor: 'events-registering' stamp: 'RichardAlexanderGreen 7/17/2013 10:43'!conditionIsSatisfied: aHumStatement 	"Note that condition is satisfied.	Then runnable frames may change.	If all conditions have been satisfied, the goal is achieved.	THINK: Should the goal itself be in remainingConditions collection?	"	self assert: ( aHumStatement isKindOf: HumStatement ).		(self remainingConditions) 		remove: aHumStatement 		ifAbsent: [Error signal: 'absent condition: ', aHumStatement source]! !