Object subclass: #HumCalculator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumCalculator commentStamp: 'RichardAlexanderGreen 3/12/2013 13:48' prior: 0!The Calculator role (agent) provides - base level arithmetic (using measures)- string utilities used to parse Hum source code.The Calculator provides compute operations.When a Hum procedure (or Hum Run-Time) needs an interface to the host computer, the Calculator provides it.See also: HumMeasure. -- In the Hum framework, all numbers are measures.!!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 10/30/2012 13:42'!xml: aTagString attributes: aMap 	"Create a stand-alone tag (ending with '/>') with the given attribute values."	| xml space equals quote |      self assert: ( aMap isKindOf:  OrderedCollection ).	space := String space.	equals := '='.	quote := $" asString.	xml := '<', aTagString.	aMap 		do: [ :map | 			xml := xml, space, map key, equals, quote, map value, quote.			].	xml := xml, ' />'.	^xml.! !!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 10/30/2012 14:11'!xml: aTagString attributes: aMap with: aBlockClosure 	"Generate the front tag and the end tag with block to produce the middle"	| frontTag xml cr indent calc |	calc := HumCalculator new.	self assert: ( aMap isKindOf: OrderedCollection ).	cr := String cr.	indent := '  '.		frontTag :=  calc xmlOpen: aTagString attributes: aMap.	xml := frontTag, cr, 	             indent, ( aBlockClosure value ), cr,			'</', aTagString, '>'.	^xml.! !!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 10/30/2012 13:43'!xml: aTag with: aBlock 	"Fix up the indent after we get this working."	| xml cr indent |	cr := String cr.	indent := '  '.		xml  := '<', aTag, '>', cr			,  indent, ( aBlock value  ) asString, cr			,'</', aTag, '>', cr.	^xml.! !!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 11/22/2012 18:28'!xmlOpen: aTagString attributes: aMap 	"Create an opening tag ( NOT ending with '/>' ) with the given attribute values."	| xml space equals quote |	self assert: ( aMap isKindOf: OrderedCollection ).	space := String space.	equals := '='.	quote := $" asString.	xml := '<', aTagString.	aMap 		do: [:map | 			xml := xml, space, map key, equals, quote, map value, quote.			].		xml := xml, ' >'.	^xml.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumCalculator class	instanceVariableNames: ''!!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 1/13/2012 09:57'!substringFrom: stringIn after: stringA 	"Get the substring that is between the two given."	| x1 stringOut s |	s := stringIn.	stringOut := ''.	x1 := s findString: stringA startingAt: 1.	(x1 > 0 ) 		ifTrue: [ stringOut := stringIn copyFrom: (x1+  stringA size) to: (stringIn size). 			 ].	^stringOut.! !!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 1/13/2012 10:01'!substringFrom: stringIn after: stringA before: stringB	"Get the substring that is between the two given."	| x1 x2 stringOut s |	s := stringIn.	stringOut := ''.	x1 := s findString: stringA startingAt: 1.	(x1 > 0 ) 		ifTrue: [ x2 := s findString: stringB startingAt: x1. 			(x2 > x1)				 ifTrue: [ stringOut := s copyFrom: x1+1 to: x2-1.]. 			 ].	^stringOut.! !!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 1/13/2012 10:12'!substringFrom: stringIn before: stringA 	"Get the substring that is between the two given."	| x1 stringOut s |	s := stringIn.	stringOut := ''.	x1 := s findString: stringA startingAt: 1.	(x1 > 0 ) 		ifTrue: [ stringOut := stringIn copyFrom: 1 to: (x1-1). 			 ].	^stringOut.! !!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 12/19/2012 12:19'!substringFrom: aString includingMatching: pairString	"	s = 'this is before [[blah]] this is after'.	self assert: ( HumCalculator substringFrom: s betweenMatching: '[]' ) = '[[blah]]'.	 "	| startPos pos nestLevel pairStart pairStop |	pairStart := pairString at: 1.	pairStop  := pairString at: 2.	self assert: (pairStart isKindOf: Character ).	self assert: (pairStop isKindOf: Character ).	"Find the start of the substring."	startPos := aString indexOf: pairStart.	"TODO: If there is no starting character, what should we return?"	(startPos > 0 ) 		ifFalse: [ ^nil ].	"Following assumes we have found the starting position."	self assert: startPos > 0.	pos := startPos + 1.	nestLevel := 1.	[ pos <= aString size ] whileTrue: [		| aCharacter |		aCharacter := aString at: pos.		( aCharacter = pairStart ) 			ifTrue: [ nestLevel := nestLevel + 1 ].		( aCharacter = pairStop )  			ifTrue: [ nestLevel := nestLevel - 1 ].		(nestLevel = 0) 			ifTrue: [ |result| result := ( aString copyFrom:startPos to: pos ). ^result. ].		pos := pos + 1.	].	"If we come here, the matching closing character is missing."	Error signal: 'String does not contain a balanced pair: ', pairString.	^nil.! !Object subclass: #HumBlackBoard	instanceVariableNames: 'quads'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumBlackBoard commentStamp: 'RichardAlexanderGreen 9/20/2012 07:21' prior: 0!The blackboard holds the values for nouns in memory that are currently being referenced by an agent.In addition, the blackboard operates the persistence mechanism so that new noun values are recorded on the world-base (database). !!HumBlackBoard methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/18/2012 11:49'!getEntityID: entityID attribute: attributeType 	" Get requested value (if any) from the world base instance "	| tau value |	self assert: (entityID isKindOf: String ).	self assert: (attributeType isKindOf: Symbol ).	"Ignore temporal features for now."		value := (self quads ) at: ( entityID -> attributeType ) ifAbsent: [ nil ].	^ value.! !!HumBlackBoard methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/18/2012 11:48'!quads	^ quads ifNil: [ quads := Dictionary new. ].! !!HumBlackBoard methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/26/2012 11:40'!setEntityID: entityID attribute: attributeType toValue: aValue	" Get requested value (if any) from the world base instance "	| tau quad value |	self assert: (entityID isKindOf: String ).	self assert: (attributeType isKindOf: Symbol ).	self assert: ( aValue notNil ).	"Ignore temporal features for now."	"Get value of reqested entity attribute."	(self quads ) at: ( entityID -> attributeType ) put: aValue.		"TODO: Update the world base also."! !Object subclass: #HumVM	instanceVariableNames: 'slots transferVector measure'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumVM commentStamp: 'RichardAlexanderGreen 9/20/2012 07:57' prior: 0!HumVM is a thought experiment for a virtural machine and byte code.After some consideration, I (Richard Alexander Green) decided that a byte code is not a good idea at this time.If compiled code is necessary for efficiency, it would make more sense at this time to translate to a language that has a compiler. Byte Code Advantages:- The resulting code may be more compact than the source and therefore it would require less delivery time.- - counter: Delivery time for an agent`s code is generally not an important factor except possibly for a dialog agent.- A byte code might be more easily compiled to a native ISA.- - counter: It is easier to translate to another language.Disadvantages:- If the normal delivery is byte code the ecology may discourage transparency.- An existing VM such as JVM or BEAM would be more acceptable to many audiences.Instance Variables:	slots	<Dictionary>	transferVector	<Dictionary>	measure	<HumMeasure>!!HumVM methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2012 10:30'!measureRegister	^ measure ifNil: [ measure := HumMeasure new. ].! !!HumVM methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2012 10:10'!setSlot: slotIndex to: aHumObject 	(self slots) at: slotIndex put: aHumObject.! !!HumVM methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2012 10:11'!slots	"slots allow objects to be referenced by byte-code indices."	^ slots ifNil: [slots := Dictionary new. ].! !!HumVM methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2012 10:39'!transferVector	transferVector ifNil: [ transferVector := Dictionary new.		transferVector 			at: 001 put: [ :x | measure := x  ];			at: 002 put: [ :x | measure := measure + x ];			at: 003 put: [ :x | measure := measure - x ];			at: 000 put: [ :x | self halt ].		].	^transferVector.! !!HumVM methodsFor: 'self evaluating' stamp: 'RichardAlexanderGreen 7/26/2012 10:41'!run: aHumInstruction 	| microCode |	"Get the microCode. (a block)"	microCode := ( self transferVector ) at: (aHumInstruction operation) 	                                                     ifAbsent: [ Error signal: 'No such opCode: ', (aHumInstruction operation)].	"Run the microCode. (a block)"	microCode value: ( self slots at: (aHumInstruction operand)).	"Assure cascade."	^self. ! !HumFrame4Data subclass: #HumJobTicket	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumJobTicket commentStamp: 'RichardAlexanderGreen 9/28/2012 14:04' prior: 0!A job ticket records the resources consumed by a job.A job is initiated when a goal is set running.When actions are delegated by the one actor to other actors, they get jobtickets also.The resulting resource data is consolidated on the parent-level job-ticketsso that the costs are rolled-up to each level and eventually to the job as a whole.When each action is completed, the resource manager reports new resource entries to the Bookkeeper.Hence a running account is maintained for the job, for each resource, for each actor, for each role, for each action.Note that resource accounting only sums resource quantities.It does not attempt to monetize (price) the resources used because that is a very specialized process.For example, withdrawals from inventory might be priced using LIFO, FIFO, or some other accounting practice.!!HumJobTicket methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 12:47'!appendCharge: aHumMeasure forAction: action byActor: anID inRole: aRoleName onJob: aJobID 	"A job ticket is a data frame. Place these items into a data group."	self appendEntity: 'Charge' attrribute: 'measure' value: aHumMeasure asString.	self appendEntity: 'Charge' attrribute: 'action' value: action asString.	self appendEntity: 'Charge' attrribute: 'ID' value: anID asString.	self appendEntity: 'Charge' attrribute: 'role' value: aRoleName asString.	self appendEntity: 'Charge' attrribute: 'job' value: aJobID asString.	! !!HumJobTicket methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/3/2012 14:31'!appendCharge: aHumMeasure forResource: actorName 	| s |	s := 'actor: {', actorName, '} charges: ', aHumMeasure asString.	self addFrameLine: s.! !Object subclass: #HumVMInstruction	instanceVariableNames: 'operation operand'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumVMInstruction commentStamp: 'RichardAlexanderGreen 9/20/2012 07:59' prior: 0!HumVM and HumVMInstruction are artifacts of a thought experiment for a virtural machine and byte code.See the HumVM class comment for further information.Instance Variables:	operation	<Integer>	operand	<Integer>Class Instance Variables:	codeNames	<Dictionary>!!HumVMInstruction methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:12'!operand	^ operand ifNil: [ Error signal: 'operand not set in HumInstruction'.  operand := 000].! !!HumVMInstruction methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:10'!operand: objectIndex 	operand := objectIndex! !!HumVMInstruction methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:11'!operation	^ operation ifNil: [ Error signal: 'op code not set in HumInstruction'.  operation := 000].! !!HumVMInstruction methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:09'!operation: opCode 	self assert: ( opCode < 256 ).	self assert: ( opCode >= 0 ).	operation := opCode.! !!HumVMInstruction methodsFor: 'associating' stamp: 'RichardAlexanderGreen 9/20/2012 07:37'!opCodeName	| name |	name := ( HumVMInstruction codeNames ) at: (self operation) ifAbsent: ['Unknown'].	^name.! !!HumVMInstruction methodsFor: 'associating' stamp: 'RichardAlexanderGreen 7/25/2012 10:18'!slotName	( (self operand) = 000 ) ifTrue: [^ 'None' ].	Error signal: 'Instruction slot name is not defined.'.	^'Undefined.'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumVMInstruction class	instanceVariableNames: 'codeNames'!!HumVMInstruction class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 7/24/2012 16:27'!opCode: opCode value: objectIndex 	| instruction |	instruction := self basicNew.	instruction operation: opCode.	instruction operand: objectIndex.	^instruction.! !!HumVMInstruction class methodsFor: 'associating' stamp: 'RichardAlexanderGreen 7/24/2012 16:26'!opCodeName	name := (self codeNames ) at: (self operation).	^name.! !!HumVMInstruction class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:33'!codeNames	codeNames ifNotNil: [ ^codeNames ].	"Otherwise, initialize . . ."	codeNames := Dictionary new.	codeNames at: 000 put: 'Halt'.! !Magnitude subclass: #HumFuzzy	instanceVariableNames: 'distribution sampleSize'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumFuzzy commentStamp: 'RichardAlexanderGreen 4/9/2013 09:48' prior: 0!This class implements fuzzy arithmetic using Monte Carlo sampling of the distributions.!!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2013 11:14'!atP: aFloat 	"Return the appropriate value from the distribution.	Iterpolate when necessary. 	This version uses linear interpolation.	Future versions might use a spline or something."	| result |	"Check that aFloat is between zero and one"	self assert: ( aFloat isKindOf: Float ).	self assert: ( aFloat >= 0.0 ).	self assert: ( aFloat <= 1.00).	"Look up value or interpolate to get a result."	result := distribution at: aFloat ifAbsent: [ self interpolate: aFloat ].	^ result.! !!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/22/2013 10:05'!distribution: aDictionary 	self assert: ( aDictionary isKindOf: Dictionary ).	distribution := aDictionary.! !!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2013 13:41'!initialize	sampleSize := 10000.! !!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2013 11:20'!interpolate: aProbability	"Interpolate the predicted value at aProbability"	| lowerP lowerF upperP upperF slope intercept result |	self assert: (aProbability isKindOf: Float ).	"Following depends on Dictionary semantics"	self assert: ( distribution isKindOf: Dictionary ).	lowerP := 0.0.	lowerF := distribution at: lowerP.	upperP := 1.0.	upperF := distribution at: upperP.	distribution keysAndValuesDo: [ :k :v |		( k > lowerP and: [ k < aProbability ] ) ifTrue: [ lowerP := k. lowerF := v. ].		( k < upperP and: [ k > aProbability ] ) ifTrue: [ upperP := k. upperF := v. ].		].	"Do simple linear interpolation."	slope :=  ( upperF - lowerF ) / ( upperP - lowerP ).	"Check: for an S-Curve the slope is always positive."	self assert: ( slope > 0.0 ).		result := lowerF + ( (aProbability - lowerP) * ( slope) ).	"Check: the result must be between upper and lower function values"	self assert: ( result > lowerF ).	self assert: ( result < upperF ).	^result.! !!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2013 13:14'!median	"find the point that represents the median"	|  medianPoint |	"Distribution is list of f->p".	"Look for f@0.50"	medianPoint := self atP: 0.50.	^medianPoint.! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/9/2013 14:15'!* aHumFuzzy 	| times result |	times := #*.	result := self op: times with: aHumFuzzy.	^result.! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/9/2013 13:42'!+ aHumFuzzy "Add two fuzzy distibutions using Monte Carlo sampling"	| resultSet random  vC sortedSet distributionC tick count fuzzyC |	resultSet := Set new.	random := Random new.	( 1 to: sampleSize )		do: [ :i |			| rA rB vA vB |			rA := random next.			vA := self atP: rA.			rB := random next.			vB := aHumFuzzy atP: rB.			vC := vA + vB.			resultSet add: vC.			].	"Create a new distribution with points every 10%"	sortedSet := resultSet asSortedCollection.	self assert: ( sortedSet size = sampleSize ).	distributionC := Dictionary new.	distributionC at: 0.0 put: ( sortedSet first ). "TODO: Should be a calculated intercept."	tick := sampleSize / 10.	count := 0.	sortedSet		do: [ :x | 				| modulo |			  count := count + 1.				modulo := ( count \\ tick ).				( modulo = 0 )					ifTrue: [ distributionC at: ( (count/sampleSize) asFloat )  put: x ].			 ].	self assert: ( distributionC size = 11 ).	fuzzyC := HumFuzzy distribution: distributionC.	^fuzzyC.		! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/9/2013 14:11'!- aHumFuzzy 	| minus result |	minus := #-.	result := self op: minus with: aHumFuzzy.	^result.! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/9/2013 14:13'!/ aHumFuzzy 	| divide result |	divide := #/.	result := self op: divide with: aHumFuzzy.	^result.! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/22/2013 09:59'!mean	| sum n result |	sum := 0.0.	n := 0.	self sampleWithBlock: [ :x | n := n + 1. sum := sum + x.].	result := sum / n.	^result.! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/22/2013 12:09'!op: aSymbol with: aHumFuzzy "Add two fuzzy distibutions using Monte Carlo sampling"	| resultSet random  vC sortedSet distributionC tick count fuzzyC |	resultSet := Set new.	random := Random new.	( 1 to: sampleSize )		do: [ :i |			| rA rB vA vB |			rA := random next.			vA := self atP: rA.			rB := random next.			vB := aHumFuzzy atP: rB.			vC := vA perform: aSymbol with: vB.			resultSet add: vC.			].	"Create a new distribution with points every 10%"	sortedSet := resultSet asSortedCollection.	self assert: ( sortedSet size = sampleSize ).	"Note: Assertion above occasionally fails (size = is off by one) for an unknown reason.	TODO: Figure out why that occurs."	distributionC := Dictionary new.	distributionC at: 0.0 put: ( sortedSet first ). "TODO: Should be a calculated intercept."	tick := sampleSize / 10.	count := 0.	sortedSet		do: [ :x | 				| modulo |			  count := count + 1.				modulo := ( count \\ tick ).				( modulo = 0 )					ifTrue: [ distributionC at: ( (count/sampleSize) asFloat )  put: x ].			 ].	self assert: ( distributionC size = 11 ).	fuzzyC := HumFuzzy distribution: distributionC.	^fuzzyC.		! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/22/2013 10:01'!sampleWithBlock: aBlock "Operate on fuzzy distibution using Monte Carlo sampling"	| resultSet random |	resultSet := Set new.	random := Random new.	( 1 to: sampleSize )		do: [ :i |			| rA  vA  |			rA := random next.			vA := self atP: rA.			aBlock value: vA.			].		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFuzzy class	instanceVariableNames: ''!!HumFuzzy class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/9/2013 13:43'!distribution: aDistribution	"Create a new instance from the given distribution."	| fuzzy |	fuzzy := self basicNew.	fuzzy initialize.	fuzzy distribution: aDistribution.	^fuzzy.! !!HumFuzzy class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/22/2013 10:24'!quantity: aQuantity plusOrMinus: aLimit 	"Create a distribution with given limits."	| fuzzy stats |	self assert: ( aQuantity isKindOf: Number ).	self assert: (    aLimit isKindOf: Number ).	"Assume upper and lower will not be exceeded.	The idea is that cases exceeding those measures would be rejected.	"	fuzzy := self basicNew.	fuzzy initialize.	stats := Dictionary new.	stats		at: 0.50  put: aQuantity;		at: 0.00  put: (aQuantity - aLimit );		at: 1.00  put: (aQuantity + aLimit ).	fuzzy distribution: stats.	^fuzzy.! !Magnitude subclass: #HumMeasure	instanceVariableNames: 'quantity units upperControlLimit lowerControlLimit dimL dimM dimT kms'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumMeasure commentStamp: 'RichardAlexanderGreen 3/12/2013 13:58' prior: 0!A measure has a quantity   with upper and lower control limits   and a unit of measure.Instance Variables:	quantity	<Object>	units	<ProtoObject>!!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/23/2013 18:38'!forceUnits	| aSymbol anArray |	aSymbol := #unknown.	anArray := ( self kms ).	(HumMeasure kms)		keysAndValuesDo: [ :key :value |			( value = anArray )				ifTrue: [ aSymbol := key.					units := aSymbol.					^ self. 					]			].	"If we come here, we have failed."	units := aSymbol.! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/23/2013 17:47'!kms	^ kms ifNil: [ kms := { 0. 0. 0. } ].! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/23/2013 17:58'!kms: anArray 	"Argument might be integer or float array"	self assert: ( anArray size = 3 ).	"Convert to integer array"	kms := { 					( anArray at: 1 ) asInteger. 					( anArray at: 2 ) asInteger. 					( anArray at: 3 ) asInteger. 				}.! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 21:33'!negated	| zero result |	zero := HumMeasure quantity: 0 units: (self units).	result := zero - self.	^result. ! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2012 20:25'!quantity		^ quantity ifNil: [ Error message: 'HumMeasure quantity was not set.' ].! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/19/2013 16:25'!quantity: aNumber 	quantity := aNumber! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/20/2012 07:42'!quantity: aQuantity plusOrMinus: aVariance units: aString	self assert: ( aQuantity isKindOf: Number ).	self assert: ( aVariance isKindOf: Number ).	quantity := aQuantity.	upperControlLimit := quantity + aVariance.	lowerControlLimit := quantity - aVariance.	units := aString. 	! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/23/2013 17:29'!quantity: aNumber units: aSymbol	quantity := aNumber.	self units: aSymbol. 	! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/23/2013 18:05'!units	^ units ifNil: [ Error signal: 'HumMeasure units were not set'].! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/23/2013 17:42'!units: aSymbol 	| lookup |	self assert: ( aSymbol isKindOf: Symbol ).	units := aSymbol.	"Set my KMS dimensions"	self kms: ((HumMeasure kms) at: aSymbol  ifAbsent: [{0. 0. 0.}]). 		! !!HumMeasure methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/23/2013 18:36'!* aMeasure 	| multiplier result |	( aMeasure isKindOf: Duration)		ifTrue: [ multiplier := HumMeasure quantity: (aMeasure asSeconds) 			                                    units: #second ].	( aMeasure isKindOf: HumMeasure )		ifTrue: [ multiplier := aMeasure.				(aMeasure units = #percent ) 				   ifTrue: [ result := HumMeasure quantity: ( self quantity * multiplier quantity / 100.0 ) 					                                   units: ( self units ).					 					^ result.									]. 				].			( aMeasure isKindOf: Number )		ifTrue: [ "dividing by a unitless scalar"			| scalar |			scalar := aMeasure.			result := self copy.			result quantity: ((self quantity) * scalar).			^result			].		result := HumMeasure new.	result quantity: (self quantity) * ( multiplier quantity);			        kms: ( self kms asFloatArray ) + ( multiplier kms asFloatArray );				forceUnits.		^result. ! !!HumMeasure methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 3/12/2013 13:54'!+ aMeasure 	"Add measures that have the same unit of measure."	| measure result |	"If the argument is not of the correct type, fix it up."	( aMeasure isKindOf:  HumMeasure )		ifTrue: [ measure := aMeasure ]		ifFalse: [ measure := HumMeasure quantity: aMeasure units: (self units)].	"This version can only add measurements with matching units of measure."		( self units = measure units )		ifFalse: [ 			(self units = '')				ifTrue: [ self units: aMeasure units ]				ifFalse: [ Error signal: 'This version can only perform arithmetic on measures with matching units.'. self halt. ].				].	result := HumMeasure quantity: (self quantity + measure quantity ) units: ( self units ).	^result.! !!HumMeasure methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 3/12/2013 13:56'!- aMeasure 	"Subtract the argument from myself giving a new measurement."	| measure result |	"If the argument is not of the correct type, try to fix it up."	( aMeasure isKindOf:  HumMeasure )		ifTrue: [ measure := aMeasure ]		ifFalse: [ measure := HumMeasure quantity: aMeasure units: (self units)].	"This version does not attempt to convert units of measure."	( self units = measure units )		ifFalse: [ Error signal: 'This version can only perform arithmetic on measures with matching units.' ].	result := HumMeasure quantity: (self quantity - measure quantity ) units: ( self units ).	^result.! !!HumMeasure methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/23/2013 18:34'!/ aMeasure 	| divisor result |	( aMeasure isKindOf: Duration)		ifTrue: [ divisor := HumMeasure quantity: (aMeasure asSeconds) 			                                units: #second ].	( aMeasure isKindOf: HumMeasure )		ifTrue: [ divisor := aMeasure.						(aMeasure units = #percent ) 								ifTrue: [ result := HumMeasure quantity: ( self quantity / ( divisor quantity / 100.0) )																							  units: ( self units ).												 ^result.					              ].  			      ].			( aMeasure isKindOf: Number )		ifTrue: [ "dividing by a unitless scalar"			| scalar |			scalar := aMeasure.			result := self copy.			result quantity: ((self quantity)/scalar).			^result			].		result := HumMeasure new.	result quantity: (self quantity) / ( divisor quantity);				     kms: ( self kms asFloatArray ) - ( divisor kms asFloatArray ).		result forceUnits.					 	^result. ! !!HumMeasure methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 3/14/2012 20:50'!= aMeasure 	| measure result |	( aMeasure isKindOf:  HumMeasure )		ifTrue: [ measure := aMeasure ]		ifFalse: [ measure := HumMeasure quantity: aMeasure units: (self units)].	( self units = measure units )		ifFalse: [ Error message: 'This version can only perform arithmetic on measures with matching units.' ].	result := (self quantity = measure quantity ).	^result.! !!HumMeasure methodsFor: 'converting' stamp: 'RichardAlexanderGreen 4/25/2013 08:34'!as: aSymbol	"Display the measure in some alternative units."	| alternativeQuantity alternativeUnits conversionFactor |	alternativeUnits := aSymbol asString.	conversionFactor := 1.0 perform: aSymbol.	alternativeQuantity := self quantity / ( conversionFactor quantity ).	^( (alternativeQuantity printWithDecimalPlaces: 3), ' ', alternativeUnits ).! !!HumMeasure methodsFor: 'converting' stamp: 'RichardAlexanderGreen 4/25/2013 08:29'!asString	| result |	((quantity abs) between: 0.1 and: 99999.0 )		ifTrue:  [ result := ( ( quantity printShowingDecimalPlaces: 3), ' ', units )]		ifFalse: [ result := ( ( quantity asString                    ), ' ', units )].	^result.! !!HumMeasure methodsFor: 'converting' stamp: 'RichardAlexanderGreen 4/25/2013 08:25'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		nextPutAll: title;		nextPutAll: ( '( ', (self asString), ' )' ).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumMeasure class	instanceVariableNames: 'kmsDimensions kms'!!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 3/12/2013 14:02'!fromString: aString	| measure trimmedString |	self assert: ( aString isKindOf: String ).	trimmedString := aString trimBoth.	measure := self basicNew.	( trimmedString includes: $% )		ifTrue: [  measure quantity: ( trimmedString asNumber )  units: '%'. ]		ifFalse: [ measure quantity: ( trimmedString asNumber )  units: ( trimmedString copyAfter: $  ). ].	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/19/2013 16:24'!quantity: aNumber 	| m |	m := HumMeasure new.	m quantity: aNumber.	^m! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/23/2013 17:45'!quantity: aNumber units: aSymbol 	"Create an instance with the given quantity and unit of measure"	| measure |	self assert: ( aNumber isKindOf: Number ).	self assert: ( aSymbol isKindOf: Symbol ).	measure := self basicNew.	measure quantity: aNumber units: aSymbol.	^measure.! !!HumMeasure class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/23/2013 17:54'!reset	kms := nil.	self kms.! !!HumMeasure class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/23/2013 17:07'!dimensionsDocument^'<HTML><HEAD><TITLE>Units and Dimensionality</TITLE></HEAD><BODY><H2>Units and Dimensionality</H2><H2>Basic, Mechanical and Electrical units and conversions</H2><H2>Physics equations for Mechanical and Electrical quantities</H2><H3><a name="Top"> Contents </a></H3><dir>  <LI><a href="#Physical"> Physical Quantities and their Associated Dimensions </a>  <LI><a href="#Basic"> Basic Physical Quantities </a>  <LI><a href="#Mechanical"> Mechanical Physical Quantities </a>  <LI><a href="#Electrical"> Electrical Physical Quantities </a>  <LI><a href="#Algebra"> The Algebra of Dimensionality </a>  <LI><a href="#Conversion"> Conversion Between Systems of Units </a>  <LI><a href="#Definition"> Definitions of Fundamental Units </a>  <LI><a href="#DefinitionDerived"> Definitions of Derived Units </a>  <LI><a href="#UCC"> Units Conversion Constants </a>  <LI><a href="#PC"> Physical Constants </a>  <LI><a href="#PE"> Physics Equations </a></dir><H2>Just need a numeric conversion from one unit to another: click below</H2><H3><a href="http://www.easyunitconverter.com">www.easyunitsconverter.com</a></H3><H3><a name="Physical"> Physical Quantities and Their Associated Dimensions </a></H3><PRE>   Errors can occur in writing equations to solve problems in classicalphysics. Many of these errors can be prevented by performing a dimensionalitycheck on the equations. All physical quantities have a fundamental dimensionthat is independent of the units of measurement. The basic physical dimensionsare: length, mass, time, electrical charge, temperature and luminous intensity.   There are a number of systems of units for measuring physical dimensions. The MKS system is based on meter, kilogram, second  measurement. The CGS systemis based on centimeter, gram, second  measurement. The English system is basedon feet, pound, second  measurement. A few physical dimensions and theassociated measurement unit in these three systems are :        Physical Quantity                           Unit System          Dimension                         MKS         CGS          English          length                            meter       centimeter   feet          mass                              kilogram    gram         pound mass          time                              second      second       second          force                             newton      dyne         poundal          energy                            joule       erg          B.t.u.   The checking of a physical equation has two aspects. The first is to checkthe dimensionality. The dimensionality is independent of the unit system. Thesecond is to check that a consistent system of units is used in the equation.   An example of a dimensionality check is using the basic equation F=ma todetermine that force has the dimension  mass x length / time squared, thencheck if  F=mv<sup>2</sup> /r  is dimensionally correct. The check is performed by expanding the dimensions, e.g.  mass x (length/time) x (length/time) / length.Combining terms and reducing yields  mass x length / time squared. This agreeswith the dimensions expected for force from the basic equation F=ma. Asexpected, centripetal force has the same dimensionality as the force fromNewton`s second law of motion.   The table below is organized to present the physical quantity name withassociated information. The second column is one of the typical symbols usedfor the physical quantity. The third column is the dimension of the physicalquantity expressed in terms of the fundamental dimensions. The fourth columnis the name of the unit in the MKS measurement system. The fifth columnis the typical MKS unit equation. An independent table presents conversionfactors from the MKS measurement system to other measurement systems.   Physics developed over a period of many years by many people from a varietyof disciplines. Thus, there is ambiguity and duplication of symbols.</PRE><h3><a name="Basic"> Basic Physical Quantities </a></H3><PRE>PHYSICAL QUANTITY         SYMBOL  DIMENSION   MEASUREMENT UNIT  UNIT EQUATION_________________         ______  _________   ________________  ______________length                     s       L           meter              mmass                       m       M           kilogram           Kgtime                       t       T           second             secelectric charge            q       Q           coulomb            cluminous intensity         I       C           candle             cdtemperature                T       K           kelvin             <sup>o</sup>Kangle                      theta   none        radians            none</PRE><H3><a name="Mechanical">  Mechanical Physical Quantities (derived) </a></H3><PRE>PHYSICAL QUANTITY         SYMBOL  DIMENSION   MEASUREMENT UNIT  UNIT EQUATION_________________         ______  _________   ________________  ______________area                       A       L<sup>2</sup>          square meter       m<sup>2</sup>volume                     V       L<sup>3</sup>          stere              m<sup>3</sup>velocity                   v       L/T         meter per second   m/secangular velocity           &omega;       1/T         radians per second sec<sup>-1</sup>acceleration               a       L/T<sup>2</sup>        meter per square   m/sec<sup>2</sup>                                               secondangular acceleration       &alpha;       1/T<sup>2</sup>        radians per        1/sec<sup>2</sup>                                               square secondforce                      F       ML/T<sup>2</sup>       newton             Kg m/sec<sup>2</sup>energy                     E       ML<sup>2</sup>/T<sup>2</sup>      joule              Kg m<sup>2</sup> /sec<sup>2</sup>work                       W                     "heat                       Q                     "torque                     T       ML<sup>2</sup>/T<sup>2</sup>      newton meter       Kg m<sup>2</sup> /sec<sup>2</sup>power                      P       ML<sup>2</sup>/T<sup>3</sup>      watt               joule/secdensity                    &rho;       M/L<sup>3</sup>        kilogram per       Kg/m<sup>3</sup>                                               cubic meterspecific gravity           SG      ratio of density to density of water                                   SG times 1000 Kg/m<sup>3</sup> is &rhopressure                   P       M/LT<sup>2</sup>       newton per sq m     Kg/m sec<sup>2</sup>elastic modulus            E                   square meterbulk modulus               K         M/LT<sup>2</sup>       newton per sq m     Kg/m sec<sup>2</sup>                                   (pressure)stress                     &sigma;        M/LT<sup>2</sup>       newton per sq m     Kg/m sec<sup>2</sup>                                   (pressure)strain                     &epsilon;       none (L`-L)/L  dimensionlessmomentum                   p       ML/T        newton second      Kg m/secimpulse                    p       ML/T        newton second      Kg m/secinertia (linear)           I       ML<sup>2</sup>/T       joule second       Kg m<sup>2</sup>/secmoment of inertia          I       ML<sup>2</sup>         kilogram meter sq  Kg m<sup>2</sup> luminous flux              &Phi;       C           lumen (4Pi candle  cd sr                                                for point source)illumination               E       C/L<sup>2</sup>        lumen per          cd sr/m<sup>2</sup>                                               square meterentropy                    S       ML<sup>2</sup>/T<sup>2</sup> K    joule per degree   Kg m<sup>2</sup> /sec<sup>2</sup> <sup>o</sup>Kvolume rate of flow        Q       L<sup>3</sup>/T        cubic meter        m<sup>3</sup> /sec                                               per seconddynamic viscosity          &mu;       M/LT        newton second      Kg/m sec                                               per square meterkinematic viscosity &mu;/&rho;    &nu;      L<sup>2</sup>/T        square meter       m<sup>2</sup> /sec                                               per secondspecific weight            &gamma;       M/L<sup>2</sup> T<sup>2</sup>     newton             Kg/m<sup>2</sup> sec<sup>2</sup>                                               per cubic meter</PRE><H3><a name="Electrical"> Electrical Physical Quantities (derived) </a></H3><PRE>PHYSICAL QUANTITY         SYMBOL  DIMENSION   MEASUREMENT UNIT  UNIT EQUATION_________________         ______  _________   ________________  ______________electric current           I       Q/T         ampere             c/sec                                     2  2                             2    2emf,voltage,potential      E       ML /T Q     volt               Kg m /sec c                                     2   2                            2      2electric resistance        R       ML /TQ      ohm                Kg m /sec c                                     2   3                             2     3conductivity               sigma   TQ /ML      mho per meter      sec c /Kg m                                    2 2   2                          2 2     2capacitance                C       T Q /ML     farad              sec c /Kg m                                     2  2                             2  2inductance                 L       ML /Q       henry              Kg m /c                                       2                                 2current density            J       Q/TL        ampere per         c/sec m                                               square meter                                      3                              3charge density             rho     Q/L         coulomb per        c/m                                               cubic metermagnetic flux,             B       M/TQ        weber per          Kq/sec c   magnetic induction                          square metermagnetic intensity         H       Q/LT        ampere per meter   c/m secmagnetic vector potential  A       ML/TQ       weber/meter        Kg m/sec c                                       2                                  2electric field intensity   E       ML/T Q      volt/meter or      Kg m/sec c                                               newton per coulomb                                      2                              2electric displacement      D       Q/L         coulomb per        c/m                                               square meter                                       2                                2permeability               mu      ML/Q        henry per meter    Kg m/c                                    2 2   3                          2 2     3 permittivity,              epsi    T Q /ML     farad per meter    sec c /Kg m  dielectric constant                                                                     -1frequency                  f       Pi/T        hertz              sec                                                                     -1angular frequency          omega   1/T         radians per second secwave length                lambda  L           meters             m</PRE><H3><a name="Algebra"> The Algebra of Dimensionality </a></H3><PRE>   The dimension of any physical quantity can be written as                 L<sup>a</sup>   M<sup>b</sup>   T<sup>c</sup>   Q<sup>d</sup>   C<sup>e</sup>   K<sup>f</sup>where a,b,c,d,e and f are integers such as -4, -3, -2 , -1, 0, 1, 2, 3, 4and L is length, M is mass, T is time, Q is charge, C is luminous intensityand K is temperature. An exponent of zero means the dimension does not applyto the physical quantity. The normal rules of algebra for exponents applyfor combining dimensions.   In order to add or subtract two physical quantities the quantities musthave the same dimension. The resulting physical quantity has the samedimensions. Physical quantities with the same dimension in differentsystems of units can be added or subtracted by multiplying one ofthe quantities by a units conversion factor to obtain compatible units.   The multiplication of two physical quantities results in a new physicalquantity that has the sum of the exponents of the dimensions of the initialtwo quantities.   The division of one physical quantity by another results in a new physicalquantity that has the dimension of the exponents of the first quantity minusthe exponents of the second quantity.   Taking the square root of a physical quantity results in a new physicalquantity having a dimension with exponents half of the initial dimension.   Raising a physical quantity to a power results in a new physical quantityhaving a dimension with the exponents multiplied by the power.          e.g. v has dimension L/T               then v<sup>2</sup>  has dimension L<sup>2</sup>/T<sup>2</sup>  or  L<sup>2</sup> T<sup>-2</sup>   The derivative of a physical quantity with respect to another physicalquantity results in a new physical quantity with the exponents of thefirst dimension minus the exponents of the other dimension.         e.g.  v has dimension L/T, t has dimension T,               then dv/dt has dimension L/T<sup>2</sup>    of acceleration   The integral of a physical quantity over the range of another physicalquantity results in a new physical quantity that has a dimension with thesum of the exponents of the two quantities.                 e.g.  v has dimension L/T, t has dimension T,               then  integral v dt  has dimension  L</PRE><H3><a name="Conversion"> Conversion Between Systems of Units </a></H3><PRE>   This section is organized to be consistent with the discussion of physicalquantities and equations of physics. The definition of the six fundamentalunits of physical quantities is presented for the MKS system of units. Thedefinition of some derived units is then presented in the MKS system. Thedefinitions in other systems of units follow the MKS definitions. This isfollowed by a table of conversion factors between the MKS system and othersystems of units.   The MKS system based on the meter, kilogram second was augmented to allowforce and energy from electrical quantities to be measured in one rationalizedsystem of units. The system was proposed by Giorgi in 1904. It was adopted bythe IEC in 1935 to take effect on January 1, 1940. The electrical to mechanicalconversion was chosen to be based on the permeability of free space to be        -74Pi x 10   henry per meter. </PRE><H3><a name="Definition"> Definition of Fundamental Units </a></H3><PRE>Meter, fundamental unit of length, defined as the distance between two                                                          ospecified lines on a specific bar of platinum-iridium at 0 C at standardatmospheric pressure supported at two neutral points 0.285 meter from thecenter of the bar. The bar is kept at the International Bureau of Weightsand Measures near Paris France.Centimeter, cgs unit of length, defined as 1/100 meter.Feet, English unit of length, defined as 0.3048 meter in U.S.Inch, English unit of length, defined as 0.00254 meter in U.S.                                       -10Angstrom, unit of length, defined as 10    meter.Kilogram, fundamental unit of mass, defined as the mass of a specificcylinder of platinum - iridium kept at the International Bureau of Weights andMeasures.Gram, cgs unit of mass, defined as 1/1000 kilogram.Pound, English unit of mass, the avoirdupois pound is defined to be0.4535924277 kilogram in the U.S. The apothecary or troy pound is5760/7000 of the avoirdupois pound.Second, fundamental unit of time, defined as one 86,400th part of a meansolar day. Presently measured by an atomic clock based on the rate of nucleardecay.Coulomb, fundamental unit of charge, defined as the charge required toobtain one newton of force between two such charges at a distance of onemeter.Candle, fundamental unit of luminous intensity, defined as the sourceintensity of 1/60 centimeter square opening of the standard light sourceof a glowing cavity with temperature equal to that of solidifying platinum.A point source of one candle radiates one lumen per steradian.Kelvin, fundamental unit of temperature, defined as zero wherethe molecular activity of gases cease. The scale is based on zero degreescentigrade (Celsius) for the freezing point of water and 100 degreescentigrade at the boiling point of water. Zero degrees centigrade is 273.16Kelvin.Radians, fundamental unit of angle, defined as the angle formed by alength of circular arc being equal to the radius creating the arc. </PRE><H3><a name="DefinitionDerived"> Definition of Derived Units </a></H3><PRE>Newton, unit of force, defined as the force required to accelerate a massof 1 kilogram at 1 meter per second per second when acting continuously. Dyne, cgs unit of force, defined as the force required to accelerate a mass                                                                  -5of 1 gram at at 1 centimeter per second per second. One dyne is 10   newton.Poundal, English unit of force, defined as the force required to acceleratea mass of 1 pound at 1 foot per second per second. One poundal is            -107.23300 10    newton. A poundal based on earth`s gravitation is 32.174 poundsavoirdupois.Joule, unit of energy, defined as work done by 1 newton acting through adistance of one meter. (equivalent to one watt expended in one second.)Erg, cgs unit of energy, defined as work done by 1 dyne acting through a                                         -7distance of one centimeter. One erg is 10   joule.Kilogram calorie, large calorie, unit of energy, is the heat required toraise the temperature of 1 kilogram of water 1 degree centigrade at astated temperature. i.e. Kg Cal(22 C). The mean kilogram calorie is defined as1/100 of the heat required to raise the temperature of 1 kilogram of water      o        ofrom 0 C to 100 C. The small calorie is the gram calorie equal to 1/1000 ofa large calorie. One mean kilogram calorie is 0.000238889 joule .British thermal unit, B.t.u , unit of energy, the heat required to raisethe temperature of 1 pound of water 1 degree Fahrenheit at a stated                            otemperature. i.e. B.t.u.(39 F). The mean British thermal unit is defined as1/180 of the heat required to raise the temperature of 1 pound of water from  o        o32 F to 212 F. One mean B.t.u. is 0.00009480 joule.Mole, kilogram molecule, is the number of kilograms of a substance thatcorresponds to its molecular weight divided by 1000. In the cgs system ofunits a mole, gram molecule, is the number of grams of a substance thatcorresponds to its molecular weight. The mass of a single molecule inkilograms is the kilogram molecule divided by Avogadro`s number. For atomsthe molecular weight is the atomic weight.Steradian, sr, is the ratio of the area of the intercepted surface ofa sphere to the radius of the sphere squared. 4Pi steradians means thetotal area of the sphere is intercepted.Watt, unit of power, defined as work done at a constant rate of onejoule per second.Horsepower ( mechanical ), English unit of power, defined as work doneat a rate of 550 foot-pounds per second. One mechanical horsepower is745.705 watt.Horsepower ( electrical ), English unit of power, by definition exactly760 watt.Ampere, unit of electric current, defined as the current that will flowthrough a circuit with a resistance of one ohm when one volt is applied. Theinternational standard is defined as the current which will deposit silverat a rate of 0.00111800 gram per second. One international ampere is about0.999835 absolute ampere. International electrical units are based on physicalstandards whose specifications are slightly in error. Instruments made afterJanuary 1, 1948 are calibrated in absolute units.Notes:        The singular form of units is used with the exception of foot and feet.        Proper names appearing in units and constants are not capitalized.References:             Conversion Factors and Tables by Zimmerman and Lavine             Electric and Magnetic Fields by Stephen Attwood             Elements of Physics by Shortley and Williams</PRE><H3><a name="UCC"> UNITS CONVERSION CONSTANTS </a></H3><PRE>to get MKS units from other units       to get other units from MKS unitsvalue      value                        value        valuein MKS  =  in other  x  constant        in other  =  in MKS  x  constantunits      units                        units        units                                 lengthmeter = angstrom x 1.0E-10              angstrom = meter x 1.0E10meter = mil x 0.254E-4                  mil = meter x 39370.07874meter = centimeter x 0.01               centimeter = meter x 100meter = inch x 0.0254                   inch = meter x 39.37007874meter = feet x 0.3048                   feet = meter x 3.280839895meter = yard x 0.9144018288             yard = meter x 1.0936111meter = fathom x 1.8288036              fathom = meter x           meter = rod x 5.0292099                 rod = meter x 0.19883839meter = chain(surveyor) x 20.12         chain(surveyor) = meter x 66 ftmeter = chain(engineer) x 30.48006      chain(engineer) = meter x 100 ftmeter = furlong x 0.2011684E+3          furlong = meter x 0.49709597E-2meter = mile(statute) x 1.6093472E+3    mile(statute) = meter x 0.6213699E-3  *meter = mile(nautical) x 1.8532487E+3   mile(nautical) = meter x 0.539593E-3meter = league(land) x 4.82804E+3       league(land) = meter x meter = league(marine) x 5.5596E+3      league(marine) = meter xmeter = light year x 9.459936E+15       light year = meter x                                    masskilogram = gram x 0.001                 gram = kilogram x 1000kilogram = grain(troy) x 0.6480E-4      grain(troy) = kilogram x 15432kilogram = pennyweight(troy) x 1.5552E-3 pennyweight(troy) = kilogram x 643                                          pennyweight(troy) = grains * 24kilogram = carat(troy) x 0.2E-3         carat(troy) = kilogram * 5000                                        carat(troy) = grains * 324kilogram = scruple x 1.296E-3           scruple = kilogram x 771.6kilogram = dram(avdp) x 1.772E-3        dram(avdp) = kilogram x 564.334kilogram = ounce(avdp) x 0.02834952     ounce(avdp) = kilogram x 35.27kilogram = ounce(troy) x 0.031103481    ounce(troy) = kilogram x 32.15kilogram = pound(troy) x 0.37324177     pound(troy) = kilogram x 2.6792285kilogram = pound(avdp) x 0.45359244     pound(avdp) = kilogram x 2.204622341  *kilogram = ton(short) x 907.18486       ton(short) = kilogram x 1.102311E-3                                        ton(short) = 2000 pounds(avdp)        *kilogram = ton(long) x 1016.047         ton(long) = kilogram x 0.9842064E-3kilogram = ton(metric) x 1000           ton(metric) = kilogram x 0.001                                     timesecond = minute x 60                    minute = second * 0.0166667second = hour x 3600                    hour = second * 2.777778E-4second = day x 86400                    day = second * 1.1574E-5second = fortnight x 1.2096E+6          fortnight = second * 0.82672E-6second = month x 2.6298E+6              month = second * 0.380257E-6second = year x 31.557E+6               year = second * 0.031688E-6                             electric chargecoulomb = electron charge x 6.2425E+20  electron charge = coulomb x 1.60193E-19coulomb = faraday x 0.01439             faraday = coulomb x 96.480coulomb = ampere hours x 2.77778E-4     ampere hours = coulomb x 3600                                temperatureo    o                                  o    o K =  C + 273.16                         C =  K - 273.16                                        o     o                                         C = ( F - 32) * 5/9o     o                                 o     o K = ( F - 32) * 5/9 + 273.16            F = ( K - 273.16) x 1.8 + 32.0                                        o    o                                         F =  C * 9/5 + 32                                     angleradian = second(angular) x 4.84814E-6   second(angular) = radian x 0.20626E+6radian = minute(angular) x 0.000290888  minute(angular) = radian x 3437.75radian = degree(angular) x 0.017453293  degree(angular) = radian x 57.2957795radian = revolution x 6.2831853         revolution = radian x 0.159154943radian = bam x                            areasquare meter = square centimeter        square centimeter = square meter                x 1.0E-4                                     x 10,000square meter = square inch              square inch = square meter               x 6.4516E-4                            x 1550square meter = square feet              square feet = square meter               x 0.09290341                           x 10.76387 square meter = square yard              square yard = square meter               x 0.83613                              x 1.19598square meter = square mile(statute)     square mile(statute) = square meter               x 2.589998E+6                                   x 0.368E-6square meter = acre x 4046.873          acre = square meter x 0.0002471square meter = circular mil             circular mil = square meter               x 0.506709E-6                           x 1.97352E+6square meter = hectare x 1.0E+4         hectare = square meter x 1.0E-4square meter = township x 93.24E+6      township = square meter x 1.0725E-8square meter = barn x 1.0E-28           barn = square meter x 1.0E+28                              volumecubic meter = cubic centimeter x 1.0E-6 cubic centimeter = cubic meter x 1.0E+6cubic meter = cubic inch x 0.163871E-4  cubic inch = cubic meter x 61023.74cubic meter = cubic feet x 0.028317     cubic feet = cubic meter x 35.31466cubic meter = cubic yard x 0.76456      cubic yard = cubic meter x 1.30795cubic meter = cubic mile(statute) x     cubic mile(statute) = cubic meter              x 4.168205E+9                                   x 0.23991E-9cubic meter = liter x 0.001             liter = cubic meter x 1000cubic meter = fluid ounce x 0.295737E-4 fluid ounce = cubic meter x 0.33814E+7cubic meter = cup x 0.236589E-3         cup = cubic meter x 42267cubic meter = pint(liquid)              pint(liquid) = cubic meter x 21113.4              x 0.4731798E-3cubic meter = quart(liquid)             quart(liquid) = cubic meter              x 9.4625E-4                               x 1056.8cubic meter = gallon x 0.003785         gallon = cubic meter x 264.2cubic meter = barrel x 6.28981          barrel = cubic meter x 0.1589873cubic meter = pint(dry) x 5.50625E-4    pint(dry) = cubic meter x 1816.118cubic meter = quart(dry) x 2.75313E-4   quart(dry) = cubic meter x 908.059                                        quart(dry) = pint(dry) x 0.5cubic meter = peck x 8.81E-3            peck = cubic meter x 113.507                                        peck = quart(dry) x 0.125cubic meter = bushel x 0.03524          bushel = cubic meter x 28.3768                                        bushel = peck x 0.25cubic meter = keg x (less than 10 gal)cubic meter = cord x 3.625barrel = gallon x 31.5 (food)  x 42 (petroleum)                              velocitymeter per second = centimeters per second x 100.0meter per second = kilometer per hour x 0.001meter per second = inches per second x 39.37meter per second = feet per second x 3.28083meter per second = miles per second x 17322.6meter per second = inches per minute x 0.6562meter per second = feet per minute x 0.05468meter per second = miles per hour x 2.2369meter per second = knots x 1.9438                            accelerationmeter per second squared = centimeter per second squared x 100.0meter per second squared = feet per second squared x 3.28083meter per second squared = miles per hour squared x  2.2369                              forcenewton = dyne x 1.0E-5                  dyne = newton x 1.0E5newton = poundal x 7.233                poundal = newton x 0.138newton = pound force x 7.233/32.17  g   pound force = newton X 1/0.2248                     x 0.2248                             energyjoule = watt second                        watt = joule per secondjoule = erg x 1.0E-7                       erg = joule / 1.0E-7joule = gram calorie x 0.238889E-6joule = calorie x 1/0.238889               calorie = joule x 0.239joule = foot pounds x 1.356                foot pounds = joule x 0.7376joule = kilowatt hour x 3.6E+6             kilowatt hour = joule/(60*60*1000)joule = watt hour x 1/0.0027               watt hour = joule x 0.00027joule = horsepower hours x 2.684E+6joule = BTU x 1/0.00094                    BTU = joule x 0.00094joule = therm x 1/9.478E-9                 therm = joule x 9.478E-9                              powerwatt = volt ampere x 1watt = calorie per second x 1/0.2390       calorie per second = watt x 0.2390watt = joule per hour x 1/3600             joule per hour = watt x 3600watt = erg per second x E-7                erg per second = joule x E+7watt = kilogram calorie per second xwatt = kilogram calorie per minute xwatt = horsepower(mechanical) x 1/745.705watt = horsepower(electrical) x 1/760     horsepower(electrical) = watt x 760watt = horsepower(metric)  1.014 ?watt = horsepower(boiler) x 9.804E+3  33,520 Btu per hourwatt = B.t.u per minute x 17.57watt = B.t.u per hour x 17.57*60watt = foot pound per minute x 0.2260E-3   33000 HPwatt = foot pound per second x 1.356   550 HP                             densitykilogram per cubic meter = pound per cubic foot x 16.018 ?                             pressurepascal = newton per square meter x 1pascal = Kg force per square meter x 1/0.10197pascal = pound force per square foot x 1/0.020885pascal = pound force per square inch x 1/0.145038E-3pascal = ton per square foot x 10.4E-6pascal = atmosphere(standard) x 1E-5pascal = inch of water x 0.004pascal = inches of mercury x 1/0.296E-3pascal = millimeters of mercury x 0.0075pascal = bar x 1/1.0E-5                         bar = pascal x 1.0E-5pascal = millibar x 1/0.01                      millibar = pascal x 0.01pascal = torr x 0.0075                             torquenewton meter = foot pound x                             flow ratecubic meter per second = gallon per minute x 0.6309E-8cubic meter per second = cubic feet per minute x 0.4719E-3                          specific heat, entropy                   o                     ojoule per kilogram  K = B.t.u. per pound  F x 4.187E+3                          dynamic viscositypoise = dyne second per square centimeter                           kinematic viscositystoke = square centimeter per second                           electric currentampere = abampere x 10ampere = statampere x 0.333333E-9                                                              magnetic flux B                         magnetic induction                        magnetomotive force                       magnetic field strength H                        dielectric constant                        permittivity constant                          rotation rateradians per second = revolutions per second xradians per second = revolutions per minute x</PRE><H3><a name="PC"> PHYSICAL CONSTANTS </a></H3><PRE>   There are a number of physical constants that are used in equationsto solve problems in physics. Errors may occur because the dimensionalityand/or units of the physical constant are not known. The table belowpresents some physical constants with their typical symbol, dimension,nominal value and unit of measure in the MKS system.PHYSICAL CONSTANT           SYMBOL  DIMENSION   MKS VALUE        UNIT_________________           ______  _________   _________        ____                                        3                             3air density, normal          rho     M/L         1.293            Kg/m   conditionsair molecule, mass           m       M           4.81E-26         Kg                              aair molecule,                w       M           0.028952         Kg/mole kilogram molecular weight                                         2                                2atmospheric pressure         A       M/LT        1.01325          newton/mAvogadro`s number            N       none        6.023E+23        molecules in  molecules in a mole                                               a mole  based on 12g of carbon-12                                       2  2                             oBoltzmann`s constant         k       ML /T K     1.380E-23        joule/ K  same units as entropy                                       2  2                          electron volt                e       ML /T       1.60210E-10      joule                                       3  2 2                         2       2electrostatic constant       k       ML /T Q     8.987E+9         nt m/coulomb  reciprocal permittivity                                          m/faradelementary charge            e       Q           1.6021892E-19    coulombelectron mass                m       M           9.1066E-31       Kg                              efaraday                      f       L/T         9.648456E+4      coulomb/mole                                       2  2                             ogas constant of a mole       R       ML /T K     8.3144           joule/ KAvogadro * Boltzmann                                        2                              2gravity (earth)              g       L/T         9.80665          m/sechydrogen atom mass           m       M           1.6734E-27       Kg                              hhydrogen atom                w       M           1.0079E-3        Kg/mole  kilogram atomic weight                                       2   2                          impedance of free space      Z       ML /TQ      120Pi            ohm                              0mechanical equivalent        J       none        4186.05          joule/   of heat                                                          Kg calorie                                      2 2   3                        permittivity (vacuum)        epsi    T Q /ML     8.854E-12        farad/meter                                 0                                         2                           permeability (vacuum)        mu      ML/Q        4Pi E-7          henry/meter                               0Pi, ratio of circumference   Pi      none        3.14159265       radians      to diameter                                       2                              Planck`s constant            h       ML /T       6.624E-34        joule secondspeed of light (vacuum)      c       L/T         2.99792458E+8    meter/secondspeed of sound (air)         s       L/T         331.45           meter/second                                      2   2                           2   2universal gravitational      G       L /MT       6.6720E-12       nt m /Kg    constant                                        3                             3density of fresh water       rho     M/L         1000.0           Kg/m    definition                                   62.43            lb/cu-ft                                        3                             3density of sea water         rho     M/L         1025.0           Kg/m    approx                                       64.00            lb/cu-ftNote: some constants are related to combinations of other constants :      electrostatic constant = 1/ 4Pi permittivity (vacuum)      speed of light = 1/ sqrt( permittivity x permeability )      impedance of free space Z  = sqrt( permeability / permittivity )                               0</PRE><H3><a name="PE"> PHYSICS EQUATIONS </a></H3><PRE>                     SOME EQUATIONS OF PHYSICS F = m a              force equals mass times acceleration,                     Newton`s second law of motion       2  F = m v /r           force equals mass times velocity squared over radius,                     centripetal force of a mass traveling in a circle             2 F = G m  m /s        gravitational force between mass  and mass  at distance s       1  2                                          1         2                     with universal gravitational constant G               2g = G m      /r        acceleration due to gravity on earth       earth   earth             2 F = k Q  Q /s        electrical force between charge  and charge  at distance s       1  2                                         1           2                     with electrostatic constant k . If there is a dielectric                     then multiply by the non dimensional dielectric constant.F = 1/2Pi  mu I  I  /s               1  2                     electrical force between two parallel wires carrying                     currents I  and I  with a spacing s with permeability                               1      2                     mu. This is the force for one meter of wire length.         2 F = B H s                     electrical force in a magnetic field equals the magnetic                     flux times the magnetic intensity applied to an area         2 F = E D s                     electrical force in an electric field equals the electric                     field intensity times the electric displacement applied                     to an areas = v t              distance equals velocity times time (linear)v = a t              velocity equals acceleration times time (linear)                      2s = s  + v t + 1/2 a t      0    0                       linear distance equals initial distance plus                     initial velocity times time plus one half acceleration                     times time squared            2 v  = sqrt( v  + 2as) f          0                    the final velocity equals the square root of the                    initial velocity squared plus two times the acceleration                    times the distance traveledv  = sqrt( s g )    the critical velocity for any object to orbit at a c                    distance s from the source of gravitational field gvf1 = ((m1-m2)/(m1+m2))*v1 + ((2*m2)/(m1+m2))*v2vf2 = ((m2-m1)/(m1+m2))*v2 + ((2*m1)/(m1+m2))*v1                    final velocities of an elastic collision of body                    with mass m1 and velocity v1 hitting a body with                    mass m2 and velocity v2. Kinetic energy conserved.vf = (m1*v1 +m2*v2)/(m1+m2)                    final velocity of an inelastic collision of body                    with mass m1 and velocity v1 hitting and sticking                    to a body with mass m2 and velocity v2. Kinetic                    energy is not conserved but is converted. theta = omega t     angle equals angular velocity times time (rotational)omega = alpha t     angular velocity equals angular acceleration times time                    (rotational)                                      2theta = theta  + omega t + 1/2 alpha t              0        0                      angular rotation equals initial angle plus                    initial angular velocity times time plus one half                    angular acceleration times time squared           2 w  = sqrt(w  + 2 alpha * angle)  f         0                    the final angular velocity equals the square root of                    the initial angular velocity squared time twice the                    angular acceleration times the angle traveled               2I = mass*radius     moment of inertia, about an axis, integral from 0 to mass                    of radius squared times incremental massT = I alpha         torque equals moment of inertia times angular accelerationL = I omega         angular momentum equals moment of inertia times                    angular velocity               2E = 1/2 I omega     kinetic energy equals one half moment of inertia times                    angular velocity squaredP = I alpha omega   power equals moment of inertia times angular acceleration                    times angular velocityW = I alpha theta   work equals moment of inertia times angular acceleration                    times angle traveledE = I R             voltage equals current through a resistor times the                    resistanceI = C (E  - E )/(t  - t )         2    1    2    1                    the current through a capacitor equals the capacitance                    times the change in voltage over the change in timeE = I * time / C    actually an integral of current divided by C                    one amp for one scecond charges one farad to one voltE = L (I  - I )/(t  - t )         2    1    2    1                    the voltage across an inductor equals the inductance                     times the change in current over the change in timeI = E * time / L    actually a derivative of voltage divided by L                    one volt change in one second causes a current                    of one amp in a 1 henry inductorC = epsi  A/s                    the capacitance in farad of a parallel plate capacitor                    equals the permittivity times the area divided by the                    spacing.L = n mu r (ln 8r/d  - 7/4)                    the inductance in henry of n turns of wire with diameter                    d closely wrapped in a coil of radius r with permeability                    mu is approximately given by this equation.H = 1/2 I / r                    the magnetic intensity at the center of a current loop                    equals 1/2 the current divided by the radius of the loopB = mu H            the magnetic flux equals the permeability times the                    magnetic intensityD = epsi E          the electric displacement equals the permittivity                    times the electric field intensityP = E I             power equals an electrical potential causing a currentP = F s             power equals a force applied over a distance       2 E = m c             energy from converting a mass to energy                       ( c = speed of light)E = I omega         energy of rotation, Inertia times rotational velocity           2 E = 1/2 m v         kinetic energy of a mass traveling at a velocityE = m g s           potential energy of a mass in a gravitational field                    at a height sE = 1/2 B H V       energy of a magnetic field in the volume V with magnetic                    flux B and magnetic intensity H. This is usually an                    integral of an incremental volume times B times H                    in the incremental volume.E = 1/2 D E V       energy of an electric field in the volume V with electric                    displacement D and electric field intensity E. This is                    usually an integral of an incremental volume times D                    times E in the incremental volume.           2E = 1/2 C V         energy stored in a capacitor with capacitance C having                    a voltage V           2E = 1/2 L I         energy stored in an inductor with inductance L having                    a current IT = F s             torque equals the force applied at radius sT = I alpha         torque equals the rotational inertia times the angular                    acceleration                                 2E = P V = R T = Na k T = 1/3 N m v             ideal gas law                                   rms                    These relations are for one mole (kilogram molecule) of                    an ideal gas at an absolute pressure P, volume V,                    gas constant R, Avogadro`s number Na, Boltzmann`s                     constant k, temperature T in Kelvin, gas                    molecule mass m, root mean square speed of the molecules                    v    in meters per second. Each section of the equation                     rms                    represents energy in joule.                    P V = n R T for n moles of the gas.                    With sigma being density, P = sigma R T / M where M = mass/n             2                          2P + 1/2 rho v + rho g z  = P + 1/2 rho v + rho g z 1           1         1    2           2         2                    This equation relates pressure P, velocity v and relative                    height z for a non compressible fluid in a pipe, observed                    at location 1 and location 2. rho is the density of the                    fluid and g is the gravitational constant.            2L = C  rho v  A / 2     L                    the lift force equals the dimensionless coefficient of                    lift times the air density times the velocity squared times                    the surface area divided by 2.            2D = C  rho v  A / 2     D                    the drag force equals the dimensionless coefficient of                    drag times the air density times the velocity squared times                    the surface area divided by 2.nu = mu / rho                    the kinematic viscosity equals the dynamic viscosity over                    the density in a fluidP = Q (p - p )        1   2       the power, P, required to drive a volume rate of flow, Q,                    from pressure p  to pressure p  .                                   1              1o    o C =  K - 273.16                    degrees centigrade equals Kelvin minus 273.16o     o F = ( K -273.16) x 9/5 + 32                    degrees Fahrenheit as a function of Kelvin</PRE><H3><a href="#Top"> Go to top </a></H3><P> Last updated 5/11/10 </P></BODY></HTML>'! !!HumMeasure class methodsFor: 'class variables' stamp: 'RichardAlexanderGreen 4/24/2013 10:53'!kms	^ kms ifNil: [ kms := Dictionary new.			kms 				at: #meter put: { 0. 1. 0. };				at: #second put: { 0. 0. 1. };				at: #meterPerSecond put: { 0. 1. -1.};             "speed"				at: #meterPerSecondPerSecond put: { 0. 1. -2. };   "acceleration"				at: #kilogram put: { 1. 0. 0. };    "mass"				at: #newton put: { 1. 1. -2. };     "force"				at: #pascal put: { 1. -1. -2. };    "newton per square meter"				at: #watt put: { 1. 2. -3. };       "power"				at: #joule put: { 1. 1. -2. };      "energy"				at: #squareMeter put: { 0. 2. 0. }; "area"				at: #cubicMeter  put: { 0. 3. 0. }; "volume"				at: #kilogramPerCubicMeter put: { 1. -3. 0.} "density"		].! !Object subclass: #HumBus	instanceVariableNames: 'uri uriActor'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumBus commentStamp: 'RichardAlexanderGreen 9/20/2012 07:34' prior: 0!The communication bus provides a message store and forward service with optional logging.If an actor is temporarily not available, a message will be held for some (TBD) time.The messages to a role may be replayed later.Instance Variables:	uri			<URI>	uriActor	<Dictionary>!!HumBus methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/10/2012 13:51'!uri	"Return my URI"	^ uri! !!HumBus methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/10/2012 13:50'!uri: aString 	uri := aString.! !!HumBus methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/10/2012 15:27'!uriActor	^ uriActor ifNil: [ uriActor := Dictionary new. ].! !!HumBus methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 2/13/2012 10:52'!ping: aURI	^ ( self uriActor ) at: aURI ifAbsent: [ Error signal: 'Messenger has no entry for URI: ', aURI ].! !!HumBus methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 3/11/2013 07:52'!registerActor: anActor atActorURL: aURI 	"Track actor."	self assert: ( anActor isKindOf: HumActor ).	self assert: ( aURI isKindOf: String ).	"Track URI->actor association."	(self uriActor) at: aURI put: anActor.	"TODO: Track actor->URI also."! !!HumBus methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 3/11/2013 07:54'!send: aHumStatement to: recipientURI from: senderURI	| actorInstance |	actorInstance := (self uriActor) at: recipientURI 								 ifAbsent: [ Error signal: 'Messenger does not know recipient: ', recipientURI ].	"This works when actor is local."	actorInstance run: aHumStatement	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumBus class	instanceVariableNames: ''!!HumBus class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/10/2012 13:49'!uri: aString 	| instance |	instance := self basicNew.	instance uri: aString.	^instance.! !Object subclass: #HumActor	instanceVariableNames: 'myID myURI messengerURI bookkeeperURI roles worldbaseURI managerURI configuration blackboard'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumActor commentStamp: 'RichardAlexanderGreen 9/19/2012 11:32' prior: 0!An actor is capable of performing one or more roles.Some actors are part of the run-time systems and have particular configuration requirements.In general, an actor needs a connection to a messenger in order to communicate with the system.Most actors also need a connection to a manager so that the manager can assign actions to the actor.Some actors also need a connection to a bookkeeper so that the actor can record utilization.Instance Variables:	myID	<String>	myURI	<String>	messengerURI	<URI>	bookkeeperURI	<URI>	roles			<Collection of: String>	managerURI	<URI>	configuration	<HumConfiguration>!!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/18/2012 10:40'!blackboard	^ blackboard ifNil: [ blackboard := HumBlackBoard new. ].! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 10:39'!bookkeeper	^ bookkeeperURI ifNil: [ (self configuration) bookkeeper ].! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 10:38'!bookkeeper: aURI 	self checkURI: aURI.	bookkeeperURI := aURI.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:00'!configuration	^ configuration ifNil: [ Error signal: 'Actor {',myID,'} is not configured.']! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/6/2012 19:50'!configuration: aHumConfiguration 	configuration := aHumConfiguration.	self messenger: ( configuration messengerURI ).! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:00'!id	^myID! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:00'!id: aString 	self assert: (aString isKindOf: String ).	myID := aString.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/10/2012 16:11'!manager	^(self configuration ) managerURI .! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:01'!manager: aURI 	self assert: ( aURI isKindOf: String ).	managerURI := aURI.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:49'!manager: anID uri: aURI configuration: aHumConfiguration 	self configuration: aHumConfiguration.	self id: anID.	self uri: aURI.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:29'!managerURI	managerURI ifNil: [ managerURI := self configuration managerURI ].	self assert: ( managerURI isKindOf: String ).	^managerURI.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/10/2012 15:31'!messenger	^( self configuration ) messenger.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:04'!messenger: aMessengerURI 	self assert: ( aMessengerURI isKindOf: String ).	messengerURI := aMessengerURI.	! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:04'!roles		^ roles  ifNil: [ Error signal: 'Actor {', myID,'} has no role.' ].! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/26/2012 20:10'!roles: anArray 	self assert: ( anArray isKindOf: Array ).	roles := anArray.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 08:59'!uri	^myURI! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:50'!uri: aURI	self assert: ( aURI isKindOf: String ).	myURI := aURI.	"My identifier (myID) should be established at this point also."	self assert: (myID isKindOf: String ).	"Because I need it to check-in with the messenger."	self assert: (self messenger isKindOf: HumBus ).	self messenger registerActor: self atActorURL: myURI. ! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 10:58'!worker: anID uri: aURI roles: arrayOfRoleNames configuration: aHumConfiguration	configuration :=  aHumConfiguration.      self id: anID.	self uri: aURI.	roles := arrayOfRoleNames.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:07'!worldbase: aURI 	self assert: ( aURI isKindOf: String ).	worldbaseURI := aURI.! !!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 2/13/2012 09:27'!checkIn	| message quotedRoles |	"First, check-in with the messenger."	( self messenger ) registerActor: self atActorURL: (self uri).	"Send check-in message to my resource manager."	quotedRoles := ''.	roles		do: [ :role | quotedRoles := quotedRoles, ' ', role quoted ].	message := 'self checkInActor: ', myID quoted, ' at: ', myURI quoted, ' withRoles: #(', quotedRoles, ').'.	self assert: (self managerURI isKindOf: String ).	self sendMessage: message to: (self managerURI).! !!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 3/11/2013 08:00'!run: aStatement 	"Execute, simulate, or log the given statement"	( aStatement isKindOf: String )		ifTrue: [ Compiler evaluate: aStatement for: self logged: false.				"No charge in this context."				^self				] .	( aStatement isKindOf: HumStatement ) 		ifTrue: [ "Simulate execution"			"Append to transcript"			Transcript cr; show: 'Actor: ', myID, ' is doing: ', aStatement source; cr.			( aStatement nounValues )				keysAndValuesDo:  [ :noun :value | 					Transcript show: 'with: ', noun, ' = ', value asString ].			"Change to job ticket"				^self chargeTo: (aStatement jobTicket). 			].	( aStatement isKindOf: HumJobTicket )		ifTrue: [ ( self isKindOf: HumResourceManager )						ifTrue: [self sendMessage: aStatement to: (self bookkeeper). 							^self. ].					( self isKindOf: HumBookkeeper )						ifTrue: [ (self jobTickets) add: aStatement.							^self.].				] .	Error signal: 'Statement type not handled.'.! !!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 2/13/2012 10:36'!sendMessage: aMessageObject to: recipientURI.	self checkURI: recipientURI. 	( self messenger ) send: aMessageObject to: recipientURI from: myURI.		! !!HumActor methodsFor: 'logging' stamp: 'RichardAlexanderGreen 4/23/2013 17:28'!chargeTo: aHumJobTicket 	"Compute the charge."	| charge |	charge := HumMeasure quantity: 1 units: #step.	"Append to the job ticket."	aHumJobTicket appendCharge: charge forResource: myID.	"Send to the manager. 	 The manager will call bookkeeper and update Supervisor."	self sendMessage: aHumJobTicket to: (self managerURI).! !!HumActor methodsFor: 'testing' stamp: 'RichardAlexanderGreen 2/13/2012 10:36'!checkURI: aString 	self assert: ( '*URI' matches: aString ).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumActor class	instanceVariableNames: ''!!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/6/2012 17:26'!bookkeeper: myID uri: myURI configuration: aHumConfiguration 	| instance |	instance := HumBookkeeper new.	instance bookkeeper: myID uri: myURI configuration: aHumConfiguration.	^instance. ! !!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/6/2012 20:05'!dialog: myID uri: myURI client: clientURI configuration: aHumConfiguration	| instance |	instance := HumDialogAgent new.	instance  dialog: myID uri: myURI client: clientURI configuration: aHumConfiguration.	^instance.	! !!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/6/2012 17:24'!manager: myID uri: myURI configuration: aHumConfiguration 	| instance |	instance := HumResourceManager new.	instance manager: myID uri: myURI configuration: aHumConfiguration.	^instance. ! !!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/10/2012 16:31'!supervisor: myID uri: myURI goal: aGoalStatementString dialog: aHumDialogAgent configuration: aHumConfiguration 	| instance |	instance := HumSupervisor new.	instance  supervisor: myID 	                              uri: myURI 	                           goal: aGoalStatementString 	                        dialog: aHumDialogAgent 	          configuration: aHumConfiguration .	^instance.! !!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 10/31/2012 10:39'!worker: id uri: aURI messenger: messengerURI manager: managerURI roles: anArray 	| worker |	worker := self basicNew.	worker configuration: ( (HumConfiguration new) messengerURI: messengerURI; yourself).	worker id: id;			messenger: messengerURI;			uri: aURI;			manager: managerURI;			roles: anArray.	^ worker.! !!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/13/2012 08:43'!worker: workerID uri: workerURI roles: arrayOfRoleNames configuration: aHumConfiguration 	| instance |	instance := self basicNew.	instance worker: workerID uri: workerURI roles: arrayOfRoleNames configuration: aHumConfiguration.	^instance.! !HumActor subclass: #HumSupervisor	instanceVariableNames: 'ontology goal context remainingConditions dialogAgent planFrames'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumSupervisor commentStamp: 'RichardAlexanderGreen 9/19/2012 11:43' prior: 0!The supervisor tracks the execution state of a plan.The state includes which conditions are satisfied, which plan frames have been completed, the accumulated resource utilization associated with the execution, and any exceptions that were encounterd or are currently pending resolution.Instance Variables:	ontology	<HumOntology>	goal	<ProtoObject | PseudoContext>	context	<Object>	remainingConditions	<Integer>	dialogAgent	<ProtoObject | PseudoContext>	planFrames	<Collection | PTEnumerable | PragmaCollector>!!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/3/2012 17:33'!context: aHumActor	context := aHumActor.! !!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 10:02'!dialogAgent: aHumDialogAgent 	self assert: ( aHumDialogAgent isKindOf: HumDialogAgent ).	dialogAgent := aHumDialogAgent.! !!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/8/2012 13:36'!goal: aString 	goal := aString.	planFrames := ( self ontology ) collectPlanFramesForGoal: goal.! !!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/8/2012 13:41'!ontology	^ ontology ifNil: [ (self configuration) ontology.].! !!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/3/2012 17:31'!ontology: aHumOntology 	ontology := aHumOntology.! !!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/3/2012 17:35'!remainingConditions	^ remainingConditions ifNil: [ remainingConditions := 0.] .! !!HumSupervisor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 10:01'!supervisor: anID uri: aURI goal: aGoalStatementString dialog: aHumDialogAgent configuration: aHumConfiguration	self configuration: aHumConfiguration.		self id: anID.	self uri: aURI.	self goal: aGoalStatementString.	self dialogAgent: aHumDialogAgent.			^self.	! !!HumSupervisor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 2/13/2012 10:17'!runAction: anInstructionLine 	"Run the given action statement."	Transcript cr; show: 'Actor: ',myID,' is running { ', anInstructionLine source, ' }'; cr.	"After the action is run, the corresponding post-condition is satisfied."	"	REFACTOR -- MORE CONTEXT IS NEEDED TO MAKE THIS POSSIBLE. "	! !!HumSupervisor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 2/10/2012 12:29'!runPlan	"Run my plan.	"	|  aRunnableFrame runnableActionStatements aPostCondition |	self assert: ( context isKindOf: HumDialogAgent ).	"		Additional Preconditions:	. All nouns in the goal statement have values on the dialog agent's' blackboard.	. The frame collection is complete.	. All the roles in the action statements are known (checked-in) to the resource manager.	. All action statements are defined in the ontology.	"	self planIsRunnable ifFalse: [ Error signal: 'Plan is not runnable for goal: ', goal ].	planFrames := ontology collectPlanFramesForGoal: goal.	"Find a plan frame that is ready to run. (All its preconditions are satisfied and it has not already run.)"	aRunnableFrame := planFrames detect: [ :frame | frame isRunnable ].	"Run it's action statements."	runnableActionStatements := aRunnableFrame actionStatements.	runnableActionStatements		do: [ :actionStatement |			actionStatement runInContext: context.			].	"Assert it's post condition."	aPostCondition := aRunnableFrame postCondition.	self conditionIsSatisfied: aPostCondition.	"Needs more work -- to loop until goal is satisfied."	self halt.		! !HumActor subclass: #HumDialogAgent	instanceVariableNames: 'clientURI'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumDialogAgent commentStamp: 'RichardAlexanderGreen 9/19/2012 11:37' prior: 0!A dialog agent provides the interface between a Dialog and a user interface framework.For example, an implementation of a dialog agent could communicate with a user via HTML forms.Another implementation might be designed to communicate via a chat-room interface such as Jabber.We anticipate that some implementations will use virtual-world avatars.Instance Variables:	clientURI	<ProtoObject | PseudoContext>!!HumDialogAgent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/6/2012 20:06'!dialog: myID uri: myURI client: uriClient configuration: aHumConfiguration	actorName := myID.	url := myURI.	clientURI := uriClient.	self configuration: aHumConfiguration.! !!HumDialogAgent methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/26/2012 11:57'!renderView: anEntityID onCanvas: html	"Check generated code by pasting it below"		html form with: [ 		html break. html heading level: 2; with: '!!!! Recipe'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #name toValue: datum ]; value: 'name'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #description toValue: datum ]; value: 'description'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #ingredients toValue: datum ]; value: 'ingredients'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #steps toValue: datum ]; value: 'steps'.		].	! !HumActor subclass: #HumBookkeeper	instanceVariableNames: 'jobTickets'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumBookkeeper commentStamp: 'RichardAlexanderGreen 9/19/2012 11:34' prior: 0!The bookkeeper records resource utilization and expenditure statistics.It provides the basic data needed for cost accounting and system utilization analysis.Instance Variables:	jobTickets	<OrderedCollection>!!HumBookkeeper methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 10:56'!bookkeeper: anID uri: aURI configuration: aHumConfiguration 	configuration := aHumConfiguration.	self id: anID.	self uri: aURI.! !!HumBookkeeper methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 11:02'!jobTickets	^ jobTickets ifNil: [ jobTickets := OrderedCollection new. ].! !Object subclass: #HumEntity	instanceVariableNames: 'title'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/16/2013 10:01'!asString	^title.! !!HumEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/16/2013 10:04'!printOn: aStream	| myClassName |	myClassName := self class name.	aStream nextPutAll: ( myClassName,'(',title,')' ).! !!HumEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/13/2013 08:47'!title	"a display string describing this entity" 	^ title.! !!HumEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/13/2013 08:47'!title: aString	"a display string describing this entity" 	title := aString.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumEntity class	instanceVariableNames: ''!!HumEntity class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/13/2013 08:44'!title: aString	| instance |	instance := self basicNew.	instance title: aString.	^instance.! !HumActor subclass: #HumResourceManager	instanceVariableNames: 'roleActor actorURI'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumResourceManager commentStamp: 'RichardAlexanderGreen 9/19/2012 11:40' prior: 0!The resource manager assigns actors to perform actions.An actor registers itself with a resource manager and identifies the roles that it knows.When a running plan or dialog requires that an action be performed, the resource manager finds an available actor that knows that role (has that capability) and assigns the requested action to that actor.When the actor has completed the role, it becomes available for further assignments.Instance Variables:	roleActor	<Set>	actorURI	<Dictionary>!!HumResourceManager methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:22'!actorURI	^ actorURI ifNil: [ actorURI := Dictionary new. ].! !!HumResourceManager methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:25'!checkInActor: actorID at: aURI withRoles: actorKnowsRoles 	"Remember actor's URI"	(self actorURI ) at: actorID put: aURI.	"For each actor role: 	. Add the actor to those that know that role."	self assert: ( actorKnowsRoles isKindOf: Array ).	actorKnowsRoles do: [ :aRole |		( self roleActor )  add: ( aRole -> actorID )		].		! !!HumResourceManager methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/10/2012 15:09'!messenger	^ ( self configuration ) messenger.! !!HumResourceManager methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/27/2012 14:00'!roleActor	^ roleActor ifNil: [ roleActor := Set new. ].! !!HumResourceManager methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 2/13/2012 10:26'!assignRole: roleString action: actionStatement 	"Assign the given action to an actor advertising the given role."	| actor actorAddress |	self assert: ( roleString isKindOf: String ).	self assert: ( actionStatement isKindOf: HumStatement ).	"Find an actor that knows the role."	( self roleActor ) 		do: [ :map | 			map key = roleString asLowercase  				ifTrue: [ actor := map value. ].			].	"Get the actor's URI."	actorAddress := (self actorURI ) at: actor ifAbsent: [ Error signal: 'No URI for actor?' ].	"Send the action to the actor."	self sendMessage: actionStatement to: actorAddress.		! !Object subclass: #HumWorldBase	instanceVariableNames: 'title quads'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumWorldBase commentStamp: 'RichardAlexanderGreen 2/19/2013 09:29' prior: 0!The world base is a data base for a "world".Typically, a "world" is an enterprise.But, it could be a game or a simulation.A world base is a temporal database.All stored values are versioned.For an entity, each stored attribute has a value and a time-span.The time-span, in turn, has two event-stamps corresponding to the event which populated or updated the value and the event which changed the value.A world base entry is a quad (4-tuple) of pointers:. ( entity, attribute, value, time-span ).Entity Schema:. Entity has attributes.. Attribute has value and time-span.. Time-span has start-event, stop-event.Event Schema:. Event has client, portal, context, date-time.. . . . . . . who . where . . why . . . when (what is the data affected). Client has identifier, client-type, credentials, ongoing-dialog.. Client-type categories include person, robot.. Context has job, ontology, frame, statement.!!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/18/2012 08:11'!getEntityID: entityID attribute: attributeType 	" Get requested value (if any) from the world base instance "	| tau value |	self assert: (entityID isKindOf: String ).	self assert: (attributeType isKindOf: Symbol ).	"Ignore temporal features for now."		value := (self quads ) at: ( entityID -> attributeType ) ifAbsent: [ nil ].	^ value.! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/18/2012 07:37'!quads	^ quads ifNil: [ quads := Dictionary new. ].! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/18/2012 08:05'!setEntityID: entityID attribute: attributeType value: aValue	" Get requested value (if any) from the world base instance "	| tau quad value |	self assert: (entityID isKindOf: String ).	self assert: (attributeType isKindOf: Symbol ).	self assert: ( aValue notNil ).	"Ignore temporal features for now."	"Get value of reqested entity attribute."	(self quads ) at: ( entityID -> attributeType ) put: aValue.! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/12/2012 10:32'!title	^ title ifNil: [ Error signal: 'A world base instance must have a title.'].! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/12/2012 10:34'!title: aWorldBaseName 	self assert: ( aWorldBaseName isKindOf: String ).	title := aWorldBaseName.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumWorldBase class	instanceVariableNames: ''!!HumWorldBase class methodsFor: 'accessing instances and variables' stamp: 'RichardAlexanderGreen 10/12/2012 10:33'!openWorldBase: aWorldBaseName	"Open the world base instance with the given name.	If it does not already exist, create a new instance." 	| instance |	self assert: ( aWorldBaseName isKindOf: String ).	instance := self basicNew.	instance title: aWorldBaseName.	^instance.! !Object subclass: #HumConfiguration	instanceVariableNames: 'messengerURI managerURI bookkeeperURI worldbaseURI ontology messengerProxy'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumConfiguration commentStamp: 'RichardAlexanderGreen 9/20/2012 07:36' prior: 0!A configuration holds the information about how an agent is connected to other agents.Instance Variables:	messengerURI	<URI>	managerURI	<URI>	bookkeeperURI	<URI>	worldbaseURI	<URI>	ontology	<HumOntology>	messengerProxy	<HumBus>!!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 10:42'!bookkeeper	^ bookkeeperURI ifNil: [ Error signal: 'Bookkeeper is missing!!' ].! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/6/2012 19:44'!bookkeeperURI	^ bookkeeperURI! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/6/2012 19:44'!bookkeeperURI: anObject	bookkeeperURI := anObject! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/10/2012 16:10'!managerURI	^ managerURI ifNil: [ Error signal: 'A configuration must have a manager.']! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/6/2012 19:44'!managerURI: anObject	managerURI := anObject! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/31/2012 10:42'!messenger	"FAKE IT."	^ messengerProxy ifNil: [ messengerProxy := HumBus new. ].! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:35'!messenger: uriMessenger manager: uriManager bookkeeper: uriBookkeeper worldbase: uriWorldbase	messengerURI := uriMessenger.	managerURI := uriManager.      bookkeeperURI := uriBookkeeper.       worldbaseURI := uriWorldbase.	"Create the MOCK messenger."	messengerProxy := HumBus new.! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/6/2012 19:44'!messengerURI	^ messengerURI! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 09:33'!messengerURI: aString	messengerURI := aString.	('*URL*' matches: aString) ifTrue: [self halt].	('*URI' matches: aString ) ifFalse: [ Error signal: 'URI is not in expected (MOCK) format.' ].! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/8/2012 13:42'!ontology	^ ontology ifNil: [ Error signal: 'ontology is missing from configuration']! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/8/2012 13:51'!ontology: aHumOntology 	ontology := aHumOntology.! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/6/2012 19:44'!worldbaseURI	^ worldbaseURI! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/6/2012 19:44'!worldbaseURI: anObject	worldbaseURI := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumConfiguration class	instanceVariableNames: ''!!HumConfiguration class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/6/2012 17:15'!messenger: uriMessenger manager: uriManager bookkeeper: uriBookkeeper worldbase: uriWorldbase 	| instance |	instance := self basicNew.	instance messenger: uriMessenger manager: uriManager bookkeeper: uriBookkeeper worldbase: uriWorldbase.	^instance.! !