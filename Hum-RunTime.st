Object subclass: #HumBase	instanceVariableNames: 'entitiesOfType entitiesWithValue entityAttributeValue events'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumBase commentStamp: 'RichardAlexanderGreen 3/26/2015 10:21' prior: 0!HumBase is an code experiment - thinking out loud.Potentially a replacement for HumWorldBase.Instance Variables:	entitiesOfType	<Dictionary>	entitiesWithValue	<Dictionary>	entityAttributeValue	<Dictionary>	events	<Dictionary>!!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2015 11:09'!entityID: anID entityType: aType attribute: anAttribute value: aValue event: anEvent	"Create a record of entity-attribute-value from event."	|  priorValue |		"Add entity to set of that type."	"ASSUMED: The entity does not change type over time."	self insert: anID at: aType into: (self entitiesOfType).		"Add entity to index by value."	"TODO: entitiesWithValue is meant to be current value. We need to remove old entry, if any."	priorValue := self getEntityID: anID attribute: anAttribute. 	priorValue		ifNotNil: [self remove: anID at: { anAttribute. priorValue. } from: ( self entitiesWithValue ).].	self insert: anID at: { anAttribute. aValue. } into: ( self entitiesWithValue ).		"Add record."	self push: { aValue. anEvent. } at: { anID. anAttribute. } onto: ( self entityAttributeValue ).	"( self entityAttributeValue ) at: { anID. anAttribute. } put: { aValue. anEvent. }."	 ! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/10/2015 11:02'!push: anItem at: aKey onto: aDictionaryOfStacks	"Insert the item into a list at the given key."	| listOfEntities  |	"Add entity to list of that type."	listOfEntities := aDictionaryOfStacks  at: aKey ifAbsent: [ Stack new ].	listOfEntities push: anItem.	aDictionaryOfStacks at: aKey put: listOfEntities.! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2015 10:32'!insert: anItem at: aKey into: aDictionaryOfSets	"Insert the item into a set at the given key."	| setOfEntities  |	"Add entity to set associated with that key."	setOfEntities := aDictionaryOfSets  at: aKey ifAbsent: [ Set new ].	setOfEntities add: anItem.	aDictionaryOfSets at: aKey put: setOfEntities.! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2015 11:06'!remove: anEntityID at: aKey from: aDictionaryOfSets 	"Remove the entityID from the set associated with the key."	| set |	set := aDictionaryOfSets at: aKey ifAbsent: [^self].	set remove: anEntityID ifAbsent: [^self].! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2015 09:42'!findEntitiesOfType: anEntityType 	| setOfEntities |	setOfEntities := (self entitiesOfType) at: anEntityType ifAbsent: [ Set new ].	^setOfEntities.! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2015 10:33'!entitiesWithValue	"A dictionary of sets. The set of entities with the given { attribute value }."	^ entitiesWithValue ifNil: [ entitiesWithValue := Dictionary new].! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/19/2016 10:06'!eventWho: aWho what: aWhat where: aWhere why: aWhy 	| stamp yyyy mo day hh mm ss nn when eventID event |	stamp := DateAndTime current.	yyyy := stamp year.	mo   := stamp month.	day  := stamp dayOfMonth.	hh   := stamp hour.	mm   := stamp minute.	ss   := stamp seconds.	nn   := stamp asNanoSeconds // 1000. "??? apparent precision is microseconds in MacOS"	when := yyyy.	{ mo. day. hh. mm. ss. } do: [ :x | when := (when * 100) + x ].	when := (when * 1e6) + ( nn \\ 1e6 ).		"when := yyyy*1e4+mo*1e2+day*1e2+hh*1e2+mm*1e2+ss*1e12+nn."	..	eventID := when.	event := { when. aWho. aWhat. aWhere. aWhy. }.	(self events) at: eventID put: event.	^eventID.	! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/10/2015 11:05'!getEntityID: anEntityID attribute: anAttributeType 	"Get the current value for given entityID attributeType"	| result tuple stack |	stack := ( self entityAttributeValue ) at: { anEntityID. anAttributeType } ifAbsent: [ ^nil ].	tuple := stack top.	result := tuple at: 1. 	^result.! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2015 10:29'!entityAttributeValue	"A dictionary holding a temporal stack of {value event} for each {entity attribute}.	 The top of the stack has the current {value event}."	^ entityAttributeValue ifNil: [ entityAttributeValue := Dictionary new ].! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2015 09:42'!findEntitiesWhereAttribute: anAttributeType satisfies: aBlockClosure 	"Get collections of entities where current attribute value satisfies condition"	| setOfEntities |	setOfEntities := Set new.	( self entityAttributeValue )		keysAndValuesDo: [ :k :v |			| entityID attributeType attributeValue stack tuple |			entityID       := k at: 1.			attributeType  := k at: 2.			stack := v. 			tuple := stack top.			attributeValue := tuple at: 1.			( attributeType = anAttributeType )				ifTrue: [ 					( aBlockClosure value: attributeValue ) 						ifTrue: [ setOfEntities add: entityID ]					]			].	^setOfEntities.	! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/9/2015 08:49'!entitiesOfType	^ entitiesOfType ifNil: [ entitiesOfType := Dictionary new ].! !!HumBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/10/2015 09:48'!events	^ events ifNil: [ events := Dictionary new].! !Object subclass: #HumBlackBoard	instanceVariableNames: 'quads worldbase worldbaseID defaultEntity entityIdentifiers businessEvent'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumBlackBoard commentStamp: 'RichardAlexanderGreen 4/20/2014 15:50' prior: 0!The blackboard holds the values for nouns in memory that are currently being referenced by an agent.In addition, the blackboard operates the persistence mechanism so that new noun values are recorded on the world-base (database). TODO: Deal with attributes that are collections (bag, set, list).- The items in a collection are entities. (They are identifiable and countable.)- That implies that they have identifiers.- The collection itself has an identifier.- Let a collection attribute be a Hum datatype. . . Then it supports the Hum equivlalent of add: item, remove: item, do: [:item| ...], asStream. . . A Hum list also supports append: item, prepend: item, first, last.. . Updating a collection is handled the same as updating other datatypes.. . The difference will be that the entities in the collection must also be on the blackboard.. . And, the collections only contain identifiers.!!HumBlackBoard methodsFor: 'private' stamp: 'RichardAlexanderGreen 7/24/2013 11:01'!worldbase	^ worldbase ifNil: [Error signal: 'Blackboard configured without a world base.']! !!HumBlackBoard methodsFor: 'private' stamp: 'RichardAlexanderGreen 3/26/2015 15:19'!quads	"a dictionary of { aValue. tau. } keyed by ( entityID -> attribute )"	^ quads ifNil: [ quads := Dictionary new. ].! !!HumBlackBoard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/26/2015 15:27'!businessEvent	"What business event is in progress?"	^businessEvent ifNil: [Error signal: 'event not set']! !!HumBlackBoard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/6/2014 14:38'!identifierForEntityName: anEntityName 	"Do I already have an entity of that name? 	 If so, assign the same ID. Otherwise, get a new identifier."	| id entity | 	entity := self cleanEntity: anEntityName.	id := (self entityIdentifiers) at: entity 	     ifAbsent: [ entityIdentifiers at: entity put: (self generateNewIdentifierForEntityName: entity). ].	^id.! !!HumBlackBoard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2015 09:30'!generateNewIdentifierForEntityName: anEntityName	"Create a unique identifier for an instance of the given entity-name noun."	| id entity |	entity := self cleanEntity: anEntityName.	id := HumIdentifier createUniqueIdentifierForEntityName: entity inContext: (self businessEvent).	^id.! !!HumBlackBoard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/22/2015 10:56'!worldbase: aHumWorldBase 	self assert: ((aHumWorldBase isKindOf: HumWorldBase) or: [aHumWorldBase = 'none']).	worldbase := aHumWorldBase! !!HumBlackBoard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/29/2015 10:23'!getEntityName: anEntityName attribute: anAttributeName 	"Get the entityID for that entity-name and fetch the requested attribute."	| value entityName entityID attributeName  |	entityName := self cleanEntity: anEntityName.	attributeName := self cleanAttribute: anAttributeName.		entityID := self identifierForEntityName: entityName.	value := self getEntityID: entityID attribute: attributeName.	^value.! !!HumBlackBoard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/10/2014 09:54'!setEntityName: anEntityName attribute: anAttributeName toValue: aValue	"for now -- same as:"	| entityID entityName attributeName |  entityName := self cleanEntity: anEntityName.  attributeName := self cleanAttribute: anAttributeName.	"Do I already have an entity of that name? 	 If so, assign the same ID. Otherwise, get a new identifier."	entityID := self identifierForEntityName: entityName.		( anAttributeName sameAs: aValue asString   )		ifTrue: ["When the value matches the attribute name, the value references an entity."			| referencedEntityID |			referencedEntityID := self identifierForEntityName: anAttributeName.			self setEntityID: entityID attribute: attributeName toValue: referencedEntityID.			^self.			].		self setEntityID: entityID attribute: attributeName toValue: aValue.		! !!HumBlackBoard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/6/2014 14:44'!appendEntity: childEntityID toEntity: parentEntityID list: anAttributeName 	"Append the given child entity to the named list attribute"	| list attribute |	self assert: ( childEntityID isKindOf: HumIdentifier ).		self assert: ( parentEntityID isKindOf: HumIdentifier ).	self assert: ( anAttributeName isKindOf: String ).	attribute := self cleanAttribute: anAttributeName.	list := self getEntityID: parentEntityID attribute: attribute.	( list isKindOf: OrderedCollection )		ifFalse: [ list := OrderedCollection new].	list addLast: childEntityID.	self setEntityID: parentEntityID attribute: attribute toValue: list.! !!HumBlackBoard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/8/2016 08:50'!setEntityID: entityID attribute: anAttributeName toValue: aValue	"Store given value in the blackboard with a time-stamp. 	 *** Side Effect: Notify the World Base. ***"	| tau  attributeName |	self assert: ( entityID isKindOf: HumIdentifier ).	attributeName := self cleanAttribute: anAttributeName.			"Put value of entity attribute and the timestamp."	tau := (self businessEvent hash). "TODO: Relate this to a business event."	( self quads ) at: ( entityID -> attributeName ) put: { aValue. tau. }.		"Update the world base also."	( self worldbase isKindOf: String ) 				ifTrue: [ "Replace string with a worldbase instance."						(worldbase = 'none') ifTrue: ["This blackboard does not persist data immediately." ^self].						self worldbase: (HumWorldBase openWorldBase: worldbase).						].					 	self assert: (self worldbase isKindOf: HumWorldBase ).	( self worldbase ) setEntityID: entityID attribute: attributeName toValue: aValue.		"NOTE: Mutation in the world-base is treated via versioning."	"TODO: Blackboard detects mutations ? -- And then what?"	"TODO: Code critic flags mutation as Error?"	"COMMENT: Mutation in a business-entity is mainly a danger when a natural-key is mutated."! !!HumBlackBoard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/4/2015 09:35'!entityIdentifiers	"What identifier is associated with a entity type noun (entity name)?"	^ entityIdentifiers ifNil: [entityIdentifiers := Dictionary new].! !!HumBlackBoard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/29/2015 10:26'!getEntityID: entityID attribute: anAttributeName 	" Get requested value (if any) from the blackboard instance "	| valueAndTau value tau attribute |	self assert: (entityID isKindOf: HumIdentifier ).	attribute := self cleanAttribute: anAttributeName.		valueAndTau := ( self quads ) at: ( entityID -> attribute ) ifAbsent: [ ^nil ].	"ToDo: If I don't have it, maybe WorldBase does. "	"TODO: If the entity-attribute-value is updated in the worldbase, are the Blackboards notified?  If so, how?"	value := valueAndTau at: 1.	tau := valueAndTau at: 2.	self assert: (tau notNil).	^ value.! !!HumBlackBoard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/8/2016 08:22'!cleanEntity: anEntityTypeString 	"Assure that the type-name is properly-trimmed, lowercase string"	| result |	anEntityTypeString ifNil: [ Error signal: 'Why was entity-type nil?']. 	result := anEntityTypeString trimBoth asLowercase.	[result endsWith: '.'] whileTrue: [ result := result copyFrom: 1 to: (result size - 1)].	self assert: (result isKindOf: String).	^result.! !!HumBlackBoard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/26/2015 15:21'!updateBlackBoardFromBlackBoard: aHumBlackBoard 	"Update myself from entries in the other blackboard."	| otherQuads |	Error signal: 'I don`t expect this to be used in current coding environment.'.	"Assume that caller is not sharing this blackboard."	self assert: (aHumBlackBoard == self ) not.	"Interpret caller quads"	otherQuads := aHumBlackBoard quads.	self assert: ( otherQuads isKindOf: Dictionary ).	otherQuads 			keysAndValuesDo: [ :key :value |				| entityID entityName attributeType newValue  |				"Parse dictionary key - it is a map of the form: (entitID -> attributeType)"				entityID := key key.				attributeType := key value.				self assert: ( entityID isKindOf: HumIdentifier ).				entityName := entityID entityName.				"Parse dictionary value - It is a tuple of the form: { value. tau. }"				newValue := value at: 1.				"tau := value at: 2."				"Update myself -- Note: I will generate my own tau."				self entityIdentifiers at: entityName put: entityID.				self setEntityID: entityID attribute: attributeType toValue: newValue.				]	! !!HumBlackBoard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/28/2015 10:59'!cleanAttribute: anAttributeNameString 	| result |	result := ((anAttributeNameString isKindOf: String ) 	                              ifTrue: [ anAttributeNameString ] 	                             ifFalse: [ Error signal: 'Sent blackboard non-string value?'.		                                      anAttributeNameString asString. ]) trimBoth asLowercase.	^result.! !!HumBlackBoard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/28/2015 13:45'!businessEvent: aString	"What business event is in progress?"	"TODO: We need a stronger (W5) business-event representation."	"TODO: Create a Business Event class with W5 (who, what, when, where, why) attributes."	^businessEvent := aString! !!HumBlackBoard methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 6/8/2016 08:45'!makeEntityOfType: anEntityType 	"Add a new entity ID for the given entity type. (entity name)."	| entityIdentifier entity |	"Generally invoked via 'New entityType.' in a dialog vignette. "	entity := self cleanEntity: anEntityType.	entityIdentifier := self generateNewIdentifierForEntityName: entity.	"NOTE: If dialog blackboard already contains an entity of this type, it is no longer accessable."	(self entityIdentifiers) at: entity put: entityIdentifier.	! !!HumBlackBoard methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 6/8/2016 08:37'!clearEntity: anEntityType 	"Clear all data for the given entity-name / entity-type."	| quadsToBe cleanName |	"REFACTOR/RETHINK: The BlackBoard seems to be built for single instances of an entity-type."	"TODO: Think about the interaction between business roles, views, and persistence."	"Hum`s general rule is 'Persist everthing, then add purge rules.'"	"REFACTOR/RETHINK: The WorldBase should check for valid ID (defensive code). "		Error signal: 'Why are we doing this?'.  "TODO: Why would we do this? -- Original test case (ClubMechV02.txt) was for a NEW entity."	"Why? - Because an long-running dialog may have already created an entity of this type,	        but a new vignette is creating another entity of this type."		cleanName := self cleanEntity: anEntityType.	"(cleanName = 'topic') ifTrue: [self halt.]."		(self entityIdentifiers) removeKey: cleanName ifAbsent: ["Okay."]. 	quadsToBe := Dictionary new.	quads		keysAndValuesDo: [ :key :value |			| association entityLabel |			association := key.			entityLabel := HumCalculator given: (association key asString) extractUpto: ':'.			(entityLabel sameAs: cleanName)				ifFalse: [ quadsToBe at: key put: value ].			].	"At this point, quadsToBe has no data associated with the entity-type."	quads := quadsToBe.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumBlackBoard class	instanceVariableNames: ''!!HumBlackBoard class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/1/2014 16:08'!worldbase: aString 	| instance |	instance := self basicNew.	instance worldbase: aString.	^instance.! !Object subclass: #HumCalculator	instanceVariableNames: 'priorCaseIsTrue indentString testValue priorIndent'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumCalculator commentStamp: 'RichardAlexanderGreen 8/16/2013 14:07' prior: 0!The Calculator role (agent) provides - base level arithmetic (using measures)- string utilities used to parse Hum source code.The Calculator provides compute operations.When a Hum procedure (or Hum Run-Time) needs an interface to the host computer, the Calculator provides it.See also: HumMeasure. -- In the Hum framework, all numbers are measures.See also: HumFuzzy.-- HumFuzzy provides arithmetic on S-curve distributions.TODO: Integrate HumMeasure and HumCalculator.!!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 8/1/2016 09:55'!exdent	"Remove a tab from the global indent string."	indentString := priorIndent ifNil: [ Error signal: 'priorIndent not set' ].	! !!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 8/1/2016 09:56'!indent	"Append a tab to the global indent string."	priorIndent := indentString ifNil: [''].	indentString := indentString, String tab.	! !!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 7/6/2015 11:18'!xmlOpen: aTagString dictionary: aDictionary 	"Create an opening tag ( NOT ending with '/>' ) with the given attribute values."	| xml space equals quote |	self assert: ( aDictionary isKindOf: Dictionary ).	space := String space.	equals := '='.	quote := $" asString.
  "Do no mess with indent here. Caller should handle."	xml := '<', aTagString.	aDictionary keysSortedSafely 		do: [ :key  |			| value |			value := aDictionary at: key. 			value ifNil: [  Error signal: 'Nil passed where xml attribute was expected.'].			xml := xml, space,  key, equals, quote,  value, quote.			].		xml := xml, ' >', String cr.	^xml.! !!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 8/1/2016 11:09'!xml: aTagString dictionary: aDictionary with: aBlockClosure 	"Generate the front tag and the end tag with block to produce the middle"	| frontTag xml cr dictionary |	dictionary := aDictionary asDictionary.	cr := String cr.	self indent.	frontTag :=  self xmlOpen: aTagString dictionary: dictionary.	xml := indentString, frontTag, cr, 	       indentString, ( aBlockClosure value ), cr,			   indentString, '</', aTagString, '>', cr.	"Restore prior indent"	self exdent.	^xml.! !!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 8/1/2016 08:43'!xml: aTagString dictionary: aDictionaryOrList 	"Create a stand-alone tag (ending with '/>') with the given attribute values."	| xml space equals quote dictionary |	dictionary := aDictionaryOrList asDictionary.  space := String space.	equals := '='.	quote := $" asString.	"Don not mess with indent here. Caller should handle."	xml := '<', aTagString.	dictionary keysSortedSafely 		do: [ :key  |			| value |			value := dictionary at: key. 			xml := xml, space, key asString, equals, quote, value asString, quote.			].	xml := xml, ' />', String cr.	^xml.! !!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 8/1/2016 09:53'!xml: aTag with: aBlock 	"Fix up the indent after we get this working."	| xml cr  insert |	insert := aBlock value.	self assert: ( insert isKindOf: String ).	cr := String cr.	self indent.	xml  := indentString,'<', aTag, '>', cr			 , indentString, insert, cr			 , indentString, '</', aTag, '>', cr.	"Restore prior indent."	self exdent.	^xml.! !!HumCalculator methodsFor: 'xml' stamp: 'RichardAlexanderGreen 8/1/2016 11:12'!xml: tagString list: anArray 	"Iterate: Enclose each item with given tagString"	| result |	self indent.	result := String new.	anArray 		do: [ :each | |s|			s := '<',tagString,'>',each,'</',tagString,'>'.			result := result, String cr, indentString, s.			].	self exdent.	^result.! !!HumCalculator methodsFor: 'case statement cascade' stamp: 'RichardAlexanderGreen 5/19/2015 08:03'!on: aValue do: aBlockClosure 	( testValue = aValue ) 		ifTrue: [ priorCaseIsTrue := true. 			aBlockClosure value ].! !!HumCalculator methodsFor: 'case statement cascade' stamp: 'RichardAlexanderGreen 5/19/2014 16:13'!priorCaseIsTrue	^ priorCaseIsTrue ifNil: [priorCaseIsTrue := false ].! !!HumCalculator methodsFor: 'case statement cascade' stamp: 'RichardAlexanderGreen 3/26/2014 16:57'!when: whenBlock then: thenBlock	"If the whenBlock evaluated to true, execute the thenBlock."	| |	"If a prior case was true, ignore this case."		( self priorCaseIsTrue ) ifTrue: [ ^self ].	"If the when block is true"	( whenBlock value ) 		ifTrue: [ 			priorCaseIsTrue := true. 			thenBlock value ].	^self.	! !!HumCalculator methodsFor: 'case statement cascade' stamp: 'RichardAlexanderGreen 5/13/2014 08:55'!otherwise: thenBlock	"If a prior case was true, ignore this case. 	 Otherwise, execute this block."		( self priorCaseIsTrue ) ifTrue: [ ^self ].	"otherwise"	thenBlock value.	^self.	! !!HumCalculator methodsFor: 'case statement cascade' stamp: 'RichardAlexanderGreen 10/14/2014 15:56'!cases	"Initialize case cascade.	Usage:	calculator cases;		 when: [ block returning boolean] then: [ some action];		 when: [ block returning boolean] then: [ some action];		 otherwise: [ action if all the when-blocks are false ].	See also:		object caseOf: {value->block. value->block.} otherwise: [action if no value matches]		"	priorCaseIsTrue := false.	! !!HumCalculator methodsFor: 'case statement cascade' stamp: 'RichardAlexanderGreen 5/19/2015 07:54'!testValue: anObject 	testValue := anObject! !!HumCalculator methodsFor: 'case statement cascade' stamp: 'RichardAlexanderGreen 5/19/2015 07:53'!switch: aCharacter 	self testValue: aCharacter.! !!HumCalculator methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 1/6/2015 10:10'!doTokensIn: input at: xInput matchPatternTokensIn: pattern at: xPattern	| result |	result := self class doTokensIn: input at: xInput matchPatternTokensIn: pattern at: xPattern.	^result.! !!HumCalculator methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 4/27/2015 10:03'!parse: aString	"Parse into { token. type. start. stop. }"	| sequence |	sequence := self class parse: aString.	^sequence.			! !!HumCalculator methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/4/2014 12:49'!scoreCandidate: candidateString againstPattern: patternString	"Return a score indicating the number of tokens that match." 	| candidateTokens patternTokens commonTokens |	self assert: (candidateString isKindOf: String).	self assert: (patternString isKindOf: String).		"Parse."	candidateTokens := HumCalculator justTheWordsIn: candidateString.	patternTokens := HumCalculator justTheWordsIn: patternString.	commonTokens := candidateTokens intersection: patternTokens.	^commonTokens size.		! !!HumCalculator methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/4/2014 12:48'!justTheWordsIn: aString	^self class justTheWordsIn: aString.! !!HumCalculator methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 3/1/2014 10:10'!given: input extractAfterSecond: marker 	"Parse cases like matching quotes or markup emphasis."	| wip result |	wip := self given: input extractAfter: marker.	result := self given: wip extractAfter: marker.	^result.! !!HumCalculator methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 10/13/2016 10:09'!fillTemplate: template fromDictionary: dictionary	"Create a String based on the given template and parameters."	| result |	result := template.	[ result includesSubString: '@']		whileTrue: ["Replace the first parameter with its value"			| front back name value delimiters |				front := self given: result extractUpto: '@'.			back := self given: result extractAfter: '@'.			"Get and remove the name of the parameter"			delimiters := '					 ~!!@#$%^&*()_+`-=[]\{}|:";<>?,./'''.			name := (back substrings: delimiters ) at: 1.			"Insert the value of the parameter"			value := dictionary at: name.			self assert: (value isKindOf: String ).			back := self given: back extractAfter: name.			result := front, value, back.			].	^result.! !!HumCalculator methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 9/12/2016 10:38'!given: s topic: aTopic doOnce: aBlock	"Use this to produce subheadings."	(s = (self topicDictionary at: aTopic ifAbsent: '') ) 		ifFalse: [ aBlock value: aTopic value: s.			self topicDictionary at: aTopic put: aTopic.			].	! !!HumCalculator methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 9/12/2016 10:39'!indentLevel: n 	"Reset the indent level. Produce indent string (tabs)."	self assert: (n isKindOf: Integer ).	indentString := String new.	(1 to: n) do: [:i | indentString := indentString, String tab.].! !!HumCalculator methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 12/12/2014 20:44'!string: stringA isLike: stringB 	"Compare ignoring differences in whitespace."	^self class string: stringA isLike: stringB. ! !!HumCalculator methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 6/13/2014 08:50'!given: sourceString extractBetween: stringA and: stringB	"Return the substring in the sourceString between the two."	| result |	result := HumCalculator given: sourceString extractBetween: stringA and: stringB.	^result.! !!HumCalculator methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 3/25/2015 09:35'!given: input replaceAll: old with: new 	|result|	result := self class given: input replaceAll: old with: new.	^result. ! !!HumCalculator methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 6/13/2014 08:46'!given: sourceString extractUpto: stringA 	"Return the substring in the sourceString between the two."	|   result |	result := HumCalculator given: sourceString extractUpto: stringA.	^result.! !!HumCalculator methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 6/13/2014 08:44'!given: sourceString extractAfter: stringA 	"Return the substring in the sourceString between the two."	| result |	result := HumCalculator given: sourceString extractAfter: stringA.	^result.! !!HumCalculator methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 1/12/2015 09:26'!given: inputString onMatch: aPatternString do: aBlockClosure 	"When the inputString matches pattern, execute the block with matching arguments.	 Use this to parse lines, interpret lines, generate code."	self class given: inputString onMatch: aPatternString do: aBlockClosure ! !!HumCalculator methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 5/27/2015 10:37'!string: aString isLike: aString2 ignore: aString3 	^self class string: aString isLike: aString2 ignore: aString3.! !!HumCalculator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/28/2014 10:31'!initialize	indentString := String new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumCalculator class	instanceVariableNames: ''!!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 1/1/2014 09:25'!writeString: aString toFileNamed: aFileName	"Write the given string to given file - overwrite the previous content."	| file |	file := StandardFileStream forceNewFileNamed: aFileName. 	file nextPutAll: aString.	file close.! !!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 4/28/2015 09:30'!diffCandidate: stringA againstIdeal: stringB showing: nTokens	"Find the first token that is different, ignoring differences in whitespace.	Show nTokens on each side of first difference to provide context.	"	| tokensA tokensB whitespace i tokenA diffA diffB |	whitespace := Character separators.	tokensA := stringA findTokens: whitespace "keep: whitespace".	tokensB := stringB findTokens: whitespace "keep: whitespace".		"Drive with the ideal string."	i := 1.	tokensB detect: [ :tokenB |		tokenA := tokensA at: i.		i := i + 1.		( tokenA sameAs: tokenB ) not.		]		ifNone: [^'no difference'].		"Come here with i set to place where first difference is seen."	diffA := ''.	(tokensA copyFrom: (i-nTokens max: 1) to: (i+nTokens min: (tokensA size))) 		do: [:token | diffA := diffA, token, ' ' ].		diffB := ''.	(tokensB copyFrom: (i-nTokens max: 1) to: (i+nTokens min: (tokensB size))) 		do: [:token | diffB := diffB, token, ' ' ].		HumTestCase new expect: diffB actual: diffA.		! !!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 5/27/2015 10:38'!string: stringA isLike: stringB 	"Compare ignoring differences in whitespace."	| result |	result := self string: stringA isLike: stringB ignore: (Character separators).	^result.! !!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 6/13/2014 20:22'!given: stringIn extractBetween: stringA and: stringB	"Get the substring that is between A and B."	| temp result |  temp := HumCalculator given: stringIn extractAfter: stringA.	result := HumCalculator given: temp extractUpto: stringB.	^result.! !!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 6/1/2015 09:16'!justTheWordsIn: aString	"Return just the words.	Simplify an English string by removing the words 'the', 'a', 'an'.	Also, remove puncturation.	Note: Returns lowercase tokens.	"	| tokens words delimiters whiteSpace |	whiteSpace := String space, String tab, String cr.	delimiters := whiteSpace, '~!!@#$%^&*()_+`={}|[]\:";<>?,./', ($' asString).	tokens := (aString asLowercase) findTokens: delimiters.	"Filter out 'the' 'a' 'an' 	(punctuation is already filtered by findTokens)"	words := OrderedCollection new.	tokens		do: [:token |			| skipWord |			skipWord := false.			skipWord := (token = 'the') | (token = 'a') | (token = 'an'). 			skipWord				ifFalse: [ words add: token ].			].	^ words.! !!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 6/13/2014 20:26'!given: aString extractIncludingMatching: pairString	"Return substring between balanced pair -- or nil if there is no such pattern.	s = 'this is before [[blah]] this is after'.	self assert: ( HumCalculator given: s betweenMatching: '[]' ) = '[[blah]]'.	 "	| startPos pos nestLevel pairStart pairStop |	pairStart := pairString at: 1.	pairStop  := pairString at: 2.	self assert: (pairStart isKindOf: Character ).	self assert: (pairStop isKindOf: Character ).	"Find the start of the substring."	startPos := aString indexOf: pairStart.	"TODO: If there is no starting character, what should we return?"	(startPos > 0 ) 		ifFalse: [ ^nil ].	"Following assumes we have found the starting position."	self assert: startPos > 0.	pos := startPos + 1.	nestLevel := 1.	[ pos <= aString size ] whileTrue: [		| aCharacter |		aCharacter := aString at: pos.		( aCharacter = pairStart ) 			ifTrue: [ nestLevel := nestLevel + 1 ].		( aCharacter = pairStop )  			ifTrue: [ nestLevel := nestLevel - 1 ].		(nestLevel = 0) 			ifTrue: [ |result| result := ( aString copyFrom:startPos to: pos ). ^result. ].		pos := pos + 1.	].	"If we come here, the matching closing character is missing."	Error signal: 'String does not contain a balanced pair: ', pairString.	^nil.! !!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 4/20/2015 08:17'!given: input replaceAll: old with: new 	| s before after|	s := input.	[ ('*',old,'*') match: s ]		whileTrue: ["Replace old with new"			before := self given: s extractUpto: old.			after  := self given: s extractAfter: old.			s := before,new,after.			].	^s.! !!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 6/13/2014 08:44'!given: stringIn extractAfter: stringA 	"Get the substring that is between the two given."	| x1 stringOut s |	s := stringIn.	stringOut := ''.	x1 := s findString: stringA startingAt: 1.	(x1 > 0 ) 		ifTrue: [ stringOut := stringIn copyFrom: (x1 + stringA size) to: (stringIn size). 			 ].	^stringOut.! !!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 2/23/2015 19:35'!given: stringIn extractUpto: stringA 	"Get the substring that is between the two given."	| x1 stringOut s |	self assert: (stringA isKindOf: String).	self assert: (stringIn isKindOf: String).	s := stringIn.	stringOut := ''.	x1 := s findString: stringA startingAt: 1.	(x1 > 0 ) ifTrue: [ stringOut := stringIn copyFrom: 1 to: (x1-1).  ].	^stringOut.! !!HumCalculator class methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 9/12/2016 10:42'!string: stringA isLike: stringB ignore: charactersToIgnore	"Compare ignoring differences in whitespace."	| result compactA compactB|	compactA := stringA asLowercase  reject: [:ch | (charactersToIgnore includes: ch ) ].	compactB := stringB asLowercase  reject: [:ch | (charactersToIgnore includes: ch ) ].	result := compactA sameAs: compactB.	^result.! !!HumCalculator class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 6/1/2015 08:55'!camelCase: aString 	| words result |	result := String new.	words := self justTheWordsIn: aString.	words do: [ :word | result := result, word capitalized. ].	^result.! !!HumCalculator class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 4/27/2015 10:02'!parse: aString	"Parse into { token. type. start. stop. }"	| sequence |	sequence := OrderedCollection new.	self parse: aString startingAt: 1 appendTokenTo: sequence.	^sequence.	! !!HumCalculator class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 4/27/2015 10:02'!parse: aString startingAt: start appendTokenTo: sequence	"Parse into { token. type. start. stop. }"	|  whitespace separators quotes quote doubleQuote isWhiteSpace isSeparator tests type isQuote priorQuote alphabet isAlphabet isQuotedText mode currentCharacter stop lex |	self assert: (sequence isKindOf: OrderedCollection).	self assert: (start > 0).	"Terminate if start is greater than aString."	(start > aString size) ifTrue: [^self].	"Set up terminal token definitions."	whitespace := ' 			'.	quote := ($' asString).	doubleQuote := ($" asString).	quotes := quote, doubleQuote.	priorQuote := quote.	separators := '~!!@#$%^&*()_+`={}|[]\:;<>?,./'.	alphabet := 'qwertyuiopasdfghjklzxcvbnm1234567890-'.		"Side-effect sets type in detect:[]"	isWhiteSpace := [ :ch | type := #whitespace. whitespace includes: ch ].	isSeparator  := [ :ch | type := #separator.  separators includes: ch ].	isAlphabet   := [ :ch | type := #word.       alphabet includes: (ch asLowercase)].	isQuote      := [ :ch | type := #quote.      quotes includes: ch ].	isQuotedText := [ :ch | type := #string.    ( priorQuote = ch ) not ].				tests := { isWhiteSpace. isSeparator. isAlphabet. isQuote. isQuotedText. }.	"mode is determined by the starting character"	currentCharacter := aString at: start.	mode := tests detect: [ :test | test value: currentCharacter.].	( type = #quote ) 		ifTrue: [ mode := isQuotedText. priorQuote := currentCharacter. ].	"The next lex is string starting with current character that matches mode test."	(start = aString size) 		ifTrue:  [stop := start ]		ifFalse: [ |x|			x := ( (start+1) to: (aString size) ) 								detect: [ :iCharacter | (mode value: (aString at: iCharacter)) not ].			(mode = isQuotedText) ifTrue: [ stop := x ] ifFalse: [ stop := x - 1 ].			 			].	lex := aString copyFrom: start to: stop .	sequence add: { lex. type. start. stop. }.	"Call self recursively"	self parse: aString startingAt: (stop + 1) appendTokenTo: sequence.	! !!HumCalculator class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 1/8/2015 09:16'!doesString: aString matchPattern: aPattern	"Match the string against the pattern, return true/false"	| inputTokens patternTokens result |	inputTokens := self findTokensInString: aString.	patternTokens := self findTokensInString: aPattern.	result := self doTokensIn: inputTokens at: 1 matchPatternTokensIn: patternTokens at: 1.	^result.! !!HumCalculator class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 1/6/2015 10:08'!doTokensIn: input at: xInput matchPatternTokensIn: pattern at: xPattern	"See if we can get any matching sequence."	| pToken atParameter isMatch |	isMatch := false.	"If we run out of pattern, we have succeeded."	( xPattern > (pattern size) ) ifTrue: [ ^true ].	"If we run out self before we run out of pattern, we have failed."	( xInput > ( input size ) ) ifTrue: [^false].	"A pattern token that is a digit will match anything. 	 Proceed to next token in both lists.	 But if there is no match there, the pattern token could still match the next self token, so try that.	"	pToken := pattern at: xPattern.	atParameter := ( ( ( pToken size = 1) and: [ pToken isAllDigits ] ) ).	atParameter			ifTrue: [ isMatch := (self doTokensIn: input at: (xInput + 1) matchPatternTokensIn: pattern at: (xPattern + 1))								   or: [self doTokensIn: input at: (xInput + 1) matchPatternTokensIn: pattern at: (xPattern + 0 ) ].						^isMatch. 					].	"Remainder assumes that current pattern token is NOT a digit."					self assert: (  atParameter not  ).	"If the current pattern token matches the current self token, proceed to the next token in both lists."	( ( pattern at: xPattern ) sameAs: ( input at: xInput ) )			ifTrue: [ "Proceed to next token in both lists"						isMatch := self doTokensIn: input at: (xInput + 1) matchPatternTokensIn: pattern at: (xPattern + 1).					    ^isMatch 					]			ifFalse: [ "See if the next token in self matches the pattern token"						isMatch := self doTokensIn: input at: (xInput + 1) matchPatternTokensIn: pattern at: (xPattern + 0).						^isMatch. ].			"At this point we have a mismatch for sure. (I think maybe.)"	isMatch := false.				^isMatch.! !!HumCalculator class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 4/27/2015 12:07'!findTokensAndConstantsInString: aString	"CODE EXPERIMENT - Where a string-delimiter is seen, consolidate quoted-string into a single token.	See also: HumCalculatorTests>>test310parse"	| tokenList resultingTokens mode doubleQuote calc whitespace singleQuote quoteDelimiter punctuation |	"TODO: TEST as is."	"TODO: Parse statements containing numbers for measurements, money, counts."	"CONVENTION: measurement := number, space, unit-of-measure."	"CONVENTION: count := number, space, plural-noun."	"TODO: Decide if language should include proper nouns (i.e. names) (as a type or kind of constant)."	resultingTokens := OrderedCollection new.	calc := self new.	doubleQuote := $" asString.	singleQuote := $' asString.	quoteDelimiter := singleQuote.	whitespace := Character separators.	punctuation := '~!!@#$%^&*()_+`={}|[]\:";<>?,./', singleQuote.	mode := #normal.	tokenList := aString  findTokens: ( punctuation, whitespace ) keep: (punctuation, whitespace).	tokenList do: [ :tokenIn |		| tokenOut |		calc cases;			when: [ mode = #normal and: [tokenIn = quoteDelimiter ] ] 				then: [ mode := #string. tokenOut := quoteDelimiter. ];			when: [ mode = #string and: [tokenIn = quoteDelimiter ] ] 				then: [ mode := #normal. tokenOut := tokenOut, quoteDelimiter. resultingTokens add: tokenOut ];			when: [ mode = #string ] 				then: [ tokenOut := tokenOut, tokenIn ];			when: [ mode = #normal ] 				then: [ resultingTokens add: tokenIn ];			otherwise: [  Error signal: 'Logic error'. ].		 ].	( mode = #string ) ifTrue: [ Error signal: 'String started but not terminated.' ].	"WARNING: resultingTokens may include whitespace."	^resultingTokens.! !!HumCalculator class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 1/7/2016 09:22'!findTokensInString: aString	"Parse the given string to return lexical units (words and punctuation).	Note: Upper Case is preserved."	| whitespace quote punctuation tokens apostrophe |	whitespace := ' 			'.	quote := $' asString.	apostrophe := $` asString.	punctuation := '~!!@#$%^&*()_+={}|[]\:";<>?,./', quote. ", apostrophe."	"Note: Hyphen is not considered punctuation. Enable hyphenated nouns."	"Note: Apostrophe is included in tokens so that possessive form of noun (recipe`s) and contraction (can`t)  are treated as a single word. "	"WARNING: Hum has a quirk: Accent (`) is used as apostrophe. Avoid complication distinguishing uses of single-quote."		tokens := aString  findTokens: ( punctuation, whitespace ) keep: punctuation.	^tokens.! !!HumCalculator class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 1/8/2015 09:37'!removeNoiseWordTokensFrom: inputTokens	| outputTokens |	outputTokens := inputTokens reject: [:token | #('a' 'an' 'the') includes: token].	^outputTokens. 	! !!HumCalculator class methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 5/18/2015 11:32'!given: inputString onMatch: aPatternString do: aBlockClosure 	"When the inputString matches pattern, execute the block with matching arguments.	 Use this to parse lines, interpret lines, generate code."	| match whitespace punctuation quote myTokens patternTokens xMe xPattern arguments myToken patternToken list |	"Parse me and the pattern."	whitespace := Character separators.	quote := $' asString.	punctuation := '~!!@#$%^&*()_+`={}|[]\:";<>?,./', quote.		myTokens := inputString asLowercase  findTokens: ( punctuation, whitespace ) keep: punctuation.	patternTokens := aPatternString asLowercase  findTokens: ( punctuation, whitespace ) keep: punctuation.	"Quick test: Exit if the first token does not match."	myToken := myTokens at: 1.	patternToken := patternTokens at: 1.	(            ( myToken sameAs: patternToken ) 	or: [ '123456789*' includesSubString: patternToken ] ) "TODO: Match measurement pattern."		ifFalse: [^self ].	"Looks like the first word matches, go on."	xMe := 1.	xPattern := 0.	arguments := OrderedCollection new.	match := false.	patternTokens 		do: [ :token | "For each pattern token:"			patternToken := token.			match := false.			xPattern := xPattern + 1.			( '123456789' includesSubString: patternToken )				ifTrue: [ "Current token is an argument"					arguments add: (myTokens at: xMe). 					match := true.					].			( patternToken = '*' )				ifTrue: ["This only works when the next pattern token is also downstream in myTokens"					((myTokens copyFrom: xMe+1 to: myTokens size ) includes: ( patternTokens at: xPattern + 1))						ifFalse: [ ^self ]						ifTrue: ["Next argument is a list"							| stopper |							stopper := ( patternTokens at: xPattern + 1).							list := OrderedCollection new.							[ (myTokens at: xMe) sameAs: stopper ] 								whileFalse: [ 									( #( ',' 'and' ) includes: (myTokens at: xMe)  )									 	ifFalse: [list add: (myTokens at: xMe).].					 									xMe := xMe + 1. 									].							arguments add: list.							"At this point we have to jump to the conclusion and exit the outer-do."							"*** TODO *** This logic will only work for lists that are at the end of the statement, but not in the middle."							aBlockClosure valueWithArguments: arguments.							^self.							].						].			( patternToken sameAs: ( myTokens at: xMe ) )						ifTrue: ["myToken matches a keyword. Proceed to next token."						match := true.].					match ifTrue: [ xMe := xMe + 1 ] 					ifFalse: ["Got to here with no match. But allow for dropped 'a', 'an', 'the', 'this', 'that'. "											    ( #('a' 'an' 'the' 'this' 'that' ) includes: patternToken )						                        ifFalse: [^self]					              ].					].	"If we've gotten this far, the pattern matched and we have zero or more arguments."		( arguments size = 0 )		ifTrue: [ aBlockClosure value ]		ifFalse: [ aBlockClosure valueWithArguments: arguments ].	^self.	! !Object subclass: #HumConfiguration	instanceVariableNames: 'messengerID managerID bookkeeperID worldbaseID ontology messengerProxy isTest clock dispatcherID debug'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumConfiguration commentStamp: 'RichardAlexanderGreen 2/21/2015 10:16' prior: 0!A configuration holds the information about how agents are connected to other agents.A typical running application needs the following actors/components:. Dialog Agent to communicate with the client. Coordinator to operate plans. Dispatcher to assign actors to actions. Bookkeeper to record resource untilization. Messenger to enable communication between these actors. A Dialog Agent uses one or more Scribes to decouple dialogs from specific user interface frameworks.. Actors have Blackboards to hold and organize their entity-attribute data.. Blackboards have World Bases to persist and archive their data.. Actors will generally share a common World Base because they are all operating in the same "world."Q: Should a configuration also hold actual objects? A: No. The configuration holds the unique names.    The messenger maps those names to network addresses and sends messages over the network.Q: How do we mock/proxy actors so that we can test without a network?A: (Eventually) The network is mocked in test mode.    Everything else should work the same in test and production modes. !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/24/2013 17:51'!bookkeeperID	^ bookkeeperID! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/22/2015 11:01'!getWorldBase	"Get this configuration`s worldbase instance."	| worldbaseInstance |	worldbaseInstance := (self messenger) getActorInstanceFromID: (self worldbaseID).	^worldbaseInstance.	! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/22/2015 10:49'!messenger: aHumMessenger	"Set the messenger -- Use to configure mocks when needed."	self assert: (aHumMessenger isKindOf: HumMessenger).  messengerProxy := aHumMessenger.! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2015 10:08'!configuration: aHumConfiguration 	"Copy configuration."	self assert: (aHumConfiguration isKindOf: HumConfiguration ).	self copyFrom: aHumConfiguration.! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/20/2015 07:59'!messengerID: aString	messengerID := aString.	('*URL*' match: aString) ifTrue: [self halt].	('*ID' match: aString ) ifFalse: [ Error signal: 'ID is not in expected (MOCK) format.' ].! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/16/2014 09:34'!debug	"Am I in debug mode?"	^ debug ifNil: [debug := false].! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/24/2013 17:54'!worldbaseID: anObject	worldbaseID := anObject! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2015 10:06'!dispatcherID	^ dispatcherID ifNil: [ Error signal: 'A configuration must have a Dispatcher.' ].! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2014 14:00'!messengerID: idMessenger dispatcherID: idDispatcher bookkeeperID: idBookkeeper worldbaseID: idWorldbase	messengerID := idMessenger.	dispatcherID := idDispatcher.  bookkeeperID := idBookkeeper.   worldbaseID := idWorldbase.	"WARNING: I am not sure this is a good idea."  ontology ifNil: [self ontology: HumOntology baseOntology].	! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2015 10:01'!clock	"What object is providing time-keeping?"	^ clock ifNil: [clock := HTime "class singleton"].! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/8/2012 13:51'!ontology: aHumOntology 	ontology := aHumOntology.! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/17/2014 11:28'!ontology	^ ontology ifNil: [ Error signal: 'ontology is missing from configuration'].	"TODO: Perhaps we should return HumOntology baseOntology instead."! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/23/2015 08:45'!openWorldBase	"Create world base instance and register with messenger."	| worldbaseInstance |	worldbaseInstance := HumWorldBase openWorldBase: (self worldbaseID).	(self messenger) registerActor: worldbaseInstance atURI: (worldbaseInstance uri). 	^worldbaseInstance.! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/15/2014 09:20'!messenger	^ messengerProxy 			ifNil: [ "Set up messenger with my clock."				messengerProxy := HumMessenger new.				messengerProxy clock: self. 				messengerProxy. "return"				].! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2014 09:24'!isTest: aBoolean	"Are we running in TEST mode?"	isTest := aBoolean	! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/24/2013 17:52'!bookkeeperID: anObject	bookkeeperID := anObject! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/24/2013 17:54'!worldbaseID	^ worldbaseID! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2015 10:01'!now	"What time is it in configured world (may be simulation)?"	^ clock now.! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/24/2013 17:53'!messengerID	^ messengerID! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2015 10:04'!clock: anObjectThatImplementsNow	"Clock must be an object that imlements >>now as a number of seconds (an Integer)."	self assert: ( anObjectThatImplementsNow respondsTo: #now ).	clock := anObjectThatImplementsNow.! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2014 13:56'!dispatcherID: anObject	dispatcherID := anObject! !!HumConfiguration methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2014 09:24'!isTest  "Are we running in TEST mode?"	^isTest ifNil: [ isTest := true. ].	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumConfiguration class	instanceVariableNames: ''!!HumConfiguration class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 9/14/2014 13:38'!configuration: aHumConfiguration	"Create an instance with the same configuration as the given configuration."	 | c instance |	 c := aHumConfiguration.   instance := self messengerID: c messengerID                       dispatcherID: c dispatcherID                    bookkeeperID: c bookkeeperID                     worldbaseID: c worldbaseID.   instance messenger: c messenger.	instance ontology: c ontology.	^ instance.! !!HumConfiguration class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 9/14/2014 14:08'!messengerID: idMessenger dispatcherID: idDispatcher bookkeeperID: idBookkeeper worldbaseID: idWorldbase 	| instance |	instance := self basicNew.	instance messengerID: idMessenger dispatcherID: idDispatcher bookkeeperID: idBookkeeper worldbaseID: idWorldbase.	instance ontology ifNil: [instance ontology: HumOntology baseOntology].	^instance.! !Object subclass: #HumEntity	instanceVariableNames: 'title id debug'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumEntity commentStamp: 'RichardAlexanderGreen 2/28/2015 10:08' prior: 0!Each instance of this class representes an entity-instance data-bag, generally not an entity-type metadata.An entity is a concept that exists in two contexts: entity-type and entity-instance.However, we tend to use the same word regardless of context because the meaning is usually clear-enough.1. An entity-type is a meta-data concept. It is associated with a noun in a Hum ontology.. . An entity-type is identified with a noun (a word or a hyphenated-word).. . In an ontology, an entity-type may have supertypes, subtypes, attributes. (See also: HumEntityAttribute). . In this context, the attribute-set of an entity merges its own attributes with those of its supertypes.2. An entity-instance is an node/item in a run-time data store (Hum BlackBoard and WorldBase).. . In a run-time context, an entity must have a unique identifier. (See HumIdentifier). . . The unique identifier enables references and facilitates data store operations.. . . Entity-instances may reference each other via their unique identifiers.. . A Hum World Base is a temporal database. . . . That means that entity data is time-stamped so that we can retrieve the history of an entity.. . . An entity may be ~created~ and ~destroyed~ to correspond to events in the real-world.. . . However, existence in the World Base may continue until the entity is ~purged~.Q: TODO: How do we represent the "entity destroyed" event in data and the world-base?A: This is relevant to how the World Base handles requests data for an entity.   If the request`s time-window is beyond the "destroy" event, the entity should not be in the result.!!HumEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/19/2014 11:49'!title	"a display string describing this entity" 	^ title ifNil: [title := 'Unknown Entity'].! !!HumEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2015 10:19'!id: aString 	"Set the entity`s identifier."	id := aString! !!HumEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2015 09:35'!id	"Return a unique identifier."	| context |	^ id ifNil: [ Error signal: 'Entity ID should be set by Blackboard or DialogAgent.'.				context := 'Default ID for ' , (self class asString). "Convenient for DEBUG?"				id := HumIdentifier createUniqueIdentifierForEntityName: title inContext: context 				].! !!HumEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2015 10:23'!title: aString	"a display string describing this entity" 	title := aString asString.	self id: (HumIdentifier createUniqueIdentifierForEntityName: title inContext: title). "???"	self id.! !!HumEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/19/2014 11:50'!asString	^self title.! !!HumEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/16/2014 09:35'!debug	"Am I in debug mode?"	^ debug ifNil: [debug := false].! !!HumEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/19/2013 17:35'!printOn: aStream	| myClassName |	myClassName := self class name.	aStream nextPutAll: ( myClassName,'(',id asString,')' ).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumEntity class	instanceVariableNames: ''!!HumEntity class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/13/2013 08:44'!title: aString	| instance |	instance := self basicNew.	instance title: aString.	^instance.! !!HumEntity class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/28/2015 10:24'!new	| instance |	Error signal: 'Why are we creating a HumEntity without a title?'.	instance := self basicNew.	instance title: (self class asString).	^instance.! !HumEntity subclass: #HumBusinessEvent	instanceVariableNames: 'who what when where why'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumBusinessEvent commentStamp: 'RichardAlexanderGreen 2/18/2016 20:18' prior: 0!A business event attributes are W5: who, what, when, where (Who said/saw what, when, where, why.). Who is an actor. (client/VR actor/. . .). What is a statement.	(assertion). When is a timestamp.	(world time or host time?). Where is a frame.  	(NOTE: Assume we are interpreting frame at run-time.). Why is a job-ticket.	(Job-ticket identifies a plan = a run-time goal.)!!HumBusinessEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/28/2015 13:53'!what: aString	"What is the cause/actor doing in the business event?"	what := aString! !!HumBusinessEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/28/2015 13:57'!why: aJobTicket	"Why (job-ticket) is business event happening?"	why := aJobTicket! !!HumBusinessEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/28/2015 13:58'!where: aString	"Where (at what location/context) is business event happening?"	where := aString! !!HumBusinessEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/28/2015 14:00'!who: aWho what: aWhat when: aTimeStamp where: aWhere why: aJobTicket	"Set the business event attributes."	self who: aWho; what: aWhat; when: aTimeStamp; where: aWhere; why: aJobTicket.! !!HumBusinessEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/28/2015 13:54'!when: aTimeStamp	"When (at what date-time) is business event happening?"	when := aTimeStamp! !!HumBusinessEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/28/2015 13:52'!who: aString	"Who is the cause/actor in the business event"	who := aString! !HumEntity subclass: #HumDataFrame	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumDataFrame commentStamp: 'RichardAlexanderGreen 1/26/2015 08:45' prior: 0!The Data Frame class standardizes the way we structure and format data.Data Frame versus Message:A HumMessage specializes a HumDataFrame.A Message Entity requires sender, reciever, sent-when, statement, and noun-values.The Message class provides serialization and deserialization services.A DataFrame may hold any entity structure and may be used for purposes other than actor-to-actor communication.For example, we may represent configuration, layout, landscape, or actor suspence data in Data Frames. Data Frame includes methods to serialize and de-serialize data. (TODO)!Object subclass: #HumEntityAttribute	instanceVariableNames: 'title id'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumEntityAttribute commentStamp: 'RichardAlexanderGreen 7/7/2015 10:25' prior: 0!An attribute describes an entity. Hence we may say entity-attribute to be more explicit.An attribute exists in two contexts: attribute-type, attribute-instance.However we tend to just say "attribute" in many contexts because the meaning is generally clear enough.1. In an ontology, an attribute-type is named by a noun.. . Entity-types have attributes. More than one entity-type may have the same attribute.. . Basically this means that an attribute-type has no meaning without the context of an entity-type.. . However, to avoid confusion, only one datatype may be associated with the noun that names an attribute-type.2. In an ontology, an attribute-type may reference an entity-type or one of the built-in entity-types.. . The built-in datatypes include string, date, timestamp, collection (set, list, bag), and measure.. . . There are no abstract or machine-oriented numeric types in Hum. . . . A real-world number is always a measurement. (See HumMeasure).. . . If no datatype is assigned to an attribute-type, the default datatype is a string.3. At run-time, an attribute-instance is associated with an entity-instance in a data store (BlackBoard/WorldBase).. . The entity-instance identifier plus the attribute-type (noun) is unique. . . . So the attribute-instance does not need an additional identifier.. . The attribute may take on different values over time. . . . Attribute values have timestamps so we know which value was applicable at any point in time.. . . Note: It makes no sense to assign a null value to a Hum attribute.. . . Comment: Generally, it is a bad practice to use an empty value as a business signal.The primative datatypes include:- String . . an array of characters- Text . . . an array of lines of tokens with styling- Measure. . a quantity with a unit of measure and precision- Date . . . a calendar date (DateAndTime)- Category . some value within an enumerated set - Collection a collection of objects (entity instances)- Identifer . . Identifies an entity instance in a World Base.Future primative datatypes might include media types:- Image  . . a 2D picture (very technology dependent)!Magnitude subclass: #HumFuzzy	instanceVariableNames: 'distribution sampleSize resultDivisions'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumFuzzy commentStamp: 'RichardAlexanderGreen 4/9/2013 09:48' prior: 0!This class implements fuzzy arithmetic using Monte Carlo sampling of the distributions.!!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/9/2013 14:13'!/ aHumFuzzy 	| divide result |	divide := #/.	result := self op: divide with: aHumFuzzy.	^result.! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 5/14/2015 16:39'!op: aSymbol with: aHumFuzzy "Add two fuzzy distibutions using Monte Carlo sampling"	| resultSet random  vC sortedSet distributionC tick count fuzzyC |	resultSet := Bag new.	random := Random new.	( 1 to: sampleSize )		do: [ :i |			| rA rB vA vB |			rA := random next.			vA := self atP: rA.			rB := random next.			vB := aHumFuzzy atP: rB.			vC := vA perform: aSymbol with: vB.			resultSet add: vC.			].	"Create a new distribution with points every 10%"	sortedSet := resultSet asSortedCollection.	self assert: ( sortedSet size = sampleSize ).	"Note: Assertion above occasionally fails due to accidental matches in set.	TODO: CONSIDER USING A BAG INSTEAD OF A SET."	distributionC := Dictionary new.	distributionC at: 0.0 put: ( sortedSet first ). "This is a placeholder."	tick := sampleSize / resultDivisions.	count := 0.	sortedSet		do: [ :x | 				| modulo |				modulo := ( count \\ tick ).				( modulo = 0 )					ifTrue: [ distributionC at: ( (count/sampleSize) asFloat )  put: x ].			  count := count + 1.			 ].	distributionC at: 1.0 put: (sortedSet last).	"self correctInterceptInDistribution: distributionC."	self assert: ( distributionC size = (resultDivisions + 1) ).	fuzzyC := self copy distribution: distributionC.	^fuzzyC.		! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/9/2013 14:15'!* aHumFuzzy 	| times result |	times := #*.	result := self op: times with: aHumFuzzy.	^result.! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 6/23/2014 14:18'!correctInterceptInDistribution: aDistribution	"-- Use slope-intercept to get a better estimate of the S-curve value at probability 0.	v(p) = a + b*p	v(0) = a.	v(p1) = a + b*p1.	v(p2) = a + b*p2.	v(p2) - v(p1) = b*(p2-p1).	b = ( v(p2) - v(p1) ) / (p2-p1).	extrapolate a = v(0) so that we get the same slope b.	b = ( v(p2) - v(0) ) / (p2 - 0).	b = ( v(p2) - a ) / p2.	b * p2 = v(p2) - a.	a = v(p2) - (b * p2).	"	| tick p1 p2 v1 v2 b a | 	self assert: (aDistribution isKindOf: Dictionary).	tick := sampleSize / resultDivisions.  "This must be coordinated to match >>op:with:"	p1 := (tick/sampleSize) asFloat.	p2 := (tick * 2/sampleSize) asFloat.	v1 := aDistribution at: p1.	v2 := aDistribution at: p2.	b := (v2 - v1) / (p2 - p1).	a := v2 - ( b * p2 ).	aDistribution at: 0.0 put: a.	! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/22/2013 09:59'!mean	| sum n result |	sum := 0.0.	n := 0.	self sampleWithBlock: [ :x | n := n + 1. sum := sum + x.].	result := sum / n.	^result.! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 6/22/2014 13:15'!+ aHumFuzzy 	| plus result |	plus := #+.	result := self op: plus with: aHumFuzzy.	^result.! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/9/2013 14:11'!- aHumFuzzy 	| minus result |	minus := #-.	result := self op: minus with: aHumFuzzy.	^result.! !!HumFuzzy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/22/2013 10:01'!sampleWithBlock: aBlock "Operate on fuzzy distibution using Monte Carlo sampling"	| resultSet random |	resultSet := Set new.	random := Random new.	( 1 to: sampleSize )		do: [ :i |			| rA  vA  |			rA := random next.			vA := self atP: rA.			aBlock value: vA.			].		! !!HumFuzzy methodsFor: 'plot' stamp: 'RichardAlexanderGreen 6/24/2014 13:03'!asCrudeMorph		| magnifyBy scaleX scaleY scalePt vMax extent priorPt canvas morph |	magnifyBy := 2.	scaleX := [:v | v*magnifyBy].	scaleY := [:p | (100 - (100*p))*magnifyBy ]. "Flip Y. Screen coordinates have Y pointing down."	scalePt := [:pt | (scaleX value: (pt x))@(scaleY value: (pt y)) ].	vMax := distribution at: 1.0.	extent := ( scalePt value: (vMax@0.0) )* 1.1.		priorPt := scalePt value: 0.0@0.0.	canvas := FormCanvas extent: extent depth: 32 origin: (10@10) clipRect: (Rectangle origin: 0@0 extent: extent).	  canvas fillColor: Color blue muchLighter.		"verticle grid"		(0.0 to: vMax by: 100.0)			do: [:v | canvas line: (scalePt value: v@0.0) to: (scalePt value: v@1.0) width: 1 color: Color green].	  "horizontal grid"		(0.0 to: 1.0 by: 0.1)			do:[:p | canvas line: (scalePt value: 0.0@p) to: (scalePt value: vMax@p) width: 1 color: Color green].		(0.0 to: 1.0 by: 0.5)			do:[:p | canvas line: (scalePt value: 0.0@p) to: (scalePt value: vMax@p) width: 2 color: Color green].		self distributionDo: [ :p :v | 		| xy | 		xy := scalePt value: v@p.		canvas line: priorPt to: xy width: 4 color: Color red.		priorPt := xy.		]. 	morph := canvas form asMorph openInWorld. 	"You can delete morph by double-clicking it."	morph on: #doubleClick send: #delete to: morph. ! !!HumFuzzy methodsFor: 'plot' stamp: 'RichardAlexanderGreen 6/24/2014 13:33'!asCrudeMorph2		|  scaleX scaleY scalePt vMax extent priorPt canvas morph pPixels vPixels vMin |	pPixels := 2.	vPixels := 2.	vMax := distribution at: 1.0.	vMin := distribution at: 0.0.	"Normalize v range to [0,100]."	scaleX := [:v | 100*(v-vMin)/(vMax-vMin)*vPixels ].	"Flip Y. Screen coordinates have Y pointing down."	scaleY := [:p | (100 - (100*p))*pPixels ]. 	scalePt := [:pt | (scaleX value: (pt x))@(scaleY value: (pt y)) ].		extent := ( scalePt value: (vMax@0.0) )* 1.1. "TODO: Enable caller to specify extent."			priorPt := scalePt value: 0.0@0.0.	canvas := FormCanvas extent: extent depth: 32 origin: (10@10) clipRect: (Rectangle origin: 0@0 extent: extent).	"Paint grid lines"	  canvas fillColor: Color blue muchLighter.		"vertical grid"		(vMin to: vMax by: ((vMax-vMin)*0.1))			do: [:v | canvas line: (scalePt value: v@0.0) to: (scalePt value: v@1.0) width: 1 color: Color green].		(vMin to: vMax by: ((vMax-vMin)*0.5))			do: [:v | canvas line: (scalePt value: v@0.0) to: (scalePt value: v@1.0) width: 2 color: Color green].	  "horizontal grid"		(0.0 to: 1.0 by: 0.1)			do:[:p | canvas line: (scalePt value: 0.0@p) to: (scalePt value: vMax@p) width: 1 color: Color green].		(0.0 to: 1.0 by: 0.5)			do:[:p | canvas line: (scalePt value: 0.0@p) to: (scalePt value: vMax@p) width: 2 color: Color green].		self distributionDo: [ :p :v | 		| xy | 		xy := scalePt value: v@p.		canvas line: priorPt to: xy width: 4 color: Color red.		priorPt := xy.		]. 	morph := canvas form asMorph openInWorld. 	"You can delete morph by double-clicking it."	morph on: #doubleClick send: #delete to: morph. ! !!HumFuzzy methodsFor: 'plot' stamp: 'RichardAlexanderGreen 6/24/2014 22:21'!asCrudeMorphInRectangle: aRectangle	"Display a plot in a Morph with the origin and extent indicated by the given Rectangle."	|  scaleX scaleY scalePt vMax extent priorPt canvas morph pPixels vPixels vMin r |	vMax := distribution at: 1.0.	vMin := distribution at: 0.0.	"Pixels per normalized value unit."	extent := (aRectangle extent) - (10@10). 	vPixels := (extent x) / 100.	pPixels := (extent y) / 100.	"Normalize v range to [0,100]."	scaleX := [:v | 100*(v-vMin)/(vMax-vMin)*vPixels ].	"Flip Y. Screen coordinates have Y pointing down."	scaleY := [:p | (100 - (100*p))*pPixels ]. 	scalePt := [:pt | (scaleX value: (pt x))@(scaleY value: (pt y)) ].		extent := ( scalePt value: (vMax@0.0) )* 1.1. "TODO: Enable caller to specify extent."			canvas := FormCanvas extent: extent depth: 32 origin: (10@10) clipRect: (Rectangle origin: 0@0 extent: extent).	"Paint grid lines"	  canvas fillColor: Color blue muchLighter.		"vertical grid"		(vMin to: vMax by: ((vMax-vMin)*0.1))			do: [:v | canvas line: (scalePt value: v@0.0) to: (scalePt value: v@1.0) width: 1 color: Color green].		(vMin to: vMax by: ((vMax-vMin)*0.5))			do: [:v | canvas line: (scalePt value: v@0.0) to: (scalePt value: v@1.0) width: 2 color: Color green].	  "horizontal grid"		(0.0 to: 1.0 by: 0.1)			do:[:p | canvas line: (scalePt value: 0.0@p) to: (scalePt value: vMax@p) width: 1 color: Color green].		(0.0 to: 1.0 by: 0.5)			do:[:p | canvas line: (scalePt value: 0.0@p) to: (scalePt value: vMax@p) width: 2 color: Color green].	priorPt := scalePt value: vMin@0.0.		self distributionDo: [ :p :v | 		| xy | 		xy := scalePt value: v@p.		canvas line: priorPt to: xy width: 4 color: Color red.		priorPt := xy.		]. 	morph := canvas form asMorph bounds: aRectangle.	morph openInWorld. 	"You can delete morph by double-clicking it."	morph on: #doubleClick send: #delete to: morph. ! !!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/22/2014 13:33'!initialize	self sampleSize: 1024*16 resultDivisions: 32.	! !!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2015 13:10'!interpolate: aProbability	"Return the predicted value at aProbability using linear interpolation."	| lowerP lowerF upperP upperF slope result |	self assert: (aProbability isKindOf: Float ).	"Following depends on Dictionary semantics"	self assert: ( distribution isKindOf: Dictionary ).	"Find the interval that brackets the requested point."	lowerP := 0.0.	lowerF := distribution at: lowerP.	upperP := 1.0.	upperF := distribution at: upperP.	distribution keysAndValuesDo: [ :k :v |		( k > lowerP and: [ k < aProbability ] ) ifTrue: [ lowerP := k. lowerF := v. ].		( k < upperP and: [ k > aProbability ] ) ifTrue: [ upperP := k. upperF := v. ].		].	"Do simple linear interpolation."	slope :=  ( upperF - lowerF ) / ( upperP - lowerP ).	"Check: for an S-Curve the slope is always positive."	self assert: ( slope > 0.0 ).		result := lowerF + ( (aProbability - lowerP) * ( slope) ).	"Check: the result must be between upper and lower function values"	self assert: ( result > lowerF ).	self assert: ( result < upperF ).	"TODO: If we need more accuracy, use two quadratic splines.	Currently, the data we have does not justify such accuracy,	so I decided to keep it simple.	"	^result.! !!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/23/2014 14:10'!sampleSize: anInteger	"Reset the sample size used in Monte Carlo sampling of input distributions.	Default value is preset in >>initialize method.	A value on the order of 10,000 produces good results.	The sampleSize must be a multiple of 10. (See >>op:with:)	"	sampleSize := anInteger.! !!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2013 11:14'!atP: aFloat 	"Return the appropriate value from the distribution.	Iterpolate when necessary. 	This version uses linear interpolation.	Future versions might use a spline or something."	| result |	"Check that aFloat is between zero and one"	self assert: ( aFloat isKindOf: Float ).	self assert: ( aFloat >= 0.0 ).	self assert: ( aFloat <= 1.00).	"Look up value or interpolate to get a result."	result := distribution at: aFloat ifAbsent: [ self interpolate: aFloat ].	^ result.! !!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/23/2014 14:09'!distribution: aDictionary 	"Distribution is an S-curve that maps probability to value.	Example: 'distribution at: 0.50 put: 12.' 	  means that sample values will be less than or equal to 12 for 50% of samples.	In other words, the median of the distribution is 12.	"	self assert: ( aDictionary isKindOf: Dictionary ).	distribution := aDictionary.! !!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/23/2014 14:15'!sampleSize: aSampleSize resultDivisions: aDivisionCount	"Reset the sample size used in Monte Carlo sampling of input distributions.	Default value is preset in >>initialize method.	A value on the order of 10,000 produces good results.	The sampleSize must be a multiple of aDivisionCount. (See >>op:with:)	"	self assert: (aSampleSize \\ aDivisionCount = 0).	"The Monte Carlo will randomly sample the inputs this many times."	sampleSize := aSampleSize.	"The resulting S-curve will have N+1 points selected from sampleSize points."	resultDivisions := aDivisionCount. ! !!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/23/2014 17:26'!distributionDo: pvBlock	"Vist the key->value (probability->value) entries in the distribution."	| keys |	self assert: ( pvBlock isKindOf: BlockClosure ).	self assert: ( pvBlock argumentCount = 2 ).	self assert: ( distribution isKindOf: Dictionary ).	keys := distribution keysSortedSafely.	keys 		do: [ :p |			| v |			v := distribution at: p.			pvBlock value: p value: v.			].! !!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/14/2015 16:25'!fromString: aString	"Set the distribution from the given string.	Assume the string value is the median (50% point) of a distribution.	Assume the 0% and 100% value are the median plus or minus the scale (number of decimal places).	"	| scaledDecimal assumedMedian err assumedDistribution |	scaledDecimal := ScaledDecimal readFrom: aString.	assumedMedian := scaledDecimal asFloat.	err := (10.0 raisedToInteger: (scaledDecimal scale negated))/2.0.	assumedDistribution := Dictionary new.	assumedDistribution		at: 0.50 put: assumedMedian;		at: 0.00 put: assumedMedian - err;		at: 1.00 put: assumedMedian + err.	self distribution: assumedDistribution.	 ! !!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/9/2013 13:14'!median	"find the point that represents the median"	|  medianPoint |	"Distribution is list of f->p".	"Look for f@0.50"	medianPoint := self atP: 0.50.	^medianPoint.! !!HumFuzzy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/14/2015 14:27'!fromScaledDecimal: aScaledDecimal	"Set the distribution from the given string.	Assume the string value is the median (50% point) of a distribution.	Assume the 0% and 100% value are the median plus or minus the scale (number of decimal places).	"	| scaledDecimal assumedMedian err assumedDistribution calc |	calc := HumCalculator new.	calc cases;		when: [ aScaledDecimal isKindOf: ScaledDecimal ]			then: [ scaledDecimal := aScaledDecimal ];		when: [ aScaledDecimal isKindOf: String ]			then: [ scaledDecimal := ScaledDecimal readFrom: aScaledDecimal ];		otherwise: [ Error signal: 'Expected ScaledDecimal or String. Got: ', (aScaledDecimal class) ].	assumedMedian := scaledDecimal asFloat.	err := 10.0 raisedToInteger: (scaledDecimal scale negated).	assumedDistribution := Dictionary new.	assumedDistribution		at: 0.50 put: assumedMedian;		at: 0.00 put: assumedMedian - err;		at: 1.00 put: assumedMedian + err.	self distribution: assumedDistribution.	 ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFuzzy class	instanceVariableNames: ''!!HumFuzzy class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/9/2013 13:43'!distribution: aDistribution	"Create a new instance from the given distribution."	| fuzzy |	fuzzy := self basicNew.	fuzzy initialize.	fuzzy distribution: aDistribution.	^fuzzy.! !!HumFuzzy class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/22/2013 10:24'!quantity: aQuantity plusOrMinus: aLimit 	"Create a distribution with given limits."	| fuzzy stats |	self assert: ( aQuantity isKindOf: Number ).	self assert: (    aLimit isKindOf: Number ).	"Assume upper and lower will not be exceeded.	The idea is that cases exceeding those measures would be rejected.	"	fuzzy := self basicNew.	fuzzy initialize.	stats := Dictionary new.	stats		at: 0.50  put: aQuantity;		at: 0.00  put: (aQuantity - aLimit );		at: 1.00  put: (aQuantity + aLimit ).	fuzzy distribution: stats.	^fuzzy.! !HumFuzzy subclass: #HumDecimal	instanceVariableNames: 'nDecimal'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumDecimal commentStamp: 'RichardAlexanderGreen 5/14/2015 11:18' prior: 0!HumDecimal tracks the number of digits of accuracy in a number.Arithmetic can never increase the number of digits.Arithmetic is performed using HumFuzzy   so that S-curves (not just triangular distributions) are available.The user interface uses scientific notation   for input and output (to/from strings).!!HumDecimal methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/14/2015 16:22'!nDecimal: anInteger 	"How many decimal places should we display."	nDecimal := anInteger.! !!HumDecimal methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/14/2015 16:21'!fromString: aString	"Count the digits in the string to estimate accuracy."	|  parser value  nDigits assumedMedian err  lowerBound upperBound aDistribution |	parser := HumNumberParser on: aString.	value := parser nextNumber.	nDigits := parser nDigits.	assumedMedian := value.	err := (10.0 raisedToInteger: (nDigits negated)) / 2.0.	lowerBound := assumedMedian - err.	upperBound :=  assumedMedian + err.	aDistribution := Dictionary new.	aDistribution		at: 0.50 put: assumedMedian;		at: 0.00 put: lowerBound;		at: 1.00 put: upperBound.	self distribution: aDistribution.	self nDecimal: nDigits.			! !!HumDecimal methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 5/14/2015 16:36'!printOn: aStream	super printOn: aStream.	distribution ifNil: [ ^self ].	aStream		nextPut: $(;		nextPutAll: (self median printShowingDecimalPlaces: self nDecimal );		nextPut: $).	! !!HumDecimal methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 5/14/2015 16:32'!nDecimal	"How many decimal places should we display."	^nDecimal ifNil: [ 0 ].! !Object subclass: #HumHttpRequest	instanceVariableNames: 'myFields'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumHttpRequest commentStamp: 'RichardAlexanderGreen 2/1/2015 09:50' prior: 0!This class provides a wrapper around the HTTP implementation.The idea is that we could switch between Zinc or Seaside or our own implementationwith minimal changes to run-time code.The ideal result would enable such changes to be merely a matter of run-time configuration.!!HumHttpRequest methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/20/2015 09:41'!fields	|  |	^myFields ifNil: [myFields := Dictionary new.].! !!HumHttpRequest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 6/2/2014 08:04'!atField: aKey put: aValue	"The Http Request form included this input name:value pair."	(self fields) at: aKey put: aValue.! !Object subclass: #HumIdentifier	instanceVariableNames: 'bigNumber uuid entityName'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumIdentifier commentStamp: 'RichardAlexanderGreen 3/5/2015 10:07' prior: 0!Primary Programmer Stories:. Identifier is related to an entity and/or event. (where used). When an entity is created, it is given a unique identifier. (where used)Instance Variables:	bigNumber	<Integer | LargePositiveInteger >	uuid	       <UUID>	entityName	 <String>Class Instance Variables:	daysRegister	     <Integer>	secondsRegister	 <Integer>	nanosRegister	   <Integer>	uuid	            <UUID>		Secondary Programmer Stories:. Identifier sorts by time-of-creation. (system clock or simulator clock). Identifier has time-stamp qualities.!!HumIdentifier methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 3/5/2015 10:55'!<= aHumIdentifier 	| result |	result := ( self asString <= aHumIdentifier asString ).	^ result.! !!HumIdentifier methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 3/30/2015 10:41'!< aHumIdentifier 	| result |	result := ( self asString < aHumIdentifier asString ).	^ result.! !!HumIdentifier methodsFor: 'private' stamp: 'RichardAlexanderGreen 4/29/2014 09:37'!printOn: aStream	aStream nextPutAll: (self asString).! !!HumIdentifier methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/8/2014 11:58'!entityName	"Return entity name -- force nil to string if needed."	^ entityName asString.! !!HumIdentifier methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/28/2015 09:23'!asString		(bigNumber isKindOf: Integer ) 		ifFalse: [ Error signal: 'bigNumber should be an Integer'.			^(entityName asString),':',(bigNumber asString)].	^ (entityName asString),':',(bigNumber printStringHex).! !!HumIdentifier methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/28/2014 17:13'!uuid: aUUID 	uuid := aUUID! !!HumIdentifier methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/28/2015 14:31'!generateForEntityName: anEntityName inContext: aBusinessEvent	"Make self a unique identifier for given entity context."	| ticks days seconds nanos prior priorDays priorSeconds priorNanos priorBigNumber |	self assert: (anEntityName isKindOf: String).	self assert: (aBusinessEvent isKindOf: String).	self assert: (aBusinessEvent > ' ').	"TODO: Think: Should the business context where the entity originates be embedded in the ID somehow ???"	entityName := anEntityName.	ticks := DateAndTime now asUTC ticks copy.	days := ticks at: 1.	seconds := ticks at: 2.	nanos := ticks at: 3.	"Singleton holds prior values."	prior := self class.	priorDays := prior days.	priorSeconds := prior seconds.	priorNanos := prior nanos.	( days = priorDays and: [ seconds = priorSeconds and: [ nanos <= priorNanos ] ] )		ifTrue: [ nanos := (prior nanos) + 1. ].	"Post Conditions:"		bigNumber := (((days * 86400) + seconds) * 1e9) + nanos.	priorBigNumber := ( ((priorDays * 86400) + priorSeconds) * 1e9) + priorNanos.	self assert: ( bigNumber > priorBigNumber ).	"Set the singleton values."	prior days: days seconds: seconds nanos: nanos.	self uuid: self class uuid.	! !!HumIdentifier methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/19/2014 11:40'!initialize	"This UUID represents the run-time. 	TODO: THIS IS A STUB. 	EVENTUALLY, THIS SHOULD BE SET FROM A CONFIGURATION FILE OR SOMETHING."	uuid := UUID new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumIdentifier class	instanceVariableNames: 'daysRegister secondsRegister nanosRegister uuid'!!HumIdentifier class methodsFor: 'class variables' stamp: 'RichardAlexanderGreen 9/19/2014 12:07'!nanos	"Fetch the prior identifier parameters."	^ nanosRegister ifNil: [ nanosRegister := 0 ].! !!HumIdentifier class methodsFor: 'class variables' stamp: 'RichardAlexanderGreen 9/19/2014 12:23'!uuid	"Fetch the prior identifier parameters?"	| x |		x := (((daysRegister*10e6)+secondsRegister)*10e9)+nanosRegister.	uuid := x printStringHex.	^ uuid! !!HumIdentifier class methodsFor: 'class variables' stamp: 'RichardAlexanderGreen 4/28/2014 09:56'!days: nDays seconds: nSeconds nanos: nNanos 	daysRegister := nDays.	secondsRegister := nSeconds.	nanosRegister := nNanos.! !!HumIdentifier class methodsFor: 'class variables' stamp: 'RichardAlexanderGreen 9/19/2014 12:07'!days	"Fetch the prior identifier parameters."	^ daysRegister ifNil: [ daysRegister := 0 ].! !!HumIdentifier class methodsFor: 'class variables' stamp: 'RichardAlexanderGreen 9/19/2014 12:07'!seconds	"Fetch the prior identifier parameters."	^ secondsRegister ifNil: [ secondsRegister := 0 ].! !!HumIdentifier class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 12/28/2015 14:06'!createUniqueIdentifierForEntityName: entityName inContext: businessEvent	"There should always be a business context (not a data-context)."	| instance |	instance := self basicNew.	instance generateForEntityName: entityName inContext: businessEvent. 	^instance.! !HumEntity subclass: #HumJobTicket	instanceVariableNames: 'ontology charges'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumJobTicket commentStamp: 'RichardAlexanderGreen 9/14/2014 13:22' prior: 0!A job ticket records the resources consumed by a job.A job is initiated when a goal is set running.When actions are delegated by the one actor to other actors, they get jobtickets also.The resulting resource data is consolidated on the parent-level job-ticketsso that the costs are rolled-up to each level and eventually to the job as a whole.When each action is completed, the Dispatcher reports new resource entries to the Bookkeeper.Hence a running account is maintained for the job, for each resource, for each actor, for each role, for each action.---Dictionary: Job Vocabulary.Job attributes include goal-invocation, resource-usage.Goal-invocation attributes include invocation-event, goal.Resource-usage has a list of usage-notes.Usage-note attributes include resource, quantity-used, by-actor, in-role, performing-action.---Note that resource accounting only sums resource quantities.It does not attempt to monetize (price) the resources used because that is a very specialized process.For example, withdrawals from inventory might be priced using LIFO, FIFO, or some other accounting practice.TODO: Refactor job ticket so that it is not a subtype of data frame.      (2013-06-07) A job ticket is currently a subtype of HumDataFrame.       That is a bad idea because it mixes ticket concept with serialization process.!!HumJobTicket methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/10/2013 10:07'!charges	^charges ifNil: [ charges := OrderedCollection new.]! !!HumJobTicket methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/22/2014 10:40'!printOn: aStream	|  |		aStream nextPutAll: ( 'Job:(',title asString,')' ).! !!HumJobTicket methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/22/2014 09:52'!appendCharge: aHumMeasure forAction: action byActor: anID inRole: aRoleName onJob: aJobID 	| charge debug |	"Use a dictionary to represent a charge."		charge := Dictionary new.	charge 		at: 'measure' put: aHumMeasure "asString";		at: 'action'  put: action asString;		at: 'ID'      put: anID asString;		at: 'role'    put: aRoleName asString;		at: 'job'     put: aJobID asString.	debug := false. 	debug 		ifTrue: [ 			Transcript cr.			charge keysAndValuesDo: [:k :v | Transcript show: ' ',k,': ', v asString.]			].			"Append this charge to ticket`s charges."	
  ( self charges ) add: charge.	! !!HumJobTicket methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/24/2014 10:27'!getActionSequence	"Parse the job ticket to show the sequence of actions."	| listOfActions |	listOfActions := OrderedCollection new.	self charges		do:[:charge |			listOfActions add: (charge at: 'action') source.			].	^listOfActions.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumJobTicket class	instanceVariableNames: ''!!HumJobTicket class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 9/22/2014 13:56'!new	| instance |	"Catch cases where instances are created without titles."	self halt.	instance := self basicNew.	instance initialize.	^instance! !Magnitude subclass: #HumMeasure	instanceVariableNames: 'dimensions quantity'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumMeasure commentStamp: 'RichardAlexanderGreen 7/9/2015 12:41' prior: 0!HumMeasure expresses most measurements in KMS (SI) units.Note: A protocol has been added to Number - to convert numbers into Measures.s := 1 lightSecond.  "HumMeasure( 299792458 meter )"smilliC := s / 1000.  "HumMeasure( 299792.458 meter ) about 300 kilometers"microC := s / 1e6.   "HumMeasure( 299.792 meter ) a football field"nanoC := s / 1e9.    "HumMeasure( 0.300 meter ) about 300 millimeter" picoC := s / 1e12.   "HumMeasure( 0.000299792458 meter ) about 0.3 millimeter"  femtoC := s / 1e15.  "HumMeasure( 2.99792458e-7 meter ) about 4000 atoms - See below."attoC := s / 1e18.   "HumMeasure( 2.99792458e-10 meter ) about 4 atoms" picoMeter := 1 meter / 1e12." HumMeasure( (1/1000000000000) meter )"carbonRadius := picoMeter * 70." HumMeasure( (7/100000000000) meter )"nCarbonAtoms := femtoC / carbonRadius." HumMeasure( 4282.749  )" !!HumMeasure methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/29/2016 12:07'!adaptToCollection: aCollection andSend: aSymbol 	| resultingCollection |	Error signal: 'How did we get here?'.	resultingCollection := OrderedCollection new.	aCollection do: [ :each | resultingCollection add: (each perform: aSymbol with: self) ].	^resultingCollection.! !!HumMeasure methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 5/30/2014 12:58'!standardNameFor: aString 	"Fix up names of units to assure consistency."	| unitsString |	unitsString := aString asString trimBoth.	"Remove square- cubic-"	(unitsString beginsWith: 'square' ) ifTrue: [ unitsString := unitsString copyReplaceTokens: 'square' with: ''].	(unitsString beginsWith: 'cubic' ) ifTrue: [ unitsString := unitsString copyReplaceTokens: 'cubic' with: ''].	unitsString := unitsString trimBoth.	"Standardize terms"	unitsString := (self unitsSynonyms) at: unitsString ifAbsent: [ unitsString ].			self assert: ( unitsString endsWith: 's' ) not.	^unitsString.! !!HumMeasure methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 10/9/2015 15:23'!quantityAsString	"Return the quantity that was observed for this instance."	| result |	result := self quantityAsString: (self quantity).	^result.! !!HumMeasure methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 10/9/2015 15:17'!asString	| result  |	result := self quantityAsString, ' ', self displayUnits.	^result.! !!HumMeasure methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 4/28/2013 13:18'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		nextPutAll: title;		nextPutAll: ( '( ', (self asString), ' )' ).! !!HumMeasure methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 4/14/2016 09:28'!quantityAsString: q	"Return the quantity that was observed for this instance."	 | result |		self assert: (q isKindOf: Number).		( q = (q truncated) ) 		ifTrue:[ result := ((q truncated) asString). 						  ^result. 					 ].	((q abs) between: 0.001 and: 99999.0 )		ifTrue:  [ result := ( ( q printShowingDecimalPlaces: 3) )  ]		ifFalse: [ result := ( ( q asString                    ) )  ].	^result.! !!HumMeasure methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 10/13/2016 10:23'!displayUnits	| displayUnits |	displayUnits := (self units).	(self dimensions = (Dictionary newFrom: {'kilogram'->1. 'meter'->1. 'second'->(-2).}) )			ifTrue: [displayUnits := 'Newton'].	(self dimensions = (Dictionary newFrom: {'kilogram'->1. 'meter'->(-1). 'second'->(-2).}) )			ifTrue: [displayUnits := 'Pascal'].	(self dimensions = (Dictionary newFrom: {'kilogram'->1. 'meter'->2. 'second'->(-2).}) )		ifTrue: [displayUnits := 'Joule'].	(self dimensions = (Dictionary newFrom: {'kilogram'->1. 'meter'->2. 'second'->(-3).}) )		ifTrue: [displayUnits := 'Watt'].	(self dimensions = (Dictionary newFrom: {'pound'->1. 'foot'->1. 'second'->(-1).}) )		ifTrue: [displayUnits := 'foot pound per second'].	(self dimensions = (Dictionary newFrom: {'pound'->1. 'foot'->1.}) )		ifTrue: [displayUnits := 'foot pound'].	^displayUnits.! !!HumMeasure methodsFor: 'convert' stamp: 'RichardAlexanderGreen 10/9/2015 12:28'!asFloat	| q |	q := self quantity asFloat.	self assert: (q isKindOf: Float).	^q.! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/28/2013 10:30'!quantity: aNumber 	quantity := aNumber! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/18/2015 09:06'!unitsSynonyms	^ self class unitsSynonyms! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/14/2015 09:43'!dimensions: aDictionary 	| calc |	calc := HumCalculator new.	calc cases;		when: [ aDictionary isKindOf: Dictionary ] then: [ dimensions := aDictionary copy ];		when: [ aDictionary isKindOf: Array ] 			then: [ dimensions := Dictionary new.				 aDictionary do: [ :map |  					 					 dimensions at: (map key asSymbol) put: (map value)					]. 				];		otherwise:	[ Error signal: 'dimensions should be dictionary-like' ].! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/7/2016 10:31'!quantity	"Return the quantity that was observed for this instance."	| |	"Raise an error if caller attempts to access without a previous set."	^ quantity ifNil: [ Error signal: 'measure quantity not set.' ].! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/22/2013 10:10'!quantity: aNumber per: denominatorUnits	"Set instance denominator units.	 Use this method when the quantity is something like coefficient of expansion.	 coefficient := HumMeasure quantity: 6.5e-6 per: #degreeCentigrade.	"	| exponent standardName numeratorExponent |	quantity := aNumber.		exponent := -1.	(denominatorUnits beginsWith: 'square' ) ifTrue: [ exponent := -2 ].	(denominatorUnits beginsWith: 'cubic' ) ifTrue: [ exponent := -3 ].	standardName := self standardNameFor: denominatorUnits.	(self dimensions) at: standardName put: exponent.	 	 ! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/4/2013 11:04'!quantity: aNumber units: numeratorUnits per: denominatorUnits	"Set instance numerator and denominator units.	Example1:	   milesPerHour := HumMeasure2 quantity: 65 units: 'miles' per: 'hour'.	   feetPerMile := HumMeasure2 quantity: 5280 units: 'feet' per: 'mile'.	   feetPerHour := milesPerHour * feetPerMile.		 secondsPerHour := HumMeasure2 quantity: 3600 units: 'seconds' per: 'hour'.		 feetPerSecond := feetPerHour / secondsPerHour.	"	| exponent standardName numeratorExponent |	quantity := aNumber.	exponent := 1.	(numeratorUnits beginsWith: 'square' ) ifTrue: [ exponent := 2 ].	(numeratorUnits beginsWith: 'cubic' ) ifTrue: [ exponent := 3 ].	(self dimensions) at: (self standardNameFor: numeratorUnits) put: ( exponent ).		exponent := -1.	(denominatorUnits beginsWith: 'square' ) ifTrue: [ exponent := -2 ].	(denominatorUnits beginsWith: 'cubic' ) ifTrue: [ exponent := -3 ].	standardName := self standardNameFor: denominatorUnits.	"Get matching numerator exponent, if any, so that we correctly handle ratios 	 such as 'length per length' and 'dollars per dollar' "	numeratorExponent := (self dimensions) at: standardName ifAbsent: [0].	(self dimensions) at: standardName put: ( numeratorExponent + exponent ).	 	 ! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/3/2015 08:22'!quantity: aNumber units: numeratorUnits 	"Set instance numerator units	"	|  exponent |	quantity := aNumber.		( numeratorUnits asString = 'none' ) ifTrue: [  ^self ]. "Dimensionless measure."		exponent := 1.	(numeratorUnits beginsWith: 'square' ) ifTrue: [ exponent := 2 ].	(numeratorUnits beginsWith: 'cubic' ) ifTrue: [ exponent := 3 ].	(self dimensions) at: (self standardNameFor: numeratorUnits ) put: ( exponent ).	 	 ! !!HumMeasure methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/28/2013 19:09'!dimensions	"Tracks units and powers of units -- "	^ dimensions ifNil: [ dimensions := Dictionary new.]! !!HumMeasure methodsFor: 'testing' stamp: 'RichardAlexanderGreen 3/7/2016 10:49'!isRadian	| result |	result := (self units) = 'radian'.	^result.! !!HumMeasure methodsFor: 'testing' stamp: 'RichardAlexanderGreen 8/29/2016 08:46'!isDimensionless	"Is the current measure dimensionless?"	| result |	result := self dimensions = (Dictionary new).! !!HumMeasure methodsFor: 'testing' stamp: 'RichardAlexanderGreen 7/23/2015 11:14'!isPixels	| result |	result := (self units) = 'px'.	^result.! !!HumMeasure methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 6/20/2016 10:04'!@ aHumMeasure 	| point x y |	self assert: (self units = #px)  description: 'Operator only valid for pixels.'.	self assert: (aHumMeasure units = #px)  description: 'Operator only valid for pixels.'.	x := self quantity.	y := aHumMeasure quantity.	self assert: (x isKindOf: Integer).	self assert: (y isKindOf: Integer).	point := x@y.	^point.	! !!HumMeasure methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 12/8/2016 13:44'!compareAngle: aRadianMeasure	"Handle special arithmetic for comparing angles."	| thisAngle thatAngle result |	thisAngle := self quantity.	thatAngle := aRadianMeasure quantity.	result := true.	( (thisAngle sin) closeTo: (thatAngle sin) ) ifFalse: [ result := false ].		( (thisAngle cos) closeTo: (thatAngle cos) ) ifFalse: [ result := false ].	^result.! !!HumMeasure methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 1/19/2017 08:06'!/ aDivisor 	| result divisor |		result := self deepCopy.	( aDivisor isKindOf: HumMeasure )		ifTrue: [divisor := aDivisor].	( aDivisor isKindOf: Duration )		ifTrue: [divisor := HumMeasure quantity: (aDivisor asSeconds) units: #second. ].	( aDivisor isKindOf: Number )		ifTrue: [ result quantity: (self quantity / aDivisor). ^ result. ].		"If the dimensions match, the result is a ratio. But we keep it as a HumMeasure to enable cascade."	self assert: ( divisor isKindOf: HumMeasure ).		( divisor dimensions = self dimensions )		ifTrue: [ result := HumMeasure new quantity: (self quantity) / (divisor quantity). ^result. ].			"Otherwise"			result quantity: (self quantity) / (divisor quantity).	(divisor dimensions)		keysAndValuesDo: [ :unit :exponent |			"Decrement and net-out the dimensions."			result incrementDimensionsAt: unit by: (exponent negated).			].	^result.	! !!HumMeasure methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 3/7/2016 10:50'!cos	self assert: (self isRadian).	^ quantity cos.! !!HumMeasure methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 7/11/2015 18:28'!abs	| measure |	measure := self copy.	measure quantity: (quantity abs).	^measure.! !!HumMeasure methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 12/8/2016 13:36'!= operand 	| result calc q |	( operand isKindOf: HumMeasure) ifFalse: [ ^false ].	"The units of measure must be the same."	((operand dimensions) = (self dimensions)) ifFalse: [^false].	q := self quantity.	calc := HumCalculator new.	calc cases; 		when: [ self units = 'radian' ] then: [ result := self compareAngle: operand ];		when: [ q isKindOf: Float ] then: [ result := q closeTo: (operand quantity) ];		when: [ q isKindOf: Integer ] then: [ result := (q asFloat) closeTo: (operand quantity) ];		when: [ q isKindOf: Array ] 			then: [ result := true.				 (1 to: q size) 						do: [ :i | 							((q at: i) closeTo: ( operand quantity at: i ))								ifFalse: [ ^false. ]							].				 ];		otherwise: [ Error signal: 'quantity not of expected type.' ]	.	^result.	! !!HumMeasure methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 8/3/2015 12:51'!sqrt	| instance |	instance := HumMeasure new.	instance quantity: (self quantity sqrt).	(self dimensions) 		keysAndValuesDo:  [ :dimension :exponent | 			(instance dimensions) at: dimension put: (exponent/2). 			].	^instance.! !!HumMeasure methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 5/4/2013 20:55'!negated	| result |	result := self deepCopy.	result quantity: (self quantity) negated.	^result.! !!HumMeasure methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 4/29/2013 09:43'!- operand 	| result |	self assert: (operand dimensions) = (self dimensions).	result := self deepCopy.	result quantity: (self quantity) - (operand quantity).	^result.	! !!HumMeasure methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 9/22/2013 10:41'!* multiplier 	| result |	result := self deepCopy.	(multiplier isKindOf: Number) 		ifTrue: [ result := self deepCopy. 							result quantity: (self quantity * multiplier).							^result.							].	(multiplier isKindOf: Duration)		ifTrue: [			| m |			m := HumMeasure quantity: (multiplier asSeconds) units: #second.			result := self * m.			^result.			].	result quantity: (self quantity) * (multiplier quantity).	(multiplier dimensions)		keysAndValuesDo: [ :unit :exponent | 			"Increment and net-out the dimensions."			result incrementDimensionsAt: unit by: exponent.			].	^result.	! !!HumMeasure methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 7/13/2015 10:08'!< operand 	| result |	"The units of measure must be the same."	((operand dimensions) = (self dimensions)) ifFalse: [ Error signal: 'Given measures are not comparable.' ].		result := (self quantity) < (operand quantity).	^result.	! !!HumMeasure methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 8/3/2015 13:59'!arcTan: aDenominator 	"Return the arc-tangent (angle) for self divided by aDenominator"	| angle |	self assert: (aDenominator isKindOf: HumMeasure).	self assert: ( self units ) = ( aDenominator units ).		angle := ( self quantity ) arcTan: ( aDenominator quantity ).	^angle.! !!HumMeasure methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 4/29/2016 10:36'!incrementDimensionsAt: aUnit by: anIncrement	"Increment / Decrement dimension exponent by given increment (negative when decrementing).	"	| x |	self assert: (anIncrement isKindOf: SmallInteger ).	x := (self dimensions) at: aUnit ifAbsent: [0].	"Remove zeroed dimensions."	"TODO: THINK: This discards potentially useful information."	" e.g. meter^0 indicates scale or stress or coeficient of expansion ... " 	(( x + anIncrement ) = 0 )				ifTrue:  [ (self dimensions) removeKey: aUnit ]  				ifFalse: [ (self dimensions) at: aUnit put: ( x + anIncrement )].					"TODO: When units cancel (e.g. length/length), find some way to preserve information.	Example: L^0 Degree^-1 should find L^1 Degree^1 in a multiplier. 	Note: The result is the same either way. 	On reflection, I probably allowed units to disappear 	so that dimensions interpreted as Energy would be easier to recognize.	"	! !!HumMeasure methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 4/29/2013 09:45'!+ operand 	| result |	"The units of measure must be the same."	self assert: (operand dimensions) = (self dimensions).	"Make a deep copy to get fresh dimensions and quantity."	result := self deepCopy.	result quantity: (self quantity) + (operand quantity).	^result.	! !!HumMeasure methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 8/29/2015 13:32'!cubed	| x  result |	x := self.	result := x * x * x.	^result.! !!HumMeasure methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 3/7/2016 10:50'!sin	self assert: (self isRadian).	^ quantity sin.! !!HumMeasure methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 12/11/2013 13:00'!> operand 	| result |	"The units of measure must be the same."	((operand dimensions) = (self dimensions)) ifFalse: [^false].		result := (self quantity) > (operand quantity).	^result.	! !!HumMeasure methodsFor: 'converting' stamp: 'RichardAlexanderGreen 8/29/2016 09:02'!asPercent	| measure |	"This is valid only if given measure is dimensionless."	self assert: (self isDimensionless).	measure := HumMeasure quantity: (self quantity / 0.01) units: '%'.	"For this to be useful, 	the caller needs to define what 100 percent means 	with something like:	windowWidth := (1600 px)/(100 percent)."	"TODO: Consider simply returning a scalar: (^self * 0.01)"	^measure.! !!HumMeasure methodsFor: 'converting' stamp: 'RichardAlexanderGreen 4/26/2015 19:20'!as: aSymbol	"Convert to the unit of measure indicated by aSymbol, and renders as String"	| result qty divisor string displayUnits calc |	divisor := 1.0 perform: aSymbol.	self assert: (self dimensions) = (divisor dimensions).	result := self / divisor.	qty := result quantity.	displayUnits := aSymbol asString.	calc := HumCalculator new.	calc cases;		when: [(qty abs) between: 0.1 and: 99999.0 ] then: [  string := ( ( qty printShowingDecimalPlaces: 3), ' ', displayUnits ) ];		when: [(qty abs) between: 0.01 and: 0.1 ] then: [  string := ( ( qty printShowingDecimalPlaces: 4), ' ', displayUnits ) ];		otherwise: [ string := ( ( qty asString                    ), ' ', displayUnits )].	^string.! !!HumMeasure methodsFor: 'converting' stamp: 'RichardAlexanderGreen 11/21/2015 10:15'!asMillimeter	"Convert pixel dimensions to millimeter dimensions"	| px result debug |	(self units = 'meter') ifTrue: [ ^self ].	self assert: (self units = 'px') description: 'This method is dedicated to converting pixel dimensions into millimeters'.	px := (1.0 / (self class pxPerMillimeter)) millimeter.  "There are about 5 px per mm on my laptop."	 "For convenience while debugging. Enlarge those pixels?"	(debug := true ) ifTrue: [ px := 1 millimeter.  ].	result := px * (self quantity).	self assert: ( result isKindOf: HumMeasure ).	^result.! !!HumMeasure methodsFor: 'converting' stamp: 'RichardAlexanderGreen 4/28/2013 13:29'!units	"Render dimensions as a string"	| string append prefix  secondPassNeeded |	append := Dictionary new.	append 		at: 2 put: 'square ';		at: 3 put: 'cubic '.	string := String new.	secondPassNeeded := false.	(self dimensions)		keysAndValuesDo: [ :unit :exponent |					( exponent > 0 ) 						ifTrue: [ 							prefix := append at: exponent ifAbsent: [''].							string := string, prefix, unit, ' '.									]						ifFalse: [ (exponent < 0 ) ifTrue: [ secondPassNeeded := true ] ].					].	secondPassNeeded 		ifTrue: [ 			string := string, 'per '.			(self dimensions)				keysAndValuesDo: [ :unit :exponent |					( exponent < 0 ) 						ifTrue: [ 							prefix := append at: (exponent negated) ifAbsent: [''].							string := string, prefix, unit, ' '.									]					].			].		^string trimBoth.	! !!HumMeasure methodsFor: 'converting' stamp: 'RichardAlexanderGreen 7/10/2015 12:21'!asMillimeters	^self asMillimeter.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumMeasure class	instanceVariableNames: 'unitsSynonyms'!!HumMeasure class methodsFor: 'examples' stamp: 'RichardAlexanderGreen 8/29/2016 08:33'!exampleStudentDebt	"Calculate student debt due to direct costs (educator hours)"	| bs cost classSize gradWage educatorWage bsCost bsCostDollar bsCostNormalized workHoursPerYear gradSalary payBackPeriod flatRate |	bs := HumMeasure quantity: 120 units: #creditHour per: #grad.  "HumMeasure( 120 creditHour per grad )"	cost := HumMeasure quantity: (15*3) units: #educatorHour per: #creditHour. "HumMeasure( 45 educatorHour per creditHour )"	classSize := HumMeasure quantity: 20 units: #student per: #educator.  "HumMeasure( 20 student per educator )"	gradWage := HumMeasure quantity: 30 units: #dollar per: #workHour. "HumMeasure( 30 dollar per workHour )"	educatorWage := HumMeasure quantity: 60 units: #dollar per: #workHour. "HumMeasure( 60 dollar per workHour )"	bsCost := bs * cost / classSize.  "HumMeasure( 270 educatorHour educator per grad student )"	bsCostDollar := bsCost * educatorWage.  	"HumMeasure( 16200 dollar educator educatorHour per workHour student grad )"	bsCostNormalized := HumMeasure quantity: (bsCostDollar quantity) units: #dollar per: #grad. 	"HumMeasure( 16200 dollar per grad )"	workHoursPerYear := HumMeasure quantity: 1800 units: #workHour per: #workYear. 	"HumMeasure( 1800 workHour per workYear )"	gradSalary := gradWage * workHoursPerYear.  	"HumMeasure( 54000 dollar per workYear )"	payBackPeriod := HumMeasure quantity: 10 units: #workYear. 	"HumMeasure( 10 workYear )"	flatRate := bsCostNormalized / (gradSalary * payBackPeriod). 	"HumMeasure( 0.030 per grad )"	"This 3% rate ignores administative costs and infrastructure costs (e.g. amortization of campus)."	self assert: (16200.00 / (54000.00 * 10)) = (flatRate quantity).! !!HumMeasure class methodsFor: 'examples' stamp: 'RichardAlexanderGreen 1/19/2017 08:23'!exampleSlingShotToOrbit	"Calculate kinetic energy and average power for various stages."	| vSound kg eSound acceleration time1 distance1 vNEO eNEO time2 distance2 watt peakWatt protonBoron  mole nReactions |	"Imagine a tube that accelerates craft to speed of sound."	vSound := (1100 feet) / (1 second).		" HumMeasure( 335.280 meter per second )"	kg := 1 kilogram.	eSound := kg * vSound * vSound * 0.5.	" Kinetic Energy = HumMeasure( 56206.241 Joule )"	acceleration := 1 gravity.	time1 := vSound / acceleration.				" HumMeasure( 34.189 second )"	distance1 := acceleration * time1 * time1 * 0.5.	" HumMeasure( 5731.442 meter )"	"Imagine that a ram-jet + rocket accelerates to NEO speed"	vNEO := (10 kilometer) / (1 second).			" HumMeasure( 10000 meter per second )"	eNEO := kg * vNEO * vNEO * 0.5.				" HumMeasure( 50000000 Joule )"	time2 := vNEO / acceleration.						" HumMeasure( 1019.716 second )"	distance2 := acceleration * time2 * time2 * 0.5.	" HumMeasure( 5.098e6 meter ) ".	(distance2 < (5100 kilometer) ).					" = 5100 kilometer"				watt := eNEO / time2.								" HumMeasure( 49033.250 Watt )"	(watt < (50 kilowatt ) ). 								" average power = 50 kilowatt per kilogram of payload"	"However, at peak velocity ... if the rate of acceleration is constant ..."	"F = m*a and e = F*d and power = e/t so power = F*v = m*a*v"	peakWatt := kg * acceleration * vNEO.	" HumMeasure( 98066.500 Watt )"	"A lower watt per kilogram means a lower acceleration and a longer time and a longer distance to NEO."		"What if the power came from proto-boron reaction?"	protonBoron := 8 mev. 								"8 Mev per proton-boron reaction."	nReactions := watt / protonBoron.	mole := nReactions / (1 avogadro). 		" HumMeasure( 6.352422498172116e-8 mole per second )"	mole := eNEO / protonBoron / (1 avogadro).		" HumMeasure( 6.477668213071861e-5 mole )"	"A few grams would launch many tons if the fuel and energy could be used efficiently."! !!HumMeasure class methodsFor: 'examples' stamp: 'RichardAlexanderGreen 5/14/2015 09:55'!exampleLorentzTable	"Display  a table of Lorentz factors for various fractions of light-speed."	|  table |	table := String new.	"Generate values of v/c ==> 0.5 0.75 0.875 . . . "( 1 to: 10  ) 	do: [ :power |  		| zeno v beta gamma s | 		zeno := 2.0 raisedToInteger: ( power  ).		v := 1.0 - (1.0/zeno).          "Incrementally halve the remaining distance to 1.0"		beta := (1.0 - (v*v)) sqrt. 		gamma := 1.0 / beta. 		s := ' v = ',( v printShowingDecimalPlaces: 6)		     , ' beta = ', (beta printShowingDecimalPlaces: 6)		     , ' gamma = ', (gamma printShowingDecimalPlaces: 6).		Transcript cr; show: s. 		table := table, s, String cr.		].   ^table.! !!HumMeasure class methodsFor: 'examples' stamp: 'RichardAlexanderGreen 8/29/2015 15:24'!exampleOrbitTable	"Compute kineticEnergy per kilogram for a Holman transfer Earth-Mars"	| planets table fields bigGM    |		"Initialize table with basic orbital data"	table := Dictionary new.	table 		at: { 'Mercury'. #orbitAu } put: 0.387; at: { 'Mercury'. #orbitYears} put: 0.241;		at: { 'Venus'. #orbitAu } put: 0.723; at: { 'Venus'. #orbitYears} put: 0.615;		at: { 'Earth'. #orbitAu } put: 1.000; at: { 'Earth'. #orbitYears} put: 1.00;		at: { 'Mars'. #orbitAu } put: 1.524; at: { 'Mars'. #orbitYears} put: 1.881;		at: { 'Jupiter'. #orbitAu } put: 5.203; at: { 'Jupiter'. #orbitYears} put: 11.869.	bigGM := (1.0 sunMass) * (1 gravitationalConstant).		planets := #('Mercury' 'Venus' 'Earth' 'Mars' 'Jupiter' ).	planets do: [  :planet |		    | radius circumference orbitTime years auPerYear velocity potentialEnergy  kineticEnergy netEnergy |					radius := (table at: { planet. #orbitAu }).					circumference := (radius au)  * 2 * 3.14159.					orbitTime := table at: {planet. #orbitYears}.					auPerYear := (radius/orbitTime).					years := orbitTime years.					velocity := circumference / years.					"Compute the potential energy due to Sun`s gravity"					potentialEnergy := ( (1.0 kg )* bigGM / (radius au)) negated.					kineticEnergy := (0.5 kg) * velocity * velocity.					netEnergy := potentialEnergy + kineticEnergy.					table						at: { planet. #circumference } put: (circumference as: #au);						at: { planet. #AUperYear } put: auPerYear;						at: { planet. #velocity } put: (velocity as: #kps);						at: { planet. #potentialEnergy } put: (potentialEnergy as: #gigajoule );						at: { planet. #kineticEnergy } put: (kineticEnergy as: #gigajoule );						at: { planet. #netEnergy } put: (netEnergy as: #gigajoule ).			 ].	"Show table"	fields := #( #orbitAu #orbitYears #AUperYear #circumference #velocity #kineticEnergy #potentialEnergy #netEnergy ).		planets do: [  :planet |		Transcript cr; show: planet.		fields do: [ :field | Transcript tab; show: field asString, ': ', ( table at: { planet. field } ) asString ].		 ].! !!HumMeasure class methodsFor: 'examples' stamp: 'RichardAlexanderGreen 1/19/2017 08:18'!exampleStarVoyage	| watt  m v e d t p megaW n nB11 molesB11 gramsB11 kgB11 	 nCNOreactions nGrams kgOfHydrogen cubicMeterPerSecond area  	minCollectingVelocity minCollectingVoverC  years |		watt := 1 watt.				" HumMeasure( 1 Watt )"	m := 1000 kilogram.		" HumMeasure( 1000 kilogram )"    	v := 0.1 lightSpeed.		" HumMeasure( 2.99792458e7 meter per second )"  	e := m * v * v * 0.5.		" HumMeasure( 449377589368408832 Joule )"	d := 4 lightYear.			" HumMeasure( 37842921890323200 meter )"	t := d / v.						" HumMeasure( 1262304000 second )"	years := t / (1 year). 		"HumMeasure( 40.027  ) ==> 40 years one way."	p := e / t.						" HumMeasure( 3.5599791283906955e8 Watt )"	megaW := 3.56e8 / 1e6.	" 356 Megawatt per ton"	n := e / (8 mev). "350599310495773556710666403840 atoms of B11"	nB11 := 350599310495773556710666403840.	molesB11 := nB11 / (1 avogadro quantity). "582183.7997985426"	gramsB11 := molesB11 * 11." 6.404e6"	kgB11 := gramsB11/1e3." 6404.021797783969 -- Houston, we have a problem."	"For each tonne of payload we need over 6 tonne of fuel, 	 and for each tonne of fuel we need fuel to accelerate the fuel."  		"What if we captured Hydrogen in ram scoop and converted them via CNO fusion? "	nCNOreactions := (3.5599791283906955e8 joule)/(25 mev)." 8.887857e19 reactions/second"	"Each reaction requires 4 Hydrogen atoms (4 protons)."	nGrams := 8.887857e19 * 4 / (1 avogadro quantity). "0.000590345"	kgOfHydrogen := nGrams / 1e3.                " 5.90345e-7 per second per tonne"	"But we need to sweep up 8.89e19 Hydrogen atoms per second."	"There is roughly 1e6 Hydrogen atoms per cubic meter in interstellar space "	cubicMeterPerSecond := 8.89e19 / 1e6." 8.89e13"	"If our scoop is 1 km in radius . . . area = pi * R * R "	area := 3.14 * 1e3 * 1e3." 3.14e6 square meters" 	"Our velocity needs to be at least"	minCollectingVelocity := cubicMeterPerSecond / area. "==> 28,312 km/second" 	minCollectingVoverC := minCollectingVelocity / 3e8.  " 0.09 lightSpeed" 	"So this scheme is feasible if artificial CNO fusion is feasible.	 And if the CNO reactor and scoop does not consume too much of our mass budget."	"Feasible at 100% efficiency -- reduced efficiency requires higher collecting velocity."	"Feasible if ignoring collection drag (an inefficiency)."	"Also, somehow the catalyst (Carbor, Nitrogen, Oxygen) has to be retained 	and not blasted out with the reaction mass."	"At this time, we have no idea about how to produce CNO fusion, except perhaps in a H-bomb."! !!HumMeasure class methodsFor: 'examples' stamp: 'RichardAlexanderGreen 4/24/2015 09:49'!zexampleWateringHighPlains	"How much power is required to lift water from Missippi / Missouri to High Plains.	"	| density acre foot acreFoot mass gravity weight lift energy timePeriod watts irrigatedAcres totalWatts |		density := HumMeasure quantity: 1000 units: 'kilogram' per: 'cubic meter'.			" HumMeasure2( 1000 kilogram per cubic meter )"		acre := HumMeasure quantity: 4046.873 units: 'square meter'.		" HumMeasure2( 4046.873 square meter )"			foot := HumMeasure quantity: 0.3048 units: 'meter'.						" HumMeasure2( 0.305 meter )"						acreFoot := acre * foot.																			" HumMeasure2( 1233.487 cubic meter )"				mass := acreFoot * density.																		" HumMeasure2( 1.2334868904e6 kilogram )"																					gravity := HumMeasure quantity: 9.80665 units: 'meter' per: 'square second'.																														" HumMeasure2( 9.807 meter per square second )" 	weight := mass * gravity.																			" HumMeasure2( 1.2096374213741159e7 Newton )"																				lift := HumMeasure quantity: (5000*0.3048) units: 'meter'.		" HumMeasure2( 1524 meter )"	energy := weight * lift.																			" HumMeasure2( 1.8434874301741528e10 Joule )"	timePeriod := HumMeasure quantity: 31449600 units: 'second'.		" HumMeasure2( 31449600 second )"	watts := energy / timePeriod.																	" HumMeasure2( 586.172 Watt )"	irrigatedAcres := 13.6e6." 1.36e7"	totalWatts := watts * irrigatedAcres.		" HumMeasure2( 7.971938927798279e9 Watt ) ==> 8 GigaWatt"	^totalWatts asString.! !!HumMeasure class methodsFor: 'examples' stamp: 'RichardAlexanderGreen 1/19/2017 08:48'!exampleCloudCity	"Suppose we wanted to float a small city (1000 people) using Helium"	|  person personStuff nPeople  payload buoyancy heliumCubic heliumDensity radius pi volume personCubic peopleCubic |	person := (100 kilogram). 	personStuff := (1000 kilogram). "2200 lb (My camping trailer weighs 1600 lb)" 	"allowance for structure, furniture, water, fuel, and air."	nPeople := 1000.	payload := (person + personStuff) * nPeople.	personCubic := (2 meter) * (4 meter) * (5 meter). "HumMeasure( 40 cubic meter )"	peopleCubic := personCubic * nPeople.	buoyancy := (1 kilogram) / (1 cubicMeter).	heliumCubic := payload / buoyancy .  "This is only a first approximation."	"Assumes weight of airframe, propulsion is already covered."	self assert: (heliumCubic = 1.1e6 cubicMeter ).		pi := Float pi.	radius := 120 meter.	volume := (radius * radius * (radius / 5) ) * 4 * pi / 3. "elipsoid volume where ( height = radius / 5 )."		self assert: (volume > (heliumCubic + peopleCubic ) ).	heliumDensity := (1 kilogram * (4.0/14.0) ) / (1 cubicMeter).	self assert: ( volume * buoyancy ) > (payload + (heliumCubic * heliumDensity ) ).	^volume.! !!HumMeasure class methodsFor: 'examples' stamp: 'RichardAlexanderGreen 11/18/2015 09:39'!exampleWateringHighPlains	"How much power is required to lift water from Missippi / Missouri to High Plains.	"	| density acre foot acreFoot mass gravity weight lift energy timePeriod watts irrigatedAcres totalWatts |		density := ( 1000 kilogram ) / ( 1 cubicMeter ).		acre := ( 1 acre ).				foot := ( 1 foot ).	acreFoot := acre * foot.																						mass := acreFoot * density.		" 1.2334868904e6 kilogram "																					gravity := ( 1 gravity ).																														 	weight := mass * gravity.																			" HumMeasure2( 1.2096374213741159e7 Newton )"																				lift := ( 5000 feet ).    				" HumMeasure2( 1524 meter )"	energy := weight * lift.																			" HumMeasure2( 1.8434874301741528e10 Joule )"	timePeriod := (1 year).	"one year as seconds"	watts := energy / timePeriod.																	" HumMeasure2( 586.172 Watt ) ==> pennies per day per acre"	irrigatedAcres := 13.6e6." 1.36e7"	totalWatts := watts * irrigatedAcres.		" HumMeasure2( 7.971938927798279e9 Watt ) ==> 8 GigaWatt"	^totalWatts asString.! !!HumMeasure class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 7/17/2015 16:06'!pxPerMillimeter	| px mm pxPer |	mm := 1 millimeter.	px := (7.0/900.0) inch.            "verticle = HumMeasure( 0.0001975555 meter ) "	px := (11.25/1440.0) inch.  "horizontal = HumMeasure( 0.0001984375 meter )"	pxPer := mm / px.              " 5.03937. . .  on my laptop"	^pxPer quantity asInteger.    "Round to 5 px per mm"! !!HumMeasure class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/3/2015 08:26'!unitsSynonyms	"Provide a dictionary that transforms various unit-of-measure names to standard names."	^ unitsSynonyms ifNil: [ unitsSynonyms := Dictionary new.		unitsSynonyms			at: 'feet' put: 'foot';			at: 'miles' put: 'mile';			at: 'meters' put: 'meter';			at: 'kg' put: 'kilogram';			at: 'km' put: 'kilometer';			at: 'inches' put: 'inch';			at: 'watt' put: 'Watt';			at: 'joule' put: 'Joule';			at: 'amp' put: 'Ampere';			at: 'ft' put: 'foot';			at: 'in' put: 'inch';			at: 'sec' put: 'second';			at: 'none' put: '';			yourself.] ! !!HumMeasure class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 7/9/2015 12:46'!readMe"Wikipedia says:The International System of Quantities (ISQ) is a system based on seven base quantities: length, mass, time, electric current, thermodynamic temperature, amount of substance and luminous intensity. Other quantities such as area, pressure and electrical resistance are derived from these base quantities by clear non-contradictory equations. The ISQ defines the quantities that are measured with the SI units. The ISQ is defined in the international standard ISO/IEC 80000, and was finalised in 2009 with the publication of ISO 80000-1.""Wikipedia:The SI base units and their physical quantities are:metre for lengthkilogram for masssecond for timeampere for electric currentkelvin for temperaturecandela for luminous intensitymole for the amount of substance"! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 8/21/2013 19:21'!quantity: aNumber per: aSymbol 	| measure |	measure := self basicNew.	measure quantity: aNumber per: aSymbol.	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/28/2013 10:47'!quantity: aNumber units: aString 	| instance |	instance := self basicNew.	instance quantity: aNumber units: aString.	^instance.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 5/4/2013 10:42'!britishThermalUnit: aNumber	"Energy - British Thermal Unit (ISO)"	| measure |	measure := self quantity: ( aNumber * 1.0545) units: 'Joule'.	measure dimensions: (Dictionary newFrom: {'kilogram'->1. 'meter'->2. 'second'->(-2).}). 	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 5/4/2013 10:35'!watt: aNumber	"Energy - British Thermal Unit (ISO)"	| measure |	measure := self quantity: ( aNumber ) units: 'Watt'.	measure dimensions: (Dictionary newFrom: {'kilogram'->1. 'meter'->2. 'second'->(-3).}). 	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 5/4/2013 10:40'!meter: aNumber	| measure |	measure := self quantity: (aNumber) units: 'meter'.		^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/29/2013 11:45'!horsePower: aNumber	| measure |	measure := self quantity: ( aNumber * 735.49875 ) units: 'Watt'.	measure dimensions: (Dictionary newFrom: {'kilogram'->1. 'meter'->2. 'second'->(-3).}).	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/13/2014 08:44'!fromString: aString 	"Convert a string of the form '-999 units'"	| measure quantity units|	self assert: (aString isKindOf: String).	quantity := aString asNumber.	units := (HumCalculator given: aString extractAfter: (String space) ) trimBoth.	measure := HumMeasure quantity: quantity units: units.	^measure.			! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/29/2013 10:34'!foot: aNumber	| measure |	measure := self quantity: (0.3048 * aNumber) units: 'meter'.		^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 10/8/2015 15:29'!gravity	"See also: Number>>gravity"	| instance |	instance := 1.0 gravity.	^instance.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 8/24/2015 09:54'!pascal: aNumber	"unit of pressure"	| measure |	measure := HumMeasure quantity: ( aNumber ) units: 'Pascal'.	measure dimensions: (Dictionary newFrom: {'kilogram'->1. 'meter'->(-1). 'second'->(-2). }).	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 1/19/2017 09:03'!lightSpeed: aNumber	"Only makes sense if aNumber < 1."	| measure |	self assert: (aNumber < 1.0).	measure := self quantity: (1e8 * aNumber) units: 'meter' per: 'second'.	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 5/4/2013 10:41'!astronomicalUnit: aNumber	| measure |	measure := self quantity: ( aNumber * 149597870700 ) units: 'meter'.		^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 10/8/2015 15:30'!gravities: gNumber	"See also Number>>gravity"	| instance |	instance := gNumber gravity.	^instance.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/29/2016 08:56'!seconds: aNumber	"Create a HumMeasure instance with unit-of-measure = second"	| instance  |	instance := self quantity: aNumber units: #second.	^instance.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/26/2015 18:29'!joule: aNumber	"Energy - Joule . . . "	| measure |	measure := self quantity: ( aNumber ) units: 'Joule'.	measure dimensions: (Dictionary newFrom: {'kilogram'->1. 'meter'->2. 'second'->(-2).}). 	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 5/4/2013 10:32'!footH2O: aNumber	"foot of water - pressure"	| measure |	measure := HumMeasure quantity: ( aNumber * 2.98898e3 ) units: 'Pascal'.	measure dimensions: (Dictionary newFrom: { }).	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 1/19/2017 09:02'!lightSpeed	| measure |	measure := (1 lightSpeed).	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/29/2013 11:47'!psi: aNumber	"pound per square inch - pressure"	| measure |	measure := self quantity: ( aNumber * 6.894757e3 ) units: 'Pascal'.	measure dimensions: (Dictionary newFrom: {'kilogram'->1. 'meter'->(-1). 'second'->(-2).}). 	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 5/4/2013 10:42'!btu: aNumber	"Energy - British Thermal Unit (ISO)"	| measure |	measure := self britishThermalUnit: aNumber.	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 5/4/2013 10:42'!au: aNumber	| measure |	measure := self astronomicalUnit: aNumber.	^measure.! !!HumMeasure class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 11/24/2014 09:29'!quantity: aNumber units: numeratorUnits per: denominatorUnits	"Create instance with given numerator and denominator units.	Example1:	   milesPerHour := HumMeasure2 quantity: 65 units: 'miles' per: 'hour'.	   feetPerMile := HumMeasure2 quantity: 5280 units: 'feet' per: 'mile'.	   feetPerHour := milesPerHour * feetPerMile.		 secondsPerHour := HumMeasure2 quantity: 3600 units: 'seconds' per: 'hour'.		 feetPerSecond := feetPerHour / secondsPerHour.	"	| instance numerator denominator |	"instance := self basicNew.	instance quantity: aNumber units: numeratorUnits per: denominatorUnits."	numerator := self quantity: aNumber units: numeratorUnits.	denominator := self quantity: 1 units: denominatorUnits.	instance := numerator / denominator.	^instance.		 	 	 	 ! !HumDataFrame subclass: #HumMessage	instanceVariableNames: 'sender receiver whenSent statement nounValues'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumMessage commentStamp: 'RichardAlexanderGreen 4/25/2014 09:56' prior: 0!A Hum Message handles data in-transit between Hum Actors.The Message class will serialize/deserialize messages to/from JSON or XML.For clarity, all Hum Messages represent Hum Action Statements sent between Hum Actors. The components of a message include sender, receiver, when sent, statement, and noun-values. Separation of function -- Messenger / Network / Message:  - The Messenger keeps track of which actors are online and where.- The Messenger also provides logging for playback and debug.- The Network wraps whatever technology is used for actor-to-actor communication.- If an actor is running in test mode, the convention is to start the URI with 'mock:'- The Network will skip the socket business when the URI starts with 'mock:'.- We will probably use Jabber technology for the network.   It provides a number of built-in operators including 'presence' that should come in handy.- The Network will send Hum Messages formatted as JSON objects  so that actors may use a number of different technologies.  (JSON is supported in almost all frameworks.)- In mock (test) mode, the Network will skip translation to/from JSON.- Hum Message will serialize/deserialize to/from JSON or XML. (as needed)		!!HumMessage methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/10/2014 21:25'!whenSent: aTimeStamp 	" "	self assert: (( aTimeStamp isKindOf: TimeStamp ) or: [ aTimeStamp isKindOf: Duration ]).	whenSent := aTimeStamp ! !!HumMessage methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/10/2014 21:26'!statement: aHumStatement 	statement := aHumStatement ! !!HumMessage methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/10/2014 21:21'!sender: aString 	sender := aString.! !!HumMessage methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/5/2014 10:35'!nounValues: associations 	"TODO: Consider: a HumStatement also has nounValues. Which noun values are which?"	nounValues := associations! !!HumMessage methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/10/2014 21:22'!receiver: aString 	receiver := aString ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumMessage class	instanceVariableNames: ''!!HumMessage class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/26/2015 09:34'!to: recipientURI from: senderURI statement: aStatement nounValues: aDictionary	"Create an instance with this data."	| instance |	instance := self basicNew.	instance		sender: senderURI;		receiver: recipientURI;		statement: aStatement;		nounValues: aDictionary;		whenSent: (TimeStamp now). "TODO: Do we need a HumTimeStamp? (Enable simulated time and clear sequence.)"	^instance.	! !Object subclass: #HumNetwork	instanceVariableNames: 'uriToNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumNetwork commentStamp: 'RichardAlexanderGreen 4/25/2014 09:42' prior: 0!The Network wraps whatever technology is used for actor-to-actor communication.Separation of function -- Messenger / Network / Message:  - The Messenger keeps track of which actors are online and where.- The Messenger also provides logging for playback and debug.- The Network wraps whatever technology is used for actor-to-actor communication.- If an actor is running in test mode, the convention is to start the URI with 'mock:'- The Network will skip the socket business when the URI starts with 'mock:'.- We will probably use Jabber technology for the network.   It provides a number of built-in operators including 'presence' that should come in handy.- The Network will send Hum Messages formatted as JSON objects  so that actors may use a number of different technologies.  (JSON is supported in almost all frameworks.)- In mock (test) mode, the Network will skip translation to/from JSON.- Hum Message will serialize/deserialize to/from JSON.		!!HumNetwork methodsFor: 'URI to actor' stamp: 'RichardAlexanderGreen 9/16/2014 09:55'!uriToNode	"Return dictionary that maps a URI to an actual actor instance"	"NOTE: This should only be used in test/local mode. 	(Mode where actors are running in same VM as the messenger.)"	^ uriToNode ifNil: [ uriToNode := Dictionary new. ].! !!HumNetwork methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/4/2015 15:57'!sendAction: anInstruction toURI: recipientURI fromURI: senderURI 	"Send the (action) statement to the given actor."	| actorInstance calc |	self assert: (anInstruction isKindOf: HumInstructionLine).	"Following only works when actor is local."	"TODO: Fix so that it works when actor is remote."	calc := HumCalculator new.	calc cases;		when: [recipientURI beginsWith: 'http:'] then: [self shouldBeImplemented];		when: [recipientURI beginsWith: 'email:'] then: [self shouldBeImplemented];	  otherwise: [	"Assume actor is local."			actorInstance := ( self uriToNode ) at: recipientURI 	                              ifAbsent: [ Error signal: 'Network has no actor for URI: ', recipientURI ].			actorInstance runAction: anInstruction inRole: (anInstruction role) onJob: (anInstruction jobTicket).		].		! !Object subclass: #HumNode	instanceVariableNames: 'myURI myID clock log htmlAgent configuration stepLog'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumNode commentStamp: 'RichardAlexanderGreen 9/7/2014 13:07' prior: 0!A Hum node may send and recieve Hum messages. !!HumNode methodsFor: 'node' stamp: 'RichardAlexanderGreen 12/27/2014 20:28'!configuration	^ configuration ifNil: [Error signal: 'Node has not been configured.'].! !!HumNode methodsFor: 'node' stamp: 'RichardAlexanderGreen 12/28/2014 14:14'!configuration: aHumConfiguration 	self assert: ( aHumConfiguration isKindOf: HumConfiguration ).	configuration := aHumConfiguration.! !!HumNode methodsFor: 'node' stamp: 'RichardAlexanderGreen 12/27/2014 20:04'!messenger	^self configuration messenger.! !!HumNode methodsFor: 'node' stamp: 'RichardAlexanderGreen 9/8/2014 10:29'!checkIn	| |	"Check-in with the messenger."	( self messenger ) registerActor: self atURI: (self uri).! !!HumNode methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/7/2014 13:26'!id: aString 	self assert: (aString isKindOf: String ).	myID := aString.! !!HumNode methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/7/2014 13:08'!id	^myID! !!HumNode methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/7/2014 13:42'!clock: anObjectThatImplementsNow	clock := anObjectThatImplementsNow.	"WARNING: #clock also appears in HumConfiguration."! !!HumNode methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/23/2015 08:17'!asString	^ self id ifNil: [ 'no ID'].! !!HumNode methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/29/2015 10:49'!clock	^ clock ifNil: [clock := DateAndTime "class singleton"].! !!HumNode methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/23/2015 08:21'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title idString|	title := self class name.	idString := self asString.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title;		nextPutAll: '(';		nextPutAll: idString;		nextPutAll: ')'.		! !!HumNode methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/11/2014 15:18'!uri: aURI	self assert: ( aURI isKindOf: String ).	myURI := aURI.	! !!HumNode methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/7/2014 13:26'!uri	^myURI.! !!HumNode methodsFor: 'html' stamp: 'RichardAlexanderGreen 1/2/2015 20:30'!sendHTML: htmlString 	"This is a dummy/mock for testing."	self log add: 'sendHTML: {',htmlString,'}'.	self stepLog add: ('Actor: {', (myID ifNil: ['unknown']),'} is sending html {',htmlString withBlanksCondensed truncate,'}' ).! !!HumNode methodsFor: 'html' stamp: 'RichardAlexanderGreen 11/12/2014 09:29'!htmlAgent	"Return http/html agent implementation.	If none has been set, use self as mock/dummy"	^ htmlAgent ifNil: [ htmlAgent := self ].! !!HumNode methodsFor: 'html' stamp: 'RichardAlexanderGreen 5/27/2015 09:35'!sendHTML: htmlString to: aURL	"This is a dummy/mock for testing. TODO: Make this real."	self log add: 'sendHTML: {',htmlString,'}'.	self stepLog add: ('Actor: {', (myID ifNil: ['unknown']),'} is sending html {',(htmlString withBlanksCondensed truncateWithElipsisTo: 400),'}' ).! !!HumNode methodsFor: 'logging' stamp: 'RichardAlexanderGreen 12/27/2014 20:25'!stepLog	^ stepLog ifNil: [ stepLog := OrderedCollection new.].! !!HumNode methodsFor: 'logging' stamp: 'RichardAlexanderGreen 11/12/2014 09:17'!log	^ log ifNil: [ log := OrderedCollection new ].! !!HumNode methodsFor: 'logging' stamp: 'RichardAlexanderGreen 12/27/2014 20:05'!stepLogDisplay	"Display the step log"	Transcript cr; show: 'Step log from actor: ', (self id asString);cr.	(self stepLog) do: [:s | Transcript show: '. ', s; cr.]! !HumNode subclass: #HumActor	instanceVariableNames: 'roles blackboard'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumActor commentStamp: 'RichardAlexanderGreen 2/18/2016 20:06' prior: 0!An actor is capable of performing one or more roles.Some actors are part of the run-time systems and have particular configuration requirements.In general, an actor needs a connection to a messenger in order to communicate with the system.Most actors also need a connection to a manager so that the manager can assign actions to the actor.Some actors also need a connection to a bookkeeper so that the actor can record utilization.Instance Variables:	myID		<String>	myURI	<String>	messengerURI	<URI>	bookkeeperURI	<URI>	roles				<Collection of: String>	managerURI		<URI>	configuration	<HumConfiguration> -- (2014-09-07 HumActor is subtype of HumConfiguration)		Configuration:. An actor needs to know a messenger. (To simplify, we hide the details in a messenger proxy.). An actor checks-in with a manager/dispatcher.. An actor`s action interface is defined in an ontology. (The ontology might also define an implementation.)!!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 9/21/2014 10:33'!completedAction: anAction inRole: aRoleString onJob: aHumJobTicket 	"Following is first-cut direct call.	When this is debugged, put an asynch wrapper on it.	"	| dispatcher   |	self assert: ( anAction isKindOf: HumInstructionLine).	dispatcher := (self messenger) getActorInstanceFromID: (self dispatcherID).	"TODO: Refactor above - It is using the messengers back door and is only valid in test mode."	self assert: (dispatcher isKindOf: HumDispatcher ).	dispatcher actor: (self id) completedAction: anAction.! !!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 9/16/2014 10:08'!completedInstruction: aHumInstructionLine inRole: aRoleString onJob: aHumJobTicket 	"Following is first-cut direct call.	When this is debugged, put an asynch wrapper on it.	"	| dispatcher   |	self assert: ( aHumInstructionLine isKindOf: HumInstructionLine).	dispatcher := (self messenger) getActorInstanceFromID: (self dispatcherID).	"TODO: Refactor above - It is using the messengers back door and is only valid in test mode."	self assert: (dispatcher isKindOf: HumDispatcher ).	dispatcher actor: (self id) completedAction: aHumInstructionLine.! !!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 10/20/2016 10:16'!runInstruction: anInstruction inRole: aRole onJob: aJobTicket	"Execute, simulate, or log the given statement"	| charge aStatement |	self assert: ( anInstruction isKindOf: HumInstructionLine ).	aStatement := anInstruction statement.	"If instruction role is not one of my roles, delegate the instruction."	( anInstruction role > '' )		ifTrue: [(self roles includes: anInstruction role) 								ifFalse: [ ^self delegateAction: anInstruction toRole: anInstruction role onJob: aJobTicket ].						].	"If statement has a translation (assume Smalltalk), run the translation."			( aStatement translation notNil ) 		ifTrue: ["Execute in Smalltalk -- TODO: What if translation is for Erlang/Java/...?"			Compiler evaluate: (aStatement translation) for: self logged: false.			"Charge to job ticket"				charge := HumMeasure quantity: 1 units: #step.   			aJobTicket appendCharge: charge forAction: aStatement byActor: myID inRole: aRole onJob: aJobTicket.			"Tell Dispatcher that we completed action normally."			self completedInstruction: anInstruction inRole: aRole onJob: aJobTicket.			^self.			]		ifFalse: [ "Simulate execution"			"Append to log"			| s |			s := aStatement source trimBoth.			( s = '' ) ifFalse: [ "Do not simulate execution of blank or comment-only statements."				self stepLog add: ('Actor: {', myID,'} is doing: {', s, '}' ). 				( aStatement nounValues )					keysAndValuesDo: [ :noun :value | stepLog add: ('. with: ', noun, ' = ', value asString). ].				"Charge to job ticket"					charge := HumMeasure quantity: 1 units: #step.   				aJobTicket appendCharge: charge forAction: aStatement byActor: myID inRole: aRole onJob: aJobTicket.				].			^ self.			].	Error signal: 'Statement type not handled.'.! !!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 11/3/2014 08:39'!checkOut	"Tell the Dispather that this actor is no longer available for assignments."	| statement jobTicket instruction |	"Don't check-in with self."	(self isKindOf: HumDispatcher ) ifTrue: [^self.].	"Coordinator is not dispatched by Dispatcher"	(self isKindOf: HumCoordinator ) ifTrue: [^self.].	"Send check-out message to my Dispatcher."		statement := HumStatement source: 'Check-out actor.'.	statement role: #dispatcher;	          noun: 'actor' value: myURI;	   translation: ('self checkOutActor: ', myID quoted, ' at: ', myURI quoted).		jobTicket := HumJobTicket title: 'checkOut:',myID.	instruction := HumInstructionLine new.	instruction	  role: #dispatcher;		statement: statement.	self delegateAction: instruction toRole: #dispatcher onJob: jobTicket.! !!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 1/23/2015 13:30'!checkIn	| statement quotedRoles instruction jobTicket |	"First, check-in with the messenger."	"TODO: REFACTOR THIS CALL.  ---  Why? Why? "	( self messenger ) registerActor: self atURI: (self uri).	"Don't check-in with self."	( self isKindOf: HumDispatcher ) ifTrue: [^self.].	"Coordinator is not dispatched by Dispatcher"	( self isKindOf: HumCoordinator ) ifTrue: [^self.].	"Allow Dialog Agents to be dispatched for Push messages."	( self isKindOf: HumDialogAgent ) 		ifTrue: ["Continue"].	"We don't expect Scribes here. 	A Dialog Agent should dispatch its own Scribe."	( self isKindOf: HumScribe )	ifTrue: [ Error signal: 'We don`t expect a Scribe checkIn.'].	"Send check-in message to my Dispatcher."	quotedRoles := ''.	( self roles )		do: [ :role | quotedRoles := quotedRoles, ' ', role quoted ].			statement := HumStatement source: 'Check-in actor with roles.'.	statement role: #dispatcher;	          noun: 'actor' value: myURI;	          noun: 'roles' value: quotedRoles;	   translation: ('self checkInActor: ', myID quoted, ' at: ', myURI quoted, 'withRoles: #(', quotedRoles, ')').		jobTicket := HumJobTicket title: 'checkIn:',myID.	instruction := HumInstructionLine new.	instruction	  role: #dispatcher;		statement: statement;		jobTicket: jobTicket.	self delegateAction: instruction toRole: #dispatcher onJob: jobTicket.	! !!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 9/22/2014 14:40'!delegateAction: anAction toRole: aRole onJob: aJobTicket	"Delegate action to another role."	| |		(self roles includes: aRole)		ifTrue: [ "If the role is one of my own, do action myself."			self runAction: anAction inRole: aRole onJob:  aJobTicket ]		ifFalse: ["Otherwise have the dispatcher send it to some actor that knows the role."			anAction jobTicket: aJobTicket.			(self messenger) sendAction: anAction toID: (self dispatcherID) fromID: myID. "STUB"].	! !!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 7/18/2016 08:24'!runAction: anAction inRole: aRole onJob: aHumJobTicket	"Run the action frame named ..." 	| ontology lines |	self assert: (anAction isKindOf: HumInstructionLine ).	ontology := self configuration ontology.	self assert: (ontology frames notEmpty).	"TODO: Ontology has instruction sequence, but lacks frame lines."	lines := ontology instructionsForRole: aRole action: anAction.	( lines size > 0 ) 		ifFalse: [Error signal: 'Action: {',anAction source,'} is not defined for role: {',aRole,'}.'].	( lines select: [:line | line isKindOf: HumInstructionLine ] )		do: [ :frameLine | 		self runInstruction: frameLine inRole: aRole onJob: aHumJobTicket.		].	"Tell Dispatcher that we completed action normally."	self completedAction: anAction inRole: aRole onJob: aHumJobTicket.! !!HumActor methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 3/25/2015 10:30'!zrunInstruction: anInstruction inRole: aRole onJob: aJobTicket	"Execute, simulate, or log the given statement"	| charge aStatement |	self assert: ( anInstruction isKindOf: HumInstructionLine ).	aStatement := anInstruction statement.	"If instruction role is not one of my roles, delegate the instruction."	( anInstruction role > '' )		ifTrue: [(self roles includes: anInstruction role) 								ifFalse: [ ^self delegateAction: anInstruction toRole: anInstruction role onJob: aJobTicket ].						].	"If statement has a translation (assume Smalltalk), run the translation."			( aStatement translation notNil ) 		ifTrue: ["Execute in Smalltalk -- TODO: What if translation is for Erlang/Java/...?"			Compiler evaluate: (aStatement translation) for: self logged: false.			"Charge to job ticket"				charge := HumMeasure quantity: 1 units: #step.   			aJobTicket appendCharge: charge forAction: aStatement byActor: myID inRole: aRole onJob: aJobTicket.			"Tell Dispatcher that we completed action normally."			self completedInstruction: anInstruction inRole: aRole onJob: aJobTicket.			^self.			]		ifFalse: [ "Simulate execution"			"Append to log"			self stepLog add: ('Actor: {', myID,'} is doing: {',aStatement source,'}' ).			( aStatement nounValues )				keysAndValuesDo: [ :noun :value | stepLog add: ('. with: ', noun, ' = ', value asString). ].			"Charge to job ticket"				charge := HumMeasure quantity: 1 units: #step.   			aJobTicket appendCharge: charge forAction: aStatement byActor: myID inRole: aRole onJob: aJobTicket.			^ self.			].	Error signal: 'Statement type not handled.'.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/7/2014 13:55'!ontology	^self configuration ontology.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/21/2013 16:04'!roles	(roles isNil and: [self class = HumActor]) ifNil: [ Error signal: 'Actor {', myID,'} has no role.' ].	^roles ifNil: [ roles := { self class name. }].! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/24/2015 09:57'!updateBlackBoardFromBlackBoard: aHumBlackBoard 	"Update my blackboard with entries from callers blackboard."	| |	self halt. "I want to check where this happens."	"Delegate this to Blackboard. Note: Subtypes might want to override."	( self blackboard ) updateBlackBoardFromBlackBoard: aHumBlackBoard. ! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/26/2012 20:10'!roles: anArray 	self assert: ( anArray isKindOf: Array ).	roles := anArray.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/23/2015 09:05'!blackboard: aHumBlackBoard 	self assert: (aHumBlackBoard isKindOf: HumBlackBoard).	blackboard := aHumBlackBoard! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2014 13:25'!dispatcherID	^self configuration dispatcherID.! !!HumActor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/18/2012 10:40'!blackboard	^ blackboard ifNil: [ blackboard := HumBlackBoard new. ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumActor class	instanceVariableNames: ''!!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 9/14/2014 13:32'!dispatcherID: myID uri: myURI configuration: aHumConfiguration 	| instance |	instance := HumDispatcher configuration: aHumConfiguration.	instance id: myID; uri: myURI. 	^instance. ! !!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 7/2/2014 10:42'!coordinatorID: myID uri: myURI goal: aGoalStatementString dialog: aHumDialogAgent configuration: aHumConfiguration 	| instance |	instance := HumCoordinator configuration: aHumConfiguration.	instance  id: myID; 	          uri: myURI; 					 goal: aGoalStatementString; 	    dialogAgent: aHumDialogAgent.	^instance.! !!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 7/2/2014 10:34'!workerID: workerID uri: workerURI roles: arrayOfRoleNames configuration: aHumConfiguration 	| instance |	instance := self configuration: aHumConfiguration.	instance id: workerID; 					uri: workerURI; 					roles: arrayOfRoleNames.	^instance.! !!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/23/2015 09:07'!dialogID: myID uri: myURI client: clientURI configuration: aHumConfiguration	| instance |	instance := HumDialogAgent configuration: aHumConfiguration.	instance  id: myID; 					 uri: 'URI:',myID; 					blackboard: (HumBlackBoard worldbase: (aHumConfiguration getWorldBase));				 client: myID.	^instance.	! !!HumActor class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 7/2/2014 10:43'!bookkeeperID: myID uri: myURI configuration: aHumConfiguration 	| instance |	instance := HumBookkeeper configuration: aHumConfiguration.	instance id: myID; uri: myURI.	^instance. ! !!HumActor class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/7/2014 13:13'!configuration: aHumConfiguration 	| instance |	instance := self basicNew.	instance configuration: aHumConfiguration.	instance initialize.	^instance.! !HumActor subclass: #HumBookkeeper	instanceVariableNames: 'jobTickets'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumBookkeeper commentStamp: 'RichardAlexanderGreen 9/19/2012 11:34' prior: 0!The bookkeeper records resource utilization and expenditure statistics.It provides the basic data needed for cost accounting and system utilization analysis.Instance Variables:	jobTickets	<OrderedCollection>!!HumBookkeeper methodsFor: 'sums' stamp: 'RichardAlexanderGreen 12/14/2015 11:58'!chargesBy: attribute	"Produce dictionary of sums for given subdivision type."	| sums |	sums := Dictionary new.	jobTickets 		do: [ :ticket |			| charges |			charges := ticket charges.						charges do: [:charge |				| key sumBy units amount x |				amount := charge at: 'measure'.				sumBy := charge at: attribute.				units := amount units.				key := sumBy,':',units.				x := sums at: key 				    ifAbsent: [ |q| q := amount copy quantity: 0. q].				x := x + amount.				sums at: key put: x.				].			].		^sums.! !!HumBookkeeper methodsFor: 'sums' stamp: 'RichardAlexanderGreen 12/14/2015 11:59'!chargesByActor	"Produce dictionary of sums keyed by actor."	| sums |	sums := self chargesBy: 'ID'.		^sums.! !!HumBookkeeper methodsFor: 'sums' stamp: 'RichardAlexanderGreen 12/14/2015 12:01'!chargesByMetric	"Produce dictionary of sums keyed by unit of measure. "	| sums |	sums := Dictionary new.	jobTickets 		do: [ :ticket |			| charges |			charges := ticket charges.			charges do: [:charge |				| key sumBy units amount x |				amount := charge at: 'measure'.				units := amount units.				sumBy := 'total'.				key := sumBy,':',units.				x := sums at: key 				    ifAbsent: [ |q| q := amount copy quantity: 0. q].				x := x + amount.				sums at: key put: x.				].			].		^sums.! !!HumBookkeeper methodsFor: 'sums' stamp: 'RichardAlexanderGreen 12/14/2015 11:59'!chargesByAction	"Produce dictionary of sums keyed by action."	| sums |	sums := self chargesBy: 'action'.	^sums.! !!HumBookkeeper methodsFor: 'sums' stamp: 'RichardAlexanderGreen 12/14/2015 12:01'!chargesByRole	"Produce dictionary of sums keyed by role-name.."	| sums |	sums := self chargesBy: 'role'.	^sums.! !!HumBookkeeper methodsFor: 'sums' stamp: 'RichardAlexanderGreen 12/14/2015 12:00'!chargesByJob	"Produce dictionary of sums keyed by job."	| sums |	sums := self chargesBy: 'job'.	^sums.! !!HumBookkeeper methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2012 11:02'!jobTickets	^ jobTickets ifNil: [ jobTickets := OrderedCollection new. ].! !!HumBookkeeper methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/14/2015 12:02'!recordJobTicket: aHumJobTicket 	"Add the given job ticket to my collection of job tickets."	(self jobTickets) add: aHumJobTicket.! !HumActor subclass: #HumCoordinator	instanceVariableNames: 'goal context remainingConditions dialogAgent planFrames jobTicket'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumCoordinator commentStamp: 'RichardAlexanderGreen 2/18/2016 20:07' prior: 0!The coordinator tracks the execution state of a plan.The state includes which conditions are satisfied, which plan frames have been completed, the accumulated resource utilization associated with the execution, and any exceptions that were encounterd or are currently pending resolution.Instance Variables:	ontology	<HumOntology>	goal	<ProtoObject | PseudoContext>	context	<Object>	remainingConditions	<Integer>	dialogAgent	<ProtoObject | PseudoContext>	planFrames	<Collection | PTEnumerable | PragmaCollector>!!HumCoordinator methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 4/9/2015 10:50'!runAction: anInstructionLine 	"Run the given action statement."	| debug |	debug := false. 	debug ifTrue: [ Transcript cr; show: 'HumCoordinator ',myID,' is running { ', anInstructionLine source, ' }'.].	"TODO: Track work-in-progress so that run-time instrumentation can view."	anInstructionLine jobTicket: (self jobTicket).	(self messenger) sendAction: anInstructionLine toID: (self configuration dispatcherID) fromID: myID.	! !!HumCoordinator methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 7/17/2013 10:33'!runPlan	"Run my plan.	"	|  result |	self runPlanSetup.	result := self runPlanFrameForCondition: goal.	result 		ifFalse: [ Error signal: 'Attempt to run plan for goal: {',goal,'} has failed.'].! !!HumCoordinator methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 4/9/2015 10:46'!runPlanFrameForCondition: aGoalString	"This visits the subtree and runs each frame that is ready to run.	TODO: RUN ACTIONS IN PARALLEL.	TODO: Track work in progress.	TODO: Write several tests.	"	| rootFrame result |	"If the condition is already satisfied (not in remainingConditions set), we can skip and return immediately."	remainingConditions detect: [:condition | condition sameAs: aGoalString ] ifNone: [  ^true.].	"Get the root of this subtree."	rootFrame := (self ontology) getPlanFrameForGoal: aGoalString.	"REFACTOR: The rootFrame does not know if it is runnable. But the Coordinator knows."	( self isPlanFrameRunnable: rootFrame )		ifTrue: ["Run its actions and then declare the goal satisfied"			"Run actions"			(rootFrame actionStatements) 				do: [ :action | self runAction: action.  ].			"Declare goal satisfied"			self conditionIsSatisfied: rootFrame goal.			^true.	 "Indicates something was runnable. See check below."			] "ifTrue"		ifFalse: [ "Try to satisfy the preconditions."			result := false.			( rootFrame preconditions )					do: [ :precondition |						| preconditionString stepResult |						preconditionString := precondition statement source.						"Call recursively on preconditions."						stepResult := self runPlanFrameForCondition: preconditionString.						result := result | stepResult.  "Boolean"						]. "do"					"Check post condition 					-- At least one precondition in the tree should be runnable on each iteration."					result ifFalse: [ Error signal: 'Nothing in the subtree was runnable!!']					]."ifFalse"						"Fall through to here when goal frame is not runnable and we ran preconditions.		Now try again."		((self remainingConditions ) isEmpty) 			ifTrue: [ Error signal: 'Remaining conditions should not be empty in this recursive loop.'.				"In this context,				 the remaining conditions should include the original goal, 				 and therfore, not be empty yet."				].		result := self runPlanFrameForCondition: aGoalString.		^result.			! !!HumCoordinator methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 9/22/2014 10:45'!runPlanSetup	"Setup to run a plan:	1. Assure plan is runnable.	2. Populate the remaining conditions collection. ()	3. Initialize the job ticket?	TODO: WATCH OUT: instance variables passed via the back-door 	"	| |	self assert: (goal isKindOf: HumStatement ).	self planIsRunnable ifFalse: [ Error signal: 'Plan is not runnable for goal: ', goal ].	planFrames := self ontology collectPlanFramesForGoal: (self goalStatement).  "Populate the remaining conditions collection"	(self remainingConditions) add: goal.	jobTicket := HumJobTicket title: goal.	planFrames		do: [ :frame |				( frame preconditions )						do: [ :precondition |								remainingConditions add: (precondition statement).							].			].! !!HumCoordinator methodsFor: 'events-registering' stamp: 'RichardAlexanderGreen 4/9/2015 10:42'!conditionIsSatisfied: precondition 	"Note that condition is satisfied.	Then runnable frames may change.	If all conditions have been satisfied, the goal is achieved.	THINK: Should the goal itself be in remainingConditions collection?	"	| debug |	(debug := false) ifTrue: [Transcript cr; show: 'HumCoordinator conditionIsSatisfied: ', precondition asString. ].	self assert: ( precondition isKindOf: HumStatement ).		precondition isSatisfied: true.	(self remainingConditions) 		remove: precondition 		ifAbsent: [Error signal: 'absent condition: ', precondition "statement" source]! !!HumCoordinator methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 9/14/2014 13:50'!planIsRunnable	"TODO: ADD NEEDED CHECKS TO THIS STUB."	| |	context := dialogAgent.	self assert: ( context isKindOf: HumDialogAgent ).	self assert: ( goal isKindOf: HumStatement ).	"		Additional Preconditions:	. All nouns in the goal statement have values on the dialog agent's' blackboard.	. The frame collection is complete.	. All the roles in the action statements are known (checked-in) to the Dispatcher.	. All action statements are defined in the ontology.	"	"TODO: DANGER -- THIS IS A STUB!!!!!!"	^true.! !!HumCoordinator methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 12/14/2015 12:07'!isPlanFrameRunnable: aHumFrame4Plan	"Determine if the given plan frame is runnable.	To be runnable, it`s preconditions must all be satisfied.	TODO: This implementation is only correct where the noun values do not affect.	WARNING: Assumes: All instances of the condition have the same noun values.	" 	(aHumFrame4Plan preconditions)		do: [ :precondition | 				((self remainingConditions) includes: (precondition statement) )						ifTrue: [^false]						].		^true				! !!HumCoordinator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2013 11:23'!dialogAgent: aHumDialogAgent 	"Concept: The dialog agent provides noun values 	 as needed to populate plan and action statements."	self assert: ( aHumDialogAgent isKindOf: HumDialogAgent ).	dialogAgent := aHumDialogAgent.! !!HumCoordinator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/2/2014 10:42'!coordinatorID: anID uri: aURI goal: aGoalStatementString dialog: aHumDialogAgent configuration: aHumConfiguration	self configuration: aHumConfiguration.		self id: anID.	self uri: aURI.	self goal: aGoalStatementString.	self dialogAgent: aHumDialogAgent.			^self.	! !!HumCoordinator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/3/2012 17:33'!context: aHumActor	context := aHumActor.! !!HumCoordinator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/22/2014 10:31'!jobTicket	^ jobTicket ifNil: [ jobTicket := HumJobTicket title: goal ].! !!HumCoordinator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/23/2013 09:20'!remainingConditions	^ remainingConditions ifNil: [ remainingConditions := Set new.] .! !!HumCoordinator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/17/2013 12:55'!goal: aStatement	goal := nil.	(aStatement isKindOf: HumStatement ) ifTrue: [ goal := aStatement. ^self ].	( aStatement isKindOf: String )		ifTrue: [ "Get the goal statement from the root frame."			| rootFrame statement |			rootFrame := (self ontology) getPlanFrameForGoal: aStatement.			statement := rootFrame goal.			self assert: (statement isKindOf: HumStatement).			goal := statement.			^self.			].	! !!HumCoordinator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/8/2013 10:37'!goalStatement	"Translate goal string to goal statement"	"TODO: THERE IS SOMETHING WRONG HERE."	| rootFrame statement |	rootFrame := ((self ontology) getPlanFrameForGoal: goal).	statement := rootFrame goal.	self assert: (statement isKindOf: HumStatement ).	^ statement. ! !!HumCoordinator methodsFor: 'logging' stamp: 'RichardAlexanderGreen 12/14/2015 12:09'!getActionSequence	"Parse the job ticket to show the sequence of actions."	| listOfActions |	listOfActions := self jobTicket getActionSequence.	^listOfActions.! !HumActor subclass: #HumDialogAgent	instanceVariableNames: 'clientURI clientID contextStack scribeProxy dialogAgentOntology'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumDialogAgent commentStamp: 'RichardAlexanderGreen 8/20/2015 15:31' prior: 0!A Dialog Agent in a subtype of Actor.For that reason, it is in the Hum-RunTime package rather than the Hum-UI package.A Dialog-Agent responds to client/user inputs according to the dialog vignettes in an ontology.A Scribe implements a (physical) user interface.A Scribe interprets user interface input (gestures)  and sends those inputs to the Dialog Agent  as standardized vignette inputs. See HumScribe documentation.A Dialog has a history.The history may be represented by a sequence of User Inputs with corresponding system responses.The history has also caused the context 'stack' to be what it is.Hence:. A Dialog has a contextStack.. A Dialog has a (log?) history of prior stimulus->response events.. ?? Do the response entries include goals that were started or just text-replies ??Design Question: Is the Dialog a separate class from the Dialog Agent?The Scribe and Dialog-Agent communicate via the Messenger.The Scribe may be client-side or server-side.In an HTML environment, the Scribe will act like an HTML web servlet.The Dialog-Agent will typically be server-side.The Messenger maintains its own logs for replay and debug purposes.But that log should not be confused with the Dialog history because it has different semantics.!!HumDialogAgent methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 2/26/2015 15:45'!extractFieldValuesFromUserInput: inputString pattern: patternString 	"Extract values from user input and post to my blackboard. 	"	| inputTokens patternTokens xInput xPattern calc input pattern entityName attributeName attributeValue |		(patternString includes: $[ ) ifFalse: ["There is no slot in this pattern." ^self].		inputTokens := HumCalculator findTokensInString: inputString.	inputTokens := HumCalculator removeNoiseWordTokensFrom: inputTokens.	 	patternTokens := HumCalculator findTokensInString: patternString.	patternTokens := HumCalculator removeNoiseWordTokensFrom: patternTokens.		xInput := 1.	xPattern := 1.	calc := HumCalculator new.	[ (xInput <= inputTokens size) and: [xPattern <= patternTokens size] ]		whileTrue: [				input := inputTokens at: xInput.				pattern := patternTokens at: xPattern.				calc cases;					when: [ input sameAs: pattern] 						then: [ xInput := xInput + 1. xPattern := xPattern + 1.];					when: [ pattern = '[' ] 						then: [ "Extract input value and push into blackboard."							entityName := patternTokens at: xPattern + 1.							attributeName := patternTokens at: xPattern + 2.							self assert: ( ']' = (patternTokens at: xPattern + 3)).							xPattern := xPattern + 4. 							pattern := patternTokens at: xPattern.							attributeValue := ''.							[(xInput <= inputTokens size) and: [input ~= pattern]] 								whileTrue: [attributeValue := attributeValue, ' ', input.									xInput := xInput + 1.									input := inputTokens at: xInput.									].							 self blackboard setEntityName: entityName 							                     attribute: attributeName 							                       toValue: (attributeValue trimBoth).							];					when: [ pattern = '*'] then: [self shouldBeImplemented];					otherwise: [Error signal: 'How did we get here?'].			].	! !!HumDialogAgent methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 12/29/2014 08:46'!dialogOntologySourceStream	"Return a stream of frames defining Dialog Agent actions."	| string stream peekCharacter |	string := '===Role: DialogAgent.Action: Ask view-name.. Get view-name from callers-ontology.. Translate view-name giving html-form-panel.. Scribe: Send html-form-panel to client-browser.. (DialogAgent black board will be updated.)To: Get view-name from callers-ontology..To: Translate view-name giving html-string..==='.	stream := ReadWriteStream with: string.	stream position: 0.	peekCharacter := stream peek.	self assert: (peekCharacter = $= ).	^stream.! !!HumDialogAgent methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 1/8/2015 10:24'!sayToClient: aHumMarkupLine 	"Say something to the client. 	 Subtypes will override."	| systemResponse |	systemResponse := aHumMarkupLine source. 	[systemResponse includes: $[ ]			whileTrue: [ systemResponse := self fillInSlotIn: systemResponse ].	self assert: (systemResponse includes: $[) not.	(self stepLog) add: ('S: ', systemResponse ).	"Delegate actual UI to my Scribe."	(self scribeProxy) systemSays: systemResponse. 	! !!HumDialogAgent methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 10/20/2016 10:29'!runAction: anAction inRole: aRole onJob: aHumJobTicket	"Dialog Agent knows: 'Ask view', 'Show view', 'Push context ...'" 	| calc source |	self assert: (aRole = 'DialogAgent').	(anAction isKindOf: String) 		ifTrue: [source := anAction].	(anAction isKindOf: HumInstructionLine)		ifTrue: [source := anAction statement source].	self assert: (source isKindOf: String).	( source trimBoth = '' ) ifTrue: [ ^self ].	self stepLog add: ('DialogAgent: {', myID,'} is doing: {',source,'}' ).	calc := HumCalculator new.	calc cases;		when: [source sameAs: '' ] then: ["Blank line or comment line."];		when: [source beginsWith: 'Ask ']			then: [ self askView: (calc given: source extractAfter: 'Ask ' ).];		when: [source beginsWith: 'Show ']			then: [ self showView: (calc given: source extractAfter: 'Show ' ).];		when: [source beginsWith: 'New ']			then: [ self newEntity: (calc given: source extractAfter: 'New ' ).];		"TODO: Give some thought to the interaction of business process roles and views."		when: [source beginsWith: 'Push context ']			then: [ self pushContext: (calc given: source extractAfter: 'Push context ' ).];		when: [source beginsWith: 'Push ']			then: [ self pushContext: (calc given: source extractAfter: 'Push ' ).];		otherwise: [Error signal: 'Action not recognized: {',source,'}'].				! !!HumDialogAgent methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 12/16/2015 10:08'!fillInSlotIn: aMarkupString 	" Fill-in first [entity attribute] dialog-response-slot with data from blackboard.	  Dialog Agent (myself) will call me until all slots are filled.	"	| fieldName entityName attributeName fieldValue result before after |	fieldName := (HumCalculator given: aMarkupString extractBetween: '[' and: ']') withSeparatorsCompacted.	"Break the field name into entityName and attributeType."	self assert: (fieldName includes: $  ) description: 'In this context, the entity must always be named.'.	entityName := (HumCalculator given: fieldName extractUpto: ' ') trimBoth.	attributeName := (HumCalculator given: fieldName extractAfter: ' ') trimBoth.	fieldValue := self blackboard getEntityName: entityName attribute: attributeName.	"Insert field-value into markup string."	before := HumCalculator given: aMarkupString extractUpto: '['.	after  := HumCalculator given: aMarkupString extractAfter: ']'.	result := before, (fieldValue ifNil: ['*** Unknown ***']), after.	^result.! !!HumDialogAgent methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 12/29/2014 07:36'!dialogAgentOntology	"Return ontology with Dialog Agent actions defined and executable in Smalltalk."	^ dialogAgentOntology ifNil: [dialogAgentOntology := self buildDialogAgentOntology].! !!HumDialogAgent methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 12/29/2014 08:34'!buildDialogAgentOntology	"Return ontology with Dialog Agent actions defined and executable in Smalltalk."	| ontology pa |		pa := HumProgrammersAssistant new.	ontology := pa loadOntologyFromTextStream: (self dialogOntologySourceStream).	^ontology. ! !!HumDialogAgent methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 2/20/2015 10:33'!showView: aViewName	| ontology viewFrame |	ontology := self ontology. 	viewFrame := ontology getViewFrame: aViewName.	"Delegate display to my scribe."	(self scribeProxy) showView: viewFrame withBlackBoard: (self blackboard).! !!HumDialogAgent methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 7/19/2016 11:47'!interpretVignette: aHumFrame4Vignette withInput: aUserInput	"Send response lines. Execute response instructions."	| responseLines responseInstructions jobTicket calc |	responseLines := aHumFrame4Vignette responseLines.	self assert: (responseLines size > 0).	responseInstructions := aHumFrame4Vignette instructionLines.	self assert: (responseInstructions size >= 0).	"Extract any values in user input and update blackboard.	NOTE: The all patterns must have identical slots."	self extractFieldValuesFromUserInput: aUserInput pattern: (aHumFrame4Vignette patterns at: 1).	"Interpret the response lines (fill in any value slots as needed)."	responseLines 		do: [ :responseLine | 			"Interpret markup."			self sayToClient: responseLine. ].	"If there are no instructions in the response, we are done."		responseInstructions 		ifEmpty: [^self].	"TODO: What is the rationale for job-ticket in this context?"		jobTicket := HumJobTicket title: 'jobTicket who:',clientID,' when:', (self clock asString),' why: ',#dialog.	"Interpret any instructions found in the response."	calc := HumCalculator new.	responseInstructions		do: [ :instructionLine |			| role |			role := instructionLine role.			calc cases;				when: [ role isNil ] "TODO: Using nil value as a signal is dangerous."					then: ["Dialog Agent instruction - I do it."						Error signal: 'Why is this different from blank role?'.						self runInstruction: instructionLine inRole: role onJob: jobTicket.];				when: [ role = '' ] 					then: ["Dialog Agent instruction - I do it."						self runAction: instructionLine inRole: 'DialogAgent' onJob: jobTicket.];				when: [ role sameAs: 'Goal' ] 					then: ["Start a plan running"						| coordinator |						coordinator := HumActor 															coordinatorID: myID,'-coordinator' "TODO: Distinguish multiple coordinators"															uri: myURI 															goal: (instructionLine statement) 															dialog: self 															configuration: (self configuration).						coordinator checkIn. 						coordinator runPlan. "TODO: [1] Fork this. [2] Figure out: What if the dialog agent goes down?"								];				when: [ role > '' ]					then: ["Delegated instruction"						self delegateAction: instructionLine toRole: role onJob: jobTicket.];			  otherwise: [ Error signal: 'How did we get here?'].			].! !!HumDialogAgent methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 2/20/2015 10:38'!askView: aViewName	| ontology viewFrame |	ontology := self ontology. 	viewFrame := ontology getViewFrame: aViewName.	"Delegate display to my scribe."	(self scribeProxy) askView: viewFrame withBlackBoard: (self blackboard).! !!HumDialogAgent methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 6/29/2015 11:07'!clearEntity: entityType	"Clear prior data in my blackboard for the given entity type."	"WARNING: Assumes dialogs vignettes only address one instance of an entity at a time."	"TODO: I think there is a UX problem here. This behavior may confuse users."	"PROBLE: It makes no sense to clear a real-world entity. 	             This occurs in the context of a data-entry pane."	self blackboard clearEntity: entityType. ! !!HumDialogAgent methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 12/28/2015 13:41'!clientSays: aString 	"Match user utterance to vignette patterns in the ontology	and return the vignette frame with the best match.	"	| bestMatch |
	"We need a context stack to define the best match."	self assert: ( self contextStack isKindOf: Stack ).	self assert: ( self contextStack notEmpty ).	"Delegate the search to the ontology."	bestMatch := self ontology findBestMatchingVignetteForInput: aString inContextStack: (self contextStack).	"TODO: Now that I've got a vignette (or not), what do I do with it?"	self assert: ( bestMatch isKindOf: HumFrame4Vignette ).	(self stepLog) add: (clientID asString,': ', aString).	(self blackboard) businessEvent: (clientID asString,' says: ', aString). 	"TODO: We need a stronger (W5: who, what, when, where, why) business-event representation."	"who = clientID, what = says: ___, when = date-stamp, where = dialog, why = vignette"	self interpretVignette: bestMatch withInput: aString.		"*** Return vignette for DEBUG? *** "	"TODO: THINK -- Should test cases examine my step log instead?"	^ bestMatch.! !!HumDialogAgent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/21/2015 09:53'!scribeProxy	"Return an instance that understands #systemSays:	"	^scribeProxy 		ifNil: [ "TODO: When we have more than one kind of Scribe, this needs to be refactored."			scribeProxy := HumScribe dialogAgent: self. 			].! !!HumDialogAgent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/25/2013 15:09'!pushContext: aString 	( self contextStack ) push: aString.! !!HumDialogAgent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/8/2016 08:33'!newEntity: anEntityType 	"Create a new entity to be associated with the given entity-type/entity-name."	"TODO: If the blackboard already contains and entity of that type, 				it should be saved before the new one is instantiated."	"TODO: Think about the interaction between business process roles, entity-type, and views."	| |	(self blackboard) makeEntityOfType: anEntityType.	"Advice: New business entities are created in the blackboard when a dialog requires them.	The blackboard (HumBlackBoard) will handle persistence by calling a World-Base.	Note: The world-base can be configured to purge data quickly. But why would you do that?	"	! !!HumDialogAgent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/23/2014 10:06'!client: aString 	clientID := aString.	clientURI := 'URI:',aString. "STUB!!"! !!HumDialogAgent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/4/2014 11:01'!contextStack	^ contextStack ifNil: [ contextStack := Stack new. self pushContext: 'Start.'. contextStack ].! !HumActor subclass: #HumDispatcher	instanceVariableNames: 'roleActor actorURI availableActors busyActors'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumDispatcher commentStamp: 'RichardAlexanderGreen 9/14/2014 13:18' prior: 0!The dispatcher assigns actors to perform actions.An actor registers itself with a dispatcher and identifies the roles that it knows.When a running plan or dialog requires that an action be performed, the dispatcher finds an available actor that knows that role (has that capability) and assigns the requested action to that actor.When the actor has completed the role, it becomes available for further assignments.Instance Variables:	roleActor	<Set>	actorURI	<Dictionary>!!HumDispatcher methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 9/11/2014 14:50'!assignAction: aHumInstructionLine toRole: aByteString forJob: aHumJobTicket 	self shouldBeImplemented.! !!HumDispatcher methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 9/15/2014 08:35'!assignRole: roleString action: actionInstruction 	"Assign the given action to an actor advertising the given role."	| actor potentialActors assignableActors  |	self assert: ( roleString isKindOf: String ).	self assert: ( roleString notEmpty ).	self assert: ( actionInstruction isKindOf: HumInstructionLine ).	potentialActors := Set new.	"Find an actor that knows the role."	( self roleActor ) 		do: [ :map | 			map key = roleString asLowercase  				ifTrue: [ potentialActors add: map value. ].			].	"Filter potential actors to include only available actors."	assignableActors := potentialActors intersection: (self availableActors).	"Assign an actor at random."	assignableActors ifEmpty: [Error signal: 'Set of assignableActors is empty - Now what?'].	actor := assignableActors atRandom.	(actor sameAs: myID)		ifTrue: ["Manager (self) cannot be busy and must always be available."]		ifFalse: ["Mark actor busy and not available."							(self busyActors) add: actor.							(self availableActors) remove: actor.							].			"Send the action to the actor."	self sendMessage: actionInstruction to: actor.	"Simulating asynch: 	. The completion comes back via callback #actor: anActor completedAction: aStatement"		! !!HumDispatcher methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 9/11/2014 15:55'!sendMessage: aMessageObject to: recipientID.	"TODO: HumActor does not need to know that delegating a statement is a message send.	 Replace this with something like: self delegateAction: aStatement to: aRole.	"	"self checkID: recipientID."	self assert: (aMessageObject isKindOf: HumInstructionLine). 	( self messenger ) sendAction: aMessageObject toID: recipientID fromID: myID.		! !!HumDispatcher methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 11/3/2014 08:57'!checkOutActor: anActorID at: anActorURI 	"Actor is no longer available for assignments."	| resultRoleActor |	"Remove the actor from role->actor map."	resultRoleActor := ( self roleActor ) copy.	( self roleActor )  		do: [:roleActorMap | 			(roleActorMap value = anActorID) 				ifTrue: [ resultRoleActor remove: roleActorMap ].			].	roleActor := resultRoleActor.		"Remove the actor from the available actor list."	( self availableActors ) remove: anActorID.	"Assume actor will not check-out with work in progress.	If they do, the remove: will trigger an exception.	TODO: In asynch environment, it is possible for assignment and check-out to cross.	"	^self.! !!HumDispatcher methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 7/18/2016 08:21'!runAction: anAction inRole: aRole onJob: aHumJobTicket	"Dispatch the action to an actor in the given role." 	|  |	self assert: ( aRole isKindOf: String ).	self assert: ( aRole notEmpty ).	self assert: ( anAction isKindOf: HumInstructionLine ).	( aRole = #dispatcher )		ifTrue: ["This action is for me as dispatcher."			self assert: (anAction statement translation notNil).			Compiler evaluate: (anAction statement translation) for: self logged: false.			^self.			].	"Otherwise: Assign action to an actor that has registered previously with that role."		anAction jobTicket: aHumJobTicket.	self assignRole: aRole action: anAction 	! !!HumDispatcher methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 7/18/2016 08:25'!actor: anActor completedAction: aHumStatement	"Dispatcher is informed that the actor completed the assigned action.	See: #assignRole: roleString action: actionStatement	"	| bookkeeperInstance |	(anActor sameAs: myID)		ifTrue: ["Dispatcher (self) cannot be busy and must always be available."]		ifFalse: [	"Actor is no longer busy."							( self busyActors ) remove: anActor.							( self availableActors ) add: anActor.							].	"Send charges to bookkeeper."	"For now, just call direct.	TODO: Make asynch call to bookkeeper.	"	bookkeeperInstance := (self messenger) getActorInstanceFromID: (self configuration bookkeeperID).	"TODO: Refactor this. It is by-passing the messenger."	bookkeeperInstance recordJobTicket: ( aHumStatement jobTicket ) .	! !!HumDispatcher methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2013 10:55'!busyActors	^ busyActors ifNil: [ busyActors := Set new ].! !!HumDispatcher methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2014 13:49'!checkInActor: actorID at: aURI withRoles: actorKnowsRoles 	"The Dispatcher should delegate finding the URI to messenger."	"For each actor role: 	. Add the actor to those that know that role."	self assert: ( actorKnowsRoles isKindOf: Array ).	actorKnowsRoles do: [ :aRole |		( self roleActor )  add: ( aRole -> actorID ).		( self availableActors ) add: actorID.		].		! !!HumDispatcher methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2013 10:40'!roleActor	"Return the role->actor map set."	^ roleActor ifNil: [ roleActor := Set new. ].! !!HumDispatcher methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2013 10:43'!availableActors	^ availableActors ifNil: [ availableActors := Set new. ].! !HumNode subclass: #HumMessenger	instanceVariableNames: 'playbackLog uriToNodeID nodeIDtoURI network'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumMessenger commentStamp: 'RichardAlexanderGreen 1/26/2015 08:42' prior: 0!The communication-bus provides a message store-and-forward service with optional logging.If an actor is temporarily not available, a message will be held for some (TBD) time.The messages to a role may be replayed later.instanceVariableNames: - uriActor 		dictionary maps URI to actor instance (assumes actor is running in local VM)- actorURI 		dictionary maps ID to URI- uriActorID 	dictionary maps URI to ID- playbackLog  logs messages to enable playback and debugSeparation of function -- Messenger versus Network:  - The Messenger keeps track of which actors are online and where.- The Messenger also provides logging for playback and debug.- The Network wraps whatever technology is used for actor-to-actor communication.- If an actor is running in test mode, the convention is to start the URI with 'mock:'- The Network will skip the socket business when the URI starts with 'mock:'.- We will probably use Jabber technology for the network.   It provides a number of built-in operators including 'presence' that should come in handy.Configuration:. The messenger needs a place to write persistant logs (to support replay and debug).. The logs could be on the worldbase, but what if the worldbase is down?		!!HumMessenger methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/7/2014 14:36'!uriToNodeID	"What actor ID is associated with URI?"	^ uriToNodeID ifNil: [ uriToNodeID := Dictionary new]! !!HumMessenger methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/11/2014 13:59'!playbackLogFromURI: aURI 	"Extract/Get log entries sent to/from a specific actor.	TODO: Should this be a URI instead of an Actor instance?"	| result |	result := (self playbackLog) at: (aURI) ifAbsent: [ OrderedCollection new].	"TODO: Add timestamp feature. 	 Someday, we may want to roll-forward from a given timestamp.	 Note: timestamps may be from simulated clock rather than system clock."	^result.	! !!HumMessenger methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/26/2014 09:47'!playbackLogFromActor: aHumActor 	"Extract/Get log entries sent to/from a specific actor.	TODO: Should this be a URI instead of an Actor instance?"	| result |	(aHumActor isKindOf: HumActor)		ifTrue: [ result := self playbackLogFromURI: (aHumActor uri) ].	(aHumActor isKindOf: String )		ifTrue: [			(aHumActor beginsWith: 'URI:') 				ifTrue: [ result := self playbackLogFromURI: aHumActor] 				ifFalse:[					| actor |					actor := self getActorInstanceFromID: aHumActor.					result := (self playbackLog) at: (actor uri) ifAbsent: [ OrderedCollection new].					].			].	self assert: (result notNil).	(result isEmpty) ifTrue: [self halt.].	"TODO: Add timestamp feature. 	 Someday, we may want to roll-forward from a given timestamp.	 Note: timestamps may be from simulated clock rather than system clock."	^result.	! !!HumMessenger methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2014 07:43'!playbackLog	^playbackLog ifNil: [ playbackLog := Dictionary new].! !!HumMessenger methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/11/2014 15:08'!network	"Return the chosen physical implementation of network service."	^ network ifNil: [ network := HumNetwork new].! !!HumMessenger methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/11/2014 14:18'!playbackLogToURI: aURI 	"Extract/Get log entries sent to/from a specific actor.	TODO: Should this be a URI instead of an Actor instance?"	| result |	result := OrderedCollection new.	(self playbackLog) 		keysAndValuesDo: [:key :value |			| actorLog |			actorLog := value.			actorLog do: [ :record |				| toURI |				toURI := record at: 2.				(toURI = aURI)					ifTrue: [ result add: record ].				].			].	"TODO: Add timestamp feature. 	 Someday, we may want to roll-forward from a given timestamp.	 Note: timestamps may be from simulated clock rather than system clock."	^result.	! !!HumMessenger methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/7/2014 14:38'!nodeIDtoURI	"actorURI contains (actor->URI) maps"	^ nodeIDtoURI ifNil: [ nodeIDtoURI := Dictionary new ].! !!HumMessenger methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 9/7/2014 14:46'!registerActor: anActor atURI: aURI 	"Track actor."	self assert: ( anActor isKindOf: HumActor ).	self assert: ( aURI isKindOf: String ).	"Track URI->actor association."	self registerNode: anActor atURI: aURI.! !!HumMessenger methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 9/7/2014 14:34'!ping: aURI	"MOCK: Return the ID of the given URI"	^ ( self uriToNodeID ) at: aURI ifAbsent: [ Error signal: 'Messenger has no ID entry for URI: ', aURI ].! !!HumMessenger methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 12/22/2014 09:19'!sendAction: anInstructionLine toID: recipientID fromID: senderID 	"Transmit action request between actors."		| recipientURI senderURI|	self assert: (anInstructionLine isKindOf: HumInstructionLine).	self assert: (recipientID isKindOf:String).	self assert: (senderID isKindOf:String).		"Translate ID to URI."	recipientURI := ( self nodeIDtoURI ) at: recipientID 														ifAbsent: [Error signal: 'Messenger has no URI for recipient ID: ', recipientID].													senderURI := ( self nodeIDtoURI ) at: senderID 														ifAbsent: [Error signal: 'Messenger has no URI for sender ID: ', senderID].	"Send  . . ."	self sendAction: anInstructionLine toURI: recipientURI fromURI: senderURI.	! !!HumMessenger methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 9/11/2014 15:33'!registerNode: aNode atURI: aURI 	"Track actor."	self assert: ( aNode isKindOf: HumNode ).	self assert: ( aURI isKindOf: String ).	"Track URI->actor association."	(self network uriToNode) at: aURI put: aNode.	(self uriToNodeID) at: aURI put: (aNode id).	(self nodeIDtoURI) at: (aNode id) put: aURI.! !!HumMessenger methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 3/26/2015 13:21'!sendInstruction: anInstruction toURI: recipientURI fromURI: senderURI	"Send the (action) statement to the given actor."	"TODO: REFACTOR so that this pushes to a network. 	And so the network becomes the mock instead of the messenger.	This moves us toward using an actual network. (Likely a jabber network.)"	| actorInstance |	self assert: (anInstruction isKindOf: HumInstructionLine).	"Following only works when actor is local."	"TODO: Fix so that it works when actor is remote."	actorInstance := ( self uriToNode ) at: recipientURI 	                              ifAbsent: [ Error signal: 'Messenger has no actor for URI: ', recipientURI ].	self logInstruction: anInstruction sentFrom: senderURI to: recipientURI. 	actorInstance runInstruction: anInstruction inRole: (anInstruction role) onJob: (anInstruction jobTicket).	"TODO: Need a better simulation of async."	"========================================"		! !!HumMessenger methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 9/11/2014 15:06'!sendAction: anInstruction toURI: recipientURI fromURI: senderURI 	"Send the (action) statement to the given actor."	| |	self assert: (anInstruction isKindOf: HumInstructionLine).	self logInstruction: anInstruction sentFrom: senderURI to: recipientURI. 	"Delegate implementation to HumNetwork"	self network sendAction: anInstruction toURI: recipientURI fromURI: senderURI. 		! !!HumMessenger methodsFor: 'events-registering' stamp: 'RichardAlexanderGreen 9/22/2014 16:47'!logInstruction: aHumStatement sentFrom: senderURI to: recipientURI 	| timeNow logEntry |	"Get the clock time - may be a simulator clock"	timeNow := ( self clock ) now.	logEntry := (self playbackLog) at: senderURI ifAbsent: [ logEntry := OrderedCollection new. ].	logEntry add: { senderURI.  recipientURI. aHumStatement. timeNow. }.	playbackLog at: senderURI put: logEntry.! !!HumMessenger methodsFor: 'URI to actor' stamp: 'RichardAlexanderGreen 9/11/2014 15:31'!getActorInstanceFromID: actorID	"*** Backdoor *** during debug to bypass the messenger"	| actorInstance someURI |	self assert: (actorID notNil).	someURI := (self nodeIDtoURI) at: actorID ifAbsent: [Error signal: 'Trouble getting actorURI for: ', actorID ].	actorInstance := (self network uriToNode) at: someURI ifAbsent: [Error signal: 'Trouble getting actorInstance for: ', actorID ].	^actorInstance.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumMessenger class	instanceVariableNames: ''!!HumMessenger class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/10/2012 13:49'!uri: aString 	| instance |	instance := self basicNew.	instance uri: aString.	^instance.! !NumberParser subclass: #HumNumberParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumNumberParser commentStamp: 'RichardAlexanderGreen 5/14/2015 14:55' prior: 0!HumNumberParser is wrapper on NumberParser.It exposes some instance variables for the convenienceof HumDecimal fromString: method.!!HumNumberParser methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 5/14/2015 15:04'!nDigits	^nDigits.! !HumActor subclass: #HumScribe	instanceVariableNames: 'dialogAgent clientConnection jobID dialogAgentURI instructionInProgress htmlSession'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumScribe commentStamp: 'RichardAlexanderGreen 1/15/2016 15:10' prior: 0!A Scribe in a subtype of Actor.For that reason, it is in the Hum-RunTime package rather than the Hum-UI package.However, we expect most scribe implementations to provide a communication path between HumWidget and HumDialogAgent instances.Notes: (2014-11-8) . Scribe and Dialog Agent will be running on same VM and do not need Messenger for communication.(2014-12-23). I am not so sure about that.. A Scribe, not needing ontology or blackboard, could be implemented client-side.. A more flexible arrangement will allow for a client-side Scribe.A Scribe translates client/user inputs (sensors, gestures, keyboard, messages)into a form usable by a Dialog Agent.The Dialog Agent responds to user inputs according to dialog vignettes seen in an ontology.The response is returned to the client/user via the Scribe.The Scribe translates vignette responses into the form required by the client/user interface framework.See: documentation for Dialog Agents, Vignette Frames.(HumDialogAgent, HumFrame4Vignette)Q: How/When/Where/Why is a Scribe instantiated? A: A Scribe instance must be in the channel when a client/user is communicating.. . A Scribe is basically a sensor-interpreter.. . In a web/chat application, a simple scribe would simply operate a chat pane.. . When a view frame is operated, a web scribe would translate it into an HTML form.. Therefore:. . A web application server will create a Scribe instance when it initiates a connection.. . In the Java vocabulary, the Scribe may be a kind of servlet or applet.. Also: A dialog-history is associated with a client/user.. Therefore: . . When a server establishes client/user identity, . . . the dialog-history must be fetched (from World Base).. . The dialog-history is needed to properly revive a .. . . So. that is when we need to instantiate the Dialog Agent.. . . The Dialog Agent is configured with Scribe, Ontology, World Base.. . . Q: What is the relation between Sensor, Scribe, Widget, Canvas, ViewPort.A: The Scribe interprets inputs from the Sensor and updates a Widget.The Widget is drawn on a Canvas - which may be painted on a Surface.The Surface may be painted on a Solid that is in some Scene; or it may be self standing.Note: A Surface is not rendered if it is not visible to the Viewport`s Camera. The flow is Sensor >> Scribe >> Widget >> Canvas >> Surface >> ViewPort (Camera).!!HumScribe methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/13/2014 19:52'!dialogAgent: aHumDialogAgent	self assert: (aHumDialogAgent isKindOf: HumDialogAgent).	dialogAgent := aHumDialogAgent. ! !!HumScribe methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/21/2015 09:57'!initialize	"DEBUG Check: Scribe should be initialized with a dialogAgent at creation."	self dialogAgent ifNil: [Error signal: 'Scribe initiated without a Dialog Agent'].	self assert: ((self worldbase) = 'none').! !!HumScribe methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2015 16:13'!clientConnection	^ clientConnection ifNil:[ clientConnection := myURI ].! !!HumScribe methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/31/2016 17:17'!blackboard	"This instance variable should be set by the instance-creation logic. "	^blackboard ifNil: [Error signal: 'Scribe blackboard should point to Dialog Agent blackboard.']! !!HumScribe methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/13/2014 19:51'!dialogAgentURI	"Returns an instance of HumDialogAgent."	^dialogAgentURI! !!HumScribe methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2015 16:08'!clientConnection: aConnectionOfSomeKind 	"How does the Scribe connect to the user/client sensors?"	"TODO: THIS NEEDS DEEPER/MORE DETAILED THOUGHT."
	self assert: ( aConnectionOfSomeKind isKindOf: ZnUrl ).	clientConnection := aConnectionOfSomeKind ! !!HumScribe methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/13/2014 13:52'!zdialogAgent: aHumDialogAgent 	self assert: (aHumDialogAgent isKindOf: HumDialogAgent).	dialogAgent := aHumDialogAgent. ! !!HumScribe methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2014 09:23'!client: aClientConection 	"synonym"	self clientConnection: aClientConection.! !!HumScribe methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/8/2014 10:47'!dialogAgent	"Returns the Dialog Agent that was attached to this Scribe when the Scribe was instantiated."	^dialogAgent ifNil: [ Error signal: 'Scribe {',myID asString,'} has no dialog agent.']	! !!HumScribe methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/13/2014 19:51'!dialogAgentURI: aHumDialogAgentURI 	self assert: (aHumDialogAgentURI isKindOf: String).	dialogAgentURI := aHumDialogAgentURI.! !!HumScribe methodsFor: 'testing' stamp: 'RichardAlexanderGreen 2/9/2015 18:59'!mockDataEntry: userData 	"Mock the user entering given data into view.	Use this for regression testing.	"	| httpRequest |	self assert: (userData isKindOf: Dictionary).	"HTML/HTTP magic places data into HTTP Request."	httpRequest := HumHttpRequest new.	userData		keysAndValuesDo: [:key :value | 			httpRequest atField: key put: value.			].	self handleHttpPostRequest: httpRequest. ! !!HumScribe methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 11/12/2014 09:50'!htmlStyle	"Return CSS style element."	| styleElement calc cssString |	cssString := '		body {background: beige;}		'.	calc := HumCalculator new.	calc indentLevel: 1. "Zero is no indent."	styleElement := calc xml: 'style' with: [cssString].	^styleElement.	! !!HumScribe methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 1/4/2015 16:11'!sendView: htmlView	"Wrap the view element with HTML header, navigation, epilog, etc." 	| head  body foot menu htmlResult calc |	"TODO: When we more than one kind of scribe, this method will be abstract."	self log add: 'sendView: {',htmlView,'}'.	calc := HumCalculator new.	head := calc xml: 'head' with: [ (calc xml: 'title' with: ['Hum Dialog']), (self htmlStyle)].	foot := calc xml: 'foot' with: [ 'Generated by Hum' ].	menu := calc xml: 'menu' with: [ calc xml: 'menuItem' list: {''.}].	body := calc xml: 'body' with: [ menu, htmlView, foot ].	htmlResult := calc xml: 'html' with: [ head, body ].	self htmlAgent sendHTML: htmlResult to: (self clientConnection).	^htmlResult.! !!HumScribe methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 10/31/2016 17:07'!about"See also: HumRunTimeTests>>testS100ScribeReadMe""Q: What is the relation between Sensor, Scribe, Widget, Canvas, Solid, ViewPort.A: The Scribe interprets inputs from the Sensor and updates a Widget.The Widget is drawn on a Canvas which is painted on a Surface.A Surface might be painted on a Solid within a Scene.Note: A Surface is not rendered if it is not visible to the Viewport`s Camera. The flow is Sensor >> Scribe >> Widget >> Canvas >> Surface >> ViewPort (Camera).""Q: What is the relationship between Sensor, Scribe, Widget, Blackboard, Dialog?A: The Scribe interprets Sensor inputs and updates both the view and the Dialog.The update of a Dialog might wait until form data is submitted.""“THINK: Perhaps an Avatar is a type of widget. It is visible in the 3D view and may interact with the user.Hence it has behavior that is similar to a widget.However, it may be more convenient to treat an Avatar as a kind of role - a role to be assigned to an agent at run-time- an agent that happens to be active in a scene.""“A Scene is mostly decoration, but it may also trigger interaction via proximity triggers.A proximity sensor is part of the scribe`s sensorium.Examples:U: User-Avatar enters the conference room.U: User-Avatar is facing the receptionist.""SUMMARY?A scribe has a sensorium.The sensorium includes . direct user-interface channels (keyboard, voice-to-text, pointer, touch, etc.). indirect user-interface widgets (widgets are probably provided by the visualization framework). scene-interface channels (proximity sensors, user-avatar location coordinates, inter-user text)"! !!HumScribe methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 2/28/2015 10:32'!handleHttpPostRequest: aHumHttpRequest 	"The scribe handles the post request by 	. placing data on a HumDataFrame	. and returning the data frame as a completion of the 'Ask viewName' task.	TODO: Eventually, this should be in a subtype 	      because we will probably also have XMPP, and virtual world interfaces.	"	| calc |	calc := HumCalculator new.	self assert: (aHumHttpRequest isKindOf: HumHttpRequest).	"TODO: Should I clear the blackboard before placing these (new/replacement) values?	 How do I know if they are new versus update?	"	aHumHttpRequest		fields 			keysAndValuesDo: [:key :value |  				| entityName attributeName |				entityName := calc given: key extractUpto: ':'.				attributeName := calc given: key extractAfter: ':'.				"Put the data on my blackboard. 				 It will be sent back to caller in job-completion message. "			  (self blackboard) setEntityName: entityName attribute: attributeName toValue: value.			  ].	"I am ready to send data back to the dialog agent 	 that delegated 'Ask viewName.' task to me."	self assert: (dialogAgent blackboard == self blackboard).	self askViewCompleted.  	! !!HumScribe methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 11/8/2014 11:32'!askViewCompleted	"Inform caller that the 'Ask viewName' task 	 that was delegated from dialog agent (caller)	 to scribe (this instance) has been completed."	| |	"Skip this if there was no dialog caller."	instructionInProgress ifNil: [^self].	"Send results back to my Dialog Agent"	"TODO: ?? Do we return results in completion message ?? 	  -OR- ?? Do we send a separate message ?? 	  -OR- ??"	"Get current task context and send task complete message."	self completedInstruction: instructionInProgress inRole: 'Scribe' onJob: jobID. 		! !!HumScribe methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 8/17/2014 20:12'!sendToDialogAgent: aClientSpeechString 	"Send the string to my Dialog Agent."	| myAgent vignette |	myAgent := self dialogAgent.	vignette := myAgent clientSays: aClientSpeechString.	^vignette.				! !!HumScribe methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 2/20/2015 11:03'!runInstruction: anInstruction inRole: aRole onJob: aJobID	"Override the HumActor -- (Why?)"	| source debug |	"We cannot accept statement strings here because we need noun values."	self assert: ( anInstruction isKindOf: HumInstructionLine ).	debug := false.	debug		ifTrue: [ Transcript cr; show: 'Scribe {',myID,'} called with instruction: {',anInstruction source,'}'.].		instructionInProgress := anInstruction "statement".	jobID := aJobID.	"We are expecting 'Ask viewName.' or 'Show viewName.'"	source := instructionInProgress statement source.	( source beginsWith: 'Ask ') 		ifTrue: [ "Send an active form for the given view to the attached client interface."			|  viewFrame   |			viewFrame := self ontology getViewFrame: (HumCalculator given: source extractBetween: 'Ask ' and: '.' ).			self askView: viewFrame withBlackBoard: (self dialogAgent blackboard).			self askViewCompleted.			].	( source beginsWith: 'Ask: ') 		ifTrue: [ "Send an active form for the given view to the attached client interface."			|  viewFrame   |			viewFrame := self ontology getViewFrame: (HumCalculator given: source extractBetween: 'Ask: ' and: '.' ).			self askView: viewFrame withBlackBoard: (self dialogAgent blackboard).			self askViewCompleted.			].	( source beginsWith: 'Show ') ifTrue: [ self shouldBeImplemented ].	^self.					! !!HumScribe methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 11/8/2014 10:55'!clientSays: aString 	"After a client sensor input is interpreted,	 this method is called with the equivalent speech act input.	The Scribe (me) then passes this to the dialog agent to stimulate a system response.	"	| vignette  |	(self stepLog) add: ('U: ', aString).	"*** Following is here for DEBUG? -- Scribe need not be coupled to ontology."	vignette := self sendToDialogAgent: aString.	self assert: (vignette isKindOf: HumFrame4Vignette ).	(vignette responseLines)		do: [:line |			(self stepLog) add: 'S: ', line source.			].	^vignette.	! !!HumScribe methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 4/9/2015 10:54'!askView: viewFrame withBlackBoard: aBlackBoard	"Current implementation assumes user interface is a HTML browser."	"TODO: HTML stuff belongs in a subtype of Scribe."	|  htmlForm html |	self assert: (viewFrame isKindOf: HumFrame4View).	"Generate an HTML form for the view."	htmlForm := self ontology codeGenerator generateHTMLforViewFrame: viewFrame blackboard: aBlackBoard.	"Wrap the view with HTML prolog, navigation, epilog, etc."	html := self sendView: htmlForm.	"TODO: Associate an event with the ask-view data-entry."! !!HumScribe methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 11/8/2014 09:44'!runAction: anAction inRole: aRole onJob: aHumJobTicket	"Over-ride HumActor to handle Scribe actions."	self assert: ( aRole sameAs: 'scribe' ).	self runInstruction: anAction inRole: aRole onJob: aHumJobTicket.! !!HumScribe methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 10/31/2016 17:26'!systemSays: aString 	"The Dialog Agent has responded with this String.	Implementations will display the response via the client/user interface. (e.g. chat diary)	But this (supertype) only logs the response for test-ability.	"	"*** Subtype implementations will override this method. ***"	(self stepLog) add: 'System: ', aString.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumScribe class	instanceVariableNames: ''!!HumScribe class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 10/31/2016 17:13'!dialogAgent: aHumDialogAgent	"Create an instance attached to the given Dialog Agent."	| instance |	instance := self basicNew.	instance dialogAgent: aHumDialogAgent;		roles: #('scribe');		blackboard: aHumDialogAgent blackboard;		configuration: aHumDialogAgent configuration.	^instance.! !HumConfiguration subclass: #HumSimulator	instanceVariableNames: 'dialogSequence startingIntervalDistribution numberOfDialogs simulatedClockSecond queue dialogAgents log4Dialog clientScribes'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumSimulator commentStamp: 'RichardAlexanderGreen 8/13/2014 12:08' prior: 0!Features:"The Simulator provides the means for 'regression testing'.	Hum dialogs / protocols may be exercised by sending a series of messages to one or more Dialog Agents.	Hum plans are initiated via such dialogs.	Evidence of execution may be found via the Bookkeeper, Messenger logs, and Agent logs.	""Simulations 'load' the system under test by starting dialog sequences 	. at random intervals as seen by the simulated clock.	==> We need a way to represent dialog sequences.	==> We need a way to represent random intervals.	==> We need a way to identify the number of dialogs to be run simultaneously.	==> Ideally, we will run the dialogs in independent threads.	""A simulation loads 'events' into a time-sorted queue and sends the events asynchronously.	. Agent/Actors respond to events by adding events of their own to the queue. 	. The timestamp on each event indicates its order, 	. . but does not determine the real-time duration of the simulation.	. There is no need to create real-time wait-times during the simulation.	""The simulator emulates a human response rate 	. of approximating 1 keystroke (or button press) per second of simulated clock time.	. It is not necessary to simulate the sensor, just the time between vignette inputs.	"Design Questions:"Q: Should the simulator act like a Scribe, or should it work through Scribes?	. In a TDD context, we will sometimes need to verify Scribe features.	. But a Simulator seems like over-kill for that purpose. (A set of Test Cases should do.)"	!!HumSimulator methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 8/20/2014 11:58'!stepUntilDone	[ self queue notEmpty ]		whileTrue: [ self step. ]! !!HumSimulator methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 7/19/2016 11:32'!step	"Send all events with timing that matches the top event."	| readyEvents remainingEvents whenNow  |	"If the queue is empty, do nothing. 	(Prevent problem when manually stepping. See: stepUntilDone)"	( self queue size = 0 ) ifTrue: [ ^self ].	"Update my clock."	whenNow := (self queue at: 1) at: 1.	self now: whenNow.	"Pull the events for this clock-time from the queue."	readyEvents       := (self queue) select: [:event | (event at: 1) = whenNow ].	remainingEvents := (self queue) reject: [:event | (event at: 1) = whenNow ].	queue := remainingEvents.	"Send those events"	readyEvents do: [:event | "For each event scheduled at this time."    | eventType clientID speechString dialogAgent  |		eventType := event at: 2.  clientID := event at: 3.  speechString := event at: 4.		"Someday we might do more than one type of event. But, currently, we just do speech events."		"The *fundamental* idea is that user-gestures are translated to speech-acts 		(represented as a String or HumStatement) before they arrive here."		"TODO: Generalize to send event to specific actor, not just the user dialog."		self assert: (eventType = #speech ).		dialogAgent := self getDialogAgentNamed: clientID.		dialogAgent clientSays: speechString.		"The dialog agent may, in turn, trigger self-actions, plans, and/or actions. "		].	! !!HumSimulator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/16/2015 10:49'!dialogSequence: anArrayOfString 	"Identify the sequence of dialog responses to be sent during this simulation."	self assert: (anArrayOfString isKindOf: SequenceableCollection ).	dialogSequence := anArrayOfString ! !!HumSimulator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/13/2014 14:36'!clientScribes	^clientScribes ifNil: [ clientScribes := Dictionary new.]! !!HumSimulator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2014 13:56'!initialize	| messenger |	messenger := HumMessenger new.	messenger clock: self.	self messenger: messenger.	"Use factory methods to build singleton accomplices"	self messengerID: 'SimMessenger' dispatcherID: 'SimDispatcher' bookkeeperID: 'SimBookkeeper' worldbaseID: 'SimWorldBase'.	"self dispatcher: (HumActor dispatcherID: 'SimDispatcherID' uri: 'SimDispatcherURI' configuration: self)."  self dispatcherID: 'SimDispatcherID'.  	"self bookkeeper: (HumActor bookkeeperID: 'SimBookkeeperID' uri: 'SimBookkeeperURI' configuration: self)."	self bookkeeperID: 'SimBookkeeperID'.	"self worldBase: (HumWorldBase openWorldBase: 'SimWorldBase')."	self worldbaseID: 'SimWorldBaseID'.! !!HumSimulator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/15/2014 09:36'!dialogAgents	^ dialogAgents ifNil: [ dialogAgents := Dictionary new ].! !!HumSimulator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/2/2014 17:59'!simulatedClockSecond	^ simulatedClockSecond ifNil: [simulatedClockSecond := 0 seconds].! !!HumSimulator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/2/2014 10:01'!randomStartingIntervals: aDistribution		"Express the distribution as an S-curve in seconds."		self assert: (aDistribution isKindOf: Dictionary).		startingIntervalDistribution := aDistribution.		! !!HumSimulator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/10/2014 20:30'!now	^ self simulatedClockSecond.! !!HumSimulator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/16/2014 11:29'!log4Dialog	^ log4Dialog ifNil: [ log4Dialog := OrderedCollection new. ].! !!HumSimulator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/17/2014 20:13'!getDialogAgentNamed: aClientID 	| clientAgent |	self assert: ( aClientID isKindOf: String ).	clientAgent := (self dialogAgents) at: aClientID ifAbsent: [self buildDialogAgentNamed: aClientID ].	^clientAgent.! !!HumSimulator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/29/2014 22:54'!getScribeForClient: aClientID 	"Get the Scribe instance corresponding to the client ID."	| scribe dialogAgent |	scribe :=	(self clientScribes) at: aClientID 		                        ifAbsent: [ dialogAgent := HumDialogAgent dialogID: aClientID uri: (aClientID,'URI') client: 'clientURI' configuration: self.			                                  scribe := HumScribe dialogAgent: dialogAgent.			                                  scribe id: aClientID. 			                                 (self clientScribes) at: aClientID put: scribe. ].	^scribe! !!HumSimulator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/2/2014 10:06'!numberOfDialogs: aSmallInteger 	"How many dialogs are to be run simulataneously?"	numberOfDialogs := aSmallInteger 	! !!HumSimulator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/2/2014 18:01'!queue	^ queue 			ifNil: [ queue := SortedCollection sortBlock: [:a :b | (a at: 1) < (b at: 1)] ].! !!HumSimulator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/23/2014 10:36'!buildDialogAgentNamed: clientID	"Build a dialog agent configured for our simulation."	| clientAgent myURI clientURI aHumConfiguration |	myURI := 'URI:DialogAgent.', clientID.	clientURI := 'URI:client.', clientID.	clientAgent := HumActor dialogID: clientID uri: myURI client: clientURI configuration: self.	(self dialogAgents) at: clientID put: clientAgent.	"Check-in with Messenger to enable communication with Dispatcher and WorldBase."	clientAgent checkIn.	^clientAgent. ! !!HumSimulator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/10/2014 20:30'!now: aDuration 	simulatedClockSecond := aDuration! !!HumSimulator methodsFor: 'logging' stamp: 'RichardAlexanderGreen 7/16/2014 11:13'!logDialogWhen: aDuration who: aClientID why: clientSaid what: systemSaid	(self log4Dialog) add: { aDuration. aClientID. clientSaid. systemSaid. }.! !!HumSimulator methodsFor: 'events-registering' stamp: 'RichardAlexanderGreen 2/2/2016 09:43'!after: aDuration sendSpeech: aString from: aClientID 	"Put this event into my queue."	| |	(self queue) add: { aDuration. #speech. aClientID. aString. }.	"TODO: Generalize to send string to specific actor, not just user dialog."	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumSimulator class	instanceVariableNames: ''!!HumSimulator class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 7/15/2014 10:08'!ontology: aHumOntology 	| instance |	instance := self basicNew.	instance ontology: aHumOntology.	instance initialize.	^instance.! !Object subclass: #HumText	instanceVariableNames: 'string lines'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumText commentStamp: 'RichardAlexanderGreen 6/24/2016 09:33' prior: 0!HumText models a text.Text is multi-line and potentially enhanced with color, emphasis, fonts, and font weights.( Also known as "Attributed String" )The immediate intent is to support a code editor and rich text without going "over-board".See: HumTextLine, HumTextToken.See also: HumTextEditor, HumTextWidget.Comment: This implementation is meant to be independent of the built-in Text class.	However, that class might be used in to render a HumTextWidget in Smalltalk.*** TODO: The current implementation is far from complete. ****** TODO: Consider subtype or composition using Text class. ****** TODO: Perhaps a document model would be more useful. ***Note: Text updates are primarily implemented via HumEditor.Instance Variables:	string	< String >	lines	< OrderedCollection of HumTextLine >!!HumText methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/13/2014 18:35'!copy	| newInstance newLines|	newInstance := self class new.	newLines := self lines class new.	self lines do: [:line | newLines add: (line copy) ].	newInstance lines: newLines.	^newInstance.! !!HumText methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/9/2014 10:54'!lines: anOrderedCollection 	( anOrderedCollection isKindOf:  OrderedCollection )		ifFalse: [ Error signal: 'Bad value sent to HumText>>lines: _']		ifTrue: [ |firstElement| firstElement := anOrderedCollection at: 1.			(firstElement isKindOf: HumTextLine) 			ifFalse: [ Error signal: 'First line should be a HumTextLine'] 			].	lines := anOrderedCollection.	self changed.! !!HumText methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/10/2015 10:02'!lines	"Return the HumText list of HumTextLine instances"	lines 		ifNil: [ "initialize the list"			lines := OrderedCollection new. 			lines add: ( HumTextLine new ). "NOTE: never empty"			].	^lines. ! !!HumText methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/13/2014 19:25'!= anotherHumText	"Does this text have same content as the other"	| isSame |	isSame := (self name) = (anotherHumText name).	^isSame.! !!HumText methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/13/2014 11:45'!string	"Return self as a string. (Lines with CR inserted as needed.)"	| result |	result := String new.	( self lines )		do: [ :line |			result := result, line string, String cr.			].	^result.! !!HumText methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/13/2014 18:55'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title s |	title := self class name.	s := title, ':'.	lines do: [ :line | s := s, line string, '/'.].	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: s! !!HumText methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/10/2015 10:19'!addLine: aString 	"Append given line at bottom of text."	| newLine  tempLines |	self assert: ( aString isKindOf: String ).	newLine := HumTextLine new.	newLine string: aString.		tempLines := self lines.	((tempLines size = 1) and: [( tempLines at: 1) string isEmpty])		ifTrue: [tempLines := OrderedCollection new. ].	tempLines add: newLine.	self lines: tempLines.		self changed.! !!HumText methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/14/2014 12:13'!insertEmptyLineAfter: lineIndex 	| currentLines tempLines |	currentLines := self lines.	tempLines := currentLines copyFrom: 1 to: lineIndex.	tempLines add: ( HumTextLine new).	(lineIndex < currentLines size )		ifTrue: [ tempLines addAll: ( currentLines copyFrom: ( lineIndex + 1 ) to:  currentLines size ). ].	"Note: Following will call self changed."		self lines: tempLines.! !Object subclass: #HumTextLine	instanceVariableNames: 'string indentLevel'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumTextLine commentStamp: 'RichardAlexanderGreen 6/24/2016 09:32' prior: 0!A text is assumed have a collection of text-lines.Each text line is assumed to be a collection of tokens.Each token may have attributes that affect how it is rendered.For example, rendering attributes may include emphasis, color, highlight, link, editable.  (ToDo)Emphasis in turn might include isBold, isItalic, isUnderlined, relative height. (ToDo)See also: HumText, HumTextToken, HumEditor, HumTextWidget.Note -- Lines might be re-flowed during the rendering if the context permits / requires it.But the source lines in the text remain the same regardless of the rendering.We don't want to surprise the author by changing the source.(TODO: There is some conceptual conflict here that I have to resolve.)Instance Variables:	string	<String>	indentLevel	<Integer>!!HumTextLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 18:21'!string: aByteString 	string := aByteString! !!HumTextLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/13/2014 11:35'!copy	| newInstance |	newInstance := self class new.	newInstance		indentLevel: (self indentLevel copy);		string: (self string copy).	^newInstance.! !!HumTextLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/8/2014 23:16'!size	^ self string size! !!HumTextLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 20:53'!indentLevel: aSmallInteger	indentLevel := aSmallInteger.! !!HumTextLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 20:54'!indentLevel	"The indent level indicates the level of indentation,	  but not the rendering of the indentation."	^ indentLevel ifNil: [ indentLevel := 0 ].! !!HumTextLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 17:51'!string	string ifNil: [ string := String new. ].	^string.! !Object subclass: #HumTextToken	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumTextToken commentStamp: 'RichardAlexanderGreen 6/24/2016 09:23' prior: 0!A text is assumed have a collection of text-lines.Each text line is assumed to be a collection of tokens.Each token may have parameters that affect how it is rendered.Rendering parameters include emphasis, color, highlight, font, relative height, and behavior.Emphasis  parameters include isBold, isItalic, isUnderlined. Behavior  parameters include link, edtable.Note: This design does NOT encourage renderings that change mid-word. It will require some trick to underline or bold part of a word and not the whole word.The trick could be a "no-space" token that serves to separate the parts of a "word" with partial word rendering.!Object subclass: #HumVM	instanceVariableNames: 'slots transferVector measure'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumVM commentStamp: 'RichardAlexanderGreen 6/24/2016 09:35' prior: 0!HumVM is a thought experiment for a virtural machine and byte code.After some consideration, I (Richard Alexander Green) decided that a byte code is not a good idea at this time.If compiled code is necessary for efficiency, it would make more sense at this time to translate to a language that has a compiler. Byte Code Advantages:- The resulting code may be more compact than the source and therefore it would require less delivery time.- - counter: Delivery time for an agent`s code is generally not an important factor except possibly for a dialog agent.- A byte code might be more easily compiled to a native ISA.- - counter: It is easier to translate to another language.Disadvantages:- If the normal delivery is byte code, the resulting ecology discourages transparency.- An existing VM such as JVM or BEAM would be more acceptable to many audiences.Instance Variables:	slots	<Dictionary>	transferVector	<Dictionary>	measure	<HumMeasure>!!HumVM methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2012 10:30'!measureRegister	^ measure ifNil: [ measure := HumMeasure new. ].! !!HumVM methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2012 10:39'!transferVector	transferVector ifNil: [ transferVector := Dictionary new.		transferVector 			at: 001 put: [ :x | measure := x  ];			at: 002 put: [ :x | measure := measure + x ];			at: 003 put: [ :x | measure := measure - x ];			at: 000 put: [ :x | self halt ].		].	^transferVector.! !!HumVM methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2012 10:11'!slots	"slots allow objects to be referenced by byte-code indices."	^ slots ifNil: [slots := Dictionary new. ].! !!HumVM methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/24/2016 09:44'!setSlot: slotIndex to: aHumObject 	"The slots allow objects to be referenced by byte-code indices."		(self slots) at: slotIndex put: aHumObject.	"Slots are used like registers in this VM thought-experiment. "! !!HumVM methodsFor: 'self evaluating' stamp: 'RichardAlexanderGreen 6/24/2016 09:38'!runInstruction: aHumInstruction 	| microCode |	"Get the microCode. (a block)"	microCode := ( self transferVector ) at: (aHumInstruction operation) 	                              ifAbsent: [ Error signal: 'No such opCode: ', (aHumInstruction operation)].	"Run the microCode. (a block)"	microCode value: ( self slots at: (aHumInstruction operand)).	"Assure cascade."	^self. ! !Object subclass: #HumVMInstruction	instanceVariableNames: 'operation operand'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumVMInstruction commentStamp: 'RichardAlexanderGreen 9/20/2012 07:59' prior: 0!HumVM and HumVMInstruction are artifacts of a thought experiment for a virtural machine and byte code.See the HumVM class comment for further information.Instance Variables:	operation	<Integer>	operand	<Integer>Class Instance Variables:	codeNames	<Dictionary>!!HumVMInstruction methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:09'!operation: opCode 	self assert: ( opCode < 256 ).	self assert: ( opCode >= 0 ).	operation := opCode.! !!HumVMInstruction methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:11'!operation	^ operation ifNil: [ Error signal: 'op code not set in HumInstruction'.  operation := 000].! !!HumVMInstruction methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:10'!operand: objectIndex 	operand := objectIndex! !!HumVMInstruction methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:12'!operand	^ operand ifNil: [ Error signal: 'operand not set in HumInstruction'.  operand := 000].! !!HumVMInstruction methodsFor: 'associating' stamp: 'RichardAlexanderGreen 7/25/2012 10:18'!slotName	( (self operand) = 000 ) ifTrue: [^ 'None' ].	Error signal: 'Instruction slot name is not defined.'.	^'Undefined.'! !!HumVMInstruction methodsFor: 'associating' stamp: 'RichardAlexanderGreen 9/20/2012 07:37'!opCodeName	| name |	name := ( HumVMInstruction codeNames ) at: (self operation) ifAbsent: ['Unknown'].	^name.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumVMInstruction class	instanceVariableNames: 'codeNames'!!HumVMInstruction class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 7/24/2012 16:27'!opCode: opCode value: objectIndex 	| instruction |	instruction := self basicNew.	instruction operation: opCode.	instruction operand: objectIndex.	^instruction.! !!HumVMInstruction class methodsFor: 'associating' stamp: 'RichardAlexanderGreen 7/24/2012 16:26'!opCodeName	name := (self codeNames ) at: (self operation).	^name.! !!HumVMInstruction class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2012 16:33'!codeNames	codeNames ifNotNil: [ ^codeNames ].	"Otherwise, initialize . . ."	codeNames := Dictionary new.	codeNames at: 000 put: 'Halt'.! !HumMeasure subclass: #HumVector	instanceVariableNames: 'x y z'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumVector commentStamp: 'RichardAlexanderGreen 1/26/2015 08:41' prior: 0!A vector to be used in geometry and Physics. Also implements functional programming concepts that enable cascading operations on large arrays.Extends FloatArray.  (That means that complex-number values are not enabled.)Uses FloatArray dot: for dot product.Adds cross product:The three scalar components of the vector s = s1 i + s2 j + s3 k = u × v are:s1 = u2*v3 - u3*v2s2 = u3*v1 - u1*v3s3 = u1*v2 - u2*v1where i,j,k are unit vectors parallel to x,y,z axes.See #cross: method.!!HumVector methodsFor: 'rotations' stamp: 'RichardAlexanderGreen 3/12/2016 09:43'!roll: anAngleInRadians	"Transform receiver by a rotation about y (North pointing) axis."	| vector |	vector := self roll: anAngleInRadians aboutPivot: ( HumVector zeroVector: #meter ).	^vector.! !!HumVector methodsFor: 'rotations' stamp: 'RichardAlexanderGreen 12/20/2016 09:01'!yaw: anAngleInRadians aboutPivot: pivot	"Transform receiver by a rotation about Z (Up pointing) axis."	| xx yy zz r alpha vector cx cy cz dx dy dz |	"The effect is to move the effective origin."	( anAngleInRadians quantity = 0.0 ) ifTrue: [ ^self ].	cx := pivot x.	cy := pivot y.	cz := pivot z.	dx := (self x) - cx.	dy := (self y) - cy.	dz := (self z) - cz.	r := ((dx * dx) + (dy * dy)) sqrt. "Note: x and y are measures"	alpha := (dy arcTan: dx) radian.	"co-tangent Float"	xx := cx + ( r * ( ( alpha + anAngleInRadians ) cos ) ).	yy := cy + ( r * ( ( alpha + anAngleInRadians ) sin ) ).	zz := cz + dz.	"Restore the coordinate origin."	vector := HumVector newFrom: { xx. yy. zz. }.	"Post condition: The length of the vector should not change"	self assert: ((self lengthSquared) = (vector lengthSquared)).	^vector.! !!HumVector methodsFor: 'rotations' stamp: 'RichardAlexanderGreen 4/13/2016 17:47'!roll: anAngleInRadians aboutPivot: pivot	"Transform receiver by a rotation about Y (forward pointing) axis."	| xx yy zz r alpha vector cx cy cz dx dy dz |	"Arithmetic is all via HumMeasure"	"The effect is to move the effective origin."	( anAngleInRadians quantity = 0.0 ) ifTrue: [ ^self ].	cx := pivot x.	cy := pivot y.	cz := pivot z.	dx := (self x) - cx.	dy := (self y) - cy.	dz := (self z) - cz.	r := ((dx * dx) + (dz * dz)) sqrt. 	alpha := (dz arcTan: dx) radian.	"co-tangent Float"	xx := cx + ( r * ( ( alpha + anAngleInRadians ) cos ) ).	yy := cy + dy.	zz := cz + ( r * ( ( alpha + anAngleInRadians ) sin ) ).	"Restore the coordinate origin."	vector := HumVector newFrom: { xx. yy. zz. }.		"Post condition: The length of the vector should not change"	self assert: ((self lengthSquared) = (vector lengthSquared)).	^vector.! !!HumVector methodsFor: 'rotations' stamp: 'RichardAlexanderGreen 4/13/2016 17:20'!pitch: anAngleInRadians	"Transform receiver by a rotation about x (East pointing) axis."	| vector |	vector := self pitch: anAngleInRadians aboutPivot: ( HumVector zeroVector: #meter ).	^vector.! !!HumVector methodsFor: 'rotations' stamp: 'RichardAlexanderGreen 3/12/2016 09:39'!yaw: anAngleInRadians	"Transform receiver by a rotation about z (Up pointing) axis."	| vector |	vector := self yaw: anAngleInRadians aboutPivot: ( HumVector zeroVector: #meter ).	^vector.! !!HumVector methodsFor: 'rotations' stamp: 'RichardAlexanderGreen 1/9/2017 09:27'!pitch: anAngleInRadians aboutPivot: pivot	"Transform receiver by a rotation about X (side pointing) axis."	| xx yy zz r alpha vector cx cy cz dx dy dz |	"The effect is to move the effective origin."	( anAngleInRadians quantity closeTo: 0.0 ) ifTrue: [ ^self ].	cx := pivot x.	cy := pivot y.	cz := pivot z.	dx := (self x) - cx.	dy := (self y) - cy.	dz := (self z) - cz.	r := ((dy * dy) + (dz * dz)) sqrt. "Note: x and y are measures"	alpha := (dz arcTan: dy) radian.	"co-tangent Float"	xx := cx + dx.	yy := cy + ( r * ( ( alpha + anAngleInRadians ) cos ) ).	zz := cz + ( r * ( ( alpha + anAngleInRadians ) sin ) ).	"Restore the coordinate origin."	vector := HumVector newFrom: { xx. yy. zz. }.	"Post condition: The length of the vector should not change"	self assert: ((self lengthSquared) = (vector lengthSquared)).	"TODO: Write a test-suite for yaw, pitch, roll."	^vector.! !!HumVector methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 4/13/2016 17:46'!lengthSquared	| s vx vy vz |	vx := self x.	vy := self y.	vz := self z.	s := (vx*vx) + (vy*vy) + (vz*vz).	"length := s sqrt."	^s.! !!HumVector methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 10/11/2015 17:29'!dot: aHumVector	|  sum  |	sum := 	   ( self x * aHumVector x )			 	+ ( self y * aHumVector y )				+ ( self z * aHumVector z ).	^sum.! !!HumVector methodsFor: 'arithmetic' stamp: 'RichardAlexanderGreen 10/9/2015 14:37'!cross: anotherHumVector	"Return the 3-dimensional vector cross product U x V	where U is self and V is the argument.	The three scalar components 		of the vector s=s1i+s2j+s3k = u×v 		are:			s1 = u2*v3 - u3*v2			s2 = u3*v1 - u1*v3			s3 = u1*v2 - u2*v1	"	| u   ux uy uz     v  vx vy vz   s sx sy sz   |	u := self.	v := anotherHumVector.	self assert: ( v isKindOf: HumVector ).	self assert: ( self quantity size = 3 ).	self assert: (     v quantity size = 3 ).	ux := u x.  uy := u y.  uz := u z.	vx := v x.  vy := v y.  vz := v z.	sx := (uy * vz) - (uz * vy).	sy := (uz * vx) - (ux * vz).	sz := (ux * vy) - (uy * vx).	s := HumVector newFrom: { sx. sy. sz. }.	^s.		! !!HumVector methodsFor: 'render' stamp: 'RichardAlexanderGreen 4/14/2016 09:29'!asString	"render my value as a string"	| result |	self assert: (quantity isKindOf: Array).	result := self quantityAsString.	result := result, ' ', self units.	^result.! !!HumVector methodsFor: 'render' stamp: 'RichardAlexanderGreen 4/14/2016 09:12'!quantityAsString	| s |	self assert: (quantity isKindOf: Array).	s := '( '.	quantity do: [ :each |  s := s, (self quantityAsString: each), ' '. ].	s := s, ')'.	^s.! !!HumVector methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/11/2016 15:33'!y	^self at: 2.! !!HumVector methodsFor: 'access' stamp: 'RichardAlexanderGreen 10/10/2015 10:30'!length	| s length vx vy vz |	vx := self x.	vy := self y.	vz := self z.	s := (vx*vx) + (vy*vy) + (vz*vz).	length := s sqrt.	^length.! !!HumVector methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/11/2016 15:33'!x	^(self at: 1).! !!HumVector methodsFor: 'access' stamp: 'RichardAlexanderGreen 4/4/2016 09:29'!size	"compatibility"	( quantity isKindOf: Array ) ifTrue: [ ^quantity size ].	Error signal: 'Why are we here?'.! !!HumVector methodsFor: 'access' stamp: 'RichardAlexanderGreen 12/16/2015 10:13'!at: k put:  aValue	quantity ifNil: [ quantity := Array new: 3. ].	self assert: (quantity isKindOf: Array).	(aValue isKindOf: HumMeasure) 		ifTrue: [quantity at: k put: aValue. self dimensions: aValue]		ifFalse: [ Error signal: 'What?' ].! !!HumVector methodsFor: 'access' stamp: 'RichardAlexanderGreen 12/16/2015 10:16'!at: index	| v |	self assert: (self quantity isKindOf: Array).	v := HumMeasure new. 	v quantity: (quantity at: index); dimensions: (self dimensions).	^v.! !!HumVector methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/11/2016 15:33'!z	^z := self at: 3.! !!HumVector methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/7/2016 11:40'!x: xValue y: yValue z: zValue	"Hum coordinates are plan-view. x points East. y North. z Up."	(xValue isKindOf: HumMeasure)		ifTrue: [ 			x := xValue. 			y := yValue. 			z := zValue. 			]		ifFalse: [ self assert: (xValue isKindOf: Number). 			x := HumMeasure quantity: xValue units: #meter.			y := HumMeasure quantity: yValue units: #meter.			z := HumMeasure quantity: zValue units: #meter.			].	"Create array and store as quantity."	self quantity:( { x. y. z. } collect: [:each | each quantity] ).	"Assume all elements have same unit of measure (by definition)."	self dimensions: (x dimensions).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumVector class	instanceVariableNames: ''!!HumVector class methodsFor: 'instance initialization' stamp: 'RichardAlexanderGreen 11/22/2016 11:17'!x: xValue y: yValue z: zValue 	| instance |	instance := self basicNew.	instance x: xValue y: yValue z: zValue.	^instance.! !!HumVector class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/4/2016 09:55'!newFrom: xyz	| a3dPoint instance v |	a3dPoint := xyz.	( a3dPoint isKindOf: Point ) ifTrue: [ ^self newFromPoint: a3dPoint ].	self assert: (a3dPoint isKindOf: Array).	( a3dPoint size = 2 ) ifTrue: [ a3dPoint := { xyz at:1. xyz at:2. HumMeasure quantity: 0.0 units: ((xyz at:1) units). } ].	self assert: (a3dPoint size = 3).	instance := self new.	v := a3dPoint at: 1.	(v isKindOf: HumMeasure)		ifTrue: [ "Make quantity an xyz array. Assume units all same."			instance x: (a3dPoint at:1) y: (a3dPoint at: 2) z: (a3dPoint at: 3).			instance dimensions: (v dimensions).			]		ifFalse: [ "Make quantity an xyz array. Assume units all meter."			self assert: (v isKindOf: Number).			instance x: (a3dPoint at:1) y: (a3dPoint at: 2) z: (a3dPoint at: 3).			instance dimensions: (1 meter) dimensions.  			].		 ^instance.! !!HumVector class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 11/19/2015 10:10'!identityVector	"Create a dimensionless identity vector (all ones)."	| instance |	instance := self basicNew.	instance dimensions. "Create an empty dimensions dictionary."	instance quantity: #( 1.0 1.0 1.0 ).	"TODO: Dimensionless measure is not working very well. 	 It may need more thought (or more testing)."	^instance.! !!HumVector class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 3/11/2016 14:21'!zeroVector: aUnitOfMeasureSymbol	"Create a dimensionless zero vector (all zero)."	| instance |	instance := self newFrom: { 0.0. 0.0. 0.0. } units: aUnitOfMeasureSymbol.	^instance.! !!HumVector class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 3/11/2016 14:22'!zeroVector	"Create a dimensionless zero vector (all zero)."	| instance |	instance := self zeroVector: #meter.	^instance.! !!HumVector class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 10/9/2015 16:54'!newFrom: aCollection units: aUnitOfMeasure 	| instance |	instance := self newFrom: aCollection.	(aUnitOfMeasure = 'none') "enable dimensionless vector -- e.g. unit vector."		ifTrue: [ instance dimensions: Dictionary new. ]		ifFalse: [ instance dimensions: (HumMeasure quantity: 1 units: aUnitOfMeasure) dimensions. ].		^instance.! !!HumVector class methodsFor: 'create instance' stamp: 'RichardAlexanderGreen 6/20/2016 09:57'!newFromPoint: aPoint 	| instance |	instance :=  self newFrom: {  aPoint x. aPoint y. 0.0. } units: #px.	^instance.! !HumNode subclass: #HumVirtualReality	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumVirtualReality commentStamp: 'RichardAlexanderGreen 6/24/2016 09:52' prior: 0!A virtual reality contains one or more scenes (HumScene).Scenes contain objects (HumBox).The Scene and its Objects may respond to Sensor events.A virtual reality (VR) contains one or more scenes - It is a model.The VR-controller (a HumSimulator subclass)  provides an API for manipulating scene objects.External and internal events are added to the event schedule  and executed when the internal clock (real or simulated clock) triggers the event.!HumSimulator subclass: #HumVirtualRealityController	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumVirtualRealityController commentStamp: 'RichardAlexanderGreen 7/18/2016 09:57' prior: 0!This controller class extends HumSimulator to control a virtual reality (VR).A virtual reality (VR) contains one or more Scenes - It is a model. (See HumVirtualReality, HumScene)The VR-controller provides an API for manipulating scene objects. (TODO - MAYBE NOT*)External and internal events are added to the event schedule  and executed when the internal clock (real or simulated clock) triggers the event.This class extends HumSimulator because . . .. HumSimulator contains step method, internal event queue, and simulated clock.. This architecture is designed to synchronize multi-player views via event notices.. It should simplify TDD (test driven development) at higher levels of integration.. IT SEEMED LIKE A GOOD IDEA AT THE TIME.* MAYBE NOT: Controlling scene objects from the controller breaks encapsulation.But, at first level, that seems to be the nature of controllers.The ideal is that the controller dispatches events.Some events would be generated by scene objects,and some by the user (e.g. manipulating avatar and/or cameras within a scene).. Scribe: Translate user-gesture into dialog-input.. Dialog: Match dialog-input to vignette and execute the vignette-response.. Vignette Response: Invoke role-action statement(s).. Avatar Role: (Actor) Execute action statement. Generate limb and facial move events.. VR-Controller: (Actor) Synchonize events - send events to Scene.. Scene: (Actor) Move scene objects per event. (Change visual object state attributes). Scene: (Actor) Inform Camera - Scene changed.. Camera: (Actor?) Inform attached ViewPorts.. ViewPort: (UI) Display view of changed scene. (Generate triangles or primative objects, texture). Display: (UI) Display view of changed scene. (GPU: generate tesselation, map texture)TODO: TRY TO WRITE ABOVE AS HUM ROLE-ACTIONS.!HumActor subclass: #HumWorldBase	instanceVariableNames: 'title quads history priorID'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!HumWorldBase commentStamp: 'RichardAlexanderGreen 2/18/2016 20:11' prior: 0!The world base is a data base for a "world".Typically, a "world" is an enterprise.But, it could be a game or a simulation.A world base is a temporal database.All stored values are versioned.For an entity, each stored attribute has a value and a time-span.The time-span, in turn, has two event-stamps corresponding to the event which populated or updated the value and the event which changed the value.A world base entry is a quad (4-tuple) of pointers:. ( entity, attribute, value, time-span ).Entity Schema:. Entity has attributes.. Attribute has value and time-span.. Time-span has start-event, stop-event.Event Schema:. Event has client, portal, context, date-time.. . . . . . . who, where, why, when, (what is the data affected). Client has identifier, client-type, credentials, ongoing-dialog.. Client-type categories include person, robot.. Context has job, ontology, frame, statement.Configuration:- A worldbase is known to a messenger. But it does not need to know any other actors.!!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/12/2012 10:32'!title	^ title ifNil: [ Error signal: 'A world base instance must have a title.'].! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/6/2015 09:47'!whereAttribute: attributeType satisfies: aBlockClosure	"Return a set of entity identifiers where the attribute value satisfies the block"	| identifierSet  |	identifierSet := Set new.	(self quads)		keysAndValuesDo: [ :quadKey :quadValue | 				| entityID attrType attrValue tau |				entityID := quadKey key. 				attrType := quadKey value. 				attrValue := quadValue at: 1. 				tau       := quadValue at: 2.				( ( attrType sameAs: attributeType ) and: [ aBlockClosure value: attrValue ] )					ifTrue: [ identifierSet add: entityID.						self checkTau: tau. 						"Tau (timestamp) is not really used. I've included it for clarity and debug."						].			].	^identifierSet.! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/24/2013 10:55'!history	^ history ifNil: [ history := Dictionary new. ].! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/12/2012 10:34'!title: aWorldBaseName 	self assert: ( aWorldBaseName isKindOf: String ).	title := aWorldBaseName.! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/24/2014 09:49'!getEntityID: entityID attribute: attributeType 	" Get requested value (if any) from the world base instance "	| valueAndTau value tau |	self assert: (entityID isKindOf: HumIdentifier ).	self assert: (attributeType asSymbol isKindOf: Symbol ).		valueAndTau := (self quads ) at: ( entityID -> attributeType ) ifAbsent: [ ^nil ].	value := valueAndTau at: 1.	tau := valueAndTau at: 2.	^ value.! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/6/2015 09:49'!quads	"For quad internal structure see 	self setEntityID: entityID attribute: attributeType toValue: aValue"	^ quads ifNil: [ quads := Dictionary new. ].! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/28/2015 13:30'!setEntityID: entityID attribute: attributeType toValue: aValue	"Put attribute-value (if any) into the world base instance. "	| tau priorValueTau |	self assert: (entityID isKindOf: HumIdentifier ).	self assert: (attributeType asSymbol isKindOf: String ).	self assert: ( aValue notNil ).	tau := (self clock) now. "seconds since 00:00 on 1 Jan 1901"	"TODO: Tau should refer to a business event."	"If there is a different prior value, archive in history."	priorValueTau := ( self quads ) at: ( entityID -> attributeType ) ifAbsent: [].	(( priorValueTau notNil ) and: [ ((priorValueTau at: 1) = aValue) not ] )		ifTrue: [ | historyKey |			historyKey :=	{ entityID. attributeType. (priorValueTau at: 2). tau }.			(self history) at: historyKey put: (priorValueTau at: 1).			].	"Put value of entity attribute and the timestamp."	( self quads ) at: ( entityID -> attributeType ) put: { aValue. tau. }.	"TODO: For large scale applications, 	. persist the entity-attribute-value on an external store.	SUGGEST: An Erlang-compatible non-SQL database. See: RIAK.	"	"TODO: Should (other) blackboards holding the same entityID be notified of the change? If so, how?"! !!HumWorldBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/21/2014 18:51'!initialize	priorID := #( 0 0 0 ).! !!HumWorldBase methodsFor: 'testing' stamp: 'RichardAlexanderGreen 6/29/2015 10:52'!checkTau: aTau 	self assert: (aTau isKindOf: DateAndTime ).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumWorldBase class	instanceVariableNames: ''!!HumWorldBase class methodsFor: 'accessing instances and variables' stamp: 'RichardAlexanderGreen 2/22/2015 11:19'!openWorldBaseFromConfiguation: aHumConfiguration	"Open the world base instance identified in the configuration.	 If the instance does not already exist, something is wrong."	| instance |	instance := aHumConfiguration getWorldBase.	^instance.! !!HumWorldBase class methodsFor: 'accessing instances and variables' stamp: 'RichardAlexanderGreen 2/23/2015 08:47'!openWorldBase: aWorldBaseName	"Open the world base instance with the given name.	If it does not already exist, create a new instance." 	"TODO: Should a world base be an actor or configuration? 	If not, how do we communicate with a remote world base?"	| instance |	self assert: ( aWorldBaseName isKindOf: String ).	instance := self new.	instance 		title: aWorldBaseName;		id: aWorldBaseName;		uri: 'URI:', aWorldBaseName.	^instance.! !PackageManifest subclass: #ManifestHumRunTime	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-RunTime'!!ManifestHumRunTime commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ManifestHumRunTime class	instanceVariableNames: ''!!ManifestHumRunTime class methodsFor: 'code-critics' stamp: 'RichardAlexanderGreen 12/8/2016 13:35'!ruleRBIfTrueReturnsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#HumMeasure #compareAngle: #false)) #'2016-12-08T13:35:36.244944-05:00') )! !