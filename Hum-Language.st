Object subclass: #HumFrame	instanceVariableNames: 'frameLines titleLine ontology uniqueIdentifier debug origin'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame commentStamp: 'RichardAlexanderGreen 9/19/2012 10:41' prior: 0!A "frame" is a small amount of program code in the ontology.Different types of frames contain different types of information and conform to different notations.A frame has a title and contains a list of frame-lines.Instance Variables:	frameLines	<OrderedCollection>	titleLine	<Object>	ontology	<HumOntology>	uniqueIdentifier	<UUID>!!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/25/2016 09:48'!origin: aString	"Where did this frame come from?"	origin := aString.! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/11/2014 12:55'!isEmpty	| hasTitle hasContent result |	hasTitle := ((titleLine notNil) and: [titleLine > '']).	hasContent := (self frameLines size > 0).	result := (hasContent or: [hasTitle]) not.	^result.				! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/12/2014 15:22'!titleLine: anObject	titleLine := anObject asString.! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/25/2016 09:55'!ontology: anOntology	Transcript cr; show: 'Ontology: ', anOntology title.	ontology := anOntology.	self origin: anOntology title.! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 13:33'!ontology	^ ontology! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/25/2016 10:07'!origin	"Where did this frame come from?"	^origin ifNil: [ origin := 'unknown' ].! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 19:48'!frameLines	^frameLines ifNil: [ frameLines := OrderedCollection new.]! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2012 11:04'!frameName	"The name of the frame is guaranteed to be a string.	Generally, it is the same as the titleLine.	"	| frameName |	frameName := (self titleLine) asString.	^ frameName.! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/28/2015 12:18'!appendFrameLine: aFrameLine	"Append a line to the frame."	(aFrameLine isKindOf: HumFrameLine ) ifFalse: [Error signal: 'not a frameLine'].	self frameLines add: aFrameLine.! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/11/2014 12:03'!titleLine	^titleLine			! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2015 09:38'!uniqueIdentifier	"Note: Lazy initialization for this frame`s identifier."	^ uniqueIdentifier 	        ifNil: [ uniqueIdentifier := HumIdentifier createUniqueIdentifierForEntityName: (self title) inContext: ('Creating ontology ', self class asString). ].! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/24/2013 20:39'!title	^ self titleLine ! !!HumFrame methodsFor: 'translating' stamp: 'RichardAlexanderGreen 4/24/2015 08:52'!delegated	Error signal: 'Should be implemented in Ontology Viewer (HumOntologyViewer)'.! !!HumFrame methodsFor: 'debugging' stamp: 'RichardAlexanderGreen 6/6/2016 08:06'!initialize	"The instance should always be a subtype."	| instance |	instance := self.	self assert: (instance className = 'HumFrame') not.	! !!HumFrame methodsFor: 'debugging' stamp: 'RichardAlexanderGreen 3/3/2014 10:38'!delegateToTranslator	Error signal: 'This frame function should be delegated to HumOntologyTranslator.'! !!HumFrame methodsFor: 'debugging' stamp: 'RichardAlexanderGreen 12/16/2014 10:00'!debug: aBoolean 	self assert: (aBoolean isKindOf: Boolean).	debug := aBoolean.! !!HumFrame methodsFor: 'debugging' stamp: 'RichardAlexanderGreen 12/16/2014 09:36'!debug	"Am I in debug mode?"	^ debug ifNil: [debug := false].! !!HumFrame methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 1/16/2012 15:00'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		"nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);"		nextPutAll: title;		nextPutAll: '( ', self frameName, ' )';		nextPutAll: String cr.! !!HumFrame methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 3/3/2014 10:13'!prettyPrintWithOntology: aHumOntology	"Pretty-print using HTML5 and CSS	--  This is a read-only view for ontology code listing."	| html calc |	self delegated.	calc := HumCalculator new.	html :=	calc xml: 'frame'		with: [			(calc xml: 'frameTitle' with: [  self titleLine asString ]),			(self linesAsHTMLwithOntology: aHumOntology)			].	^html.	! !!HumFrame methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 1/9/2012 12:58'!linesAsHTMLwithOntology: anOntology	| html cr |	cr := String cr.	html := cr.	self frameLines 		do: [ :frameLine |				html := html, '<br/>', ( frameLine asHTML5withOntology: anOntology ) ].	^html.! !!HumFrame methodsFor: 'testing' stamp: 'RichardAlexanderGreen 6/12/2014 15:13'!checkSyntaxWithOntology: anOntology	| frameErrors lineErrors    |	frameErrors := OrderedCollection new.	"Check stand-alone syntax.	Detect statements with no nouns.	Detect statements that have not been defined.	"	(self frameLines reject: [:frameLine | (frameLine isKindOf: HumTitleLine)])		do: [ :frameLine | 			lineErrors := (frameLine checkSyntaxWithOntology: anOntology).			(lineErrors isEmpty) ifFalse: [ frameErrors := frameErrors, lineErrors ].			].	^frameErrors.! !!HumFrame methodsFor: 'testing' stamp: 'RichardAlexanderGreen 8/22/2013 15:25'!compileToOntology: aHumOntology 	| problems lineProblems |	problems := OrderedCollection new.	self frameLines		do: [ :frameLine |			lineProblems := ( frameLine compileLineToOntology: aHumOntology ).			problems := problems, lineProblems.			].	"Regardless of errors add frame to the ontology."		aHumOntology storeFrame: self.	^problems.! !!HumFrame methodsFor: 'testing' stamp: 'RichardAlexanderGreen 3/23/2015 09:17'!zcompileToOntology: aHumOntology 	| problems lineProblems |	"Regardless of errors add frame to the ontology."		aHumOntology storeFrame: self.	"Looking for trouble!!"	problems := OrderedCollection new.	self frameLines		do: [ :frameLine |			"Action, Plan, and Vignette frames all may have instruction lines."			( frameLine isKindOf: HumInstructionLine )				ifTrue: [ lineProblems := frameLine compileLineToOntology: aHumOntology defaultRole: 'DialogAgent'.]				ifFalse: [lineProblems := frameLine compileLineToOntology: aHumOntology.].			problems := problems, lineProblems.			].	^problems.! !HumFrame subclass: #HumFrame4Action	instanceVariableNames: 'role actionStatement instructions'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4Action commentStamp: 'RichardAlexanderGreen 6/11/2014 22:16' prior: 0!Action frames define the steps (instructions) in an action.An action belongs to a role.Actors may be assigned to a role at run-time.Such actors have a set of action-statements as their external interface.In that sense, they "know" the role.The format of an action frame looks like this:---Role: Cook.Action: Preheat oven to recipe temperature.. (Delegate to oven's robot.). Oven: Set temperature to recipe temperature.. (Proceed with other actions while oven comes up to heat.)Action: Mix ingredients per recipe.. For each ingredient in recipe ingredients:. . Add ingredient quantity to mixing-bowl.. Stir contents of mixing-bowl for 5 minutes.To: Add ingredient quantity to mixing-bowl.. Select device appropriate to ingredient`s type and quantity giving selected-metering-device.. Meter the ingredient into the mixing-bowl using selected-metering-device.---Action frames may be public (Action: prefix) or private (To: prefix).Instance Variables:	role	<String>	actionStatement	<HumStatement>	instructions	<OrderedCollection>!!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2015 10:18'!actionStatement: anObject	actionStatement := nil.	(anObject isKindOf: String)             ifTrue: [ actionStatement := HumStatement from: anObject ].	(anObject isKindOf: HumStatement )      ifTrue: [ actionStatement := anObject ].	(anObject isKindOf: HumInstructionLine) ifTrue: [ actionStatement := anObject statement].	self assert: ( actionStatement isKindOf: HumStatement ).	! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/17/2015 12:07'!appendInstructionRole: aRole statement: aStatement comment: aComment		| actionInstruction |		actionInstruction := HumInstructionLine new.	actionInstruction role: aRole; statement: aStatement; comment: aComment.		self instructionLines add: actionInstruction.	self frameLines add:  actionInstruction .! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/17/2015 12:06'!appendInstructionStatement: aSource 	| actionInstruction |		actionInstruction := HumInstructionLine new.	actionInstruction role: ''; statement: aSource; comment: ' '.		self instructionLines add: actionInstruction.	self frameLines add:  actionInstruction .! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/17/2015 12:06'!appendInstructionRole: aRole statement: aStatement 	| frameLine |	frameLine := ( HumInstructionLine role: aRole statement: aStatement ).	self instructionLines add: frameLine.	self frameLines add: frameLine.! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/28/2015 12:19'!titleLine	"Format a cannonical title line."	^ 'Role: ', ( self role asString capitalized), ' -- ', ( self actionStatement asString ).! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 18:02'!instructions	^ instructions ifNil: [ instructions := OrderedCollection new. ].! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/23/2012 07:35'!instructionLines	^ instructions ifNil: [ instructions := OrderedCollection new ].! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/17/2014 19:03'!role	^ role.! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 20:44'!instructions: anObject	instructions := anObject! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 20:45'!role: anObject	role := anObject! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/13/2012 14:23'!actionStatement	^ actionStatement ifNil:[ Error signal: 'Action frame must have an action statement']. ! !!HumFrame4Action methodsFor: 'testing' stamp: 'RichardAlexanderGreen 5/20/2016 09:16'!checkSyntaxWithOntology: anOntology 	"Critique the instructions for this role action."	|  critique lineCritique action actionNouns |			"Return the critique as a sequence of strings."	critique := OrderedCollection new.		"The action should contain at least one noun."	action := self actionStatement.	actionNouns := anOntology nounsInStatement: action.	( actionNouns size > 0 ) 		ifFalse: [ critique add: ( 'Action statement {',( action asString ),'} has no known nouns!!' ) ].			"There should be at least one instruction for the action statement."			( self instructionLines size > 0 )		ifFalse: [ critique add: 'Action {', self titleLine,'} has no instructions.'. ].				"Nouns in the instructions should find antecedants in the action statement."	(self instructionLines) 		do: [ :instruction | 			lineCritique := ( instruction checkSyntaxWithOntology: anOntology defaultRole: (self role)).			critique := critique, lineCritique.			lineCritique := ( instruction checkForAntecedantsIn: (self actionStatement) withOntology: anOntology ).			critique := critique, lineCritique.						]. 	"TODO: The line after  'For . . .  : ' or  'If . . .  : '  or 'Else:' should be indented."		"TODO: Think about how indentation should be assured. 	In the editor context, the indentation should be automatic.	Note: Indentation is an attribute of an instruction line.	"	^critique.! !!HumFrame4Action methodsFor: 'testing' stamp: 'RichardAlexanderGreen 3/23/2015 09:22'!compileToOntology: aHumOntology 	"Compile the frame into the ontology."	| nLinesIn nLinesOut |	"Make sure frame is stored."	aHumOntology storeFrame: self.	"Index the role-action"		aHumOntology indexRole: self role action: self actionStatement.	nLinesIn := self frameLines size.	"Add the instruction sequence"	( self instructionLines )		 do: [ :instruction |			"aHumOntology appendInstruction: instruction toRole: (self role) action: (self actionStatement)."			(instruction role sameAs: '') 				ifFalse: [ aHumOntology indexFrame: self relation: #invokesAction object: (instruction title). ].			].	nLinesOut := self frameLines size.	self assert: (nLinesOut = nLinesIn ) description: 'compileToOntology affects source.'.	"Return no errors."		^ (self checkSyntaxWithOntology:  aHumOntology ).		 	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrame4Action class	instanceVariableNames: ''!!HumFrame4Action class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 9/15/2012 10:55'!ontology: aHumOntology role: aRole action: anActionStatement  	| frame |	frame := HumFrame4Action new.	frame ontology: aHumOntology; 		role: aRole;		actionStatement: anActionStatement.	^frame.	! !HumFrame subclass: #HumFrame4Comment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4Comment commentStamp: 'RichardAlexanderGreen 6/11/2014 17:56' prior: 0!A comment frame has no executable code. It is a place to put generic comment lines.Comments that apply to a specific frame should be placed in that frame instead.!!HumFrame4Comment methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/21/2015 09:47'!appendFrameLine: aLine	| frameLine calc | 	calc := HumCalculator new.	calc cases;		when: [  aLine isKindOf: HumCommentLine ] then: [ frameLine := aLine ];		when: [ aLine isKindOf: String ] then: [ frameLine := HumCommentLine new. frameLine source: aLine ];		otherwise: [ Error signal: 'Comment value is not of expected type.' ].	self assert: (frameLine isKindOf: HumCommentLine).	self frameLines add: frameLine.! !HumFrame subclass: #HumFrame4Data	instanceVariableNames: 'priorEntityName'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4Data commentStamp: 'RichardAlexanderGreen 12/21/2015 10:46' prior: 0!Data frames provide a notation and means for transferring data between actors.See #documentation method on the class side.The format is similar to JSON but without the curly brackets.The nesting is indicated by indentation.The notation accomodates tables that populate collection attributes.It also accomdates text (multi-line strings but without formatting) delimited by triple quotes.Comment: The Hum data frame notation was invented before JSON became prevalent.Hum contains a data frame notation for the sake of internal consistencyand because other programming frameworks (ForTran, Basic, . . .) include a data transfer notation.The Hum data frame notation syntax is consistent with other Hum notations. Like Smalltalk and COBOL, statements are terminated with a  period.Like Python, block scope is indicated by indentation.===Data: frame title.Entity: identifier.. attribute: attribute-value.. attribute:"""A text valuemay go on and on for many lines."""===!!HumFrame4Data methodsFor: 'associating' stamp: 'RichardAlexanderGreen 3/17/2015 12:04'!appendEntity: aEntityName attrribute: anAttributeName value: aValueString 	|  colon indent |	indent := '. '.	colon := ': '.	( ( priorEntityName isNil ) or: [(aEntityName sameAs: priorEntityName) not]  )		ifTrue: [ self appendFrameLine: (aEntityName, colon ).				priorEntityName := aEntityName ].	self appendFrameLine:  ( indent, anAttributeName, colon, aValueString ).! !!HumFrame4Data methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 2/13/2012 12:55'!asString	| s cr |	cr := String cr.	s := 'Data Frame', cr.	s := s, '---', cr.	( self frameLines )		do: [ :line | s := s, line asString, cr. ].	s := s, '---', cr.			^s.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrame4Data class	instanceVariableNames: ''!!HumFrame4Data class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/21/2015 10:54'!documentation	| indentedForm tableForm |	indentedForm := '===Data: (data set name)    << Indicate a data frame. Give the frame a name/title.Worker                   << The following data is for a worker (entity). . ID: (string)           		<< The system knows an ID should be unique.. name: (string)         << provides the data value for worker`s "name" attribute.. Home Address       << "Home Address" is an embedded entity.. . line1: (string). . line2: (string). . postal-code: (string)	<< "Reader" and "Smart Editor" validate values.. age: (string)          		<< This value should be a measure.Site                     		<< The following data is for a Site (entity). name: (string)         	<< name of site. description:           << The description of the site is in text format."""                      		<< Arbitrary text delimited by triples as shown here.(text)                   		<< The text data starts on the line after the triple."""                      		<< A triple DOUBLE-QUOTE or SINGLE-QUOTE starts and ends the text.. Site Address           << Indentation indicates "Site Address" is an embedded entity.. . line1: (string). . postal code: (string)===	'.	tableForm := '===Data: Worker`s Scheduled HoursWorker. ID: 12345. name: Robin Good. weekly hours:"""table of weekly-hours delimited by || Day       		| Begin 	| End  |  						<<< First line of table names the attributes associated with the table columns.| Monday    	| 06:00 	| 14:00 |					<<< Values between column delimiters are treated as strings, but trimmed.| Tuesday   	| 06:00 	| 14:00 |						<< See Time class>>readFrom: for an example of how such data might be converted.| Wednesday	| 06:00 	| 14:00 || Thursday  	| 06:00 	| 14:00 || Friday    		| 06:00 	| 14:00 |"""===	'.	^ ( indentedForm, tableForm  ).! !HumFrame subclass: #HumFrame4Dictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4Dictionary commentStamp: 'RichardAlexanderGreen 9/19/2012 10:55' prior: 0!A dictionary frame defines noun relationships.!!HumFrame4Dictionary methodsFor: 'testing' stamp: 'RichardAlexanderGreen 3/23/2015 09:22'!compileToOntology: aHumOntology 	"Each dictionary line will have some additive effect on the ontology."	| syntaxErrors lineErrors |	"Make sure frame is stored."	aHumOntology storeFrame: self.	"We may discover syntax errors while compiling."	syntaxErrors := OrderedCollection new.	(self frameLines select: [ :frameLine | frameLine isKindOf: HumDictionaryLine ] )		do: [ :dictionaryLine |			lineErrors := dictionaryLine compileLineToOntology: aHumOntology.			syntaxErrors := syntaxErrors, lineErrors.
			].	^syntaxErrors.! !!HumFrame4Dictionary methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!addDictionaryLine: aSourceString 	self frameLines add: ( HumDictionaryLine new statement: aSourceString ).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrame4Dictionary class	instanceVariableNames: ''!!HumFrame4Dictionary class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/11/2014 12:09'!ontology: anOntology title: aString	"Create an instance with this ontology and title"	| instance |	instance := self new.	instance		ontology: anOntology;		titleLine: (aString).	^instance! !HumFrame subclass: #HumFrame4Plan	instanceVariableNames: 'goal preconditions planActions'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4Plan commentStamp: 'RichardAlexanderGreen 9/19/2012 10:57' prior: 0!Plan frames define plan-fragments.A plan frame has a goal-statement (a post condition) and a set of preconditions.The action list defines zero or more actions that implement the transition from the preconditions to the post condition.The action list will not execute until the preconditions are all met.Instance Variables:	goal	<HumStatement>	preconditions	<Set>	planActions	<Set>!!HumFrame4Plan methodsFor: 'testing' stamp: 'RichardAlexanderGreen 12/30/2014 10:19'!checkSyntaxWithOntology: anOntology	| frameErrors lineErrors  checkLines  |	frameErrors := OrderedCollection new.	"Check stand-alone syntax.	Detect statements with no nouns.	Detect statements that have not been defined.	"	checkLines := (self preconditions), (self planActions).	checkLines		do: [ :frameLine | 			( frameLine isKindOf: HumInstructionLine )				ifTrue: [ lineErrors := (frameLine checkSyntaxWithOntology: anOntology defaultRole: (frameLine role)).]				ifFalse: [lineErrors := (frameLine checkSyntaxWithOntology: anOntology).].						(lineErrors isEmpty) ifFalse: [ frameErrors := frameErrors, lineErrors ].			].	"Check data flow. 	Each statement's nouns must have antecedants in the goal statement."	checkLines		do: [ :frameLine |			lineErrors := (frameLine checkForAntecedantsIn: (self goal) withOntology: anOntology ).			(lineErrors isEmpty) ifFalse: [ frameErrors := frameErrors, lineErrors ].			].	^frameErrors.! !!HumFrame4Plan methodsFor: 'testing' stamp: 'RichardAlexanderGreen 5/29/2012 19:12'!check	"Check the basic integrity of the plan frame."	| problems |	"The callers sees the problems in the same order we do."	problems := OrderedCollection new.	"The plan frame must have a goal."	( self goal isNil ) 		ifTrue: [ problems add: 'A plan frame must have a goal.']		ifFalse: [ ( self goal source size > 5 ) 						ifFalse: [ problems add: 'A plan frame must have a goal.' ].				 ].		"A plan frame should have at least two preconditions."	(( self preconditions size ) > 1) ifFalse: [ problems add: 'A plan frame should have at least two preconditions.' ].	^problems.! !!HumFrame4Plan methodsFor: 'testing' stamp: 'RichardAlexanderGreen 11/7/2012 12:04'!isNoPlan	"Frame is no plan if there are no preconditions and no actions.	Either the preconditions or the action may be empty, but not both.	However, both could have the statement: 'None.' to indicate that the programmer	has not simply forgotten this frame.	Comment: If goal appears as a precondition elsewhere,	. but has no preconditions and no action needed to make it true,	. it could be annotated as [Assumed.] where it appears as a precondition	. and then no frame would be required for it.	TODO: Think about a feature 	. where a precondition marked [Assumed] in one context 	. is automatically marked [Assumed] everywhere.	"	self preconditions isEmpty		ifFalse: [ ^false ].	self planActions isEmpty		ifFalse: [ ^false ].	^true.! !!HumFrame4Plan methodsFor: 'testing' stamp: 'RichardAlexanderGreen 3/23/2015 09:22'!compileToOntology: aHumOntology 	"Check the basic integrity of the plan frame.	If it is viable, put it into ontology."	| problems |	"Make sure frame is stored."	aHumOntology storeFrame: self.	"The callers sees the problems in the same order we do."	problems := self checkSyntaxWithOntology: aHumOntology.			"A plan frame should have at least two preconditions. (should not must)"	(( self preconditions size ) > 1) 		ifFalse: [ problems add: 'No preconditions.'.			(planActions size > 0) 				ifTrue: [problems add:' Action will be taken as soon as plan starts.'] 				ifFalse: [problems add: 'Plan frame is empty.']			].		"The plan frame must have a goal."	( self goal isNil ) 		ifTrue: [ problems add: 'A plan frame must have a goal.']		ifFalse: [ ( self goal source size > 5 ) 						ifFalse: [ problems add: 'A plan frame must have a goal.']						ifTrue: [ "Looks like we have a goal"							aHumOntology addPlanFrame: self ForGoal: (self goal source).								"If the frame has a goal, store the frame regardless of errors."							aHumOntology storeFrame: self.							] .				].	"Compile the preconditions"			(self preconditions)		do: [ :precondition | 				| thisProblem |				 thisProblem := precondition compileLineToOntology: aHumOntology.				 problems := problems, thisProblem. 				"Index the precondition"				 "aHumOntology frameRelations add: { (self title). #precondition. (precondition statement asString). }."				ontology indexFrame: self relation: #precondition object: (precondition statement asString).				"TODO: Decide if we want the title or the frame itself. (frame reference)"				"Note: The title may change when the goal statement is edited. However, recompile should fix."				"Note: Our structure could enable changing definition, changes all references."				].		"Compile the actions"			( self actionStatements )		do: [ :action | 				| thisProblem |				 thisProblem := action compileLineToOntology: aHumOntology.				 problems := problems, thisProblem. 				"Index the precondition"				 "aHumOntology frameRelations add: { (self title). #invokesAction. ( action titleLine ). }."				 ontology indexFrame: self relation: #invokesAction object: (action titleLine).				 ].		^problems.! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/30/2011 14:19'!goal	"Get the plan frame's goal statement."	^ goal! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/25/2014 09:36'!preconditions	"Preconditions are ordered to preserve the author`s sequence,	and to make locally-run unit test sequences repeatable. 	However, during actual runtime execution, 	  preconditions will be executed asynchronously	  with dynamic scheduling.	Required sequences should be indicated by the plan tree structure or via Action procedure.	"	^ preconditions ifNil: [ preconditions := OrderedCollection new ].! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/17/2015 11:58'!appendRole: aRole action: aSource comment: aComment	"Add 'role: action-statement. (comment)' to plan-frame"	| actionInstruction |		actionInstruction := HumInstructionLine new.	actionInstruction role: aRole; statement: aSource; comment: aComment.		self planActions add: actionInstruction.	self frameLines add:  actionInstruction .! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/25/2014 09:38'!planActions  "A sequence of actions to be performed after preconditions are satisfied.   Generally, a single action is better form, but multiple actions are allowed.   Multiple actions will be performed in the sequence given by the author.  "	^ planActions ifNil: [ planActions := OrderedCollection new. ].! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/17/2015 13:01'!appendPrecondition: aStatement annotation: anAnnotation	| precondition |	precondition := (HumConditionLine new) statement: aStatement.	precondition annotation: anAnnotation.	self assert: ( precondition isKindOf: HumConditionLine ).	self preconditions add: precondition.	self frameLines add: precondition.! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!appendRole: aRole action: aSource 	"Add 'role: action-statement' to plan-frame"	| |		self appendRole: aRole action: aSource comment: nil.! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!appendPrecondition: aSource 	| precondition |	precondition := (HumConditionLine new) statement: aSource.	self assert: ( precondition isKindOf: HumConditionLine ).	self preconditions add: precondition.	self frameLines add: precondition.! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/19/2013 17:32'!actionStatements	^self planActions.! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/17/2015 12:06'!appendInstructionRole: aRole statement: aStatement 	| instruction |	instruction :=  ( HumInstructionLine role: aRole statement: aStatement ).	self planActions add: instruction.	self frameLines add:  instruction.! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/19/2013 17:30'!goal: aSource 	"This instance variable contains the plan frame's goal statement."	| goalStatement |  ( aSource isKindOf: String ) ifTrue: [ goalStatement := HumStatement from: aSource.].  ( aSource isKindOf: HumStatement ) ifTrue: [ goalStatement := aSource.].	goal := goalStatement.	titleLine := 'Goal: ', goalStatement source.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrame4Plan class	instanceVariableNames: ''!!HumFrame4Plan class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 9/15/2012 10:56'!ontology: aHumOntology goal: aGoalStatement	| frame | 	frame := HumFrame4Plan new.	frame ontology: aHumOntology;			goal: aGoalStatement.			^frame.! !HumFrame subclass: #HumFrame4View	instanceVariableNames: 'entity viewName'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4View commentStamp: 'RichardAlexanderGreen 8/20/2015 15:45' prior: 0!A view frame indicates the organization of a user interface - as an interactive document.- The view frame notation is a mainly a mark-up notation. (See: HumMarkupLine.)- Some instructions might be intermixed.The instructions are intended for the view-frame translators.For example.". Table of <plural-noun>:"The user views and enters data shown in data-slots (fields)as indicated by the mark-up.The intention of a view-frame is that it will be implemented (translated to)in some user-interface framework such as HTML5, Pharo-Morphs, or perhaps Hum itself.Instance Variables:	entity	<a noun> -- The entity which is the subject of the view.!!HumFrame4View methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/20/2015 08:10'!compileToOntology: aHumOntology	""	| errors |	"Make sure frame is stored."	aHumOntology storeFrame: self.	errors := OrderedCollection new.	"Index cases where a widget refers to another view."	(self frameLines select: [:frameLine | frameLine isKindOf: HumMarkupLine ])		do: [ :frameLine |			| widgets |			widgets := frameLine widgets.			widgets				do: [ :widget |						('[pane: *]' match: widget)						ifTrue: ["Index this case."							| viewName |							viewName := (HumCalculator given: widget extractBetween: '[pane:' and: ']') trimBoth.							"(aHumOntology frameRelations) add: { (self title). #invokesView. viewName. }"							aHumOntology indexFrame: self relation: #invokesView object: viewName.							].					].			].		^errors := (super compileToOntology: aHumOntology ).! !!HumFrame4View methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/6/2016 08:15'!viewName: aString	"Caller passes the name of the view - to be used in calls."	viewName := aString.	"View-name is a noun."	self ontology addNoun: aString isA: 'view'. ! !!HumFrame4View methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 18:09'!entity: anObject	entity := anObject! !!HumFrame4View methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/9/2015 18:35'!entity	^ entity ifNil: [ entity := HumCalculator given: (self titleLine) extractAfter: ': '].! !!HumFrame4View methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/9/2012 11:57'!viewEntity: anEntityType. 	"What entity-type is this view displaying."	entity := anEntityType.! !!HumFrame4View methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/9/2014 18:04'!addMarkUp: aSource 	| frameLine |	(aSource isKindOf: String)		ifTrue: [ frameLine := HumMarkupLine source: aSource ].	(aSource isKindOf: HumMarkupLine )		ifTrue: [ frameLine := aSource ].	frameLine ifNil: [Error signal: 'Unexpected object type.'].		self frameLines add: frameLine.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrame4View class	instanceVariableNames: ''!!HumFrame4View class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 6/11/2016 08:10'!ontology: aHumOntology viewEntity: entityType 	| frame |	frame := self new.	frame viewEntity: entityType;	       titleLine: 'View: ', entityType, '.';			 ontology: aHumOntology.	"TODO: Think through instantiation via view. Add tests."	^frame. ! !!HumFrame4View class methodsFor: 'instance-creation' stamp: 'RichardAlexanderGreen 6/6/2016 08:00'!titleLine: aString 	"Create an instance based on the given title-line."	| instance  |	instance := self new.	instance titleLine: aString.	instance viewName: (HumCalculator given: aString extractBetween: ' ' and: '.').	^ instance.! !!HumFrame4View class methodsFor: 'instance-creation' stamp: 'RichardAlexanderGreen 6/6/2016 08:11'!ontology: anOntology title: aString 	"Create an instance based on the given title-line."	| instance  |	instance := self new.	instance ontology: anOntology.	instance titleLine: aString.	instance viewName: (HumCalculator given: aString extractBetween: ' ' and: '.').	^ instance.! !HumFrame subclass: #HumFrame4Vignette	instanceVariableNames: 'vignetteContext responseLines instructionLines nextContext patterns'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4Vignette commentStamp: 'RichardAlexanderGreen 12/28/2015 12:33' prior: 0!A dialog contains a set of contexts.A context contains a set of vignettes.A vignette defines a stimulus and a response.The stimulus is a prioritized set of patterns which will be matched against client statements.When a pattern is matched the response is executed.The response may include a speech and/or a short set of instructions.Dialog instructions are addressed to the dialog-agent unless specified otherwise with a role-prefix.The role/label "Goal:" invokes a Coordinator with the indicated plan goal.The prefix: "Avatar:" sends an action via the Scribe to an avatar, if any.Delegating a Goal is not blocking, but all other actions are assumed to be blocking. (The Dialog Agent and/or scribe mediates delegated actions - so this is under programmer control.)The dialog agent maintains a 'stack' of contexts.The contexts nearest the top of the stack have priority when attempting to match client statements.The stack is generally ordered with the most recently used contexts nearest the top.A dialog vignette may command that another context be placed at the top in order to switch contexts.In general, dialogs are organized by the same principles as ALICE chat bots.Instance Variables:	vignetteContext	<Collection | UndefinedObject>	responseLines	<OrderedCollection>	instructionLines	<OrderedCollection>	nextContext	<Collection | UndefinedObject>	pattern	<Collection | UndefinedObject>!!HumFrame4Vignette methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 12/18/2014 13:39'!zpatternMatchScore: aString	"How well does the string (from client) match the pattern int this vignette?	Score a point for each token matched in order.	"	| points bestPatternPoints  |	points := 0.	bestPatternPoints := 0.		"(aString beginsWith: 'My name is') ifTrue: [self halt]." "DEBUG"		"But first, one pattern has to match. Then we score it."	( self patterns )		do: [:pattern |			| patternTokens inputTokens  xInput xPattern |			self assert: [ pattern isKindOf: String ].						"Remove noise words and punctuation"			patternTokens := (self patternTokensIn: pattern).			inputTokens   := (self inputTokensIn: aString).						"Attempt to match input to pattern."			xInput := 1.			xPattern := 1.			points := 0.			[ xPattern <= patternTokens size ]				whileTrue: [ "For each pattern token"						| continue patternToken inputToken |						continue := true.						patternToken := patternTokens at: xPattern.						(patternToken = '*') 							ifTrue: ["Match everything upto next pattern token"								| nextPatternToken xNextInput  |								nextPatternToken := patternTokens at: (xPattern + 1).								"Does the remaining input have the next pattern token?								If not, we are done scoring. 								"								xNextInput := inputTokens indexOf: nextPatternToken startingAt: xInput ifAbsent: [ -1 ].								( xNextInput < 0 )									ifTrue: ["Match fails. Force to next pattern."										points := 0.  "TODO:  No credit for partial match?"										xPattern := 9999.										continue := false.										]									ifFalse: ["Matching so far. Continue to next pattern token."										xInput := xNextInput.										xPattern := xPattern + 1.										points := points + 1.										].																continue := false.								].						(continue and: [ patternToken = '[' ])							ifTrue: ["Assign the next inputToken to the noun named between [...]"								| xNextPattern | 																"TODO: HOW SHOULD WE INTERPRET THIS?								Will we assign the next input to the noun value								or require the next input to match the noun value?								TODO: HOW SHOULD WE SCORE THIS?								"								"For now, assume the next input token matches the bracket expression."								"Advance the pattern token index to the closing bracket."								xNextPattern := patternTokens indexOf: ']' startingAt: xPattern ifAbsent: [Error signal: 'no closing bracket?'].								xPattern := xNextPattern.								points := points + 1.								continue := false.								].						inputToken := inputTokens at: xInput.												(continue and: [self inputToken: inputToken isEquivalentTo: patternToken])							ifTrue: ["Increment the score"								points := points + 1.								continue := false.								].							(continue)							ifTrue: ["The input token does not match the pattern."								"Force out to the next pattern."								points := 0.								xPattern := 9999.								].						xInput := xInput + 1.							xPattern := xPattern + 1.							((xInput > inputTokens size) and: [ xPattern <= patternTokens size ])							ifTrue: ["We ran out of input before we ran out of pattern."								"Force out to the next pattern."								points := 0.								xPattern := 9999.								].						]. "Each token"				 ( points > bestPatternPoints ) ifTrue: [ bestPatternPoints := points ].			]. "Each pattern"	^ bestPatternPoints.! !!HumFrame4Vignette methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 1/8/2015 09:52'!patternMatchScore: aString	"How well does the string (from client) match the pattern int this vignette?	Score a point for each token matched in order.	"	| points bestPatternPoints calc |		calc := HumCalculator new.	points := 0.	bestPatternPoints := 0.		"But first, one pattern has to match. Then we score it."	( self patterns )		do: [:pattern |			| patternTokens inputTokens  xInput xPattern |			self assert: [ pattern isKindOf: String ].						"These parsers remove noise words (a, an, the)."			patternTokens := (self patternTokensIn: pattern).			inputTokens   := (self inputTokensIn: aString).						"Attempt to match input to pattern."			xInput := 1.			xPattern := 1.			points := 0.			[ (xPattern <= patternTokens size ) and: [xInput < (inputTokens size)] ]				whileTrue: [ "For each pattern token"						|  patternToken inputToken |						patternToken := patternTokens at: xPattern.						inputToken := inputTokens at: xInput.						calc cases;						when: [patternToken = '*']						then: ["Match everything upto next pattern token"								| nextPatternToken xNextInput  |								nextPatternToken := patternTokens at: (xPattern + 1).								"Does the remaining input have the next pattern token?								If not, we are done scoring. 								"								"xNextInput := inputTokens indexOf: nextPatternToken startingAt: xInput ifAbsent: [ -1 ]."								xNextInput := 0.								(1 to: inputTokens size) 									do: [:i | ( (i >= xInput)  										          and: [ self inputToken: (inputTokens at: i) isEquivalentTo: nextPatternToken]) 															ifTrue: [xNextInput := i]									 		].								( xNextInput = 0 )									ifTrue: ["Match fails. Force to next pattern."										points := 0.  "TODO:  No credit for partial match?"										xPattern := 9999.										]									ifFalse: ["Matching so far. Continue to next pattern token."										xInput := xNextInput.										xPattern := xPattern + 1.										points := points + 1.										].																];						when: [ patternToken = '[' ]						then: ["Assign the next inputToken to the noun named between [...]"								| xNextPattern | 																								"For now, assume the next input token matches the bracket expression."								points := points + 1.																"Advance the pattern token index to the closing bracket."								"A missing bracket should have been caught at compile-time."								xNextPattern := patternTokens indexOf: ']' startingAt: xPattern 							                                               ifAbsent: [Error signal: 'no closing bracket?'].								xPattern := xNextPattern + 1.								patternToken := patternTokens at: xPattern.								"Advance the input to the next pattern token."								xInput := inputTokens indexOf: patternToken ifAbsent: [ inputTokens size + 1 ].								(xInput <= inputTokens size) ifTrue: [points := points + 1 ].							  								];						when: [self inputToken: inputToken isEquivalentTo: patternToken]						then:["Increment the score"								points := points + 1.								];						otherwise: ["The input token does not match the pattern."								"Force out to the next pattern."								points := 0.								xPattern := 9999.								].						xInput := xInput + 1.							xPattern := xPattern + 1.							((xInput > inputTokens size) and: [ xPattern <= patternTokens size ])							ifTrue: ["We ran out of input before we ran out of pattern."								"Partial match does not score."								points := 0.								"Force out to the next pattern."								xPattern := 9999.								].						]. "Each token"				 ( points > bestPatternPoints ) ifTrue: [ bestPatternPoints := points ].			]. "Each pattern"	^ bestPatternPoints.! !!HumFrame4Vignette methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 8/14/2013 11:52'!patternNouns	| nouns |	nouns := Set new.	( self patterns )		do: [ :pattern |			nouns := nouns addAll: (self patternNouns: pattern ).			].	^ nouns.! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2013 09:04'!patterns	^ patterns ifNil: [ patterns := OrderedCollection new ].! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/12/2014 16:02'!addVignetteResponse: aResponseString 	"Append a verbal response line."	| markup |	markup :=  ( HumMarkupLine source: aResponseString ).	self responseLines add: markup.	self frameLines add: (HumVignetteResponseLine source: ('S: ', aResponseString)).! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/19/2012 07:40'!responseLines	"What will be the verbal response? "	^ responseLines ifNil: [ responseLines := OrderedCollection new. ].! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/12/2014 16:03'!addVignettePattern: patternString 	"Append an Pattern to be executed in response to the user / client."	|  |	(self patterns ) add: patternString.	(self frameLines ) add: (HumVignettePatternLine source: ('U: ',patternString)).! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/19/2012 07:42'!vignetteContext: aContextString 	"The context is used to prioritize responses when two or more patterns match a user input.	It also provides a category seen when viewing the collection of vignettes.	"	vignetteContext := aContextString. ! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/11/2014 10:11'!addPattern: aPatternString 	"Enter a pattern -- What pattern will the vignette respond to?"	"Nil is ignored when parser is running."	aPatternString ifNil: [^self].		(self patterns) add: aPatternString trimBoth.! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/13/2014 19:47'!addVignetteInstruction: anInstructionLine 	"Append an instruction to be executed in response to the user / client."	| instruction |	( anInstructionLine isKindOf: HumInstructionLine )		ifTrue: [ instruction := anInstructionLine ]		ifFalse: [ | role stmt |			"check for role"			role := HumProgrammersAssistant getLabelFromSource: anInstructionLine.			stmt := HumProgrammersAssistant removeLabelFromSource: anInstructionLine.			instruction := ( HumInstructionLine role: role statement: stmt).].		(self instructionLines ) add: instruction.	(self frameLines ) add: instruction.! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/13/2014 08:50'!patternFields: pattern	"Parse the pattern and return the [noun] fields - including the brackets."	| fields s field |	fields := OrderedCollection new.	s := self pattern.	self assert: ( s isKindOf: String ).	[ field := HumCalculator given: s extractBetween: '[' and: ']'.  ( field size > 0 )  ]		whileTrue: [  fields add: ( '[', field, ']' ). 						s := HumCalculator given: s extractAfter: ']'.					 ].	^fields.	! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2012 13:47'!nextVignetteContext	"By default, the next context is the current context."	( nextContext isEmptyOrNil )  ifTrue: [ nextContext := vignetteContext ].	^ nextContext.! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2012 13:49'!vignetteContext	"The context is used to prioritize responses when two or more patterns match a user input.	It also provides a category seen when viewing the collection of vignettes.	"	( vignetteContext isEmptyOrNil ) ifTrue: [ Error signal: 'A vignette context is missing.'].	^ vignetteContext! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/6/2014 09:13'!nextVignetteContext: aContextName 	"What will be the context after the response is rendered?	The context stack prioritizes responses to otherwise identical user patterns.	NOTE: This assumes that vignette frame contains a single set of patterns and a single response.	"	nextContext := aContextName.! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/13/2014 08:50'!patternNouns: pattern	"Parse the pattern and return the nouns referenced in [noun] fields. 	When the pattern is recognized, the noun value will be placed on the dialog's blackboard.'	"	| fields s field |	fields := OrderedCollection new.	s := pattern.	self assert: ( s isKindOf: String ).	[ field := HumCalculator given: s extractBetween: '[' and: ']'.  ( field size > 0 )  ]		whileTrue: [  fields add: (  field ). 						s := HumCalculator given: s extractAfter: ']'.					 ].	^fields.	! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/19/2012 07:33'!instructionLines	"Return the vignette's instruction lines. "	^ instructionLines ifNil: [ instructionLines := OrderedCollection new. ].! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/11/2014 10:14'!titleLine	| s |	self patterns isEmpty		ifTrue: [s := 'Context: "', ( vignetteContext asString), '" pattern: "nil"'.]		ifFalse: [s := 'Context: "', ( vignetteContext asString), '" pattern: "', ( (patterns at: 1) asString ),'"'.].		^s.! !!HumFrame4Vignette methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 1/8/2015 09:35'!inputTokensIn: aString	"Return the pattern tokens in the given string."	| tokens |	tokens := HumCalculator findTokensInString: aString.	tokens := HumCalculator removeNoiseWordTokensFrom: tokens.		"Extract strings in the input as separate tokens."	"TODO: Numbers followed by measurement units should be treated as a single token."	(tokens include: '"')		ifTrue: [| correctedTokens collecting string |			correctedTokens := OrderedCollection new.			string := String new.			collecting := false.			tokens do: [:token |				 ( collecting or: [token = '"']) 						ifFalse: [ correctedTokens add: token ]						ifTrue: [							string := string, token.							(collecting and: [token = '"'] ) 								ifTrue: [ correctedTokens add: string. collecting := false. ]								ifFalse: [collecting := true.]							]				].			tokens := correctedTokens.			].	^tokens. 	! !!HumFrame4Vignette methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/18/2014 15:45'!inputToken: inputToken isEquivalentTo: patternToken	"Is the input equivalent to the pattern?	Allow for common synonyms.	" 	| calc patternLC inputLC |	"Simple case."	(inputToken sameAs: patternToken) ifTrue: [^true].		"Handle tricky pattern tokens."		calc := HumCalculator new.	patternLC := patternToken asLowercase.	inputLC := inputToken asLowercase.	calc cases;		when: [ patternLC = '.' ]    then: [ ^(inputLC = '!!') ];		when: [ patternLC = 'hello'] then: [ ^(#('hi' 'hey' 'howdy') includes: inputLC) ];		otherwise: [^false].! !!HumFrame4Vignette methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 1/8/2015 09:36'!patternTokensIn: aString 	"Return the pattern tokens in the given string.	WARNING: Uppercase is preserved.	"	| tokens |	tokens := HumCalculator findTokensInString: aString.	tokens := HumCalculator removeNoiseWordTokensFrom: tokens.	^tokens.! !!HumFrame4Vignette methodsFor: 'testing' stamp: 'RichardAlexanderGreen 12/31/2014 17:31'!checkSyntaxWithOntology: anOntology	"Check the vignette for syntax problems."	| critique patternCritique nouns |	"First get the critique of the frame lines."	critique := OrderedCollection new.	( self frameLines )		do: [ :frameLine | 			| lineErrors |			( frameLine isKindOf: HumInstructionLine )				ifTrue: [lineErrors := (frameLine checkSyntaxWithOntology: anOntology defaultRole: 'DialogAgent').]				ifFalse: [lineErrors := (frameLine checkSyntaxWithOntology: anOntology).].			(lineErrors isEmpty) ifFalse: [ critique := critique, lineErrors ].			].	patternCritique := OrderedCollection new.		"The vignette must have a context and a pattern."	( vignetteContext isEmptyOrNil  ) ifTrue: [ critique add: 'Vignette has no context!!' ].	( patterns isEmptyOrNil ) ifTrue: [ critique add: 'Vignette has no pattern!!' ].				"The nextContext should be known to the ontology.	NOTE: This assumes that a Frame4Vignette contains a single vignette.	"	(( anOntology vignettesForContext: ( self nextVignetteContext ) ) isEmpty )
		 ifTrue: [ critique add: 'Vignette`s next context {',( self nextVignetteContext ),'} is unknown in ontology. ' ].		"Each [noun] field  in the pattern should reference known nouns."	nouns := self patternNouns.	nouns 		do: [ :noun | 			(anOntology isNoun: noun) 				ifFalse: [ patternCritique add: 'Vignette pattern references unknown noun: ', noun.]  			].		critique := critique, patternCritique.		^critique.! !!HumFrame4Vignette methodsFor: 'testing' stamp: 'RichardAlexanderGreen 6/8/2016 08:56'!compileToOntology: anOntology	"Update the ontology with this vignette."	| |	"Make sure frame is stored."	anOntology storeFrame: self.		anOntology addVignette: self toContext: (self vignetteContext trimBoth ).		"Index any external action calls."	( self instructionLines )		do: [ :instructionLine |			( instructionLine role = '' )				ifFalse: [ "(ontology frameRelations) add: { (self title). #invokesAction. ( instructionLine title ).}. "						ontology indexFrame: self relation: #invokesAction object: (instructionLine title)]				ifTrue: ["Index 'Show view' and 'Ask view' cases."					| sourceString |					sourceString := instructionLine statement source.					(sourceString beginsWith: 'Ask') "Ask for attribute values via the given view."						ifTrue: [ |viewName|							viewName := (HumCalculator given: sourceString extractBetween: 'Ask' and: '.') trimBoth asLowercase.							ontology indexFrame: self relation: #invokesView object: viewName. 							].					(sourceString beginsWith: 'Show') "Show (read-only) attribute values via the given view."						ifTrue: [ |viewName|							viewName := (HumCalculator given: sourceString extractBetween: 'Show' and: '.') trimBoth asLowercase.							ontology indexFrame: self relation: #invokesView object: viewName. 							].					(sourceString beginsWith: 'New') "Create a new entity in the dialog blackboard."						ifTrue: [ |entityName|							entityName := (HumCalculator given: sourceString extractBetween: 'New' and: '.') trimBoth asLowercase.							ontology indexFrame: self relation: #creates object: entityName. 							].											(sourceString beginsWith: 'Push context') "Place given context on top of context-stack."						ifTrue: [ |contextName|							contextName := (HumCalculator given: sourceString extractBetween: 'Push context' and: '.') trimBoth asLowercase.							ontology indexFrame: self relation: #invokesContext object: contextName. 							].					].			].		^ ( self checkSyntaxWithOntology: anOntology ) .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrame4Vignette class	instanceVariableNames: ''!!HumFrame4Vignette class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 12/11/2014 10:08'!ontology: aHumOntology vignetteContext: aContextString pattern: aPatternString 	| frame |	self assert: ( (aPatternString isKindOf: String) or: [ aPatternString isNil ]  ).	frame := self new.	frame ontology: aHumOntology;        vignetteContext: aContextString;        addPattern: aPatternString.	frame titleLine: 'Context: ', aContextString, ' Pattern: ', aPatternString asString.	^frame. 		! !Object subclass: #HumFrameLine	instanceVariableNames: 'source indentLevel comment'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrameLine commentStamp: 'RichardAlexanderGreen 9/19/2012 11:09' prior: 0!A frame line conforms to a specific notation.For example, a dictionary line conforms to dictionary syntax.Instance Variables:	source	<String>!!HumFrameLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2012 14:03'!source	^ source! !!HumFrameLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/13/2014 08:15'!comment	"Any frame line can have a comment."	^comment ifNil: [comment := ''].! !!HumFrameLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/13/2014 09:03'!source: aString 	self assert: ( aString isKindOf: String ).	source := aString.	"Any frame line might have a comment between ()."	self comment: (HumCalculator given: source extractIncludingMatching: '()').	! !!HumFrameLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/13/2014 20:20'!comment: aString	"Any frame line can have a comment."	| test |	aString ifNil: [comment := nil. ^self].	test := HumCalculator given: aString extractIncludingMatching: '()'.	(test isNil)		ifTrue: [comment := aString]		ifFalse: [comment := HumCalculator given: test extractBetween: '(' and: ')'].		! !!HumFrameLine methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 1/11/2012 19:34'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		"nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);"		nextPutAll: title;		nextPutAll: '( ', self source, ' )';		nextPutAll: String cr.! !!HumFrameLine methodsFor: 'compiling' stamp: 'RichardAlexanderGreen 7/25/2013 15:50'!sameAs: anotherFrameLine	(anotherFrameLine isKindOf: String)		ifTrue: [^ (self source) sameAs: anotherFrameLine.].	(anotherFrameLine isKindOf: HumFrameLine )		ifTrue: [^ ( self source ) sameAs: ( anotherFrameLine source ).].	"Eh? Why are we here?"	Error signal: 'unexpected type'.	! !!HumFrameLine methodsFor: 'compiling' stamp: 'RichardAlexanderGreen 1/18/2012 14:00'!checkSyntaxWithOntology: aHumOntology 	|  nouns errors  |	errors := OrderedCollection new.	nouns := aHumOntology nounsInStatement: (self statement).	(nouns isEmpty ) 		ifTrue: [ errors add:( 'Statement { ', self statement source ,' } has no known nouns!!' ) ].	^ errors.! !!HumFrameLine methodsFor: 'compiling' stamp: 'RichardAlexanderGreen 3/30/2012 10:30'!checkForAntecedantsIn: aHumStatement withOntology: aHumOntology 	| antecedants myNouns result |	antecedants := aHumOntology nounsInStatement: aHumStatement.	myNouns := aHumOntology nounsInStatement: self statement.	result := OrderedCollection new.	( antecedants includesAllOf: myNouns )		ifTrue: [ ^result ].	( myNouns copyWithoutAll:  antecedants )		do: [ :noun |			result add: 'The noun: "',noun,'" has no antecedant.'. 			].	^result.! !!HumFrameLine methodsFor: 'compiling' stamp: 'RichardAlexanderGreen 6/12/2014 15:16'!compileLineToOntology: aHumOntology 	"Compile this instruction line."	| errors | 	"Subtypes should implement."	"Error signal: 'Subtypes should implement.'."	errors := OrderedCollection new.	^ errors.! !!HumFrameLine methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/26/2015 11:47'!generateCodeFrom: aTemplateString using: parameterValues 	"Generate code (string) from the template replacing parameters with values in the parameter list."	"TODO: Does this method belong in HumOntologyTranslator ?"	| templateTokens code  |	self assert: ( aTemplateString isKindOf: String ).	self assert: ( parameterValues isKindOf: OrderedCollection ).	code := String new.	templateTokens := self getTokensIn: aTemplateString.	templateTokens 		do: [ :token | "For each token:"			| atParameter |			atParameter := ( ( ( token size = 1 ) and: [ token isAllDigits ] ) ).			atParameter				ifTrue: [ code := code, ( parameterValues at:  ( token asNumber ) ).  ]				ifFalse: [ code := code, token ].			].	^code.! !!HumFrameLine methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/26/2015 11:52'!getTokensIn: aString	"This is a helper for #matchesPattern: (). It implements a Hum-friendly tokenizer."	"TODO: Does this method belong in HumOntologyTranslator ?  It also might be in HumCalculator."	| punctuation whiteSpace tokens |	"Punctuation does not include hyphen because nouns may be hypenated."	punctuation := '~!!@#$%^&*()_+`={}|[[]\:";<>?,./'. 	"White space includes space, cr, tab."		whiteSpace := ' 			'.	"Tokens are all lower-case and include punctuation."	tokens := ( aString asLowercase ) findTokens: ( punctuation, whiteSpace ) keep: (punctuation, whiteSpace).		^tokens.! !!HumFrameLine methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/26/2015 11:57'!doTokensIn: input at: x matchPatternTokensIn: patternTokens at: xPattern	"See if we can get any matching sequence."	"TODO: Everything in this method category should probably be in HumOntologyTranslator."	| pToken atParameter isMatch |	isMatch := false.	"If we run out of pattern, we have succeeded."	( xPattern > (patternTokens size) ) ifTrue: [ ^true ].	"If we run out self before we run out of pattern, we have failed."	( x > ( input size ) ) ifTrue: [^false].	"A pattern token that is a digit will match anything. 	 Proceed to next token in both lists.	 But if there is no match there, the pattern token could still match the next self token, so try that.	"	pToken := patternTokens at: xPattern.	atParameter := ( ( ( pToken size = 1) and: [ pToken isAllDigits ] ) ).	atParameter			ifTrue: [ isMatch := (self doTokensIn: input at: (x + 1) matchPatternTokensIn: patternTokens at: (xPattern + 1) )								      or: [self doTokensIn: input at: (x + 1) matchPatternTokensIn: patternTokens at: (xPattern + 0 ) ].						^isMatch. 					].	"Remainder assumes that current pattern token is NOT a digit."					self assert: (  atParameter not  ).	"If the current pattern token matches the current self token, proceed to the next token in both lists."	( ( patternTokens at: xPattern ) sameAs: ( input at: x ) )			ifTrue: [ "Proceed to next token in both lists"						isMatch := self doTokensIn: input at: (x + 1) matchPatternTokensIn: patternTokens at: (xPattern + 1).					    ^isMatch 					]			ifFalse: [ "See if the next token in self matches the pattern token"						isMatch := self doTokensIn: input at: (x + 1) matchPatternTokensIn: patternTokens at: (xPattern + 0).						^isMatch. ].			"At this point we have a mismatch for sure. (I think maybe.)"	isMatch := false.				^isMatch.! !!HumFrameLine methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 1/8/2015 09:26'!extractPatternParameters: aPatternString 	"Extract parameters (tokens) from source that match the pattern."	| parameters patternTokens selfTokens isMatch |		self assert: ( aPatternString isKindOf: String ).	patternTokens := self getTokensIn: ( aPatternString asLowercase ).  	selfTokens := self getTokensIn: ( self source asLowercase ).	"Search to see if a sequence in my tokens matches a sequence in pattern tokens."	isMatch := self doTokensIn: selfTokens at: 1 matchPatternTokensIn: patternTokens at: 1.		isMatch ifFalse: [ Error signal: 'Attempt to get parameters when pattern does not match.' ].	parameters := OrderedCollection new.	self getParametersIn: selfTokens at: 1 thatMatchParametersIn: patternTokens at: 1 accumulating: parameters.	^ parameters reversed.! !!HumFrameLine methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 10/27/2012 10:44'!onMatch: aPatternString generate: aTemplateString 	"When some part of the content in the current line matches the pattern,	 - Generate code from the template.	 - Replace parameters indicated by digits with corresponding values in the parameter array.	"	| code parameters |	self assert: ( aPatternString isKindOf: String ).	self assert: ( aTemplateString isKindOf: String ).	"If there is no match, there is nothing to do. Return an empty string."	code := String new.	( self matchesPattern: aPatternString ) ifFalse: [ ^code ].	"Otherwise, we have a match.	Generate some code.	"	parameters := self extractPatternParameters: aPatternString.	code := self generateCodeFrom: aTemplateString using: parameters.	^code.! !!HumFrameLine methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 1/12/2015 09:42'!getParametersIn: input at: x thatMatchParametersIn: patternTokens at: xPattern accumulating: parameters	"See if we can get any matching sequence."	| pToken atParameter  isMatch parameter |	isMatch := false.	 parameter := nil.	"If we run out of pattern, we have succeeded."	( xPattern > (patternTokens size) ) ifTrue: [ ^true ].	"If we run out self before we run out of pattern, we have failed."	( x > ( input size ) ) ifTrue: [^false].	"A pattern token that is a digit will match anything. 	 Proceed to next token in both lists.	 But if there is no match there, the pattern token could still match the next self token, so try that.	"	pToken := patternTokens at: xPattern.	atParameter := ( ( ( pToken size = 1) and: [ pToken isAllDigits ] ) ).	atParameter			ifTrue: [ isMatch := (self getParametersIn: input at: (x + 1 ) thatMatchParametersIn: patternTokens at: (xPattern + 1 ) accumulating: parameters )								   or: [self getParametersIn: input at: (x + 1 ) thatMatchParametersIn: patternTokens at: (xPattern + 0 ) accumulating: parameters ].					    isMatch ifTrue: [ parameters add: ( input at: x ) ].						  ^isMatch.					].	"Remainder assumes that current pattern token is not a parameter."					self assert: ( atParameter not ).	"If the current pattern token matches the current self token, proceed to the next token in both lists."	( ( patternTokens at: xPattern ) sameAs: ( input at: x ) )			ifTrue: [ "Proceed to next token in both lists"						isMatch := self getParametersIn: input at: (x + 1) thatMatchParametersIn:patternTokens at: (xPattern + 1) accumulating: parameters.					    ^isMatch 					]			ifFalse: [ "See if the next token in self matches the pattern token"						isMatch := self getParametersIn: input at: (x + 1) thatMatchParametersIn:patternTokens at: (xPattern + 0) accumulating: parameters.						^isMatch. ].			"At this point we have a mismatch for sure. (I think maybe.)"	isMatch := false.				^isMatch.! !!HumFrameLine methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/26/2015 11:53'!matchesPattern: aPatternString 	"Does some part of the frame-line match the given pattern?"	| patternTokens selfTokens isMatch |	self assert: ( aPatternString isKindOf: String ).	patternTokens := self getTokensIn: ( aPatternString asLowercase ).  	selfTokens := self getTokensIn: ( self source asLowercase ).	"Search to see if a sequence in my tokens matches a sequence in pattern tokens."	isMatch := self doTokensIn: selfTokens at: 1 matchPatternTokensIn: patternTokens at: 1. 	^isMatch.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrameLine class	instanceVariableNames: ''!!HumFrameLine class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 1/13/2012 11:41'!source: aByteString      | frameLine |	frameLine := self new.	frameLine source: aByteString.	^frameLine.! !HumFrameLine subclass: #HumCommentLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumCommentLine commentStamp: 'RichardAlexanderGreen 9/28/2012 11:14' prior: 0!A comment line is a line in a single-line or multi-line comment.The lines in the multi-line comment are signaled by a line that begins with a '(' -- a right parend.The lines end with a line that ends with a ')' -- a left parend.Note: In some ontology text files, an additional convention allows a frame or subframe that begins with a 'Comment:' label and ends when the next label (of any kind) is encountered. !HumFrameLine subclass: #HumConditionLine	instanceVariableNames: 'statement annotation'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumConditionLine commentStamp: 'RichardAlexanderGreen 9/28/2012 12:43' prior: 0!A precondition line occurs in a plan frame's preconditions section.As a matter of style, it should be stated as an assertion or declaration. (Present tense descript of the required state of the system.)A precondition line may contain a statement with an optional comment and/or annotation.Here is an example:___Post:  . . .Pre:. All necessary ingredients are on-hand. 	(In the local kitchen) 	[assumed]The comment is within round parentheses.The annotion is withing square brackets.Instance Variables:	statement	<HumStatement>	comment	<ProtoObject>	annotation	<ProtoObject>!!HumConditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/11/2012 13:51'!annotation	^ annotation ifNil: [ '' ].! !!HumConditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/24/2015 08:58'!annotation: aString 	"Annotation may indicate that condition is 'assumed'.  Other cases are not yet defined."	self assert: (aString sameAs: 'assumed').	annotation := aString.! !!HumConditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/11/2012 13:51'!comment	^ comment ifNil: [ '' ].! !!HumConditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/16/2012 14:20'!statement: aSource 	"Set my statement."	statement := nil.	( aSource isKindOf:  String ) ifTrue: [ statement := HumStatement from: aSource ].	( aSource isKindOf: HumStatement ) ifTrue: [ statement := aSource ].	self assert: ( statement isKindOf: HumStatement ).	! !!HumConditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2012 11:13'!source
	| s |	s := self statement asString.	(self comment isEmpty) ifFalse: [ s := s, ( self comment ) ].	(self annotation isEmpty) ifFalse: [ s := s, ( self annotation ) ].	^ s. ! !!HumConditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/11/2014 13:35'!source: aString	"DEBUG: Should not be 'Precondition' or: 'Pre'"	self assert: (aString asLowercase beginsWith: 'pre') not.	^super source: aString.! !!HumConditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/11/2012 13:50'!statement		^ statement ifNil: [ '' ].! !!HumConditionLine methodsFor: 'compiling' stamp: 'RichardAlexanderGreen 1/5/2015 10:30'!checkSyntaxWithOntology: aHumOntology 	|  nouns errors correspondingPlanFrame |	errors := OrderedCollection new.	statement := HumStatement from: (self statement).	nouns := aHumOntology nounsInStatement: statement.	( nouns isEmpty ) 		ifTrue: [ errors add:( 'Precondition {" ', statement source, ' "} has no known nouns!!' ) ].		"Is the precondition assumed?"	( ( self annotation ) sameAs: 'assumed' ) ifTrue: [ ^errors ].		"Otherwise: See if we have a plan for satisfying this precondition."	correspondingPlanFrame := aHumOntology getPlanFrameForGoal: statement.	"NOTE: #getPlanFrameForGoal: will return an empty plan frame  if there is none in the ontology. 	Also, the ontology might contain an empty frame. 	In either case, an empty frame is not a usable subplan.	"	( correspondingPlanFrame isNoPlan ) 		ifTrue: [ errors add:  'Precondition {" ', statement source, ' "} has no plan.'].	^errors.! !!HumConditionLine methodsFor: 'compiling' stamp: 'RichardAlexanderGreen 8/23/2013 14:46'!compileLineToOntology: aHumOntology 	"compile a precondition line into the ontology.	Update where-used.	"	| problems |	problems := self checkSyntaxWithOntology: aHumOntology.	^problems.! !!HumConditionLine methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 5/24/2014 10:41'!<= aHumConditionLine 	"Provide a way to order preconditions	so that we get repeatable sequences when running a plan."	^(self source) <= (aHumConditionLine source)! !HumFrameLine subclass: #HumDictionaryLine	instanceVariableNames: 'statement'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumDictionaryLine commentStamp: 'RichardAlexanderGreen 9/28/2012 11:17' prior: 0!A dictionary line is a line in a dictionary frame.The statement in a dictionary line must conform to the dictionary DSL.Instance Variables:	statement	<HumStatement>	comment	<String>!!HumDictionaryLine methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 6/13/2014 08:44'!getListAfter: aString 	| s sAfter list |	s := self statement source.	sAfter := HumCalculator given: s extractAfter: aString. 	list := sAfter findTokens: ', .'.	"Remove the word 'and' from the list."	list removeAllSuchThat: [ :item | item sameAs: 'and' ].	^list.! !!HumDictionaryLine methodsFor: 'compiling' stamp: 'RichardAlexanderGreen 6/11/2016 09:16'!compileLineToOntology: aHumOntology 	"Add nouns and noun-relations to the ontology.	If statement does not match a dictionary statement pattern,	return an error.	"	| lineErrors s    |	"We may discover syntax errors while compiling.	 Return an empty list when statement matches okay.	"	lineErrors := OrderedCollection new. 		s := self statement source.  	( s trimBoth isEmpty ) ifTrue: [ ^lineErrors ].		( '* is a kind of*' match: s )		ifTrue: [ | subtype supertypes |			  subtype := ( s findTokens: ' ' ) at: 1.				supertypes := self getListAfter: ' is a kind of'.				self assert: ( supertypes size = 1 ).				aHumOntology addNoun: subtype isA: ( supertypes at: 1 ). 				^lineErrors.				].	( '* is a type of*' match: s )		ifTrue: [ | subtype supertypes |			  subtype := ( s findTokens: ' ' ) at: 1.				supertypes := self getListAfter: ' is a type of'.				self assert: ( supertypes size = 1 ).				aHumOntology addNoun: subtype isA: ( supertypes at: 1 ). 				^lineErrors.				].	( '* is an *' match: s )		ifTrue: [ | subtype supertypes |			  subtype := ( s findTokens: ' ' ) at: 1.				supertypes := self getListAfter: 'is an '.				self assert: ( supertypes size = 1 ).				aHumOntology addNoun: subtype isA: ( supertypes at: 1 ). 				^lineErrors.				].	( '* is a *' match: s )		ifTrue: [ | subtype supertypes |			  subtype := ( s findTokens: ' ' ) at: 1.				supertypes := self getListAfter: ' is a '.				self assert: ( supertypes size = 1 ).				aHumOntology addNoun: subtype isA: ( supertypes at: 1 ). 				^lineErrors.				].	( '* subtypes include *' match: s )		ifTrue: [ | supertype subtypes | 			  supertype := ( s findTokens: ' ' ) at: 1.				subtypes := self getListAfter: ' include '.				self assert: ( subtypes size >= 1 ).				subtypes do: [ :sub | aHumOntology addNoun: sub isA: ( supertype ). ].				^lineErrors.				].	( '* attributes include *' match: s ) 		ifTrue: [ | entity attributes |			attributes := self getListAfter: 'include'.			entity := ( s findTokens: ' ' ) at: 1.			aHumOntology addEntity: entity attributes: attributes.			^lineErrors. 			 ].		( '* categories include *' match: s ) 		ifTrue: [ | attribute categories |			categories := self getListAfter: 'include'.			attribute := ( s findTokens: ' ' ) at: 1.			aHumOntology categoriesOf: attribute include: categories.			^lineErrors. 			 ].		(( '*includes a set of*' match: s )	  or: [ '*has a set of*' match: s  ] )		ifTrue: [ | attribute entity |			  attribute := ( self getListAfter: 'a set of' ) at: 1.				entity := ( s findTokens: ' ' ) at: 1.				aHumOntology addEntity: entity attribute: attribute.				aHumOntology addNoun: attribute isA: 'set'.				^ lineErrors.				].	(( '*includes a list of*' match: s )	  or: [ '*has a list of*' match: s ] )		ifTrue: [ | entity attribute| 				attribute := ( self getListAfter: 'a list of' ) at: 1.				entity := ( s findTokens: ' ' ) at: 1.				aHumOntology addEntity: entity attribute: attribute.				aHumOntology addNoun: attribute isA: 'list'.				^ lineErrors.				].				(( '*is synonym for*' match: s) or: ['*is a synonym for*' match: s])		ifTrue: [ | synonym aNoun |				synonym := ( s findTokens: ' ' ) at: 1.				aNoun := self getListAfter: ' synonym for '.				self assert: ( aNoun size = 1 ).				aHumOntology addNoun: synonym isSynonymFor: ( aNoun at: 1 ). 				^lineErrors.				].

	(( '*is shorthand for*' match: s) or: ['*is a shorthand for*' match: s])		ifTrue: [ | synonym aNoun |				synonym := ( s findTokens: ' ' ) at: 1.				aNoun := self getListAfter: ' shorthand for '.				self assert: ( aNoun size = 1 ).				aHumOntology addNoun: synonym isSynonymFor: ( aNoun at: 1 ). 				^lineErrors.				].	(( '*is derived from*' match: s) or: ['*is a shorthand for*' match: s])		ifTrue: [ | synonym aNoun |				synonym := ( s findTokens: ' ' ) at: 1.				aNoun := self getListAfter: ' derived from '.				self assert: ( aNoun size = 1 ).				aHumOntology addNoun: synonym isDerivedFrom: ( aNoun at: 1 ). 				^lineErrors.				].	(( '*is abbreviation for*' match: s) or: ['*is an abbreviation for*' match: s])		ifTrue: [ | synonym aNoun |				synonym := ( s findTokens: ' ' ) at: 1.				aNoun := self getListAfter: ' abbreviation for '.				self assert: ( aNoun size = 1 ).				aHumOntology addNoun: synonym isSynonymFor: ( aNoun at: 1 ). 				^lineErrors.].	"Comment: Shorthand and synonym and abbreviation features enable jargon. 	One could argue that enabling jargon improves readability - or not.	We could treat these nouns as subtypes and everything would work 	... except that subtype graphs would should anomolous subtypes.	"
	"If we fall through to here, 	 the statement was not matched to any dictionary statement pattern."			lineErrors add:( 'Dictionary statement not understood: ', s).			^ lineErrors.! !!HumDictionaryLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/9/2012 14:33'!source	"Construct a source line based on convention and content of my attributes."	| s |	s := self statement asString.	(self comment isEmpty) ifFalse: [ s := s, ( self comment ) ].	^ s. ! !!HumDictionaryLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/9/2012 14:36'!comment	^ comment ifNil: [ comment := String new. ].! !!HumDictionaryLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/9/2012 14:38'!statement: aStatementString 	statement := HumStatement from: aStatementString.! !!HumDictionaryLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/9/2012 14:35'!statement	^ statement! !HumFrameLine subclass: #HumInstructionLine	instanceVariableNames: 'indent role statement annotation translation problems jobTicket'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumInstructionLine commentStamp: 'RichardAlexanderGreen 3/24/2015 08:55' prior: 0!An instruction line may occur in  an action frame,  a plan-frame action section,  or in a dialog vignette as part of the response to a stimulus.Here is a sample instruction line:. Oven: Preheat to temperature. (The oven will emit a ding when the required temperature is reached.)  [duration: 5 minutes]This line has a role (Oven) to which the action is delegated.It has a statement: 'Preheat to temperature.' The action request with the value of the 'temperature' noun will be sent to the actor assigned to the role.It has a comment -- within by round parentheses.It has an annotation -- within square brackets.Instance Variables:	indent	<Integer>	role	<String>	statement	<HumStatement>	comment	<String>	annotation	<String>	translation	<String>			"TODO: Kludge some polymorphism.	 TODO: Fix-up string arguments"	!!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2012 10:16'!indent: aSmallInteger	"How many indents (tabs) before the start of the code-text ?"	indent := aSmallInteger.	(indent < 1 ) ifTrue: [ indent := 1].! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/26/2015 12:23'!= anInstruction	"??? Looks like bad code ???  "	( anInstruction isKindOf: String) ifTrue: [ ^ statement = anInstruction ].	( anInstruction isKindOf: HumInstructionLine ) ifTrue: [ ^ statement = ( anInstruction statement ) ].	"Find out where this is used.  (2015-12-26: None of the unit tests trip over this halt.)"	self halt.! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 20:34'!comment: aString 	"Comment is not executable. May be displayed in certain contexts."	comment := aString.! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2015 10:50'!annotation: aString 	"Annotation may indicate timing for simulations. 	[native] indicates that the statement should be native to the agents that implement the role.	When a statement is [native], the critique should not expect an definition in the current ontology.	"	annotation := aString.! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/16/2015 08:51'!source	"Construct a source line based on convention and content of my attributes."	| s |	s := self statement asString.	(self role trimBoth isEmpty ) ifFalse: [ s :=( role,': ', s ) ].	(self comment trimBoth isEmpty) ifFalse: [ s := s,' (', ( self comment ), ') ' ].	(self annotation trimBoth isEmpty) ifFalse: [ s := s, ' [', ( self annotation ), '] ' ].	source ifNil: [ source := s. ].	^ s. ! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/13/2012 13:47'!annotation	^ annotation ifNil: [^'' ].! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2011 07:12'!translation: aString 	translation := aString.! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/11/2014 13:41'!source: aString	"Should not be: 'Action:' block-label."	self assert: (aString beginsWith: 'Action:') not.	^super source: aString.! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/6/2012 11:39'!comment	^ comment ifNil: [''].! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/12/2014 15:45'!statement	"What will be done . . . will be done at run-time."	^ statement 			ifNil: [ "FIX UP !!!!!!"				source ifNil: [Error signal: 'Blank instruction line.'].				statement := HumStatement source: source.				].! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/24/2013 20:38'!titleLine	^ ( self role), ': ', ( self statement asString ).! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2012 10:25'!statement: aSource 	"What to do  at run-time?"	| x |	( aSource isKindOf: String ) 		ifTrue: [ "Convert to HumStatement"			| sourceString |			sourceString := aSource.			x := 0.			[ sourceString beginsWith: '. ' ] 				whileTrue: [ "Count the indents."					x := x + 1.					sourceString := sourceString copyFrom: 3 to: (sourceString size).					].			statement := HumStatement from: sourceString. 			"Determine the indent level."			self indent: x.			^self.			].	( aSource isKindOf: HumStatement )		ifTrue: ["Copy the Statement."			statement := aSource copy.			self indent: 1.			^self. ].	self assert: ( statement notNil ).	! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/24/2013 20:44'!title	^ self titleLine.! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/20/2015 15:49'!role	"What role am I delegating to? If none, the instruction is to myself."	^ role  ifNotNil: [ (role) ] ifNil: ['']. 	"TODO: Consider returning #self instead of an empty string."! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2012 09:51'!indent	"How many indents (tabs) before the start of the code-text ?"	^ indent ifNil: [ indent := 1 ].! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 20:35'!role: aString 	"Delegate the task (statement) to this role at run-time. "	role := aString.! !!HumInstructionLine methodsFor: 'compiling' stamp: 'RichardAlexanderGreen 6/6/2016 08:23'!checkSyntaxWithOntology: aHumOntology defaultRole: aRole	|  nouns errors theRole |	errors := OrderedCollection new.	"Forgive a nil statement. Sometimes an instruction line has no statement."	statement ifNil: [^errors].	"Ignore empty statement"	(statement source trimBoth  =  '' ) ifTrue: [ ^errors ].	"Check that the nouns in the statement are known. (defined in the ontology)."	nouns := aHumOntology nounsInStatement: statement.	( nouns isEmpty ) 		ifTrue: [ errors add: ( 'Statement: {', statement source ,'} has no known nouns!!' ) ].		"Check that a delegated action is defined in the ontology."	theRole := self role.	( theRole = '') ifTrue: [ theRole := aRole ].	( aHumOntology isActionDefined: self inRole: theRole ) 		ifFalse: [ errors add: ('Action: {', statement source, '} has not been defined.') ].		^ errors.! !!HumInstructionLine methodsFor: 'compiling' stamp: 'RichardAlexanderGreen 12/30/2014 10:19'!compileLineToOntology: aHumOntology 	"Compile this instruction line."	| errors | 	"Check syntax"	errors := self checkSyntaxWithOntology: aHumOntology defaultRole: (self role).	"remember the errors - May show in HTML and other views"	problems := errors.	^ errors.! !!HumInstructionLine methodsFor: 'compiling' stamp: 'RichardAlexanderGreen 3/25/2015 10:00'!onRole: aBlockClosure 	"If instruction includes a role prefix, execute the block."	role ifNil: [^self ].	(role size > 1) ifTrue: aBlockClosure.! !!HumInstructionLine methodsFor: 'compiling' stamp: 'RichardAlexanderGreen 3/25/2015 10:01'!onComment: aBlockClosure 	"If instruction includes a comment, execute the block."	comment ifNil: [^self].	(comment size > 1 ) ifTrue: aBlockClosure.! !!HumInstructionLine methodsFor: 'compiling' stamp: 'RichardAlexanderGreen 1/23/2015 12:02'!checkSyntaxWithOntology: aHumOntology 	|  errors |	Error signal: 'In this context, call "checkSyntaxWithOntology: aHumOntology defaultRole: aRole"  instead.'.	errors := OrderedCollection new.	^ errors.! !!HumInstructionLine methodsFor: 'compiling' stamp: 'RichardAlexanderGreen 3/24/2015 08:56'!compileLineToOntology: aHumOntology defaultRole: aRole	"Compile this instruction line."	| errors | 	"TODO: Kludge some polymorphism.	 TODO: Fix-up string arguments"		"Check syntax"	errors := self checkSyntaxWithOntology: aHumOntology defaultRole: aRole.	"remember the errors - May show in HTML and other views"	problems := errors.	^ errors.! !!HumInstructionLine methodsFor: 'job ticket' stamp: 'RichardAlexanderGreen 8/20/2015 15:56'!jobTicket: aJobTicket	"At run-time, a job ticket may be associated with action request."	self assert: ( aJobTicket isKindOf: HumJobTicket ).	jobTicket := aJobTicket.	"TODO: This instance variable is here because the run-time needs to pass a jobTicket when delegating an instruction. (?)			I think there is something wrong in that calling logic. See: ???"! !!HumInstructionLine methodsFor: 'job ticket' stamp: 'RichardAlexanderGreen 1/5/2015 10:25'!jobTicket	"There should be a job ticket if the (run-time) caller expects one."	^ jobTicket ifNil: [ Error signal: 'no jobTicket']! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumInstructionLine class	instanceVariableNames: ''!!HumInstructionLine class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 1/3/2012 20:57'!statement: aSourceString 	"Return an instance with given source."	| instruction |	instruction := self new.	instruction statement: aSourceString.	^instruction.	! !!HumInstructionLine class methodsFor: 'Instance creation convenience' stamp: 'RichardAlexanderGreen 1/2/2012 21:37'!role: aRole statement: aSourceString annotation: anAnnotation	"Return an instance with given  role, source, and annotation."	| instruction |	instruction := self new.	instruction role: aRole; statement: aSourceString;  annotation: anAnnotation.	^instruction.! !!HumInstructionLine class methodsFor: 'Instance creation convenience' stamp: 'RichardAlexanderGreen 1/2/2012 21:36'!role: aRole statement: aSourceString  comment: aComment	"Return an instance with given source, role, and comment."	| instruction |	instruction := self new.	instruction  role: aRole;  statement: aSourceString; comment: aComment.	^instruction.! !!HumInstructionLine class methodsFor: 'Instance creation convenience' stamp: 'RichardAlexanderGreen 12/1/2014 10:31'!role: aRole statement: aSourceString  	"Return an instance with given source, role, and comment."	| instruction |	instruction := self new.	instruction 		statement: aSourceString; 		role: aRole.	^instruction.! !HumFrameLine subclass: #HumMarkupLine	instanceVariableNames: 'lastLevel'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumMarkupLine commentStamp: 'RichardAlexanderGreen 4/18/2014 17:27' prior: 0!A markup line may occur within a view or a dialog vignette response.In those contexts, a mark-up line is a line that does not begin with a period.(Lines that begin with a period contain instructions to be exectuted by the dialog agent or rendering engine.)The content of the line will be rendered when the view or response is rendered. Hum mark-up uses the following notations:Outline Mark-Up:  (outlines are indicated by a line that begins with a specific special character.)!! a level one heading!!!! a level two heading -- an so on up to level 5.- a bullet at first level of outline-- a bullet at second level of outline -- an so on up to 5 levels --- a bullet at third level of outline -- note that a line that begins with three underscores (___) indicates a horizontal rule (or a splitter)# a numbered outlline - first level## a numbered outline - second level -- and so on up to 5 levels.Text Emphasis:  Text substrings may be emphasized by surrounding the substring as follows:    *bold*    ~italic~    _underline_Widget Mark-Up: [widget] -- a widget is enclosed in square brackets. Widgets are used in interactive contexts. [[button]] -- a button is a widget. The dialog speech-act intended must be defined in a following instruction. [a] -- a widget containing a single character indicates a check-box. The intended action must be defined in a following instruction. (a) -- a radio button. Then intended action must be defined in a following instruction. [type: string ] -- The type indicates the rendering intended.                           Example: [range: utilization ] might render as a meter, or bar, or spinner, depending on the rendering engine and its style rules.Widget Actions:  [attribute] -- The widget names an attribute. The current value (if any) of the attribute is rendered.                 The rendering engine will provide an appropriate widget depending on the type of the attribute.                 For example, a category may be rendered with a pull-down list, text with a text-area, date with a date selector.  [page: title] -- The internal page with the given title is linked.  [link: blah blah | URI ] -- "blah blah" is displayed. The URI links to an external resource.  [pane: title] -- The Hum view frame with the matching title will be rendered at this position.                         More elaborate layouts are achieved by placing panes within panes.Tables:  (These are used to list the content of an entity's collection attributes.)  The columns of the table are indicated by attribute names separated by pipe '|' characters.  Here is an example where an order entity has a list attribute called order-lines.. Table of order-lines.| catalog-id | description | quantity | unit-price | %%%%%%%%%%%%%%% Summary %%%%%%%%%%%%%%%%%%%%%%%%%%	 . Known widget types include 	 . . [page:  TITLE ] -- Link to local page (a la wiki)	 . . [link: TITLE | URL] -- Link to a remote page given by the URL/URI	 . . [pane: TITLE] -- Insert given pane	 . . [range: LB - UB ] -- Provide a slider or similar device on input; a progress bar on output.	 . Attribute types with specific rendering should eventually 	 . . [category] [text] [date] [email] -- HTML5 can handle directly	 . . [measure] -- accept and validate quantity, unit-of-measure, plus-or-minus	 . . [collection -- display a table? (default rendering or ???)  !!HumMarkupLine methodsFor: 'widgets' stamp: 'RichardAlexanderGreen 6/13/2014 08:50'!widgets	"Scan the source matching pairs of [. . .] or [[. . .]]."	| widgets  s button widget |	widgets := OrderedCollection new.		s := self source.	"Scan for widgets"			[ widget := HumCalculator given: s extractBetween: '[' and: ']'.	  ( widget size > 0 ) ]		whileTrue: [  "Watch out for [[button label]] pattern."					( widget beginsWith: '[')							ifTrue: [ "This widget looks like a button. Return [[button label]]."								        widgets add: ( '[', widget, ']]' ).								        s := HumCalculator given: s extractAfter: ']]'.											]							ifFalse: [ "This widget does not look like a button. Return [content]." 								         widgets add: ( '[', widget, ']' ). 												s := HumCalculator given: s extractAfter: ']'.											].					 ].	^widgets.! !!HumMarkupLine methodsFor: 'widgets' stamp: 'RichardAlexanderGreen 6/8/2016 09:54'!getWidgetNoun: aWidgetString	"Parse the widget-string to get the widget`s noun (blackboard entity-attribute-name), if any."	| noun |	(aWidgetString includesSubString: ':') "[verb: argument] pattern has no blackboard noun."		ifTrue: [^''].	(aWidgetString beginsWith: '[[')	"[[button]] has no blackboard noun."		ifTrue: [ ^'' ].	noun := HumCalculator given: aWidgetString  extractBetween: '[' and: ']'.	^noun	! !!HumMarkupLine methodsFor: 'widgets' stamp: 'RichardAlexanderGreen 6/8/2016 09:47'!getWidgetVerb: aWidgetString	"Parse the widget-string to get the widget`s verb, if any."	| verb |	(aWidgetString includesSubString: ':')		ifFalse: [^''].	verb := HumCalculator given: aWidgetString extractBetween: '[' and: ':'.	self assert: (verb size > 0).	^verb! !!HumMarkupLine methodsFor: 'widgets' stamp: 'RichardAlexanderGreen 6/8/2016 09:48'!getWidgetArgument: aWidgetString	"Parse the widget string to get verb`s argument, if any."	| argument |	(aWidgetString includesSubString: ':')		ifFalse: [^''].	argument := HumCalculator given: aWidgetString extractBetween: ':' and: ']'.	self assert: (argument size > 0).	^argument! !!HumMarkupLine methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 4/24/2015 09:01'!generateHtmlTableFor: aNoun withOntology: anOntology	| singular attributes html  |		self delegated.	singular := anOntology singularFormOfNoun: aNoun.	attributes := anOntology allAttributesOfEntity: singular.	"If the entity has no attributes, generate a default table."	( attributes size = 0 )		ifTrue: [^'<table name="',aNoun,'"><tr><th>',aNoun,' has no attributes in current ontology.</th></tr></table>'].  "Otherwise generate a normal table."	html := '<table name="',aNoun,'" >'.	html := html, '<tr>'.	attributes do: [:attribute | html := html, '<th>', attribute, '</th>'.]. 	html := html, '</tr>'.	html := html, '<tr>'.	attributes do: [:attribute | html := html, '<td>', attribute, ' value </td>'.]. "STUB"	html := html, '</tr>'.	html := html, '</table>'.	^html.! !!HumMarkupLine methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 3/3/2014 10:06'!generateCodeOfType: aSymbol fromTokens: tokens at: xToken	"Generate code of the given type HTML/Seaside/JavaScript based on token stream."	| currentToken code cr doubleQuote singleQuote calc |		self delegated.	calc := HumCalculator new.	"Current experiment is to generate HTML5 from Hum mark-up."	self assert: aSymbol = #HTML.	code := String new.	cr := String cr.	"If we ran out of tokens, we are done?"	( xToken > tokens size ) ifTrue: [ ^self ].	currentToken := tokens at: xToken.	"If we are at beginning of line, there are special rules."	( xToken = 1 )		ifTrue: [ "Look for heading, list, or instruction."			(currentToken = '.') 				ifTrue: [ "Line is instruction." "Ignore it for now. Make a comment line as a reminder."					code := '<!!-- ', source, ' -->'.  					^ code.					].			(currentToken = '!!') 				ifTrue: ["Line is heading. But what level?"					| level |					level := 1.					[ (level < (tokens size))  and: [ (tokens at: level + 1 ) = '!!' ] ] whileTrue: [ level := level + 1 ].					"Remainder of line is in this header"					code := calc xml: ('h', (level asString))  with: [ self generateCodeOfType: aSymbol fromTokens: tokens at: level + 1 ] .					^code.					].			(currentToken = '-' ) 				ifTrue: ["Line is list. But what level?"					| level |					level := 1.					[ (level < (tokens size))  and: [ (tokens at: level + 1 ) = '-' ] ] whileTrue: [ level := level + 1 ].					"If level has changed, we need to output <ul> or </ul>"					( level > indentLevel ) ifTrue: [ code := '<ul>', cr. ].					( level < indentLevel ) ifTrue: [ code := '</ul>', cr. ].					"Remainder of line is in this header"					code := code, (calc xml: 'li' with: [ self generateCodeOfType: aSymbol fromTokens: tokens at: level + 1 ]) .					^code.					].				"If we have come this far, the line begins with nothing special."			     "Go on as if we were not on the first token."			].		"Look for quotes -- we need to remove tokens between quotes from translation."		doubleQuote := $".		singleQuote := $".			(currentToken = doubleQuote or: [ currentToken = singleQuote ] )			ifTrue: [ | quote removal x | 				quote := currentToken.				removal := String new.				x := xToken + 1.				[ ( x < (tokens size) ) and: [ tokens at: x = quote ] ] whileFalse: [ removal := removal, (tokens at: x). x := x + 1. ].				code := code, removal, quote, (self generateCodeOfType: aSymbol fromTokens: tokens at: ( x + 1 )   ).				^code.				].		"Look for emphasis -- tokens between are in scope of  . . ."		(currentToken = '*' or: [[ currentToken = '~' ]  or: [ currentToken = '_' ] ] )			ifTrue: [ | emphasis removal x | 				emphasis := currentToken.				removal := String new.				x := xToken + 1.				[ ( x < (tokens size) ) and: [ tokens at: x = emphasis ] ] whileFalse: [ removal := removal, (tokens at: x). x := x + 1. ].				code := code, removal, emphasis, (self generateCodeOfType: aSymbol fromTokens: tokens at: ( x + 1 )   ).				"Note: Above is a bit simplistic. 				It assumes there is nothing to be interpreted in the string between emphasis tokens.				The following would not work properly: *~bold-italic~*  *_bold-and-underlined_*				TBD: Make this smarter.				"				^code.				].		"Look for widgets."		( currentToken = '[' )			ifTrue: [ "What we do depends on the type of widget."				| nextToken |				nextToken := (tokens at: (xToken + 1) ).				( nextToken = 'page' )					ifTrue: [self generatePageWidgetFromTokens: tokens at: nextToken ].				].! !!HumMarkupLine methodsFor: 'compiling' stamp: 'RichardAlexanderGreen 10/7/2013 14:56'!checkSyntaxWithOntology: aHumOntology 	"Syntax errors in mark-up mainly have to do with widgets that won't work.	Other errors will simply be rendered as-is.	"	|  errors widgets widgetNoun |	""	errors := OrderedCollection new.	widgets := self widgets.	"Look for unknown nouns in widgets."	widgets 		do: [ :widget | 			widgetNoun := HumMarkupLine widgetNounIn: widget.			( aHumOntology isNoun: widgetNoun )				ifFalse: [ errors add: ('In {', self source,'} the widget contains unknown noun: ', widgetNoun ) ].			].	"TODO: Look for unknown widget-types in widgets.	 . Known widget types include 	 . . [page:  TITLE ] -- Link to local page (a la wiki)	 . . [link: TITLE | URL] -- Link to a remote page given by the URL/URI	 . . [pane: TITLE] -- Insert given pane	 . . [range: LB - UB ] -- Provide a slider or similar device on input; a progress bar on output.	 . Attribute types with specific rendering should eventually include 	 . . [category] [text] [date] [email] -- HTML5 can handle directly	 . . [measure] -- accept and validate quantity, unit-of-measure, plus-or-minus	 . . [collection -- display a table? (default rendering or ???)	"	widgets		do: [ :widget | 			].		^errors.! !!HumMarkupLine methodsFor: 'compiling' stamp: 'RichardAlexanderGreen 6/8/2016 09:04'!compileLineToOntology: aHumOntology 	|  errors widgets  |	""	errors := OrderedCollection new.	widgets := self widgets.	"Look for unknown nouns in widgets."	widgets 		do: [ :widget | 			| widgetNoun |			widgetNoun := HumMarkupLine widgetNounIn: widget.			( aHumOntology isNoun: widgetNoun )				ifFalse: [ errors add: ('In {', self source,'} the widget contains unknown noun: ', widgetNoun ) ]				ifTrue: [ 					aHumOntology addNoun: widgetNoun.					aHumOntology addNoun: widgetNoun reference: self.					 ].			].	"TODO: Look for unknown widget-types in widgets."	widgets		do: [ :widget | 			].		^errors.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumMarkupLine class	instanceVariableNames: ''!!HumMarkupLine class methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 6/8/2016 09:30'!widgetNounIn: aWidgetString 	"Find the noun in typical field widgets."	| buttonLabel noun s |		"Heuristic: If there is a colon, this is not a field widget. -- Return empty string."	(aWidgetString includes: $: ) ifTrue: [ ^'' ].		"Ignore buttons -- Return an empty string."	buttonLabel := HumCalculator given: aWidgetString extractBetween: '[[' and: ']]'.	(buttonLabel size > 0) ifTrue: [ ^'' ]. 		"s is potential noun -- May need to remove a number-of-lines parameter"	s := HumCalculator given: aWidgetString extractBetween: '[' and: ']'.	(s includes: $ ) 		ifTrue: [ noun := HumCalculator given: s extractUpto: ' ' ]		ifFalse: [ noun := s ]. 			"TODO: Refactor to deal with possessive case.  e.g. [user`s name]"	^noun.! !Object subclass: #HumOntology	instanceVariableNames: 'nouns nounSubtypes entityAttributes roles roleActions fromFile framesByName framesByIdentifier nounReferences contextVignettes title frames frameRelations viewer translator attributeChain nounCategories debug contexts nounSynonyms'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumOntology commentStamp: 'RichardAlexanderGreen 1/30/2014 12:07' prior: 0!HumOntology is similar to a Smalltalk image file.It records the frames that make up the source code.It also tracks the relationships between syntax elements.Instance Variables:	fromFile	        <String>	-- The name of the file where this ontology was last stored (read).	nouns	        <Set>		-- The nouns known in this ontology	nounSubtypes	  <Set>		-- The subtype relations between nouns 												-- set of ( supertype -> suptype)  associations	entityAttributes  <Set>		-- The attributes of those nouns that represent entity names 													-- set of ( entity -> attribute )	roles	          <Set>		-- The roles defined in this ontology 	roleActions  	  <Set>		-- The actions of the roles 													-- set of ( role -> actionStatement )	instructionSequences   <Dictionary>	-- The instructions that define the actions	framesByName	          <Dictionary>	-- frames indexed by name	framesByIdentifier	    <Dictionary>	-- frames indexed by their unique ID			(An ontology is held in a single file much like the code in a Smalltalk image.)(However, an ontology does not hold run-time state.) An ontology has a set of frames.Token attributes include string.Token types include word, noun, punctuation, keyword, comment, annotation.Frame attributes include frame-title, framelines.Frame types include goal-frame, action-frame, dialog-frame, view-frame, dictionary-frame.Frameline attributes include source, tokens, label, comment.Frameline types include title-line, action-line, precondition-line, markup-line, instruction-line, vignette-line, dictionary-line.Instruction-line attributes include role, statement, comment, annotation.Precondition-line attributes include precondition, commment, annotation.A precondition is a statement.Title-line attributes include label, title, comment. (no annotation)Statement attributes include source, nouns, tokens.Noun attributes include word, supertypes.Noun types include string, category, collection, date, measure, entity, name. (class types)Collection types include set, list. (A collection is a list by default)Measure attributes include quantity, unit-of-measure, distribution, precision.Entity attributes include attributes.Entity-instance attributes include name, values.Value attributes include name, datum.Datum types include string, category, collection, date, measure, entity, name. (instance types)A supertype is a noun.!!HumOntology methodsFor: 'utility' stamp: 'RichardAlexanderGreen 1/7/2016 12:47'!nounAsCamelCase: aString 	|result delimiters tokens |	delimiters := '- '.	tokens := aString findTokens: delimiters keep: ' '.	result := tokens at: 1.	(tokens copyFrom: 2 to: tokens size)		do: [:token | result := result, (token capitalized) ].	^result.! !!HumOntology methodsFor: 'utility' stamp: 'RichardAlexanderGreen 2/8/2014 10:37'!projectValuesOf: aSetOfAssociations from: aKey	"encapsulate a bit of recurring code"	| resultSet |	self assert: ( aSetOfAssociations isKindOf: Collection ).	resultSet := Set new.	aSetOfAssociations do: [ :map | ( map key = aKey) ifTrue: [resultSet add: (map value)] ].	^resultSet.! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 4/28/2015 09:29'!getFrameForRole: aRole action: anAction 	"Get the frame that matches given role and action."	| frame  |	"TODO: Kludge some polymorphism.	 TODO: Fix-up string arguments"		(self roleActions)		do: [:map | 			| role frameAction |			role := map key.			frameAction := map value.			self assert: (role = (role capitalized)) description: 'Watch for index bug.'.			( (role sameAs: aRole) 			  and: [frameAction matchesCandidateStatement: anAction inOntology: self])					ifTrue: ["Get the frame. If it does not exist, make it."						| frameKey |						frameKey := 'Role: ',aRole,' -- ',(frameAction source).						frame := (self framesByName) at: frameKey 						                  ifAbsent: [ "Make and store an action frame."																frame := HumFrame4Action ontology: self role: role action: frameAction.							 									self storeFrame: frame.																frame.																].						^frame.						].			].	"If no frame is found/generated (will happen for a new role), return an empty frame."	frame ifNil: [frame := HumFrame4Action ontology: self role: aRole action: anAction.].	self assert: (frame isKindOf: HumFrame4Action) .	^frame.! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 4/28/2015 10:48'!actionsOf: aRole	"The actions of a role define its public interface. (API).	NOTE: Statements prefixed with: 'To: ' name private methods. 	"      ^self projectValuesOf: (self roleActions) from: (aRole capitalized).! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 3/24/2015 08:59'!getRole: aRole action: aStringOrStatement 	"Get the action if it already exists."	| actionStatement |	"TODO: Kludge some polymorphism.	 TODO: Fix-up string arguments"		"Assure that we are dealing with a HumStatment."	actionStatement := aStringOrStatement copy.	( actionStatement isKindOf: HumStatement ) 		ifFalse: [ actionStatement := HumStatement from: aStringOrStatement ].	"If the role action set already contains the action statement,	    return an equivalent statement.	"		(self roleActions include: ( ( aRole capitalized ) -> actionStatement ) ) 		ifFalse: [ "The role does not currently define a proper match"			"TODO: Refactor to handle polymorphism."			self error: 'Attempt to get a non-existent action statement.'. 			^nil ].	^actionStatement.! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 3/17/2015 12:10'!indexRole: aRole action: actionStatement    "Index role and action statement."   | capRole |		self assert: ( aRole isKindOf: String ).	self assert: ( actionStatement isKindOf: HumStatement ).	"Assure role is in set."	capRole := aRole capitalized.	self addRole: capRole.		"Assure statement is in set."	self roleActions add: ( capRole -> actionStatement ).! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 2/12/2014 10:55'!getFramesThatInvokeAction: anActionString 	"Lookup the frames where action is invoked."	| resultSet  |	resultSet := self getFramesWithRelation: #invokesAction object: anActionString.	^ resultSet.! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 12/30/2011 10:20'!roleActions	"This instance variable is a map, a set of associations  ( role -> actionStatement ) "	^roleActions ifNil: [ roleActions := Set new.]! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!appendRole: aRole action: actionStatement    "Add role and action statement."   | capRole |	Error signal: 'Use indexRole: aRole action: actionStatement.'.	self assert: ( aRole isKindOf: String ).	self assert: ( actionStatement isKindOf: HumStatement ).	"Assure role is in set."	capRole := aRole capitalized.	self addRole: capRole.		"Assure statement is in set."	self roleActions add: ( capRole -> actionStatement ).! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 1/17/2012 12:50'!isActionDefinedV01: anInstructionLine 	"See if we have a definition for the given action."	| numberOfDefinitions |	numberOfDefinitions := ( self roleActions ) 		count: [ :map | 			( map key = anInstructionLine  role ) and: [ map value = anInstructionLine statement ].			].	self assert: ( numberOfDefinitions < 2 ).	^ numberOfDefinitions > 0.		! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 3/24/2015 08:57'!appendInstruction: aHumInstruction toRole: aRole action: anAction 	"Append the given instruction to the action's sequence of instructions."	| sequence instruction actionString actionFrame |		self assert: ( aRole isKindOf: String ).	actionString := (anAction isKindOf: String ) ifTrue: [ anAction ] ifFalse: [ anAction asString ].	self assert: ( actionString isKindOf: String ).		instruction := aHumInstruction copy.	( instruction isKindOf: String ) ifTrue: [ instruction := HumInstructionLine statement: aHumInstruction ].				"Get the sequence of instructions belonging to this role action."	actionFrame := self getFrameForRole: aRole capitalized action: actionString. 	sequence := actionFrame frameLines.		"Append the given instruction to the sequence."	sequence add: instruction.		"Assure that the data store is updated."	self storeFrame: actionFrame.! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 12/29/2011 17:21'!critiqueRole: aRole action: anAction 	"Critique the instructions for this role action."	|  critique actionStatement sequence actionNouns instructionNouns |			"Return the critique as a sequence of strings."	critique := OrderedCollection new.		"The action should contain at least one noun."	actionStatement := self getRole:  aRole action: anAction.	actionNouns := self nounsInStatement: actionStatement.	( actionNouns size > 0 ) 		ifFalse: [ critique add: 'Action Statement has no known nouns.'].			"There should be at least one instruction for the action statement."			sequence := self instructionsForRole: aRole action: anAction.	( sequence size > 0 )		ifFalse: [ critique add: 'Action has no instructions.'].				"Nouns in the instructions should find antecedants in the action statement."	sequence 		do: [ :instruction | 			instructionNouns := self nounsInStatement: instruction statement.			( actionNouns includesAllOf: instructionNouns )				ifFalse: [ critique add: ( 'Some nouns lack antecedants in: ', instruction statement source ) ].			]. 		^critique.! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 9/17/2014 11:35'!addRole: aRole 	self assert: (aRole isKindOf: String ).	self roles add: aRole capitalized.! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 12/30/2011 10:20'!roles	"This instance variable contains the set of all roles that have been defined so far."	^roles ifNil: [ roles := Set new.].! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 12/30/2014 09:36'!instructionsForRole: aRole action: anAction	| actionFrame lines actionStatement |	self assert: (aRole > '') description: 'Role cannot be empty for frame lookup.'.	(anAction isKindOf: HumStatement) ifTrue: [ actionStatement := anAction  ].	(anAction isKindOf: HumInstructionLine) ifTrue: [ actionStatement := anAction statement ].	(anAction isKindOf: String ) ifTrue: [ actionStatement := HumStatement source: anAction ].	self assert: (actionStatement isKindOf: HumStatement ).	actionFrame := self getFrameForRole: aRole capitalized action: actionStatement.	lines := actionFrame frameLines.	^lines.  	! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 5/10/2016 10:14'!isActionDefined: anInstructionLine inRole: aRole	"Has the given statement been defined as an action for the given role?"	| instructions result | 	"TODO: Kludge some polymorphism.	 TODO: Fix-up string arguments"		(aRole > ' ') ifFalse:[Error signal: 'Role cannot be empty for action lookup.'].	instructions := self instructionsForRole: aRole action: ( anInstructionLine statement ).	result := ( instructions size > 0 ).	"(result) ifFalse: [ self halt. ]."	^ result.! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 3/24/2015 10:15'!yesRole: aRole hasAction: aSource	"Is the given action defined for the given role?"	| actionCandidate |	"Convert String to Statement, if needed."	(aSource isKindOf: String)		ifTrue: [actionCandidate := HumStatement source: aSource].	(aSource isKindOf: HumStatement)		ifTrue: [actionCandidate := aSource].	self assert: (actionCandidate isKindOf: HumStatement).	 	^(self actionsOf: (aRole capitalized ) ) anySatisfy: [ :statement | 		 actionCandidate matchesTemplateStatement: statement inOntology: self.		 ] .! !!HumOntology methodsFor: 'about Vignettes' stamp: 'RichardAlexanderGreen 6/1/2015 08:57'!addVignette: aFrame4Vignette toContext: aContext 	"Add to store"	| contextKey |	contextKey := self cleanKey: aContext.	( self contexts ) add: contextKey.	( self contextVignettes ) add: ( contextKey -> aFrame4Vignette ).		"frame defines context"	self indexFrame: aFrame4Vignette relation: #definesContext object: contextKey.! !!HumOntology methodsFor: 'about Vignettes' stamp: 'RichardAlexanderGreen 4/28/2015 10:23'!contexts	^ contexts ifNil: [  contexts := Set new. ]! !!HumOntology methodsFor: 'about Vignettes' stamp: 'RichardAlexanderGreen 6/1/2015 08:51'!getFramesThatDefineContext: aContextName 	"Get the vignette frames that define the given context."	| resultSet |	resultSet := Set new.		resultSet := self getFramesWithRelation: #definesContext object: ( self cleanKey: aContextName ).	^resultSet.! !!HumOntology methodsFor: 'about Vignettes' stamp: 'RichardAlexanderGreen 6/1/2015 09:00'!vignettesForContext: aRequestedContext	| vignettes calc requestedContext |	self assert: ( aRequestedContext isKindOf: String ).	"DEBUG ('*activity*' match: aRequestedContext ) ifTrue: [ self halt. ]."	requestedContext := self cleanKey: aRequestedContext.	calc := HumCalculator new.	vignettes := OrderedCollection new.	(self contextVignettes )		do: [ :contextVignette |			| contextName contextFrame  |			self assert: (contextVignette isKindOf: Association ).			contextName  := contextVignette key.			contextFrame := contextVignette value.			( calc string: contextName isLike: requestedContext ignore: ' .' ) ifTrue: [ vignettes add: contextFrame ].			].	^vignettes.! !!HumOntology methodsFor: 'about Vignettes' stamp: 'RichardAlexanderGreen 8/14/2013 20:54'!findBestMatchingVignetteForInput: aString inContextStack: aStack 	"Search the vignette frames for the one whose pattern is the best match	for the given input and context-stack."	| bestMatch stackCopy bestMatchScore |	self assert: ( aString isKindOf: String ).	self assert: ( aStack  isKindOf: Stack ).	self assert: ( aStack notEmpty ).	"We want the best match with a score better than zero."	bestMatchScore := 0.	aStack		do: [ :contextString |			"See if we have any vignettes that match that context."			| vignettesInContext |			vignettesInContext := self vignettesForContext: contextString.			"Get the bestMatch from that set."			vignettesInContext				do: [ :candidate |					| score |					score := candidate patternMatchScore: aString.					( score > bestMatchScore)							ifTrue: [ bestMatch := candidate. 								        bestMatchScore := score. 								     ].					].			].	( bestMatchScore = 0 )			ifTrue: [ bestMatch := self hasNoVignetteMatchFor: aString. ].	^ bestMatch.! !!HumOntology methodsFor: 'about Vignettes' stamp: 'RichardAlexanderGreen 2/8/2014 10:39'!contextVignettes	"This list holds the (1:M) relation (context -> vignette)."	contextVignettes ifNil: [ contextVignettes := OrderedCollection new. ].	"Vignettes are evaluated in the order seen."	"TODO: Decide if we need a priority attribute on a vignette to enable re-ordering." 	self assert: (contextVignettes isKindOf: OrderedCollection ).	^contextVignettes.! !!HumOntology methodsFor: 'about Vignettes' stamp: 'RichardAlexanderGreen 1/8/2015 17:13'!hasNoVignetteMatchFor: aString 	| defaultVignette |	(self debug) ifTrue: [Error signal: 'No vignette pattern match for {',aString,'}'].	defaultVignette := HumFrame4Vignette ontology: self vignetteContext: 'any' pattern: aString trimBoth.	defaultVignette addVignetteResponse: ('Sorry, { ', aString, '} is not understood.').	^ defaultVignette.! !!HumOntology methodsFor: 'about Views' stamp: 'RichardAlexanderGreen 1/2/2015 20:51'!getViewFrame: nameString 	"Get the view frame with the given name."	| frame viewName |	viewName := nameString.	(viewName endsWith: '.') ifTrue: [viewName := nameString copyFrom: 1 to: ((nameString size) - 1)].	frame := ( self framesByName ) 						at: ('View: ', viewName trimBoth capitalized,'.')						ifAbsent: ["If none, make one."							Error signal: 'No such view as: ', viewName.							frame := HumFrame4View ontology: self viewEntity: viewName.							].	^frame.! !!HumOntology methodsFor: 'about Views' stamp: 'RichardAlexanderGreen 1/2/2015 18:32'!addViewFrame: aHumFrame4View 	self storeFrame: aHumFrame4View.	self addNoun: aHumFrame4View entity isA: 'view'.! !!HumOntology methodsFor: 'about Views' stamp: 'RichardAlexanderGreen 4/16/2014 19:12'!isViewName: aString 	"Does the string name a view frame?"	| frame result |	frame := (self framesByName) at: ('View: ',aString trimBoth,'.') ifAbsent: [^false].	result := frame isKindOf: HumFrame4View.		^result.! !!HumOntology methodsFor: 'about Views' stamp: 'RichardAlexanderGreen 2/12/2014 10:55'!getFramesThatInvokeView: aViewName	"A view may be invoked by another view or by a vignette."	| resultSet |	"Compiler will scan views to index [pane: ...] pattern. " 		"Compiler will scan vignettes to index instructions 'Show <viewname>.' and 'Ask <viewname>.'"	resultSet := self getFramesWithRelation: #invokesView object: aViewName.		^resultSet.	! !!HumOntology methodsFor: 'translate to' stamp: 'RichardAlexanderGreen 5/20/2014 09:23'!codeGenerator	"Return a translator."	^translator 		ifNil: [ 			"Precondition: Assure we are compiled."			self compileAllFrames.			"TODO: This 'Assure we are compiled.' strategy will fail 			       when the ontology is updated between translations."			"Post condition: translator is set."			translator := HumOntologyTranslator ontology: self. 			].! !!HumOntology methodsFor: 'translate to' stamp: 'RichardAlexanderGreen 2/12/2014 12:15'!view	^viewer ifNil: [ viewer := HumOntologyViewer ontology: self. ].! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 2/12/2014 12:11'!getFramesThatInvokeContext: aContextName 	"Get frames with 'Push context <aContextName>.'  instructions."	| resultSet |	resultSet := self getFramesWithRelation: #invokesContext object: aContextName.	^resultSet.! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 1/15/2012 08:59'!fromFile	"The file name serves as a natural identifier. "	^ fromFile ifNil: [ ^ '(untitled)' ].! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 3/17/2015 12:11'!storeFrame: aFrame 	"Store this frame in the ontology.	The frame may be stored even if it has errors.	"	| primaryKey frameName |	self assert: (aFrame isKindOf: HumFrame ).	"If the frame does not have an ID (serial-number) give it one."	"The title of the frame can serve to index it but cannot be used to ID it 		because the title can be changed by the user 			while the intent of the frame remains the same."	primaryKey := aFrame uniqueIdentifier.	( self framesByIdentifier ) at: primaryKey put: aFrame.		"Also enable caller to fetch a frame by its name."	frameName := aFrame frameName.	( self framesByName ) at: frameName put: aFrame.		"Also enable caller to fetch frames by role."	( aFrame isKindOf: HumFrame4Action ) 		ifTrue: [self indexRole: (aFrame role) action: aFrame actionStatement.].	"Enable caller to fetch vignettes by context-name."	( aFrame isKindOf: HumFrame4Vignette )		ifTrue: [self addVignette: aFrame toContext: aFrame vignetteContext ].			"Also enable caller to fetch frame collection without any keys."	( self frames ) add: aFrame.		! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 12/8/2014 18:17'!indexFrame: aHumFrame relation: aSymbol object: aKeyString 	"Add the given frame to the index"	| |	self assert: ( aSymbol isKindOf: Symbol ).	(self frameRelations) add: { aHumFrame title. aSymbol. (aKeyString trimBoth asLowercase). }.! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 8/22/2013 15:46'!frames	^ frames ifNil: [ frames := Set new. ].! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 4/20/2015 08:18'!parseFrameLine: frameLine keywords: keywords	"Parse the frameLine -- Return a list of token-type pairs: ( token -> tokenType ).	TODO: Fix this up so that it returns comment and annotation as types."	| whitespace punctuation quote tokens tokenTypePairs tokenType i |	whitespace := String space, String tab, String crlf.	quote := $' asString.	punctuation := '~!!@#$%^&*()_+`={}|[]\:";<>?,./', quote.	"Note: Preserve uppercase in tokens so that first word of a sentence is capitalized."	tokens := frameLine source  findTokens: ( punctuation, whitespace ) keep: punctuation.	tokenTypePairs := OrderedCollection new.	"QUESTION: Is the role-label part of the statement? 	(I think it is part of an instruction, but the statement is separated.)"	i := 1.	[ i <= tokens size ]			whileTrue: [ 			| token |			token := tokens at: i.			tokenType := #word.			( self isNoun: token ) ifTrue: [ tokenType := #noun ].			( keywords include: token ) ifTrue: [ tokenType := #keyword ].			( punctuation includes: (token at: 1) ) 				ifTrue: [ tokenType := #punctuation. "Until proven otherwise."					"Does the source have a comment?"					(((token at: 1) = '(') and: ['*(*)*' match: (frameLine source) ] )						ifTrue: [ "Advance index to closing parend"							| commentString |							commentString := '('.							[ i <= (tokens size) and:[( token at: 1) =')']] 								whileFalse: [ i := i+1. token := tokens at: i. commentString := commentString, ' ', token. ].								token := commentString.								tokenType := #comment.								]. 					"Does the source have annotation?"					(((token at: 1) = '[') and: ['*[*]*' match: (frameLine source) ] )						ifTrue: [ "Advance index to closing parend"							| annotationString |							annotationString := '['.							[ i <= (tokens size) and: [( token at: 1) =']']] 								whileFalse: [ i := i+1. token := tokens at: i. annotationString := annotationString, ' ', token. ].								token := annotationString.								tokenType := #annotation.								]. 					].			tokenTypePairs add: ( token -> tokenType ).			].	^ tokenTypePairs.! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 2/12/2014 10:22'!frameRelations	"The cross index collection tracks relationships between frames."	"Entries have the form: { frameA. #symbol. frameB. }	  where the frames are identified by their titles.	 Cases:		- { frameA.    #invokes. actionB. }  ( frameA may be action, plan, or vignette. )		- { vignetteA. #stacks. contextB. }		- { goalA.     #requires.  goalB. }  ( This very like plan tree. )	"	^ frameRelations ifNil: [ frameRelations := Set new. ].! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 1/15/2012 10:34'!fetchFrameByIdentifier: aPrimaryKey 	"Fetch the frame with this identifier."	| frame |	frame := ( self framesByIdentifier ) at: aPrimaryKey ifAbsent: [ Error signal: 'No such frame in this ontology!!'].	^frame.! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 12/6/2014 09:57'!fetchFrameByName: aString 	| frame |	self assert: (aString isKindOf: String).	"self assert: (aString endsWith: '.')."	frame := (self framesByName ) at: aString ifAbsent: [ Error signal: 'No frame by this name.'].	^frame.! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 4/30/2015 13:11'!frameRelationsWhere:  aBlock	"Return frame relations where aBlock evaluates as true"	| selectedRelations |	selectedRelations := frameRelations 			select:  [ :frameRelation |				| a r b |				a := frameRelation at: 1.				r := frameRelation at: 2.				b := frameRelation at: 3.				aBlock value: a value: r value: b ].	^selectedRelations.! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 3/17/2015 11:41'!getFramesWithRelation: aSymbol object: aName	"Get frames that are indexed with given relation and object."	| resultSet |	resultSet := Set new.		(self frameRelations select: [:tuple | (tuple at: 2) = aSymbol])		do: [ :relation |		"Relation looks like { frameTitle. relationSymbol. someString. }"			| subject verb object |			subject := relation at: 1.			verb := relation at: 2.			object := relation at: 3.			(( verb = aSymbol ) and: [ object = (aName trimBoth asLowercase) ])					ifTrue: [ resultSet add: subject. ].			].	^resultSet.! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 1/25/2012 20:22'!framesByIdentifier	"Each frame is given a unique identifier. 	This store indexes the frames their identifiers."	^ framesByIdentifier ifNil: [ framesByIdentifier := Dictionary new. ].! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 5/14/2016 11:06'!compileAllFrames	"Compile the dictionary frames first, then the others." 	| dictionaryFrames otherFrames problems frameProblems |	"Return any problems found."	problems := OrderedCollection new.	"Reset the frame index"	frameRelations := nil.		"Compile the dictionary frames first."	dictionaryFrames := (self frames) select: [:frame | frame isKindOf: HumFrame4Dictionary ].	dictionaryFrames		do: [ :frame | 			frameProblems := frame compileToOntology: self. 			problems addAllLast: frameProblems.			].			"Compile the remaining frames."	otherFrames := (self frames) select: [:frame | (frame isKindOf: HumFrame4Dictionary) not ].	otherFrames		do: [ :frame | 			frameProblems := frame compileToOntology: self. 			problems addAllLast: frameProblems.			].			^problems.! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 1/15/2012 10:32'!framesByName	"Enable access to frames by their name (title line string)."	^ framesByName ifNil: [ framesByName := Dictionary new ].! !!HumOntology methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/18/2012 17:51'!file: aString 	fromFile := aString.! !!HumOntology methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/22/2016 10:00'!title	^ title ifNil: [ title :=  (self fromFile), ' -- No title yet.'. ].! !!HumOntology methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/6/2012 16:27'!title: aString 	title := aString! !!HumOntology methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/25/2012 09:44'!file	^ fromFile ifNil: [ fromFile := 'HumOntologyFile.ontology' ].! !!HumOntology methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 12/16/2014 07:50'!parseStatement: aHumStatement triggerWords: triggerWords keywords: keywords 	"Parse the statement -- Return a list of token-type pairs: ( token -> tokenType ).	triggerWords are 'if else for-each' when they appear as first word. 	TODO: Fix this up so that it returns comment and annotation as types."	|  whitespace punctuation quote tokens tokenTypes tokenType firstToken |	self assert: (triggerWords isKindOf: String) not.	self assert: (keywords isKindOf: String) not.	whitespace := Character separators.	quote := $' asString.	punctuation := '~!!@#$%^&*()_+`={}|[]\:";<>?,./', quote.	"TODO: Scan to detect and remove strings delimited by quote or double-quote."	(aHumStatement source includes: '"') ifTrue: [Error signal: 'Strings as tokens is not implemented yet.'].	"Note: Preserve uppercase in tokens so that first word of a sentence is capitalized."	tokens := aHumStatement source  findTokens: ( punctuation, whitespace ) keep: punctuation.	tokenTypes := OrderedCollection new.	"QUESTION: Is the role-label part of the statement? 	(I think it is part of an instruction, but the statement is separated.)"	firstToken := true.	tokens 		do: [ :token | 			tokenType := #word.			( self isNoun: token ) ifTrue: [ tokenType := #noun ].			( firstToken and: [triggerWords include: (token asLowercase)]) ifTrue: [ tokenType := #keyword ].			( (firstToken not) and: [keywords include: (token asLowercase)]) ifTrue: [ tokenType := #keyword ].			( punctuation includes: (token at: 1) ) ifTrue: [tokenType := #punctuation ].			( token isAllDigits ) ifTrue: [ tokenType := #number. ].			tokenTypes add: ( token -> tokenType ).			firstToken := false.			].	"TODO: Detect measurement pattern: 'number unit-of-measure' "	^ tokenTypes.! !!HumOntology methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 9/28/2014 12:56'!xparseString: aStatementString keywords: keywords 	"Coding experiment to see if I can tweak existing code to handle quoted strings."	"Parse the statement string -- Return a list of token-type pairs: ( token -> tokenType ).	TODO: Fix this up so that it returns comment and annotation as types."	| whitespace punctuation quote tokens tokenTypes tokenType doubleQuote isQuoteSeen |	whitespace := ' 			'.	quote := $' asString.	doubleQuote := $" asString.	isQuoteSeen := false.	"Note: Preserve uppercase in tokens so that first word of a sentence is capitalized."	punctuation := '~!!@#$%^&*()_+`={}|[]\:;<>?,./', quote, doubleQuote.	tokens := aStatementString  findTokens: ( punctuation, whitespace ) keep: punctuation.	tokenTypes := OrderedCollection new.	"QUESTION: Is the role-label part of the statement? 	(I think it is part of an instruction, but the statement is separated.)"	tokens 		do: [ :token | 			tokenType := #word. "default"			( self isNoun: token ) ifTrue: [ tokenType := #noun ].			( keywords include: token ) ifTrue: [ tokenType := #keyword ].			( punctuation includes: (token at: 1) ) "WARNING: A sequence of punctuation is single token."				 ifTrue: [tokenType := #punctuation ].			( token isAllDigits ) ifTrue: [ tokenType := #number. ].			( token = quote or: [token = doubleQuote] ) ifTrue: [tokenType := #quote. isQuoteSeen := true. ].			tokenTypes add: ( token -> tokenType ).			].	"Collapse quoted string."	isQuoteSeen 		ifTrue: ["Collapse the tokens in the quoted string into a single token."			self shouldBeImplemented.			].	"TODO: Detect measurement pattern: 'number unit-of-measure' "	^ tokenTypes.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 8/1/2016 09:32'!categoriesOf: anAttributeName include: anArrayOfCategoryNames	"Add this noun in case it is not already added;"	"and make it a kind of category"	| setOfCategories attribute |	attribute := anAttributeName trimBoth asLowercase. 	self addNoun: attribute isA: 'category'.	setOfCategories := self categoriesOf: attribute.	anArrayOfCategoryNames do: [:category | setOfCategories add: category ].	(self nounCategories) at: attribute put: setOfCategories.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 6/11/2015 09:19'!isNoun: aNounString 		"Is the given string a noun?"	| singular |	self assert: [ aNounString isKindOf: String ].	"TODO: Refactor to deal with possessive case. e.g. 'user`s name'. "	singular := self singularFormOfNoun: aNounString.	^( self nouns ) include: singular.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 6/1/2015 08:47'!cleanKey: aString	"Assure that the string will be a clean key -- convert to lower-case, trim blanks."	| camelCase |	camelCase := HumCalculator camelCase: aString.	^camelCase.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/5/2016 09:41'!getEntityAttributePhraseFromStatement: aHumStatement 	"Return collection of 'entity attribute' pairs when statement contains possessive nouns."	| remainder  pairs |	pairs := OrderedCollection new.	remainder := aHumStatement source.	['*`s *' match: remainder]		whileTrue: [  "Get the first entity and the attribute pair"			| entity attribute front back tokens |			front := HumCalculator given: remainder  extractUpto: '`s '.			back := HumCalculator given: remainder  extractAfter: '`s '.			tokens := HumCalculator findTokensInString: front.			entity := tokens last.			tokens := HumCalculator findTokensInString: back.			attribute := tokens first.			remainder := HumCalculator given: back extractAfter: attribute.			pairs add: (entity, ' ', attribute).			"TODO: Perhaps we should put '`s' in the pair. Leave a clue, other than the space, for other processes."			].	^pairs.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 6/16/2015 09:34'!addNoun: aNoun 	"Remember noun."	| singularNoun |	self assert: (aNoun isKindOf: String).	(#('a' 'an' 'the') includes: (aNoun)) 		ifTrue: [ "Error signal: 'Attempt to add article as noun.' "			^self.			].	"Watch for parsing bug"	(aNoun at: 1) isLetter ifFalse: [ Error signal: 'noun must start with a letter.' ].		singularNoun := self singularFormOfNoun: aNoun.	self nouns add: singularNoun.	"Check if noun has an implied supertype."	self setAutomaticSupertypeForNoun: singularNoun.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/22/2015 18:17'!categoriesOf: anAttributeName 	| categories |	^categories := (self nounCategories) at: anAttributeName ifAbsent: [Set new].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/21/2015 20:08'!allAttributesOfEntity: anEntity 	"Get the attributes, the attributes of the attributes, and the attributes of the supertypes."	| allAttributes localAttributes tempAttributes localSupertypes localProperties entity |	(self attributeChain includes: anEntity) ifTrue: [ ^Set new. "Return empty set to terminate cycle." ].	self attributeChainPush: anEntity.	entity := anEntity asLowercase.	self assert: (entity sameAs: anEntity).	"Get the immediate properties of this entity."	localAttributes := self immediateAttributesOfEntity: anEntity.	self assert: (( localAttributes include: anEntity ) not ) description: 'An entity should not be an attribute of itself.'.	localSupertypes := self immediateSupertypesOf: anEntity.	self assert: (( localSupertypes include: anEntity ) not ) description: 'An entity should not be a supertype of itself.'.		"Entity properties include attributes and supertypes."	localProperties := localAttributes, localSupertypes.	self assert: ( localProperties include: anEntity ) not.		"For each local property: Look up attributes and add them to the result set."	allAttributes := localAttributes.	self assert: ( allAttributes include: anEntity ) not.	localProperties 		do: [ :eachProperty |			"RECURSIVE CALL !!!!!!"			tempAttributes := self allAttributesOfEntity: eachProperty.			allAttributes := allAttributes, tempAttributes.			"Detect cycles in the tree."			( allAttributes include: anEntity ) 				ifTrue: [ Error signal: 'noun attribute-tree contains cycle at: ', anEntity ].			 ].	self attributeChainPop: anEntity.		^allAttributes	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 6/11/2016 09:03'!yesNoun: aSubtype isAKindOf: aSuperType 	"Is the noun a subtype of the given supertype? Used when matching action statements."	| result |	"Check for special case:	Action statement definitions in the base ontology may include 'entity' as a noun.	The noun 'entity' is not in the base ontology because it would cause too much clutter.	Example: 'New entity.' action statements.	"	(aSuperType = 'entity')		ifTrue: [ ^self isEntity: aSubtype ].	"Normal case:"	result := self nounSubtypes includes: ( aSuperType -> aSubtype  ).	^result.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/30/2011 08:32'!immediateSubtypesOf: aSuperType 	"Get the subtypes (if any) of this noun."	^ self projectValuesOf: (self nounSubtypes) from: aSuperType.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 6/11/2016 08:43'!nounsInStatement: aHumStatement 	"Return the (known) nouns found in the statement."	| tokens statement statementNouns nounSet |	"Forgive a nil statement. (Sometimes an instruction line has no statement.)"	aHumStatement ifNil: [ ^OrderedCollection new ].	"Forgive a string instead of a statement."	statement := aHumStatement.	(statement isKindOf: String) ifTrue: [ statement := HumStatement from: aHumStatement ].	self assert: ( statement isKindOf: HumStatement ).		tokens := statement tokens.	nounSet := self nouns copy.	statementNouns := tokens select: [ :token | nounSet includes: token ].	"TODO: Detect entity-attribute noun-phrase. Example: recipe`s bake-time."	('*`s*' match: statement source) 		ifTrue: [ | pairs | pairs := (self getEntityAttributePhraseFromStatement: statement).			"Remove nouns in each pair from the prior set."			pairs do: [ :pair | 				| entity attribute |				entity := HumCalculator given: pair extractUpto: ' '.				attribute := HumCalculator given: pair extractAfter: ' '.				statementNouns remove: entity ifAbsent: [].				statementNouns remove: attribute ifAbsent: [].				statementNouns add: pair.				 ].			].	"TODO: Technical strategy for dealing with explicit constants in caller code."	"TODO: Detect quoted strings as nouns? -- (Caller side)"	"TODO: Detect measurements as nouns? -- (Caller side)"	"TODO: Detect names as nouns? -- (Caller side) "	^statementNouns.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 2/28/2014 13:08'!attributeChain	^attributeChain ifNil: [ attributeChain := Stack new.]! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 4/18/2014 20:47'!isCategory: aNameString	"Does the string name an attribute? (An attribute has no attributes of its own.)"	| result attributes |		"First: Does it name a noun?"	result := self isNoun: aNameString.	result ifFalse: [^false].		result := self yesNoun: aNameString isAKindOf: 'category'.	^result.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 3/27/2014 17:23'!allSubtypesOf: aSuperType 	"Get the subtypes (if any) of this noun and the subtypes of the subtypes all the way down"	| localSubtypes tempSubtypes allSubtypes |	localSubtypes := self immediateSubtypesOf: aSuperType asLowercase.	allSubtypes := localSubtypes.	localSubtypes 		do: [ :eachSubtype | 			"RECURSION: Get the subtypes for each of those subtypes."			tempSubtypes := self allSubtypesOf: eachSubtype.			"Merge the sets"			allSubtypes := allSubtypes, tempSubtypes. 			"Detect cycles in the tree."			( allSubtypes includes: aSuperType ) 				ifTrue: [ Error signal: 'noun subtype-tree contains a cycle at: ', aSuperType ].		 	].	"Return the merged set of all subtypes."		^allSubtypes.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 3/27/2014 17:23'!allSupertypesOf: aSubType 	"Get the Supertypes (if any) of this noun and the Supertypes of the Supertypes all the way down"	| localSupertypes tempSupertypes allSupertypes |	localSupertypes := self immediateSupertypesOf: aSubType asLowercase.	allSupertypes := localSupertypes.	localSupertypes 		do: [ :eachSupertype | 			"RECURSION: Get the Supertypes for each of those Supertypes."			tempSupertypes := self allSupertypesOf: eachSupertype.			"Merge the sets"			allSupertypes := allSupertypes, tempSupertypes. 			"Detect cycles in the tree."			( allSupertypes includes: aSubType ) 				ifTrue: [ Error signal: 'noun Supertype-tree contains a cycle at: ', aSubType ].		 	].	"Return the merged set of all Supertypes."		^allSupertypes.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 3/27/2014 16:38'!nounCategories	^ nounCategories ifNil: [ nounCategories := Dictionary new ].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 4/19/2014 11:16'!addEntity: anEntity attributes: anAttributeCollection       "Define these nouns and their relationship." | entityName |	entityName := anEntity asLowercase.	self addNoun: entityName.	anAttributeCollection 		do: [ :anAttribute | 			self addEntity: anEntity attribute: anAttribute.			].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/30/2011 10:16'!nouns	"This instance variable is the set of all nouns that have been defined so far."	^nouns ifNil: [ nouns := Set new.].	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 4/8/2014 09:09'!isEntity: aNameString	"Does the string name an entity?"	| result attributes |		"First: Does it name a noun?"	result := self isNoun: aNameString.	result ifFalse: [^false].		"An entity has one or more attributes."	attributes := self allAttributesOfEntity: aNameString.	result := attributes size > 0.	^result.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/21/2015 09:35'!buildNounTreeForNoun: aNoun indent: anIndentLevel 	""	|  nounTree subTree singular supertypes properties attributes |	self assert: (anIndentLevel < 5).	nounTree := OrderedCollection new.	attributes := self immediateAttributesOfEntity: aNoun.	supertypes := self allSupertypesOf: aNoun.	properties := attributes, supertypes.	(properties sorted)		do: [ :property  |			nounTree add: ( aNoun -> { anIndentLevel. property.} ).			singular := self singularFormOfNoun: property.			subTree := self buildNounTreeForNoun: singular indent: (anIndentLevel + 1).			nounTree := nounTree, subTree.			"Detect a cycle in the tree."			( nounTree anySatisfy: [ :map |  (map value at: 2) = aNoun ] ) 				ifTrue: [ Error signal: 'cycle detected in noun tree' ].			].		^nounTree.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 5/9/2016 08:22'!nounSynonyms	^nounSynonyms ifNil: [  nounSynonyms := Set new ].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 2/28/2014 10:59'!isPluralNoun: aNoun	"Return true if the noun is plural."	| singular isSingular |	singular := self singularFormOfNoun: aNoun.	isSingular := (singular sameAs: aNoun).	^isSingular not.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 6/16/2015 10:47'!singularFormOfNoun: aNoun 	"If noun ends in 's'  remove the 's'.  Crude."	| s singular calc |	self assert: ( aNoun isKindOf: String ).		s := aNoun asLowercase.		"Following is first approximation. 	TODO: Deal with other plural forms."	calc := HumCalculator new.	calc cases;		when: [ (s endsWith: 's' ) not] then: [ singular := s ];		when: [ s endsWith: 'ss' ] then: [ singular := s ];		when: [ s endsWith: 'ies' ] then: [ singular :=  (s copyFrom: 1 to: (s size-3)),'y' ];		when: [ s endsWith: 'es' ] then: [ singular :=  (s copyFrom: 1 to: (s size-1)) ];		otherwise: [  singular := singular :=  (s copyFrom: 1 to: (s size-1))  ].	^singular.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 3/27/2014 17:26'!addNoun: aSubType isA: aSuperType       "Add these nouns and add is-A relation."	| theNoun theSuperType |	theNoun := aSubType asLowercase.	theSuperType := aSuperType asLowercase.	"Add these nouns in case they are not already added."	self addNoun: theNoun.	self addNoun: theSuperType.	"Add inverse relation -- Note: subtypes is also a Set."	self nounSubtypes add: ( theSuperType -> theNoun).	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/29/2011 10:57'!addNouns: anArrayOfNouns 		anArrayOfNouns do: [ :noun | self addNoun: noun ].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 7/22/2013 16:56'!addEntity: anEntity attribute: anAttribute       "Define these nouns and their relationship."	| lcEntity lcAttribute |	lcEntity := anEntity asLowercase.	lcAttribute := anAttribute asLowercase.	self addNoun: lcEntity.	self addNoun: lcAttribute.	"Add entity-attribute relationship."	self entityAttributes add: ( lcEntity -> lcAttribute ).! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/21/2015 09:54'!immediateSupertypesOf: aNoun	"Get the immedate supertypes (if any) for this noun." 	| mapSet supertypes |	"Initialize the result set."	supertypes := Set new.	"for each map ( supertype -> subtype ):"	mapSet := self nounSubtypes.	mapSet 		do: [ :nounSubtype |			( nounSubtype value = aNoun )				ifTrue: [ supertypes add: nounSubtype key ].			].	^supertypes.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 2/28/2014 13:06'!attributeChainPush: anAttribute   self assert: ((self attributeChain) includes: anAttribute ) not. 	(self attributeChain) push: anAttribute.	 ! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/30/2011 10:28'!immediateAttributesOfEntity: anEntity 	^ self projectValuesOf: (self entityAttributes) from: anEntity.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/23/2012 17:53'!nounReferences	^ nounReferences ifNil: [ nounReferences := Set new. ].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 6/25/2015 10:57'!entityAttributes	"This instance variable is a map, a set of associations ( anEntity -> anAttribute )"	^entityAttributes ifNil: [ entityAttributes := Set new.].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 2/28/2014 13:10'!attributeChainPop: anAttribute   self assert: (self attributeChain top) = anAttribute.	self attributeChain pop.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 4/18/2014 20:44'!nounSubtypes	"This instance variable is a map, a set of associations ( aSuperType -> aSubType )."	^ nounSubtypes ifNil: [ nounSubtypes := Set new.].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 5/9/2016 08:09'!addNoun: aSynonym isSynonymFor: aStandardNoun    "Add these nouns and add is-A relation."	| theNoun theSynonym |	theNoun := aStandardNoun asLowercase.	theSynonym := aSynonym asLowercase.	"Add these nouns in case they are not already added."	self addNoun: theNoun.	self addNoun: theSynonym.	"Add inverse relation -- Note: subtypes is also a Set."	self nounSynonyms add: ( theSynonym -> theNoun).	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 6/11/2016 09:20'!addNoun: aNoun isDerivedFrom: anotherNoun	 self log: 'This ontology uses advanced features that have not been implemented yet.'	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/23/2012 17:52'!addNoun: aNounString reference: aFrameLine 	"Remember where nouns are referenced."	(self nounReferences ) add: ( aNounString -> aFrameLine ).! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/2/2015 20:20'!isAttribute: aNameString	"Does the string name an attribute? (An attribute has no attributes of its own.)"	| result attributes | 		"First: Does it name a noun?"	result := self isNoun: aNameString.	result ifFalse: [^false].		"An attribute has no attributes. 	 Nor is it a subtype of something that has attributes."	attributes := self allAttributesOfEntity: aNameString.	result := attributes size = 0.	^result.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 4/8/2014 09:23'!isEntity: entityName attribute: attributeName	"Does this combination make sense? "	| result attributes |		"Does the first noun name an entity?"	result := self isEntity: entityName.	result ifFalse: [^false].		"Is the second noun an attribute of the first noun?"	attributes := self allAttributesOfEntity: entityName.	result := attributes includes: attributeName.	^result.		! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/21/2015 09:30'!setAutomaticSupertypeForNoun: aNoun 	"If a hyphenated nouns ends with the name of another noun,	 it is automately a subtype of the other noun."	| tokens suffix |	"See if there is a hyphen in the noun."	tokens := aNoun findTokens: '-'.	( tokens size > 1 ) ifFalse: [^self].		"See if the last token is currently a noun."	suffix := tokens last.	(self isEntity: suffix ) ifFalse: [^self].	  "The last token is currently a noun, so make this noun a subtype."	self nounSubtypes add: ( suffix -> aNoun ).! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 2/12/2014 10:07'!getPlanFrameForGoal: aGoalString 	| frame key |	key := 'Goal: ', aGoalString asString.	frame := (self framesByName ) 							at: key							ifAbsent: [ "Return an empty planFrame." 								^ HumFrame4Plan ontology: self goal: (aGoalString asString).								].	self assert: ( frame isKindOf: HumFrame4Plan ).	^frame.	! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 9/15/2012 10:56'!planFrames	| planFrames |	planFrames := Set new.	( self framesByIdentifier )		keysAndValuesDo:  [ :key :value | 			(value isKindOf: HumFrame4Plan)  ifTrue: [ planFrames add: value ].			].	^planFrames ! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 3/17/2015 11:24'!addPlanFrame: aPlanFrame ForGoal: aGoalString 	"Store frame as a plan frame - index as needed."	| |	self assert: ( aPlanFrame isKindOf: HumFrame4Plan ).	self storeFrame: aPlanFrame.	! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 1/23/2015 13:18'!buildPlanTreeForGoal: aGoal indent: anIndentLevel	"Build a list of associations: ( goalStatement -> { anIndentLevel. precondition statement.} )"	| goalStatement planTree subTree rootFrame |	goalStatement := HumStatement from: aGoal.	planTree := OrderedCollection new.	rootFrame := self getPlanFrameForGoal: aGoal.	"Stop building the plan subtree if the root frame is not defined."	( rootFrame isNoPlan ) ifTrue: [ ^planTree ].		( rootFrame preconditions )		do: [ :precondition |			planTree add: ( goalStatement -> { anIndentLevel. precondition statement.} ).			subTree := self buildPlanTreeForGoal: (precondition statement) indent: (anIndentLevel + 1).			planTree := planTree, subTree.			"Detect a cycle in the tree."			( planTree anySatisfy: [ :map |  (map value at: 2) = goalStatement ] ) 				ifTrue: [ Error signal: 'cycle detected in plan tree' ].			].			^planTree.! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 2/12/2014 10:55'!getFramesThatInvokePrecondition: aStatementString 	"Lookup the frames where precondition is invoked."	| resultSet  |	resultSet := self getFramesWithRelation: #precondition object: aStatementString.	^ resultSet.! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 7/22/2013 17:09'!collectPlanFramesForGoal: aGoalStatement 	"| goalStatement planTree subTree rootFrame |	goalStatement := HumStatement from: aGoal.	planTree := OrderedCollection new.	rootFrame := self getPlanFrameForGoal: aGoal.	( rootFrame preconditions )		do: [ :precondition |			planTree add: ( goalStatement -> (precondition statement) ).			subTree := self buildPlanTreeForGoal: (precondition statement).			planTree := planTree, subTree.			( planTree anySatisfy: [ :map |  map value = goalStatement ] ) 				ifTrue: [ Error signal: 'cycle detected in plan tree' ].			].			^planTree."	| problems rootFrame frameCollection subSet |	"First check to make sure the plan frames are complete."	problems := self checkPlanTreeForGoal:  aGoalStatement.	problems isEmpty		 ifFalse: [ Error signal: 'There are problems with the plan tree for goal: ', (aGoalStatement asString)			                                , String cr, ' Problems: ', problems asString. ].	"Collect the plan frames."	frameCollection := Set new.	rootFrame := self getPlanFrameForGoal: aGoalStatement.	frameCollection add: rootFrame.	( rootFrame preconditions )		do: [ :precondition |			subSet := self collectPlanFramesForGoal: (precondition statement).			frameCollection addAll: subSet.			].	^frameCollection.! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 1/23/2015 13:22'!checkPlanTreeForGoal: aGoal 	| goalStatement planTreeProblems subTreeProblems rootFrame planFrame |	"Check for problems that would prevent the plan from working."	goalStatement := HumStatement from: aGoal.	planTreeProblems := OrderedCollection new.		"Safety check -- >>buildPlanTreeForGoal: . . . will stop execution if there is a cycle in the plan-tree."	self buildPlanTreeForGoal: aGoal indent: 0.	rootFrame := self getPlanFrameForGoal: goalStatement.	(rootFrame isNoPlan) 		ifTrue: [ planTreeProblems add: 'Precondition: {', ( goalStatement asString ), '} has no plan frame.'. 						^ planTreeProblems ].		" Look for preconditions that have no corresponding plan frame in the ontology."	( rootFrame preconditions )		do: [ :precondition |			planFrame := self getPlanFrameForGoal: precondition statement.			planFrame ifNil: [ planTreeProblems add: 'Precondition: {', ( precondition statement asString ), '} has no plan frame.' ].			subTreeProblems := self checkPlanTreeForGoal:   ( precondition statement ).			planTreeProblems := planTreeProblems, subTreeProblems.			].							^planTreeProblems.! !!HumOntology methodsFor: 'debugging' stamp: 'RichardAlexanderGreen 12/16/2014 09:29'!debug	"Am I in debug mode?"	^ debug ifNil: [debug := false].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumOntology class	instanceVariableNames: ''!!HumOntology class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 6/13/2016 07:48'!baseOntologyOld	"Return a base ontology -- See also: BaseOntology.txt."	| base dummyAction |	base := HumOntology new.	"TODO: Load base-ontology from a text file."	"TODO: Add base nouns and frames to the base ontology."	"The base vocabulary includes: 	  order, order item, bill-of-material, material, part, assembly, 	  container, person, worker, employee, organization, roles, 	  measure, metric, money, cost, price, account, 	  resource, resource-pool, inventory, 	  and more".	base		addEntity: 'order' attributes: #( 'order-items' );		addEntity: 'party' attributes: #( 'email' 'name' 'roles' );		addEntity: 'person' attributes: #( 'first-name' 'last-name' );		addNoun: 'organization' isA: 'party';		addNoun: 'organisation' isA: 'organization';		"synonym"	  addEntity: 'organization' attributes: #( 'members');		addNoun: 'member' isA: 'party'; "Creates a loop in the noun graph!!!!!!!!"		addNoun: 'person' isA: 'party';		addNoun: 'worker' isA: 'person';		addNoun: 'employee' isA: 'worker';		addEntity: 'measure' attributes: #('quantity' 'unit-of-measure' 'precision' 'methodology' ).		 	"TODO: Add action frames for HumDialogAgent ?	- Ask viewName.	- Show viewName.	- New entityType."	base addNoun: 'view' isA: 'name'. 	dummyAction := HumFrame4Action ontology: base role: 'DialogAgent' action: 'Ask view.'.	dummyAction appendInstructionStatement: 'Dummy statement.'.	"TODO: Finalize syntax for translations."	dummyAction compileToOntology: base.		 ^base.! !!HumOntology class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 6/22/2016 09:22'!baseOntology	"Return a base ontology -- See also: BaseOntology.txt."	| base  pa |	pa := HumProgrammersAssistant new.	base := pa loadOntologyFromSaveFileNamed: 'BaseOntology.txt'.	^base.! !!HumOntology class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/19/2016 10:08'!nounAsCamelCase: aString 	| tokens result |	tokens := aString substrings: '-'.	result := ''.	tokens do: [ :token |		(result = '') 			ifTrue: [ result := token] 			ifFalse: [ result := result, (token capitalized )].		].	^result.! !!HumOntology class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/8/2016 10:52'!tokensInString: aString	"Return the tokens in the statement as an array of strings."	| punctuation whiteSpace tokens quote apostrophe |	"Punctuation does not include hyphen because nouns may be hypenated."	quote := $' asString.	apostrophe := $` asString.	punctuation := '~!!@#$%^&*()_+={}|[[]\:";<>?,./', quote. ", apostrophe."	"Apostrophe (`) is treated as part of a word? (possessive contraction)"	"WARNING: Hum has a quirk: Accent (`) is used as apostrophe. Avoid complication distinguishing uses of single-quote."	"White space includes space, cr, tab."		whiteSpace := ' 			'.	"Tokens are all lower-case and include punctuation."	tokens := ( aString asLowercase ) findTokens: ( punctuation, whiteSpace ) keep: punctuation.	^tokens.! !Object subclass: #HumOntologyTranslator	instanceVariableNames: 'methodsForClasses prologues ontology contextEntity html'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumOntologyTranslator commentStamp: 'RichardAlexanderGreen 5/13/2014 09:04' prior: 0!This class provides tools used to generate code from Hum frames.Strategies vary a little depending on the target language and framework.This is crude version - oriented toward Smalltalk and other object-oriented frameworks.	- Roles become classes.	- Entity-Attribute relations become class accessors. { but in what class ??? }	- Noun datatypes are one of: ( Entity Category Enumeration String Measure TimeStamp ).	- Dialogs become method calls with blocks.	- Views are translated to some Web Server framework { Seaside when target is Smalltalk }.	I am thinking that something like Erlang or Scala might be the best target frameworkbecause those frameworks support "actors", distribution, and parallel processingin relatively natural ways.In any case, the original Hum code will be included as comments in the generated code.This can assure that translations to less readable languages (Javascript, Erlang)will still be maintainable in those languages (not recommended)should the user-programmer decide to go that way.!!HumOntologyTranslator methodsFor: 'translate to HTML' stamp: 'RichardAlexanderGreen 2/20/2015 09:41'!genHTML: generatedCodeString	"Append generated code to 'html' instance variable. (YIKES!!)"	| |		"If code begins with a tag, insert cr to improve readability."	( generatedCodeString beginsWith: '<' )	  ifTrue: [(self html) nextPutAll: (String cr, generatedCodeString).]	  ifFalse: ["Otherwise, it is caller`s responsibility to prepend cr <br/>"		         (self html) nextPutAll: generatedCodeString.		         ].
  "TODO: REFACTOR this HTML generator to eliminate this side-effect stuff."	! !!HumOntologyTranslator methodsFor: 'translate to HTML' stamp: 'RichardAlexanderGreen 6/11/2015 09:45'!generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard	"Build output until we see a substring matching aStopString."	"When we need to recurse, 	  we pass the remainder of line.	WARNING: Results are appended to 'html' instance-variable.	"	|  remainder |	remainder := aMarkupString. 		"Emphasis patterns.  (bold, italic, underline, superscript)"	remainder := self when: remainder matchesPattern: '*1*' produce: [:x | self genHTML: '<b>',x,'</b>'].	remainder := self when: remainder matchesPattern: '~1~' produce: [:x | self genHTML: '<i>',x,'</i>'].	remainder := self when: remainder matchesPattern: '_1_' produce: [:x | self genHTML: '<u>',x,'</u>'].	remainder := self when: remainder matchesPattern: '^1^' produce: [:x | self genHTML: '<sup>',x,'</sup>'].	"Hypertext"	remainder := self when: remainder matchesPattern: '[link:1|2]' 	               produce: [:x :url |  self genHTML: '<a href="',url trimBoth,'">',x trimBoth,'</a>'].	remainder := self when: remainder matchesPattern: '[image:1|2]' 	               produce: [:x :url |  self genHTML: '<img src="',url trimBoth,'" alt="',x trimBoth,'"/>'].		remainder := self when: remainder matchesPattern: '[page:1]' 								produce: [:x | 									| filename |									filename := (x asCamelCase),'.html'.   "Should work in most file systems"									self genHTML: '<a href="',filename,'">',x,'</a>'].		"Delegate to another pane."	remainder := self when: remainder matchesPattern: '[pane:1]' 								produce: [:x | 									(ontology isViewName: x) 										ifFalse: [ self humParserError: ('Expected view name but found: ', x)  inCodeFragment: remainder]										ifTrue: [ | frame frameLines |											frame := ontology fetchFrameByName: x.											frameLines := frame frameLines.											self generateHTMLforMarkupLines: frameLines blackboard: aBlackBoard.											]. 										].	"Button"	"Treat button as a special case?"	remainder := self when: remainder matchesPattern: '[[1]]' 	               produce: [ :x | 		                       | buttonLabel buttonType |		                       buttonLabel := x trimBoth.		                       buttonType := buttonLabel asLowercase.                           ( #('submit' 'reset' ) includes: (buttonType) ) ifFalse: [buttonType := 'button'].				                       self genHTML: '<button name="',buttonLabel,'" type="',buttonType,'">',buttonLabel,'</button>'.		                      ].		"Radio Button or Comment"	remainder := self when: remainder matchesPattern: '(1)'		               produce: [:x | 									"Is a radio button intended?"									(x size = 1 ) 									   ifTrue: [ self genHTML: '<input name="',x,'" type="radio"/>']									  ifFalse: [ "Parse the interior of the comment -- It might contain links, etc."										  self genHTML: (self generateHTMLforMarkupString: x blackboard: aBlackBoard).											  ]									].	"Input widgets"	"TODO: When view is invoked with 'Show:' rather than 'Ask:', the input fields should be disabled."	remainder := self when: remainder matchesPattern: '[1`s 2]'  "[entity`s attribute]"								produce: [:entity :attribute | 									( ontology isAttribute: attribute )										ifFalse: [ self humParserError: ('Expected attribute name but found: ', attribute) inCodeFragment: remainder]										ifTrue: [| value |											value := aBlackBoard getEntityName: entity attribute: attribute.											self genHTML: '<input type="text" name="', entity,':',attribute, 											              '" value="',(value ifNil: ''),'"/>'.											"TODO: Adapt input to datatype." 											].									].		remainder := self when: remainder matchesPattern: '[1 2]'   "text widget"								produce: [:textAttribute :rows | 									( ontology isAttribute: textAttribute )										ifFalse: [ self humParserError: 'Expected attribute name but found: ', textAttribute ]										ifTrue: [| value |											value := aBlackBoard getEntityName: contextEntity attribute: textAttribute.											self genHTML: '<textarea type="text" name="', textAttribute,'" rows="',rows,'">'											           ,(value ifNil: ['']),'</textarea>'. 											].									].									remainder := self when: remainder matchesPattern: '[1]'    "attribute widget" 								produce: [:attribute | 									"Catch checkbox case"									( attribute size = 1 )										ifTrue:["Generate checkbox widget."											self genHTML: '<input type="checkbox" name="', attribute,'"/>'.											]                     ifFalse: ["Generate attribute input widget."	                     ( ontology isAttribute: attribute )										    ifFalse: [ self humParserError: ('Expected attribute name but found: ', attribute) inCodeFragment: remainder ]										    ifTrue: [| value |									     		value := (aBlackBoard getEntityName: contextEntity attribute: attribute) ifNil: [''].											    self genHTML: '<input type="text" name="', contextEntity,':',attribute, '" value="',value,'"/>'.											    "TODO: Adapt input to datatype.											     . Category should be drop-down or small radio group.												. Measure should be number plus drop-down.												. Date should be . . .												. Money should be . . .												. Duration should be . . .											    " 											    ].                       ].									].			"table row -- Should be implemented elsewhere."	self assert: ( remainder beginsWith: '|' ) not.  "Just ordinary text."  ( (remainder findTokens: '*~_^[]|()' keep: '*~_^[]|()') size <= 1 )		ifTrue: [ "Consume remainder"			self genHTML: remainder.			^remainder := ''.						].  "Recurse"	self assert: (remainder beginsWith: ']' ) not.	^self generateHTMLforMarkupString: remainder blackboard: aBlackBoard.	! !!HumOntologyTranslator methodsFor: 'translate to HTML' stamp: 'RichardAlexanderGreen 11/11/2014 08:59'!html	^html ifNil: [html := ReadWriteStream on: ''.].! !!HumOntologyTranslator methodsFor: 'translate to HTML' stamp: 'RichardAlexanderGreen 2/20/2015 09:36'!generateHTMLforMarkupLines: aListOfFrameLines blackboard: aBlackboard	"Build HTML for the given list of frame-lines"	|  remainder calc source translator2 cr |	cr := String cr.	calc := HumCalculator new.	"My code produces side-effect in instance-variable 'html', (shame on me)	 so I need another instance as helper.	TODO: Refactor this generator to make it properly recursive without side-effects.	"	translator2 := HumOntologyTranslator new.		aListOfFrameLines		do: [:frameLine | 			source := frameLine source.			calc cases; "Start case block"			   when: [source = ''] 			   then:["blank line indicates paragraph break"					     self genHTML: '<br/>'					    ];				 when: [source beginsWith: '!!']				 then: [ "Generate heading"							| level n |							level := self countLeading: '!!' inString: source.							remainder := source copyFrom: level+1 to: source size.							n := level asString.							self genHTML: '<h',n,'>'							            , ([translator2 generateHTMLforMarkupString: remainder blackboard: aBlackboard.								              translator2 html contents.] value)							            , '</h',n,'>',cr.							];				 when: [source beginsWith: '-']				 then: [ "Generate list item. Let CSS do the indent."							| level n |							level := self countLeading: '-' inString: source.							remainder := source copyFrom: level+1 to: source size.							n := level asString.							self genHTML: '<item',n,'> &bull; '							            , ([translator2 generateHTMLforMarkupString: remainder blackboard: aBlackboard.								              translator2 html contents.] value)							            , '</item',n,'>'.							];				when: [ source beginsWith: '|']				then: [ | columns |					      columns := source findTokens: '|'.					      self genHTML: '<tr>'.							  columns do: [:column |								  translator2 := HumOntologyTranslator ontology: (self ontology).								  translator2 generateHTMLforMarkupString: column blackboard: aBlackboard.								  self genHTML: '<td>',(translator2 html contents),'</td>'.								  ].					      self genHTML: '</tr>'.					    ];						otherwise: [					remainder := self generateHTMLforMarkupString: source blackboard: aBlackboard. 					"There should be no remainder"					self assert: (remainder = '').					].			].    ^self html contents.! !!HumOntologyTranslator methodsFor: 'translate to HTML' stamp: 'RichardAlexanderGreen 2/20/2015 10:31'!generateHTMLforViewFrame: aHumFrame4View blackboard: aHumBlackBoard 	"Wrap viewframe lines with  HTML form and submit logic."	| calc formHTML innerHTML formAttributes |	"Translate the Hum markup"	self contextEntity: aHumFrame4View entity.	innerHTML := self generateHTMLforMarkupLines: (aHumFrame4View frameLines) blackboard: aHumBlackBoard.	"Add a submit button"	innerHTML := innerHTML, String cr, ' <input type="submit" value="Go!!"   style="color:WHITE; background:GREEN"/>'.	"The user might not be ready to fill-in-the-blanks. Give user a way to decline."	innerHTML := innerHTML, String cr, ' <input type="submit" value="NoGo!!" style="color:WHITE; background:RED"/>'.	"TODO: The Scribe must interpret 'Go!!' versus 'NoGo!!' -- to invoke appropriate dialog vignette."	"Wrap in a form."	formAttributes := Dictionary new.	formAttributes		at: 'id'     put: aHumFrame4View title;		at: 'action' put: aHumFrame4View title;		at: 'method' put: 'POST';		at: 'enctype' put: 'application/x-www-form-urlencoded'; "Is this really needed? Is is correct for my intent?"		at: 'class' put: 'Ask'.	calc := HumCalculator new.	formHTML := calc xml: 'form' dictionary: formAttributes with: innerHTML.	^formHTML.! !!HumOntologyTranslator methodsFor: 'translate to HTML' stamp: 'RichardAlexanderGreen 6/13/2014 08:44'!when: aSource matchesPattern: aPattern produce: aBlock	| patternStream sourceStream arguments remainder sourceCharacter patternCharacter s uptoMark markupCharacters |  	(aSource = '') ifTrue: [ ^aSource ].	"Convertstrings to streams."	patternStream := ReadStream on: aPattern.	sourceStream := ReadStream on: aSource.		"Does source begin with markup?"	markupCharacters := '~^*_[]()|'.	uptoMark := String new.	[ sourceStream atEnd or: [ markupCharacters includes: (sourceStream peek)] ]		whileFalse:["Output ordinary text until a markup character is seen"			uptoMark := uptoMark, (sourceStream next asString). 			].	( uptoMark size > 0 ) 	   ifTrue: [ self genHTML: uptoMark.		   remainder := HumCalculator given: aSource extractAfter: uptoMark.  		   ^remainder.		   ].  "The source must begin with a markup character."	self assert: ( markupCharacters includes: (sourceStream peek) ).		"If the pattern does not match, 	  return the source 	  so that the caller can try another pattern."	(( patternStream peek ) = ( sourceStream peek )) ifFalse: [^aSource].  "If there is a match, build the argument list."	arguments := OrderedCollection new.	[ patternStream atEnd or: [ sourceStream atEnd ]]		whileFalse: [ 				patternCharacter := patternStream next.				sourceCharacter := sourceStream next.				( patternCharacter isDigit )				  ifFalse: ["Compare pattern character to source character."					  "Does the pattern match the source? 					   If not, return the source so that caller can try another pattern."					  ( patternCharacter = sourceCharacter ) ifFalse: [ ^aSource ].					  ]					ifTrue: ["Accumulate upto next delimiter or end"						| nextPatternCharacter |						nextPatternCharacter := patternStream next.						s := String new.						[ sourceStream atEnd or: [ sourceCharacter == nextPatternCharacter ]] 								whileFalse: [								(markupCharacters includes: sourceCharacter) ifTrue: [^aSource].								s := s, sourceCharacter asString.								sourceCharacter := sourceStream next.								].						arguments add: s.						].			].	"If we matched, run the production block"	( patternStream atEnd and: [arguments notEmpty] ) 		ifTrue: [ aBlock valueWithArguments: arguments ]		ifFalse: [^aSource].	"Return the remainder of the source."	remainder := String new.	[ sourceStream atEnd ] 		whileFalse: [ remainder := remainder, (sourceStream next asString). ].  ^remainder.! !!HumOntologyTranslator methodsFor: 'translate to HTML' stamp: 'RichardAlexanderGreen 2/20/2015 09:26'!countLeading: aCharacter inString: line	"Count leading"	| n ch |	( aCharacter isKindOf: Character ) ifTrue: [ ch := aCharacter ].	( aCharacter isKindOf: String ) ifTrue: [ ch := aCharacter at: 1 ].	self assert: ( ch isKindOf: Character ).	self assert: ( (line at: 1) = ch ).	n := 1.	[ (line at: n) = ch ] whileTrue: [n := n+1].  ^n-1.! !!HumOntologyTranslator methodsFor: 'translate to JavaScript Angular' stamp: 'RichardAlexanderGreen 4/24/2015 09:07'!generateJavaScriptAngularReadMe	"Angular is a JavaScript user interface framework."	"Angular-Bootstrap simplifies the programming of layouts and rich interface effects."	self shouldNotImplement.! !!HumOntologyTranslator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/20/2014 09:41'!contextEntity: aString 	contextEntity := aString! !!HumOntologyTranslator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/15/2013 17:15'!prologues	^ prologues ifNil: [ prologues := Dictionary new ].! !!HumOntologyTranslator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/19/2014 16:45'!ontology	^ ontology ifNil: [ontology := HumOntology new.]! !!HumOntologyTranslator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/12/2014 12:38'!ontology: aHumOntology 	ontology := aHumOntology.! !!HumOntologyTranslator methodsFor: 'Generate OO Modules' stamp: 'RichardAlexanderGreen 3/15/2013 17:14'!attachPrologToActorClass: aClassName fromSource: aSourceString 	"Attach the given prologue source code to the named class."	| |	"Note: There can be only one prologue for each actor class"	( self prologues ) at: aClassName put: aSourceString.! !!HumOntologyTranslator methodsFor: 'Generate OO Modules' stamp: 'RichardAlexanderGreen 2/27/2013 15:02'!methodsForClasses	^ methodsForClasses ifNil: [ methodsForClasses := Dictionary new ].! !!HumOntologyTranslator methodsFor: 'Generate OO Modules' stamp: 'RichardAlexanderGreen 3/15/2013 17:04'!attachAction: aMethodName toActorClass: aClassName fromSource: aSource	"Attach the given method source 		to the given class 			under the given method name."	| methods |	methods := self getMethodsForClass: aClassName.	self assert: (methods isKindOf: Dictionary ).	methods at: aMethodName put: aSource.	  ! !!HumOntologyTranslator methodsFor: 'Generate OO Modules' stamp: 'RichardAlexanderGreen 2/27/2013 15:01'!getMethodsForClass: aClassName	"Get the methods colletion (a Dictionary) for the given Class"	| methods |	methods := ( self methodsForClasses ) at: aClassName ifAbsent: [ nil ].	methods 		ifNil: [ methods := Dictionary new. 						( self methodsForClasses ) at: aClassName put: methods.						].	^methods.! !!HumOntologyTranslator methodsFor: 'utility' stamp: 'RichardAlexanderGreen 6/25/2015 11:20'!nounAsCamelCase: aNoun 	"Generate camel-case string the the given noun."	| camelCase tokens |	camelCase := String new.	tokens := (aNoun trimBoth) findTokens: '-'. 	tokens do: [  :token | camelCase := camelCase, (token asLowercase capitalized) ].	"Note: First letter is also capitalized. 	Caller must decide if this is appropriate to translation."	^camelCase.! !!HumOntologyTranslator methodsFor: 'translate to Xamarin C-Sharp' stamp: 'RichardAlexanderGreen 4/24/2015 09:08'!generateXamarinReadMe	"Xamarin runs on Windows, iOS, and Android devices.  (client side)	However, some components are platform-specific."	"See XamarinHQ on YouTube for tutorials."	self shouldNotImplement.	! !!HumOntologyTranslator methodsFor: 'debugging' stamp: 'RichardAlexanderGreen 6/11/2015 09:43'!humParserError: aComplaint inCodeFragment: aCodeFragment	|  complaintHTML errorMessage |	"TODO: In the future, we might not want this to stop execution."	errorMessage := aComplaint, ' in {',aCodeFragment,'}'.	Error signal: errorMessage.	"Generate HTML to embed critique near problem"	complaintHTML := HumCalculator xml: 'errorNote' with: [ errorMessage ].	^complaintHTML.! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 3/3/2014 18:33'!generateJavaForStatement: aHumStatement 	| code  |	"TODO -- This will fail if there is a comment appended to the statement."	( aHumStatement isConditional ) 		ifTrue: [ code := self generateJavaConditionalForStatement: aHumStatement ]		ifFalse: [code := self generateJavaCallForStatement: aHumStatement . ].			^code! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 4/20/2015 08:18'!generateJavaCallForStatement: aHumStatement 	| nouns code comma space parend |	code := ''.	space := ' '.	comma := ','.	parend := ' )'.	code := code, (aHumStatement asCamelCaseWithOntology: ontology),'('.	nouns := ontology nounsInStatement: aHumStatement.	nouns		do: [ :aNoun | 				| javaNoun |				javaNoun := aHumStatement nounAsCamelCase: aNoun.				code := code, space, 'a', javaNoun capitalized, comma.				].	code := code, parend.	( code endsWith: (comma, parend ) ) 		ifTrue: [ code := (code copyFrom: 1 to: (code findString: (comma, parend))-1), parend ].	self assert: ( code endsWith: parend ).	self assert: (( code endsWith: (comma, parend) ) not).				self assert: ( '*, )*' match: code ) not.	^code.! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 3/3/2014 18:30'!generateJavaForFrame: aHumFrame4Action 	"Translate frame to Java using the nouns given in the ontology."	| selectorCode frameCode cr indentation priorIndent space tab javaDoc |	cr := String cr.	space := $   asString.	tab := String tab.	indentation := tab.	javaDoc := '/** ', aHumFrame4Action actionStatement asString,' */'.	selectorCode := self generateJavaMethodDeclarationForStatement: aHumFrame4Action actionStatement.	frameCode := ''.	priorIndent := 0.	( aHumFrame4Action frameLines ) 		do: [ :frameLine |			(frameLine indent < priorIndent ) 				ifTrue: [ "Insert a block-end bracket with appropriate indent."					indentation := (1 to: priorIndent) inject: '' into: [:s :next | s, tab ]. 					frameCode := frameCode, cr, indentation, '}'.				].			frameCode := frameCode, cr, (self generateJavaForFrameLine: frameLine).			"TODO: Translate if/else/for"			priorIndent := frameLine indent.			].	^ javaDoc, cr, selectorCode, space, '{', frameCode, cr, '}' .! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 6/25/2015 10:04'!nounsAsJava	"Emit java code that implements noun relations."	"Currently this emits all classes into a single code stream. 	In the future, we might want to find a way to map the stream into separate '.java' files.	"	| code entities cr tab semicolon space fnToGetSupertype |	code := ''.	cr := String cr.	tab := String tab.	semicolon := ';'.	space := String space.	"Get a list of the entities."	entities := Set new.	( ontology entityAttributes ) do: [ :eachMap |  entities add: (eachMap key) ].	"Define a private function that determines the correct supertype for a given noun."	fnToGetSupertype := [ :noun :default | 			|  typeName supertypes |			supertypes := ontology immediateSupertypesOf: noun.			( supertypes size = 0 ) ifTrue: [ typeName := default ].			( supertypes size > 0 ) ifTrue: [ typeName :=  ( HumOntology nounAsCamelCase:  ( supertypes asSortedCollection at: 1 ) ) capitalized ].			( supertypes size > 1 ) ifTrue: [Error signal: '// WARNING: Cannot correctly translate ', noun, ' to Java because it has more than one supertype.', cr. ].			"TODO: Fix this up so that multiple inheritance is correctly handled."			"Function returns the discovered supertype or the default supertype"			typeName.		].	"Emit a class for each entity."	( entities asSortedCollection ) do: [ :entity | 		| attributes extendsSupertype  |		"Everything extends Entity class -- which provides toHTML(), toXML(), and persistence methods (TBD)."		extendsSupertype := fnToGetSupertype value:  entity value: 'Entity'.		"TODO: If the entity has a single superclass, override the extendsSuperType value with that superclass name."		code := code, cr, 'public class ', (HumOntology nounAsCamelCase:  entity) capitalized , ' extends ', extendsSupertype, ' {', cr.		"Get the entity's attributes."		attributes := ontology immediateAttributesOfEntity: entity.		"Emit instance variable declarations for each attribute. -- Default type is String."		( attributes asSortedCollection ) do: [ :attribute |			|  typeName |			typeName := fnToGetSupertype value: attribute value: 'String'.			( entities include:  attribute ) ifTrue: [ typeName :=  ( HumOntology nounAsCamelCase:  attribute ) capitalized ].			"If noun is plural, make the type Bag<Entity>"			( ontology isPluralNoun: attribute ) 				ifTrue: [ 					| singular |					singular := ontology singularFormOfNoun: attribute.					typeName := 'Bag<',(HumOntology nounAsCamelCase: singular),'>'  ].			code := code, tab, 'public ', typeName, space, ( HumOntology nounAsCamelCase: attribute), semicolon, cr.			].		"Class ends with closing brace and a comment."		code := code, '} // Entity: ', (HumOntology nounAsCamelCase:  entity) capitalized, cr.		].	"Comment: This demonstrates that entities can be translated to java classes.	                   It also demonstrates that Hum is ~type-safe~."	^code.! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 4/28/2015 10:28'!rolesAsJava	| code cr |	code := ''.	cr := String cr.	( ontology roles asSortedCollection   )		do: [ :role | 			| actions |			code := code, cr, '/** Actor: ', role capitalized, 			             cr, ' * Generated from Hum ontology: ', (ontology fromFile) asString, 			             cr, ' */'.			code := code, cr, 'public class ', role capitalized, ' extends Actor { ', cr, cr.			actions := ontology actionsOf: role.						( actions asSortedCollection )				do: [ :actionStatement |					| frame frameCode frameName |					frameName := 'Role: ', role capitalized, ' -- ', actionStatement source.					frame := ontology fetchFrameByName: frameName.					frameCode := self generateJavaForFrame: frame.					code := code, frameCode.					].			code := code, cr, cr, '} // Actor: ', role capitalized, cr.			].	^code.! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 6/5/2014 09:08'!generateJavaIterationForStatement: aHumStatement 	"Given a Hum for-statement, generate a Java for-statement."	| code |	"TODO: Refactor this to use a template. (Should be cleaner code.)"	aHumStatement onMatch:  'For each 1 in the 2:' do: [ :item :container |	code := 'for ( ', (aHumStatement nounAsCamelCase: item) capitalized				, ' ', (aHumStatement nounAsCamelCase: item) 		           , ' : ', (aHumStatement nounAsCamelCase: container ),'.',(aHumStatement nounAsCamelCase: item),'s' 		           , ' )  {' ].	^code.! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 3/3/2014 18:28'!generateJavaForFrameLine: aHumInstructionLine 	| instructionCode statementCode roleCode commentCode cr documentation tab indentation  |	roleCode := 'this'.	commentCode := ''.	cr := String cr.	"space := Character space asString."	tab := Character tab asString.	indentation := (1 to: (aHumInstructionLine indent)) inject: '' into: [:s :next | s, tab ]. 	documentation := '/** ', (aHumInstructionLine source ), ' */', cr.	statementCode := self generateJavaForStatement: (aHumInstructionLine statement ).	"Generate optional code if role or comment is present."	aHumInstructionLine onRole: [ roleCode := ' a', (aHumInstructionLine role capitalized) ].	aHumInstructionLine onComment: [ commentCode := ('/* ', (aHumInstructionLine comment ), ' */'). ].	"Generate Java code -- depending on type of statement."	(aHumInstructionLine statement isConditional ) "Does the statement begin with For/If/Else ???"		ifTrue: [ instructionCode := indentation, documentation, indentation, statementCode, commentCode. ]		ifFalse: [instructionCode := indentation, documentation, indentation, roleCode,'.', statementCode, '; ', commentCode. ].	^instructionCode.! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 3/3/2014 18:30'!generateJavaCallForFrameLine: aHumInstructionLine 	| instructionCode statementCode roleCode commentCode cr documentation tab indentation  |	self assert: (aHumInstructionLine isKindOf: HumInstructionLine).
self halt.	roleCode := 'this'.	commentCode := ''.	cr := String cr.	"space := Character space asString."	tab := Character tab asString.	indentation := (1 to: (aHumInstructionLine indent)) inject: '' into: [:s :next | s, tab ]. 	documentation := '/** ', (aHumInstructionLine source ), ' */', cr.	statementCode := self generateJavaCallForStatement: (aHumInstructionLine statement ).	"Generate optional code if role or comment is present."	aHumInstructionLine onRole: [ roleCode := ' a', (aHumInstructionLine role capitalized) ].	aHumInstructionLine onComment: [ commentCode := ('/* ', (aHumInstructionLine comment ), ' */'). ].	"Generate Java code -- depending on type of statement."	(aHumInstructionLine statement isConditional ) "Does the statement begin with For/If/Else ???"		ifTrue: [ instructionCode := indentation, documentation, indentation, statementCode, commentCode. ]		ifFalse: [instructionCode := indentation, documentation, indentation, roleCode,'.', statementCode, '; ', commentCode. ].	^instructionCode.! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 3/3/2014 18:36'!generateJavaConditionalForStatement: aHumStatement 	| code source |	code := ''.	source := aHumStatement source.	(source beginsWith: 'For ' )		ifTrue: [ code := self generateJavaIterationForStatement: aHumStatement ].	( source beginsWith: 'If ')		ifTrue: [ code := self generateJavaIfForStatement: aHumStatement ].	( source beginsWith: 'Else:')		ifTrue: [ code := self generateJavaElseForStatement: aHumStatement ].			self assert: ( code = '' ) not.	^code.! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 4/20/2015 08:11'!generateJavaMethodDeclarationForStatement: aHumStatement 	| nouns code comma space parend |	code := ''.	space := ' '.	comma := ', '.	parend := ' )'.	code := code,'public void ', (aHumStatement asCamelCaseWithOntology: ontology),'( '.	nouns := ontology nounsInStatement: aHumStatement.	nouns		do: [ :aNoun | 			| javaNoun |			javaNoun := aHumStatement nounAsCamelCase: aNoun.			code := code, javaNoun capitalized , space, 'a', javaNoun capitalized, comma.			].	code := code, parend.	( code endsWith: (comma, parend ) ) 		ifTrue: [ code := (code copyFrom: 1 to: (code findString: (comma, parend))-1), parend ].	self assert: ( code endsWith: parend ).	self assert: (( code endsWith: (comma, parend) ) not).				self assert: ( '*, )*' match: code ) not.	^code.! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 4/19/2014 12:39'!asJava	"This is crude version.	Futures:	- Roles become classes.	- Entity-Attribute relations become classes with get/set methods.	- Noun types are one of: ( Entity Category Enumeration String Measure TimeStamp ).	- Dialogs are become method calls with blocks.	- Views are still interpreted.	"	| code nounCode actionCode |	code := ''.	nounCode := self nounsAsJava.	code := code, nounCode.	actionCode := self rolesAsJava.	code := code, actionCode.	^ code.! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 6/17/2015 08:53'!generateJavaForPlanFrame: aHumFrame4Plan 	"The plan is data, so translation involves translating each goal frame into a series of Java setters.	/* prologue */	public HumPlan plan = new HumPlan();	public HumPlanFrame frame = new HumPlanFrame();	/* for each goal frame in the ontology */	frame.setGoal('...')		.addPrecondition('...')		.addPrecondition('...')		.addAction('...');	plan.addGoalFrame(frame);		"	| javaCode goalStatement indent |	javaCode := String new.	indent := '  '.	goalStatement := aHumFrame4Plan goal source.	javaCode := indent, 'planFrame.setGoal("', goalStatement, '")'.	aHumFrame4Plan preconditions do: [  :precondition |		javaCode := javaCode, String cr, indent, indent, '.addPrecondition("', precondition source, '")'].	aHumFrame4Plan planActions do: [  :action |		javaCode := javaCode, String cr, indent, indent, '.addAction("', action source, '")' ].	^javaCode.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/8/2014 13:21'!generateSmalltalkForFrameLine: anInstructionLine 	| instructionCode statementCode roleCode commentCode quote cr documentation tab indentation  |	self assert: (anInstructionLine isKindOf: HumInstructionLine).	roleCode := ' self'.	commentCode := ''.	quote := $" asString.	cr := String cr.	"space := Character space asString."	tab := Character tab asString.	indentation := (1 to: (anInstructionLine indent)) inject: '' into: [:s :next | s, tab ]. 	documentation := quote, (anInstructionLine source ), quote, cr.	statementCode := self generateSmalltalkForStatement: (anInstructionLine statement ).	anInstructionLine onRole: [ roleCode := ' a', (anInstructionLine role capitalized) ].	anInstructionLine onComment: [ commentCode := (quote, (anInstructionLine comment ), quote). ].	(anInstructionLine statement isConditional ) 		ifTrue: [ instructionCode := indentation, documentation, indentation, statementCode, commentCode. ]		ifFalse: [instructionCode := indentation, documentation, indentation, roleCode, ' ', statementCode, '. ', commentCode. ].	^instructionCode.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 6/5/2014 09:05'!generateSmalltalkIterationFor: aHumStatement 	|     code statement |  statement := aHumStatement.	code := ''.	statement onMatch:  'For each 1 in the 2:' 	          do: [ :item :container |		code := '( self blackboard entity: ', (statement nounAsCamelCase: container) quoted		           , ' attribute: ', (statement nounAsCamelCase: item ) quoted		           , ' ) do: [ :', (statement nounAsCamelCase: item), ' | '			         , String cr			         , '     | a', (statement nounAsCamelCase: item) capitalized, ' |'			         , String cr							 , '     a', (statement nounAsCamelCase: item) capitalized, ' := ', (statement nounAsCamelCase: item), '.'		]. 	"TODO: Refactor this to use a template. (Should be cleaner code.)"	^code.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/3/2014 10:57'!generateSmalltalkForConditional: aHumStatement 	| code source|	code := ''.	source := aHumStatement source.	(source beginsWith: 'For ' )		ifTrue: [ code := self generateSmalltalkIterationFor: aHumStatement ].	( source beginsWith: 'If ')		ifTrue: [ code := self generateSmalltalkIfFor: aHumStatement ].	( source beginsWith: 'Else:')		ifTrue: [ code := self asSmalltalkElse ].			self assert: ( code = '' ) not.	^code.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/3/2014 11:16'!generateSmalltalkForStatement: aHumStatement 	| nouns code  colon space |	"TODO -- This will fail if there is a comment appended to the statement."	( aHumStatement isConditional ) 		ifTrue: [ code := self generateSmalltalkForConditional: aHumStatement. 			^code ].	code := ''.	colon := ':'.	space := ' '.	code := code, ( aHumStatement asCamelCase ), 'Q'.	nouns := ontology nounsInStatement: aHumStatement.	nouns		do: [ :aNoun | 			| camelCase |			camelCase := aHumStatement nounAsCamelCase: aNoun.			code := code, camelCase, colon, space, 'a', camelCase capitalized, space.			].			^code! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/3/2014 11:24'!generateSmalltalkActionFor: aHumFrame4Action 	"Translate frame to Smalltalk using the nouns given in the ontology."	| selectorCode frameCode priorIndent cr tab indentation |	cr := String cr.	tab := String tab.	selectorCode := self generateSmalltalkForStatement: aHumFrame4Action actionStatement.	"Translate the lines. Adding block ends when indent is reduced."	frameCode := ''.	priorIndent := 0.	aHumFrame4Action frameLines		do: [ :line |			| lineCode |			(line indent < priorIndent ) 				ifTrue: [ "Insert a block-end bracket with appropriate indent."					indentation := (1 to: priorIndent) inject: '' into: [:s :next | s, tab ]. 					frameCode := frameCode, indentation, '].', cr.				].			lineCode := self generateSmalltalkForFrameLine: line.			frameCode := frameCode, lineCode,  cr.			priorIndent := line indent.			].	^ selectorCode, String cr, frameCode .! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 2/20/2014 17:19'!generateSmalltalkOnFile: aFileName	"Open file and produce File-Out / File-In format."     "Following is template for file-out / file-in format.""@@Superclass subclass: #@@ClassName	instanceVariableNames: '@@InstanceVariables'	classVariableNames: ''	poolDictionaries: ''	category: '@@ClassCategory'!!!!@@ClassName commentStamp: '@@Stamp' prior: 0!!@@ClassComment!!!!@@ClassName methodsFor: '@@MethodCategory' stamp: '@@Stamp'!!@@MethodSelector	""@@MethodComment""	| @@LocalVariables |	@@MethodCode	!!!!"			| code |	self shouldBeImplemented.	code := ''.	"This is crude version.	Futures:	- Roles become classes.	- Entity-Attribute relations become class accessors.	- Noun types are one of: ( Entity Category Enumeration String Measure TimeStamp ).	- Dialogs become method calls with blocks.	- Views are translated to Seaside html onRender: methods.	"	self framesByName		keysAndValuesDo: [  :frameName :frame |			| frameCode |			frameCode := frame asSmalltalkWithOntology: self.			code := code, frameCode.			].! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/3/2014 11:20'!generateSmalltalkForFrame: aHumFrame	"Translate frame to Smalltalk using the nouns given in the ontology."	| frameCode |	(aHumFrame isKindOf: HumFrame4Action) ifTrue: [ ^self generateSmalltalkActionFor: aHumFrame ].	frameCode := ''.	aHumFrame frameLines		do: [ :line |			| lineCode |			lineCode := self generateSmalltalkForFrameLine: line.			frameCode := frameCode, lineCode, String cr.			].	^frameCode.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/3/2014 11:05'!generateSmalltalk	"This is crude version.	Futures:	- Roles become classes.	- Entity-Attribute relations become class accessors.	- Noun types are one of: ( Entity Category Enumeration String Measure TimeStamp ).	- Dialogs are become method calls with blocks.	- Views are still interpreted.	"	| code |	code := ''.	ontology framesByName		keysAndValuesDo: [  :frameName :frame |			| frameCode |			frameCode := self generateSmalltalkForFrame: frame.			code := code, frameCode.			].	^ code.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 1/23/2015 14:48'!generateSmalltalkIfFor: aHumStatement 	"Translate a Hum if-statement into a Smalltalk (  ) ifTrue: [] expression."	| code  statement smalltalkIf |	statement := aHumStatement.	code := ''.	"TODO: Refactor this to use a template. (Should be cleaner code.)"	"TODO: Refactor to make the operator an argument."	smalltalkIf := [:entity1 :attribute2 :entity3 :attribute4 :op |		'(  ( blackboard entity: ',(statement nounAsCamelCase: entity1 ) quoted					            , ' attribute: ',  (statement nounAsCamelCase: attribute2 ) quoted							, ' ) ',op,' ( blackboard entity: ', (statement nounAsCamelCase: entity3 ) quoted							, ' attribute: ', ( statement nounAsCamelCase: attribute4 ) quoted							, ' ) )  ifTrue: ['		].	statement onMatch: 'If 1 2 is greater than 3 4 :'				do: [ :entity1 :attribute2 :entity3 :attribute4 |					^code := smalltalkIf valueWithArguments: { entity1. attribute2. entity3. attribute4. '>'.}					].	statement onMatch: 'If 1 2 > 3 4 :'				do: [ :entity1 :attribute2 :entity3 :attribute4 |					^code := smalltalkIf valueWithArguments: { entity1. attribute2. entity3. attribute4. '>'.}					].	statement onMatch: 'If 1 2 is less than 3 4 :'				do: [ :entity1 :attribute2 :entity3 :attribute4 |					^code := smalltalkIf valueWithArguments: { entity1. attribute2. entity3. attribute4. '<'.}					].	statement onMatch: 'If 1 2 < 3 4 :'				do: [ :entity1 :attribute2 :entity3 :attribute4 |					^code := smalltalkIf valueWithArguments: { entity1. attribute2. entity3. attribute4. '<'.}					].	statement onMatch: 'If 1 2 = 3 4 :'				do: [ :entity1 :attribute2 :entity3 :attribute4 |					^code := smalltalkIf valueWithArguments: { entity1. attribute2. entity3. attribute4. '='.}					].	statement onMatch: 'If 1 2 is equal to 3 4 :'				do: [ :entity1 :attribute2 :entity3 :attribute4 |					^code := smalltalkIf valueWithArguments: { entity1. attribute2. entity3. attribute4. '='.}					].			self assert: ( code = '' ) not.	^code.! !!HumOntologyTranslator methodsFor: 'translate to Erlang' stamp: 'RichardAlexanderGreen 1/4/2016 11:08'!generateErlangForSelfCall: aString	"Translate a Hum Self call into an Erlang self call."	| erlang statementString nounValues quote |	self assert: (aString isKindOf: String).	self assert: ( '*:*' match: aString ) not.	statementString := aString trimBoth.	[ statementString beginsWith: '. '] 		whileTrue: [ statementString := statementString copyFrom: 3 to: (statementString size) ].	"TODO: HumStatement knows how to parse better than above. It knows about comments and annotations."	nounValues := self generateErlangNounValuesForStatement: statementString.	quote := $' asString.	erlang := 'do( { ', quote, statementString, quote, ', [ ', nounValues, ' ] } ),'.	^erlang	! !!HumOntologyTranslator methodsFor: 'translate to Erlang' stamp: 'RichardAlexanderGreen 1/4/2016 11:15'!generateErlangForActionCall: aString	"Translate a Hum Action call into an Erlang OTP call."	| erlang colon quote comma roleAtom statementString  statementAtom nounValues |	self assert: (aString isKindOf: String).	"Extract the statement string from the Instruction Line."	"TODO: HumStatement knows how to parse better than HumCalculator. It knows about comments and annotations."		colon := $: asString.	quote := $' asString.	comma := $, asString.	roleAtom := (HumCalculator given: aString extractUpto: colon) asLowercase.	statementString := (HumCalculator given: aString extractAfter: colon) trimBoth.	statementAtom := quote, statementString, quote.	nounValues := self generateErlangNounValuesForStatement: statementString.	erlang := '?CALL( ', roleAtom, comma, statementAtom, ', [ ', nounValues, ' ] )', comma, String cr.	^erlang	! !!HumOntologyTranslator methodsFor: 'translate to Erlang' stamp: 'RichardAlexanderGreen 1/4/2016 10:58'!generateErlangNounValuesForStatement: aStatementString	|  statementNouns nounValueTuples firstNoun quote |	"Get statement nouns."	statementNouns := self ontology nounsInStatement: aStatementString.	self assert: ( statementNouns size > 0 ). 	quote := $' asString.	nounValueTuples := ReadWriteStream on: ''.	firstNoun := true.	statementNouns do: [ :noun |		(firstNoun) ifFalse: [ nounValueTuples << ', ' ].  "After the first noun, we need a comma separator."		firstNoun := false.		nounValueTuples << '{' << quote << noun << quote.		nounValueTuples << ', ' << ( (self ontology nounAsCamelCase: noun ) capitalized ) << '}'.		].		^ nounValueTuples contents.! !!HumOntologyTranslator methodsFor: 'translate to Erlang' stamp: 'RichardAlexanderGreen 1/4/2016 10:38'!generateErlangForActionHeader: aString 	"Then: The do header looks like 'do( { action-statement, noun-values } )' "	| erlang quote statementString    nounValues |	quote := $' asString.	(aString beginsWith: 'Action:')		ifTrue: [ statementString := (HumCalculator given: aString extractAfter: 'Action:') trimBoth. ]		ifFalse: [ statementString := aString ].	"TODO: Fix case where statementString contains single quote/s."	nounValues := self generateErlangNounValuesForStatement: statementString.		erlang := 'do( { ', quote, statementString, quote, ', [ ', nounValues, ' ] } ) ->', String cr.	^ erlang.! !!HumOntologyTranslator methodsFor: 'translate to Erlang' stamp: 'RichardAlexanderGreen 12/26/2015 12:37'!generateErlangForEntity: anEntity	"Translate entity into an Erlang record data structure. <<< OBSOLETE	-record( entity, { attribute, attribute, attribute } ).		"	| erlangCode comma attributes separator supertypes |		Error signal: 'Decided after giving it more thought that this translation concept is a bad idea'.	"After all, action call will be ?CALL({',roleAtom,',"',statementString,'",NounValues}). where NounValues is a list of {noun, noun-value} tuples."		self assert: (anEntity isKindOf: String).	comma := ', '.	separator := ' '.	"Generate the preamble."	erlangCode := '-record( ', (self nounAsCamelCase: anEntity) uncapitalized, comma, '{'.	"Generate the tuple elements."	attributes := (ontology immediateAttributesOfEntity: anEntity) asArray.  "Note: Attributes that are also entities imply nested records."	self assert: ( (attributes at: 1) isKindOf: String).  "Assume a collection of String"	attributes 		do: [ :attribute | 			erlangCode := erlangCode, separator, (self nounAsCamelCase: attribute) uncapitalized.  			separator := comma. "Remaining attributes will be separated by a comma."			].			supertypes := (ontology immediateSupertypesOf: anEntity) asArray.  "Note: Attributes that are also entities imply nested records."	self assert: ( (attributes at: 1) isKindOf: String).  "Assume a collection of String"	supertypes 		do: [ :supertype | 			erlangCode := erlangCode, separator, (self nounAsCamelCase: supertype) uncapitalized.  			separator := comma. "Remaining attributes will be separated by a comma."			].	erlangCode := erlangCode, ' }  ).' .	^erlangCode.	! !!HumOntologyTranslator methodsFor: 'translate to Erlang' stamp: 'RichardAlexanderGreen 1/4/2016 10:45'!generateErlangForInstruction: aHumInstructionLine 	"Generate self-call or RPC for given instruction."	| role statement comment erlangCode cr indent quote statementAtom |	role := aHumInstructionLine role.	statement := aHumInstructionLine statement.	comment := aHumInstructionLine comment.	erlangCode := ReadWriteStream on: ''.	cr := String cr.	indent := '  '.	quote := $' asString.	statementAtom := quote, statement source, quote.	"Insert comment, if any, before the Erlang translation of the statement."	(comment > ' ') 		ifTrue: [ erlangCode <<  indent << '% ' << comment << cr ]. 	"If a role-label is present, the action is delegated to another role; otherwise calling self."	(role > ' ')		ifTrue: [ | rpc |  			rpc := self generateErlangForActionCall: aHumInstructionLine source. 			erlangCode << indent << rpc.			]		ifFalse: [ erlangCode << indent << (self generateErlangForSelfCall: statement source) << cr].	^erlangCode contents.! !!HumOntologyTranslator methodsFor: 'translate to Erlang' stamp: 'RichardAlexanderGreen 12/26/2015 13:00'!generateErlangDocumentation	| translationStrategy runTimeStrategy |	translationStrategy := 'Erlang Translation Strategy	Each Hum role is translated into Erlang module.	Hum Instructions become Erlang patterns - that match on the HumStatement source.	The Hum statement source becomes an Erlang atom for matching purposes.	Delegation become an Erlang message.	'.	runTimeStrategy := 'Erlang Run-Time Strategy	The Hum run-time will be implemented in Erlang.	The Hum-Erlang run-time actors include: Coordinator, Dispatcher, Messenger, BlackBoard, WorldBase, Bookkeeper.	It also seems likely that the Hum-Erlang run-time will also include DialogAgent, and Scribe actors.	However, it may make more sense to implement those actors in JavaScript. (TBD).	'.	"2015-12-26: I wrote some experimental versions of an Erlang Messenger some time ago.	I think (but may mis-remember) that I also wrote an experimental Erlang WorldBase. 	"	^translationStrategy, runTimeStrategy.! !!HumOntologyTranslator methodsFor: 'translate to Erlang' stamp: 'RichardAlexanderGreen 12/31/2015 14:33'!generateErlangForRole: aRoleName	"Generate Erlang code for the given role-name."	| moduleDeclarationCode moduleLogicCode cr actionStatements quote |	"Generate the module`s declarations."	cr := String cr.	quote := $' asString.	moduleDeclarationCode := ReadWriteStream on: ''.	moduleDeclarationCode << '-module(' << aRoleName << ').' << cr.	moduleDeclarationCode << '-export([do/1]).' << cr.	moduleDeclarationCode << '-define( CALL( Role, Statement, NounValues ), ?TBD( Role, Statement, NounValues ).' << cr.	"TODO: Define TBD string (see above) - Call is routed to appropriate Hum Dispatcher via Hum Messenger."	"Following causes compiler to show macro expansion. "	moduleDeclarationCode << '-compile:file( File, [' <<quote << 'P' << quote << ']).' << cr.		"Generate the logic for each action frame."	moduleLogicCode := ReadWriteStream on: ''.	actionStatements := self ontology actionsOf: aRoleName.	self assert: (actionStatements size > 0).	actionStatements 		do: [ :actionStatement | 			| actionHeader frame frameLines |			actionHeader := self generateErlangForActionHeader: actionStatement source.			moduleLogicCode << actionHeader.			frame := self ontology getFrameForRole: aRoleName capitalized  action: actionStatement.			frameLines := frame frameLines.			self assert: (frameLines size > 0).			frameLines do: [ :frameLine |  					| erlangInstruction |					erlangInstruction := self generateErlangForInstruction: frameLine. "Already contains needed cr."					moduleLogicCode << erlangInstruction.					].			moduleLogicCode << '  okay.' << cr << cr.	"Final line of function -- returns okay."			].		^moduleDeclarationCode contents, moduleLogicCode contents.		! !!HumOntologyTranslator methodsFor: 'translate to Erlang' stamp: 'RichardAlexanderGreen 12/26/2015 12:38'!generateErlangForPlanFrame: aHumFrame4Plan 	"Translate the plan frame into an Erlang data structure.	planFrame = { goal, [ precondition, precondition ] , [ action, action ] }	"	| erlangCode goalStatement quote indent comma |	quote := $' asString.	comma := ', '.	indent := '  '.	erlangCode := 'planFrame = { '.  "Start tuple."	goalStatement := aHumFrame4Plan goal source.	erlangCode := erlangCode, quote, goalStatement, quote, comma. "Goal-statement is first element of tuple"	erlangCode := erlangCode, String cr, indent, ' [  '.  "Start list of preconditions."	aHumFrame4Plan preconditions do: [  :precondition |		erlangCode := erlangCode, String cr, indent, quote, precondition source, quote.		indent := '  , '.		 ].	indent := '  '.	erlangCode := erlangCode, String cr, indent, ' ], '.  "End list of preconditions."	erlangCode := erlangCode, String cr, indent, ' ['.  "Start list of actions."	aHumFrame4Plan planActions do: [  :action |		erlangCode := erlangCode, String cr, indent, quote, action source, quote.		indent := '  , '.  "Separate list items with a comma."		 ].	indent := '  '.	erlangCode := erlangCode, String cr, indent, ' ] '. "End list of actions."	erlangCode := erlangCode, String cr,  ' }'.		^erlangCode.! !!HumOntologyTranslator methodsFor: 'translate to Erlang' stamp: 'RichardAlexanderGreen 12/30/2015 10:17'!generateErlangForRoles	"Generate a Erlang module file for each Hum role."! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk Seaside' stamp: 'RichardAlexanderGreen 4/20/2015 08:19'!generateSeasideWidgetsForSource: aSourceString	"Generate Seaside calls for the widgets found in this mark-up line."	| calc between before after wip |		self moveCodeGenerator.	"*** CALLER MUST REPLACE ALL [] WITH {} BECAUSE WE GENERATE [] IN SEASIDE CODE. ***"	wip := aSourceString.		"Match button."	( '*{{*}}*' match: wip )		ifTrue: [ calc := HumCalculator new.			between := calc given: wip extractBetween: '{{' and: '}}'.			before := calc given: wip extractUpto: '{{'.			after  := calc given: wip extractAfter: '}}'.			wip := before,'<button name="',between,'" />'.			"Get all the buttons before we go on."			wip := wip, (self generateSeasideWidgetsForSource: after).			].	"Match check-box" 	( '*{#}*' match: wip )		ifTrue: [ calc := HumCalculator new.			between := calc given: wip extractBetween: '{' and: '}'.			before := calc given: wip extractUpto: '{'.			after  := calc given: wip extractAfter: '}'.			wip := before,'<input name="',between,'" type="checkbox"/>'.			"Get all the check-boxes before we go on."			wip := wip, (self generateSeasideWidgetsForSource: after).			].	"Match other widgets."	( '*{*}*' match: wip )		ifTrue: [ calc := HumCalculator new.			between := calc given: wip extractBetween: '{' and: '}'.			before := calc given: wip extractUpto: '{'.			after  := calc given: wip extractAfter: '}'.			       "Name followed by space and digit means multi-line text box"			( between matchesRegex: '^.*\b\d$'  )				ifTrue: [ | name d |					name := calc given: between extractUpto: ' '.					d := calc given: between extractAfter: ' '.					wip := before,'<textarea name="',name,'" rows=',d,' cols=60 /></textarea>'.					wip := wip, (self generateSeasideWidgetsForSource: after).					]				ifFalse: ["Not a textarea . . ."					"TODO: If the attribute-name is plural, render as a table."					| noun |					noun := between.					(ontology isPluralNoun: noun)						ifFalse: [wip := before,'<input name="',between,'" />',after.]						ifTrue:  [wip := before, (self generateSeasideTableFor: noun ), after.].					].			"TODO: Special handling for other types: category, date-time, measure."			].	"Match radio-button -- TODO: THIS RADIO BUTTON STRATEGY WILL FAIL."		( '*(#)*' match: wip )			ifTrue: [ calc := HumCalculator new.			between := calc given: wip extractBetween: '(' and: ')'.			self assert: (between size = 1).			before := calc given: wip extractUpto: '('.			after  := calc given: wip extractAfter: ')'.			"Call myself recursively"			wip := before,'<input name="',between,'" type="radio"/>'.			wip := wip, (self generateSeasideWidgetsForSource: after).			"TODO: Need <group> tags."			].			^wip.	! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk Seaside' stamp: 'RichardAlexanderGreen 3/10/2014 02:59'!generateSeasideHeadingFor: source	"Generate Seaside heading code for the given heading line."	| headingString end outlineCode  quote period|			self moveCodeGenerator.	self assert: (source beginsWith: '!!' ).	quote := $' asString.	period := $. asString.   headingString := source. 	end := headingString size.													(source beginsWith: '!!' ) 		ifTrue: [ outlineCode := 'html heading level: 1; with: ',			                        quote, (headingString copyFrom: 1+1 to: end), quote, period. ].	(source beginsWith: '!!!!' ) 		ifTrue: [ outlineCode := 'html heading level: 2; with: ',			                        quote, (headingString copyFrom: 2+1 to: end), quote, period. ].	(source beginsWith: '!!!!!!' ) 		ifTrue: [ outlineCode := 'html heading level: 3; with: ',			                        quote, (headingString copyFrom: 3+1 to: end), quote, period. ].	(source beginsWith: '!!!!!!!!' ) 		ifTrue: [ outlineCode := 'html heading level: 4; with: ',			                        quote, (headingString copyFrom: 4+1 to: end), quote, period. ].	(source beginsWith: '!!!!!!!!!!' ) 		ifTrue: [ outlineCode := 'html heading level: 5; with: ',			                        quote, (headingString copyFrom: 5+1 to: end), quote, period. ].	^outlineCode.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk Seaside' stamp: 'RichardAlexanderGreen 3/10/2014 02:59'!generateSeasideForView: aHumFrame4View 	"Implement the view frame via Seaside components.	This is a code generator.	"	| tab cr frameCode |		self moveCodeGenerator.		cr := String cr.	tab := String tab.	frameCode := String new.	frameCode := frameCode, tab, 'html form with: [ ', cr.	aHumFrame4View frameLines		do: [ :line |			| lineCode |			"Generate Seaside code for each line in the view frame"			lineCode := self generateSeasideForViewMarkup: line.			frameCode := frameCode, tab, tab, lineCode, cr.			"TODO: SUSPECT THERE SHOULD BE A COMMA IN GENERATED CODE ABOVE."			].	frameCode := frameCode, tab, tab,  ']', cr.	^frameCode.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk Seaside' stamp: 'RichardAlexanderGreen 6/13/2014 08:50'!generateSeasideWidgetForField: fieldName	| widgetCode commentCode semicolon period|		self moveCodeGenerator.  self assert: ( fieldName notNil ). 	semicolon := $; asString.	period := $. asString.	"This is the default to cover when we fall through the cases."	commentCode := ' "*** Widget not handled [', fieldName,'] ***" '.	"Does widget contain a colon. If not, we have a simple attribute."	( fieldName includesSubString: ':' ) 		ifFalse: [ 					commentCode := '"*** Update attribute [',fieldName,'] ***"'.					widgetCode := 'html textInput'					  ,' callback: [:datum | self blackBoard setEntityID: entityID attribute: #', fieldName						,' toValue: datum ]'					  , semicolon					  ,' name: ', (fieldName surroundedBySingleQuotes)					  , semicolon					  ,' value: ',(fieldName surroundedBySingleQuotes)						, period. 					( fieldName size = 1 )  "Over-ride and invoke a Seaside checkbox instead."						ifTrue: [ commentCode := '"*** TODO: Generate code for check-box: [',fieldName,'] ***' ].						].	"TODO: REFACTOR above so that it is more sensitive to the attribute`s data-type. 	Text should render as text-area.	A category should render as a select or radio group.	A date-time as a date-picker.	A set or list should render as a table.	Perhaps a measure should render as text (validated to numeric) plus a select (of unit-of-measure).	"	( fieldName beginsWith: 'page:')		ifTrue: [ | pageName | "[page: local page reference]"					pageName := ( HumCalculator given: fieldName extractAfter: 'page:' ).					commentCode := ' "*** Generate code for page: ', pageName ,'****" '.					widgetCode := widgetCode, 'html anchor '											,'url: ', (('./',(pageName asCamelCase)) surroundedBySingleQuotes)											, semicolon											,'with: ', (pageName surroundedBySingleQuotes )											, period.					].	( fieldName beginsWith: 'link:')		ifTrue: [  "[link: text | uri ]"				| linkName linkURL |				linkName := ( HumCalculator given: fieldName extractBetween: 'link:' and: '|' ).				linkURL := ( HumCalculator given: fieldName extractAfter: '|').				commentCode := ' "*** Generate code for link: ', linkName ,'****" '.				widgetCode := widgetCode, 'html anchor '											,'url: ', ( linkURL surroundedBySingleQuotes )											, semicolon											,'with: ', ( linkName surroundedBySingleQuotes )											, period.					].	( fieldName beginsWith: 'pane:')		ifTrue: [ | paneName | "[pane: name of a Hum view]"					paneName := ( HumCalculator given: fieldName extractAfter: 'pane:' ).					commentCode := ' "*** Generate code for pane: ', paneName, '****" '.										widgetCode := '(self ontology fetchFrameByName: ', paneName											,') asSeasideWithOntology: (self ontology)', period.					].	"TODO: Hum panes need to be enclosed in table <td> or perhaps <div> 	 . . . so that they can be placed side-by-side.	 . . . (The alternative using CSS {position: ABSOLUTE} is much more difficult.)	PERHAPS: We might require that the author indicate the table like this:	| [pane: left-navigation] | [pane: content] | 	That would simplify the code generation, 	  but it leaks HTML constraints to the view code.	In any case, this code-block needs to 'call' the view-code.	"						^ commentCode, String cr, widgetCode.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk Seaside' stamp: 'RichardAlexanderGreen 3/10/2014 02:59'!moveCodeGenerator	(self isKindOf: HumOntologyTranslator)		ifFalse: [Error signal: 'Move this code generator to HumOntologyTranslator'].! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk Seaside' stamp: 'RichardAlexanderGreen 6/13/2014 08:49'!generateSeasideForViewMarkup: aHumMarkupLine 	"Generate Seaside code to implement a view mark-up line."	| lineCode  fieldName source|		self moveCodeGenerator.	"Parse into tokens"	source := aHumMarkupLine source.	lineCode := String new.	lineCode := lineCode, 'html break. '.	"Generate for heading"	(source beginsWith: '!!' ) 		ifTrue: [ lineCode := lineCode, (self generateSeasideHeadingFor: source )]. 		"Generate input fields."	fieldName := ( HumCalculator given: source extractBetween: '[' and: ']' ).	fieldName ifNotNil: [ lineCode := lineCode, (self generateSeasideWidgetForField: fieldName )].		^lineCode. ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumOntologyTranslator class	instanceVariableNames: ''!!HumOntologyTranslator class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/12/2014 12:38'!ontology: aHumOntology 	"Create an instance"	| instance |	instance := self basicNew.	instance ontology: aHumOntology.	^instance! !Object subclass: #HumOntologyViewer	instanceVariableNames: 'ontology lastLevel modeStack priorCaseIsTrue generatedMarkupCode calc'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumOntologyViewer commentStamp: 'RichardAlexanderGreen 5/13/2014 09:09' prior: 0!The Ontology Viewer renders views of the ontology frames in HTML.The Ontology Translator is a code generator that translates frames into some executable language.This architecture separates rendering and translating logic from the ontology itself.Hopefully, this will make the code easier to maintain.!!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 5/18/2015 09:34'!renderCritiqueForFrame: aHumFrame 	"Return (HTML5) rendering of the frame`s critique"	| html problems myCalc  |	problems := aHumFrame compileToOntology: ontology.	problems isEmpty ifTrue: [^''].	myCalc := HumCalculator new.	html := (myCalc xml: 'critiqueLine' with: [ '<br/><br/><u style="color: DARKRED">Critique:</u>' ]).	problems 		do: [ :critiqueText |			 html := html, (myCalc xml: 'critiqueLine' with: [ '<br/>&nbsp; ', critiqueText ]).			 ].	^html.! !!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 8/1/2016 07:30'!renderFrame: aHumFrame  withCritique: withCritique withBase: withBaseOntology	"Render (pretty print) source code. 	--  This is a read-only view for ontology code listing."	| html |	html := String new.		"Abbreviate the frame if we are skipping base ontology frames."	((withBaseOntology = false) and: [aHumFrame origin = 'BaseOntology.txt'])		ifTrue: [ 				"html := calc xml: 'commentLine' with: [ (aHumFrame titleLine), ' -- See base ontology.'  ]. "				^html.			 ].	"Wrap the lines with a HumFrame tag."	"Note: <frame> has semantics in HTML, so we use <HumFrame> tag instead."	html :=		calc xml: 'HumFrame'				with: [ | frameHTML titleHTML subHTML|					calc cases;						when: [ aHumFrame isKindOf: HumFrame4Action ] 							then: [ frameHTML := self renderActionFrame: aHumFrame ];						when: [ aHumFrame isKindOf: HumFrame4Plan ] 							then: [ frameHTML := self renderPlanFrame: aHumFrame ];						otherwise: [ "Tag the title line."												titleHTML := (calc xml: 'frameTitle' with: [  aHumFrame titleLine asString ]).												subHTML := self renderFrameLinesIn: aHumFrame.												frameHTML := titleHTML, subHTML. ].					withCritique ifTrue: [ frameHTML := frameHTML, (self renderCritiqueForFrame: aHumFrame ) ].					"Return"					frameHTML.					].	^'<hr/>',String cr,html.! !!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 5/18/2015 18:00'!renderPlanFrame: aHumFrame4Plan 	"Render source code. 	--  This is a read-only view for ontology code listing."	| html  |	calc := HumCalculator new. "Initialize indent"	html :=	calc xml: 'HumFrame'		with: [			(calc xml: 'frameTitle' with: [  'Goal: ', ( self renderInstruction: (aHumFrame4Plan goal ) )]),			( self renderPlanPreconditionsIn: aHumFrame4Plan ),			( self renderPlanActionsIn: aHumFrame4Plan )					].	^html.! !!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 2/12/2014 12:27'!showPlanTree: aPlanTree	"Display a previous created planTree (generated by  buildPlanTreeForGoal: )"	| string cr |	"See: HumOntologyTests>>test540GetPlanTree 	-- Call to this method is commented out.	See also: HumOntology>>buildPlanTreeForGoal:	"	cr := String cr.	 string := cr, 'Plan Tree:', cr.	aPlanTree 		do: [ :mapPostPre |				string := string, ( mapPostPre key ) asString, ' -> ', ( mapPostPre value ) asString, cr.				].		"TODO: What does this produce?  It looks like a simple rendering with no indentation."	^ string.! !!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 5/20/2016 07:48'!renderActionFrame: aHumFrame4Action 	"Render action frame with indentation.	--  This is a read-only view for ontology code listing."	| html  innerHTML frameLines statementIndent  titleHtml |	calc := HumCalculator new. "By-Product: Initializes XML indent"	innerHTML := ''.	statementIndent := 1.	frameLines := aHumFrame4Action frameLines.	( frameLines reject: [:aFrameLine | |s| s := aFrameLine source. (s beginsWith: 'Action:') or: [s beginsWith: 'To:']] )		do: [ :frameLine |			| s |			s := frameLine statement source trimBoth.			"Else: reduces indent for self."			( s asLowercase beginsWith: 'else') ifTrue: [ statementIndent := statementIndent - 1 ].			(frameLine isKindOf: HumInstructionLine) ifTrue: [ frameLine indent: statementIndent ].			innerHTML := innerHTML,'<br/>', String cr, (self renderFrameLine: frameLine ).			"If, Else, for-each, all increase indent."			(s endsWith: ':') ifTrue:  [ statementIndent := statementIndent + 1 ]. 			].	titleHtml := calc xml: 'frameTitle' with: [  aHumFrame4Action titleLine asString ].	html := calc xml: 'HumFrame' with: [		  titleHtml,			'<br/><b>Role: </b>',			(calc xml: 'role' with: [ (aHumFrame4Action role capitalized),'.' ]),			'<br/><b>Action: </b>',			(calc xml: 'action' with: [ self renderInstruction: ( aHumFrame4Action actionStatement ) ]), innerHTML.					].	^html.! !!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 12/15/2014 07:16'!renderPlanActionsIn: aHumFrame4Plan 	"render precondition lines"	| html cr |	cr := String cr.	html := '<br/><b>Actions:</b>', cr.	(aHumFrame4Plan actionStatements)		do: [ :actionLine |			self assert: ( actionLine isKindOf: HumInstructionLine ).			html := html, '<br/>', (self renderInstructionLine: actionLine).			"html := html, '<br/>', ( self renderStatement: actionLine ), cr."			].	^ html! !!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 3/2/2014 12:19'!renderFrameLinesIn: aHumFrame 	"Iterate throught the frame lines" 	| html cr class |	"View frames are rendered as HTML forms with widgets."	class := aHumFrame class.	(class = HumFrame4View ) ifTrue: [^ self renderView: aHumFrame ].	"Plan frames are rendered with Precondition and Action sections"	(class = HumFrame4Plan ) ifTrue: [^ self renderPlanFrame: aHumFrame ].	"Action frames are rendered with Role: and Action: labels."	(class = HumFrame4Action ) ifTrue: [^ self renderActionFrame: aHumFrame ].		"Other frame types are just pretty-printed?"	cr := String cr.	html := cr.	aHumFrame frameLines 		do: [ :frameLine |				html := html, '<br/>', ( self renderFrameLine: frameLine  ) ].	^html.! !!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 7/25/2016 11:01'!renderFrame: aHumFrame  withCritique: withCritique	"Render (pretty print) source code. 	--  This is a read-only view for ontology code listing."	| html |	html := self renderFrame: aHumFrame withCritique: withCritique withBase: false.	^html.! !!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 5/28/2014 12:20'!renderView: aHumViewFrame 	"Views are rendered as HTML forms -- which is different from other frames."	| html cr br innerHTML |	cr := String cr.	br := cr, '<br/>'.	innerHTML := cr.	html := cr, (calc xml:'form' with: [		aHumViewFrame frameLines 		do: [ :frameLine |				"Markup lines will control line-breaks without my help."				"Future: View might have instruction-lines for tables."				(frameLine isKindOf: HumMarkupLine)					ifTrue: [innerHTML := innerHTML, br, ( self renderMarkupAsHTML5: frameLine source )]					ifFalse:[innerHTML := innerHTML, br, ( self renderInstructionLine: frameLine source )						].				 ].		"Block returns "		innerHTML.		]	).	^html.! !!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 5/20/2016 07:45'!renderActionFrame: aHumFrame4Action withCritique: aBoolean	"Render source code. 	--  This is a read-only view for ontology code listing."	| html  innerHTML frameLines statementIndent  titleHtml |	calc := HumCalculator new. "By-Product: Initializes XML indent"	innerHTML := ''.	statementIndent := 1.	frameLines := aHumFrame4Action frameLines.	( frameLines reject: [:aFrameLine | |s| s := aFrameLine source. (s beginsWith: 'Action:') or: [s beginsWith: 'To:']] )		do: [ :frameLine |			| s |			s := frameLine statement source trimBoth.			"Else: reduces indent for self."			( s asLowercase beginsWith: 'else') ifTrue: [ statementIndent := statementIndent - 1 ].			(frameLine isKindOf: HumInstructionLine) ifTrue: [ frameLine indent: statementIndent ].			innerHTML := innerHTML,'<br/>', String cr, (self renderFrameLine: frameLine ).			"If, Else, for-each, all increase indent."			(s endsWith: ':') ifTrue:  [ statementIndent := statementIndent + 1 ]. 			].	titleHtml := calc xml: 'frameTitle' with: [  aHumFrame4Action titleLine asString ].	html := calc xml: 'HumFrame' with: [		  titleHtml,			'<br/><b>Role: </b>',			(calc xml: 'role' with: [ (aHumFrame4Action role capitalized),'.' ]),			'<br/><b>Action: </b>',			(calc xml: 'action' with: [ self renderInstruction: ( aHumFrame4Action actionStatement ) ]), innerHTML.					].	^html.! !!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 12/15/2014 07:17'!renderPlanPreconditionsIn: aHumFrame4Plan 	"render precondition lines"	| html br|	"Always include this subheading."	html := '<br/><b>Preconditions:</b>'.	br := String cr, '<br/>'.	(aHumFrame4Plan preconditions)		do: [ :preconditionLine |			self assert: (preconditionLine isKindOf: HumFrameLine ).			html := html, br, (self renderFrameLine: preconditionLine ).			].	^ html! !!HumOntologyViewer methodsFor: 'render widgets' stamp: 'RichardAlexanderGreen 8/1/2016 08:23'!renderWidgetsInMarkup: aSourceString 	"Return HTML5 equivalent of the widgets found in this mark-up line."	|  between before after wip |	wip := aSourceString.	"Match button."	( '*[[*]]*' match: wip )		ifTrue: [			between := calc given: wip extractBetween: '[[' and: ']]'.			before := calc given: wip extractUpto: '[['.			after  := calc given: wip extractAfter: ']]'.			wip := before,'<button name="',between,'" />',after.			"Get all the buttons before we go on."			wip := self renderWidgetsInMarkup: wip.			].	"Match check-box" 	( '*[#]*' match: wip )		ifTrue: [ 			between := calc given: wip extractBetween: '[' and: ']'.			before := calc given: wip extractUpto: '['.			after  := calc given: wip extractAfter: ']'.			wip := before,'<input name="',between,'" type="checkbox"/>',after.			"Get all the check-boxes before we go on."			wip := self renderWidgetsInMarkup: wip.			].	"Match other widgets."	( '*[*]*' match: wip )		ifTrue: [ 			between := calc given: wip extractBetween: '[' and: ']'.			before := calc given: wip extractUpto: '['.			after  := calc given: wip extractAfter: ']'.			       "Name followed by space and digit means multi-line text box"			( between matchesRegex: '^.*\b\d$'  )				ifTrue: [ | name d |					name := calc given: between extractUpto: ' '.					d := calc given: between extractAfter: ' '.					wip := before,'<textarea name="',name,'" rows=',d,' cols=60 /></textarea>',after.]				ifFalse: ["Not a textarea . . ."					"TODO: If the attribute-name is plural, render as a table."					| noun calc2 |					noun := between.					calc2 := HumCalculator new.					calc2 cases;						when: [ ontology isPluralNoun: noun ] 							then: [wip := before, (self generateHtmlTableFor: noun ), after.  ];						when: [ ontology isCategory: noun ]							then: [ wip := before, (self generateCategoryPullDownFor: noun ), after. ];						otherwise: 							[ wip := before, '<input name="', noun, '" />', after ].					].			"TODO: Special handling for other types: category, date-time, measure."			].	"Match radio-button"		( '*(#)*' match: wip )			ifTrue: [ 			between := calc given: wip extractBetween: '(' and: ')'.			self assert: ((between size) = 1).			before := calc given: wip extractUpto: '('.			after  := calc given: wip extractAfter: ')'.			wip := before,'<input name="',between,'" type="radio"/>',after.			"TODO: Need <group> tags. HOW ARE WE GOING TO DO THAT?"			].			"If no widgets were found in this pass: Return;  Otherwise: Iterate."	( wip = aSourceString ) 		ifTrue: [ ^aSourceString.]		ifFalse: [ ^ self renderWidgetsInMarkup: wip ].	! !!HumOntologyViewer methodsFor: 'render widgets' stamp: 'RichardAlexanderGreen 8/1/2016 11:07'!generateCategoryPullDownFor: aNoun 	"Render category noun as a pull-down selection."	| html categoryList|	categoryList := ontology categoriesOf: aNoun.	self assert: (categoryList size > 0).	"Use global HumCalculator to generate XML "	html := calc xml: 'select' dictionary: { 'name'->aNoun }								with: [ calc xml: 'option' list: (categoryList sorted) ].	^html.! !!HumOntologyViewer methodsFor: 'render statement' stamp: 'RichardAlexanderGreen 5/18/2015 18:04'!renderStatement: aHumStatement triggerWords: triggerWords keywords: keywords 	| tokenTypes html token type fragment |	html := ''.	tokenTypes := ontology parseStatement: aHumStatement triggerWords: triggerWords keywords: keywords.	tokenTypes		do: [ :tokenType |   "For each token-type:"			token := tokenType key.			type := tokenType value.			fragment := ''.			"Assign a tag that the CSS can then style."			( type = #word ) ifTrue: [ fragment := ' ', token ].			( type = #noun ) ifTrue: [ fragment := ' <n>', token, '</n>' ].			( type = #keyword ) ifTrue: [ fragment := ' <k>', token, '</k>' ].			( type = #role ) ifTrue: [ fragment := ' <r>', token, '</r>' ].			"Just another token with no particular type."			( fragment = '' ) ifTrue: [ fragment := token ].			html := html, fragment.			].	^html! !!HumOntologyViewer methodsFor: 'render statement' stamp: 'RichardAlexanderGreen 5/18/2015 18:09'!renderInstruction: aHumStatement   "Pretty-print statement as HTML"	| triggerWords keywords |	triggerWords := 'if else for-each for' findTokens: ' '.	 keywords := #('giving').	^self renderStatement: aHumStatement triggerWords: triggerWords keywords: keywords.	 ! !!HumOntologyViewer methodsFor: 'render statement' stamp: 'RichardAlexanderGreen 5/18/2015 18:04'!renderStatement: aHumStatement keywords: keywords 	| tokenTypes html token type fragment |	html := ''.	tokenTypes := ontology parseStatement: aHumStatement triggerWords: #() keywords: keywords.	tokenTypes		do: [ :tokenType |   "For each token-type:"			token := tokenType key.			type := tokenType value.			fragment := ''.			"Assign a tag that the CSS can then style."			( type = #word ) ifTrue: [ fragment := ' ', token ].			( type = #noun ) ifTrue: [ fragment := ' <n>', token, '</n>' ].			( type = #keyword ) ifTrue: [ fragment := ' <k>', token, '</k>' ].			( type = #role ) ifTrue: [ fragment := ' <r>', token, '</r>' ].			"Just another token with no particular type."			( fragment = '' ) ifTrue: [ fragment := token ].			html := html, fragment.			].	^html! !!HumOntologyViewer methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/28/2014 13:04'!initialize	calc := HumCalculator new.! !!HumOntologyViewer methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/12/2014 12:14'!ontology: aHumOntology 	ontology := aHumOntology.! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 5/18/2015 18:00'!renderInstructionLine: aHumInstructionLine  	"Pretty-print using HTML5 tags and CSS."	| html xmlRole xmlStatement xmlComment xmlAnnotation assembly  attr |	"Avoid an empty role element.	Note that colon may be  inserted for HTML readability."	xmlRole :=  ( aHumInstructionLine role sameAs: '' )  		ifTrue: [''] 		ifFalse: [ (( calc xml: 'role' with: [ (aHumInstructionLine role) ] ), ':' )].	"Avoid empty statement element."		xmlStatement := (aHumInstructionLine statement source isEmpty ) 		ifTrue: [''] 		ifFalse: [( calc xml: 'statement' with: [self renderInstruction: (aHumInstructionLine statement)  ] ) ].	"Avoid empty comment element.	Note that parends are added for Hum consistency."	xmlComment := ( aHumInstructionLine comment trimBoth isEmpty ) 		ifTrue: [''] 		ifFalse: [ self renderCommentIn: aHumInstructionLine ].	"Render the annotation."		xmlAnnotation := ( aHumInstructionLine annotation trimBoth isEmpty ) 		ifTrue: [''] 		ifFalse: [ (  calc xml: 'annotation' with: [ ' [ ', (aHumInstructionLine annotation), ' ]' ]   ) ].	"Assemble it without any line breaks."		assembly := xmlRole, xmlStatement, xmlComment, xmlAnnotation.	attr := (Dictionary new) at: 'class' put: ('indent',(aHumInstructionLine indent asString)); yourself.	html := (calc xml: 'InstructionLine' dictionary: attr with: [ assembly ]).	^html.! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 5/18/2015 08:32'!renderFrameLine: frameLine  	"Dispatch frameLine to rendering specialist."	| class |	self assert: (frameLine isKindOf: HumFrameLine).	class := frameLine class.	(class = HumConditionLine ) ifTrue: [^ self renderConditionLine: frameLine ]. 	(class = HumDictionaryLine ) ifTrue: [^ self renderDictionaryLine: frameLine ]. 	(class = HumInstructionLine ) ifTrue: [^ self renderInstructionLine: frameLine ].	(class = HumCommentLine)          ifTrue: [^ calc xml: 'commentLine' with: [ frameLine source ]].	(class = HumVignettePatternLine)  ifTrue: [^ calc xml: 'patternLine' with: [ frameLine source] ]. 	(class = HumVignetteResponseLine) ifTrue: [^ calc xml: 'responseLine' with: [ frameLine source] ]. 		"Under some conditions we get an ordinary frame line in Action frames."	self assert: false description: 'Something has changed. Be careful.'.	(class = HumFrameLine and: [frameLine source sameAs: ' ']) ifTrue: [^' ' ].	(class = HumFrameLine and: [frameLine source beginsWith: 'Role:']) ifTrue: [^self renderActionLine: frameLine ].	(class = HumFrameLine and: [frameLine source beginsWith: 'Action:']) ifTrue: [^self renderActionLine: frameLine ].	(class = HumFrameLine and: [frameLine source beginsWith: 'To:']) ifTrue: [^self renderActionLine: frameLine ].		Error signal: 'FrameLine  subclass not handled: ', (class asString).! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 5/9/2016 07:42'!renderDictionaryLine: aHumDictionaryLine 	|  |					^ calc xml: 'DictionaryLine' 			with: [				(calc xml: 'statement' 					 with: [(self renderStatement: (aHumDictionaryLine statement ) keywords: #('is' 'a' 'attributes' 'include' 'categories' 'list' 'set' 'subtypes' 'abbreviation' 'shorthand' 'synonym' 'for' ) )						    , (self renderCommentIn: aHumDictionaryLine)  ]					 					)				  ]. ! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 6/14/2014 09:26'!renderMarkupAsHTML5: markupSource	"Render the given mark-up text as HTML headings, lists, emphasis."	"TODO: Replace this with call to HumOntologyTranslator." 	| html heading marker remainder level aString |	self assert: (markupSource isKindOf: String ).	"Maintain spacing."	aString := calc given: markupSource replaceAll: '  ' with: '&nbsp;&nbsp;'.		"Is this markup line a heading?"	heading := 'none'.	(1 to: 5)		do: [ :i |			marker := '!!!!!!!!!!' copyFrom: 1 to: i.			( aString beginsWith: marker ) 				ifTrue: [ "Set the heading type and extract the remainder."					heading := 'title', (marker size) asString. 					remainder := (calc given: aString extractAfter: marker ) ]. 			].	"If this is a heading, render the whole line as a heading. "		"Call self recursively to catch any additional emphasis (e.g. italics)"	( heading = 'none'	) ifFalse: [ ^html := calc xml: heading with: (self renderMarkupAsHTML5: remainder).].	"Is this markup line a bullet/numbered list item."		#( '-----' '#####')		do: [ :leaderType |				level := 0.		(1 to: 5 )			do: [ :i |				marker := leaderType copyFrom: 1 to: i.				( aString beginsWith: marker ) 					ifTrue: [ "Set the heading type and extract the remainder."						level := (marker size). 						remainder := (calc given: aString extractAfter: marker ) ]. 				].		( level > 0 )			ifTrue: [				html := ''.				( (lastLevel isNil ) or: [ level > lastLevel ] ) 					ifTrue:[ 						(marker beginsWith: '-') ifTrue: [ self modeStack push: 'ul'].						(marker beginsWith: '#') ifTrue: [ self modeStack push: 'ol'].						html := '<',(self modeStack top),'>'.						].				"TODO: Figure out how to emit '</ul>' and '</ol>.' -- Might need MODES. (heavens)"				( (lastLevel notNil ) and: [ level < lastLevel ] ) 					ifTrue:[ 						html := '</',(self modeStack top),'>'. 						].				lastLevel := level.				html := html, (calc xml: 'li' with: (self renderMarkupAsHTML5: remainder )).				^html.					].			].		"None of the above"	"Delegate emphasis"	html := self renderMarkupEmphasisAsHTML5: aString.	html := self renderWidgetsInMarkup: html.	^html.			! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 4/20/2015 08:12'!renderMarkupEmphasisAsHTML5: aString 	"Render bold, italic, underscore emphasis."	| wip between before after |  self assert: ( aString isKindOf: String ).	(( aString includes: $*) or: [ (aString includes: $~) or: [ aString includes: $_]])		ifFalse: [^aString].	"Initialize work-in-progress."	wip := aString.	('*_*_*' match: wip )		ifTrue: [ "become *<u>*</u>*"			between := calc given: wip extractBetween: '_' and: '_'. 			before  := calc given: wip extractUpto: '_'.			after   := calc given: wip extractAfterSecond: '_'.			wip := before, '<u>', between, '</u>', after.			].	('*~*~*' match: wip )		ifTrue: [ "become *<i>*</i>*"			between := calc given: wip extractBetween: '~' and: '~'. 			before  := calc given: wip extractUpto: '~'.			after   := calc given: wip extractAfterSecond: '~'.			wip := before, '<i>', between, '</i>', after.			].	"Cannot use #match: for asterisk case. So we use this trick:"	((HumCalculator given: wip extractBetween: '*' and: '*') = '')		ifFalse: [			between := HumCalculator given: wip extractBetween: '*' and: '*'.			before := calc given: wip extractUpto: '*'.			after   := calc given: wip extractAfterSecond: '*'.			wip := before, '<b>', between, '</b>', after.			].		^wip.! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 3/2/2014 11:17'!modeStack	"Stack to track list-type modes."	^ modeStack ifNil: [ modeStack := Stack new.]! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 5/28/2014 11:16'!renderCommentIn: aFrameLine 	"Render comment (if any) as HTML"	| html |	html := ''.	(aFrameLine comment notEmpty)		ifTrue: [ html := calc xml: 'comment' with: (aFrameLine comment) ]. 	^html.! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 5/18/2015 17:58'!renderConditionLine: aHumConditionLine  	| html xmlStatement xmlComment xmlAnnotation assembly  |	"Avoid empty statement element."		xmlStatement := (aHumConditionLine statement source isEmpty ) 		ifTrue: [''] 		ifFalse: [( calc xml: 'statement' with: [self renderInstruction: (aHumConditionLine statement) ] ) ].	"Avoid empty comment element.	Note that parends are added for Hum consistency."	xmlComment := ( aHumConditionLine comment trimBoth isEmpty ) 		ifTrue: [''] 		ifFalse: [ (  calc xml: 'comment' with: [ '( ', (aHumConditionLine comment), ' )' ]   ) ].	"Render the annotation."		xmlAnnotation := ( aHumConditionLine annotation trimBoth isEmpty ) 		ifTrue: [''] 		ifFalse: [ (  calc xml: 'annotation' with: [ '[ ', (aHumConditionLine annotation), ' ]' ]   ) ].	"Assemble it without any line breaks."		assembly := xmlStatement, xmlComment, xmlAnnotation.	html := (calc xml: 'PreconditionLine' with: [ assembly ]).	"TODO: Add hyperlink to frame (if any) that has goal matching this precondition."	^html.! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 12/14/2014 10:37'!renderActionLine: aHumFrameLine 	| source  isRedundant |	"Tests indicate this is redundant."	isRedundant := true.	isRedundant ifTrue: [self halt.  ^' '].
		source := aHumFrameLine source.	^ calc xml: 'titleLine' with: [source].! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 3/2/2014 11:15'!generateHtmlTableFor: anEntity	"Generate a dummy table showing the attributes for this entity-name." 	| singular attributes html  |	singular := ontology singularFormOfNoun: anEntity.	attributes := ontology allAttributesOfEntity: singular.	"If the entity has no attributes, generate a default table."	( attributes size = 0 )		ifTrue: [^'<table name="',anEntity,'"><tr><th>',anEntity,' has no attributes in current ontology.</th></tr></table>'].  "Otherwise generate a normal table."	html := '<table name="',anEntity,'" >'.	html := html, '<tr>'.	attributes do: [:attribute | html := html, '<th>', attribute, '</th>'.]. 	html := html, '</tr>'.	html := html, '<tr>'.	attributes do: [:attribute | html := html, '<td>', attribute, ' value </td>'.]. 	html := html, '</tr>'.	html := html, '</table>'.	^html.! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 3/2/2014 10:42'!renderAsHTMLonFileNamed: aNewFile 	"Render as HTML5 and echo on given file."	| html file  |	html := self asHTML5.	file := StandardFileStream forceNewFileNamed: aNewFile. 	file nextPutAll: html.	file close.	^html.! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 7/25/2016 10:50'!asHTML5withCritique	"Render the ontology as an HTML5 page.	. Include critique.	. Do not expand base frames.	"	| html    |	html := self asHTML5withCritique: true withBase: false.	^html! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 7/25/2016 10:55'!asHTML5withCritiqueSkippingBaseOntology	"Render the ontology as an HTML5 page.	. Since HTML is based on XML, we create XML elements.	"	| html    |	html := self asHTML5withCritique: true  withBase: false.	^html.! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 3/2/2014 10:42'!renderAs: aSymbol 	"FUTURE: Render as X -- Currently not needed."	self shouldBeImplemented.	self assert: ( aSymbol isKindOf: Symbol ).	self log: 'Ontology: Document ontology as: ', ( aSymbol asString ). 	"Call the HTML rendering code."	(aSymbol = #HTML or: [ aSymbol = #HTML5 ])		ifTrue: [ self renderAsHTMLonFileNamed: ( (self file), '.html') ]		ifFalse: [ self shouldBeImplemented ].	! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 2/12/2014 12:27'!render: asSymbol onFileNamed: aNewFile	| string file |	string := self renderAs: asSymbol.	file := StandardFileStream forceNewFileNamed: aNewFile. 	file nextPutAll: string.	file close.	^string.! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 5/18/2015 18:00'!renderPlanTreeForGoal: aGoal	"Render HTML for a previous created planTree (generated by  buildPlanTreeForGoal: )"	| string cr indentedPlanTree priorIndent goalHTML |	"NOTE: The goals that are most relevant are those found in dialog vignettes."	"See: HumOntologyTests>>test540GetPlanTree 	-- Call to this method is commented out.	See also: HumOntology>>buildPlanTreeForGoal:	"	cr := String cr.	string := cr, 'Plan Tree:', cr.	indentedPlanTree := ontology buildPlanTreeForGoal: aGoal indent: 0.	priorIndent := 999.	goalHTML := self renderInstruction: (HumStatement source: ( ( indentedPlanTree at: 1 ) key )).	indentedPlanTree 		do: [ :mapPostPre |				| value indent precondition pad |				value := ( mapPostPre value ).  "= { indent. precondition. }"				indent := value at: 1.				precondition := value at: 2.				pad := String new: 2 + (indent * 5) withAll: (Character space).				( priorIndent = 999 ) 					ifTrue: [ string := string, pad, goalHTML, cr ].				string := string, pad, ' |-> ', (self renderInstruction: precondition ), cr.				priorIndent := indent.				].	^ string.! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 2/12/2014 12:29'!showPlanTreeForGoal: aGoal	"Display a previous created planTree (generated by  buildPlanTreeForGoal: )"	| string cr indentedPlanTree priorIndent |	"See: HumOntologyTests>>test540GetPlanTree 	-- Call to this method is commented out.	See also: HumOntology>>buildPlanTreeForGoal:	"	cr := String cr.	string := cr, 'Plan Tree:', cr.	indentedPlanTree := ontology buildPlanTreeForGoal: aGoal indent: 0.	priorIndent := 999.	indentedPlanTree 		do: [ :mapPostPre |				| value indent precondition pad |				value := ( mapPostPre value ).  "= { indent. precondition. }"				indent := value at: 1.				precondition := value at: 2.				pad := String new: 1 + (indent * 2) withAll: (Character space).				( priorIndent = 999 ) 					ifTrue: [ string := string, pad, ( mapPostPre key ) asString, cr ].				string := string, pad, ' -> ', precondition asString, cr.				priorIndent := indent.				].	^ string.! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 7/25/2016 10:49'!asHTML5	"Render the ontology as an HTML5 page.	. No critique.	. No base frames.	"	| html    |	html := self asHTML5withCritique: false withBase: false.	^html! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 7/25/2016 10:51'!renderAsHTMLwithCritiqueOnFileNamed: aNewFile 	"Render as HTML5 and echo on given file."	| html file  |	html := self asHTML5withCritique: true withBase: false. 	file := StandardFileStream forceNewFileNamed: aNewFile. 	file nextPutAll: html.	file close.	^html.! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 3/24/2015 08:46'!renderNounTreeForNoun: aNoun 	"Render a noun-tree rooted at the given noun (entity)."	| cr string indentedNounTree priorIndent priorNoun |	self assert: (aNoun isKindOf: String).	cr := String cr.	string := cr, 'Noun Tree:', cr.	indentedNounTree := ontology buildNounTreeForNoun: aNoun indent: 0.	priorIndent := 999.	priorNoun := aNoun.	indentedNounTree 		do: [ :mapPostPre |				| value indent property pad supertypes |				value := ( mapPostPre value ).  "= { indent. attribute. }"				indent := value at: 1.				property := value at: 2.				pad := String new: 3 + (indent * 5) withAll: (Character space).				( priorIndent = 999 ) 					ifTrue: [ string := string, pad, aNoun, cr ].				supertypes := ontology immediateSupertypesOf: priorNoun.				( supertypes includes: property )					ifTrue:  [string := string, pad, ' |=> ', property, cr.]					ifFalse: [string := string, pad, ' |-> ', property, cr.].				priorIndent := indent.				priorNoun := property.				].	^ string.	! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 8/17/2016 11:56'!renderNounTreeForNounAsHTML: aNoun 	"Render a noun-tree rooted at the given noun (entity)."	| string html |	string := self renderNounTreeForNoun: aNoun.	html := HumCalculator given: string  replaceAll: '>' with: '&gt;'.	^html! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 6/11/2015 09:41'!css	"generate HTML Cascading Style Sheet (CSS) code segment"	| html  |	calc := HumCalculator new.	html := calc xml: 'style' 			with: [' 				body {font-family: MONOSPACE;}				heading {font-size: X-LARGE; }							title1, title2, title3, title4, title5 {font-weight: BOLD;}				title1 {font-size: 200%;}				title2 {font-size: 150%;}				title3 {font-size: 125%;}				title4 {font-size: 100%;}				frameTitle {color: BLUE; font-size: LARGER; font-weight: BOLD;}								n, noun {color: PURPLE;}				k, keyword {font-weight: BOLD;}				r, role {font-style: ITALIC;font-weight: BOLD;}								statement {color: BLUE;}				c, comment {color: GREEN;}				annotation {}								pattern {}				markup {font-family: MONOSPACE;}				widget {color: RED;}												HumFrame {}				frameLine, CommentLine, DictionaryLine, PreconditionLine  {margin-left: 1em;}				InstructionLine {margin-left: 1em; color: BLUE;}					InstructionLine.indent1 {margin-left: 1em;}						InstructionLine.indent2 {margin-left: 2em;}						InstructionLine.indent3 {margin-left: 3em;}						InstructionLine.indent4 {margin-left: 4em;}											textarea {vertical-align: top;}					form {border-style: outset; padding: 1em;}				table {}				th {background: CYAN;}				td {background: LIGHTGREY;}				errorNote { color: DARKRED; }				critiqueLine { color: DARKRED; margin-left: 1em; }				commentLine { color: DARKGREEN; margin-left: 1em; }				' ].	"TODO: Consider using class='indentN' to control indent in action frames.	 That would enable multi-level indent in Action Frames.	"	^html.! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 8/1/2016 07:26'!asHTML5withCritique: withCritique withBase: withBase	"Render the ontology as an HTML5 page.	. Since HTML is based on XML, we create XML elements.	"	| html heading   |	"Creating a fresh calculator initializes XML indent."	calc := HumCalculator new.	html := calc xml: 'html' 				with: [ "Build the HTML header"					      ( calc xml: 'head' 							with: [ (calc xml: 'title' 										with: [ (ontology title) asString ]),									self css.								   ]),						"Build the HTML body"							(calc xml: 'body'							with: [ | bodyLines | 									bodyLines := ''.									"Render the ontology fiilename, if any, as an HTML5 heading element."									heading := calc xml: 'heading' with: [  'Ontology: ',(ontology title asString) ].									(ontology framesByName keysSortedSafely) 										do: [ :frameName  | 											| frame |											frame := ontology framesByName at: frameName.											"Delegate rendering of the frames to the frames."											 bodyLines := bodyLines, 																	( self renderFrame: frame withCritique: withCritique withBase: withBase ).											"The <hr/> seems to be needed. I cannot figure out how to do that with CSS."											] .									heading, bodyLines, String cr, '<hr/>'.									"The <hr/> also seems to be needed. I cannot figure out how to do that in CSS either."								   ] )						].	"TODO: Add plan-tree rendering.  Render plan-tree for each goal that is invoked in a vignette."	"See: renderPlanTreeForGoal: aGoal"	"TODO: Add noun-tree rendeing. Render a noun-tree for each entity."	"See: renderNounTreeForNoun: aNoun"	"TODO: Add role-dependency rendering. Render a dependency tree for each role."	"TODO: Add context-path rendering.  Render the context path diagram starting with 'Start' context. "	^html.    ! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 7/28/2016 10:19'!renderAsHTMLwithCritique: withCritique withBase: withBase onFileNamed: aNewFile 	"Render as HTML5 and echo on given file."	| html file  |	html := self asHTML5withCritique: withCritique withBase: withBase. 	file := StandardFileStream forceNewFileNamed: aNewFile. 	file nextPutAll: html.	file close.	^html.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumOntologyViewer class	instanceVariableNames: ''!!HumOntologyViewer class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 5/28/2014 13:07'!ontology: aHumOntology 	| instance |	instance := self basicNew.	instance initialize.	instance ontology: aHumOntology.	^instance.! !Object subclass: #HumParser2	instanceVariableNames: 'stack ignoreNext'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumParser2 methodsFor: 'syntax' stamp: 'RichardAlexanderGreen 4/16/2014 07:26'!markupSyntax	"Experimental BNF syntax"	| markup heading text emphasis bold widget alphanum italic underline headingPrefix matched  pageWidget attributeWidget x ordinaryText textAreaWidget number d blank list listPrefix humNoun p t |			markup := [:s | self match: s oneOf: { heading. list. emphasis. widget. alphanum. }  ].		heading := [:s | self match: s sequence:{ headingPrefix. text. } 		                  produce:[|n| n := p size asString. self pop:2; push: ('<h',n,'>',t,'</h',n,'>')] ].	"x is the matched text -- see alphanum below"	"n is the size of the match -- see _prefix below"	headingPrefix := [ :s | p := self match: s oneOf: { '!!!!!!!!!!'. '!!!!!!!!'. '!!!!!!'.  '!!!!'. '!!'. } ].   list := [:s | self match: s sequence:{listPrefix. text.} 	                 produce: [ |n| n := p size asString.  self pop:2; push:('<item',n,'>',t,'</item',n,'>')] ].	listPrefix := [ :s | p := (self match: s oneOf: { '-----'. '----'. '---'. '--'. '-'. } ) ].	text := [ :s | t := self match: s repeat: { ordinaryText. emphasis. } ].	ordinaryText := [:s | x := self match: s repeat: { alphanum. '.'. ','. '-'. '!!'. '?'. ':'. } ].		alphanum := [ :s | x := self alphanumeric: s. ]. "Produces x."	number := [:s | d := self digits: s ].  "Produces d."	blank := [:s | self spaces: s ].		emphasis := [:s | self match: s oneOf: { bold. italic. underline. } ].	bold := [ :s | self match: s      sequence:{ '*'. alphanum. '*'.} produce:[self pop:3; push:('<b>',x,'</b>')] ].		italic := [ :s | self match: s    sequence:{ '~'. alphanum. '~'.} produce:[self pop:3; push:('<i>',x,'</i>')] ].		underline := [ :s | self match: s sequence:{ '_'. alphanum. '_'.} produce:[self pop:3; push:('<u>',x,'</u>')] ].		widget := [:s | self match: s oneOf: { pageWidget. attributeWidget. textAreaWidget. } ].	humNoun := [:s | x := (self noun: s ) ].	pageWidget := [:s | self match: s sequence: {'[page:'. alphanum. ']'. } 		                       produce: [self pop:3; push:('<a href="',x asCamelCase,'">',x,'</a>')] ].	attributeWidget := [:s| self match: s sequence: {'['. humNoun. ']'.} 														  produce: [self pop:3; push:('<input type="text" name="',x,'"></input>')]].	textAreaWidget := [:s | self match: s sequence: { '['. humNoun. blank. number. ']'}		                           produce: [self pop:5; push:('<textarea rows="',d,'" name="',x,'"></textarea>')] ].		^markup.	! !!HumParser2 methodsFor: 'syntax' stamp: 'RichardAlexanderGreen 4/19/2014 09:58'!markupSyntaxWithOntology: anOntology	"Experimental BNF syntax"	| markup heading text emphasis bold widget alphanum italic underline headingPrefix matched  pageWidget attributeWidget x ordinaryText textAreaWidget number d blank list listPrefix humNoun p t viewName v paneWidget code ordinaryLine url u linkWidget entityAttributeWidget entity eName attribute aName checkboxWidget radioWidget comment category categoryWidget |		markup := [:s | self match: s oneOf: { heading. list. ordinaryLine.  }  ].	ordinaryLine := [:s | self match: s repeat: {  emphasis. widget. ordinaryText. comment. }].		heading := [:s | self match: s sequence:{ headingPrefix. text. } 		                  produce:[|n| n := p size asString. self push: ('<h',n,'>',t,'</h',n,'>')] ].	"x is the matched text -- see alphanum below"	"n is the size of the match -- see _prefix below"	headingPrefix := [ :s | p := self match: s oneOf: { '!!!!!!!!!!'. '!!!!!!!!'. '!!!!!!'.  '!!!!'. '!!'. } ]. 	  list := [:s | self match: s sequence:{listPrefix. text.} 	                 produce: [:z | |n| n := p size asString. 		                                  self pop:1; 		                                       push:('<item',n,'>&bull; ',t,'</item',n,'>')] ].	listPrefix := [ :s | p := (self match: s oneOf: { '-----'. '----'. '---'. '--'. '-'. } ) ].	"TODO: FIGURE OUT HOW TO DO AN ORDERED (NUMBERED) LIST."	text := [ :s | t := self match: s repeat: { ordinaryText. emphasis. } ].	ordinaryText := [:s | x := self text: s "This does a push." ].	comment := [:s | self match: s sequence: { '('. ordinaryText. ')' } produce: [:z| self pop: 1; push: z ] ].		alphanum := [ :s | x := self alphanumeric: s. ]. "Produces x."	number := [:s | d := self digits: s ].  "Produces d."	blank := [:s | self spaces: s ].		emphasis := [:s | self match: s oneOf: { bold. italic. underline. } ].	bold := [ :s | self match: s      sequence:{'*'. alphanum. '*'.} produce:[:z| self push:('<b>',x,'</b>')] ].		italic := [ :s | self match: s    sequence:{'~'. alphanum. '~'.} produce:[:z| self push:('<i>',x,'</i>')] ].		underline := [ :s | self match: s sequence:{'_'. alphanum. '_'.} produce:[:z| self push:('<u>',x,'</u>')] ].		widget := [:s | self match: s oneOf: { pageWidget. paneWidget. linkWidget. 																		   checkboxWidget. radioWidget. categoryWidget.																		   attributeWidget. textAreaWidget.  entityAttributeWidget. } ].	humNoun := [:s | x := (self noun: s ) ].	entity := [:s | eName := (self ontology: anOntology isEntity: s)].	attribute := [:s | aName := (self ontology: anOntology isAttribute: s)].	category := [:s | aName := (self ontology: anOntology isCategory: s)].	attributeWidget := [:s| self match: s sequence: {'['. humNoun. ']'.} 														  produce: [:z | self push:('<input type="text" name="',x,'" value=""/>')]].	entityAttributeWidget := [:s| self match: s sequence: {'['. entity. blank. attribute. ']'.} 									produce: [:z | self push:('<input type="text" name="',eName,':',aName,'" value=""/>')]].								"Note the name='...' value must be HTML, CSS, jQuery and HumBlackboard compatible "	textAreaWidget := [:s | self match: s sequence: { '['. humNoun. blank. number. ']'}		                           produce: [:z |self push:('<textarea rows="',d,'" name="',x,'"></textarea>')] ].  checkboxWidget := [:s | self checkbox: s 	                              produce: [:z | self pushIgnore: '<input type="checkbox" name="',z,'"/>']].  radioWidget := [:s | self radioButton: s 	                          produce: [:z | self pushIgnore: '<input type="radio" name="',z,'"/>']].	categoryWidget := [:s| self match: s sequence: {'['. category. ']'.} 													 produce: [:z | "Generate the choice tag code."																	 code := self generateChoicesFor: aName inOntology: anOntology.															     self push:('<select name="',aName,'">',code,'</select>')]].	pageWidget := [:s | self match: s sequence: {'[page:'. alphanum. ']'. } 		                       produce: [:z |self push:('<a href="',x asCamelCase,'">',x,'</a>')] ].  viewName := [:s | self ontology: anOntology isViewName: s  															produce: [:z | v := z.]].	paneWidget := [:s | self match: s sequence: {'[pane:'. viewName. ']'. }													produce: [:z | self pop: 1; push: ('<div name="',v trimBoth,'">'														                        ,(self ontology: anOntology produceView: v)														                        ,'</div>')]].	url := [:s | u := self url: s ].	linkWidget := [:s | self match: s sequence: {'[link:'. alphanum. '|'. url. ']' }													produce: [:z | self push:'<a href="',u,'">',x trimBoth,'</a>'] ].		^markup.! !!HumParser2 methodsFor: 'syntax' stamp: 'RichardAlexanderGreen 4/19/2014 11:07'!markupSyntaxWithOntology: anOntology blackBoard: aBlackBoard	"Experimental BNF syntax"	| markup heading text emphasis bold widget alphanum italic underline headingPrefix matched  pageWidget attributeWidget x ordinaryText textAreaWidget number d blank list listPrefix humNoun p t viewName v paneWidget code ordinaryLine url u linkWidget entityAttributeWidget entity eName attribute aName checkboxWidget radioWidget comment category categoryWidget |		markup := [:s | self match: s oneOf: { heading. list. ordinaryLine.  }  ].	ordinaryLine := [:s | self match: s repeat: {  emphasis. widget. ordinaryText. comment. }].		heading := [:s | self match: s sequence:{ headingPrefix. text. } 		                  produce:[|n| n := p size asString. self push: ('<h',n,'>',t,'</h',n,'>')] ].	"x is the matched text -- see alphanum below"	"n is the size of the match -- see _prefix below"	headingPrefix := [ :s | p := self match: s oneOf: { '!!!!!!!!!!'. '!!!!!!!!'. '!!!!!!'.  '!!!!'. '!!'. } ]. 	  list := [:s | self match: s sequence:{listPrefix. text.} 	                 produce: [:z | |n| n := p size asString. 		                                  self pop:1; 		                                       push:('<item',n,'>&bull; ',t,'</item',n,'>')] ].	listPrefix := [ :s | p := (self match: s oneOf: { '-----'. '----'. '---'. '--'. '-'. } ) ].	"TODO: FIGURE OUT HOW TO DO AN ORDERED (NUMBERED) LIST."	text := [ :s | t := self match: s repeat: { ordinaryText. emphasis. } ].	ordinaryText := [:s | x := self text: s "This does a push." ].	comment := [:s | self match: s sequence: { '('. ordinaryText. ')' } produce: [:z| self pop: 1; push: z ] ].		alphanum := [ :s | x := self alphanumeric: s. ]. "Produces x."	number := [:s | d := self digits: s ].  "Produces d."	blank := [:s | self spaces: s ].		emphasis := [:s | self match: s oneOf: { bold. italic. underline. } ].	bold := [ :s | self match: s      sequence:{'*'. alphanum. '*'.} produce:[:z| self push:('<b>',x,'</b>')] ].		italic := [ :s | self match: s    sequence:{'~'. alphanum. '~'.} produce:[:z| self push:('<i>',x,'</i>')] ].		underline := [ :s | self match: s sequence:{'_'. alphanum. '_'.} produce:[:z| self push:('<u>',x,'</u>')] ].		widget := [:s | self match: s oneOf: { pageWidget. paneWidget. linkWidget. 																		   checkboxWidget. radioWidget. categoryWidget.																		   attributeWidget. textAreaWidget.  entityAttributeWidget. } ].	"humNoun := [:s | x := (self noun: s ). self halt. ]."	entity := [:s | eName := (self ontology: anOntology isEntity: s)].	attribute := [:s | aName := (self ontology: anOntology isAttribute: s)].	category := [:s | aName := (self ontology: anOntology isCategory: s)].	attributeWidget := [:s| self match: s sequence: {'['. attribute. ']'.} 														  produce: [:z | "Get data from black board."															|data| data := aBlackBoard getEntityName: v attribute: aName.															self push:('<input type="text" name="',x,'" value="',data,'"/>')]].	entityAttributeWidget := [:s| self match: s sequence: {'['. entity. blank. attribute. ']'.} 									produce: [:z | self push:('<input type="text" name="',eName,':',aName,'" value=""/>')]].								"Note the name='...' value must be HTML, CSS, jQuery and HumBlackboard compatible "	textAreaWidget := [:s | self match: s sequence: { '['. attribute. blank. number. ']'}		                           produce: [:z |self push:('<textarea rows="',d,'" name="',x,'"></textarea>')] ].  checkboxWidget := [:s | self checkbox: s 	                              produce: [:z | self pushIgnore: '<input type="checkbox" name="',z,'"/>']].  radioWidget := [:s | self radioButton: s 	                          produce: [:z | self pushIgnore: '<input type="radio" name="',z,'"/>']].	categoryWidget := [:s| self match: s sequence: {'['. category. ']'.} 													 produce: [:z | "Generate the choice tag code."																	 code := self generateChoicesFor: aName inOntology: anOntology.															     self push:('<select name="',aName,'">',code,'</select>')]].	pageWidget := [:s | self match: s sequence: {'[page:'. alphanum. ']'. } 		                       produce: [:z |self push:('<a href="',x asCamelCase,'">',x,'</a>')] ].  viewName := [:s | self ontology: anOntology isViewName: s  															produce: [:z | v := z.]].	paneWidget := [:s | self match: s sequence: {'[pane:'. viewName. ']'. }													produce: [:z | self pop: 1; 														       push: ('<div name="',v trimBoth,'">'														             ,(self ontology: anOntology blackBoard: aBlackBoard produceView: v)														             ,'</div>')]].	url := [:s | u := self url: s ].	linkWidget := [:s | self match: s sequence: {'[link:'. alphanum. '|'. url. ']' }													produce: [:z | self push:'<a href="',u,'">',x trimBoth,'</a>'] ].		^markup.! !!HumParser2 methodsFor: 'syntax' stamp: 'RichardAlexanderGreen 4/16/2014 18:51'!url: source	"Does current source match a URL pattern?"	| alpha prefix server url result p x u nom parser |	parser := self class new.	alpha := [:s | parser alphanumeric: s ].	nom := [:s | parser match: s oneOf: { alpha. '-'. '_'.} ].	prefix := [:s | p := parser match: s oneOf: {'http://'. 'https://'. } ].	server := [:s | x := (parser match: s repeat: { nom. '.'. '/'. }) trimBoth ].	"Note: Calling trimBoth above might accidentally clean up a bad URL."	url := [:s | u := parser match: s sequence: { prefix. server. } produce: [:t | parser push:(p,x)] ].	result := parser match: source with: url.	^result.! !!HumParser2 methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/18/2014 20:33'!text: aString 	"Return that part of string that contains no mark-up."	| empty result |	empty := ''.	result := empty.		aString		do: [:ch |			"Terminate on any character that indicates emphasis or widget."			( '*~_[]()' includes: ch )				ifFalse: [ result := result, ch asString. ]				ifTrue: [^self push: result.].			].	^self push: result.! !!HumParser2 methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/16/2014 17:59'!match: source sequence: anArrayOfSyntaxThings produce: productionBlock	"Does current source match array? If so, run the production."	| result  empty |	self assert: ( productionBlock isKindOf: BlockClosure ).	empty := ''.	result := self match: source sequence: anArrayOfSyntaxThings.	(result = empty) ifFalse: [ productionBlock value: result ].	^result.! !!HumParser2 methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/16/2014 18:04'!match: aString with: syntaxThing 	"Does aString match with syntaxThing?"	| result empty |	empty := ''.	result := empty. "Null result is EMPTY string"		( syntaxThing isKindOf: String )		ifTrue: [			( (aString trimLeft) beginsWith: syntaxThing ) 				ifTrue: [  ^ syntaxThing ]				ifFalse: [ ^ empty ] 			].	( syntaxThing isKindOf: BlockClosure ) ifFalse: [Error signal: 'Should be block closure in this context'].	result := syntaxThing value: aString.	(result = empty) ifFalse: [ ].	^result.! !!HumParser2 methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/14/2014 15:24'!alphanumeric: aString 	"Match that part of the string that is alpha-numeric"	| empty result |	empty := ''.	result := empty.	aString		do: [:ch |			( ch isLetter or: [ (ch = $ ) or: [ch isDigit]  ])				ifTrue: [ result := result, ch asString. ]				ifFalse: [^result].			].	^result.! !!HumParser2 methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/18/2014 18:03'!checkbox: aSource produce: aProductionBlock	"Does the current source start with a check box widget?"	| empty s |	empty := ''.	(aSource size >= 3) ifFalse: [^empty].	s := aSource copyFrom: 1 to: 3.	('[#]' matches: s) 		ifTrue: [ 			| ch x |			ch := (s at: 2).			"A check box must contain a single letter. 			(Otherwise the name will not be HTML/CSS compatible)"			(ch isLetter) 				ifFalse: [Error signal: 'A checkbox must contain a single letter.'].			x := ch asString.			self push: (aProductionBlock value: x ). ^s]		ifFalse: [^empty].	! !!HumParser2 methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/14/2014 16:48'!digits: source 	"Match leading part of source that is digits"	| empty result |	empty := ''.	result := empty.	source		do: [:ch |			( ch isDigit)				ifTrue: [ result := result, ch asString. ]				ifFalse: [^result].			].	^result.	! !!HumParser2 methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/16/2014 13:14'!match: source oneOf: anArrayOfSyntaxThings	| result empty |	empty := ''.	result := empty.	anArrayOfSyntaxThings		do: [:syntaxThing |			result := self match: source with: syntaxThing.			(result = empty ) ifFalse: [^result].			].	^result.! !!HumParser2 methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/18/2014 20:34'!match: source repeat: anArrayOfSyntaxThings	"Does current source match array?"	| empty result nextSource  calc nextResult |	empty := ''.	result := empty. "By default if nothing matches front of source"	(source = empty) 		ifTrue: [Error signal: 'Why are you calling repeat with empty source?'].	( anArrayOfSyntaxThings isEmpty )		ifTrue: [Error signal: 'Why are you calling repeat with empty syntax?'].			anArrayOfSyntaxThings		do: [:syntaxThing|			result := self match: source with: syntaxThing.			(result = empty) 				ifFalse: ["There was a match at current front. Move along now."					nextSource := HumCalculator substringFrom: source after: result.					(nextSource = empty) 						ifTrue: ["Hurray, we matched the whole source!!"							^result].	         "Call myself recursively."					nextResult := self match: nextSource repeat: anArrayOfSyntaxThings.					result := result, nextResult.					(result size > 99 ) 						ifTrue: [Error signal: 'Result looks too long for current debug mode.'].					^result. 					].			].	"If we fall through we've matched nothing"	self assert: ( result = empty ).	^result.! !!HumParser2 methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/18/2014 17:58'!checkbox: aSource	"Does the current source start with a check box widget?"	| empty s |	empty := ''.	(aSource size >= 3) ifFalse: [^empty].	s := aSource copyFrom: 1 to: 3.	('[#]' matches: s) 		ifTrue: [^s]		ifFalse: [^empty].	! !!HumParser2 methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/14/2014 16:55'!spaces: source 	"Match leading part of source that is digits"	| empty result |	empty := ''.	result := empty.	source		do: [:ch |			( ch = Character space  or: [ ch = Character tab ] )				ifTrue: [ result := result, ch asString. ]				ifFalse: [^result].			].	^result.	! !!HumParser2 methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/18/2014 18:26'!radioButton: aSource produce: aProductionBlock	"Does the current source start with a radio button widget?"	| empty s |	empty := ''.	(aSource size >= 3) ifFalse: [^empty].	s := aSource copyFrom: 1 to: 3.	('(#)' matches: s) 		ifTrue: [ 			| ch x |			ch := (s at: 2).			"A radio button must contain a single letter. 			(Otherwise the name will not be HTML/CSS compatible)"			(ch isLetter) 				ifFalse: [Error signal: 'A radio button must contain a single letter.'].			x := ch asString.			self push: (aProductionBlock value: x ). ^s]		ifFalse: [^empty].	! !!HumParser2 methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/16/2014 10:50'!match: source sequence: anArrayOfSyntaxThings	"Does current source match array?"	| empty result nextSource nextArray syntaxThing calc nextResult |	empty := ''.	(source = empty) ifTrue: [^''].	( anArrayOfSyntaxThings isEmpty )		ifTrue: [^''].	syntaxThing := anArrayOfSyntaxThings at: 1.	result := self match: source with: syntaxThing.	(result = empty) ifTrue: [^result].	calc := HumCalculator new.	nextSource := (calc given: source extractAfter: result). 	nextArray := anArrayOfSyntaxThings copyFrom: 2 to: anArrayOfSyntaxThings size.  (nextSource = empty) ifTrue: [^result].  (nextArray isEmpty) ifTrue: [^result].  nextResult := self match: nextSource sequence: nextArray.	(nextResult = empty) ifTrue: [^empty].	result := result, nextResult.	result size > 99 ifTrue: [ Error signal: 'Result looks too long for current tests.'].	^result.! !!HumParser2 methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 4/16/2014 18:09'!match: source oneOf: anArrayOfSyntaxThings produce: productionBlock	"Does current source match array? If so, run the production."	| result  empty |	self assert: ( productionBlock isKindOf: BlockClosure ).	empty := ''.	result := self match: source oneOf: anArrayOfSyntaxThings.	(result = empty) ifFalse: [ productionBlock value: result ].	^result.! !!HumParser2 methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/16/2014 11:07'!push: aString 	(self ignoreNext) 		ifFalse: [(self stack) addLast: aString.]		ifTrue: [self ignoreNext: false.].	^aString! !!HumParser2 methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/16/2014 11:08'!pushIgnore: aString 	(self stack) addLast: aString.	self ignoreNext: true.	^aString! !!HumParser2 methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/16/2014 11:09'!ignoreNext	^ignoreNext ifNil: [ ignoreNext := false. ].! !!HumParser2 methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/16/2014 08:50'!top	| item |	item := (self stack) last.	^item.! !!HumParser2 methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/16/2014 07:50'!generatedCode	""	| code |	code := ''.	(self stack) 		do: [:item | code := code, item. ].	^code.! !!HumParser2 methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/16/2014 07:49'!stack	^stack ifNil: [ stack := OrderedCollection new.]! !!HumParser2 methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/16/2014 11:10'!ignoreNext: aBoolean 	ignoreNext := aBoolean! !!HumParser2 methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/16/2014 07:50'!pop: aSmallInteger 	(1 to: aSmallInteger)		do: [:i | (self stack) removeLast.]	! !!HumParser2 methodsFor: 'binding' stamp: 'RichardAlexanderGreen 4/18/2014 21:13'!generateChoicesFor: anAttributeName inOntology: aHumOntology 	"Generate HTML choice tags"	| html choices |	html := String new.	choices := aHumOntology categoriesOf: anAttributeName.	choices		do: [:choice |			html := html, String cr, '  <option name="',choice,'">',choice,'</option>'.			].	^html.! !!HumParser2 methodsFor: 'binding' stamp: 'RichardAlexanderGreen 4/18/2014 20:57'!ontology: aHumOntology isAttribute: aSource 	"Does the current source, upto some delimiter, match an ontology attribute name?"	| parser result empty  |	parser := self class new.	empty := ''.	result := empty.	"An attribute name must be alphanumeric"	result := parser noun: aSource.	(result = empty)		ifTrue: [ Error signal: 'Expected a noun, but found:"',aSource ].	(aHumOntology isAttribute: result)		ifTrue: [ "self push: result." ^result ]		ifFalse: [Error signal: result,' does not name an attribute.'].	^result.! !!HumParser2 methodsFor: 'binding' stamp: 'RichardAlexanderGreen 4/19/2014 10:43'!ontology: aHumOntology blackBoard: aBlackBoard produceView: aViewName 	"Produce the HTML for the given view frame."	| parser syntax frame lines code |	"Set up an indepent parser so that we don't interfere with caller."	parser := self class new.	frame := aHumOntology getViewFrame: aViewName.	lines := frame frameLines.	(lines isEmpty) ifTrue: [ Error signal: 'View is empty or name is wrong'].	syntax := parser markupSyntaxWithOntology: aHumOntology blackBoard: aBlackBoard.	"Pass the view name through -- is also default entity-name."	aBlackBoard defaultEntity: aViewName trimBoth.	lines		do: [:frameLine |			| s |			s := frameLine source.			parser push: (String cr,'<br/>&nbsp; ').			(s trimBoth = '') 				ifTrue: [ parser push: ('').]				ifFalse: [parser match: s with: syntax.].			].	^code := parser generatedCode .	! !!HumParser2 methodsFor: 'binding' stamp: 'RichardAlexanderGreen 4/18/2014 17:23'!noun: source 	"Match that part of the string that might name a Hum noun"	| empty result |	empty := ''.	result := empty.	source		do: [:ch |			( ch isLetter or: [ (ch = $- ) or: [ch isDigit]  ])				ifTrue: [ result := result, ch asString. ]				ifFalse: [					"A Hum noun must start with a letter."					((result at: 1) isLetter) 						ifFalse: [Error signal: 'A Hum noun must start with a letter'].					"A Hum noun must be more than a single letter."					(result size > 1) 						ifFalse: [Error signal: 'A Hum noun must be more than a single letter.'].					^result					].			].	^result.! !!HumParser2 methodsFor: 'binding' stamp: 'RichardAlexanderGreen 4/18/2014 21:00'!ontology: aHumOntology isCategory: aSource 	"Does the current source, upto some delimiter, match an ontology category name?"	| parser result empty  |	parser := self class new.	empty := ''.	result := empty.	"A category name must be alphanumeric"	result := parser noun: aSource.	(result = empty)		ifTrue: [ Error signal: 'Expected a noun, but found:"',aSource ].	(aHumOntology isCategory: result)		ifTrue: [ "self push: result." ^result ]		ifFalse: [^empty.].	Error signal: 'How did we get here?'.	^result.! !!HumParser2 methodsFor: 'binding' stamp: 'RichardAlexanderGreen 4/18/2014 20:57'!ontology: aHumOntology isEntity: aSource 	"Does the current source, upto some delimiter, match an ontology entity name?"	| parser result empty  |	parser := self class new.	empty := ''.	result := empty.	"An entity name must be alphanumeric"	result := parser noun: aSource.	(result = empty)		ifTrue: [ Error signal: 'Expected a noun, but found:"',aSource ].	(aHumOntology isEntity: result)		ifTrue: [ "self push: result." ^result ]		ifFalse: [Error signal: result,' does not name an entity.'].	^result.! !!HumParser2 methodsFor: 'binding' stamp: 'RichardAlexanderGreen 4/18/2014 16:39'!ontology: aHumOntology isViewName: aSource 	"Does the current source, upto some delimiter, match an ontology view name?"	| parser result empty alpha |	parser := self class new.	empty := ''.	result := empty.	"a view name must be alphanumeric"	alpha := [:s | parser alphanumeric: s ].	result := parser match: aSource repeat: { alpha. '-'.}.	(result = empty)		ifTrue: [ Error signal: 'Expected alphanumeric, but found:"',aSource ].	(aHumOntology isViewName: result)		ifTrue: [ self push: result. ^result ]		ifFalse: [Error signal: result,' does not name a view frame.'].	^result.! !!HumParser2 methodsFor: 'binding' stamp: 'RichardAlexanderGreen 4/18/2014 16:57'!ontology: aHumOntology isViewName: aSource produce: productionBlock 	"Does the current source, upto some delimiter, match an ontology view name? 	If so, produce the given production"	| result empty alpha |		empty := ''.	result := empty.	"a view name must be alphanumeric"	alpha := [:s | self alphanumeric: s ].	result := self match: aSource repeat: { alpha. '-'.}.	(result = empty)		ifTrue: [ Error signal: 'Expected alphanumeric, but found:"',aSource ].	(aHumOntology isViewName: result)		ifTrue: [ self push: (productionBlock value: result)]		ifFalse: [Error signal: result,' does not name a view frame.'].	^result.! !!HumParser2 methodsFor: 'binding' stamp: 'RichardAlexanderGreen 4/17/2014 23:54'!ontology: aHumOntology produceView: aViewName 	"Produce the HTML for the given view frame."	| parser syntax frame lines code |	"Set up an indepent parser so that we don't interfere with caller."	parser := self class new.	frame := aHumOntology getViewFrame: aViewName.	lines := frame frameLines.	(lines isEmpty) ifTrue: [ Error signal: 'View is empty or name is wrong'].	syntax := parser markupSyntaxWithOntology: aHumOntology.	lines		do: [:frameLine |			| s |			s := frameLine source.			parser push: (String cr,'<br/>&nbsp; ').			(s trimBoth = '') 				ifTrue: [ parser push: ('').]				ifFalse: [parser match: s with: syntax.].			].	^code := parser generatedCode .	! !Object subclass: #HumStatement	instanceVariableNames: 'source errors nounValues jobTicket role translation isSatisfied'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumStatement commentStamp: 'RichardAlexanderGreen 9/28/2012 13:40' prior: 0!Some types of frame lines will contain a statement as part or all of their content.For example, an instruction line might contain a role prefix, a statement, a comment, and a annotation.This statement class is meant to provide a set of services for interpreting and analyzing statements.A statement is simply a sequence of tokens. Some of those tokens must be nouns. Otherwise the statement has no data to give it meaning at run-time  and there is no way for the compiler to check for data continuity.Instance Variables:	source	<String>	errors	<Set>	nounValues	<Dictionary>	jobTicket	<ProtoObject>!!HumStatement methodsFor: 'run-time' stamp: 'RichardAlexanderGreen 6/29/2015 10:22'!noun: aNoun value: aValueObject 	"Noun values are set at run-time just prior to executing the statement.	Record the name value pair for this noun.	(The noun is assumed to be one that appears in the statement source.)		Comment: The noun value is also on the actor`s blackboard. So this might be redundant.	On the other hand, in any other run-time, the noun would be populated via the calling mechanism. 	So this is a reasonable simulation.		TODO: Decide how to handle a noun that is an entity. (What does the valueObject argument look like?)	It could be an identifier. The local blackboard could supply attribute values as needed - with WorldBase as collaborator.		Comment: If an entity is updated after the original job ticket is sent, 	  it is not obvious whether we should use the old values or the new.	In general, I think that the new values would be the correct choice.	However, this may be very situation dependent.		We could move the question to the coder by having exposing 'Blackboard: Synchronize entity.' (API).	I don't particularly like that solution because the philosophy of Hum is that persistence mechanisms should be transparent.	However, it does solve the problem.	"	self assert: ( aNoun isKindOf: String ).	self assert: ( aValueObject notNil ).	( self nounValues ) at: aNoun put: aValueObject.! !!HumStatement methodsFor: 'run-time' stamp: 'RichardAlexanderGreen 4/20/2015 09:34'!isSatisfied: aBoolean 	self assert: (aBoolean isKindOf: Boolean ).	isSatisfied := aBoolean.! !!HumStatement methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 3/25/2015 11:24'!stripRole	"Source should not contain a role prefix in this context.	 Signal an error if caller has sent source with role prefix."	| tokens quote punctuation whitespace |	whitespace := ' 			'.	whitespace := Character separators.	quote := $' asString.	punctuation := '~!!@#$%^&*()_+`={}|[]\:";<>?,./', quote.	"Note: Preserve uppercase in tokens so that first word of a sentence is capitalized."	tokens := source  findTokens: ( punctuation, whitespace ) keep: punctuation.	((tokens size > 2) and: [(tokens at: 2) = ':'])			ifTrue: [ "Found a role label in the source"				Error signal: 'Found role label in source.'.				"role := tokens at: 1.				source := HumCalculator given: source extractAfter: ':'" ].! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/29/2013 07:16'!isConditional	(source beginsWith: 'For ' ) ifTrue: [ ^true ].	( source beginsWith: 'If ')   ifTrue: [ ^true ].	( source beginsWith: 'ElseIf ')   ifTrue: [ ^true ].	( source beginsWith: 'Else:') ifTrue: [ ^true ].	^false.	! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/29/2015 09:54'!translation	"How might the statement be translated into another programming language?"	^translation! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2011 15:03'!source	^ source! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/30/2011 17:31'!asString	^ self source asString.! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/25/2015 11:21'!source: aSource      "Set and check the source string."	|  lastCharacter |		"Remember my source string."	source := '*** SOURCE IS NOT VALID ***'.	( aSource isKindOf:  String )       ifTrue: [ source := aSource trimBoth.].	( aSource isKindOf:  HumStatement ) ifTrue: [ source := aSource source.].	( aSource isKindOf: HumConditionLine ) ifTrue: [ source := aSource source.].		self assert:	( source = '*** SOURCE IS NOT VALID ***' ) not.	source := HumProgrammersAssistant removeCommentFromSource: source.	"Reset errors."	errors := Set new. 		"self stripLeader." "Leader is a UI artifact. Not really part of the source."	source := HumProgrammersAssistant removeLeaderFromSource: source.	self stripRole. "Check: Source should not contain a role prefix in this context."		(source sameAs: '') 	   ifTrue: ["Statement may be empty after comment and leader is removed." ^self].	"Syntax check: A statement ends with a period or a colon."	lastCharacter :=  ( source at: ( source size )). 	( lastCharacter = $. ) ifTrue: [^self].	( lastCharacter = $: ) ifTrue: [^self].	"Last character was not a period or colon."	 self syntaxError: 'Statement must end with a period or colon.'.	! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/28/2011 09:13'!errors	^errors ifNil: [ errors := Set new.].! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/29/2015 09:53'!translation: aString 	"How might the statement be translated into another programming language?"	translation := aString! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/5/2014 10:40'!nounValues	"Noun values are set at run-time. 	Typically, they are found on a blackboard and transcribed as needed.	Noun values are transcribed to action-call from Agent`s blackboard.	Noun values are transcribed to goal-call from Dialog blackboard.	Noun values are transcribed to view-call from Dialog blackboard.	Noun values are transcribed to view-return message from Scribe blackboard.	"	^ nounValues ifNil: [ nounValues := Dictionary new.].! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/11/2012 19:36'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		"nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);"		nextPutAll: title;		nextPutAll: '( ', self source, ' )';		nextPutAll: String cr.! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2013 08:26'!role	^role ifNil: [ Error signal: 'role was not set in HumStatement']! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/7/2016 09:23'!tokens	"Return the tokens in the statement as an array of strings."	|  tokens |	tokens := HumOntology tokensInString: (self source).	"WARNING: Hum has a quirk: Accent (`) is used as apostrophe. 	                    Avoid complication distinguishing uses of single-quote."	^tokens.! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2014 13:51'!role: aString	"What role is meant to execute this statement?	If this is an action statement, 	the Dispatcher will assign execution 	to an available actor that claims the role at run-time.	"	role := aString.! !!HumStatement methodsFor: 'translate' stamp: 'RichardAlexanderGreen 3/1/2014 09:17'!asCamelCase 	"Convert this statement to camelCase."	| tokens code   first |	code := ''.	first := true.	tokens := (self source) findTokens: ' ,.-'.  "Do not inlude articles in the camel case."	(tokens reject: [:token | #( 'a' 'an' 'the' ) includes: (token asLowercase) ])		do: [ :token |				first ifTrue: [ code := code, token asLowercase .						            first := false.]					   ifFalse: [ code := code, (token capitalized) ].			].		^code! !!HumStatement methodsFor: 'translate' stamp: 'RichardAlexanderGreen 3/24/2015 08:39'!asCamelCaseWithOntology: aHumOntology 	"Convert this statement to camelCase."	| tokens code   first |		code := ''.	first := true.	tokens := (self source) findTokens: ' ,.-'.	(tokens reject: [:token | #('a' 'an' 'the') includes: token ] )		do: [ :token |				first ifTrue: [ code := code, token asLowercase .						first := false.]					ifFalse: [ code := code, (token capitalized) ].			].	"TODO: Deal with polymorphism by looking up the proper definition.	Can borrow algorithm from prior version of SimpleEnglish ?	However, by removing nouns from the camelCase, I could just let Java do the work.	BAD IDEA: Depending on Java would make the semantics target-language-dependent.	"	^code! !!HumStatement methodsFor: 'translate' stamp: 'RichardAlexanderGreen 1/12/2015 09:20'!onMatch: aPatternString do: aBlockClosure 	"When my source matches pattern, execute the block with matching arguments.	 Use this to parse lines, interpret lines, generate code."	HumCalculator given: (self source) onMatch: aPatternString do: aBlockClosure.! !!HumStatement methodsFor: 'translate' stamp: 'RichardAlexanderGreen 3/3/2014 10:39'!delegateToTranslator	Error signal: 'This statement function should be delegated to Ontology Translator (HumOntologyTranslator).'! !!HumStatement methodsFor: 'translate' stamp: 'RichardAlexanderGreen 4/9/2012 12:46'!nounAsCamelCase: aString 	"Delegate to ontology class"	^ HumOntology nounAsCamelCase: aString.! !!HumStatement methodsFor: 'logging' stamp: 'RichardAlexanderGreen 1/16/2012 14:45'!syntaxError: anErrorMessage 	"Error signal: anErrorMessage."	(self errors) add: anErrorMessage.! !!HumStatement methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 1/23/2012 13:04'!hash 	"This HACK (which may be a bad idea) makes HumStatement hash the same as a matching string.	It makes set lookup work.	But maybe it makes some coding error too forgiven.	"	^ ( source hash ).! !!HumStatement methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 4/18/2015 09:41'!matchesCandidateStatement: aCandidate inOntology: aHumOntology	"Does the candidate match me? (Candidate nouns might be subtypes of my nouns.)"	| statement candidateTokens myTokens calc |	calc := HumCalculator new.	calc cases;		when: [aCandidate isKindOf: HumStatement] then: [statement := aCandidate ];		when: [aCandidate isKindOf: String ] then: [ statement := HumStatement from: aCandidate. ];		otherwise: [ Error signal: 'expecting a statement type'].	(self source sameAs: statement source ) ifTrue: [^true]. "shortcut"	"Get tokens minus articles."	candidateTokens := ( statement tokens ) reject: [ :token | #('a' 'an' 'the') includes: token ] .	myTokens := ( self tokens ) reject: [ :token | #('a' 'an' 'the') includes: token ] .	"TODO: Parse allowing for quoted strings."	( myTokens size = candidateTokens size ) ifFalse: [ ^false ].	"Is my noun a supertype of the argument`s noun?"	( 1 to: (myTokens size) )		do: [ :x |			| myToken candidateToken |			myToken := myTokens at: x.			candidateToken := candidateTokens at: x.			( myToken sameAs: candidateToken )				ifTrue: ["continue"]				ifFalse: [ "Is myToken a noun? If so, see if my token is a supertype"					( aHumOntology yesNoun: candidateToken isAKindOf: myToken  )						ifTrue: ["continue"]						ifFalse: [ ^false ].						"TODO: A series of nouns (example: entity attribute attribute) matches a single noun. "						].			].	^ true.		! !!HumStatement methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 3/24/2015 10:45'!matchesTemplateStatement: aStatementTemplate inOntology: aHumOntology 	"Do I match the given template? (My nouns may be subtypes of template nouns)"	| templateTokens myTokens |	self assert: ( aStatementTemplate isKindOf: HumStatement ).	"First try a shortcut."	( self source sameAs: aStatementTemplate source) ifTrue: [^true].	"Get tokens minus articles."	myTokens := ( self tokens ) difference: #('a' 'an' 'the').	templateTokens := ( aStatementTemplate tokens ) difference: #('a' 'an' 'the').	( templateTokens size <= myTokens size ) ifFalse: [ ^false ].	"TODO: Parse statements containing quoted strings."		"Is each template noun a supertype of my noun?"	( 1 to: (templateTokens size) )		do: [ :x |			| templateToken myToken |			templateToken := templateTokens at: x.			myToken := myTokens at: x.			( templateToken sameAs: myToken )				ifTrue: ["continue"]				ifFalse: [ "Is myToken a noun? If so, see if my token is a supertype"					( aHumOntology yesNoun: myToken isAKindOf: templateToken  )						ifTrue: ["continue"]						ifFalse: [ ^false ].						"TODO: A series of nouns (example: entity attribute attribute) matches a single noun. "						].			].	^ true.		! !!HumStatement methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 12/29/2011 15:04'!= aStatement 	( aStatement isKindOf: String )  ifTrue: [ ^source sameAs: aStatement ].	( aStatement isKindOf: HumStatement ) ifTrue: [ ^ source sameAs: aStatement source ].	^self halt.! !!HumStatement methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 12/27/2015 16:02'!sameAs: aHumStatement 	"Return true if receiver is semantically equivalent to (argument) aHumStatement."	(aHumStatement isKindOf: String)		ifTrue: [^ (self source) sameAs: aHumStatement ].	(aHumStatement isKindOf: HumStatement)		ifTrue: [^ (self source) sameAs: (aHumStatement source) ].	"TODO: Allow variations in use of 'a' 'an' 'the'.   "		"TODO: Allow a cascade of nouns. (example: entity attribute-entity attribute-entity attribute)"	Error signal: 'argument not of expected type'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumStatement class	instanceVariableNames: ''!!HumStatement class methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 1/2/2012 17:22'!isKeyWord: aString	| keyWordList answer |	keyWordList := #( 'if' 'else' 'for' 'each' 'in' 'giving' ).	answer := ( keyWordList includes: aString ).	^answer.! !!HumStatement class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 12/30/2011 14:12'!from: aSource	| newStatement |	newStatement := self basicNew.	newStatement source: aSource.	^newStatement.! !!HumStatement class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 1/16/2012 14:37'!source: aSource	| |	^ self from: aSource.! !HumFrameLine subclass: #HumTranslationLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumTranslationLine commentStamp: 'RichardAlexanderGreen 9/28/2012 13:33' prior: 0!A translation line may occur between triple-brace lines in a role-action frame.It specifies how an action statement (generally an internal "To:" statement) may be implemented in some target language.Generally the implementation will be a method declaration where the role is assumed to be implemented as a class.Here is an example:____Role: Invoicing.To: Extend the order's unit prices.. As Smalltalk:{{{extendOrderLinePricesFor: anOrder	"Multiply the unit price times the quantity to fill in the extended price. 	Then apply any quantity discounts."	( anOrder orderLines )		do: [ :orderLine |			orderLine extendedPrice: (orderLine quantity) * (orderLine price).			orderLine applyQuantityDiscountIfAny.			"The quantity discount rule depends on the the catalogNumber and quantity"			 ].}}}___In this case, the translator will assemble the given translation lines with other translation lines to produce a Smalltalk class definition.Similar results might be obtained for translation to Java or Python or Javascript or Objective-C.Note: The code above could have been written entirely in Hum without the need to use an external framework.  This example was used because it does not require explanation of the context.The general form is:___To: <action statement>.. As <language>:{{{   <several lines in the target procedural language>}}}___Note: "To: . . . " could also be "Action: . . . ". (That is allowed but is probably bad form.)!HumFrameLine subclass: #HumVignettePatternLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumVignettePatternLine commentStamp: 'RichardAlexanderGreen 8/3/2016 10:21' prior: 0!A vignette pattern may have multiple lines.Lines are matched in the order given.So higher lines will match before lower ones.A pattern starts with a label: 'U:'/'User:'/'Client:'/ or some role-name.When a pattern is matched, the response lines are then interpreted.!!HumVignettePatternLine methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/23/2015 09:34'!checkSyntaxWithOntology: aHumOntology	"TODO: Look for [noun]. Is the noun defined in the ontology?"	^ OrderedCollection new.! !HumFrameLine subclass: #HumVignetteResponseLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumVignetteResponseLine commentStamp: 'RichardAlexanderGreen 8/3/2016 10:26' prior: 0!A vignette response line is either a markup line or an instruction line.If an instruction line does not name a specific role,the DialogAgent role is assumed.(See BaseOntology.txt for a description of DialogAgent actions.)See also: HumFrame4Vignette class comment.!!HumVignetteResponseLine methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/23/2015 09:33'!checkSyntaxWithOntology: aHumOntology	"TODO: Look for [noun]. Is the noun defined in the ontology?"	^ OrderedCollection new.! !