Object subclass: #HumOntologyTranslator	instanceVariableNames: 'methodsForClasses prologues ontology contextEntity html'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumOntologyTranslator commentStamp: 'RichardAlexanderGreen 5/13/2014 09:04' prior: 0!This class provides tools used to generate code from Hum frames.Strategies vary a little depending on the target language and framework.This is crude version - oriented toward Smalltalk and other object-oriented frameworks.	- Roles become classes.	- Entity-Attribute relations become class accessors. { but in what class ??? }	- Noun datatypes are one of: ( Entity Category Enumeration String Measure TimeStamp ).	- Dialogs become method calls with blocks.	- Views are translated to some Web Server framework { Seaside when target is Smalltalk }.	I am thinking that something like Erlang or Scala might be the best target frameworkbecause those frameworks support "actors", distribution, and parallel processingin relatively natural ways.In any case, the original Hum code will be included as comments in the generated code.This can assure that translations to less readable languages (Javascript, Erlang)will still be maintainable in those languages (not recommended)should the user-programmer decide to go that way.!!HumOntologyTranslator methodsFor: 'translate to HTML' stamp: 'RichardAlexanderGreen 5/20/2014 10:25'!countLeading: aCharacter inString: line	"Count leading"	| n ch |	( aCharacter isKindOf: Character ) ifTrue: [ ch := aCharacter ].	( aCharacter isKindOf: String ) ifTrue: [ ch := aCharacter at: 1 ].	self assert: ( ch isKindOf: Character ).	self assert: ( (line at: 1) = ch ).	n := 1.	[ (line at: n) = ch ] whileTrue: [n := n+1].  ^n-1.! !!HumOntologyTranslator methodsFor: 'translate to HTML' stamp: 'RichardAlexanderGreen 5/13/2014 09:11'!genHTML: generatedCodeString	"Append generated code"	| |		"If code begins with a tag, insert cr to improve readability."	( generatedCodeString beginsWith: '<' )	  ifTrue: [(self html) nextPutAll: (String cr, generatedCodeString).]	  ifFalse: ["Otherwise, it is caller`s responsibility to prepend cr <br/>"		         (self html) nextPutAll: generatedCodeString.		         ].	! !!HumOntologyTranslator methodsFor: 'translate to HTML' stamp: 'RichardAlexanderGreen 5/20/2014 10:31'!generateHTMLforMarkupLines: aListOfFrameLines blackboard: aBlackboard	"Build HTML for the given list of frame-lines"	|  remainder calc source translator2 |	calc := HumCalculator new.	translator2 := HumOntologyTranslator new.	aListOfFrameLines		do: [:frameLine | 			source := frameLine source.			calc cases; "Start case block"			   when: [source = ''] 			   then:["blank line indicates paragraph break"					     self genHTML: '<br/>'					    ];				 when: [source beginsWith: '!!']				 then: [ "Generate heading"							| level n |							level := self countLeading: '!!' inString: source.							remainder := source copyFrom: level+1 to: source size.							n := level asString.							self genHTML: '<h',n,'>'							            , ([translator2 generateHTMLforMarkupString: remainder blackboard: aBlackboard.								              translator2 html contents.] value)							            , '</h',n,'>'.							];				 when: [source beginsWith: '-']				 then: [ "Generate list item. Let CSS do the indent."							| level n |							level := self countLeading: '-' inString: source.							remainder := source copyFrom: level+1 to: source size.							n := level asString.							self genHTML: '<item',n,'> &bull; '							            , ([translator2 generateHTMLforMarkupString: remainder blackboard: aBlackboard.								              translator2 html contents.] value)							            , '</item',n,'>'.							];				when: [ source beginsWith: '|']				then: [ | columns |					      columns := source findTokens: '|'.					      self genHTML: '<tr>'.							  columns do: [:column |								  translator2 := HumOntologyTranslator ontology: (self ontology).								  translator2 generateHTMLforMarkupString: column blackboard: aBlackboard.								  self genHTML: '<td>',(translator2 html contents),'</td>'.								  ].					      self genHTML: '</tr>'.					    ];						otherwise: [					remainder := self generateHTMLforMarkupString: source blackboard: aBlackboard. 					"There should be no remainder"					self assert: (remainder = '').					].			].    ^self html contents.! !!HumOntologyTranslator methodsFor: 'translate to HTML' stamp: 'RichardAlexanderGreen 5/20/2014 10:12'!generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard	"Build output until we see a substring matching aStopString."	"When we need to recurse, 	  we pass the remaining lines or create another list of lines.	"	|  remainder markupStream uptoMark |	remainder := aMarkupString. 		"Emphasis patterns.  (bold, italic, underline, superscript)"	remainder := self when: remainder matchesPattern: '*1*' produce: [:x | self genHTML: '<b>',x,'</b>'].	remainder := self when: remainder matchesPattern: '~1~' produce: [:x | self genHTML: '<i>',x,'</i>'].	remainder := self when: remainder matchesPattern: '_1_' produce: [:x | self genHTML: '<u>',x,'</u>'].	remainder := self when: remainder matchesPattern: '^1^' produce: [:x | self genHTML: '<sup>',x,'</sup>'].	"Hypertext"	remainder := self when: remainder matchesPattern: '[link:1|2]' 	               produce: [:x :url |  self genHTML: '<a href="',url,'">',x trimBoth,'</a>'].		remainder := self when: remainder matchesPattern: '[page:1]' 								produce: [:x | 									| filename |									filename := (x asCamelCase),'.html'.   "Should work in most file systems"									self genHTML: '<a href="',filename,'">',x,'</a>'].		"Delegate to another pane."	remainder := self when: remainder matchesPattern: '[pane:1]' 								produce: [:x | 									(ontology isViewName: x) 										ifFalse: [ self humParserError: 'Expected view name but found: ', x ]										ifTrue: [ | frame frameLines |											frame := ontology fetchFrameByName: x.											frameLines := frame frameLines.											self generateHTMLforMarkupLines: frameLines blackboard: aBlackBoard.											]. 										].	"Button"	"Treat button as a special case?"	remainder := self when: remainder matchesPattern: '[[1]]' 	               produce: [ :x | 		                       | buttonLabel buttonType |		                       buttonLabel := x trimBoth.		                       buttonType := buttonLabel asLowercase.                           ( #('submit' 'reset' ) includes: (buttonType) ) ifFalse: [buttonType := 'button'].				                       self genHTML: '<button name="',buttonLabel,'" type="',buttonType,'">',buttonLabel,'</button>'.		                      ].		"Radio Button or Comment"	remainder := self when: remainder matchesPattern: '(1)'		               produce: [:x | 									"Is a radio button intended?"									(x size = 1 ) 									   ifTrue: [ self genHTML: '<input name="',x,'" type="radio"/>']									  ifFalse: [ "Parse the interior of the comment -- It might contain links, etc."										  self genHTML: (self generateHTMLforMarkupString: x blackboard: aBlackBoard).											  ]									].		"Input widgets"	remainder := self when: remainder matchesPattern: '[1`s 2]'  "[entity`s attribute]"								produce: [:entity :attribute | 									( ontology isAttribute: attribute )										ifFalse: [ self humParserError: 'Expected attribute name but found: ', attribute ]										ifTrue: [| value |											value := aBlackBoard getEntityName: entity attribute: attribute.											self genHTML: '<input type="text" name="', entity,':',attribute, '" value="',value,'"/>'.											"TODO: Adapt input to datatype." 											].									].		remainder := self when: remainder matchesPattern: '[1 2]'   "text widget"								produce: [:textAttribute :rows | 									( ontology isAttribute: textAttribute )										ifFalse: [ self humParserError: 'Expected attribute name but found: ', textAttribute ]										ifTrue: [| value |											value := aBlackBoard getEntityName: contextEntity attribute: textAttribute.											self genHTML: '<textarea type="text" name="', textAttribute,'" rows="',rows,'">'											           ,value,'</textarea>'. 											].									].									remainder := self when: remainder matchesPattern: '[1]'    "attribute widget" 								produce: [:attribute | 									"Catch checkbox case"									( attribute size = 1 )										ifTrue:["Generate checkbox widget."											self genHTML: '<input type="checkbox" name="', attribute,'"/>'.											]                     ifFalse: ["Generate attribute input widget."	                     ( ontology isAttribute: attribute )										    ifFalse: [ self humParserError: 'Expected attribute name but found: ', attribute ]										    ifTrue: [| value |									     		value := aBlackBoard getEntityName: contextEntity attribute: attribute.											    self genHTML: '<input type="text" name="', attribute, '" value="',value,'"/>'.											    "TODO: Adapt input to datatype." 											    ].                       ].									].			"table row -- Should be implemented elsewhere."	self assert: ( remainder beginsWith: '|' ) not.  "Just ordinary text."  ( (remainder findTokens: '*~_^[]|()' keep: '*~_^[]|()') size <= 1 )		ifTrue: [ "Consume remainder"			self genHTML: remainder.			^remainder := ''.						].  "Recurse"	self assert: (remainder beginsWith: ']' ) not.	^self generateHTMLforMarkupString: remainder blackboard: aBlackBoard.	! !!HumOntologyTranslator methodsFor: 'translate to HTML' stamp: 'RichardAlexanderGreen 5/19/2014 06:40'!html	^html ifNil: [html := ReadWriteStream on: ''.]! !!HumOntologyTranslator methodsFor: 'translate to HTML' stamp: 'RichardAlexanderGreen 5/20/2014 10:03'!when: aSource matchesPattern: aPattern produce: aBlock	| patternStream sourceStream arguments remainder sourceCharacter patternCharacter s uptoMark markupCharacters |  	(aSource = '') ifTrue: [ ^aSource ].	"Convertstrings to streams."	patternStream := ReadStream on: aPattern.	sourceStream := ReadStream on: aSource.		"Does source begin with markup?"	markupCharacters := '~^*_[]()|'.	uptoMark := String new.	[ sourceStream atEnd or: [ markupCharacters includes: (sourceStream peek)] ]		whileFalse:["Output ordinary text until a markup character is seen"			uptoMark := uptoMark, (sourceStream next asString). 			].	( uptoMark size > 0 ) 	   ifTrue: [ self genHTML: uptoMark.		   remainder := HumCalculator substringFrom: aSource after: uptoMark.  		   ^remainder.		   ].  "The source must begin with a markup character."	self assert: ( markupCharacters includes: (sourceStream peek) ).		"If the pattern does not match, 	  return the source 	  so that the caller can try another pattern."	(( patternStream peek ) = ( sourceStream peek )) ifFalse: [^aSource].  "If there is a match, build the argument list."	arguments := OrderedCollection new.	[ patternStream atEnd or: [ sourceStream atEnd ]]		whileFalse: [ 				patternCharacter := patternStream next.				sourceCharacter := sourceStream next.				( patternCharacter isDigit )				  ifFalse: ["Compare pattern character to source character."					  "Does the pattern match the source? 					   If not, return the source so that caller can try another pattern."					  ( patternCharacter = sourceCharacter ) ifFalse: [ ^aSource ].					  ]					ifTrue: ["Accumulate upto next delimiter or end"						| nextPatternCharacter |						nextPatternCharacter := patternStream next.						s := String new.						[ sourceStream atEnd or: [ sourceCharacter == nextPatternCharacter ]] 								whileFalse: [								(markupCharacters includes: sourceCharacter) ifTrue: [^aSource].								s := s, sourceCharacter asString.								sourceCharacter := sourceStream next.								].						arguments add: s.						].			].	"If we matched, run the production block"	( patternStream atEnd and: [arguments notEmpty] ) 		ifTrue: [ aBlock valueWithArguments: arguments ]		ifFalse: [^aSource].	"Return the remainder of the source."	remainder := String new.	[ sourceStream atEnd ] 		whileFalse: [ remainder := remainder, (sourceStream next asString). ].  ^remainder.! !!HumOntologyTranslator methodsFor: 'Generate OO Modules' stamp: 'RichardAlexanderGreen 3/15/2013 17:04'!attachAction: aMethodName toActorClass: aClassName fromSource: aSource	"Attach the given method source 		to the given class 			under the given method name."	| methods |	methods := self getMethodsForClass: aClassName.	self assert: (methods isKindOf: Dictionary ).	methods at: aMethodName put: aSource.	  ! !!HumOntologyTranslator methodsFor: 'Generate OO Modules' stamp: 'RichardAlexanderGreen 3/15/2013 17:14'!attachPrologToActorClass: aClassName fromSource: aSourceString 	"Attach the given prologue source code to the named class."	| |	"Note: There can be only one prologue for each actor class"	( self prologues ) at: aClassName put: aSourceString.! !!HumOntologyTranslator methodsFor: 'Generate OO Modules' stamp: 'RichardAlexanderGreen 2/27/2013 15:01'!getMethodsForClass: aClassName	"Get the methods colletion (a Dictionary) for the given Class"	| methods |	methods := ( self methodsForClasses ) at: aClassName ifAbsent: [ nil ].	methods 		ifNil: [ methods := Dictionary new. 						( self methodsForClasses ) at: aClassName put: methods.						].	^methods.! !!HumOntologyTranslator methodsFor: 'Generate OO Modules' stamp: 'RichardAlexanderGreen 2/27/2013 15:02'!methodsForClasses	^ methodsForClasses ifNil: [ methodsForClasses := Dictionary new ].! !!HumOntologyTranslator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/20/2014 09:41'!contextEntity: aString 	contextEntity := aString! !!HumOntologyTranslator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/19/2014 16:45'!ontology	^ ontology ifNil: [ontology := HumOntology new.]! !!HumOntologyTranslator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/12/2014 12:38'!ontology: aHumOntology 	ontology := aHumOntology.! !!HumOntologyTranslator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/15/2013 17:15'!prologues	^ prologues ifNil: [ prologues := Dictionary new ].! !!HumOntologyTranslator methodsFor: 'translate to Erlang' stamp: 'RichardAlexanderGreen 10/24/2013 16:16'!translateActionCallToErlang: aString	"Translate a Hum Action call into an Erlang OTP call."	| erlang colon roleAtom statementString |	self assert: (aString isKindOf: String).	colon := $: asString.	roleAtom := (HumCalculator substringFrom: aString before: colon) asLowercase.	statementString := (HumCalculator substringFrom: aString after: colon) trimBoth.	"TODO: HumStatement knows how to parse better than this. It knows about comments and annotations."		erlang := '?CALL({',roleAtom,',"',statementString,'",NounValues}).'.	^erlang	! !!HumOntologyTranslator methodsFor: 'translate to Erlang' stamp: 'RichardAlexanderGreen 10/24/2013 15:39'!translateActionHeaderToErlang: aString 	"Then: The do header looks like 'do( { action-statement, noun-values } )' "	| erlang quote statementString |	quote := $' asString.	(aString beginsWith: 'Action:')		ifTrue: [ statementString := (HumCalculator substringFrom: aString after: 'Action:') trimBoth. ]		ifFalse: [ statementString := aString ].	"TODO: Fix case where statementString contains single quote/s."	erlang := 'do( { "',statementString,'", NounValues } ) ->'.	^ erlang.! !!HumOntologyTranslator methodsFor: 'translate to Erlang' stamp: 'RichardAlexanderGreen 10/24/2013 16:26'!translateSelfCallToErlang: aString	"Translate a Hum Self call into an Erlang self call."	| erlang statementString trimString |	self assert: (aString isKindOf: String).	self assert: ( '*:*' matches: aString ) not.	statementString := aString trimBoth.	[ statementString beginsWith: '. '] 		whileTrue: [ statementString := statementString copyFrom: 3 to: (statementString size) ].	"TODO: HumStatement knows how to parse better than this. It knows about comments and annotations."		erlang := 'do({self,"',statementString,'",NounValues}).'.	^erlang	! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/3/2014 11:05'!generateSmalltalk	"This is crude version.	Futures:	- Roles become classes.	- Entity-Attribute relations become class accessors.	- Noun types are one of: ( Entity Category Enumeration String Measure TimeStamp ).	- Dialogs are become method calls with blocks.	- Views are still interpreted.	"	| code |	code := ''.	ontology framesByName		keysAndValuesDo: [  :frameName :frame |			| frameCode |			frameCode := self generateSmalltalkForFrame: frame.			code := code, frameCode.			].	^ code.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/3/2014 11:24'!generateSmalltalkActionFor: aHumFrame4Action 	"Translate frame to Smalltalk using the nouns given in the ontology."	| selectorCode frameCode priorIndent cr tab indentation |	cr := String cr.	tab := String tab.	selectorCode := self generateSmalltalkForStatement: aHumFrame4Action actionStatement.	"Translate the lines. Adding block ends when indent is reduced."	frameCode := ''.	priorIndent := 0.	aHumFrame4Action frameLines		do: [ :line |			| lineCode |			(line indent < priorIndent ) 				ifTrue: [ "Insert a block-end bracket with appropriate indent."					indentation := (1 to: priorIndent) inject: '' into: [:s :next | s, tab ]. 					frameCode := frameCode, indentation, '].', cr.				].			lineCode := self generateSmalltalkForFrameLine: line.			frameCode := frameCode, lineCode,  cr.			priorIndent := line indent.			].	^ selectorCode, String cr, frameCode .! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/3/2014 10:57'!generateSmalltalkForConditional: aHumStatement 	| code source|	code := ''.	source := aHumStatement source.	(source beginsWith: 'For ' )		ifTrue: [ code := self generateSmalltalkIterationFor: aHumStatement ].	( source beginsWith: 'If ')		ifTrue: [ code := self generateSmalltalkIfFor: aHumStatement ].	( source beginsWith: 'Else:')		ifTrue: [ code := self asSmalltalkElse ].			self assert: ( code = '' ) not.	^code.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/3/2014 11:20'!generateSmalltalkForFrame: aHumFrame	"Translate frame to Smalltalk using the nouns given in the ontology."	| frameCode |	(aHumFrame isKindOf: HumFrame4Action) ifTrue: [ ^self generateSmalltalkActionFor: aHumFrame ].	frameCode := ''.	aHumFrame frameLines		do: [ :line |			| lineCode |			lineCode := self generateSmalltalkForFrameLine: line.			frameCode := frameCode, lineCode, String cr.			].	^frameCode.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/8/2014 13:21'!generateSmalltalkForFrameLine: anInstructionLine 	| instructionCode statementCode roleCode commentCode quote cr documentation tab indentation  |	self assert: (anInstructionLine isKindOf: HumInstructionLine).	roleCode := ' self'.	commentCode := ''.	quote := $" asString.	cr := String cr.	"space := Character space asString."	tab := Character tab asString.	indentation := (1 to: (anInstructionLine indent)) inject: '' into: [:s :next | s, tab ]. 	documentation := quote, (anInstructionLine source ), quote, cr.	statementCode := self generateSmalltalkForStatement: (anInstructionLine statement ).	anInstructionLine onRole: [ roleCode := ' a', (anInstructionLine role capitalized) ].	anInstructionLine onComment: [ commentCode := (quote, (anInstructionLine comment ), quote). ].	(anInstructionLine statement isConditional ) 		ifTrue: [ instructionCode := indentation, documentation, indentation, statementCode, commentCode. ]		ifFalse: [instructionCode := indentation, documentation, indentation, roleCode, ' ', statementCode, '. ', commentCode. ].	^instructionCode.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/3/2014 11:16'!generateSmalltalkForStatement: aHumStatement 	| nouns code  colon space |	"TODO -- This will fail if there is a comment appended to the statement."	( aHumStatement isConditional ) 		ifTrue: [ code := self generateSmalltalkForConditional: aHumStatement. 			^code ].	code := ''.	colon := ':'.	space := ' '.	code := code, ( aHumStatement asCamelCase ), 'Q'.	nouns := ontology nounsInStatement: aHumStatement.	nouns		do: [ :aNoun | 			| camelCase |			camelCase := aHumStatement nounAsCamelCase: aNoun.			code := code, camelCase, colon, space, 'a', camelCase capitalized, space.			].			^code! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/3/2014 11:00'!generateSmalltalkIfFor: aHumStatement 	"Translate a Hum if-statement into a Smalltalk (  ) ifTrue: [] expression."	| code  statement |	statement := aHumStatement.	code := ''.	statement onMatch: 'If 1 2 is greater than 3 4 :'				do: [ :entity1 :attribute2 :entity3 :attribute4 |					code := '(  ( blackboard entity: ',(statement nounAsCamelCase: entity1 ) quoted					            , ' attribute: ',  (statement nounAsCamelCase: attribute2 ) quoted							, ' ) > ( blackboard entity: ', (statement nounAsCamelCase: entity3 ) quoted							, ' attribute: ', ( statement nounAsCamelCase: attribute4 ) quoted							, ' ) )  ifTrue: ['.					^code.					].	statement onMatch: 'If 1 2 > 3 4 :'				do: [ :entity1 :attribute2 :entity3 :attribute4 |					code := '(  ( blackboard entity: ',(statement nounAsCamelCase: entity1 ) quoted					            , ' attribute: ',  (statement nounAsCamelCase: attribute2 ) quoted							, ' ) > ( blackboard entity: ', (statement nounAsCamelCase: entity3 ) quoted							, ' attribute: ', ( statement nounAsCamelCase: attribute4 ) quoted							, ' ) )  ifTrue: ['.					^code.					].	statement onMatch: 'If 1 2 is less than 3 4 :'				do: [ :entity1 :attribute2 :entity3 :attribute4 |					code := '(  ( blackboard entity: ',(statement nounAsCamelCase: entity1 ) quoted					            , ' attribute: ',  (statement nounAsCamelCase: attribute2 ) quoted							, ' ) < ( blackboard entity: ', (statement nounAsCamelCase: entity3 ) quoted							, ' attribute: ', ( statement nounAsCamelCase: attribute4 ) quoted							, ' ) )  ifTrue: ['.					^code.					].	statement onMatch: 'If 1 2 < 3 4 :'				do: [ :entity1 :attribute2 :entity3 :attribute4 |					code := '(  ( blackboard entity: ',(statement nounAsCamelCase: entity1 ) quoted					            , ' attribute: ',  (statement nounAsCamelCase: attribute2 ) quoted							, ' ) < ( blackboard entity: ', (statement nounAsCamelCase: entity3 ) quoted							, ' attribute: ', ( statement nounAsCamelCase: attribute4 ) quoted							, ' ) )  ifTrue: ['.					^code.					].	statement onMatch: 'If 1 2 = 3 4 :'				do: [ :entity1 :attribute2 :entity3 :attribute4 |					code := '(  ( blackboard entity: ',(statement nounAsCamelCase: entity1 ) quoted					            , ' attribute: ',  (statement nounAsCamelCase: attribute2 ) quoted							, ' ) = ( blackboard entity: ', (statement nounAsCamelCase: entity3 ) quoted							, ' attribute: ', ( statement nounAsCamelCase: attribute4 ) quoted							, ' ) )  ifTrue: ['.					^code.					].	statement onMatch: 'If 1 2 is equal to 3 4 :'				do: [ :entity1 :attribute2 :entity3 :attribute4 |					code := '(  ( blackboard entity: ',(statement nounAsCamelCase: entity1 ) quoted					            , ' attribute: ',  (statement nounAsCamelCase: attribute2 ) quoted							, ' ) = ( blackboard entity: ', (statement nounAsCamelCase: entity3 ) quoted							, ' attribute: ', ( statement nounAsCamelCase: attribute4 ) quoted							, ' ) )  ifTrue: ['.					^code.					].			self assert: ( code = '' ) not.	^code.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/3/2014 10:55'!generateSmalltalkIterationFor: aHumStatement 	|     code statement |  statement := aHumStatement.	code := ''.	statement onMatch:  'For each 1 in the 2:' 	          do: [ :item :container |		code := '( self blackboard entity: ', (statement nounAsCamelCase: container) quoted		           , ' attribute: ', (statement nounAsCamelCase: item ) quoted		           , ' ) do: [ :', (statement nounAsCamelCase: item), ' | '			         , String cr			         , '     | a', (statement nounAsCamelCase: item) capitalized, ' |'			         , String cr							 , '     a', (statement nounAsCamelCase: item) capitalized, ' := ', (statement nounAsCamelCase: item), '.'		]. 	"TODO: CLEAN THIS UP BY USING A TEMPLATE INSTEAD."	^code.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 2/20/2014 17:19'!generateSmalltalkOnFile: aFileName	"Open file and produce File-Out / File-In format."     "Following is template for file-out / file-in format.""@@Superclass subclass: #@@ClassName	instanceVariableNames: '@@InstanceVariables'	classVariableNames: ''	poolDictionaries: ''	category: '@@ClassCategory'!!!!@@ClassName commentStamp: '@@Stamp' prior: 0!!@@ClassComment!!!!@@ClassName methodsFor: '@@MethodCategory' stamp: '@@Stamp'!!@@MethodSelector	""@@MethodComment""	| @@LocalVariables |	@@MethodCode	!!!!"			| code |	self shouldBeImplemented.	code := ''.	"This is crude version.	Futures:	- Roles become classes.	- Entity-Attribute relations become class accessors.	- Noun types are one of: ( Entity Category Enumeration String Measure TimeStamp ).	- Dialogs become method calls with blocks.	- Views are translated to Seaside html onRender: methods.	"	self framesByName		keysAndValuesDo: [  :frameName :frame |			| frameCode |			frameCode := frame asSmalltalkWithOntology: self.			code := code, frameCode.			].! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 4/19/2014 12:39'!asJava	"This is crude version.	Futures:	- Roles become classes.	- Entity-Attribute relations become classes with get/set methods.	- Noun types are one of: ( Entity Category Enumeration String Measure TimeStamp ).	- Dialogs are become method calls with blocks.	- Views are still interpreted.	"	| code nounCode actionCode |	code := ''.	nounCode := self nounsAsJava.	code := code, nounCode.	actionCode := self rolesAsJava.	code := code, actionCode.	^ code.! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 3/3/2014 18:30'!generateJavaCallForFrameLine: aHumInstructionLine 	| instructionCode statementCode roleCode commentCode cr documentation tab indentation  |	self assert: (aHumInstructionLine isKindOf: HumInstructionLine).
self halt.	roleCode := 'this'.	commentCode := ''.	cr := String cr.	"space := Character space asString."	tab := Character tab asString.	indentation := (1 to: (aHumInstructionLine indent)) inject: '' into: [:s :next | s, tab ]. 	documentation := '/** ', (aHumInstructionLine source ), ' */', cr.	statementCode := self generateJavaCallForStatement: (aHumInstructionLine statement ).	"Generate optional code if role or comment is present."	aHumInstructionLine onRole: [ roleCode := ' a', (aHumInstructionLine role capitalized) ].	aHumInstructionLine onComment: [ commentCode := ('/* ', (aHumInstructionLine comment ), ' */'). ].	"Generate Java code -- depending on type of statement."	(aHumInstructionLine statement isConditional ) "Does the statement begin with For/If/Else ???"		ifTrue: [ instructionCode := indentation, documentation, indentation, statementCode, commentCode. ]		ifFalse: [instructionCode := indentation, documentation, indentation, roleCode,'.', statementCode, '; ', commentCode. ].	^instructionCode.! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 3/3/2014 18:18'!generateJavaCallForStatement: aHumStatement 	| nouns code comma space parend |	code := ''.	space := ' '.	comma := ','.	parend := ' )'.	code := code, (aHumStatement asCamelCaseWithOntology: ontology),'('.	nouns := ontology nounsInStatement: aHumStatement.	nouns		do: [ :aNoun | 				| javaNoun |				javaNoun := aHumStatement nounAsCamelCase: aNoun.				code := code, space, 'a', javaNoun capitalized, comma.				].	code := code, parend.	( code endsWith: (comma, parend ) ) 		ifTrue: [ code := (code copyFrom: 1 to: (code findString: (comma, parend))-1), parend ].	self assert: ( code endsWith: parend ).	self assert: (( code endsWith: (comma, parend) ) not).				self assert: ( '*, )*' matches: code ) not.	^code.! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 3/3/2014 18:36'!generateJavaConditionalForStatement: aHumStatement 	| code source |	code := ''.	source := aHumStatement source.	(source beginsWith: 'For ' )		ifTrue: [ code := self generateJavaIterationForStatement: aHumStatement ].	( source beginsWith: 'If ')		ifTrue: [ code := self generateJavaIfForStatement: aHumStatement ].	( source beginsWith: 'Else:')		ifTrue: [ code := self generateJavaElseForStatement: aHumStatement ].			self assert: ( code = '' ) not.	^code.! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 3/3/2014 18:30'!generateJavaForFrame: aHumFrame4Action 	"Translate frame to Java using the nouns given in the ontology."	| selectorCode frameCode cr indentation priorIndent space tab javaDoc |	cr := String cr.	space := $   asString.	tab := String tab.	indentation := tab.	javaDoc := '/** ', aHumFrame4Action actionStatement asString,' */'.	selectorCode := self generateJavaMethodDeclarationForStatement: aHumFrame4Action actionStatement.	frameCode := ''.	priorIndent := 0.	( aHumFrame4Action frameLines ) 		do: [ :frameLine |			(frameLine indent < priorIndent ) 				ifTrue: [ "Insert a block-end bracket with appropriate indent."					indentation := (1 to: priorIndent) inject: '' into: [:s :next | s, tab ]. 					frameCode := frameCode, cr, indentation, '}'.				].			frameCode := frameCode, cr, (self generateJavaForFrameLine: frameLine).			"TODO: Translate if/else/for"			priorIndent := frameLine indent.			].	^ javaDoc, cr, selectorCode, space, '{', frameCode, cr, '}' .! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 3/3/2014 18:28'!generateJavaForFrameLine: aHumInstructionLine 	| instructionCode statementCode roleCode commentCode cr documentation tab indentation  |	roleCode := 'this'.	commentCode := ''.	cr := String cr.	"space := Character space asString."	tab := Character tab asString.	indentation := (1 to: (aHumInstructionLine indent)) inject: '' into: [:s :next | s, tab ]. 	documentation := '/** ', (aHumInstructionLine source ), ' */', cr.	statementCode := self generateJavaForStatement: (aHumInstructionLine statement ).	"Generate optional code if role or comment is present."	aHumInstructionLine onRole: [ roleCode := ' a', (aHumInstructionLine role capitalized) ].	aHumInstructionLine onComment: [ commentCode := ('/* ', (aHumInstructionLine comment ), ' */'). ].	"Generate Java code -- depending on type of statement."	(aHumInstructionLine statement isConditional ) "Does the statement begin with For/If/Else ???"		ifTrue: [ instructionCode := indentation, documentation, indentation, statementCode, commentCode. ]		ifFalse: [instructionCode := indentation, documentation, indentation, roleCode,'.', statementCode, '; ', commentCode. ].	^instructionCode.! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 3/3/2014 18:33'!generateJavaForStatement: aHumStatement 	| code  |	"TODO -- This will fail if there is a comment appended to the statement."	( aHumStatement isConditional ) 		ifTrue: [ code := self generateJavaConditionalForStatement: aHumStatement ]		ifFalse: [code := self generateJavaCallForStatement: aHumStatement . ].			^code! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 3/3/2014 18:37'!generateJavaIterationForStatement: aHumStatement 	| code |	aHumStatement onMatch:  'For each 1 in the 2:' do: [ :item :container |	code := 'for ( ', (aHumStatement nounAsCamelCase: item) capitalized				, ' ', (aHumStatement nounAsCamelCase: item) 		           , ' : ', (aHumStatement nounAsCamelCase: container ),'.',(aHumStatement nounAsCamelCase: item),'s' 		           , ' )  {' ].	^code.! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 3/3/2014 11:36'!generateJavaMethodDeclarationForStatement: aHumStatement 	| nouns code comma space parend |	code := ''.	space := ' '.	comma := ', '.	parend := ' )'.	code := code,'public void ', (aHumStatement asCamelCaseWithOntology: ontology),'( '.	nouns := ontology nounsInStatement: aHumStatement.	nouns		do: [ :aNoun | 			| javaNoun |			javaNoun := aHumStatement nounAsCamelCase: aNoun.			code := code, javaNoun capitalized , space, 'a', javaNoun capitalized, comma.			].	code := code, parend.	( code endsWith: (comma, parend ) ) 		ifTrue: [ code := (code copyFrom: 1 to: (code findString: (comma, parend))-1), parend ].	self assert: ( code endsWith: parend ).	self assert: (( code endsWith: (comma, parend) ) not).				self assert: ( '*, )*' matches: code ) not.	^code.! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 2/12/2014 12:47'!nounsAsJava	"Emit java code that implements noun relations."	"Currently this emits all classes into a single code stream. 	In the future, we might want to find a way to map the stream into separate '.java' files.	"	| code entities cr tab semicolon space fnToGetSupertype |	code := ''.	cr := String cr.	tab := String tab.	semicolon := ';'.	space := String space.	"Get a list of the entities."	entities := Set new.	( ontology entityAttributes ) do: [ :eachMap |  entities add: (eachMap key) ].	"Define a private function that determines the correct supertype for a given noun."	fnToGetSupertype := [ :noun :default | 			|  typeName supertypes |			supertypes := ontology immediateSupertypesOf: noun.			( supertypes size = 0 ) ifTrue: [ typeName := default ].			( supertypes size > 0 ) ifTrue: [ typeName :=  ( HumOntology nounAsCamelCase:  ( supertypes asSortedCollection at: 1 ) ) capitalized ].			( supertypes size > 1 ) ifTrue: [Error signal: '// WARNING: Cannot correctly translate ', noun, ' to Java because it has more than one supertype.', cr. ].			"Function returns the discovered supertype or the default supertype"			typeName.		].	"Emit a class for each entity."	( entities asSortedCollection ) do: [ :entity | 		| attributes extendsSupertype  |		"Everything extends Entity class -- which provides toHTML(), toXML(), and persistence methods (TBD)."		extendsSupertype := fnToGetSupertype value:  entity value: 'Entity'.		code := code, cr, 'public class ', (HumOntology nounAsCamelCase:  entity) capitalized , ' extends ',extendsSupertype, ' {', cr.		"Get the entity's attributes."		attributes := ontology immediateAttributesOfEntity: entity.		"Emit instance variable declarations for each attribute. -- Default type is String."		( attributes asSortedCollection ) do: [ :attribute |			|  typeName |			typeName := fnToGetSupertype value: attribute value: 'String'.			( entities include:  attribute ) ifTrue: [typeName :=  ( HumOntology nounAsCamelCase:  attribute ) capitalized ].			code := code, tab, 'public ', typeName, space, ( HumOntology nounAsCamelCase: attribute), semicolon, cr.			].		"Class ends with closing brace and a comment."		code := code, '} // Entity: ', (HumOntology nounAsCamelCase:  entity) capitalized, cr.		].		^code.! !!HumOntologyTranslator methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 3/3/2014 11:26'!rolesAsJava	| code cr |	code := ''.	cr := String cr.	( ontology roles asSortedCollection   )		do: [ :role | 			| actions |			code := code, cr, '/** Actor: ', role capitalized, 			             cr, ' * Generated from Hum ontology: ', (ontology fromFile) asString, 			             cr, ' */'.			code := code, cr, 'public class ', role capitalized, ' extends Actor { ', cr, cr.			actions := ontology actionsOf: role.						( actions asSortedCollection )				do: [ :actionStatement |					| frame frameCode frameName |					frameName := role capitalized, ': ', actionStatement source.					frame := ontology fetchFrameByName: frameName.					frameCode := self generateJavaForFrame: frame.					code := code, frameCode.					].			code := code, cr, cr, '} // Actor: ', role capitalized, cr.			].	^code.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk Seaside' stamp: 'RichardAlexanderGreen 3/10/2014 02:59'!generateSeasideForView: aHumFrame4View 	"Implement the view frame via Seaside components.	This is a code generator.	"	| tab cr frameCode |		self moveCodeGenerator.		cr := String cr.	tab := String tab.	frameCode := String new.	frameCode := frameCode, tab, 'html form with: [ ', cr.	aHumFrame4View frameLines		do: [ :line |			| lineCode |			"Generate Seaside code for each line in the view frame"			lineCode := self generateSeasideForViewMarkup: line.			frameCode := frameCode, tab, tab, lineCode, cr.			"TODO: SUSPECT THERE SHOULD BE A COMMA IN GENERATED CODE ABOVE."			].	frameCode := frameCode, tab, tab,  ']', cr.	^frameCode.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk Seaside' stamp: 'RichardAlexanderGreen 3/10/2014 02:59'!generateSeasideForViewMarkup: aHumMarkupLine 	"Generate Seaside code to implement a view mark-up line."	| lineCode  	         fieldName source|		self moveCodeGenerator.	"Parse into tokens"	source := aHumMarkupLine source.	lineCode := String new.	lineCode := lineCode, 'html break. '.	"Generate for heading"	(source beginsWith: '!!' ) 		ifTrue: [ lineCode := lineCode, (self generateSeasideHeadingFor: source )]. 		"Generate input fields."	fieldName := ( aHumMarkupLine getString: source between: '[' and: ']' ).	fieldName ifNotNil: [ lineCode := lineCode, (self generateSeasideWidgetForField: fieldName )].		^lineCode. ! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk Seaside' stamp: 'RichardAlexanderGreen 3/10/2014 02:59'!generateSeasideHeadingFor: source	"Generate Seaside heading code for the given heading line."	| headingString end outlineCode  quote period|			self moveCodeGenerator.	self assert: (source beginsWith: '!!' ).	quote := $' asString.	period := $. asString.   headingString := source. 	end := headingString size.													(source beginsWith: '!!' ) 		ifTrue: [ outlineCode := 'html heading level: 1; with: ',			                        quote, (headingString copyFrom: 1+1 to: end), quote, period. ].	(source beginsWith: '!!!!' ) 		ifTrue: [ outlineCode := 'html heading level: 2; with: ',			                        quote, (headingString copyFrom: 2+1 to: end), quote, period. ].	(source beginsWith: '!!!!!!' ) 		ifTrue: [ outlineCode := 'html heading level: 3; with: ',			                        quote, (headingString copyFrom: 3+1 to: end), quote, period. ].	(source beginsWith: '!!!!!!!!' ) 		ifTrue: [ outlineCode := 'html heading level: 4; with: ',			                        quote, (headingString copyFrom: 4+1 to: end), quote, period. ].	(source beginsWith: '!!!!!!!!!!' ) 		ifTrue: [ outlineCode := 'html heading level: 5; with: ',			                        quote, (headingString copyFrom: 5+1 to: end), quote, period. ].	^outlineCode.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk Seaside' stamp: 'RichardAlexanderGreen 3/10/2014 02:59'!generateSeasideWidgetForField: fieldName	| widgetCode commentCode semicolon period|		self moveCodeGenerator.  self assert: ( fieldName notNil ). 	semicolon := $; asString.	period := $. asString.	"This is the default to cover when we fall through the cases."	commentCode := ' "*** Widget not handled [', fieldName,'] ***" '.	"Does widget contain a colon. If not, we have a simple attribute."	( fieldName includesSubString: ':' ) 		ifFalse: [ 					commentCode := '"*** Update attribute [',fieldName,'] ***"'.					widgetCode := 'html textInput'					  ,' callback: [:datum | self blackBoard setEntityID: entityID attribute: #', fieldName						,' toValue: datum ]'					  , semicolon					  ,' name: ', (fieldName surroundedBySingleQuotes)					  , semicolon					  ,' value: ',(fieldName surroundedBySingleQuotes)						, period. 					( fieldName size = 1 )  "Over-ride and invoke a Seaside checkbox instead."						ifTrue: [ commentCode := '"*** TODO: Generate code for check-box: [',fieldName,'] ***' ].						].	"TODO: REFACTOR above so that it is more sensitive to the attribute`s data-type. 	Text should render as text-area.	A category should render as a select or radio group.	A date-time as a date-picker.	A set or list should render as a table.	Perhaps a measure should render as text (validated to numeric) plus a select (of unit-of-measure).	"	( fieldName beginsWith: 'page:')		ifTrue: [ | pageName | "[page: local page reference]"					pageName := ( HumCalculator substringFrom: fieldName after: 'page:' ).					commentCode := ' "*** Generate code for page: ', pageName ,'****" '.					widgetCode := widgetCode, 'html anchor '											,'url: ', (('./',(pageName asCamelCase)) surroundedBySingleQuotes)											, semicolon											,'with: ', (pageName surroundedBySingleQuotes )											, period.					].	( fieldName beginsWith: 'link:')		ifTrue: [  "[link: text | uri ]"				| linkName linkURL |				linkName := ( HumCalculator substringFrom: fieldName after: 'link:' before: '|' ).				linkURL := ( HumCalculator substringFrom: fieldName after: '|').				commentCode := ' "*** Generate code for link: ', linkName ,'****" '.				widgetCode := widgetCode, 'html anchor '											,'url: ', ( linkURL surroundedBySingleQuotes )											, semicolon											,'with: ', ( linkName surroundedBySingleQuotes )											, period.					].	( fieldName beginsWith: 'pane:')		ifTrue: [ | paneName | "[pane: name of a Hum view]"					paneName := ( HumCalculator substringFrom: fieldName after: 'pane:' ).					commentCode := ' "*** Generate code for pane: ', paneName, '****" '.										widgetCode := '(self ontology fetchFrameByName: ', paneName											,') asSeasideWithOntology: (self ontology)', period.					].	"TODO: Hum panes need to be enclosed in table <td> or perhaps <div> 	 . . . so that they can be placed side-by-side.	 . . . (The alternative using CSS {position: ABSOLUTE} is much more difficult.)	PERHAPS: We might require that the author indicate the table like this:	| [pane: left-navigation] | [pane: content] | 	That would simplify the code generation, 	  but it leaks HTML constraints to the view code.	In any case, this code-block needs to 'call' the view-code.	"						^ commentCode, String cr, widgetCode.! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk Seaside' stamp: 'RichardAlexanderGreen 3/10/2014 02:59'!generateSeasideWidgetsForSource: aSourceString	"Generate Seaside calls for the widgets found in this mark-up line."	| calc between before after wip |		self moveCodeGenerator.	"*** CALLER MUST REPLACE ALL [] WITH {} BECAUSE WE GENERATE [] IN SEASIDE CODE. ***"	wip := aSourceString.		"Match button."	( '*{{*}}*' matches: wip )		ifTrue: [ calc := HumCalculator new.			between := calc given: wip extractBetween: '{{' and: '}}'.			before := calc given: wip extractUpto: '{{'.			after  := calc given: wip extractAfter: '}}'.			wip := before,'<button name="',between,'" />'.			"Get all the buttons before we go on."			wip := wip, (self generateSeasideWidgetsForSource: after).			].	"Match check-box" 	( '*{#}*' matches: wip )		ifTrue: [ calc := HumCalculator new.			between := calc given: wip extractBetween: '{' and: '}'.			before := calc given: wip extractUpto: '{'.			after  := calc given: wip extractAfter: '}'.			wip := before,'<input name="',between,'" type="checkbox"/>'.			"Get all the check-boxes before we go on."			wip := wip, (self generateSeasideWidgetsForSource: after).			].	"Match other widgets."	( '*{*}*' matches: wip )		ifTrue: [ calc := HumCalculator new.			between := calc given: wip extractBetween: '{' and: '}'.			before := calc given: wip extractUpto: '{'.			after  := calc given: wip extractAfter: '}'.			       "Name followed by space and digit means multi-line text box"			( between matchesRegex: '^.*\b\d$'  )				ifTrue: [ | name d |					name := calc given: between extractUpto: ' '.					d := calc given: between extractAfter: ' '.					wip := before,'<textarea name="',name,'" rows=',d,' cols=60 /></textarea>'.					wip := wip, (self generateSeasideWidgetsForSource: after).					]				ifFalse: ["Not a textarea . . ."					"TODO: If the attribute-name is plural, render as a table."					| noun |					noun := between.					(ontology isPluralNoun: noun)						ifFalse: [wip := before,'<input name="',between,'" />',after.]						ifTrue:  [wip := before, (self generateSeasideTableFor: noun ), after.].					].			"TODO: Special handling for other types: category, date-time, measure."			].	"Match radio-button -- TODO: THIS RADIO BUTTON STRATEGY WILL FAIL."		( '*(#)*' matches: wip )			ifTrue: [ calc := HumCalculator new.			between := calc given: wip extractBetween: '(' and: ')'.			self assert: (between size = 1).			before := calc given: wip extractUpto: '('.			after  := calc given: wip extractAfter: ')'.			"Call myself recursively"			wip := before,'<input name="',between,'" type="radio"/>'.			wip := wip, (self generateSeasideWidgetsForSource: after).			"TODO: Need <group> tags."			].			^wip.	! !!HumOntologyTranslator methodsFor: 'translate to Smalltalk Seaside' stamp: 'RichardAlexanderGreen 3/10/2014 02:59'!moveCodeGenerator	(self isKindOf: HumOntologyTranslator)		ifFalse: [Error signal: 'Move this code generator to HumOntologyTranslator'].! !!HumOntologyTranslator methodsFor: 'debugging' stamp: 'RichardAlexanderGreen 5/19/2014 10:23'!humParserError: aString 	Error signal: aString.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumOntologyTranslator class	instanceVariableNames: ''!!HumOntologyTranslator class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/12/2014 12:38'!ontology: aHumOntology 	"Create an instance"	| instance |	instance := self basicNew.	instance ontology: aHumOntology.	^instance! !Object subclass: #HumFrameLine	instanceVariableNames: 'source indentLevel'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrameLine commentStamp: 'RichardAlexanderGreen 9/19/2012 11:09' prior: 0!A frame line conforms to a specific notation.For example, a dictionary line conforms to dictionary syntax.Instance Variables:	source	<String>!!HumFrameLine methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 1/11/2012 19:34'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		"nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);"		nextPutAll: title;		nextPutAll: '( ', self source, ' )';		nextPutAll: String cr.! !!HumFrameLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2012 14:03'!source	^ source! !!HumFrameLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2012 13:59'!source: aByteString 	source := aByteString! !!HumFrameLine methodsFor: 'testing' stamp: 'RichardAlexanderGreen 3/30/2012 10:30'!checkForAntecedantsIn: aHumStatement withOntology: aHumOntology 	| antecedants myNouns result |	antecedants := aHumOntology nounsInStatement: aHumStatement.	myNouns := aHumOntology nounsInStatement: self statement.	result := OrderedCollection new.	( antecedants includesAllOf: myNouns )		ifTrue: [ ^result ].	( myNouns copyWithoutAll:  antecedants )		do: [ :noun |			result add: 'The noun: "',noun,'" has no antecedant.'. 			].	^result.! !!HumFrameLine methodsFor: 'testing' stamp: 'RichardAlexanderGreen 1/18/2012 14:00'!checkSyntaxWithOntology: aHumOntology 	|  nouns errors  |	errors := OrderedCollection new.	nouns := aHumOntology nounsInStatement: (self statement).	(nouns isEmpty ) 		ifTrue: [ errors add:( 'Statement { ', self statement source ,' } has no known nouns!!' ) ].	^ errors.! !!HumFrameLine methodsFor: 'testing' stamp: 'RichardAlexanderGreen 10/18/2012 09:52'!getString: sourceString between: stringA and: stringB	"Return the substring in the sourceString between the two."	| xStart xStop result |	xStart := sourceString findString: stringA startingAt: 1 caseSensitive: false.	( xStart > 1 ) ifFalse: [ ^nil ].	xStop := sourceString findString: stringB startingAt: xStart caseSensitive: false.	( xStop > xStart ) ifFalse: [ ^nil ].	result := sourceString copyFrom: (xStart + 1) to: (xStop - 1).	^result.! !!HumFrameLine methodsFor: 'testing' stamp: 'RichardAlexanderGreen 7/25/2013 15:50'!sameAs: anotherFrameLine	(anotherFrameLine isKindOf: String)		ifTrue: [^ (self source) sameAs: anotherFrameLine.].	(anotherFrameLine isKindOf: HumFrameLine )		ifTrue: [^ ( self source ) sameAs: ( anotherFrameLine source ).].	"Eh? Why are we here?"	Error signal: 'unexpected type'.	! !!HumFrameLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/27/2012 19:43'!extractPatternParameters: aPatternString 	"Extract parameters (tokens) from source that match the pattern."	| parameters patternTokens selfTokens isMatch |	parameters := OrderedCollection new.		self assert: ( aPatternString isKindOf: String ).	patternTokens := self getTokensIn: ( aPatternString asLowercase ).  	selfTokens := self getTokensIn: ( self source asLowercase ).	"Search to see if a sequence in my tokens matches a sequence in pattern tokens."	isMatch := self matchTokensIn: selfTokens at: 1 matchTokensIn: patternTokens at: 1.		isMatch ifFalse: [ Error signal: 'Attempt to get parameters when pattern does not match.' ].	self getParametersIn: selfTokens at: 1 thatMatchParametersIn: patternTokens at: 1 accumulating: parameters.	^ parameters reversed.! !!HumFrameLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/27/2012 20:54'!generateCodeFrom: aTemplateString using: parameterValues 	"Generate code (string) from the template replacing paramters with values in the parameter list."	| templateTokens code xParameter |	self assert: ( aTemplateString isKindOf: String ).	self assert: ( parameterValues isKindOf: OrderedCollection ).	code := String new.	templateTokens := self getTokensIn: aTemplateString.	templateTokens 		do: [ :token | "For each token:"			| atParameter |			atParameter := ( ( ( token size = 1) and: [ token isAllDigits ] ) ).			atParameter				ifTrue: [ code := code, ( parameterValues at:  ( token asNumber ) ).  ]				ifFalse: [ code := code, token ].			].	^code.! !!HumFrameLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/27/2012 19:30'!getParametersIn: selfTokens at: xSelf thatMatchParametersIn: patternTokens at: xPattern accumulating: parameters	"See if we can get any matching sequence."	| pToken atParameter  isMatch parameter |	isMatch := false.	 parameter := nil.	"If we run out of pattern, we have succeeded."	( xPattern > (patternTokens size) ) ifTrue: [ ^true ].	"If we run out self before we run out of pattern, we have failed."	( xSelf > ( selfTokens size ) ) ifTrue: [^false].	"A pattern token that is a digit will match anything. 	 Proceed to next token in both lists.	 But if there is no match there, the pattern token could still match the next self token, so try that.	"	pToken := patternTokens at: xPattern.	atParameter := ( ( ( pToken size = 1) and: [ pToken isAllDigits ] ) ).	atParameter			ifTrue: [ isMatch := (self getParametersIn: selfTokens at: (xSelf + 1 ) thatMatchParametersIn: patternTokens at: (xPattern + 1 ) accumulating: parameters )								   or: [self getParametersIn: selfTokens at: (xSelf + 1 ) thatMatchParametersIn: patternTokens at: (xPattern + 0 ) accumulating: parameters ].					    isMatch ifTrue: [ parameters add: ( selfTokens at: xSelf ) ].						  ^isMatch.					].	"Remainder assumes that current pattern token is not a parameter."					self assert: ( atParameter not ).	"If the current pattern token matches the current self token, proceed to the next token in both lists."	( ( patternTokens at: xPattern ) sameAs: ( selfTokens at: xSelf ) )			ifTrue: [ "Proceed to next token in both lists"						isMatch := self getParametersIn: selfTokens at: (xSelf + 1) thatMatchParametersIn:patternTokens at: (xPattern + 1) accumulating: parameters.					    ^isMatch 					]			ifFalse: [ "See if the next token in self matches the pattern token"						isMatch := self getParametersIn: selfTokens at: (xSelf + 1) thatMatchParametersIn:patternTokens at: (xPattern + 0) accumulating: parameters.						^isMatch. ].			"At this point we have a mismatch for sure. (I think maybe.)"	isMatch := false.				^isMatch.! !!HumFrameLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/27/2012 20:51'!getTokensIn: aString	| punctuation whiteSpace tokens |	"Punctuation does not include hyphen because nouns may be hypenated."	punctuation := '~!!@#$%^&*()_+`={}|[[]\:";<>?,./'. 	"White space includes space, cr, tab."		whiteSpace := ' 			'.	"Tokens are all lower-case and include punctuation."	tokens := ( aString asLowercase ) findTokens: ( punctuation, whiteSpace ) keep: (punctuation, whiteSpace).		^tokens.! !!HumFrameLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/27/2012 19:32'!matchTokensIn: selfTokens at: xSelf matchTokensIn: patternTokens at: xPattern	"See if we can get any matching sequence."	| pToken atParameter isMatch |	isMatch := false.	"If we run out of pattern, we have succeeded."	( xPattern > (patternTokens size) ) ifTrue: [ ^true ].	"If we run out self before we run out of pattern, we have failed."	( xSelf > ( selfTokens size ) ) ifTrue: [^false].	"A pattern token that is a digit will match anything. 	 Proceed to next token in both lists.	 But if there is no match there, the pattern token could still match the next self token, so try that.	"	pToken := patternTokens at: xPattern.	atParameter := ( ( ( pToken size = 1) and: [ pToken isAllDigits ] ) ).	atParameter			ifTrue: [ isMatch := (self matchTokensIn: selfTokens at: (xSelf + 1) matchTokensIn: patternTokens at: (xPattern + 1))								   or: [self matchTokensIn: selfTokens at: (xSelf + 1) matchTokensIn: patternTokens at: (xPattern + 0 ) ].						^isMatch. 					].	"Remainder assumes that current pattern token is NOT a digit."					self assert: (  atParameter not  ).	"If the current pattern token matches the current self token, proceed to the next token in both lists."	( ( patternTokens at: xPattern ) sameAs: ( selfTokens at: xSelf ) )			ifTrue: [ "Proceed to next token in both lists"						isMatch := self matchTokensIn: selfTokens at: (xSelf + 1) matchTokensIn: patternTokens at: (xPattern + 1).					    ^isMatch 					]			ifFalse: [ "See if the next token in self matches the pattern token"						isMatch := self matchTokensIn: selfTokens at: (xSelf + 1) matchTokensIn: patternTokens at: (xPattern + 0).						^isMatch. ].			"At this point we have a mismatch for sure. (I think maybe.)"	isMatch := false.				^isMatch.! !!HumFrameLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/27/2012 19:12'!matchesPattern: aPatternString 	"Does some part of the line match the given pattern?"	| patternTokens selfTokens isMatch |	self assert: ( aPatternString isKindOf: String ).	patternTokens := self getTokensIn: ( aPatternString asLowercase ).  	selfTokens := self getTokensIn: ( self source asLowercase ).	"Search to see if a sequence in my tokens matches a sequence in pattern tokens."	isMatch := self matchTokensIn: selfTokens at: 1 matchTokensIn: patternTokens at: 1. 	^isMatch.! !!HumFrameLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/27/2012 10:44'!onMatch: aPatternString generate: aTemplateString 	"When some part of the content in the current line matches the pattern,	 - Generate code from the template.	 - Replace parameters indicated by digits with corresponding values in the parameter array.	"	| code parameters |	self assert: ( aPatternString isKindOf: String ).	self assert: ( aTemplateString isKindOf: String ).	"If there is no match, there is nothing to do. Return an empty string."	code := String new.	( self matchesPattern: aPatternString ) ifFalse: [ ^code ].	"Otherwise, we have a match.	Generate some code.	"	parameters := self extractPatternParameters: aPatternString.	code := self generateCodeFrom: aTemplateString using: parameters.	^code.! !!HumFrameLine methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 8/22/2013 17:47'!compileLineToOntology: aHumOntology 	"Compile this instruction line."	| errors | 	"Subtypes should implement."	Error signal: 'Subtypes should implement.'.	errors := OrderedCollection new.	^ errors.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrameLine class	instanceVariableNames: ''!!HumFrameLine class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 1/13/2012 11:41'!source: aByteString      | frameLine |	frameLine := self new.	frameLine source: aByteString.	^frameLine.! !HumFrameLine subclass: #HumTranslationLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumTranslationLine commentStamp: 'RichardAlexanderGreen 9/28/2012 13:33' prior: 0!A translation line may occur between triple-brace lines in a role-action frame.It specifies how an action statement (generally an internal "To:" statement) may be implemented in some target language.Generally the implementation will be a method declaration where the role is assumed to be implemented as a class.Here is an example:____Role: Invoicing.To: Extend the order's unit prices.. As Smalltalk:{{{extendOrderLinePricesFor: anOrder	"Multiply the unit price times the quantity to fill in the extended price. 	Then apply any quantity discounts."	( anOrder orderLines )		do: [ :orderLine |			orderLine extendedPrice: (orderLine quantity) * (orderLine price).			orderLine applyQuantityDiscountIfAny.			"The quantity discount rule depends on the the catalogNumber and quantity"			 ].}}}___In this case, the translator will assemble the given translation lines with other translation lines to produce a Smalltalk class definition.Similar results might be obtained for translation to Java or Python or Javascript or Objective-C.Note: The code above could have been written entirely in Hum without the need to use an external framework.  This example was used because it does not require explanation of the context.The general form is:___To: <action statement>.. As <language>:{{{   <several lines in the target procedural language>}}}___Note: "To: . . . " could also be "Action: . . . ". (That is allowed but is probably bad form.)!HumFrameLine subclass: #HumCommentLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumCommentLine commentStamp: 'RichardAlexanderGreen 9/28/2012 11:14' prior: 0!A comment line is a line in a single-line or multi-line comment.The lines in the multi-line comment are signaled by a line that begins with a '(' -- a right parend.The lines end with a line that ends with a ')' -- a left parend.Note: In some ontology text files, an additional convention allows a frame or subframe that begins with a 'Comment:' label and ends when the next label (of any kind) is encountered. !HumFrameLine subclass: #HumInstructionLine	instanceVariableNames: 'indent role statement comment annotation translation problems'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumInstructionLine commentStamp: 'RichardAlexanderGreen 9/28/2012 11:29' prior: 0!An instruction line may occur in  an action frame,  a plan-frame action section,  or in a dialog vignette as part of the response to a stimulus.Here is a sample instruction line:. Oven: Preheat to temperature. (The oven will emit a ding when the required temperature is reached.)  [duration: 5 minutes]This line has a role (Oven) to which the action is delegated.It has a statement: 'Preheat to temperature.' The action request with the value of the 'temperature' noun will be sent to the actor assigned to the role.It has a comment -- within by round parentheses.It has an annotation -- within square brackets.Instance Variables:	indent	<Magnitude>	role	<String>	statement	<HumStatement>	comment	<Object>	annotation	<ProtoObject>	translation	<ProtoObject | PseudoContext>!!HumInstructionLine methodsFor: 'testing' stamp: 'RichardAlexanderGreen 1/18/2012 13:59'!checkSyntaxWithOntology: aHumOntology 	|  nouns errors |	errors := OrderedCollection new.		"Check that the nouns in the statement are known. (defined in the ontology)."	nouns := aHumOntology nounsInStatement: statement.	( nouns isEmpty ) 		ifTrue: [ errors add: ( 'Statement: {', statement source ,'} has no known nouns!!' ) ].		"Check that a delegated action is defined in the ontology."	( aHumOntology isActionDefined: self ) 		ifFalse: [ errors add: ('Action: {', statement source, '} has not been defined.') ].		^ errors.! !!HumInstructionLine methodsFor: 'testing' stamp: 'RichardAlexanderGreen 8/23/2013 11:14'!compileLineToOntology: aHumOntology 	"Compile this instruction line."	| errors | 	"Check syntax"	errors := self checkSyntaxWithOntology: aHumOntology.	"remember the errors - May show in HTML and other views"	problems := errors.	^ errors.! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/13/2012 13:47'!annotation	^ annotation ifNil: [^'' ].! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 20:37'!annotation: aString 	"Annotation may indicate timing for simulations."	annotation := aString.! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/6/2012 11:39'!comment	^ comment ifNil: [''].! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 20:34'!comment: aString 	"Comment is not executable. May be displayed in certain contexts."	comment := aString.! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2012 09:51'!indent	"How many indents (tabs) before the start of the code-text ?"	^ indent ifNil: [ indent := 1 ].! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2012 10:16'!indent: aSmallInteger	"How many indents (tabs) before the start of the code-text ?"	indent := aSmallInteger.	(indent < 1 ) ifTrue: [ indent := 1].! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2012 11:34'!role	^ role  ifNotNil: [ (role) ] ifNil: [''].! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 20:35'!role: aString 	"Delegate the task (statement) to this role at run-time. "	role := aString.! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2012 11:33'!source	"Construct a source line based on convention and content of my attributes."	| s |	s := self statement asString.	(self role trimBoth isEmpty ) ifFalse: [ s :=( role,': ', s ) ].	(self comment isEmpty) ifFalse: [ s := s, ( self comment ) ].	(self annotation isEmpty) ifFalse: [ s := s, ( self annotation ) ].	^ s. ! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 20:36'!statement	"What will be done . . . will be done at run-time."	^ statement! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2012 10:25'!statement: aSource 	"What to do  at run-time?"	| x |	( aSource isKindOf: String ) 		ifTrue: [ "Convert to HumStatement"			| sourceString |			sourceString := aSource.			x := 0.			[ sourceString beginsWith: '. ' ] 				whileTrue: [ "Count the indents."					x := x + 1.					sourceString := sourceString copyFrom: 3 to: (sourceString size).					].			statement := HumStatement from: sourceString. 			"Determine the indent level."			self indent: x.			^self.			].	( aSource isKindOf: HumStatement )		ifTrue: ["Copy the Statement."			statement := aSource copy.			self indent: 1.			^self. ].	self assert: ( statement notNil ).	! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/24/2013 20:44'!title	^ self titleLine.! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/24/2013 20:38'!titleLine	^ ( self role), ': ', ( self statement asString ).! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2011 07:12'!translation: aString 	translation := aString.! !!HumInstructionLine methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!= anInstruction	( anInstruction isKindOf: String) ifTrue: [ ^ statement = anInstruction ].	( anInstruction isKindOf: HumInstructionLine ) ifTrue: [ ^ statement = ( anInstruction statement ) ].	self halt.! !!HumInstructionLine methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 2/13/2012 16:04'!onComment: aBlockClosure 	comment ifNil: [^self].	(comment size > 1 ) ifTrue: aBlockClosure.! !!HumInstructionLine methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 2/13/2012 16:03'!onRole: aBlockClosure 	role ifNil: [^self ].	(role size > 1) ifTrue: aBlockClosure.! !!HumInstructionLine methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 2/26/2014 23:09'!runInContext: aHumCoordinator 	"Fake it for now.	TODO: REPLACE THIS STUB"	| aHumMeasure ticket |	self assert: ( aHumCoordinator isKindOf: HumCoordinator ).	"Simulate agent side-effects."	ticket := aHumCoordinator jobTicket.	aHumMeasure := HumMeasure quantity: 1 units: 'step'.	ticket appendCharge: aHumMeasure forAction: self byActor: ((self role),'Actor') inRole: (self role) onJob: (ticket id). 	^self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumInstructionLine class	instanceVariableNames: ''!!HumInstructionLine class methodsFor: 'Instance creation convenience' stamp: 'RichardAlexanderGreen 1/2/2012 21:34'!role: aRole statement: aSourceString  	"Return an instance with given source, role, and comment."	| instruction |	instruction := self new.	instruction statement: aSourceString; role: aRole.	^instruction.! !!HumInstructionLine class methodsFor: 'Instance creation convenience' stamp: 'RichardAlexanderGreen 1/2/2012 21:37'!role: aRole statement: aSourceString annotation: anAnnotation	"Return an instance with given  role, source, and annotation."	| instruction |	instruction := self new.	instruction role: aRole; statement: aSourceString;  annotation: anAnnotation.	^instruction.! !!HumInstructionLine class methodsFor: 'Instance creation convenience' stamp: 'RichardAlexanderGreen 1/2/2012 21:36'!role: aRole statement: aSourceString  comment: aComment	"Return an instance with given source, role, and comment."	| instruction |	instruction := self new.	instruction  role: aRole;  statement: aSourceString; comment: aComment.	^instruction.! !!HumInstructionLine class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 1/3/2012 20:57'!statement: aSourceString 	"Return an instance with given source."	| instruction |	instruction := self new.	instruction statement: aSourceString.	^instruction.	! !Object subclass: #HumOntologyViewer	instanceVariableNames: 'ontology lastLevel modeStack priorCaseIsTrue generatedMarkupCode calc'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumOntologyViewer commentStamp: 'RichardAlexanderGreen 5/13/2014 09:09' prior: 0!The Ontology Viewer renders views of the ontology frames in HTML.The Ontology Translator is a code generator that translates frames into some executable language.This architecture separates rendering and translating logic from the ontology itself.Hopefully, this will make the code easier to maintain.!!HumOntologyViewer methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/28/2014 13:04'!initialize	calc := HumCalculator new.! !!HumOntologyViewer methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/12/2014 12:14'!ontology: aHumOntology 	ontology := aHumOntology.! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 5/28/2014 12:45'!asHTML5	"Render the ontology as an HTML5 page.	. Since HTML is based on XML, we create XML elements.	"	| html heading   |	"Creating a fresh calculator initializes XML indent."	calc := HumCalculator new.	html := calc xml: 'html' 				with: [ "Build the HTML header"					      ( calc xml: 'head' 							with: [ (calc xml: 'title' 										with: [ (ontology title) asString ]),									self css.								   ]),						"Build the HTML body"							(calc xml: 'body'							with: [ | bodyLines | 									bodyLines := ''.									"Render the ontology fiilename, if any, as an HTML5 heading element."									heading := calc xml: 'heading' with: [  'Ontology: ',(ontology title asString) ].									(ontology framesByName keysSortedSafely) 										do: [ :frameName  | 											| frame |											frame := ontology framesByName at: frameName.											"Delegate rendering of the frames to the frames."											 bodyLines := bodyLines,'<hr/>',String cr, ( self renderFrame: frame  ).											"The <hr/> seems to be needed. I cannot figure out how to do that with CSS."											] .									heading, bodyLines, String cr, '<hr/>'.									"The <hr/> also seems to be needed. I cannot figure out how to do that in CSS either."								   ] )						].	^html.    ! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 5/28/2014 10:16'!css	"generate HTML Cascading Style Sheet (CSS) code segment"	| html  |	calc := HumCalculator new.	html := calc xml: 'style' 			with: [' 				body {}				heading {font-size: X-LARGE; }							frameTitle {color: BLUE; font-size: LARGER; font-weight: BOLD;}								n, noun {color: PURPLE;}				k, keyword {font-weight: BOLD;}								role {font-style: ITALIC;}				statement {}				comment {color: GREEN;}				annotation {}								pattern {}				markup {font-family: MONOSPACE;}				widget {color: RED;}												HumFrame {}				frameLine       {margin-left: 1em;}				DictionaryLine  {margin-left: 1em;}				PreconditionLine {margin-left: 1em;}					InstructionLine {margin-left: 1em;}					InstructionLine.indent1 {margin-left: 1em;}						InstructionLine.indent2 {margin-left: 2em;}						InstructionLine.indent3 {margin-left: 3em;}						InstructionLine.indent4 {margin-left: 4em;}											textarea {vertical-align: top;}					form {border-style: outset; padding: 1em;}				table {}				th {background: CYAN;}				td {background: LIGHTGREY;}				' ].	"TODO: Consider using class='indentN' to control indent in action frames.	 That would enable multi-level indent in Action Frames.	"	^html.! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 2/12/2014 12:27'!render: asSymbol onFileNamed: aNewFile	| string file |	string := self renderAs: asSymbol.	file := StandardFileStream forceNewFileNamed: aNewFile. 	file nextPutAll: string.	file close.	^string.! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 3/2/2014 10:42'!renderAs: aSymbol 	"FUTURE: Render as X -- Currently not needed."	self shouldBeImplemented.	self assert: ( aSymbol isKindOf: Symbol ).	self log: 'Ontology: Document ontology as: ', ( aSymbol asString ). 	"Call the HTML rendering code."	(aSymbol = #HTML or: [ aSymbol = #HTML5 ])		ifTrue: [ self renderAsHTMLonFileNamed: ( (self file), '.html') ]		ifFalse: [ self shouldBeImplemented ].	! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 3/2/2014 10:42'!renderAsHTMLonFileNamed: aNewFile 	"Render as HTML5 and echo on given file."	| html file  |	html := self asHTML5.	file := StandardFileStream forceNewFileNamed: aNewFile. 	file nextPutAll: html.	file close.	^html.! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 3/2/2014 11:48'!renderPlanTreeForGoal: aGoal	"Render HTML for a previous created planTree (generated by  buildPlanTreeForGoal: )"	| string cr indentedPlanTree priorIndent goalHTML |	"See: HumOntologyTests>>test540GetPlanTree 	-- Call to this method is commented out.	See also: HumOntology>>buildPlanTreeForGoal:	"	cr := String cr.	string := cr, 'Plan Tree:', cr.	indentedPlanTree := ontology buildPlanTreeForGoal: aGoal indent: 0.	priorIndent := 999.	goalHTML := self renderStatement: (HumStatement source: ( ( indentedPlanTree at: 1 ) key )).	indentedPlanTree 		do: [ :mapPostPre |				| value indent precondition pad |				value := ( mapPostPre value ).  "= { indent. precondition. }"				indent := value at: 1.				precondition := value at: 2.				pad := String new: 1 + (indent * 2) withAll: (Character space).				( priorIndent = 999 ) 					ifTrue: [ string := string, pad, goalHTML, cr ].				string := string, pad, ' -> ', (self renderStatement: precondition ), cr.				priorIndent := indent.				].	^ string.! !!HumOntologyViewer methodsFor: 'render all frames' stamp: 'RichardAlexanderGreen 2/12/2014 12:29'!showPlanTreeForGoal: aGoal	"Display a previous created planTree (generated by  buildPlanTreeForGoal: )"	| string cr indentedPlanTree priorIndent |	"See: HumOntologyTests>>test540GetPlanTree 	-- Call to this method is commented out.	See also: HumOntology>>buildPlanTreeForGoal:	"	cr := String cr.	string := cr, 'Plan Tree:', cr.	indentedPlanTree := ontology buildPlanTreeForGoal: aGoal indent: 0.	priorIndent := 999.	indentedPlanTree 		do: [ :mapPostPre |				| value indent precondition pad |				value := ( mapPostPre value ).  "= { indent. precondition. }"				indent := value at: 1.				precondition := value at: 2.				pad := String new: 1 + (indent * 2) withAll: (Character space).				( priorIndent = 999 ) 					ifTrue: [ string := string, pad, ( mapPostPre key ) asString, cr ].				string := string, pad, ' -> ', precondition asString, cr.				priorIndent := indent.				].	^ string.! !!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 5/28/2014 12:17'!renderActionFrame: aHumFrame4Action 	"Render source code. 	--  This is a read-only view for ontology code listing."	| html  innerHTML |	calc := HumCalculator new. "By-Product: Initializes indent"	innerHTML := ''.	aHumFrame4Action frameLines		do: [ :frameLine |			innerHTML := innerHTML,'<br/>', String cr, (self renderFrameLine: frameLine ).			].		html := calc xml: 'HumFrame' with: [			'<br/><b>Role: </b>',			(calc xml: 'role' with: [ (aHumFrame4Action role capitalized),'.' ]),			'<br/><b>Action: </b>',			(calc xml: 'action' with: [ self renderStatement: ( aHumFrame4Action actionStatement ) ]), innerHTML.					].	^html.! !!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 3/2/2014 12:10'!renderActionsIn: aHumFrame4Plan 	"render precondition lines"	| html cr |	cr := String cr.	html := '<br/><b>Actions:</b>', cr.	(aHumFrame4Plan actionStatements)		do: [ :actionLine |			self assert: ( actionLine isKindOf: HumFrameLine ).			html := html, '<br/>', ( self renderStatement: actionLine ), cr.			].	^ html! !!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 5/28/2014 12:48'!renderFrame: aHumFrame  	"Render (pretty print) source code. 	--  This is a read-only view for ontology code listing."	| html |	"Wrap the lines with a HumFrame tag."	"Note: <frame> has semantics in HTML, so we use <HumFrame> tag instead."	html :=		calc xml: 'HumFrame'				with: [					"Tag the title line."					(calc xml: 'frameTitle' with: [  aHumFrame titleLine asString ]),					"Append the frame lines"					(self renderFrameLinesIn: aHumFrame )					].	^html.! !!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 3/2/2014 12:19'!renderFrameLinesIn: aHumFrame 	"Iterate throught the frame lines" 	| html cr class |	"View frames are rendered as HTML forms with widgets."	class := aHumFrame class.	(class = HumFrame4View ) ifTrue: [^ self renderView: aHumFrame ].	"Plan frames are rendered with Precondition and Action sections"	(class = HumFrame4Plan ) ifTrue: [^ self renderPlanFrame: aHumFrame ].	"Action frames are rendered with Role: and Action: labels."	(class = HumFrame4Action ) ifTrue: [^ self renderActionFrame: aHumFrame ].		"Other frame types are just pretty-printed?"	cr := String cr.	html := cr.	aHumFrame frameLines 		do: [ :frameLine |				html := html, '<br/>', ( self renderFrameLine: frameLine  ) ].	^html.! !!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 5/28/2014 10:59'!renderPlanFrame: aHumFrame4Plan 	"Render source code. 	--  This is a read-only view for ontology code listing."	| html  |	calc := HumCalculator new. "Initialize indent"	html :=	calc xml: 'HumFrame'		with: [			(calc xml: 'frameTitle' with: [  'Goal: ', ( self renderStatement: (aHumFrame4Plan goal ) )]),			( self renderPreconditionsIn: aHumFrame4Plan ),			( self renderActionsIn: aHumFrame4Plan )					].	^html.! !!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 5/28/2014 12:19'!renderPreconditionsIn: aHumFrame4Plan 	"render precondition lines"	| html br|	"Always include this subheading."	html := '<br/><b>Preconditions:</b>'.	br := String cr, '<br/>'.	(aHumFrame4Plan preconditions)		do: [ :preconditionLine |			self assert: (preconditionLine isKindOf: HumFrameLine ).			html := html, br, (self renderFrameLine: preconditionLine ).			].	^ html! !!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 5/28/2014 12:20'!renderView: aHumViewFrame 	"Views are rendered as HTML forms -- which is different from other frames."	| html cr br innerHTML |	cr := String cr.	br := cr, '<br/>'.	innerHTML := cr.	html := cr, (calc xml:'form' with: [		aHumViewFrame frameLines 		do: [ :frameLine |				"Markup lines will control line-breaks without my help."				"Future: View might have instruction-lines for tables."				(frameLine isKindOf: HumMarkupLine)					ifTrue: [innerHTML := innerHTML, br, ( self renderMarkupAsHTML5: frameLine source )]					ifFalse:[innerHTML := innerHTML, br, ( self renderInstructionLine: frameLine source )						].				 ].		"Block returns "		innerHTML.		]	).	^html.! !!HumOntologyViewer methodsFor: 'render frame' stamp: 'RichardAlexanderGreen 2/12/2014 12:27'!showPlanTree: aPlanTree	"Display a previous created planTree (generated by  buildPlanTreeForGoal: )"	| string cr |	"See: HumOntologyTests>>test540GetPlanTree 	-- Call to this method is commented out.	See also: HumOntology>>buildPlanTreeForGoal:	"	cr := String cr.	 string := cr, 'Plan Tree:', cr.	aPlanTree 		do: [ :mapPostPre |				string := string, ( mapPostPre key ) asString, ' -> ', ( mapPostPre value ) asString, cr.				].		"TODO: What does this produce?  It looks like a simple rendering with no indentation."	^ string.! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 3/2/2014 11:15'!generateHtmlTableFor: anEntity	"Generate a dummy table showing the attributes for this entity-name." 	| singular attributes html  |	singular := ontology singularFormOfNoun: anEntity.	attributes := ontology allAttributesOfEntity: singular.	"If the entity has no attributes, generate a default table."	( attributes size = 0 )		ifTrue: [^'<table name="',anEntity,'"><tr><th>',anEntity,' has no attributes in current ontology.</th></tr></table>'].  "Otherwise generate a normal table."	html := '<table name="',anEntity,'" >'.	html := html, '<tr>'.	attributes do: [:attribute | html := html, '<th>', attribute, '</th>'.]. 	html := html, '</tr>'.	html := html, '<tr>'.	attributes do: [:attribute | html := html, '<td>', attribute, ' value </td>'.]. 	html := html, '</tr>'.	html := html, '</table>'.	^html.! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 3/2/2014 11:17'!modeStack	"Stack to track list-type modes."	^ modeStack ifNil: [ modeStack := Stack new.]! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 5/28/2014 11:16'!renderCommentIn: aFrameLine 	"Render comment (if any) as HTML"	| html |	html := ''.	(aFrameLine comment notEmpty)		ifTrue: [ html := calc xml: 'comment' with: (aFrameLine comment) ]. 	^html.! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 5/28/2014 11:16'!renderConditionLine: aHumConditionLine  	| html xmlStatement xmlComment xmlAnnotation assembly  |	"Avoid empty statement element."		xmlStatement := (aHumConditionLine statement source isEmpty ) 		ifTrue: [''] 		ifFalse: [( calc xml: 'statement' with: [self renderStatement: (aHumConditionLine statement) ] ) ].	"Avoid empty comment element.	Note that parends are added for Hum consistency."	xmlComment := ( aHumConditionLine comment trimBoth isEmpty ) 		ifTrue: [''] 		ifFalse: [ (  calc xml: 'comment' with: [ '( ', (aHumConditionLine comment), ' )' ]   ) ].	"Render the annotation."		xmlAnnotation := ( aHumConditionLine annotation trimBoth isEmpty ) 		ifTrue: [''] 		ifFalse: [ (  calc xml: 'annotation' with: [ '[ ', (aHumConditionLine annotation), ' ]' ]   ) ].	"Assemble it without any line breaks."		assembly := xmlStatement, xmlComment, xmlAnnotation.	html := (calc xml: 'PreconditionLine' with: [ assembly ]).	"TODO: Add hyperlink to frame (if any) that has goal matching this precondition."	^html.! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 5/28/2014 11:16'!renderDictionaryLine: aHumDictionaryLine 	|  |					^ calc xml: 'DictionaryLine' 			with: [				(calc xml: 'statement' 					 with: [(self renderStatement: (aHumDictionaryLine statement )), (self renderCommentIn: aHumDictionaryLine)  ]					 					)				  ]. ! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 3/2/2014 11:20'!renderFrameLine: frameLine  	"Dispatch frameLine to rendering specialist."	| class |	class := frameLine class.	(class = HumConditionLine ) ifTrue: [^ self renderConditionLine: frameLine ]. 	(class = HumInstructionLine ) ifTrue: [^ self renderInstructionLine: frameLine ]. 	(class = HumDictionaryLine ) ifTrue: [^ self renderDictionaryLine: frameLine ]. 	self shouldBeImplemented.! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 5/28/2014 12:11'!renderInstructionLine: aHumInstructionLine  	"Pretty-print using HTML5 tags and CSS."	| html xmlRole xmlStatement xmlComment xmlAnnotation assembly |	"Avoid an empty role element.	Note that colon may be  inserted for HTML readability."	xmlRole :=  (aHumInstructionLine role isEmpty )  		ifTrue: [''] 		ifFalse: [ (( calc xml: 'role' with: [ (aHumInstructionLine role) ] ), ':' )].	"Avoid empty statement element."		xmlStatement := (aHumInstructionLine statement source isEmpty ) 		ifTrue: [''] 		ifFalse: [( calc xml: 'statement' with: [self renderStatement: (aHumInstructionLine statement)  ] ) ].	"Avoid empty comment element.	Note that parends are added for Hum consistency."	xmlComment := ( aHumInstructionLine comment trimBoth isEmpty ) 		ifTrue: [''] 		ifFalse: [ (  calc xml: 'comment' with: [ ' ( ', (aHumInstructionLine comment), ' )' ]   ) ].	"Render the annotation."		xmlAnnotation := ( aHumInstructionLine annotation trimBoth isEmpty ) 		ifTrue: [''] 		ifFalse: [ (  calc xml: 'annotation' with: [ ' [ ', (aHumInstructionLine annotation), ' ]' ]   ) ].	"Assemble it without any line breaks."		assembly := xmlRole, xmlStatement, xmlComment, xmlAnnotation.	html := (calc xml: 'InstructionLine' with: [ assembly ]).	^html.! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 5/28/2014 13:02'!renderMarkupAsHTML5: markupSource	"Render the given mark-up text as HTML headings, lists, emphasis." 	| html heading marker remainder level aString |	self assert: (markupSource isKindOf: String ).	"Maintain spacing."	aString := calc given: markupSource replaceAll: '  ' with: '&nbsp;&nbsp;'.		"Is this markup line a heading?"	heading := 'none'.	(1 to: 5)		do: [ :i |			marker := '!!!!!!!!!!' copyFrom: 1 to: i.			( aString beginsWith: marker ) 				ifTrue: [ "Set the heading type and extract the remainder."					heading := 'h', (marker size) asString. 					remainder := (calc given: aString extractAfter: marker ) ]. 			].	"If this is a heading, render the whole line as a heading. "		"Call self recursively to catch any additional emphasis (e.g. italics)"	( heading = 'none'	) ifFalse: [ ^html := calc xml: heading with: (self renderMarkupAsHTML5: remainder).].	"Is this markup line a bullet/numbered list item."		#( '-----' '#####')		do: [ :leaderType |				level := 0.		(1 to: 5 )			do: [ :i |				marker := leaderType copyFrom: 1 to: i.				( aString beginsWith: marker ) 					ifTrue: [ "Set the heading type and extract the remainder."						level := (marker size). 						remainder := (calc given: aString extractAfter: marker ) ]. 				].		( level > 0 )			ifTrue: [				html := ''.				( (lastLevel isNil ) or: [ level > lastLevel ] ) 					ifTrue:[ 						(marker beginsWith: '-') ifTrue: [ self modeStack push: 'ul'].						(marker beginsWith: '#') ifTrue: [ self modeStack push: 'ol'].						html := '<',(self modeStack top),'>'.						].				"TODO: Figure out how to emit '</ul>' and '</ol>.' -- Might need MODES. (heavens)"				( (lastLevel notNil ) and: [ level < lastLevel ] ) 					ifTrue:[ 						html := '</',(self modeStack top),'>'. 						].				lastLevel := level.				html := html, (calc xml: 'li' with: (self renderMarkupAsHTML5: remainder )).				^html.					].			].		"None of the above"	"Delegate emphasis"	html := self renderMarkupEmphasisAsHTML5: aString.	html := self renderWidgetsInMarkup: html.	^html.			! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 5/28/2014 11:29'!renderMarkupEmphasisAsHTML5: aString 	"Render bold, italic, underscore emphasis."	| wip between before after |  self assert: ( aString isKindOf: String ).	(( aString includes: $*) or: [ (aString includes: $~) or: [ aString includes: $_]])		ifFalse: [^aString].	"Initialize work-in-progress."	wip := aString.	('*_*_*' matches: wip )		ifTrue: [ "become *<u>*</u>*"			between := calc given: wip extractBetween: '_' and: '_'. 			before  := calc given: wip extractUpto: '_'.			after   := calc given: wip extractAfterSecond: '_'.			wip := before, '<u>', between, '</u>', after.			].	('*~*~*' matches: wip )		ifTrue: [ "become *<i>*</i>*"			between := calc given: wip extractBetween: '~' and: '~'. 			before  := calc given: wip extractUpto: '~'.			after   := calc given: wip extractAfterSecond: '~'.			wip := before, '<i>', between, '</i>', after.			].	"Cannot use #matches: for asterisk case. So we use this trick:"	((HumCalculator substringFrom: wip after: '*' before: '*') = '')		ifFalse: [			between := HumCalculator substringFrom: wip after: '*' before: '*'.			before := calc given: wip extractUpto: '*'.			after   := calc given: wip extractAfterSecond: '*'.			wip := before, '<b>', between, '</b>', after.			].		^wip.! !!HumOntologyViewer methodsFor: 'render frame line' stamp: 'RichardAlexanderGreen 5/28/2014 11:43'!renderWidgetsInMarkup: aSourceString 	"Return HTML5 equivalent of the widgets found in this mark-up line."	|  between before after wip |	wip := aSourceString.	"Match button."	( '*[[*]]*' matches: wip )		ifTrue: [			between := calc given: wip extractBetween: '[[' and: ']]'.			before := calc given: wip extractUpto: '[['.			after  := calc given: wip extractAfter: ']]'.			wip := before,'<button name="',between,'" />',after.			"Get all the buttons before we go on."			wip := self renderWidgetsInMarkup: wip.			].	"Match check-box" 	( '*[#]*' matches: wip )		ifTrue: [ 			between := calc given: wip extractBetween: '[' and: ']'.			before := calc given: wip extractUpto: '['.			after  := calc given: wip extractAfter: ']'.			wip := before,'<input name="',between,'" type="checkbox"/>',after.			"Get all the check-boxes before we go on."			wip := self renderWidgetsInMarkup: wip.			].	"Match other widgets."	( '*[*]*' matches: wip )		ifTrue: [ 			between := calc given: wip extractBetween: '[' and: ']'.			before := calc given: wip extractUpto: '['.			after  := calc given: wip extractAfter: ']'.			       "Name followed by space and digit means multi-line text box"			( between matchesRegex: '^.*\b\d$'  )				ifTrue: [ | name d |					name := calc given: between extractUpto: ' '.					d := calc given: between extractAfter: ' '.					wip := before,'<textarea name="',name,'" rows=',d,' cols=60 /></textarea>',after.]				ifFalse: ["Not a textarea . . ."					"TODO: If the attribute-name is plural, render as a table."					| noun |					noun := between.					(ontology isPluralNoun: noun)						ifFalse: [wip := before,'<input name="',between,'" />',after.]						ifTrue:  [wip := before, (self generateHtmlTableFor: noun ), after.].					].			"TODO: Special handling for other types: category, date-time, measure."			].	"Match radio-button"		( '*(#)*' matches: wip )			ifTrue: [ 			between := calc given: wip extractBetween: '(' and: ')'.			self assert: ((between size) = 1).			before := calc given: wip extractUpto: '('.			after  := calc given: wip extractAfter: ')'.			wip := before,'<input name="',between,'" type="radio"/>',after.			"TODO: Need <group> tags. HOW ARE WE GOING TO DO THAT?"			].			"If no widgets were found in this pass: Return;  Otherwise: Iterate."	( wip = aSourceString ) 		ifTrue: [ ^aSourceString.]		ifFalse: [ ^ self renderWidgetsInMarkup: wip ].	! !!HumOntologyViewer methodsFor: 'render statement' stamp: 'RichardAlexanderGreen 3/2/2014 11:34'!renderStatement: aHumStatement   "Pretty-print statement as HTML"	^self renderStatement: aHumStatement keywords: 'if then else for for-each'.	! !!HumOntologyViewer methodsFor: 'render statement' stamp: 'RichardAlexanderGreen 3/2/2014 11:37'!renderStatement: aHumStatement keywords: keywords 	| tokenTypes html token type fragment |	html := ''.	tokenTypes := ontology parseStatement: aHumStatement keywords: keywords.	tokenTypes		do: [ :tokenType |   "For each token-type:"			token := tokenType key.			type := tokenType value.			fragment := ''.			"Assign a tag that the CSS can then style."			( type = #word ) ifTrue: [ fragment := ' ', token ].			( type = #noun ) ifTrue: [ fragment := ' <n>', token, '</n>' ].			( type = #keyword ) ifTrue: [ fragment := ' <k>', token, '</k>' ].			( type = #role ) ifTrue: [ fragment := ' <r>', token, '</r>' ].			"Just another token with no particular type."			( fragment = '' ) ifTrue: [ fragment := token ].			html := html, fragment.			].	^html! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumOntologyViewer class	instanceVariableNames: ''!!HumOntologyViewer class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 5/28/2014 13:07'!ontology: aHumOntology 	| instance |	instance := self basicNew.	instance initialize.	instance ontology: aHumOntology.	^instance.! !HumFrameLine subclass: #HumDictionaryLine	instanceVariableNames: 'statement comment'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumDictionaryLine commentStamp: 'RichardAlexanderGreen 9/28/2012 11:17' prior: 0!A dictionary line is a line in a dictionary frame.The statement in a dictionary line must conform to the dictionary DSL.Instance Variables:	statement	<HumStatement>	comment	<String>!!HumDictionaryLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/9/2012 14:36'!comment	^ comment ifNil: [ comment := String new. ].! !!HumDictionaryLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/9/2012 14:33'!source	"Construct a source line based on convention and content of my attributes."	| s |	s := self statement asString.	(self comment isEmpty) ifFalse: [ s := s, ( self comment ) ].	^ s. ! !!HumDictionaryLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/9/2012 14:35'!statement	^ statement! !!HumDictionaryLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/9/2012 14:38'!statement: aStatementString 	statement := HumStatement from: aStatementString.! !!HumDictionaryLine methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 1/13/2012 16:50'!getListAfter: aString 	| s sAfter list |	s := self statement source.	sAfter := HumCalculator substringFrom: s after: aString. 	list := sAfter findTokens: ', .'.	"Remove the word 'and' from the list."	list removeAllSuchThat: [ :item | item sameAs: 'and' ].	^list.! !!HumDictionaryLine methodsFor: 'testing' stamp: 'RichardAlexanderGreen 2/28/2014 12:10'!compileLineToOntology: aHumOntology 	"Add nouns and noun-relations to the ontology.	If statement does not match a dictionary statement pattern,	return an error.	"	| lineErrors s entity attributes subtype supertypes |	"We may discover syntax errors while compiling.	 Return an empty list when statement matches okay.	"	lineErrors := OrderedCollection new. 		s := self statement source.		( '*is a*' matches: s )		ifTrue: [ subtype := ( s findTokens: ' ' ) at: 1.				supertypes := self getListAfter: 'is a'.				self assert: ( supertypes size = 1 ).				aHumOntology addNoun: subtype isA: ( supertypes at: 1 ). 				^lineErrors.				].	( '*attributes include*' matches: s ) 		ifTrue: [ attributes := self getListAfter: 'include'.			entity := ( s findTokens: ' ' ) at: 1.			aHumOntology addEntity: entity attributes: attributes.			^lineErrors. 			 ].		(( '*includes a set of*' matches: s )	  or: [ '*has a set of*' matches: s  ] )		ifTrue: [ | attribute |			     attribute := ( self getListAfter: 'a set of' ) at: 1.				entity := ( s findTokens: ' ' ) at: 1.				aHumOntology addEntity: entity attribute: attribute.				aHumOntology addNoun: attribute isA: 'set'.				^ lineErrors.				].	(( '*includes a list of*' matches: s )	  or: [ '*has a list of*' matches: s ] )		ifTrue: [ |attribute| 				attribute := ( self getListAfter: 'a list of' ) at: 1.				entity := ( s findTokens: ' ' ) at: 1.				aHumOntology addEntity: entity attribute: attribute.				aHumOntology addNoun: attribute isA: 'list'.				^ lineErrors.				].	"If we fall through to here, 	 the statement was not matched to any dictionary statement pattern."			lineErrors add:( 'Dictionary statement not understood: ', s).			^ lineErrors.! !Object subclass: #HumFrame	instanceVariableNames: 'frameLines titleLine ontology uniqueIdentifier'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame commentStamp: 'RichardAlexanderGreen 9/19/2012 10:41' prior: 0!A "frame" is a small amount of program code in the ontology.Different types of frames contain different types of information and conform to different notations.A frame has a title and contains a list of frame-lines.Instance Variables:	frameLines	<OrderedCollection>	titleLine	<Object>	ontology	<HumOntology>	uniqueIdentifier	<UUID>!!HumFrame methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 1/9/2012 12:58'!linesAsHTMLwithOntology: anOntology	| html cr |	cr := String cr.	html := cr.	self frameLines 		do: [ :frameLine |				html := html, '<br/>', ( frameLine asHTML5withOntology: anOntology ) ].	^html.! !!HumFrame methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 3/3/2014 10:13'!prettyPrintWithOntology: aHumOntology	"Pretty-print using HTML5 and CSS	--  This is a read-only view for ontology code listing."	| html calc |	self delegated.	calc := HumCalculator new.	html :=	calc xml: 'frame'		with: [			(calc xml: 'frameTitle' with: [  self titleLine asString ]),			(self linesAsHTMLwithOntology: aHumOntology)			].	^html.	! !!HumFrame methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 1/16/2012 15:00'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		"nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);"		nextPutAll: title;		nextPutAll: '( ', self frameName, ' )';		nextPutAll: String cr.! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 19:49'!addFrameLine: aSourceString	self frameLines add: aSourceString.! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 19:48'!frameLines	^frameLines ifNil: [ frameLines := OrderedCollection new.]! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2012 11:04'!frameName	"The name of the frame is guaranteed to be a string.	Generally, it is the same as the titleLine.	"	| frameName |	frameName := (self titleLine) asString.	^ frameName.! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 13:33'!ontology	^ ontology! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 13:33'!ontology: anObject	ontology := anObject! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/24/2013 20:39'!title	^ self titleLine ! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2012 10:13'!titleLine	^ titleLine ! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2012 10:13'!titleLine: anObject	titleLine := anObject asString! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/2/2012 13:16'!uniqueIdentifier	"Note: Lazy initialization for this identifier."	^ uniqueIdentifier ifNil: [ uniqueIdentifier := UUID new. ].! !!HumFrame methodsFor: 'testing' stamp: 'RichardAlexanderGreen 3/30/2012 10:38'!checkSyntaxWithOntology: anOntology	| frameErrors lineErrors    |	frameErrors := OrderedCollection new.	"Check stand-alone syntax.	Detect statements with no nouns.	Detect statements that have not been defined.	"	self frameLines		do: [ :frameLine | 			lineErrors := (frameLine checkSyntaxWithOntology: anOntology).			(lineErrors isEmpty) ifFalse: [ frameErrors := frameErrors, lineErrors ].			].	^frameErrors.! !!HumFrame methodsFor: 'testing' stamp: 'RichardAlexanderGreen 8/22/2013 15:25'!compileToOntology: aHumOntology 	| problems lineProblems |	problems := OrderedCollection new.	self frameLines		do: [ :frameLine |			lineProblems := ( frameLine compileLineToOntology: aHumOntology ).			problems := problems, lineProblems.			].	"Regardless of errors add frame to the ontology."		aHumOntology storeFrame: self.	^problems.! !!HumFrame methodsFor: 'translating' stamp: 'RichardAlexanderGreen 3/3/2014 10:06'!delegated.	Error signal: 'Should be implemented in Ontology Viewer (HumOntologyViewer)'.! !!HumFrame methodsFor: 'debugging' stamp: 'RichardAlexanderGreen 3/3/2014 10:38'!delegateToTranslator	Error signal: 'This frame function should be delegated to HumOntologyTranslator.'! !HumFrame subclass: #HumFrame4Action	instanceVariableNames: 'role actionStatement instructions'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4Action commentStamp: 'RichardAlexanderGreen 9/19/2012 10:50' prior: 0!Action frames define the steps (instructions) in an action.An action belongs to a role.Actors may be assigned to a role at run-time.Such actors have a set of action-statements as their external interface.In that sense, they "know" the role.The format of an action frame looks like this:---Role: Cook.Action: Preheat oven to recipe temperature.. (Delegate to oven's robot.). Oven: Set temperature to recipe temperature.. (Proceed with other actions while oven comes up to heat.)Action: Mix ingredients per recipe.. For each ingredient in recipe ingredients:. . Add ingredient quantity to mixing-bowl.. Stir contents of mixing-bowl for 5 minutes.---Instance Variables:	role	<String>	actionStatement	<HumStatement>	instructions	<OrderedCollection>!!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/13/2012 14:23'!actionStatement	^ actionStatement ifNil:[ Error signal: 'Action frame must have an action statement']. ! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/13/2012 14:25'!actionStatement: anObject	actionStatement := nil.	(anObject isKindOf: String) ifTrue: [ actionStatement := HumStatement from: anObject ].	(anObject isKindOf: HumStatement ) ifTrue: [ actionStatement := anObject ].	self assert: ( actionStatement isKindOf: HumStatement ).	! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!addInstructionRole: aRole statement: aStatement 	| frameLine |	frameLine := ( HumInstructionLine role: aRole statement: aStatement ).	self instructionLines add: frameLine.	self frameLines add: frameLine.! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!addInstructionRole: aRole statement: aStatement comment: aComment		| actionInstruction |		actionInstruction := HumInstructionLine new.	actionInstruction role: aRole; statement: aStatement; comment: aComment.		self instructionLines add: actionInstruction.	self frameLines add:  actionInstruction .! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!addInstructionStatement: aSource 	| actionInstruction |		actionInstruction := HumInstructionLine new.	actionInstruction role: ''; statement: aSource; comment: ' '.		self instructionLines add: actionInstruction.	self frameLines add:  actionInstruction .! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/23/2012 07:35'!instructionLines	^ instructions ifNil: [ instructions := OrderedCollection new ].! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 18:02'!instructions	^ instructions ifNil: [ instructions := OrderedCollection new. ].! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 20:44'!instructions: anObject	instructions := anObject! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 20:45'!role	^ role! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 20:45'!role: anObject	role := anObject! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/6/2012 15:34'!titleLine	^ ( self role), ': ', ( self actionStatement asString ).! !!HumFrame4Action methodsFor: 'testing' stamp: 'RichardAlexanderGreen 11/7/2012 12:12'!checkSyntaxWithOntology: anOntology 	"Critique the instructions for this role action."	|  critique lineCritique action actionNouns |			"Return the critique as a sequence of strings."	critique := OrderedCollection new.		"The action should contain at least one noun."	action := self actionStatement.	actionNouns := anOntology nounsInStatement: action.	( actionNouns size > 0 ) 		ifFalse: [ critique add: ( 'Action statement {',( action asString ),'} has no known nouns!!' ) ].			"There should be at least one instruction for the action statement."			( self instructionLines size > 0 )		ifFalse: [ critique add: 'Action has no instructions.'].				"Nouns in the instructions should find antecedants in the action statement."	(self instructionLines) 		do: [ :instruction | 			lineCritique := ( instruction checkSyntaxWithOntology: anOntology ).			critique := critique, lineCritique.			lineCritique := ( instruction checkForAntecedantsIn: (self actionStatement) withOntology: anOntology ).			critique := critique, lineCritique.						]. 	"TODO: The line after  'For . . .  : ' or  'If . . .  : '  or 'Else:' should be indented."		"TODO: Think about how indentation should be assured. 	In the editor context, the indentation should be automatic.	Note: Indentation is an attribute of an instrution line.	"	^critique.! !!HumFrame4Action methodsFor: 'testing' stamp: 'RichardAlexanderGreen 2/12/2014 10:23'!compileToOntology: aHumOntology 	"Compile the frame into the ontology."	| |	"Add the role-action"		aHumOntology addRole: self role action: self actionStatement.	"Add the instruction sequence"	(self instructionLines )		 do: [ :instruction |			aHumOntology addRole: (self role) action: (self actionStatement ) instruction: instruction.			(instruction role sameAs: '') 				ifFalse: [ "(ontology frameRelations) add: { self title. #invokesAction. instruction title.}"						ontology indexFrame: self relation: #invokesAction object: (instruction title). ].			].	"Return no errors."		^ (self checkSyntaxWithOntology:  aHumOntology ).		 	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrame4Action class	instanceVariableNames: ''!!HumFrame4Action class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 9/15/2012 10:55'!ontology: aHumOntology role: aRole action: anActionStatement  	| frame |	frame := HumFrame4Action new.	frame ontology: aHumOntology; 		role: aRole;		actionStatement: anActionStatement.	^frame.	! !HumFrame subclass: #HumFrame4Vignette	instanceVariableNames: 'vignetteContext responseLines instructionLines nextContext patterns'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4Vignette commentStamp: 'RichardAlexanderGreen 9/19/2012 11:08' prior: 0!A dialog contains a set of contexts.A context contains a set of vignettes.A vignette defines a stimulus and a response.The stimulus is a prioritized set of patterns which will be matched against client statements.When a pattern is matched the response is executed.The response may include a speech and/or a short set of instructions.Dialog instructions are addressed to the dialog-agent unless specified otherwise with a role-prefix.The dialog agent maintains a 'stack' of contexts.The contexts nearest the top of the stack have priority when attempting to match client statements.The stack is generally ordered with the most recently used contexts nearest the top.A dialog vignette may command that another context be placed at the top in order to switch contexts.In general, dialogs are organized by the same principles as ALICE chat bots.Instance Variables:	vignetteContext	<Collection | UndefinedObject>	responseLines	<OrderedCollection>	instructionLines	<OrderedCollection>	nextContext	<Collection | UndefinedObject>	pattern	<Collection | UndefinedObject>!!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/14/2013 10:53'!addPattern: aPatternString 	"Enter a pattern -- What pattern will the vignette respond to?"	(self patterns) add: aPatternString.! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/9/2014 16:02'!addVignetteInstruction: anInstructionLine 	"Append an instruction to be executed in response to the user / client."	| instruction |	( anInstructionLine isKindOf: HumInstructionLine )		ifTrue: [ instruction := anInstructionLine ]		ifFalse: [ instruction := ( HumInstructionLine statement: anInstructionLine).].		(self instructionLines ) add: instruction.	(self frameLines ) add: instruction.! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2013 08:21'!addVignettePattern: patternString 	"Append an Pattern to be executed in response to the user / client."	|  |	(self patterns ) add: patternString.	(self frameLines ) add: patternString.! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/15/2012 10:58'!addVignetteResponse: aResponseString 	"Append a verbal response line."	| markup |	markup :=  ( HumMarkupLine source: aResponseString ).	self responseLines add: markup.	self frameLines add: markup.! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/19/2012 07:33'!instructionLines	"Return the vignette's instruction lines. "	^ instructionLines ifNil: [ instructionLines := OrderedCollection new. ].! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2012 13:47'!nextVignetteContext	"By default, the next context is the current context."	( nextContext isEmptyOrNil )  ifTrue: [ nextContext := vignetteContext ].	^ nextContext.! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/19/2012 07:32'!nextVignetteContext: aContextName 	"What will be the context after the response is rendered?	The context stack prioritizes responses to otherwise identical user patterns.	"	nextContext := aContextName.! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2013 08:22'!patternFields: pattern	"Parse the pattern and return the [noun] fields - including the brackets."	| fields s field |	fields := OrderedCollection new.	s := self pattern.	self assert: ( s isKindOf: String ).	[ field := HumCalculator substringFrom: s after: '[' before: ']'.  ( field size > 0 )  ]		whileTrue: [  fields add: ( '[', field, ']' ). 						s := HumCalculator substringFrom: s after: ']'.					 ].	^fields.	! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2013 08:23'!patternNouns: pattern	"Parse the pattern and return the nouns referenced in [noun] fields. 	When the pattern is recognized, the noun value will be placed on the dialog's blackboard.'	"	| fields s field |	fields := OrderedCollection new.	s := pattern.	self assert: ( s isKindOf: String ).	[ field := HumCalculator substringFrom: s after: '[' before: ']'.  ( field size > 0 )  ]		whileTrue: [  fields add: (  field ). 						s := HumCalculator substringFrom: s after: ']'.					 ].	^fields.	! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/26/2013 09:04'!patterns	^ patterns ifNil: [ patterns := OrderedCollection new ].! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/19/2012 07:40'!responseLines	"What will be the verbal response? "	^ responseLines ifNil: [ responseLines := OrderedCollection new. ].! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/8/2013 09:56'!titleLine	^ 'context: ', ( vignetteContext asString), ' patterns: ', ( (patterns at: 1) asString ).! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2012 13:49'!vignetteContext	"The context is used to prioritize responses when two or more patterns match a user input.	It also provides a category seen when viewing the collection of vignettes.	"	( vignetteContext isEmptyOrNil ) ifTrue: [ Error signal: 'A vignette context is missing.'].	^ vignetteContext! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/19/2012 07:42'!vignetteContext: aContextString 	"The context is used to prioritize responses when two or more patterns match a user input.	It also provides a category seen when viewing the collection of vignettes.	"	vignetteContext := aContextString. ! !!HumFrame4Vignette methodsFor: 'testing' stamp: 'RichardAlexanderGreen 8/14/2013 10:58'!checkSyntaxWithOntology: anOntology	"Check the vignette for syntax problems."	| critique patternCritique nouns |	"First get the critique of the frame lines."	critique := super checkSyntaxWithOntology: anOntology.	patternCritique := OrderedCollection new.		"The vignette must have a context and a pattern."	( vignetteContext isEmptyOrNil  ) ifTrue: [ critique add: 'Vignette has no context!!' ].	( patterns isEmptyOrNil ) ifTrue: [ critique add: 'Vignette has no pattern!!' ].				"The nextContext should be known to the ontology."	(( anOntology vignettesForContext: ( self nextVignetteContext ) ) isEmpty )
		 ifTrue: [ critique add: 'Vignette`s next context {',( self nextVignetteContext ),'} is unknown in ontology. ' ].		"Each [noun] field  in the pattern should reference known nouns."	nouns := self patternNouns.	nouns 		do: [ :noun | 			(anOntology isNoun: noun) 				ifFalse: [ patternCritique add: 'Vignette pattern references unknown noun: ', noun.]  			].		critique := critique, patternCritique.		^critique.! !!HumFrame4Vignette methodsFor: 'testing' stamp: 'RichardAlexanderGreen 2/12/2014 11:12'!compileToOntology: anOntology	"Update the ontology with this vignette."		anOntology addVignette: self toContext: (self vignetteContext ).		"Index any external action calls."	( self instructionLines )		do: [ :instructionLine |			( instructionLine role = '' )				ifFalse: [ "(ontology frameRelations) add: { (self title). #invokesAction. ( instructionLine title ).}. "						ontology indexFrame: self relation: #invokesAction object: (instructionLine title)]				ifTrue: ["Index 'Show view' and 'Ask view' cases."					| sourceString |					sourceString := instructionLine statement source.					(sourceString beginsWith: 'Ask')						ifTrue: [ |viewName|							viewName := (HumCalculator substringFrom: sourceString after: 'Ask' before: '.') trimBoth asLowercase.							ontology indexFrame: self relation: #invokesView object: viewName. 							].					(sourceString beginsWith: 'Push context')						ifTrue: [ |contextName|							contextName := (HumCalculator substringFrom: sourceString after: 'Push context' before: '.') trimBoth asLowercase.							ontology indexFrame: self relation: #invokesContext object: contextName. 							].					].			].		^ ( super compileToOntology: anOntology ) .! !!HumFrame4Vignette methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 8/16/2013 15:14'!patternMatchScore: aString	"How well does the string (from client) match the pattern int this vignette?	Score a point for each token matched in order.	"	| points bestPatternPoints  |	points := 0.	bestPatternPoints := 0.		"But first, one pattern has to match. Then we score it."	( self patterns	)		do: [:pattern |			| patternTokens inputTokens  xInput xPattern |			self assert: [ pattern isKindOf: String ].			"Remove noise words and punctuation"			patternTokens := (HumCalculator justTheWordsIn: pattern).			inputTokens   := (HumCalculator justTheWordsIn: aString).			"Put back the end-of-statement stopper."			patternTokens add: '.'.			inputTokens add: '.'.			"Attempt to match input to pattern."			xInput := 1.			xPattern := 1.			[ xPattern <= patternTokens size ]				whileTrue: [ "For each pattern token"						| continue patternToken inputToken |						continue := true.						patternToken := patternTokens at: xPattern.						(patternToken = '*') 							ifTrue: ["Match everything upto next pattern token"								| nextPatternToken xNextInput  |								nextPatternToken := patternTokens at: (xPattern + 1).								"Does the remaining input have the next pattern token?								If not, we are done scoring. 								"								xNextInput := inputTokens indexOf: nextPatternToken startingAt: xInput ifAbsent: [ -1 ].								( xNextInput < 0 )									ifTrue: ["Match fails. Force to next pattern."										points := 0.  "TODO:  No credit for partial match?"										xPattern := 9999.										continue := false.										]									ifFalse: ["Matching so far. Continue to next pattern token."										xInput := xNextInput.										xPattern := xPattern + 1.										points := points + 1.										].																continue := false.								].						(continue and: [ patternToken = '[' ])							ifTrue: ["Assign the next inputToken to the noun named between [...]"								| xNextPattern | 								"TODO: HOW SHOULD WE INTERPRET THIS?								Will we assign the next input to the noun value								or require the next input to match the noun value?								TODO: HOW SHOULD WE SCORE THIS?								"								"For now, assume the next input token matches the bracket expression."								"Advance the pattern token index to the closing bracket."								xNextPattern := patternTokens indexOf: ']' startingAt: xPattern ifAbsent: [Error signal: 'no closing bracket?'].								xPattern := xNextPattern.								points := points + 1.								continue := false.								].						inputToken := inputTokens at: xInput.						(continue and: [ patternToken sameAs: inputToken ])							ifTrue: ["Increment the score"								points := points + 1.								continue := false.								].							(continue)							ifTrue: ["The input token does not match the pattern."								"Force out to the next pattern."								points := 0.								xPattern := 9999.								].						xInput := xInput + 1.							xPattern := xPattern + 1.							((xInput > inputTokens size) and: [ xPattern <= patternTokens size ])							ifTrue: ["We ran out of input before we ran out of pattern."								"Force out to the next pattern."								points := 0.								xPattern := 9999.								].						]. "Each token"				 ( points > bestPatternPoints ) ifTrue: [ bestPatternPoints := points ].			]. "Each pattern"	^ bestPatternPoints.! !!HumFrame4Vignette methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 8/14/2013 11:52'!patternNouns	| nouns |	nouns := Set new.	( self patterns )		do: [ :pattern |			nouns := nouns addAll: (self patternNouns: pattern ).			].	^ nouns.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrame4Vignette class	instanceVariableNames: ''!!HumFrame4Vignette class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 8/14/2013 10:54'!ontology: aHumOntology vignetteContext: aContextString pattern: aPatternString 	| frame |	frame := self new.	frame ontology: aHumOntology;				vignetteContext: aContextString;				 addPattern: aPatternString.	^frame. 		! !HumFrame subclass: #HumFrame4Plan	instanceVariableNames: 'goal preconditions planActions'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4Plan commentStamp: 'RichardAlexanderGreen 9/19/2012 10:57' prior: 0!Plan frames define plan-fragments.A plan frame has a goal-statement (a post condition) and a set of preconditions.The action list defines zero or more actions that implement the transition from the preconditions to the post condition.The action list will not execute until the preconditions are all met.Instance Variables:	goal	<HumStatement>	preconditions	<Set>	planActions	<Set>!!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/19/2013 17:32'!actionStatements	^self planActions.! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!addInstructionRole: aRole statement: aStatement 	| instruction |	instruction :=  ( HumInstructionLine role: aRole statement: aStatement ).	self planActions add: instruction.	self frameLines add:  instruction.! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/23/2013 09:36'!addPrecondition: aSource 	| precondition |	precondition := (HumConditionLine new) statement: aSource.	self assert: ( precondition isKindOf: HumConditionLine ).	self preconditions add: precondition.	self frameLines add: precondition.! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/23/2013 11:08'!addRole: aRole action: aSource 	| actionInstruction |		actionInstruction := HumInstructionLine new.	actionInstruction role: aRole; statement: aSource; comment: nil.		self planActions add: actionInstruction.	self frameLines add:  actionInstruction .! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/23/2013 11:09'!addRole: aRole action: aSource comment: aComment	| actionInstruction |		actionInstruction := HumInstructionLine new.	actionInstruction role: aRole; statement: aSource; comment: aComment.		self planActions add: actionInstruction.	self frameLines add:  actionInstruction .! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/30/2011 14:19'!goal	"Get the plan frame's goal statement."	^ goal! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/19/2013 17:30'!goal: aSource 	"This instance variable contains the plan frame's goal statement."	| goalStatement |  ( aSource isKindOf: String ) ifTrue: [ goalStatement := HumStatement from: aSource.].  ( aSource isKindOf: HumStatement ) ifTrue: [ goalStatement := aSource.].	goal := goalStatement.	titleLine := 'Goal: ', goalStatement source.! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/25/2014 09:38'!planActions  "A sequence of actions to be performed after preconditions are satisfied.   Generally, a single action is better form, but multiple actions are allowed.   Multiple actions will be performed in the sequence given by the author.  "	^ planActions ifNil: [ planActions := OrderedCollection new. ].! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/25/2014 09:36'!preconditions	"Preconditions are ordered to preserve the author`s sequence,	and to make locally-run unit test sequences repeatable. 	However, during actual runtime execution, 	  preconditions will be executed asynchronously	  with dynamic scheduling.	Required sequences should be indicated by the plan tree structure or via Action procedure.	"	^ preconditions ifNil: [ preconditions := OrderedCollection new ].! !!HumFrame4Plan methodsFor: 'testing' stamp: 'RichardAlexanderGreen 5/29/2012 19:12'!check	"Check the basic integrity of the plan frame."	| problems |	"The callers sees the problems in the same order we do."	problems := OrderedCollection new.	"The plan frame must have a goal."	( self goal isNil ) 		ifTrue: [ problems add: 'A plan frame must have a goal.']		ifFalse: [ ( self goal source size > 5 ) 						ifFalse: [ problems add: 'A plan frame must have a goal.' ].				 ].		"A plan frame should have at least two preconditions."	(( self preconditions size ) > 1) ifFalse: [ problems add: 'A plan frame should have at least two preconditions.' ].	^problems.! !!HumFrame4Plan methodsFor: 'testing' stamp: 'RichardAlexanderGreen 3/30/2012 10:37'!checkSyntaxWithOntology: anOntology	| frameErrors lineErrors    |	frameErrors := OrderedCollection new.	"Check stand-alone syntax.	Detect statements with no nouns.	Detect statements that have not been defined.	"	self frameLines		do: [ :frameLine | 			lineErrors := (frameLine checkSyntaxWithOntology: anOntology).			(lineErrors isEmpty) ifFalse: [ frameErrors := frameErrors, lineErrors ].			].	"Check data flow. 	Each statement's nouns must have antecedants in the goal statement."	self frameLines		do: [ :frameLine |			lineErrors := (frameLine checkForAntecedantsIn: (self goal) withOntology: anOntology ).			(lineErrors isEmpty) ifFalse: [ frameErrors := frameErrors, lineErrors ].			].	^frameErrors.! !!HumFrame4Plan methodsFor: 'testing' stamp: 'RichardAlexanderGreen 2/12/2014 10:25'!compileToOntology: aHumOntology 	"Check the basic integrity of the plan frame.	If it is viable, put it into ontology."	| problems |	"The callers sees the problems in the same order we do."	problems := self checkSyntaxWithOntology: aHumOntology.			"A plan frame should have at least two preconditions."	(( self preconditions size ) > 1) ifFalse: [ problems add: 'A plan frame should have at least two preconditions.' ].		"The plan frame must have a goal."	( self goal isNil ) 		ifTrue: [ problems add: 'A plan frame must have a goal.']		ifFalse: [ ( self goal source size > 5 ) 						ifFalse: [ problems add: 'A plan frame must have a goal.']						ifTrue: [ "Looks like we have a goal"							aHumOntology addPlanFrame: self ForGoal: (self goal source).								"If the frame has a goal, store the frame regardless of errors."							aHumOntology storeFrame: self.							] .				].	"Compile the preconditions"			(self preconditions)		do: [ :precondition | 				| thisProblem |				 thisProblem := precondition compileLineToOntology: aHumOntology.				 problems := problems, thisProblem. 				"Index the precondition"				 "aHumOntology frameRelations add: { (self title). #precondition. (precondition statement asString). }."				ontology indexFrame: self relation: #precondition object: (precondition statement asString).				"TODO: Decide if we want the title or the frame itself. (frame reference)"				"Note: The title may change when the goal statement is edited. However, recompile should fix."				"Note: Our structure could enable changing definition, changes all references."				].		"Compile the actions"			( self actionStatements )		do: [ :action | 				| thisProblem |				 thisProblem := action compileLineToOntology: aHumOntology.				 problems := problems, thisProblem. 				"Index the precondition"				 "aHumOntology frameRelations add: { (self title). #invokesAction. ( action titleLine ). }."				 ontology indexFrame: self relation: #invokesAction object: (action titleLine).				 ].		^problems.! !!HumFrame4Plan methodsFor: 'testing' stamp: 'RichardAlexanderGreen 11/7/2012 12:04'!isNoPlan	"Frame is no plan if there are no preconditions and no actions.	Either the preconditions or the action may be empty, but not both.	However, both could have the statement: 'None.' to indicate that the programmer	has not simply forgotten this frame.	Comment: If goal appears as a precondition elsewhere,	. but has no preconditions and no action needed to make it true,	. it could be annotated as [Assumed.] where it appears as a precondition	. and then no frame would be required for it.	TODO: Think about a feature 	. where a precondition marked [Assumed] in one context 	. is automatically marked [Assumed] everywhere.	"	self preconditions isEmpty		ifFalse: [ ^false ].	self planActions isEmpty		ifFalse: [ ^false ].	^true.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrame4Plan class	instanceVariableNames: ''!!HumFrame4Plan class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 9/15/2012 10:56'!ontology: aHumOntology goal: aGoalStatement	| frame | 	frame := HumFrame4Plan new.	frame ontology: aHumOntology;			goal: aGoalStatement.			^frame.! !HumFrameLine subclass: #HumMarkupLine	instanceVariableNames: 'lastLevel'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumMarkupLine commentStamp: 'RichardAlexanderGreen 4/18/2014 17:27' prior: 0!A markup line may occur within a view or a dialog vignette response.In those contexts, a mark-up line is a line that does not begin with a period.(Lines that begin with a period contain instructions to be exectuted by the dialog agent or rendering engine.)The content of the line will be rendered when the view or response is rendered. Hum mark-up uses the following notations:Outline Mark-Up:  (outlines are indicated by a line that begins with a specific special character.)!! a level one heading!!!! a level two heading -- an so on up to level 5.- a bullet at first level of outline-- a bullet at second level of outline -- an so on up to 5 levels --- a bullet at third level of outline -- note that a line that begins with three underscores (___) indicates a horizontal rule (or a splitter)# a numbered outlline - first level## a numbered outline - second level -- and so on up to 5 levels.Text Emphasis:  Text substrings may be emphasized by surrounding the substring as follows:    *bold*    ~italic~    _underline_Widget Mark-Up: [widget] -- a widget is enclosed in square brackets. Widgets are used in interactive contexts. [[button]] -- a button is a widget. The dialog speech-act intended must be defined in a following instruction. [a] -- a widget containing a single character indicates a check-box. The intended action must be defined in a following instruction. (a) -- a radio button. Then intended action must be defined in a following instruction. [type: string ] -- The type indicates the rendering intended.                           Example: [range: utilization ] might render as a meter, or bar, or spinner, depending on the rendering engine and its style rules.Widget Actions:  [attribute] -- The widget names an attribute. The current value (if any) of the attribute is rendered.                 The rendering engine will provide an appropriate widget depending on the type of the attribute.                 For example, a category may be rendered with a pull-down list, text with a text-area, date with a date selector.  [page: title] -- The internal page with the given title is linked.  [link: blah blah | URI ] -- "blah blah" is displayed. The URI links to an external resource.  [pane: title] -- The Hum view frame with the matching title will be rendered at this position.                         More elaborate layouts are achieved by placing panes within panes.Tables:  (These are used to list the content of an entity's collection attributes.)  The columns of the table are indicated by attribute names separated by pipe '|' characters.  Here is an example where an order entity has a list attribute called order-lines.. Table of order-lines.| catalog-id | description | quantity | unit-price | %%%%%%%%%%%%%%% Summary %%%%%%%%%%%%%%%%%%%%%%%%%%	 . Known widget types include 	 . . [page:  TITLE ] -- Link to local page (a la wiki)	 . . [link: TITLE | URL] -- Link to a remote page given by the URL/URI	 . . [pane: TITLE] -- Insert given pane	 . . [range: LB - UB ] -- Provide a slider or similar device on input; a progress bar on output.	 . Attribute types with specific rendering should eventually 	 . . [category] [text] [date] [email] -- HTML5 can handle directly	 . . [measure] -- accept and validate quantity, unit-of-measure, plus-or-minus	 . . [collection -- display a table? (default rendering or ???)  !!HumMarkupLine methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 3/3/2014 10:06'!generateCodeOfType: aSymbol fromTokens: tokens at: xToken	"Generate code of the given type HTML/Seaside/JavaScript based on token stream."	| currentToken code cr doubleQuote singleQuote calc |		self delegated.	calc := HumCalculator new.	"Current experiment is to generate HTML5 from Hum mark-up."	self assert: aSymbol = #HTML.	code := String new.	cr := String cr.	"If we ran out of tokens, we are done?"	( xToken > tokens size ) ifTrue: [ ^self ].	currentToken := tokens at: xToken.	"If we are at beginning of line, there are special rules."	( xToken = 1 )		ifTrue: [ "Look for heading, list, or instruction."			(currentToken = '.') 				ifTrue: [ "Line is instruction." "Ignore it for now. Make a comment line as a reminder."					code := '<!!-- ', source, ' -->'.  					^ code.					].			(currentToken = '!!') 				ifTrue: ["Line is heading. But what level?"					| level |					level := 1.					[ (level < (tokens size))  and: [ (tokens at: level + 1 ) = '!!' ] ] whileTrue: [ level := level + 1 ].					"Remainder of line is in this header"					code := calc xml: ('h', (level asString))  with: [ self generateCodeOfType: aSymbol fromTokens: tokens at: level + 1 ] .					^code.					].			(currentToken = '-' ) 				ifTrue: ["Line is list. But what level?"					| level |					level := 1.					[ (level < (tokens size))  and: [ (tokens at: level + 1 ) = '-' ] ] whileTrue: [ level := level + 1 ].					"If level has changed, we need to output <ul> or </ul>"					( level > indentLevel ) ifTrue: [ code := '<ul>', cr. ].					( level < indentLevel ) ifTrue: [ code := '</ul>', cr. ].					"Remainder of line is in this header"					code := code, (calc xml: 'li' with: [ self generateCodeOfType: aSymbol fromTokens: tokens at: level + 1 ]) .					^code.					].				"If we have come this far, the line begins with nothing special."			     "Go on as if we were not on the first token."			].		"Look for quotes -- we need to remove tokens between quotes from translation."		doubleQuote := $".		singleQuote := $".			(currentToken = doubleQuote or: [ currentToken = singleQuote ] )			ifTrue: [ | quote removal x | 				quote := currentToken.				removal := String new.				x := xToken + 1.				[ ( x < (tokens size) ) and: [ tokens at: x = quote ] ] whileFalse: [ removal := removal, (tokens at: x). x := x + 1. ].				code := code, removal, quote, (self generateCodeOfType: aSymbol fromTokens: tokens at: ( x + 1 )   ).				^code.				].		"Look for emphasis -- tokens between are in scope of  . . ."		(currentToken = '*' or: [[ currentToken = '~' ]  or: [ currentToken = '_' ] ] )			ifTrue: [ | emphasis removal x | 				emphasis := currentToken.				removal := String new.				x := xToken + 1.				[ ( x < (tokens size) ) and: [ tokens at: x = emphasis ] ] whileFalse: [ removal := removal, (tokens at: x). x := x + 1. ].				code := code, removal, emphasis, (self generateCodeOfType: aSymbol fromTokens: tokens at: ( x + 1 )   ).				"Note: Above is a bit simplistic. 				It assumes there is nothing to be interpreted in the string between emphasis tokens.				The following would not work properly: *~bold-italic~*  *_bold-and-underlined_*				TBD: Make this smarter.				"				^code.				].		"Look for widgets."		( currentToken = '[' )			ifTrue: [ "What we do depends on the type of widget."				| nextToken |				nextToken := (tokens at: (xToken + 1) ).				( nextToken = 'page' )					ifTrue: [self generatePageWidgetFromTokens: tokens at: nextToken ].				].! !!HumMarkupLine methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 3/3/2014 10:06'!generateHtmlTableFor: aNoun withOntology: anOntology	| singular attributes html  |		self delegated.	singular := anOntology singularFormOfNoun: aNoun.	attributes := anOntology allAttributesOfEntity: singular.	"If the entity has no attributes, generate a default table."	( attributes size = 0 )		ifTrue: [^'<table name="',aNoun,'"><tr><th>',aNoun,' has no attributes in current ontology.</th></tr></table>'].  "Otherwise generate a normal table."	html := '<table name="',aNoun,'" >'.	html := html, '<tr>'.	attributes do: [:attribute | html := html, '<th>', attribute, '</th>'.]. 	html := html, '</tr>'.	html := html, '<tr>'.	attributes do: [:attribute | html := html, '<td>', attribute, ' value </td>'.]. 	html := html, '</tr>'.	html := html, '</table>'.	^html.! !!HumMarkupLine methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 10/7/2013 14:56'!checkSyntaxWithOntology: aHumOntology 	"Syntax errors in mark-up mainly have to do with widgets that won't work.	Other errors will simply be rendered as-is.	"	|  errors widgets widgetNoun |	""	errors := OrderedCollection new.	widgets := self widgets.	"Look for unknown nouns in widgets."	widgets 		do: [ :widget | 			widgetNoun := HumMarkupLine widgetNounIn: widget.			( aHumOntology isNoun: widgetNoun )				ifFalse: [ errors add: ('In {', self source,'} the widget contains unknown noun: ', widgetNoun ) ].			].	"TODO: Look for unknown widget-types in widgets.	 . Known widget types include 	 . . [page:  TITLE ] -- Link to local page (a la wiki)	 . . [link: TITLE | URL] -- Link to a remote page given by the URL/URI	 . . [pane: TITLE] -- Insert given pane	 . . [range: LB - UB ] -- Provide a slider or similar device on input; a progress bar on output.	 . Attribute types with specific rendering should eventually include 	 . . [category] [text] [date] [email] -- HTML5 can handle directly	 . . [measure] -- accept and validate quantity, unit-of-measure, plus-or-minus	 . . [collection -- display a table? (default rendering or ???)	"	widgets		do: [ :widget | 			].		^errors.! !!HumMarkupLine methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 10/8/2013 16:29'!widgets	"Scan the source matching pairs of [. . .] or [[. . .]]."	| widgets  s button widget |	widgets := OrderedCollection new.		s := self source.	"Scan for widgets"			[ widget := HumCalculator substringFrom: s after: '[' before: ']'.	  ( widget size > 0 ) ]		whileTrue: [  "Watch out for [[button label]] pattern."					( widget beginsWith: '[')							ifTrue: [ "This widget looks like a button. Return [[button label]]."								        widgets add: ( '[', widget, ']]' ).								        s := HumCalculator substringFrom: s after: ']]'.											]							ifFalse: [ "This widget does not look like a button. Return [content]." 								         widgets add: ( '[', widget, ']' ). 												s := HumCalculator substringFrom: s after: ']'.											].					 ].	^widgets.! !!HumMarkupLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 9/15/2012 10:58'!compileLineToOntology: aHumOntology 	|  errors widgets widgetNoun |	""	errors := OrderedCollection new.	widgets := self widgets.	"Look for unknown nouns in widgets."	widgets 		do: [ :widget | 			widgetNoun := HumMarkupLine widgetNounIn: widget.			( aHumOntology isNoun: widgetNoun )				ifFalse: [ errors add: ('In {', self source,'} the widget contains unknown noun: ', widgetNoun ) ]				ifTrue: [ 					aHumOntology addNoun: widgetNoun.					aHumOntology addNoun: widgetNoun reference: self.					 ].			].	"Look for unknown widget-types in widgets."	widgets		do: [ :widget | 			].		^errors.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumMarkupLine class	instanceVariableNames: ''!!HumMarkupLine class methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 1/13/2012 15:16'!widgetNounIn: aWidgetString 	"Find the noun in typical field widgets."	| buttonLabel noun s |		"Heuristic: If there is a colon, this is not a field widget. -- Return empty string."	(aWidgetString includes: $: ) ifTrue: [ ^'' ].		"Ignore buttons -- Return an empty string."	buttonLabel := HumCalculator substringFrom: aWidgetString after: '[[' before: ']]'.	(buttonLabel size > 0) ifTrue: [ ^'' ]. 		"s is potential noun -- May need to remove a number-of-lines parameter"	s := HumCalculator substringFrom: aWidgetString after: '[' before: ']'.	(s includes: $ ) 		ifTrue: [ noun := HumCalculator substringFrom: s before: ' ' ]		ifFalse: [ noun := s ].	^noun.! !HumFrame subclass: #HumFrame4Data	instanceVariableNames: 'priorEntityName'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4Data commentStamp: 'RichardAlexanderGreen 9/19/2012 10:54' prior: 0!Data frames provide a notation and means for transferring data between actors.The format is similar to JSON but without the curly brackets.The nesting is indicated by indentation.The notation accomodates tables that populate collection attributes.It also accomdates text (multi-line strings but without formatting) delimited by triple quotes.!!HumFrame4Data methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 2/13/2012 12:55'!asString	| s cr |	cr := String cr.	s := 'Data Frame', cr.	s := s, '---', cr.	( self frameLines )		do: [ :line | s := s, line asString, cr. ].	s := s, '---', cr.			^s.! !!HumFrame4Data methodsFor: 'associating' stamp: 'RichardAlexanderGreen 2/13/2012 12:51'!appendEntity: aEntityName attrribute: anAttributeName value: aValueString 	|  colon indent |	indent := '. '.	colon := ': '.	( ( priorEntityName isNil ) or: [(aEntityName sameAs: priorEntityName) not]  )		ifTrue: [ self addFrameLine: (aEntityName, colon ).				priorEntityName := aEntityName ].	self addFrameLine:  ( indent, anAttributeName, colon, aValueString ).! !Object subclass: #HumOntology	instanceVariableNames: 'nouns nounSubtypes entityAttributes roles roleActions instructionSequences fromFile framesByName framesByIdentifier nounReferences contextVignettes title frames frameRelations viewer translator attributeChain nounCategories'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumOntology commentStamp: 'RichardAlexanderGreen 1/30/2014 12:07' prior: 0!HumOntology is similar to a Smalltalk image file.It records the frames that make up the source code.It also tracks the relationships between syntax elements.Instance Variables:	fromFile	        <String>	-- The name of the file where this ontology was last stored (read).	nouns	        <Set>		-- The nouns known in this ontology	nounSubtypes	  <Set>		-- The subtype relations between nouns 												-- set of ( supertype -> suptype)  associations	entityAttributes  <Set>		-- The attributes of those nouns that represent entity names 													-- set of ( entity -> attribute )	roles	          <Set>		-- The roles defined in this ontology 	roleActions  	  <Set>		-- The actions of the roles 													-- set of ( role -> actionStatement )	instructionSequences   <Dictionary>	-- The instructions that define the actions	framesByName	          <Dictionary>	-- frames indexed by name	framesByIdentifier	    <Dictionary>	-- frames indexed by their unique ID			(An ontology is held in a single file much like the code in a Smalltalk image.)(However, an ontology does not hold run-time state.) An ontology has a set of frames.Token attributes include string.Token types include word, noun, punctuation, keyword, comment, annotation.Frame attributes include frame-title, framelines.Frame types include goal-frame, action-frame, dialog-frame, view-frame, dictionary-frame.Frameline attributes include source, tokens, label, comment.Frameline types include title-line, action-line, precondition-line, markup-line, instruction-line, vignette-line, dictionary-line.Instruction-line attributes include role, statement, comment, annotation.Precondition-line attributes include precondition, commment, annotation.A precondition is a statement.Title-line attributes include label, title, comment. (no annotation)Statement attributes include source, nouns, tokens.Noun attributes include word, supertypes.Noun types include string, category, collection, date, measure, entity, name. (class types)Collection types include set, list. (A collection is a list by default)Measure attributes include quantity, unit-of-measure, distribution, precision.Entity attributes include attributes.Entity-instance attributes include name, values.Value attributes include name, datum.Datum types include string, category, collection, date, measure, entity, name. (instance types)A supertype is a noun.!!HumOntology methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/25/2012 09:44'!file	^ fromFile ifNil: [ fromFile := 'HumOntologyFile.ontology' ].! !!HumOntology methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/18/2012 17:51'!file: aString 	fromFile := aString.! !!HumOntology methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/18/2012 17:53'!title	^ title ifNil: [ title :=  (self fromFile), ' -- No title yet.'].! !!HumOntology methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/6/2012 16:27'!title: aString 	title := aString! !!HumOntology methodsFor: 'utility' stamp: 'RichardAlexanderGreen 4/9/2014 09:08'!nounAsCamelCase: aString 	|result delimiters tokens |	delimiters := '-'.	tokens := aString findTokens: delimiters.	result := tokens at: 1.	(tokens copyFrom: 2 to: tokens size)		do: [:token | result := result, (token capitalized) ].	^result.! !!HumOntology methodsFor: 'utility' stamp: 'RichardAlexanderGreen 2/8/2014 10:37'!projectValuesOf: aSetOfAssociations from: aKey	"encapsulate a bit of recurring code"	| resultSet |	self assert: ( aSetOfAssociations isKindOf: Collection ).	resultSet := Set new.	aSetOfAssociations do: [ :map | ( map key = aKey) ifTrue: [resultSet add: (map value)] ].	^resultSet.! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 1/22/2014 17:22'!addPlanFrame: aPlanFrame ForGoal: aGoalString 	| |	self assert: ( aPlanFrame isKindOf: HumFrame4Plan ).	self storeFrame: aPlanFrame.	! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 1/21/2014 22:19'!buildPlanTreeForGoal: aGoal 	"Build a list of associations: ( goalStatement -> (precondition statement) )"	| goalStatement planTree subTree rootFrame |	goalStatement := HumStatement from: aGoal.	planTree := OrderedCollection new.	rootFrame := self getPlanFrameForGoal: aGoal.	"Stop building the plan subtree if the root frame is not defined."	( rootFrame isNoPlan ) ifTrue: [ ^planTree ].	"Transcript cr; show: ( 'rootFrame = ', rootFrame frameName ); cr."	( rootFrame preconditions )		do: [ :precondition |			planTree add: ( goalStatement -> (precondition statement) ).			subTree := self buildPlanTreeForGoal: (precondition statement).			planTree := planTree, subTree.			"Detect a cycle in the tree."			( planTree anySatisfy: [ :map |  map value = goalStatement ] ) 				ifTrue: [ Error signal: 'cycle detected in plan tree' ].			].			"TODO: Fix this up to track indentation level."	^planTree.! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 1/21/2014 22:22'!buildPlanTreeForGoal: aGoal indent: anIndentLevel	"Build a list of associations: ( goalStatement -> (precondition statement) )"	| goalStatement planTree subTree rootFrame |	goalStatement := HumStatement from: aGoal.	planTree := OrderedCollection new.	rootFrame := self getPlanFrameForGoal: aGoal.	"Stop building the plan subtree if the root frame is not defined."	( rootFrame isNoPlan ) ifTrue: [ ^planTree ].	"Transcript cr; show: ( 'rootFrame = ', rootFrame frameName ); cr."	( rootFrame preconditions )		do: [ :precondition |			planTree add: ( goalStatement -> { anIndentLevel. precondition statement.} ).			subTree := self buildPlanTreeForGoal: (precondition statement) indent: (anIndentLevel + 1).			planTree := planTree, subTree.			"Detect a cycle in the tree."			( planTree anySatisfy: [ :map |  map value = goalStatement ] ) 				ifTrue: [ Error signal: 'cycle detected in plan tree' ].			].			"TODO: Fix this up to track indentation level."	^planTree.! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 8/14/2013 10:40'!checkPlanTreeForGoal: aGoal 	| goalStatement planTreeProblems subTreeProblems rootFrame planFrame |	"Check for problems that would prevent the plan from working."	goalStatement := HumStatement from: aGoal.	planTreeProblems := OrderedCollection new.		"Safety check -- >>buildPlanTreeForGoal: . . . will stop execution if there is a cycle in the plan-tree."	self buildPlanTreeForGoal: aGoal.	rootFrame := self getPlanFrameForGoal: goalStatement.	(rootFrame isNoPlan) 		ifTrue: [ planTreeProblems add: 'Precondition: {', ( goalStatement asString ), '} has no plan frame.'. 						^ planTreeProblems ].		" Look for preconditions that have no corresponding plan frame in the ontology."	( rootFrame preconditions )		do: [ :precondition |			planFrame := self getPlanFrameForGoal: precondition statement.			planFrame ifNil: [ planTreeProblems add: 'Precondition: {', ( precondition statement asString ), '} has no plan frame.' ].			subTreeProblems := self checkPlanTreeForGoal:   ( precondition statement ).			planTreeProblems := planTreeProblems, subTreeProblems.			].							^planTreeProblems.! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 7/22/2013 17:09'!collectPlanFramesForGoal: aGoalStatement 	"| goalStatement planTree subTree rootFrame |	goalStatement := HumStatement from: aGoal.	planTree := OrderedCollection new.	rootFrame := self getPlanFrameForGoal: aGoal.	( rootFrame preconditions )		do: [ :precondition |			planTree add: ( goalStatement -> (precondition statement) ).			subTree := self buildPlanTreeForGoal: (precondition statement).			planTree := planTree, subTree.			( planTree anySatisfy: [ :map |  map value = goalStatement ] ) 				ifTrue: [ Error signal: 'cycle detected in plan tree' ].			].			^planTree."	| problems rootFrame frameCollection subSet |	"First check to make sure the plan frames are complete."	problems := self checkPlanTreeForGoal:  aGoalStatement.	problems isEmpty		 ifFalse: [ Error signal: 'There are problems with the plan tree for goal: ', (aGoalStatement asString)			                                , String cr, ' Problems: ', problems asString. ].	"Collect the plan frames."	frameCollection := Set new.	rootFrame := self getPlanFrameForGoal: aGoalStatement.	frameCollection add: rootFrame.	( rootFrame preconditions )		do: [ :precondition |			subSet := self collectPlanFramesForGoal: (precondition statement).			frameCollection addAll: subSet.			].	^frameCollection.! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 2/12/2014 10:55'!getFramesThatInvokePrecondition: aStatementString 	"Lookup the frames where precondition is invoked."	| resultSet  |	resultSet := self getFramesWithRelation: #precondition object: aStatementString.	^ resultSet.! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 2/12/2014 10:07'!getPlanFrameForGoal: aGoalString 	| frame key |	key := 'Goal: ', aGoalString asString.	frame := (self framesByName ) 							at: key							ifAbsent: [ "Return an empty planFrame." 								^ HumFrame4Plan ontology: self goal: (aGoalString asString).								].	self assert: ( frame isKindOf: HumFrame4Plan ).	^frame.	! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 9/15/2012 10:56'!planFrames	| planFrames |	planFrames := Set new.	( self framesByIdentifier )		keysAndValuesDo:  [ :key :value | 			(value isKindOf: HumFrame4Plan)  ifTrue: [ planFrames add: value ].			].	^planFrames ! !!HumOntology methodsFor: 'render as . . .' stamp: 'RichardAlexanderGreen 1/23/2014 15:17'!parseStatement: aHumStatement keywords: keywords 	"Parse the statement -- Return a list of token-type pairs: ( token -> tokenType ).	TODO: Fix this up so that it returns comment and annotation as types."	| whitespace punctuation quote tokens tokenTypes tokenType |	whitespace := ' 			'.	quote := $' asString.	punctuation := '~!!@#$%^&*()_+`={}|[]\:";<>?,./', quote.	"Note: Preserve uppercase in tokens so that first word of a sentence is capitalized."	tokens := aHumStatement source  findTokens: ( punctuation, whitespace ) keep: punctuation.	tokenTypes := OrderedCollection new.	"QUESTION: Is the role-label part of the statement? 	(I think it is part of an instruction, but the statement is separated.)"	tokens 		do: [ :token | 			tokenType := #word.			( self isNoun: token ) ifTrue: [ tokenType := #noun ].			( keywords include: token ) ifTrue: [ tokenType := #keyword ].			( punctuation includes: (token at: 1) ) ifTrue: [tokenType := #punctuation ].			tokenTypes add: ( token -> tokenType ).			].	^ tokenTypes.! !!HumOntology methodsFor: 'render as . . .' stamp: 'RichardAlexanderGreen 2/12/2014 12:15'!view	^viewer ifNil: [ viewer := HumOntologyViewer ontology: self. ].! !!HumOntology methodsFor: 'about Views' stamp: 'RichardAlexanderGreen 2/12/2014 10:55'!getFramesThatInvokeView: aViewName	"A view may be invoked by another view or by a vignette."	| resultSet |	"Compiler will scan views to index [pane: ...] pattern. " 		"Compiler will scan vignettes to index instructions 'Show <viewname>.' and 'Ask <viewname>.'"	resultSet := self getFramesWithRelation: #invokesView object: aViewName.		^resultSet.	! !!HumOntology methodsFor: 'about Views' stamp: 'RichardAlexanderGreen 4/15/2014 12:58'!getViewFrame: aString 	"Get the view frame with the given name."	| frame |	frame := ( self framesByName ) 						at: ('View: ', aString trimBoth,'.')						ifAbsent: ["If none, make one."							frame := HumFrame4View ontology: self viewEntity: aString.							].	^frame.! !!HumOntology methodsFor: 'about Views' stamp: 'RichardAlexanderGreen 4/16/2014 19:12'!isViewName: aString 	"Does the string name a view frame?"	| frame result |	frame := (self framesByName) at: ('View: ',aString trimBoth,'.') ifAbsent: [^false].	result := frame isKindOf: HumFrame4View.		^result.! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 2/8/2014 11:42'!compileAllFrames	"Compile the dictionary frames first, then the others." 	| dictionaryFrames otherFrames |	"Reset the frame index"	frameRelations := nil.	"Compile the dictionary frames first."	dictionaryFrames := (self frames) select: [:frame | frame isKindOf: HumFrame4Dictionary ].	dictionaryFrames		do: [ :frame | frame compileToOntology: self ].	"Compile the remaining frames."	otherFrames := (self frames) select: [:frame | (frame isKindOf: HumFrame4Dictionary) not ].	otherFrames		do: [ :frame | frame compileToOntology: self ].! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 1/15/2012 10:34'!fetchFrameByIdentifier: aPrimaryKey 	"Fetch the frame with this identifier."	| frame |	frame := ( self framesByIdentifier ) at: aPrimaryKey ifAbsent: [ Error signal: 'No such frame in this ontology!!'].	^frame.! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 3/20/2014 14:48'!fetchFrameByName: aString 	| frame |	self assert: (aString isKindOf: String).	self assert: (aString endsWith: '.').	frame := (self framesByName ) at: aString ifAbsent: [ Error signal: 'No frame by this name.'].	^frame.! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 2/12/2014 10:22'!frameRelations	"The cross index collection tracks relationships between frames."	"Entries have the form: { frameA. #symbol. frameB. }	  where the frames are identified by their titles.	 Cases:		- { frameA.    #invokes. actionB. }  ( frameA may be action, plan, or vignette. )		- { vignetteA. #stacks. contextB. }		- { goalA.     #requires.  goalB. }  ( This very like plan tree. )	"	^ frameRelations ifNil: [ frameRelations := Set new. ].! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 8/22/2013 15:46'!frames	^ frames ifNil: [ frames := Set new. ].! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 1/25/2012 20:22'!framesByIdentifier	"Each frame is given a unique identifier. 	This store indexes the frames their identifiers."	^ framesByIdentifier ifNil: [ framesByIdentifier := Dictionary new. ].! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 1/15/2012 10:32'!framesByName	"Enable access to frames by their name (title line string)."	^ framesByName ifNil: [ framesByName := Dictionary new ].! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 1/15/2012 08:59'!fromFile	"The file name serves as a natural identifier. "	^ fromFile ifNil: [ ^ '(untitled)' ].! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 2/12/2014 12:11'!getFramesThatInvokeContext: aContextName 	"Get frames with 'Push context <aContextName>.'  instructions."	| resultSet |	resultSet := self getFramesWithRelation: #invokesContext object: aContextName.	^resultSet.! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 2/12/2014 10:39'!getFramesWithRelation: aSymbol object: aName	"Get frames that are indexed with given relation and object."	| resultSet |	resultSet := Set new.	"Compiler will scan vignettes to index those that define the context."	(self frameRelations)		do: [ :relation |		"Relation looks like { frameTitle. relationSymbol. someString. }"			| frameTitle verb object |			frameTitle := relation at: 1.			verb := relation at: 2.			object := relation at: 3.			(( verb = aSymbol ) and: [ object = (aName trimBoth asLowercase) ])					ifTrue: [ resultSet add: frameTitle. ].			].	^resultSet.! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 2/12/2014 10:42'!indexFrame: aHumFrame relation: aSymbol object: aKeyString 	"Add the given frame to the index"	| |	(self frameRelations) add: { aHumFrame title. aSymbol. (aKeyString trimBoth asLowercase). }.! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 1/30/2014 10:36'!parseFrameLine: frameLine keywords: keywords	"Parse the frameLine -- Return a list of token-type pairs: ( token -> tokenType ).	TODO: Fix this up so that it returns comment and annotation as types."	| whitespace punctuation quote tokens tokenTypePairs tokenType i |	whitespace := String space, String tab, String crlf.	quote := $' asString.	punctuation := '~!!@#$%^&*()_+`={}|[]\:";<>?,./', quote.	"Note: Preserve uppercase in tokens so that first word of a sentence is capitalized."	tokens := frameLine source  findTokens: ( punctuation, whitespace ) keep: punctuation.	tokenTypePairs := OrderedCollection new.	"QUESTION: Is the role-label part of the statement? 	(I think it is part of an instruction, but the statement is separated.)"	i := 1.	[ i <= tokens size ]			whileTrue: [ 			| token |			token := tokens at: i.			tokenType := #word.			( self isNoun: token ) ifTrue: [ tokenType := #noun ].			( keywords include: token ) ifTrue: [ tokenType := #keyword ].			( punctuation includes: (token at: 1) ) 				ifTrue: [ tokenType := #punctuation. "Until proven otherwise."					"Does the source have a comment?"					(((token at: 1) = '(') and: ['*(*)*' matches: (frameLine source) ] )						ifTrue: [ "Advance index to closing parend"							| commentString |							commentString := '('.							[ i <= (tokens size) and:[( token at: 1) =')']] 								whileFalse: [ i := i+1. token := tokens at: i. commentString := commentString, ' ', token. ].								token := commentString.								tokenType := #comment.								]. 					"Does the source have annotation?"					(((token at: 1) = '[') and: ['*[*]*' matches: (frameLine source) ] )						ifTrue: [ "Advance index to closing parend"							| annotationString |							annotationString := '['.							[ i <= (tokens size) and: [( token at: 1) =']']] 								whileFalse: [ i := i+1. token := tokens at: i. annotationString := annotationString, ' ', token. ].								token := annotationString.								tokenType := #annotation.								]. 					].			tokenTypePairs add: ( token -> tokenType ).			].	^ tokenTypePairs.! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 8/23/2013 14:29'!storeFrame: aFrame 	"Store this frame in the ontology.	The frame may be stored even if it has errors.	"	| primaryKey frameName |	self assert: (aFrame isKindOf: HumFrame ).	"If the frame does not have an ID (serial-number) give it one."	"The title of the frame can serve to index it but cannot be used to ID it 		because the title can be changed by the user 			while the intent of the frame remains the same."	primaryKey := aFrame uniqueIdentifier.	( self framesByIdentifier ) at: primaryKey put: aFrame.		"Also enable caller to fetch a frame by its name."	frameName := aFrame frameName.	( self framesByName ) at: frameName put: aFrame.		"Also enable caller to fetch frames by role."	( aFrame isKindOf: HumFrame4Action ) 		ifTrue: [self addRole: (aFrame role) action: aFrame actionStatement.].			"Also enable caller to fetch frame collection without any keys."	( self frames ) add: aFrame.		! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 7/22/2013 16:56'!addEntity: anEntity attribute: anAttribute       "Define these nouns and their relationship."	| lcEntity lcAttribute |	lcEntity := anEntity asLowercase.	lcAttribute := anAttribute asLowercase.	self addNoun: lcEntity.	self addNoun: lcAttribute.	"Add entity-attribute relationship."	self entityAttributes add: ( lcEntity -> lcAttribute ).! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 4/19/2014 11:16'!addEntity: anEntity attributes: anAttributeCollection       "Define these nouns and their relationship." | entityName |	entityName := anEntity asLowercase.	self addNoun: entityName.	anAttributeCollection 		do: [ :anAttribute | 			self addEntity: anEntity attribute: anAttribute.			].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/13/2012 16:59'!addNoun: aNoun 	"Remember noun."	| singularNoun |	singularNoun := self singularFormOfNoun: aNoun.	self nouns add: singularNoun.	"Check if noun has an implied supertype."	self setAutomaticSupertypeForNoun: singularNoun.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 3/27/2014 17:26'!addNoun: aSubType isA: aSuperType       "Add these nouns and add is-A relation."	| theNoun theSuperType |	theNoun := aSubType asLowercase.	theSuperType := aSuperType asLowercase.	"Add these nouns in case they are not already added."	self addNoun: theNoun.	self addNoun: theSuperType.	"Add inverse relation -- Note: subtypes is also a Set."	self nounSubtypes add: ( theSuperType -> theNoun).	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/23/2012 17:52'!addNoun: aNounString reference: aFrameLine 	"Remember where nouns are referenced."	(self nounReferences ) add: ( aNounString -> aFrameLine ).! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/29/2011 10:57'!addNouns: anArrayOfNouns 		anArrayOfNouns do: [ :noun | self addNoun: noun ].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 2/28/2014 13:21'!allAttributesOfEntity: anEntity 	"Get the attributes, the attributes of the attributes, and the attributes of the supertypes."	| allAttributes localAttributes tempAttributes localSupertypes localProperties entity |	(self attributeChain includes: anEntity) ifTrue: [ ^Set new. "Return empty set to terminate cycle." ].	self attributeChainPush: anEntity.	entity := anEntity asLowercase.	self assert: (entity sameAs: anEntity).	"Get the immediate properties of this entity."	localAttributes := self immediateAttributesOfEntity: anEntity.	self assert: ( localAttributes include: anEntity ) not.	localSupertypes := self immediateSupertypesOf: anEntity.	self assert: ( localSupertypes include: anEntity ) not.		"Entity properties include attributes and supertypes."	localProperties := localAttributes, localSupertypes.	self assert: ( localProperties include: anEntity ) not.		"For each local property: Look up attributes and add them to the result set."	allAttributes := localAttributes.	self assert: ( allAttributes include: anEntity ) not.	localProperties 		do: [ :eachProperty |			"RECURSIVE CALL !!!!!!"			tempAttributes := self allAttributesOfEntity: eachProperty.			allAttributes := allAttributes, tempAttributes.			"Detect cycles in the tree."			( allAttributes include: anEntity ) 				ifTrue: [ Error signal: 'noun attribute-tree contains cycle at: ', anEntity ].			 ].	self attributeChainPop: anEntity.		^allAttributes	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 3/27/2014 17:23'!allSubtypesOf: aSuperType 	"Get the subtypes (if any) of this noun and the subtypes of the subtypes all the way down"	| localSubtypes tempSubtypes allSubtypes |	localSubtypes := self immediateSubtypesOf: aSuperType asLowercase.	allSubtypes := localSubtypes.	localSubtypes 		do: [ :eachSubtype | 			"RECURSION: Get the subtypes for each of those subtypes."			tempSubtypes := self allSubtypesOf: eachSubtype.			"Merge the sets"			allSubtypes := allSubtypes, tempSubtypes. 			"Detect cycles in the tree."			( allSubtypes includes: aSuperType ) 				ifTrue: [ Error signal: 'noun subtype-tree contains a cycle at: ', aSuperType ].		 	].	"Return the merged set of all subtypes."		^allSubtypes.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 3/27/2014 17:23'!allSupertypesOf: aSubType 	"Get the Supertypes (if any) of this noun and the Supertypes of the Supertypes all the way down"	| localSupertypes tempSupertypes allSupertypes |	localSupertypes := self immediateSupertypesOf: aSubType asLowercase.	allSupertypes := localSupertypes.	localSupertypes 		do: [ :eachSupertype | 			"RECURSION: Get the Supertypes for each of those Supertypes."			tempSupertypes := self allSupertypesOf: eachSupertype.			"Merge the sets"			allSupertypes := allSupertypes, tempSupertypes. 			"Detect cycles in the tree."			( allSupertypes includes: aSubType ) 				ifTrue: [ Error signal: 'noun Supertype-tree contains a cycle at: ', aSubType ].		 	].	"Return the merged set of all Supertypes."		^allSupertypes.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 2/28/2014 13:08'!attributeChain	^attributeChain ifNil: [ attributeChain := Stack new.]! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 2/28/2014 13:10'!attributeChainPop: anAttribute   self assert: (self attributeChain top) = anAttribute.	self attributeChain pop.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 2/28/2014 13:06'!attributeChainPush: anAttribute   self assert: ((self attributeChain) includes: anAttribute ) not. 	(self attributeChain) push: anAttribute.	 ! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 3/27/2014 16:58'!categoriesOf: anAttributeName 	| categories |	^categories := (self nounCategories) at: anAttributeName.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 4/18/2014 20:43'!categoriesOf: anAttriubuteName include: anArrayOfCategoryNames	"Add this nouns in case it is not already added;"	"and make it a kind of category"	self addNoun: anAttriubuteName isA: 'category'.	(self nounCategories) at: anAttriubuteName put: anArrayOfCategoryNames.	"TODO: REFACTOR: The collection of category names should be a set.	And we should update (merge) into the set here."! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/30/2011 10:15'!entityAttributes	"Thisinstance variable is a map, a set of associations ( anEntity -> anAttribute )"	^entityAttributes ifNil: [ entityAttributes := Set new.].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/30/2011 10:28'!immediateAttributesOfEntity: anEntity 	^ self projectValuesOf: (self entityAttributes) from: anEntity.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/30/2011 08:32'!immediateSubtypesOf: aSuperType 	"Get the subtypes (if any) of this noun."	^ self projectValuesOf: (self nounSubtypes) from: aSuperType.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/30/2011 10:49'!immediateSupertypesOf: aNoun	"Get the immedate supertypes (if any) for this noun." 	| mapSet supertypes |	"Initialize the result set."	supertypes := Set new.	"for each map ( supertype -> subtype ):"	mapSet := self nounSubtypes.	mapSet 		do: [ :nounSubtype |			( nounSubtype value = aNoun )				ifTrue: [ supertypes add: nounSubtype key ].			].	^supertypes.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 4/8/2014 09:14'!isAttribute: aNameString	"Does the string name an attribute? (An attribute has no attributes of its own.)"	| result attributes |		"First: Does it name a noun?"	result := self isNoun: aNameString.	result ifFalse: [^false].		"An attribute has no attributes. 	 Nor is it a subtype of something that has attributes."	attributes := self allAttributesOfEntity: aNameString.	result := attributes size = 0.	^result.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 4/18/2014 20:47'!isCategory: aNameString	"Does the string name an attribute? (An attribute has no attributes of its own.)"	| result attributes |		"First: Does it name a noun?"	result := self isNoun: aNameString.	result ifFalse: [^false].		result := self yesNoun: aNameString isAKindOf: 'category'.	^result.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 4/8/2014 09:09'!isEntity: aNameString	"Does the string name an entity?"	| result attributes |		"First: Does it name a noun?"	result := self isNoun: aNameString.	result ifFalse: [^false].		"An entity has one or more attributes."	attributes := self allAttributesOfEntity: aNameString.	result := attributes size > 0.	^result.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 4/8/2014 09:23'!isEntity: entityName attribute: attributeName	"Does this combination make sense? "	| result attributes |		"Does the first noun name an entity?"	result := self isEntity: entityName.	result ifFalse: [^false].		"Is the second noun an attribute of the first noun?"	attributes := self allAttributesOfEntity: entityName.	result := attributes includes: attributeName.	^result.		! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 8/14/2013 11:00'!isNoun: aNounString 		"Is the given string a noun?"	| singular |	self assert: [ aNounString isKindOf: String ].	singular := self singularFormOfNoun: aNounString.	^( self nouns ) include: singular.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 2/28/2014 10:59'!isPluralNoun: aNoun	"Return true if the noun is plural."	| singular isSingular |	singular := self singularFormOfNoun: aNoun.	isSingular := (singular sameAs: aNoun).	^isSingular not.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 3/27/2014 16:38'!nounCategories	^ nounCategories ifNil: [ nounCategories := Dictionary new ].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/23/2012 17:53'!nounReferences	^ nounReferences ifNil: [ nounReferences := Set new. ].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 4/18/2014 20:44'!nounSubtypes	"This instance variable is a map, a set of associations ( aSuperType -> aSubType )."	^ nounSubtypes ifNil: [ nounSubtypes := Set new.].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/30/2011 10:16'!nouns	"This instance variable is the set of all nouns that have been defined so far."	^nouns ifNil: [ nouns := Set new.].	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/16/2012 14:08'!nounsInStatement: aHumStatement 	"Return the (known) nouns found in the statement."	| tokens statement statementNouns nounSet |	"Forgive a string instead of a statement."	statement := aHumStatement.	(statement isKindOf: String) ifTrue: [ statement := HumStatement from: aHumStatement ].	self assert: ( statement isKindOf: HumStatement ).		tokens := statement tokens.	nounSet := self nouns.	statementNouns := tokens select: [ :token | nounSet includes: token].	^statementNouns.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/29/2011 10:17'!setAutomaticSupertypeForNoun: aNoun 	"If a hyphenated nouns ends with the name of another noun,	 it is automately a subtype of the other noun."	| tokens suffix |	"See if there is a hyphen in the noun."	tokens := aNoun findTokens: '-'.	( tokens size > 1 ) ifFalse: [^self].		"See if the last token is currently a noun."	suffix := tokens last.	(self nouns include:  suffix) ifFalse: [^self].	       "The last token is currently a noun, so make this noun a subtype."	self nounSubtypes add: ( suffix -> aNoun ).! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 10/26/2012 10:48'!singularFormOfNoun: aNoun 	"If noun ends in 's'  remove the 's'.  Crude."	| s singular |	self assert: ( aNoun isKindOf: String ).	s := aNoun asLowercase.	( s endsWith: 's' ) ifFalse: [ ^ s ].	"Following is first approximation"	singular := s copyFrom: 1 to: (s size - 1).	^singular.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/28/2011 13:14'!yesNoun: aSubtype isAKindOf: aSuperType 	^self nounSubtypes includes: ( aSuperType -> aSubtype  ).! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 2/1/2012 21:27'!actionsOf: aRole	"The actions of a role define its public interface. (API)"      ^self projectValuesOf: (self roleActions) from: (aRole asLowercase ).! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 2/1/2012 20:15'!addRole: aRole 	self assert: (aRole isKindOf: String ).	self roles add: aRole asLowercase.! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 4/10/2012 11:50'!addRole: aRole action: actionStatement      "Add role and action statement."     | |	self assert: ( aRole isKindOf: String ).	self assert: ( actionStatement isKindOf: HumStatement ).	"Assure role is in set."	self addRole: aRole.		"Assure statement is in set."	self roleActions add: (  ( aRole asLowercase )-> actionStatement ).! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 8/23/2013 11:16'!addRole: aRole action: anAction instruction: aHumInstruction 	"Append the given instruction to the action's sequence of instructions."	| sequence instruction actionString |		self assert: ( aRole isKindOf: String ).	actionString := (anAction isKindOf: String ) ifTrue: [ anAction ] ifFalse: [ anAction asString ].	self assert: ( actionString isKindOf: String ).		"Kludge some polymorphism -- fix-up string arguments"		instruction := aHumInstruction copy.	( instruction isKindOf: String ) ifTrue: [ instruction := HumInstructionLine statement: aHumInstruction ].				"Get the sequence of instructions belonging to this role action."	sequence := self instructionsForRole: aRole action: anAction.		"Append the given instruction to the sequence."	sequence add: instruction.		"Assure that the data store is updated."	self instructionSequences at: ( (aRole asLowercase) -> actionString ) put: sequence.! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 12/29/2011 17:21'!critiqueRole: aRole action: anAction 	"Critique the instructions for this role action."	|  critique actionStatement sequence actionNouns instructionNouns |			"Return the critique as a sequence of strings."	critique := OrderedCollection new.		"The action should contain at least one noun."	actionStatement := self getRole:  aRole action: anAction.	actionNouns := self nounsInStatement: actionStatement.	( actionNouns size > 0 ) 		ifFalse: [ critique add: 'Action Statement has no known nouns.'].			"There should be at least one instruction for the action statement."			sequence := self instructionsForRole: aRole action: anAction.	( sequence size > 0 )		ifFalse: [ critique add: 'Action has no instructions.'].				"Nouns in the instructions should find antecedants in the action statement."	sequence 		do: [ :instruction | 			instructionNouns := self nounsInStatement: instruction statement.			( actionNouns includesAllOf: instructionNouns )				ifFalse: [ critique add: ( 'Some nouns lack antecedants in: ', instruction statement source ) ].			]. 		^critique.! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 2/5/2014 13:50'!getFrameForRole: aRole action: anAction 	|  key frame |	key := aRole ,': ', anAction asString.	frame := (self framesByName ) 				at: key				ifAbsent: [ "Return an empty Action Frame." 					^ HumFrame4Action ontology: self role: aRole action: anAction .					].	self assert: ( frame isKindOf: HumFrame4Action ).	^frame.! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 2/12/2014 10:55'!getFramesThatInvokeAction: anActionString 	"Lookup the frames where action is invoked."	| resultSet  |	resultSet := self getFramesWithRelation: #invokesAction object: anActionString.	^ resultSet.! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 3/14/2013 12:38'!getRole: aRole action: aStringOrStatement 	"Get the action if it already exists."	| actionStatement |	"Assure that we are dealing with a HumStatment."	actionStatement := aStringOrStatement copy.	( actionStatement isKindOf: HumStatement ) 		ifFalse: [ actionStatement := HumStatement from: aStringOrStatement ].	"If the role action set already contains the action statement,	    return an equivalent statement.	"		(self roleActions include: ( ( aRole asLowercase ) -> actionStatement ) ) 		ifFalse: [ "The role does not currently define a proper match"			"TODO: Refactor to handle polymorphism."			self error: 'Attempt to get a non-existent action statement.'. 			^nil ].	^actionStatement.! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 12/29/2011 07:57'!instructionSequences	^ instructionSequences ifNil: [ instructionSequences := Dictionary new. ].! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 2/1/2012 21:26'!instructionsForRole: aRole action: anAction 	"Get the instruction sequence (if any) for the given role-action."	^ self instructionSequences at: ( (aRole asLowercase ) -> anAction ) ifAbsent: [ OrderedCollection new.]. ! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 1/17/2012 12:53'!isActionDefined: anInstructionLine 	"See if we have a definition for the given action."	| instructions |	instructions := self instructionsForRole: (anInstructionLine role) action: ( anInstructionLine statement ).	^ ( instructions size > 0 ).		! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 1/17/2012 12:50'!isActionDefinedV01: anInstructionLine 	"See if we have a definition for the given action."	| numberOfDefinitions |	numberOfDefinitions := ( self roleActions ) 		count: [ :map | 			( map key = anInstructionLine  role ) and: [ map value = anInstructionLine statement ].			].	self assert: ( numberOfDefinitions < 2 ).	^ numberOfDefinitions > 0.		! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 12/30/2011 10:20'!roleActions	"This instance variable is a map, a set of associations  ( role -> actionStatement ) "	^roleActions ifNil: [ roleActions := Set new.]! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 12/30/2011 10:20'!roles	"This instance variable contains the set of all roles that have been defined so far."	^roles ifNil: [ roles := Set new.].! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 3/14/2013 16:22'!yesRole: aRole hasAction: aSource 	^(self actionsOf: (aRole asLowercase ) ) anySatisfy: [ :statement | statement matchesStatement: aSource ] .! !!HumOntology methodsFor: 'about Vignettes' stamp: 'RichardAlexanderGreen 2/12/2014 10:29'!addVignette: aFrame4Vignette toContext: aContext 	"Add to store"	( self contextVignettes ) add: ( aContext -> aFrame4Vignette ).	"Index frame defines context"	"( self frameRelations ) add: { (aFrame4Vignette title). #definesContext. (aContext asLowercase). }."	self indexFrame: aFrame4Vignette relation: #definesContext object: aContext.! !!HumOntology methodsFor: 'about Vignettes' stamp: 'RichardAlexanderGreen 2/8/2014 10:39'!contextVignettes	"This list holds the (1:M) relation (context -> vignette)."	contextVignettes ifNil: [ contextVignettes := OrderedCollection new. ].	"Vignettes are evaluated in the order seen."	"TODO: Decide if we need a priority attribute on a vignette to enable re-ordering." 	self assert: (contextVignettes isKindOf: OrderedCollection ).	^contextVignettes.! !!HumOntology methodsFor: 'about Vignettes' stamp: 'RichardAlexanderGreen 8/14/2013 20:54'!findBestMatchingVignetteForInput: aString inContextStack: aStack 	"Search the vignette frames for the one whose pattern is the best match	for the given input and context-stack."	| bestMatch stackCopy bestMatchScore |	self assert: ( aString isKindOf: String ).	self assert: ( aStack  isKindOf: Stack ).	self assert: ( aStack notEmpty ).	"We want the best match with a score better than zero."	bestMatchScore := 0.	aStack		do: [ :contextString |			"See if we have any vignettes that match that context."			| vignettesInContext |			vignettesInContext := self vignettesForContext: contextString.			"Get the bestMatch from that set."			vignettesInContext				do: [ :candidate |					| score |					score := candidate patternMatchScore: aString.					( score > bestMatchScore)							ifTrue: [ bestMatch := candidate. 								        bestMatchScore := score. 								     ].					].			].	( bestMatchScore = 0 )			ifTrue: [ bestMatch := self hasNoVignetteMatchFor: aString. ].	^ bestMatch.! !!HumOntology methodsFor: 'about Vignettes' stamp: 'RichardAlexanderGreen 2/12/2014 10:31'!getFramesThatDefineContext: aContextName 	"Get the vignette frames that define the given context."	| resultSet |	resultSet := Set new.		resultSet := self getFramesWithRelation: #definesContext object: aContextName.	^resultSet.! !!HumOntology methodsFor: 'about Vignettes' stamp: 'RichardAlexanderGreen 7/25/2013 15:44'!hasNoVignetteMatchFor: aString 	| defaultVignette |	defaultVignette := HumFrame4Vignette new.	defaultVignette addVignetteResponse: ('Sorry, { ', aString, '} is not understood.').	^ defaultVignette.! !!HumOntology methodsFor: 'about Vignettes' stamp: 'RichardAlexanderGreen 1/25/2012 14:05'!vignettesForContext: aVignetteContext	| vignettes |	self assert: ( aVignetteContext isKindOf: String ).	vignettes := self projectValuesOf:  (self contextVignettes ) from: aVignetteContext.	^vignettes.! !!HumOntology methodsFor: 'translate to' stamp: 'RichardAlexanderGreen 5/20/2014 09:23'!codeGenerator	"Return a translator."	^translator 		ifNil: [ 			"Precondition: Assure we are compiled."			self compileAllFrames.			"TODO: This 'Assure we are compiled.' strategy will fail 			       when the ontology is updated between translations."			"Post condition: translator is set."			translator := HumOntologyTranslator ontology: self. 			].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumOntology class	instanceVariableNames: ''!!HumOntology class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 8/18/2013 22:06'!baseOntology	"Return a base ontology"	| instance |	instance := HumOntology new.	"TODO: Add base nouns and frames to the base ontology."	"The base vocabulary includes: 	  order, order item, bill-of-material, material, part, assembly, 	  container, person, worker, employee, organization, roles, 	  measure, metric, money, cost, price, account, 	  resource, resource pool, inventory, 	  and more"	^instance.! !!HumOntology class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/9/2012 12:45'!nounAsCamelCase: aString 	| tokens result |	tokens := aString subStrings: '-'. 	result := ''.	tokens do: [ :token |		(result = '') 			ifTrue: [ result := token] 			ifFalse: [ result := result, (token capitalized )].		].	^result.! !!HumOntology class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/13/2012 12:05'!tokensInString: aString	"Return the tokens in the statement as an array of strings."	| punctuation whiteSpace tokens |	"Punctuation does not include hyphen because nouns may be hypenated."	punctuation := '~!!@#$%^&*()_+`={}|[[]\:";<>?,./'. 	"White space includes space, cr, tab."		whiteSpace := ' 			'.	"Tokens are all lower-case and include punctuation."	tokens := ( aString asLowercase ) findTokens: ( punctuation, whiteSpace ) keep: punctuation.	^tokens.! !HumFrame subclass: #HumFrame4View	instanceVariableNames: 'entity'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4View commentStamp: 'RichardAlexanderGreen 9/19/2012 11:00' prior: 0!A view frame indicates the organization of a user interface - as an interactive document.The view frame notation is a mark-up notation.Instance Variables:	entity	<a noun> -- The entity which is the subject of the view.!!HumFrame4View methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/9/2014 18:04'!addMarkUp: aSource 	| frameLine |	(aSource isKindOf: String)		ifTrue: [ frameLine := HumMarkupLine source: aSource ].	(aSource isKindOf: HumMarkupLine )		ifTrue: [ frameLine := aSource ].	frameLine ifNil: [Error signal: 'Unexpected object type.'].		self frameLines add: frameLine.! !!HumFrame4View methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 18:09'!entity	^ entity! !!HumFrame4View methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 18:09'!entity: anObject	entity := anObject! !!HumFrame4View methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/9/2012 11:57'!viewEntity: anEntityType. 	"What entity-type is this view displaying."	entity := anEntityType.! !!HumFrame4View methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/12/2014 10:27'!compileToOntology: aHumOntology	""	| errors |	errors := OrderedCollection new.	"Index cases where a widget refers to another view."	(self frameLines)		do: [ :frameLine |			| widgets |			widgets := frameLine widgets.			widgets				do: [ :widget |						('[pane: *]' matches: widget)						ifTrue: ["Index this case."							| viewName |							viewName := (HumCalculator substringFrom: widget after: '[pane:' before: ']') trimBoth.							"(aHumOntology frameRelations) add: { (self title). #invokesView. viewName. }"							aHumOntology indexFrame: self relation: #invokesView object: viewName.							].					].			].		^errors := (super compileToOntology: aHumOntology ).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrame4View class	instanceVariableNames: ''!!HumFrame4View class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 1/9/2012 12:05'!ontology: aHumOntology viewEntity: entityType 	| frame |	frame := self new.	frame viewEntity: entityType;	              titleLine: 'View: ', entityType, '.';			 ontology: aHumOntology.	^frame. ! !Object subclass: #HumStatement	instanceVariableNames: 'source errors nounValues jobTicket role translation isSatisfied'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumStatement commentStamp: 'RichardAlexanderGreen 9/28/2012 13:40' prior: 0!Some types of frame lines will contain a statement as part or all of their content.For example, an instruction line might contain a role prefix, a statement, a comment, and a annotation.This statement class is meant to provide a set of services for interpreting and analyzing statements.A statement is simply a sequence of tokens. Some of those tokens must be nouns. Otherwise the statement has no data to give it meaning at run-time  and there is no way for the compiler to check for data continuity.Instance Variables:	source	<String>	errors	<Set>	nounValues	<Dictionary>	jobTicket	<ProtoObject>!!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/30/2011 17:31'!asString	^ self source asString.! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/28/2011 09:13'!errors	^errors ifNil: [ errors := Set new.].! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/29/2013 07:16'!isConditional	(source beginsWith: 'For ' ) ifTrue: [ ^true ].	( source beginsWith: 'If ')   ifTrue: [ ^true ].	( source beginsWith: 'ElseIf ')   ifTrue: [ ^true ].	( source beginsWith: 'Else:') ifTrue: [ ^true ].	^false.	! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/23/2013 09:45'!isSatisfied: aBoolean 	self assert: (aBoolean isKinOf: Boolean ).	isSatisfied := aBoolean.! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/7/2013 15:10'!jobTicket	"The jobTicket is present when the statement executes at run time."
	"TODO: Should we mix run-time functions with language functions? "	^ jobTicket ifNil: [ Error signal: 'No job ticket was provided!!' ].! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2013 08:25'!jobTicket: aHumJobTicket 	jobTicket := aHumJobTicket.! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/8/2013 10:13'!noun: nounString value: valueObject 	"Noun values are set at run-time just prior to executing the statement.	Record the name value pair for this noun.	(The noun is assumed to be one that appears in the statement source.)	"	(self nounValues ) at: nounString put: valueObject.! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/7/2013 15:22'!nounValues	"Noun values are set at run-time. 	Typically, they are found on a blackboard and transcribed as needed.	Noun values are transcribed to action-call from agent`s blackboard.	Noun values are transcribed to goal-call from dialog blackboard.	Noun values are transcribed to view-call from dialog blackboard.	"	^ nounValues ifNil: [ nounValues := Dictionary new.].! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/11/2012 19:36'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		"nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);"		nextPutAll: title;		nextPutAll: '( ', self source, ' )';		nextPutAll: String cr.! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2013 08:26'!role	^role ifNil: [ Error signal: 'role was not set in HumStatement']! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2013 08:28'!role: aString	"What role is meant to execute this statement?	If this is an action statement, 	the resource manager will assign execution 	to an available actor that claims the role at run-time.	"	role := aString.! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2011 15:03'!source	^ source! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/23/2013 09:36'!source: aSource      "Set and check the source string."	|  lastCharacter |		"Remember my source string."	source := '*** SOURCE IS NOT VALID ***'.	( aSource isKindOf:  String )       ifTrue: [ source := aSource trimBoth.].	( aSource isKindOf:  HumStatement ) ifTrue: [ source := aSource source.].	( aSource isKindOf: HumConditionLine ) ifTrue: [ source := aSource source.].		self assert:	( source = '*** SOURCE IS NOT VALID ***' ) not.	"Reset errors."	errors := Set new. 		"Syntax check: A statement ends with a period or a colon."	lastCharacter :=  ( source at: ( source size )). 	( lastCharacter = $. ) ifTrue: [^self].	( lastCharacter = $: ) ifTrue: [^self].	"Last character was not a period or colon."	 self syntaxError: 'Statement must end with a period or colon.'.	! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/13/2012 12:08'!tokens	"Return the tokens in the statement as an array of strings."	|  tokens |	tokens := HumOntology tokensInString: (self source).	^tokens.! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2013 09:01'!translation	^translation! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2013 09:20'!translation: aString 	translation := aString! !!HumStatement methodsFor: 'testing' stamp: 'RichardAlexanderGreen 12/29/2011 15:04'!= aStatement 	( aStatement isKindOf: String )  ifTrue: [ ^source sameAs: aStatement ].	( aStatement isKindOf: HumStatement ) ifTrue: [ ^ source sameAs: aStatement source ].	^self halt.! !!HumStatement methodsFor: 'testing' stamp: 'RichardAlexanderGreen 1/23/2012 13:04'!hash 	"This HACK (which may be a bad idea) makes HumStatement hash the same as a matching string.	It makes set lookup work.	But maybe it makes some coding error too forgiven.	"	^ ( source hash ).! !!HumStatement methodsFor: 'testing' stamp: 'RichardAlexanderGreen 10/7/2013 15:18'!matchesStatement: aStatement 	self assert: ( aStatement isKindOf: String ).	"TODO: Refactor for polymorphism."	"TODO: Match when A AN THE are dropped."	"TODO: Match as-if certain prepositions are synonyms? 	           (example: AT=ON, OVER=ABOVE, UNTIL=TO ON=ONTO)"	^source sameAs: aStatement.! !!HumStatement methodsFor: 'testing' stamp: 'RichardAlexanderGreen 3/15/2013 15:19'!matchesStatement: aCandidate inOntology: aHumOntology	"Does this statement match the argument -- accounting for supertypes."	| statement candidateTokens myTokens |	( aCandidate isKindOf: String )				ifTrue: [ "First try a shortcut"				(( self source) sameAs: aCandidate ) ifTrue: [^true].				"Otherwise: Convert string to statement."				statement := HumStatement from: aCandidate. 				].	( aCandidate isKindOf: HumStatement )			ifTrue: [ statement := aCandidate ].	"Guard against surprises. At this point, statement should be . . ."	self assert: ( statement isKindOf: HumStatement ).	"Get tokens minus articles."	candidateTokens := ( statement tokens ) difference: #('a' 'the').	myTokens := ( self tokens ) difference: #('a' 'the').	( myTokens size = candidateTokens size ) ifFalse: [ ^false ].	"Is my noun a supertype of the argument`s noun?"	( 1 to: (myTokens size) )		do: [ :x |			| myToken candidateToken |			myToken := myTokens at: x.			candidateToken := candidateTokens at: x.			( myToken sameAs: candidateToken )				ifTrue: ["continue"]				ifFalse: [ "Is myToken a noun? If so, see if my token is a supertype"					( aHumOntology yesNoun: candidateToken isAKindOf: myToken  )						ifTrue: ["continue"]						ifFalse: [ ^false ].					].			].	^ true.		! !!HumStatement methodsFor: 'testing' stamp: 'RichardAlexanderGreen 1/15/2012 10:02'!sameAs: aHumStatement 	^ (self source) sameAs: (aHumStatement source).! !!HumStatement methodsFor: 'logging' stamp: 'RichardAlexanderGreen 1/16/2012 14:45'!syntaxError: anErrorMessage 	"Error signal: anErrorMessage."	(self errors) add: anErrorMessage.! !!HumStatement methodsFor: 'translate' stamp: 'RichardAlexanderGreen 3/1/2014 09:17'!asCamelCase 	"Convert this statement to camelCase."	| tokens code   first |	code := ''.	first := true.	tokens := (self source) findTokens: ' ,.-'.  "Do not inlude articles in the camel case."	(tokens reject: [:token | #( 'a' 'an' 'the' ) includes: (token asLowercase) ])		do: [ :token |				first ifTrue: [ code := code, token asLowercase .						            first := false.]					   ifFalse: [ code := code, (token capitalized) ].			].		^code! !!HumStatement methodsFor: 'translate' stamp: 'RichardAlexanderGreen 3/1/2014 09:11'!asCamelCaseWithOntology: aHumOntology 	"Convert this statement to camelCase."	| tokens code   first |		code := ''.	first := true.	tokens := (self source) findTokens: ' ,.-'.	tokens		do: [ :token |				"TODO: Consider an option to drop articles ('a' or 'the')"								first ifTrue: [ code := code, token asLowercase .						first := false.]					ifFalse: [ code := code, (token capitalized) ].			].	"TODO: Deal with polymorphism by looking up the proper definition.	Can borrow algorithm from prior version of SimpleEnglish ?	However, by removing nouns from the camelCase, I could just let Java do the work.	BAD IDEA: Depending on Java would make the semantics target-language-dependent.	"	^code! !!HumStatement methodsFor: 'translate' stamp: 'RichardAlexanderGreen 4/9/2012 12:46'!nounAsCamelCase: aString 	"Delegate to ontology class"	^ HumOntology nounAsCamelCase: aString.! !!HumStatement methodsFor: 'translate' stamp: 'RichardAlexanderGreen 3/23/2012 15:30'!onMatch: aPatternString do: aBlockClosure 	"When my source matches pattern, execute the block with matching arguments."	| match whitespace punctuation quote myTokens patternTokens xMe xPattern arguments myToken patternToken list |	"Parse me and the pattern."	whitespace := ' 			'.	quote := $' asString.	punctuation := '~!!@#$%^&*()_+`={}|[]\:";<>?,./', quote.		myTokens := self source asLowercase  findTokens: ( punctuation, whitespace ) keep: punctuation.	patternTokens := aPatternString asLowercase  findTokens: ( punctuation, whitespace ) keep: punctuation.	"Quick test: Exit if the first token does not match."	myToken := myTokens at: 1.	patternToken := patternTokens at: 1.	(            ( myToken sameAs: patternToken ) 	or: [ '123456789*' includesSubString: patternToken ] )		ifFalse: [^self ].	"Looks like the first word matches, go on."	xMe := 1.	xPattern := 0.	arguments := OrderedCollection new.	match := false.	patternTokens 		do: [ :token | "For each pattern token:"			patternToken := token.			match := false.			xPattern := xPattern + 1.			( '123456789' includesSubString: patternToken )				ifTrue: [ "Current token is an argument"					arguments add: (myTokens at: xMe). 					match := true.					].			( patternToken = '*' )				ifTrue: ["This only works when the next pattern token is also downstream in myTokens"					((myTokens copyFrom: xMe+1 to: myTokens size ) includes: ( patternTokens at: xPattern + 1))						ifFalse: [ ^self ]						ifTrue: ["Next argument is a list"							| stopper |							stopper := ( patternTokens at: xPattern + 1).							list := OrderedCollection new.							[ (myTokens at: xMe) sameAs: stopper ] 								whileFalse: [ 									( #( ',' 'and' ) includes: (myTokens at: xMe)  )									 	ifFalse: [list add: (myTokens at: xMe).].					 									xMe := xMe + 1. 									].							arguments add: list.							"At this point we have to jump to the conclusion and exit the outer-do."							"*** TODO *** This logic will only work for lists that are at the end of the statement, but not in the middle."							aBlockClosure valueWithArguments: arguments.							^self.							].						].			( patternToken sameAs: ( myTokens at: xMe ) )						ifTrue: ["myToken matches a keyword. Proceed to next token."						match := true.].					match ifTrue: [ xMe := xMe + 1 ] 
					ifFalse: ["Got to here with no match. But allow for dropped 'a', 'an', 'the', 'this', 'that'. "											    ( #('a' 'an' 'the' 'this' 'that' ) includes: patternToken )						                        ifFalse: [^self]					              ].					].	"If we've gotten this far, the pattern matched and we have zero or more arguments."		( arguments size = 0 )		ifTrue: [ aBlockClosure value ]		ifFalse: [ aBlockClosure valueWithArguments: arguments ].	^self.	! !!HumStatement methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/3/2014 10:39'!delegateToTranslator	Error signal: 'This statement function should be delegated to Ontology Translator (HumOntologyTranslator).'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumStatement class	instanceVariableNames: ''!!HumStatement class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 12/30/2011 14:12'!from: aSource	| newStatement |	newStatement := self basicNew.	newStatement source: aSource.	^newStatement.! !!HumStatement class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 1/16/2012 14:37'!source: aSource	| |	^ self from: aSource.! !!HumStatement class methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 1/2/2012 17:22'!isKeyWord: aString	| keyWordList answer |	keyWordList := #( 'if' 'else' 'for' 'each' 'in' 'giving' ).	answer := ( keyWordList includes: aString ).	^answer.! !HumFrameLine subclass: #HumTitleLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumTitleLine commentStamp: 'RichardAlexanderGreen 9/28/2012 12:52' prior: 0!Every frame has a title line. It is simply the first line of the frame.The title must uniquely identify the frame within the ontology.The title should be descriptive of the content.The title of a role-action frame consists of the role-name and the action statement.The title of a dialog-context frame consists of the dialog-title and the context-title.The title of a view or a dictionary frame is a single string.The title of a plan frame is the post-condition statement. (That means there can only be one way to reach the post-condition!!)!HumFrameLine subclass: #HumConditionLine	instanceVariableNames: 'statement comment annotation'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumConditionLine commentStamp: 'RichardAlexanderGreen 9/28/2012 12:43' prior: 0!A precondition line occurs in a plan frame's preconditions section.As a matter of style, it should be stated as an assertion or declaration. (Present tense descript of the required state of the system.)A precondition line may contain a statement with an optional comment and/or annotation.Here is an example:___Post:  . . .Pre:. All necessary ingredients are on-hand. 	(In the local kitchen) 	[assumed]The comment is within round parentheses.The annotion is withing square brackets.Instance Variables:	statement	<HumStatement>	comment	<ProtoObject>	annotation	<ProtoObject>!!HumConditionLine methodsFor: 'compiling' stamp: 'RichardAlexanderGreen 2/10/2012 12:19'!checkSyntaxWithOntology: aHumOntology 	|  nouns errors correspondingPlanFrame |	errors := OrderedCollection new.	statement := HumStatement from: (self statement).	nouns := aHumOntology nounsInStatement: statement.	( nouns isEmpty ) 		ifTrue: [ errors add:( 'Precondition {" ', statement source, ' "} has no known nouns!!' ) ].	"Is the precondition assumed?"	( ( self annotation ) sameAs: 'assumed' )		ifTrue: [ ^errors ].	"Otherwise: See if we have a plan for satisfying this precondition."	correspondingPlanFrame := aHumOntology getPlanFrameForGoal: statement.	"#getPlanFrameForGoal: will return an empty plan frame  if there is none in the ontology. 	Also, the ontology might contain an empty frame. 	In either case, an empty frame is not a usable subplan.	"	( correspondingPlanFrame isNoPlan ) 		ifTrue: [ errors add:  'Precondition {" ', statement source, ' "} has no plan.'].	^errors.! !!HumConditionLine methodsFor: 'compiling' stamp: 'RichardAlexanderGreen 8/23/2013 14:46'!compileLineToOntology: aHumOntology 	"compile a precondition line into the ontology.	Update where-used.	"	| problems |	problems := self checkSyntaxWithOntology: aHumOntology.	^problems.! !!HumConditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/11/2012 13:51'!annotation	^ annotation ifNil: [ '' ].! !!HumConditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/11/2012 13:51'!comment	^ comment ifNil: [ '' ].! !!HumConditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2012 11:13'!source
	| s |	s := self statement asString.	(self comment isEmpty) ifFalse: [ s := s, ( self comment ) ].	(self annotation isEmpty) ifFalse: [ s := s, ( self annotation ) ].	^ s. ! !!HumConditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/11/2012 13:50'!statement		^ statement ifNil: [ '' ].! !!HumConditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/16/2012 14:20'!statement: aSource 	"Set my statement."	statement := nil.	( aSource isKindOf:  String ) ifTrue: [ statement := HumStatement from: aSource ].	( aSource isKindOf: HumStatement ) ifTrue: [ statement := aSource ].	self assert: ( statement isKindOf: HumStatement ).	! !!HumConditionLine methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 5/24/2014 10:41'!<= aHumConditionLine 	"Provide a way to order preconditions	so that we get repeatable sequences when running a plan."	^(self source) <= (aHumConditionLine source)! !HumFrame subclass: #HumFrame4Dictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4Dictionary commentStamp: 'RichardAlexanderGreen 9/19/2012 10:55' prior: 0!A dictionary frame defines noun relationships.!!HumFrame4Dictionary methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!addDictionaryLine: aSourceString 	self frameLines add: ( HumDictionaryLine new statement: aSourceString ).! !!HumFrame4Dictionary methodsFor: 'testing' stamp: 'RichardAlexanderGreen 8/22/2013 15:25'!compileToOntology: aHumOntology 	"Each dictionary line will have some additive effect on the ontology."	| syntaxErrors lineErrors |	"We may discover syntax errors while compiling."	syntaxErrors := OrderedCollection new.	(self frameLines select: [ :frameLine | frameLine isKindOf: HumDictionaryLine ] )		do: [ :dictionaryLine |			lineErrors := dictionaryLine compileLineToOntology: aHumOntology.			syntaxErrors := syntaxErrors, lineErrors.
			].	^syntaxErrors.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrame4Dictionary class	instanceVariableNames: ''!!HumFrame4Dictionary class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 7/8/2013 09:45'!ontology: anOntology title: aString	"Create an instance with this ontology and title"	| instance |	instance := self new.	instance		ontology: anOntology;		titleLine: ('Dictionary: ', aString).	^instance! !