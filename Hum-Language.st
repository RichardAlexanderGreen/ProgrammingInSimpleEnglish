Object subclass: #HumOntologyTranslator	instanceVariableNames: 'methodsForClasses prologues'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumOntologyTranslator commentStamp: 'RichardAlexanderGreen 2/26/2013 12:21' prior: 0!This class provides tools used to produce source code modules.Strategies vary a little depending on the target language and framework.This is crude version - oriented toward Smalltalk and other object-oriented frameworks.	- Roles become classes.	- Entity-Attribute relations become class accessors. { but in what class ??? }	- Noun datatypes are one of: ( Entity Category Enumeration String Measure TimeStamp ).	- Dialogs become method calls with blocks.	- Views are translated to some Web Server framework { Seaside when target is Smalltalk }.	I am thinking that something like Erlang or Scala might be the best target frameworkbecause those frameworks support "actors", distribution, and parallel processingin relatively natural ways.In any case, the original Hum code will be included as comments in the generated code.This can assure that translations to less readable languages (Javascript, Erlang)will still be maintainable in those languages (not recommended)should the user-programmer decide to go that way.!!HumOntologyTranslator methodsFor: 'Generate OO Modules' stamp: 'RichardAlexanderGreen 3/15/2013 17:04'!attachAction: aMethodName toActorClass: aClassName fromSource: aSource	"Attach the given method source 		to the given class 			under the given method name."	| methods |	methods := self getMethodsForClass: aClassName.	self assert: (methods isKindOf: Dictionary ).	methods at: aMethodName put: aSource.	  ! !!HumOntologyTranslator methodsFor: 'Generate OO Modules' stamp: 'RichardAlexanderGreen 3/15/2013 17:14'!attachPrologToActorClass: aClassName fromSource: aSourceString 	"Attach the given prologue source code to the named class."	| |	"Note: There can be only one prologue for each actor class"	( self prologues ) at: aClassName put: aSourceString.! !!HumOntologyTranslator methodsFor: 'Generate OO Modules' stamp: 'RichardAlexanderGreen 2/27/2013 15:01'!getMethodsForClass: aClassName	"Get the methods colletion (a Dictionary) for the given Class"	| methods |	methods := ( self methodsForClasses ) at: aClassName ifAbsent: [ nil ].	methods 		ifNil: [ methods := Dictionary new. 						( self methodsForClasses ) at: aClassName put: methods.						].	^methods.! !!HumOntologyTranslator methodsFor: 'Generate OO Modules' stamp: 'RichardAlexanderGreen 2/27/2013 15:02'!methodsForClasses	^ methodsForClasses ifNil: [ methodsForClasses := Dictionary new ].! !!HumOntologyTranslator methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/15/2013 17:15'!prologues	^ prologues ifNil: [ prologues := Dictionary new ].! !Object subclass: #HumParseString	instanceVariableNames: 'string index'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumParseString commentStamp: 'RichardAlexanderGreen 9/19/2012 11:15' prior: 0!HumParseString -- This class was created as part of an experiment in parsing.See testP000 under HumUserInterfaceTestsInstance Variables:	string	<ProtoObject>	index	<Integer>!!HumParseString methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/27/2012 10:23'!index	^ index ifNil: [ index := 1 ].! !!HumParseString methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/27/2012 10:20'!string	^ string ifNil: [ Error signal: 'parse string has not been set'].! !!HumParseString methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/27/2012 10:24'!string: aString 	string := aString.	index := 1.! !!HumParseString methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 8/27/2012 10:22'!nextEquals: aString 	| result x |	result := false.	x := ( self string ) findString: aString startingAt: (self index) caseSensitive: false.	result := ( x = (self index) ).	^result.! !Object subclass: #HumFrameLine	instanceVariableNames: 'source indentLevel'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrameLine commentStamp: 'RichardAlexanderGreen 9/19/2012 11:09' prior: 0!A frame line conforms to a specific notation.For example, a dictionary line conforms to dictionary syntax.Instance Variables:	source	<String>!!HumFrameLine methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 10/30/2012 13:56'!asHTML5	| html calc |	calc := HumCalculator new.	html := calc xml: 'frameLine' with: [self source].	^html.! !!HumFrameLine methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 10/30/2012 13:57'!asHTML5withOntology: aHumOntology	| calc | 	calc := HumCalculator new.	^ calc xml: 'frameLine' with: [ self source ].! !!HumFrameLine methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 1/11/2012 19:34'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		"nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);"		nextPutAll: title;		nextPutAll: '( ', self source, ' )';		nextPutAll: String cr.! !!HumFrameLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2012 14:03'!source	^ source! !!HumFrameLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2012 13:59'!source: aByteString 	source := aByteString! !!HumFrameLine methodsFor: 'testing' stamp: 'RichardAlexanderGreen 3/30/2012 10:30'!checkForAntecedantsIn: aHumStatement withOntology: aHumOntology 	| antecedants myNouns result |	antecedants := aHumOntology nounsInStatement: aHumStatement.	myNouns := aHumOntology nounsInStatement: self statement.	result := OrderedCollection new.	( antecedants includesAllOf: myNouns )		ifTrue: [ ^result ].	( myNouns copyWithoutAll:  antecedants )		do: [ :noun |			result add: 'The noun: "',noun,'" has no antecedant.'. 			].	^result.! !!HumFrameLine methodsFor: 'testing' stamp: 'RichardAlexanderGreen 1/18/2012 14:00'!checkSyntaxWithOntology: aHumOntology 	|  nouns errors  |	errors := OrderedCollection new.	nouns := aHumOntology nounsInStatement: (self statement).	(nouns isEmpty ) 		ifTrue: [ errors add:( 'Statement { ', self statement source ,' } has no known nouns!!' ) ].	^ errors.! !!HumFrameLine methodsFor: 'testing' stamp: 'RichardAlexanderGreen 10/18/2012 09:52'!getString: sourceString between: stringA and: stringB	"Return the substring in the sourceString between the two."	| xStart xStop result |	xStart := sourceString findString: stringA startingAt: 1 caseSensitive: false.	( xStart > 1 ) ifFalse: [ ^nil ].	xStop := sourceString findString: stringB startingAt: xStart caseSensitive: false.	( xStop > xStart ) ifFalse: [ ^nil ].	result := sourceString copyFrom: (xStart + 1) to: (xStop - 1).	^result.! !!HumFrameLine methodsFor: 'testing' stamp: 'RichardAlexanderGreen 1/15/2012 09:38'!sameAs: anotherFrameLine	^ ( self source ) sameAs: ( anotherFrameLine source ).! !!HumFrameLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/27/2012 19:43'!extractPatternParameters: aPatternString 	"Extract parameters (tokens) from source that match the pattern."	| parameters patternTokens selfTokens isMatch |	parameters := OrderedCollection new.		self assert: ( aPatternString isKindOf: String ).	patternTokens := self getTokensIn: ( aPatternString asLowercase ).  	selfTokens := self getTokensIn: ( self source asLowercase ).	"Search to see if a sequence in my tokens matches a sequence in pattern tokens."	isMatch := self matchTokensIn: selfTokens at: 1 matchTokensIn: patternTokens at: 1.		isMatch ifFalse: [ Error signal: 'Attempt to get parameters when pattern does not match.' ].	self getParametersIn: selfTokens at: 1 thatMatchParametersIn: patternTokens at: 1 accumulating: parameters.	^ parameters reversed.! !!HumFrameLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/27/2012 20:54'!generateCodeFrom: aTemplateString using: parameterValues 	"Generate code (string) from the template replacing paramters with values in the parameter list."	| templateTokens code xParameter |	self assert: ( aTemplateString isKindOf: String ).	self assert: ( parameterValues isKindOf: OrderedCollection ).	code := String new.	templateTokens := self getTokensIn: aTemplateString.	templateTokens 		do: [ :token | "For each token:"			| atParameter |			atParameter := ( ( ( token size = 1) and: [ token isAllDigits ] ) ).			atParameter				ifTrue: [ code := code, ( parameterValues at:  ( token asNumber ) ).  ]				ifFalse: [ code := code, token ].			].	^code.! !!HumFrameLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/27/2012 19:30'!getParametersIn: selfTokens at: xSelf thatMatchParametersIn: patternTokens at: xPattern accumulating: parameters	"See if we can get any matching sequence."	| pToken atParameter  isMatch parameter |	isMatch := false.	 parameter := nil.	"If we run out of pattern, we have succeeded."	( xPattern > (patternTokens size) ) ifTrue: [ ^true ].	"If we run out self before we run out of pattern, we have failed."	( xSelf > ( selfTokens size ) ) ifTrue: [^false].	"A pattern token that is a digit will match anything. 	 Proceed to next token in both lists.	 But if there is no match there, the pattern token could still match the next self token, so try that.	"	pToken := patternTokens at: xPattern.	atParameter := ( ( ( pToken size = 1) and: [ pToken isAllDigits ] ) ).	atParameter			ifTrue: [ isMatch := (self getParametersIn: selfTokens at: (xSelf + 1 ) thatMatchParametersIn: patternTokens at: (xPattern + 1 ) accumulating: parameters )								   or: [self getParametersIn: selfTokens at: (xSelf + 1 ) thatMatchParametersIn: patternTokens at: (xPattern + 0 ) accumulating: parameters ].					    isMatch ifTrue: [ parameters add: ( selfTokens at: xSelf ) ].						  ^isMatch.					].	"Remainder assumes that current pattern token is not a parameter."					self assert: ( atParameter not ).	"If the current pattern token matches the current self token, proceed to the next token in both lists."	( ( patternTokens at: xPattern ) sameAs: ( selfTokens at: xSelf ) )			ifTrue: [ "Proceed to next token in both lists"						isMatch := self getParametersIn: selfTokens at: (xSelf + 1) thatMatchParametersIn:patternTokens at: (xPattern + 1) accumulating: parameters.					    ^isMatch 					]			ifFalse: [ "See if the next token in self matches the pattern token"						isMatch := self getParametersIn: selfTokens at: (xSelf + 1) thatMatchParametersIn:patternTokens at: (xPattern + 0) accumulating: parameters.						^isMatch. ].			"At this point we have a mismatch for sure. (I think maybe.)"	isMatch := false.				^isMatch.! !!HumFrameLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/27/2012 20:51'!getTokensIn: aString	| punctuation whiteSpace tokens |	"Punctuation does not include hyphen because nouns may be hypenated."	punctuation := '~!!@#$%^&*()_+`={}|[[]\:";<>?,./'. 	"White space includes space, cr, tab."		whiteSpace := ' 			'.	"Tokens are all lower-case and include punctuation."	tokens := ( aString asLowercase ) findTokens: ( punctuation, whiteSpace ) keep: (punctuation, whiteSpace).		^tokens.! !!HumFrameLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/27/2012 19:32'!matchTokensIn: selfTokens at: xSelf matchTokensIn: patternTokens at: xPattern	"See if we can get any matching sequence."	| pToken atParameter isMatch |	isMatch := false.	"If we run out of pattern, we have succeeded."	( xPattern > (patternTokens size) ) ifTrue: [ ^true ].	"If we run out self before we run out of pattern, we have failed."	( xSelf > ( selfTokens size ) ) ifTrue: [^false].	"A pattern token that is a digit will match anything. 	 Proceed to next token in both lists.	 But if there is no match there, the pattern token could still match the next self token, so try that.	"	pToken := patternTokens at: xPattern.	atParameter := ( ( ( pToken size = 1) and: [ pToken isAllDigits ] ) ).	atParameter			ifTrue: [ isMatch := (self matchTokensIn: selfTokens at: (xSelf + 1) matchTokensIn: patternTokens at: (xPattern + 1))								   or: [self matchTokensIn: selfTokens at: (xSelf + 1) matchTokensIn: patternTokens at: (xPattern + 0 ) ].						^isMatch. 					].	"Remainder assumes that current pattern token is NOT a digit."					self assert: (  atParameter not  ).	"If the current pattern token matches the current self token, proceed to the next token in both lists."	( ( patternTokens at: xPattern ) sameAs: ( selfTokens at: xSelf ) )			ifTrue: [ "Proceed to next token in both lists"						isMatch := self matchTokensIn: selfTokens at: (xSelf + 1) matchTokensIn: patternTokens at: (xPattern + 1).					    ^isMatch 					]			ifFalse: [ "See if the next token in self matches the pattern token"						isMatch := self matchTokensIn: selfTokens at: (xSelf + 1) matchTokensIn: patternTokens at: (xPattern + 0).						^isMatch. ].			"At this point we have a mismatch for sure. (I think maybe.)"	isMatch := false.				^isMatch.! !!HumFrameLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/27/2012 19:12'!matchesPattern: aPatternString 	"Does some part of the line match the given pattern?"	| patternTokens selfTokens isMatch |	self assert: ( aPatternString isKindOf: String ).	patternTokens := self getTokensIn: ( aPatternString asLowercase ).  	selfTokens := self getTokensIn: ( self source asLowercase ).	"Search to see if a sequence in my tokens matches a sequence in pattern tokens."	isMatch := self matchTokensIn: selfTokens at: 1 matchTokensIn: patternTokens at: 1. 	^isMatch.! !!HumFrameLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/27/2012 10:44'!onMatch: aPatternString generate: aTemplateString 	"When some part of the content in the current line matches the pattern,	 - Generate code from the template.	 - Replace parameters indicated by digits with corresponding values in the parameter array.	"	| code parameters |	self assert: ( aPatternString isKindOf: String ).	self assert: ( aTemplateString isKindOf: String ).	"If there is no match, there is nothing to do. Return an empty string."	code := String new.	( self matchesPattern: aPatternString ) ifFalse: [ ^code ].	"Otherwise, we have a match.	Generate some code.	"	parameters := self extractPatternParameters: aPatternString.	code := self generateCodeFrom: aTemplateString using: parameters.	^code.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrameLine class	instanceVariableNames: ''!!HumFrameLine class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 1/13/2012 11:41'!source: aByteString      | frameLine |	frameLine := self new.	frameLine source: aByteString.	^frameLine.! !HumFrameLine subclass: #HumTranslationLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumTranslationLine commentStamp: 'RichardAlexanderGreen 9/28/2012 13:33' prior: 0!A translation line may occur between triple-brace lines in a role-action frame.It specifies how an action statement (generally an internal "To:" statement) may be implemented in some target language.Generally the implementation will be a method declaration where the role is assumed to be implemented as a class.Here is an example:____Role: Invoicing.To: Extend the order's unit prices.. As Smalltalk:{{{extendOrderLinePricesFor: anOrder	"Multiply the unit price times the quantity to fill in the extended price. 	Then apply any quantity discounts."	( anOrder orderLines )		do: [ :orderLine |			orderLine extendedPrice: (orderLine quantity) * (orderLine price).			orderLine applyQuantityDiscountIfAny.			"The quantity discount rule depends on the the catalogNumber and quantity"			 ].}}}___In this case, the translator will assemble the given translation lines with other translation lines to produce a Smalltalk class definition.Similar results might be obtained for translation to Java or Python or Javascript or Objective-C.Note: The code above could have been written entirely in Hum without the need to use an external framework.  This example was used because it does not require explanation of the context.The general form is:___To: <action statement>.. As <language>:{{{   <several lines in the target procedural language>}}}___Note: "To: . . . " could also be "Action: . . . ". (That is allowed but is probably bad form.)!HumFrameLine subclass: #HumCommentLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumCommentLine commentStamp: 'RichardAlexanderGreen 9/28/2012 11:14' prior: 0!A comment line is a line in a single-line or multi-line comment.The lines in the multi-line comment are signaled by a line that begins with a '(' -- a right parend.The lines end with a line that ends with a ')' -- a left parend.Note: In some ontology text files, an additional convention allows a frame or subframe that begins with a 'Comment:' label and ends when the next label (of any kind) is encountered. !!HumCommentLine methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/30/2012 13:51'!asHTML5withOntology: aHumOntology 	^ (HumCalculator new) xml: 'commentLine' with: [ self source ].! !HumFrameLine subclass: #HumInstructionLine	instanceVariableNames: 'indent role statement comment annotation translation'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumInstructionLine commentStamp: 'RichardAlexanderGreen 9/28/2012 11:29' prior: 0!An instruction line may occur in  an action frame,  a plan-frame action section,  or in a dialog vignette as part of the response to a stimulus.Here is a sample instruction line:. Oven: Preheat to temperature. (The oven will emit a ding when the required temperature is reached.)  [duration: 5 minutes]This line has a role (Oven) to which the action is delegated.It has a statement: 'Preheat to temperature.' The action request with the value of the 'temperature' noun will be sent to the actor assigned to the role.It has a comment -- within by round parentheses.It has an annotation -- within square brackets.Instance Variables:	indent	<Magnitude>	role	<String>	statement	<HumStatement>	comment	<Object>	annotation	<ProtoObject>	translation	<ProtoObject | PseudoContext>!!HumInstructionLine methodsFor: 'testing' stamp: 'RichardAlexanderGreen 1/18/2012 13:59'!checkSyntaxWithOntology: aHumOntology 	|  nouns errors |	errors := OrderedCollection new.		"Check that the nouns in the statement are known. (defined in the ontology)."	nouns := aHumOntology nounsInStatement: statement.	( nouns isEmpty ) 		ifTrue: [ errors add: ( 'Statement: {', statement source ,'} has no known nouns!!' ) ].		"Check that a delegated action is defined in the ontology."	( aHumOntology isActionDefined: self ) 		ifFalse: [ errors add: ('Action: {', statement source, '} has not been defined.') ].		^ errors.! !!HumInstructionLine methodsFor: 'testing' stamp: 'RichardAlexanderGreen 10/6/2012 10:39'!compileLineToOntology: aHumOntology 	"Compile this instruction line."	| errors | 	"*** TO DO ***"	errors := OrderedCollection new.	^ errors.! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/13/2012 13:47'!annotation	^ annotation ifNil: [^'' ].! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 20:37'!annotation: aString 	"Annotation may indicate timing for simulations."	annotation := aString.! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/6/2012 11:39'!comment	^ comment ifNil: [''].! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 20:34'!comment: aString 	"Comment is not executable. May be displayed in certain contexts."	comment := aString.! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2012 09:51'!indent	"How many indents (tabs) before the start of the code-text ?"	^ indent ifNil: [ indent := 1 ].! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2012 10:16'!indent: aSmallInteger	"How many indents (tabs) before the start of the code-text ?"	indent := aSmallInteger.	(indent < 1 ) ifTrue: [ indent := 1].! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2012 11:34'!role	^ role  ifNotNil: [ (role) ] ifNil: [''].! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 20:35'!role: aString 	"Delegate the task (statement) to this role at run-time. "	role := aString.! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2012 11:33'!source	"Construct a source line based on convention and content of my attributes."	| s |	s := self statement asString.	(self role trimBoth isEmpty ) ifFalse: [ s :=( role,': ', s ) ].	(self comment isEmpty) ifFalse: [ s := s, ( self comment ) ].	(self annotation isEmpty) ifFalse: [ s := s, ( self annotation ) ].	^ s. ! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 20:36'!statement	"What will be done . . . will be done at run-time."	^ statement! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2012 10:25'!statement: aSource 	"What to do  at run-time?"	| x |	( aSource isKindOf: String ) 		ifTrue: [ "Convert to HumStatement"			| sourceString |			sourceString := aSource.			x := 0.			[ sourceString beginsWith: '. ' ] 				whileTrue: [ "Count the indents."					x := x + 1.					sourceString := sourceString copyFrom: 3 to: (sourceString size).					].			statement := HumStatement from: sourceString. 			"Determine the indent level."			self indent: x.			^self.			].	( aSource isKindOf: HumStatement )		ifTrue: ["Copy the Statement."			statement := aSource copy.			self indent: 1.			^self. ].	self assert: ( statement notNil ).	! !!HumInstructionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2011 07:12'!translation: aString 	translation := aString.! !!HumInstructionLine methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!= anInstruction	( anInstruction isKindOf: String) ifTrue: [ ^ statement = anInstruction ].	( anInstruction isKindOf: HumInstructionLine ) ifTrue: [ ^ statement = ( anInstruction statement ) ].	self halt.! !!HumInstructionLine methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/30/2012 13:59'!asHTML5withOntology: aHumOntology 	| html xmlRole xmlStatement xmlComment xmlAnnotation assembly calc |	calc := HumCalculator new.	"Avoid an empty role element.	Note that colon may be  inserted for HTML readability."	xmlRole :=  (self role isEmpty )  		ifTrue: [''] 		ifFalse: [ (( calc xml: 'role' with: [ (self role) ] ), ':' )].	"Avoid empty statement element."		xmlStatement := (self statement source isEmpty ) 		ifTrue: [''] 		ifFalse: [( calc xml: 'statement' with: [self statement asHTML5withOntology: aHumOntology ] ) ].	"Avoid empty comment element.	Note that parends are added for Hum consistency."	xmlComment := ( self comment isEmpty ) 		ifTrue: [''] 		ifFalse: [ (  calc xml: 'comment' with: [ '( ', (self comment), ' )' ]   ) ].	"Render the annotation."		xmlAnnotation := ( self annotation isEmpty ) 		ifTrue: [''] 		ifFalse: [ (  calc xml: 'annotation' with: [ '( ', (self annotation), ' )' ]   ) ].	"Assemble it without any line breaks."		assembly := xmlRole, xmlStatement, xmlComment, xmlAnnotation.	html :=  calc xml: 'InstructionLine' with: [ assembly ].	"TODO: This all should be inside an instruction tag ?"	^html.! !!HumInstructionLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 3/13/2013 18:03'!asJavaWithOntology: aHumOntology 	| instructionCode statementCode roleCode commentCode cr documentation tab indentation  |	roleCode := 'this'.	commentCode := ''.	cr := String cr.	"space := Character space asString."	tab := Character tab asString.	indentation := (1 to: (self indent)) inject: '' into: [:s :next | s, tab ]. 	documentation := '/** ', (self source ), ' */', cr.	statementCode := (self statement ) asJavaWithOntology: aHumOntology.	"Generate optional code if role or comment is present."	self onRole: [ roleCode := ' a', (role capitalized) ].	self onComment: [ commentCode := ('/* ', (self comment ), ' */'). ].	"Generate Java code -- depending on type of statement."	(self statement isConditional ) "Does the statement begin with For/If/Else ???"		ifTrue: [ instructionCode := indentation, documentation, indentation, statementCode, commentCode. ]		ifFalse: [instructionCode := indentation, documentation, indentation, roleCode,'.', statementCode, '; ', commentCode. ].	^instructionCode.! !!HumInstructionLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 4/3/2012 13:04'!asSmalltalkWithOntology: aHumOntology 	| instructionCode statementCode roleCode commentCode quote cr documentation tab indentation  |	roleCode := ' self'.	commentCode := ''.	quote := $" asString.	cr := String cr.	"space := Character space asString."	tab := Character tab asString.	indentation := (1 to: (self indent)) inject: '' into: [:s :next | s, tab ]. 	documentation := quote, (self source ), quote, cr.	statementCode := (self statement ) asSmalltalkWithOntology: aHumOntology.	self onRole: [ roleCode := ' a', (role capitalized) ].	self onComment: [ commentCode := (quote, (self comment ), quote). ].	(self statement isConditional ) 		ifTrue: [ instructionCode := indentation, documentation, indentation, statementCode, commentCode. ]		ifFalse: [instructionCode := indentation, documentation, indentation, roleCode, ' ', statementCode, '. ', commentCode. ].	^instructionCode.! !!HumInstructionLine methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 2/13/2012 16:04'!onComment: aBlockClosure 	comment ifNil: [^self].	(comment size > 1 ) ifTrue: aBlockClosure.! !!HumInstructionLine methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 2/13/2012 16:03'!onRole: aBlockClosure 	role ifNil: [^self ].	(role size > 1) ifTrue: aBlockClosure.! !!HumInstructionLine methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 7/18/2013 10:45'!runInContext: aHumSupervisor 	"Fake it for now.	TODO: REPLACE THIS STUB"	| aHumMeasure ticket |	self assert: ( aHumSupervisor isKindOf: HumSupervisor ).	"Simulate agent side-effects."	ticket := aHumSupervisor jobTicket.	aHumMeasure := HumMeasure quantity: 1 units: 'step'.	ticket appendCharge: aHumMeasure forAction: self byActor: ((self role),'Actor') inRole: (self role) onJob: (ticket id). 	^self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumInstructionLine class	instanceVariableNames: ''!!HumInstructionLine class methodsFor: 'Instance creation convenience' stamp: 'RichardAlexanderGreen 1/2/2012 21:34'!role: aRole statement: aSourceString  	"Return an instance with given source, role, and comment."	| instruction |	instruction := self new.	instruction statement: aSourceString; role: aRole.	^instruction.! !!HumInstructionLine class methodsFor: 'Instance creation convenience' stamp: 'RichardAlexanderGreen 1/2/2012 21:37'!role: aRole statement: aSourceString annotation: anAnnotation	"Return an instance with given  role, source, and annotation."	| instruction |	instruction := self new.	instruction role: aRole; statement: aSourceString;  annotation: anAnnotation.	^instruction.! !!HumInstructionLine class methodsFor: 'Instance creation convenience' stamp: 'RichardAlexanderGreen 1/2/2012 21:36'!role: aRole statement: aSourceString  comment: aComment	"Return an instance with given source, role, and comment."	| instruction |	instruction := self new.	instruction  role: aRole;  statement: aSourceString; comment: aComment.	^instruction.! !!HumInstructionLine class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 1/3/2012 20:57'!statement: aSourceString 	"Return an instance with given source."	| instruction |	instruction := self new.	instruction statement: aSourceString.	^instruction.	! !HumFrameLine subclass: #HumDictionaryLine	instanceVariableNames: 'statement comment'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumDictionaryLine commentStamp: 'RichardAlexanderGreen 9/28/2012 11:17' prior: 0!A dictionary line is a line in a dictionary frame.The statement in a dictionary line must conform to the dictionary DSL.Instance Variables:	statement	<HumStatement>	comment	<String>!!HumDictionaryLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/9/2012 14:36'!comment	^ comment ifNil: [ comment := String new. ].! !!HumDictionaryLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/9/2012 14:33'!source	"Construct a source line based on convention and content of my attributes."	| s |	s := self statement asString.	(self comment isEmpty) ifFalse: [ s := s, ( self comment ) ].	^ s. ! !!HumDictionaryLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/9/2012 14:35'!statement	^ statement! !!HumDictionaryLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/9/2012 14:38'!statement: aStatementString 	statement := HumStatement from: aStatementString.! !!HumDictionaryLine methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 10/30/2012 14:10'!asHTML5withOntology: aHumOntology 	| calc |	calc := HumCalculator new.					^ calc xml: 'DictionaryLine' 			with: [				(calc xml: 'statement' 					 with: [self statement asHTML5withOntology: aHumOntology ]), 					 ( calc xml: 'comment' with: [self comment] )				  ].! !!HumDictionaryLine methodsFor: 'parsing' stamp: 'RichardAlexanderGreen 1/13/2012 16:50'!getListAfter: aString 	| s sAfter list |	s := self statement source.	sAfter := HumCalculator substringFrom: s after: aString. 	list := sAfter findTokens: ', .'.	"Remove the word 'and' from the list."	list removeAllSuchThat: [ :item | item sameAs: 'and' ].	^list.! !!HumDictionaryLine methodsFor: 'testing' stamp: 'RichardAlexanderGreen 5/7/2013 09:42'!compileLineToOntology: aHumOntology 	"Add nouns and noun-relations to the ontology.	If statement does not match a dictionary statement pattern,	return an error.	"	| lineErrors s entity attributes subtype supertypes |		"We may discover syntax errors while compiling.	 Return an empty list when statement matches okay.	"	lineErrors := OrderedCollection new. 		s := self statement source.		( '*is a*' matches: s )		ifTrue: [ subtype := ( s findTokens: ' ' ) at: 1.				supertypes := self getListAfter: 'is a'.				self assert: ( supertypes size = 1 ).				aHumOntology addNoun: subtype isA: ( supertypes at: 1 ). 				^lineErrors.				].	( '*attributes include*' matches: s ) 		ifTrue: [ attributes := self getListAfter: 'include'.			entity := ( s findTokens: ' ' ) at: 1.			aHumOntology addEntity: entity attributes: attributes.			^lineErrors. 			 ].		(( '*includes a set of*' matches: s )	  or: [ '*has a set of*' matches: s  ] )		ifTrue: [ | attribute |			     attribute := ( self getListAfter: 'a set of' ) at: 1.				entity := ( s findTokens: ' ' ) at: 1.				aHumOntology addEntity: entity attribute: attribute.				aHumOntology addNoun: attribute isA: 'set'.				^ lineErrors.				].	(( '*includes a list of*' matches: s )	  or: [ '*has a list of*' matches: s ] )		ifTrue: [ |attribute| 				attribute := ( self getListAfter: 'a list of' ) at: 1.				entity := ( s findTokens: ' ' ) at: 1.				aHumOntology addEntity: entity attribute: attribute.				aHumOntology addNoun: attribute isA: 'list'.				^ lineErrors.				].	"If we fall through to here, 	 the statement was not matched to any dictionary statement pattern."			lineErrors add:( 'Dictionary statement not understood: ', s).			^ lineErrors.! !Object subclass: #HumFrame	instanceVariableNames: 'frameLines titleLine ontology uniqueIdentifier'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame commentStamp: 'RichardAlexanderGreen 9/19/2012 10:41' prior: 0!A "frame" is a small amount of program code in the ontology.Different types of frames contain different types of information and conform to different notations.A frame has a title and contains a list of frame-lines.Instance Variables:	frameLines	<OrderedCollection>	titleLine	<Object>	ontology	<HumOntology>	uniqueIdentifier	<UUID>!!HumFrame methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 10/30/2012 13:56'!asHTML5withOntology: aHumOntology	"Render source code. 	--  This is a read-only view for ontology code listing."	| html calc |	calc := HumCalculator new.	html :=	calc xml: 'frame'		with: [			(calc xml: 'frameTitle' with: [  self titleLine asString ]),			(self linesAsHTMLwithOntology: aHumOntology)			].	^html.	! !!HumFrame methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 1/9/2012 12:58'!linesAsHTMLwithOntology: anOntology	| html cr |	cr := String cr.	html := cr.	self frameLines 		do: [ :frameLine |				html := html, '<br/>', ( frameLine asHTML5withOntology: anOntology ) ].	^html.! !!HumFrame methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 1/16/2012 15:00'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		"nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);"		nextPutAll: title;		nextPutAll: '( ', self frameName, ' )';		nextPutAll: String cr.! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 19:49'!addFrameLine: aSourceString	self frameLines add: aSourceString.! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 19:48'!frameLines	^frameLines ifNil: [ frameLines := OrderedCollection new.]! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2012 11:04'!frameName	"The name of the frame is guaranteed to be a string.	Generally, it is the same as the titleLine.	"	| frameName |	frameName := (self titleLine) asString.	^ frameName.! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 13:33'!ontology	^ ontology! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 13:33'!ontology: anObject	ontology := anObject! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2012 10:13'!titleLine	^ titleLine ! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2012 10:13'!titleLine: anObject	titleLine := anObject asString! !!HumFrame methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/2/2012 13:16'!uniqueIdentifier	"Note: Lazy initialization for this identifier."	^ uniqueIdentifier ifNil: [ uniqueIdentifier := UUID new. ].! !!HumFrame methodsFor: 'testing' stamp: 'RichardAlexanderGreen 3/30/2012 10:38'!checkSyntaxWithOntology: anOntology	| frameErrors lineErrors    |	frameErrors := OrderedCollection new.	"Check stand-alone syntax.	Detect statements with no nouns.	Detect statements that have not been defined.	"	self frameLines		do: [ :frameLine | 			lineErrors := (frameLine checkSyntaxWithOntology: anOntology).			(lineErrors isEmpty) ifFalse: [ frameErrors := frameErrors, lineErrors ].			].	^frameErrors.! !!HumFrame methodsFor: 'testing' stamp: 'RichardAlexanderGreen 10/6/2012 10:27'!saveFrameToOntology: aHumOntology 	| problems lineProblems |	problems := OrderedCollection new.	self frameLines		do: [ :frameLine |			lineProblems := ( frameLine compileLineToOntology: aHumOntology ).			problems := problems, lineProblems.			].	"Regardless of errors add frame to the ontology."		aHumOntology storeFrame: self.	^problems.! !!HumFrame methodsFor: 'converting' stamp: 'RichardAlexanderGreen 2/13/2012 16:11'!asSmalltalkWithOntology: aHumOntology 	"Translate frame to Smalltalk using the nouns given in the ontology."	| frameCode |	frameCode := ''.	self frameLines		do: [ :line |			| lineCode |			lineCode := line asSmalltalkWithOntology: aHumOntology.			frameCode := frameCode, lineCode, String cr.			].	^frameCode.! !HumFrame subclass: #HumFrame4Action	instanceVariableNames: 'role actionStatement instructions'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4Action commentStamp: 'RichardAlexanderGreen 9/19/2012 10:50' prior: 0!Action frames define the steps (instructions) in an action.An action belongs to a role.Actors may be assigned to a role at run-time.Such actors have a set of action-statements as their external interface.In that sense, they "know" the role.The format of an action frame looks like this:---Role: Cook.Action: Preheat oven to recipe temperature.. (Delegate to oven's robot.). Oven: Set temperature to recipe temperature.. (Proceed with other actions while oven comes up to heat.)Action: Mix ingredients per recipe.. For each ingredient in recipe ingredients:. . Add ingredient quantity to mixing-bowl.. Stir contents of mixing-bowl for 5 minutes.---Instance Variables:	role	<String>	actionStatement	<HumStatement>	instructions	<OrderedCollection>!!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/13/2012 14:23'!actionStatement	^ actionStatement ifNil:[ Error signal: 'Action frame must have an action statement']. ! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/13/2012 14:25'!actionStatement: anObject	actionStatement := nil.	(anObject isKindOf: String) ifTrue: [ actionStatement := HumStatement from: anObject ].	(anObject isKindOf: HumStatement ) ifTrue: [ actionStatement := anObject ].	self assert: ( actionStatement isKindOf: HumStatement ).	! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!addInstructionRole: aRole statement: aStatement 	| frameLine |	frameLine := ( HumInstructionLine role: aRole statement: aStatement ).	self instructionLines add: frameLine.	self frameLines add: frameLine.! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!addInstructionRole: aRole statement: aStatement comment: aComment		| actionInstruction |		actionInstruction := HumInstructionLine new.	actionInstruction role: aRole; statement: aStatement; comment: aComment.		self instructionLines add: actionInstruction.	self frameLines add:  actionInstruction .! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!addInstructionStatement: aSource 	| actionInstruction |		actionInstruction := HumInstructionLine new.	actionInstruction role: ''; statement: aSource; comment: ' '.		self instructionLines add: actionInstruction.	self frameLines add:  actionInstruction .! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/23/2012 07:35'!instructionLines	^ instructions ifNil: [ instructions := OrderedCollection new ].! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 18:02'!instructions	^ instructions ifNil: [ instructions := OrderedCollection new. ].! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 20:44'!instructions: anObject	instructions := anObject! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 20:45'!role	^ role! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2012 20:45'!role: anObject	role := anObject! !!HumFrame4Action methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/6/2012 15:34'!titleLine	^ ( self role), ': ', ( self actionStatement asString ).! !!HumFrame4Action methodsFor: 'testing' stamp: 'RichardAlexanderGreen 11/7/2012 12:12'!checkSyntaxWithOntology: anOntology 	"Critique the instructions for this role action."	|  critique lineCritique action actionNouns |			"Return the critique as a sequence of strings."	critique := OrderedCollection new.		"The action should contain at least one noun."	action := self actionStatement.	actionNouns := anOntology nounsInStatement: action.	( actionNouns size > 0 ) 		ifFalse: [ critique add: ( 'Action statement {',( action asString ),'} has no known nouns!!' ) ].			"There should be at least one instruction for the action statement."			( self instructionLines size > 0 )		ifFalse: [ critique add: 'Action has no instructions.'].				"Nouns in the instructions should find antecedants in the action statement."	(self instructionLines) 		do: [ :instruction | 			lineCritique := ( instruction checkSyntaxWithOntology: anOntology ).			critique := critique, lineCritique.			lineCritique := ( instruction checkForAntecedantsIn: (self actionStatement) withOntology: anOntology ).			critique := critique, lineCritique.						]. 	"TODO: The line after  'For . . .  : ' or  'If . . .  : '  or 'Else:' should be indented."		"TODO: Think about how indentation should be assured. 	In the editor context, the indentation should be automatic.	Note: Indentation is an attribute of an instrution line.	"	^critique.! !!HumFrame4Action methodsFor: 'testing' stamp: 'RichardAlexanderGreen 10/6/2012 10:27'!saveFrameToOntology: aHumOntology 	"Compile the frame into the ontology."	| |	"Add the role-action"		aHumOntology addRole: self role action: self actionStatement.	"Add the instruction sequence"	(self instructionLines )		 do: [ :instruction |			aHumOntology appendRole: (self role) action: (self actionStatement ) instruction: instruction.			].	"Return no errors."		^ (self checkSyntaxWithOntology:  aHumOntology ).		 	! !!HumFrame4Action methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 1/19/2012 07:34'!renderInstructionAt: aSmallInteger withOntology: anOntology	| statement statementTokens renderedTokens tokenType |	"Get the tokens for the statement (if any)."	statement := ((self instructionLines) at: aSmallInteger ) statement.	statementTokens := statement tokens.	renderedTokens := OrderedCollection new.	statementTokens		do: [ :token |			tokenType := #none.			( self ontology isNoun: token )				ifTrue: [ tokenType := #noun ].			( HumStatement isKeyWord: token )					ifTrue: [ tokenType := #keyword ].			renderedTokens add: ( token -> tokenType ).				].	^ renderedTokens.! !!HumFrame4Action methodsFor: 'converting' stamp: 'RichardAlexanderGreen 4/3/2012 15:18'!asJavaWithOntology: aHumOntology 	"Translate frame to Java using the nouns given in the ontology."	| selectorCode frameCode cr indentation priorIndent space tab javaDoc |	cr := String cr.	space := $   asString.	tab := String tab.	indentation := tab.	javaDoc := '/** ', actionStatement asString,' */'.	selectorCode := actionStatement asJavaDeclarationWithOntology: aHumOntology.	frameCode := ''.	priorIndent := 0.	( self frameLines ) 		do: [ :frameLine |			(frameLine indent < priorIndent ) 				ifTrue: [ "Insert a block-end bracket with appropriate indent."					indentation := (1 to: priorIndent) inject: '' into: [:s :next | s, tab ]. 					frameCode := frameCode, cr, indentation, '}'.				].			frameCode := frameCode, cr, (frameLine asJavaWithOntology:  aHumOntology).			priorIndent := frameLine indent.			].	^ javaDoc, cr, selectorCode, space, '{', frameCode, cr, '}' .! !!HumFrame4Action methodsFor: 'converting' stamp: 'RichardAlexanderGreen 4/3/2012 13:05'!asSmalltalkWithOntology: aHumOntology 	"Translate frame to Smalltalk using the nouns given in the ontology."	| selectorCode frameCode priorIndent cr tab indentation |	cr := String cr.	tab := String tab.	selectorCode := actionStatement asSmalltalkWithOntology: aHumOntology.	"Translate the lines. Adding block ends when indent is reduced."	frameCode := ''.	priorIndent := 0.	self frameLines		do: [ :line |			| lineCode |			(line indent < priorIndent ) 				ifTrue: [ "Insert a block-end bracket with appropriate indent."					indentation := (1 to: priorIndent) inject: '' into: [:s :next | s, tab ]. 					frameCode := frameCode, indentation, ']', cr.				].			lineCode := line asSmalltalkWithOntology: aHumOntology.			frameCode := frameCode, lineCode,  cr.			priorIndent := line indent.			].	^ selectorCode, String cr, frameCode .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrame4Action class	instanceVariableNames: ''!!HumFrame4Action class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 9/15/2012 10:55'!ontology: aHumOntology role: aRole action: anActionStatement  	| frame |	frame := HumFrame4Action new.	frame ontology: aHumOntology; 		role: aRole;		actionStatement: anActionStatement.	^frame.	! !HumFrame subclass: #HumFrame4Vignette	instanceVariableNames: 'vignetteContext responseLines instructionLines nextContext pattern'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4Vignette commentStamp: 'RichardAlexanderGreen 9/19/2012 11:08' prior: 0!A dialog contains a set of contexts.A context contains a set of vignettes.A vignette defines a stimulus and a response.The stimulus is a prioritized set of patterns which will be matched against client statements.When a pattern is matched the response is executed.The response may include a speech and/or a short set of instructions.Dialog instructions are addressed to the dialog-agent unless specified otherwise with a role-prefix.The dialog agent maintains a 'stack' of contexts.The contexts nearest the top of the stack have priority when attempting to match client statements.The stack is generally ordered with the most recently used contexts nearest the top.A dialog vignette may command that another context be placed at the top in order to switch contexts.In general, dialogs are organized by the same principles as ALICE chat bots.Instance Variables:	vignetteContext	<Collection | UndefinedObject>	responseLines	<OrderedCollection>	instructionLines	<OrderedCollection>	nextContext	<Collection | UndefinedObject>	pattern	<Collection | UndefinedObject>!!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!addVignetteInstruction: anInstructionLine 	"Append an instruction to be executed in response to the user / client."	| instruction |	instruction := ( HumInstructionLine statement: anInstructionLine).	(self instructionLines ) add: instruction.	(self frameLines ) add: instruction.! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/15/2012 10:58'!addVignetteResponse: aResponseString 	"Append a verbal response line."	| markup |	markup :=  ( HumMarkupLine source: aResponseString ).	self responseLines add: markup.	self frameLines add: markup.! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/19/2012 07:33'!instructionLines	"Return the vignette's instruction lines. "	^ instructionLines ifNil: [ instructionLines := OrderedCollection new. ].! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2012 13:47'!nextVignetteContext	"By default, the next context is the current context."	( nextContext isEmptyOrNil )  ifTrue: [ nextContext := vignetteContext ].	^ nextContext.! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/19/2012 07:32'!nextVignetteContext: aContextName 	"What will be the context after the response is rendered?	The context stack prioritizes responses to otherwise identical user patterns.	"	nextContext := aContextName.! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/19/2012 07:36'!pattern	"What pattern does this vignette respond to?"	^ pattern! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/19/2012 07:36'!pattern: aPatternString 	"Enter a pattern -- What pattern will the vignette respond to?"	pattern := aPatternString.! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/19/2012 07:38'!patternFields	"Parse the pattern and return the [noun] fields - including the brackets."	| fields s field |	fields := OrderedCollection new.	s := self pattern.	self assert: ( s isKindOf: String ).	[ field := HumCalculator substringFrom: s after: '[' before: ']'.  ( field size > 0 )  ]		whileTrue: [  fields add: ( '[', field, ']' ). 						s := HumCalculator substringFrom: s after: ']'.					 ].	^fields.	! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/19/2012 07:39'!patternNouns	"Parse the pattern and return the nouns referenced in [noun] fields. 	When the pattern is recognized, the noun value will be placed on the dialog's blackboard.'	"	| fields s field |	fields := OrderedCollection new.	s := self pattern.	self assert: ( s isKindOf: String ).	[ field := HumCalculator substringFrom: s after: '[' before: ']'.  ( field size > 0 )  ]		whileTrue: [  fields add: (  field ). 						s := HumCalculator substringFrom: s after: ']'.					 ].	^fields.	! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/19/2012 07:40'!responseLines	"What will be the verbal response? "	^ responseLines ifNil: [ responseLines := OrderedCollection new. ].! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/24/2012 18:33'!titleLine	^ 'context: ', ( vignetteContext asString), 'pattern: ', ( pattern asString ).! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2012 13:49'!vignetteContext	"The context is used to prioritize responses when two or more patterns match a user input.	It also provides a category seen when viewing the collection of vignettes.	"	( vignetteContext isEmptyOrNil ) ifTrue: [ Error signal: 'A vignette context is missing.'].	^ vignetteContext! !!HumFrame4Vignette methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/19/2012 07:42'!vignetteContext: aContextString 	"The context is used to prioritize responses when two or more patterns match a user input.	It also provides a category seen when viewing the collection of vignettes.	"	vignetteContext := aContextString. ! !!HumFrame4Vignette methodsFor: 'testing' stamp: 'RichardAlexanderGreen 1/25/2012 14:08'!checkSyntaxWithOntology: anOntology	"Check the vignette for syntax problems."	| critique patternCritique patternNouns |	"First get the critique of the frame lines."	critique := super checkSyntaxWithOntology: anOntology.	patternCritique := OrderedCollection new.		"The vignette must have a context and a pattern."	( vignetteContext isEmptyOrNil  ) ifTrue: [ critique add: 'Vignette has no context!!' ].	( pattern isEmptyOrNil ) ifTrue: [ critique add: 'Vignette has no pattern!!' ].				"The nextContext should be known to the ontology."	(( anOntology vignettesForContext: ( self nextVignetteContext ) ) isEmpty )
		 ifTrue: [ critique add: 'Vignette`s next context {',( self nextVignetteContext ),'} is unknown in ontology. ' ].		"Each [noun] field  in the pattern should reference known nouns."	patternNouns := self patternNouns.	patternNouns 		do: [ :noun | 			(anOntology isNoun: noun) 				ifFalse: [ patternCritique add: 'Vignette pattern references unknown noun: ', noun.]  			].		critique := critique, patternCritique.		^critique.! !!HumFrame4Vignette methodsFor: 'testing' stamp: 'RichardAlexanderGreen 10/6/2012 10:27'!saveFrameToOntology: anOntology	"Update the ontology with this vignette."		anOntology addVignette: self toContext: (self vignetteContext ).		^ ( super saveFrameToOntology: anOntology ) .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrame4Vignette class	instanceVariableNames: ''!!HumFrame4Vignette class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 1/16/2012 10:40'!ontology: aHumOntology vignetteContext: aContextString pattern: aPatternString 	| frame |	frame := self new.	frame ontology: aHumOntology;				vignetteContext: aContextString;				 pattern: aPatternString.	^frame. 		! !HumFrame subclass: #HumFrame4Plan	instanceVariableNames: 'goal preconditions planActions'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4Plan commentStamp: 'RichardAlexanderGreen 9/19/2012 10:57' prior: 0!Plan frames define plan-fragments.A plan frame has a goal-statement (a post condition) and a set of preconditions.The action list defines zero or more actions that implement the transition from the preconditions to the post condition.The action list will not execute until the preconditions are all met.Instance Variables:	goal	<HumStatement>	preconditions	<Set>	planActions	<Set>!!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/8/2013 10:32'!actionStatements	^planActions! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!addActionRole: aRole statement: aSource 	| actionInstruction |		actionInstruction := HumInstructionLine new.	actionInstruction role: aRole; statement: aSource; comment: nil.		self planActions add: actionInstruction.	self frameLines add:  actionInstruction .! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!addActionRole: aRole statement: aSource comment: aComment	| actionInstruction |		actionInstruction := HumInstructionLine new.	actionInstruction role: aRole; statement: aSource; comment: aComment.		self planActions add: actionInstruction.	self frameLines add:  actionInstruction .! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!addInstructionRole: aRole statement: aStatement 	| instruction |	instruction :=  ( HumInstructionLine role: aRole statement: aStatement ).	self planActions add: instruction.	self frameLines add:  instruction.! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/17/2013 11:00'!addPrecondition: aSource 	| precondition |	precondition := (HumPreconditionLine new) statement: aSource.	self assert: ( precondition isKindOf: HumStatement ).	self preconditions add: precondition.	self frameLines add: precondition.! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/30/2011 14:19'!goal	"Get the plan frame's goal statement."	^ goal! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/17/2013 12:54'!goal: aSource 	"This instance variable contains the plan frame's goal statement."	self assert: ( aSource isKindOf: String ).	goal := HumStatement from: aSource.	titleLine := 'Goal: ', aSource.! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/30/2011 14:33'!planActions	^ planActions ifNil: [ planActions := Set new. ].! !!HumFrame4Plan methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/30/2011 14:21'!preconditions	^ preconditions ifNil: [ preconditions := Set new ].! !!HumFrame4Plan methodsFor: 'testing' stamp: 'RichardAlexanderGreen 5/29/2012 19:12'!check	"Check the basic integrity of the plan frame."	| problems |	"The callers sees the problems in the same order we do."	problems := OrderedCollection new.	"The plan frame must have a goal."	( self goal isNil ) 		ifTrue: [ problems add: 'A plan frame must have a goal.']		ifFalse: [ ( self goal source size > 5 ) 						ifFalse: [ problems add: 'A plan frame must have a goal.' ].				 ].		"A plan frame should have at least two preconditions."	(( self preconditions size ) > 1) ifFalse: [ problems add: 'A plan frame should have at least two preconditions.' ].	^problems.! !!HumFrame4Plan methodsFor: 'testing' stamp: 'RichardAlexanderGreen 3/30/2012 10:37'!checkSyntaxWithOntology: anOntology	| frameErrors lineErrors    |	frameErrors := OrderedCollection new.	"Check stand-alone syntax.	Detect statements with no nouns.	Detect statements that have not been defined.	"	self frameLines		do: [ :frameLine | 			lineErrors := (frameLine checkSyntaxWithOntology: anOntology).			(lineErrors isEmpty) ifFalse: [ frameErrors := frameErrors, lineErrors ].			].	"Check data flow. 	Each statement's nouns must have antecedants in the goal statement."	self frameLines		do: [ :frameLine |			lineErrors := (frameLine checkForAntecedantsIn: (self goal) withOntology: anOntology ).			(lineErrors isEmpty) ifFalse: [ frameErrors := frameErrors, lineErrors ].			].	^frameErrors.! !!HumFrame4Plan methodsFor: 'testing' stamp: 'RichardAlexanderGreen 11/7/2012 12:04'!isNoPlan	"Frame is no plan if there are no preconditions and no actions.	Either the preconditions or the action may be empty, but not both.	However, both could have the statement: 'None.' to indicate that the programmer	has not simply forgotten this frame.	Comment: If goal appears as a precondition elsewhere,	. but has no preconditions and no action needed to make it true,	. it could be annotated as [Assumed.] where it appears as a precondition	. and then no frame would be required for it.	TODO: Think about a feature 	. where a precondition marked [Assumed] in one context 	. is automatically marked [Assumed] everywhere.	"	self preconditions isEmpty		ifFalse: [ ^false ].	self planActions isEmpty		ifFalse: [ ^false ].	^true.! !!HumFrame4Plan methodsFor: 'testing' stamp: 'RichardAlexanderGreen 10/6/2012 10:27'!saveFrameToOntology: aHumOntology 	"Check the basic integrity of the plan frame.	If it is viable, put it into ontology."	| problems |	"The callers sees the problems in the same order we do."	problems := OrderedCollection new.			"A plan frame should have at least two preconditions."	(( self preconditions size ) > 1) ifFalse: [ problems add: 'A plan frame must have at least two preconditions.' ].		"The plan frame must have a goal."	( self goal isNil ) 		ifTrue: [ problems add: 'A plan frame must have a goal.']		ifFalse: [ ( self goal source size > 5 ) 						ifFalse: [ problems add: 'A plan frame must have a goal.']						ifTrue: [ "Looks like we have a goal"							aHumOntology addPlanFrame: self ForGoal: (self goal source).								"If the frame has a goal, store the frame regardless of errors."							aHumOntology storeFrame: self.							] .				].				 		^problems.! !!HumFrame4Plan methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 7/8/2013 11:38'!isRunnable
	"A plan frame is runnable 	  if all of its preconditions have been satisfied."	| isRunnable |	isRunnable := false.	isRunnable := (self preconditions) allSatisfy: [ :precondition | precondition isSatisfied ]. 												^isRunnable.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrame4Plan class	instanceVariableNames: ''!!HumFrame4Plan class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 9/15/2012 10:56'!ontology: aHumOntology goal: aGoalStatement	| frame | 	frame := HumFrame4Plan new.	frame ontology: aHumOntology;			goal: aGoalStatement.			^frame.! !HumFrameLine subclass: #HumMarkupLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumMarkupLine commentStamp: 'RichardAlexanderGreen 9/28/2012 12:58' prior: 0!A markup line may occur within a view or a dialog vignette response.In those contexts, a mark-up line is a line that does not begin with a period.(Lines that begin with a period contain instructions to be exectuted by the dialog agent or rendering engine.)The content of the line will be rendered when the view or response is rendered. Hum mark-up uses the following notations:Outline Mark-Up:  (outlines are indicated by a line that begins with a specific special character.)!! a level one heading!!!! a level two heading -- an so on up to level 5.- a bullet at first level of outline-- a bullet at second level of outline -- an so on up to 5 levels --- a bullet at third level of outline -- note that a line that begins with three underscores (___) indicates a horizontal rule (or a splitter)# a numbered outlline - first level## a numbered outline - second level -- and so on up to 5 levels.Text Emphasis:  Text substrings may be emphasized by surrounding the substring as follows:    *bold*    ~italic~    _underline_Widget Mark-Up: [widget] -- a widget is enclosed in square brackets. Widgets are used in interactive contexts. [[button]] -- a button is a widget. The dialog speech-act intended must be defined in a following instruction. [a] -- a widget containing a single character indicates a check-box. The intended action must be defined in a following instruction. (a) -- a radio button. Then intended action must be defined in a following instruction. [type: string ] -- The type indicates the rendering intended.                           Example: [range: utilization ] might render as a meter, or bar, or spinner, depending on the rendering engine and its style rules.Widget Actions:  [attribute] -- The widget names an attribute. The current value (if any) of the attribute is rendered.                      The rendering engine will provide an appropriate widget depending on the type of the attribute.                      For example, a category may be rendered with a pull-down list, text with a text-area, date with a date selector.  [page: title] -- The internal page with the given title is linked.  [link: blah blah | URI ] -- "blah blah" is displayed. The URI links to an external resource.  [pane: title] -- The Hum view frame with the matching title will be rendered at this position.                         More elaborate layouts are achieved by placing panes within panes.Tables:  (These are used to list the content of an entity's collection attributes.)  The columns of the table are indicated by attribute names separated by pipe '|' characters.  Here is an example where an order entity has a list attribute called order-lines.. Table of order-lines.| catalog-id | description | quantity | unit-price |   !!HumMarkupLine methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/30/2012 14:00'!asHTML5withOntology: aHumOntology 	"Render the markup line -- to pretty-print the source. (Not HTML form)."	| calc |	calc := HumCalculator new.	^ calc xml: 'markup' with: [ self  highlightHumWidgets. ].! !!HumMarkupLine methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 11/7/2012 11:48'!checkSyntaxWithOntology: aHumOntology 	"Syntax errors in mark-up mainly have to do with widgets that won't work.	Other errors will simply be rendered as-is.	"	|  errors widgets widgetNoun |	""	errors := OrderedCollection new.	widgets := self widgets.	"Look for unknown nouns in widgets."	widgets 		do: [ :widget | 			widgetNoun := HumMarkupLine widgetNounIn: widget.			( aHumOntology isNoun: widgetNoun )				ifFalse: [ errors add: ('In {', self source,'} the widget contains unknown noun: ', widgetNoun ) ].			].	"TODO: Look for unknown widget-types in widgets."	widgets		do: [ :widget | 			].		^errors.! !!HumMarkupLine methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/19/2012 09:49'!generateCodeOfType: aSymbol fromTokens: tokens at: xToken	"Generate code of the given type HTML/Seaside/JavaScript based on token stream."	| currentToken code cr doubleQuote singleQuote calc |	calc := HumCalculator new.	"Current experiment is to generate HTML5 from Hum mark-up."	self assert: aSymbol = #HTML.	code := String new.	cr := String cr.	"If we ran out of tokens, we are done?"	( xToken > tokens size ) ifTrue: [ ^self ].	currentToken := tokens at: xToken.	"If we are at beginning of line, there are special rules."	( xToken = 1 )		ifTrue: [ "Look for heading, list, or instruction."			(currentToken = '.') 				ifTrue: [ "Line is instruction." "Ignore it for now. Make a comment line as a reminder."					code := '<!!-- ', source, ' -->'.  					^ code.					].			(currentToken = '!!') 				ifTrue: ["Line is heading. But what level?"					| level |					level := 1.					[ (level < (tokens size))  and: [ (tokens at: level + 1 ) = '!!' ] ] whileTrue: [ level := level + 1 ].					"Remainder of line is in this header"					code := calc xml: ('h', (level asString))  with: [ self generateCodeOfType: aSymbol fromTokens: tokens at: level + 1 ] .					^code.					].			(currentToken = '-' ) 				ifTrue: ["Line is list. But what level?"					| level |					level := 1.					[ (level < (tokens size))  and: [ (tokens at: level + 1 ) = '-' ] ] whileTrue: [ level := level + 1 ].					"If level has changed, we need to output <ul> or </ul>"					( level > indentLevel ) ifTrue: [ code := '<ul>', cr. ].					( level < indentLevel ) ifTrue: [ code := '</ul>', cr. ].					"Remainder of line is in this header"					code := code, (calc xml: 'li' with: [ self generateCodeOfType: aSymbol fromTokens: tokens at: level + 1 ]) .					^code.					].				"If we have come this far, the line begins with nothing special."			     "Go on as if we were not on the first token."			].		"Look for quotes -- we need to remove tokens between quotes from translation."		doubleQuote := $".		singleQuote := $".			(currentToken = doubleQuote or: [ currentToken = singleQuote ] )			ifTrue: [ | quote removal x | 				quote := currentToken.				removal := String new.				x := xToken + 1.				[ ( x < (tokens size) ) and: [ tokens at: x = quote ] ] whileFalse: [ removal := removal, (tokens at: x). x := x + 1. ].				code := code, removal, quote, (self generateCodeOfType: aSymbol fromTokens: tokens at: ( x + 1 )   ).				^code.				].		"Look for emphasis -- tokens between are in scope of  . . ."		(currentToken = '*' or: [[ currentToken = '~' ]  or: [ currentToken = '_' ] ] )			ifTrue: [ | emphasis removal x | 				emphasis := currentToken.				removal := String new.				x := xToken + 1.				[ ( x < (tokens size) ) and: [ tokens at: x = emphasis ] ] whileFalse: [ removal := removal, (tokens at: x). x := x + 1. ].				code := code, removal, emphasis, (self generateCodeOfType: aSymbol fromTokens: tokens at: ( x + 1 )   ).				"Note: Above is a bit simplistic. 				It assumes there is nothing to be interpreted in the string between emphasis tokens.				The following would not work properly: *~bold-italic~*  *_bold-and-underlined_*				TBD: Make this smarter.				"				^code.				].		"Look for widgets."		( currentToken = '[' )			ifTrue: [ "What we do depends on the type of widget."				| nextToken |				nextToken := (tokens at: (xToken + 1) ).				( nextToken = 'page' )					ifTrue: [self generatePageWidgetFromTokens: tokens at: nextToken ].				].! !!HumMarkupLine methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 2/24/2013 09:49'!asSeasideWithOntology: aHumOntology 	"Generate Seaside code to implement a view mark-up line."	| lineCode delimiters 	quote doubleQuote period semicolon tokens  outlineCode headingString end fieldName |	"Parse into tokens"	quote := $' asString.	doubleQuote := $" asString.	period := $. asString.	semicolon := $; asString."	delimiters := '`~!!@#$%^&*()+-=;:<>,.?/{}[]|', quote, doubleQuote.	tokens  := source findTokens: (delimiters, String space, String tab) keep: delimiters."			lineCode := String new.	lineCode := lineCode, 'html break. '.	"Generate for heading"	outlineCode := String new.	(source beginsWith: '!!' ) 		ifTrue: [ headingString := source. 						  end := headingString size.												].	(source beginsWith: '!!' ) 		ifTrue: [ outlineCode := 'html heading level: 1; with: ',			                        quote, (headingString copyFrom: 1+1 to: end), quote, period. ].	(source beginsWith: '!!!!' ) 		ifTrue: [ outlineCode := 'html heading level: 2; with: ',			                        quote, (headingString copyFrom: 2+1 to: end), quote, period. ].	(source beginsWith: '!!!!!!' ) 		ifTrue: [ outlineCode := 'html heading level: 3; with: ',			                        quote, (headingString copyFrom: 3+1 to: end), quote, period. ].	(source beginsWith: '!!!!!!!!' ) 		ifTrue: [ outlineCode := 'html heading level: 4; with: ',			                        quote, (headingString copyFrom: 4+1 to: end), quote, period. ].	(source beginsWith: '!!!!!!!!!!' ) 		ifTrue: [ outlineCode := 'html heading level: 5; with: ',			                        quote, (headingString copyFrom: 5+1 to: end), quote, period. ].	lineCode := lineCode, outlineCode.		"Generate input fields."	fieldName := ( self getString: source between: '[' and: ']' ).	fieldName 		ifNotNil: [ "TODO: Expand this to handle [pane: view-name] and other widgets."					| widgetCode |					widgetCode := ' "*** Widget not handled in source: ', source, '***" '.					 ( fieldName includesSubString: ':' ) 						ifFalse: [ "TODO: REFACTOR this so that it is more sensitive the attribute`s data-type. 									Text should render as text-area.									A category should render as a select or radio group.									A date-time as a date-picker.									A set or list should render as a table.									Perhaps a measure should render as text (validated to numeric) plus a select (of unit-of-measure).									"									widgetCode := 'html textInput'									  ,' callback: [:datum | self blackBoard setEntityID: entityID attribute: #', fieldName										,' toValue: datum ]'									  , semicolon									  ,' name: ', (fieldName surroundedBySingleQuotes)									  , semicolon									  ,' value: ',(fieldName surroundedBySingleQuotes)										, period. 									( fieldName size = 1 )  "Over-ride and create a checkbox instead."										ifTrue: [ widgetCode := '"*** Generate code for check-box: [',fieldName,'] ***' ].										].					"Generate something like:					 html anchor								url: 'http://www.seaside.st';								with: 'Visit the Seaside'"					( fieldName beginsWith: 'page:')						ifTrue: [ | pageName | "[page: local page reference]"									pageName := ( HumCalculator substringFrom: fieldName after: 'page:' ).									widgetCode := ' "*** Generate code for page: ', pageName ,'****" '.								  widgetCode := widgetCode, 'html anchor '															,'url: ', ((pageName asCamelCase) surroundedBySingleQuotes)															, semicolon															,'with: ', (pageName surroundedBySingleQuotes )															, period.									].					( fieldName beginsWith: 'link:')						ifTrue: [ | linkName linkURL | "[link: text | uri ]"									linkName := ( HumCalculator substringFrom: fieldName after: 'link:' before: '|' ).									linkURL := ( HumCalculator substringFrom: fieldName after: '|').									widgetCode := ' "*** Generate code for link: ', linkName ,'****" '.								  widgetCode := widgetCode, 'html anchor '															,'url: ', ( linkURL surroundedBySingleQuotes )															, semicolon															,'with: ', ( linkName surroundedBySingleQuotes )															, period.									].					( fieldName beginsWith: 'pane:')						ifTrue: [ | paneName | "[pane: name of a Hum view]"									paneName := ( HumCalculator substringFrom: fieldName after: 'pane:' ).									widgetCode := ' "*** Generate code for pane: ', paneName, '****" '.									"TODO: Hum panes need to be enclosed in table <td> or perhaps <div> 									 . . . so that they can be placed side-by-side.									PERHAPS: We might require that the author indicate the table like this:									| [pane: left-navigation] | [pane: content] | 									That would simplify the code generation, but it leaks some implementation to user view.									In any case, this code-block needs to 'call' the view-code.									"									widgetCode := '(self ontology fetchFrameByName: ', paneName															,') asSeasideWithOntology: (self ontology)', period.									].										lineCode := lineCode, widgetCode.					].		^lineCode. ! !!HumMarkupLine methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 1/9/2012 13:43'!highlightHumWidgets	"Scan the source matching pairs of [. . .] or [[. . .]]."	| html substrings stream |	html := ''.	substrings := source findTokens: '[ ]' keep:  '[ ]'.	"Mark widgets."	substrings 		do: [ :substring |			substring = '[['  ifTrue: [ html := html, '<widget>' ].			substring = '['   ifTrue: [ html := html, '<widget>' ].				html := html, substring.			substring = ']]'  ifTrue: [ html := html, '</widget>' ].			substring = ']'   ifTrue: [ html := html, '</widget>' ].			].		"Keep leading spaces."	stream := ReadStream on: html.	[ ( stream next) = $  ] whileTrue: [ html := '&nbsp;', html. ].			^html.! !!HumMarkupLine methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 12/19/2012 11:15'!widgets	"Scan the source matching pairs of [. . .] or [[. . .]]."	| widgets  s button widget |	widgets := OrderedCollection new.		s := self source.	"Remove the buttons first."	"TODO: If buttons and widgets occur on the same line, 	 this code will force the buttons to appear prior to the other widgets.	 THIS IS A BUG.	 TODO: Find a way to match balanced brackets. 	"	[ button := HumCalculator substringFrom: s after: '[[' before: ']]'.	  ( button size > 0 ) ]		whileTrue: [  widgets add: ( '[[', button, ']]' ). 						s := HumCalculator substringFrom: s after: ']]'.					 ].					"Then get the remaining widgets."			[ widget := HumCalculator substringFrom: s after: '[' before: ']'.	  ( widget size > 0 ) ]		whileTrue: [  widgets add: ( '[', widget, ']' ). 						s := HumCalculator substringFrom: s after: ']'.					 ].	^widgets.! !!HumMarkupLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 9/15/2012 10:58'!compileLineToOntology: aHumOntology 	|  errors widgets widgetNoun |	""	errors := OrderedCollection new.	widgets := self widgets.	"Look for unknown nouns in widgets."	widgets 		do: [ :widget | 			widgetNoun := HumMarkupLine widgetNounIn: widget.			( aHumOntology isNoun: widgetNoun )				ifFalse: [ errors add: ('In {', self source,'} the widget contains unknown noun: ', widgetNoun ) ]				ifTrue: [ 					aHumOntology addNoun: widgetNoun.					aHumOntology addNoun: widgetNoun reference: self.					 ].			].	"Look for unknown widget-types in widgets."	widgets		do: [ :widget | 			].		^errors.! !!HumMarkupLine methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/28/2012 14:01'!xperiment	"This is a coding experiment.	I will try to drive code generation from syntax"	| tokens code |	tokens := super getTokensIn: (self source).	"If the mark-up begins with !! -- we are dealing with a heading"	code := String new.	self generateCodeOfType: #HTML fromTokens: tokens at: 1.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumMarkupLine class	instanceVariableNames: ''!!HumMarkupLine class methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 1/13/2012 15:16'!widgetNounIn: aWidgetString 	"Find the noun in typical field widgets."	| buttonLabel noun s |		"Heuristic: If there is a colon, this is not a field widget. -- Return empty string."	(aWidgetString includes: $: ) ifTrue: [ ^'' ].		"Ignore buttons -- Return an empty string."	buttonLabel := HumCalculator substringFrom: aWidgetString after: '[[' before: ']]'.	(buttonLabel size > 0) ifTrue: [ ^'' ]. 		"s is potential noun -- May need to remove a number-of-lines parameter"	s := HumCalculator substringFrom: aWidgetString after: '[' before: ']'.	(s includes: $ ) 		ifTrue: [ noun := HumCalculator substringFrom: s before: ' ' ]		ifFalse: [ noun := s ].	^noun.! !HumFrame subclass: #HumFrame4Data	instanceVariableNames: 'priorEntityName'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4Data commentStamp: 'RichardAlexanderGreen 9/19/2012 10:54' prior: 0!Data frames provide a notation and means for transferring data between actors.The format is similar to JSON but without the curly brackets.The nesting is indicated by indentation.The notation accomodates tables that populate collection attributes.It also accomdates text (multi-line strings but without formatting) delimited by triple quotes.!!HumFrame4Data methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 2/13/2012 12:55'!asString	| s cr |	cr := String cr.	s := 'Data Frame', cr.	s := s, '---', cr.	( self frameLines )		do: [ :line | s := s, line asString, cr. ].	s := s, '---', cr.			^s.! !!HumFrame4Data methodsFor: 'associating' stamp: 'RichardAlexanderGreen 2/13/2012 12:51'!appendEntity: aEntityName attrribute: anAttributeName value: aValueString 	|  colon indent |	indent := '. '.	colon := ': '.	( ( priorEntityName isNil ) or: [(aEntityName sameAs: priorEntityName) not]  )		ifTrue: [ self addFrameLine: (aEntityName, colon ).				priorEntityName := aEntityName ].	self addFrameLine:  ( indent, anAttributeName, colon, aValueString ).! !Object subclass: #HumOntology	instanceVariableNames: 'nouns nounSubtypes entityAttributes roles roleActions instructionSequences fromFile framesByName framesByIdentifier nounReferences contextVignettes title'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumOntology commentStamp: 'RichardAlexanderGreen 2/25/2013 18:25' prior: 0!HumOntology is similar to a Smalltalk image file.It records the frames that make up the source code.It also tracks the relationships between syntax elements.Instance Variables:	fromFile	        <String>	-- The name of the file where this ontology was last stored (read).	nouns	        <Set>		-- The nouns known in this ontology	nounSubtypes	  <Set>		-- The subtype relations between nouns 												-- set of ( supertype -> suptype)  associations	entityAttributes  <Set>		-- The attributes of those nouns that represent entity names 													-- set of ( entity -> attribute )	roles	          <Set>		-- The roles defined in this ontology 	roleActions  	  <Set>		-- The actions of the roles 													-- set of ( role -> actionStatement )	instructionSequences   <Dictionary>	-- The instructions that define the actions	framesByName	          <Dictionary>	-- frames indexed by name	framesByIdentifier	    <Dictionary>	-- frames indexed by their unique ID!!HumOntology methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/25/2012 09:44'!file	^ fromFile ifNil: [ fromFile := 'HumOntologyFile.ontology' ].! !!HumOntology methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/18/2012 17:51'!file: aString 	fromFile := aString.! !!HumOntology methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/18/2012 17:53'!title	^ title ifNil: [ title :=  (self fromFile), ' -- No title yet.'].! !!HumOntology methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/6/2012 16:27'!title: aString 	title := aString! !!HumOntology methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 9/18/2012 17:50'!renderAs: aSymbol 	self assert: ( aSymbol isKindOf: Symbol ).	self log: 'Ontology: Document ontology as: ', ( aSymbol asString ). 	"TODO -- Call the HTML rendering code."	self renderAsHTMLonFileNamed: ( (self file), '.html')! !!HumOntology methodsFor: 'utility' stamp: 'RichardAlexanderGreen 1/25/2012 14:01'!projectValuesOf: aSetOfAssociations from: aKey	"encapsulate a bit of recurring code"	| resultSet |	self assert: ( aSetOfAssociations isKindOf: Set ).	resultSet := Set new.	aSetOfAssociations do: [ :map | ( map key = aKey) ifTrue: [resultSet add: (map value)] ].	^resultSet.! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 9/15/2012 10:56'!addPlanFrame: aPlanFrame ForGoal: aGoalString 	| |	self assert: ( aPlanFrame isKindOf: HumFrame4Plan ).	(self framesByName )  at: aGoalString asString put: aPlanFrame.	! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 3/12/2013 11:26'!buildPlanTreeForGoal: aGoal 	"Build a list of associations: ( goalStatement -> (precondition statement) )"	| goalStatement planTree subTree rootFrame |	goalStatement := HumStatement from: aGoal.	planTree := OrderedCollection new.	rootFrame := self getPlanFrameForGoal: aGoal.	"Transcript cr; show: ( 'rootFrame = ', rootFrame frameName ); cr."	( rootFrame preconditions )		do: [ :precondition |			planTree add: ( goalStatement -> (precondition statement) ).			subTree := self buildPlanTreeForGoal: (precondition statement).			planTree := planTree, subTree.			"Detect a cycle in the tree."			( planTree anySatisfy: [ :map |  map value = goalStatement ] ) 				ifTrue: [ Error signal: 'cycle detected in plan tree' ].			].			^planTree.! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 1/23/2012 14:21'!checkPlanTreeForGoal: aGoal 	| goalStatement planTreeProblems subTreeProblems rootFrame planFrame |	"Check for problems that would prevent the plan from working."	goalStatement := HumStatement from: aGoal.	planTreeProblems := OrderedCollection new.		"Safety check -- >>buildPlanTreeForGoal: . . . will stop execution if there is a cycle in the plan-tree."	self buildPlanTreeForGoal: aGoal.	rootFrame := self getPlanFrameForGoal: goalStatement.		" Look for preconditions that have no corresponding plan frame in the ontology."	( rootFrame preconditions )		do: [ :precondition |			planFrame := self getPlanFrameForGoal: precondition statement.			(planFrame preconditions size < 1 ) 				ifTrue: [ planTreeProblems add: 'Precondition: {', ( precondition statement asString ), '} has no plan frame.' ].			subTreeProblems := self checkPlanTreeForGoal:   ( precondition statement ).			planTreeProblems := planTreeProblems, subTreeProblems.			].							^planTreeProblems.! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 2/10/2012 08:42'!collectPlanFramesForGoal: aGoalString 	"| goalStatement planTree subTree rootFrame |	goalStatement := HumStatement from: aGoal.	planTree := OrderedCollection new.	rootFrame := self getPlanFrameForGoal: aGoal.	( rootFrame preconditions )		do: [ :precondition |			planTree add: ( goalStatement -> (precondition statement) ).			subTree := self buildPlanTreeForGoal: (precondition statement).			planTree := planTree, subTree.			( planTree anySatisfy: [ :map |  map value = goalStatement ] ) 				ifTrue: [ Error signal: 'cycle detected in plan tree' ].			].			^planTree."	| problems rootFrame frameCollection subSet |	"First check to make sure the plan frames are complete."	problems := self checkPlanTreeForGoal:  aGoalString.	problems isEmpty		 ifFalse: [ Error signal: 'There are problems with the plan tree for goal: ', aGoalString			                                , '\n Problems: ', problems asString. ].	"Collect the plan frames."	frameCollection := Set new.	rootFrame := self getPlanFrameForGoal: aGoalString.	frameCollection add: rootFrame.	( rootFrame preconditions )		do: [ :precondition |			subSet := self collectPlanFramesForGoal: (precondition statement).			frameCollection addAll: subSet.			].	^frameCollection.! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 9/15/2012 10:56'!getPlanFrameForGoal: aGoalString 	| frame |	frame := (self framesByName ) 				at: aGoalString asString				ifAbsent: [ HumFrame4Plan ontology: self goal: aGoalString ].	self assert: ( frame isKindOf: HumFrame4Plan ).	^frame.	! !!HumOntology methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 9/15/2012 10:56'!planFrames	| planFrames |	planFrames := Set new.	( self framesByIdentifier )		keysAndValuesDo:  [ :key :value | 			(value isKindOf: HumFrame4Plan)  ifTrue: [ planFrames add: value ].			].	^planFrames ! !!HumOntology methodsFor: 'render as . . .' stamp: 'RichardAlexanderGreen 10/30/2012 14:02'!asHTML5	"Render the ontology as an HTML5 page.	. Since HTML is based on XML, we create XML elements.	"	| html heading  calc  |	calc := HumCalculator new.	html := calc xml: 'html' 				with: [ "Build the HTML header"					      ( calc xml: 'head' 							with: [ (calc xml: 'title' 										with: [ (self title) asString ]),									self css.								   ]),						"Build the HTML body"							(calc xml: 'body'							with: [ | bodyLines | 									bodyLines := ''.									"Render the ontology fiilename, if any, as an HTML5 heading element."									heading := calc xml: 'heading' with: [ self fromFile asString ].									(self framesByName keysSortedSafely) 										do: [ :frameName  | 											| frame |											frame := framesByName at: frameName.											"Delegate rendering of the frames to the frames."											 bodyLines := bodyLines,'<br/>', ( frame asHTML5withOntology: self ).											"The <br/> seems to be needed. I cannot figure out how to do that with CSS."											] .									heading,'<hr/>',  bodyLines.									"The <hr/> also seems to be needed. I cannot figure out how to do that in CSS either."								   ] )						].	^html.    ! !!HumOntology methodsFor: 'render as . . .' stamp: 'RichardAlexanderGreen 10/30/2012 14:02'!css	| html calc |	calc := HumCalculator new.	html := calc xml: 'style' 			with: [' body {}				heading {font-size: X-LARGE; }								frameTitle {color: BLUE; font-size: larger; font-weight: BOLD;}				frameLine {}								n, noun {color: PURPLE;}				k, keyword {font-weight: BOLD;}								role {font-style: ITALIC;}				statement {}				comment {color: GREEN;}				annotation {}								pattern {}				markup {}				widget {color: RED;}								' ].	^html.! !!HumOntology methodsFor: 'render as . . .' stamp: 'RichardAlexanderGreen 10/17/2012 11:29'!parseStatement: aHumStatement keywords: keywords 	"Parse the statement -- Return a list of token-type pairs: ( token -> tokenType )."	| whitespace punctuation quote tokens tokenTypes tokenType |	whitespace := ' 			'.	quote := $' asString.	punctuation := '~!!@#$%^&*()_+`={}|[]\:";<>?,./', quote.		tokens := aHumStatement source asLowercase  findTokens: ( punctuation, whitespace ) keep: punctuation.	tokenTypes := OrderedCollection new.	"QUESTION: Is the role-label part of the statement? (I think it is part of an instruction, but the statement is separated.)"	tokens 		do: [ :token | 			tokenType := #word.			( self isNoun: token ) ifTrue: [ tokenType := #noun ].			( keywords include: token ) ifTrue: [ tokenType := #keyword ].			( punctuation includes: (token at: 1) ) ifTrue: [tokenType := #punctuation ].			tokenTypes add: ( token -> tokenType ).			].	^ tokenTypes.! !!HumOntology methodsFor: 'render as . . .' stamp: 'RichardAlexanderGreen 1/4/2012 21:02'!render: asSymbol onFileNamed: aNewFile	| string |	string := self asSymbol.	^string.! !!HumOntology methodsFor: 'render as . . .' stamp: 'RichardAlexanderGreen 1/4/2012 21:39'!renderAsHTMLonFileNamed: aNewFile 	| string |	string := self asHTML5.	^string.! !!HumOntology methodsFor: 'render as . . .' stamp: 'RichardAlexanderGreen 3/12/2013 11:25'!showPlanTree: planTree	"See: HumOntologyTests>>test540GetPlanTree 	-- Call to this method is commented out.	See also: HumOntology>>buildPlanTreeForGoal:	"	Transcript cr; show: 'Plan Tree: '; cr.	planTree do: [ :mapPostPre |		Transcript show: ( mapPostPre key ) asString;		                  show: ' -> ';		                  show: ( mapPostPre value ) asString;		                   cr.		].			! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 1/15/2012 10:34'!fetchFrameByIdentifier: aPrimaryKey 	"Fetch the frame with this identifier."	| frame |	frame := ( self framesByIdentifier ) at: aPrimaryKey ifAbsent: [ Error signal: 'No such frame in this ontology!!'].	^frame.! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 1/16/2012 15:29'!fetchFrameByName: aString 	| frame |	self assert: (aString isKindOf: String).	frame := (self framesByName ) at: aString ifAbsent: [ Error signal: 'No frame by this name.'].	^frame.! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 1/25/2012 20:22'!framesByIdentifier	"Each frame is given a unique identifier. 	This store indexes the frames their identifiers."	^ framesByIdentifier ifNil: [ framesByIdentifier := Dictionary new. ].! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 1/15/2012 10:32'!framesByName	"Enable access to frames by their name (title line string)."	^ framesByName ifNil: [ framesByName := Dictionary new ].! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 1/15/2012 08:59'!fromFile	"The file name serves as a natural identifier. "	^ fromFile ifNil: [ ^ '(untitled)' ].! !!HumOntology methodsFor: 'about Frames' stamp: 'RichardAlexanderGreen 9/15/2012 10:55'!storeFrame: aFrame 	"Store this frame in the ontology.	The frame may be stored even if it has errors.	"	| primaryKey frameName |	"If the frame does not have an ID (serial-number) give it one."	"The title of the frame can serve to index it but cannot be used to ID it 		because the title can be changed by the user 			while the intent of the frame remains the same."	primaryKey := aFrame uniqueIdentifier.	( self framesByIdentifier ) at: primaryKey put: aFrame.		"Also enable caller to fetch a frame by its name."	frameName := aFrame frameName.	( self framesByName ) at: frameName put: aFrame.		"Also enable caller to fetch frames by role."	( aFrame isKindOf: HumFrame4Action ) 		ifTrue: [self addRole: (aFrame role) action: aFrame actionStatement.].	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/28/2011 11:56'!addEntity: anEntity attribute: anAttribute       "Define these nouns and their relationship."	self addNoun: anEntity.	self addNoun: anAttribute.	"Add entity-attribute relationship."	self entityAttributes add: ( anEntity -> anAttribute ).! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/30/2011 09:07'!addEntity: anEntity attributes: anAttributeCollection       "Define these nouns and their relationship."	self addNoun: anEntity.	anAttributeCollection 		do: [ :anAttribute | 			self addNoun: anAttribute.			"Add entity-attribute relationship."			self entityAttributes add: ( anEntity ->  anAttribute ).			].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/13/2012 16:59'!addNoun: aNoun 	"Remember noun."	| singularNoun |	singularNoun := self singularFormOfNoun: aNoun.	self nouns add: singularNoun.	"Check if noun has an implied supertype."	self setAutomaticSupertypeForNoun: singularNoun.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/28/2011 13:11'!addNoun: aSubType isA: aSuperType       "Add these nouns and add is-A relation."	| |	"Add these nouns in case they are not already added."	self addNoun: aSubType.	self addNoun: aSuperType.	"Add inverse relation -- Note: subtypes is also a Set."	self nounSubtypes add: (aSuperType -> aSubType).	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/23/2012 17:52'!addNoun: aNounString reference: aFrameLine 	"Remember where nouns are referenced."	(self nounReferences ) add: ( aNounString -> aFrameLine ).! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/29/2011 10:57'!addNouns: anArrayOfNouns 		anArrayOfNouns do: [ :noun | self addNoun: noun ].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/23/2012 14:12'!allAttributesOfEntity: anEntity 	"Get the attributes, the attributes of the attributes, and the attributes of the supertypes."	| allAttributes localAttributes tempAttributes localSupertypes localProperties |		"Get the immediate properties of this entity."	localAttributes := self immediateAttributesOfEntity: anEntity.	localSupertypes := self immediateSupertypesOf: anEntity.		"Entity properties include attributes and supertypes."	localProperties := localAttributes, localSupertypes.		"For each local property: Look up attributes and add them to the result set."	allAttributes := localAttributes.	localProperties 		do: [ :eachProperty |			"RECURSIVE CALL !!!!!!"			tempAttributes := self allAttributesOfEntity: eachProperty.			allAttributes := allAttributes, tempAttributes.			"Detect cycles in the tree."			( allAttributes include: anEntity ) 				ifTrue: [ Error signal: 'noun attribute-tree contains cycle at: ', anEntity ].			 ].			^allAttributes	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/23/2012 14:12'!allSubtypesOf: aSuperType 	"Get the subtypes (if any) of this noun and the subtypes of the subtypes all the way down"	| localSubtypes tempSubtypes allSubtypes |	localSubtypes := self immediateSubtypesOf: aSuperType.	allSubtypes := localSubtypes.	localSubtypes 		do: [ :eachSubtype | 			"RECURSION: Get the subtypes for each of those subtypes."			tempSubtypes := self allSubtypesOf: eachSubtype.			"Merge the sets"			allSubtypes := allSubtypes, tempSubtypes. 			"Detect cycles in the tree."			( allSubtypes includes: aSuperType ) 				ifTrue: [ Error signal: 'noun subtype-tree contains a cycle at: ', aSuperType ].		 	].	"Return the merged set of all subtypes."		^allSubtypes.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/30/2011 10:15'!entityAttributes	"Thisinstance variable is a map, a set of associations ( anEntity -> anAttribute )"	^entityAttributes ifNil: [ entityAttributes := Set new.].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/30/2011 10:28'!immediateAttributesOfEntity: anEntity 	^ self projectValuesOf: (self entityAttributes) from: anEntity.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/30/2011 08:32'!immediateSubtypesOf: aSuperType 	"Get the subtypes (if any) of this noun."	^ self projectValuesOf: (self nounSubtypes) from: aSuperType.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/30/2011 10:49'!immediateSupertypesOf: aNoun	"Get the immedate supertypes (if any) for this noun." 	| mapSet supertypes |	"Initialize the result set."	supertypes := Set new.	"for each map ( supertype -> subtype ):"	mapSet := self nounSubtypes.	mapSet 		do: [ :nounSubtype |			( nounSubtype value = aNoun )				ifTrue: [ supertypes add: nounSubtype key ].			].	^supertypes.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/13/2012 17:05'!isNoun: aNounString 		"Is the given string a noun?"	| singular |	singular := self singularFormOfNoun: aNounString.	^( self nouns ) include: singular.! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/23/2012 17:53'!nounReferences	^ nounReferences ifNil: [ nounReferences := Set new. ].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/30/2011 10:15'!nounSubtypes	"This instance variable is a map, a set of assoications (aSuperType -> aSubType)."	^nounSubtypes ifNil: [ nounSubtypes := Set new.].! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/30/2011 10:16'!nouns	"This instance variable is the set of all nouns that have been defined so far."	^nouns ifNil: [ nouns := Set new.].	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/16/2012 14:08'!nounsInStatement: aHumStatement 	"Return the (known) nouns found in the statement."	| tokens statement statementNouns nounSet |	"Forgive a string instead of a statement."	statement := aHumStatement.	(statement isKindOf: String) ifTrue: [ statement := HumStatement from: aHumStatement ].	self assert: ( statement isKindOf: HumStatement ).		tokens := statement tokens.	nounSet := self nouns.	statementNouns := tokens select: [ :token | nounSet includes: token].	^statementNouns.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/29/2011 10:17'!setAutomaticSupertypeForNoun: aNoun 	"If a hyphenated nouns ends with the name of another noun,	 it is automately a subtype of the other noun."	| tokens suffix |	"See if there is a hyphen in the noun."	tokens := aNoun findTokens: '-'.	( tokens size > 1 ) ifFalse: [^self].		"See if the last token is currently a noun."	suffix := tokens last.	(self nouns include:  suffix) ifFalse: [^self].	       "The last token is currently a noun, so make this noun a subtype."	self nounSubtypes add: ( suffix -> aNoun ).! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 10/26/2012 10:48'!singularFormOfNoun: aNoun 	"If noun ends in 's'  remove the 's'.  Crude."	| s singular |	self assert: ( aNoun isKindOf: String ).	s := aNoun asLowercase.	( s endsWith: 's' ) ifFalse: [ ^ s ].	"Following is first approximation"	singular := s copyFrom: 1 to: (s size - 1).	^singular.	! !!HumOntology methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 12/28/2011 13:14'!yesNoun: aSubtype isAKindOf: aSuperType 	^self nounSubtypes includes: ( aSuperType -> aSubtype  ).! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 2/1/2012 21:27'!actionsOf: aRole	"The actions of a role define its public interface. (API)"      ^self projectValuesOf: (self roleActions) from: (aRole asLowercase ).! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 2/1/2012 20:15'!addRole: aRole 	self assert: (aRole isKindOf: String ).	self roles add: aRole asLowercase.! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 4/10/2012 11:50'!addRole: aRole action: actionStatement      "Add role and action statement."     | |	self assert: ( aRole isKindOf: String ).	self assert: ( actionStatement isKindOf: HumStatement ).	"Assure role is in set."	self addRole: aRole.		"Assure statement is in set."	self roleActions add: (  ( aRole asLowercase )-> actionStatement ).! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!appendRole: aRole action: anAction instruction: aHumInstruction 	"Append the given instruction to the action's sequence of instructions."	| sequence instruction |				"Kludge some polymorphism -- fix-up string arguments"		instruction := aHumInstruction copy.	( instruction isKindOf: String ) ifTrue: [ instruction := HumInstructionLine statement: aHumInstruction ].				"Get the sequence of instructions belonging to this role action."	sequence := self instructionsForRole: aRole action: anAction.		"Append the given instruction to the sequence."	sequence add: instruction.		"Assure that the data store is updated."	self instructionSequences at: ( (aRole asLowercase) -> anAction ) put: sequence.! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 12/29/2011 17:21'!critiqueRole: aRole action: anAction 	"Critique the instructions for this role action."	|  critique actionStatement sequence actionNouns instructionNouns |			"Return the critique as a sequence of strings."	critique := OrderedCollection new.		"The action should contain at least one noun."	actionStatement := self getRole:  aRole action: anAction.	actionNouns := self nounsInStatement: actionStatement.	( actionNouns size > 0 ) 		ifFalse: [ critique add: 'Action Statement has no known nouns.'].			"There should be at least one instruction for the action statement."			sequence := self instructionsForRole: aRole action: anAction.	( sequence size > 0 )		ifFalse: [ critique add: 'Action has no instructions.'].				"Nouns in the instructions should find antecedants in the action statement."	sequence 		do: [ :instruction | 			instructionNouns := self nounsInStatement: instruction statement.			( actionNouns includesAllOf: instructionNouns )				ifFalse: [ critique add: ( 'Some nouns lack antecedants in: ', instruction statement source ) ].			]. 		^critique.! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 3/14/2013 12:38'!getRole: aRole action: aStringOrStatement 	"Get the action if it already exists."	| actionStatement |	"Assure that we are dealing with a HumStatment."	actionStatement := aStringOrStatement copy.	( actionStatement isKindOf: HumStatement ) 		ifFalse: [ actionStatement := HumStatement from: aStringOrStatement ].	"If the role action set already contains the action statement,	    return an equivalent statement.	"		(self roleActions include: ( ( aRole asLowercase ) -> actionStatement ) ) 		ifFalse: [ "The role does not currently define a proper match"			"TODO: Refactor to handle polymorphism."			self error: 'Attempt to get a non-existent action statement.'. 			^nil ].	^actionStatement.! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 12/29/2011 07:57'!instructionSequences	^ instructionSequences ifNil: [ instructionSequences := Dictionary new. ].! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 2/1/2012 21:26'!instructionsForRole: aRole action: anAction 	"Get the instruction sequence (if any) for the given role-action."	^ self instructionSequences at: ( (aRole asLowercase ) -> anAction ) ifAbsent: [ OrderedCollection new.]. ! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 1/17/2012 12:53'!isActionDefined: anInstructionLine 	"See if we have a definition for the given action."	| instructions |	instructions := self instructionsForRole: (anInstructionLine role) action: ( anInstructionLine statement ).	^ ( instructions size > 0 ).		! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 1/17/2012 12:50'!isActionDefinedV01: anInstructionLine 	"See if we have a definition for the given action."	| numberOfDefinitions |	numberOfDefinitions := ( self roleActions ) 		count: [ :map | 			( map key = anInstructionLine  role ) and: [ map value = anInstructionLine statement ].			].	self assert: ( numberOfDefinitions < 2 ).	^ numberOfDefinitions > 0.		! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 12/30/2011 10:20'!roleActions	"This instance variable is a map, a set of associations  ( role -> actionStatement ) "	^roleActions ifNil: [ roleActions := Set new.]! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 12/30/2011 10:20'!roles	"This instance variable contains the set of all roles that have been defined so far."	^roles ifNil: [ roles := Set new.].! !!HumOntology methodsFor: 'about Roles and Actions' stamp: 'RichardAlexanderGreen 3/14/2013 16:22'!yesRole: aRole hasAction: aSource 	^(self actionsOf: (aRole asLowercase ) ) anySatisfy: [ :statement | statement matchesStatement: aSource ] .! !!HumOntology methodsFor: 'about Vignettes' stamp: 'RichardAlexanderGreen 1/25/2012 14:16'!addVignette: aFrame4Vignette toContext: aContext 	"Add to store"	( self contextVignettes ) add: ( aContext -> aFrame4Vignette ).! !!HumOntology methodsFor: 'about Vignettes' stamp: 'RichardAlexanderGreen 1/25/2012 14:13'!addVignetteContext: aByteString pattern: aByteString2 	self shouldBeImplemented.! !!HumOntology methodsFor: 'about Vignettes' stamp: 'RichardAlexanderGreen 1/25/2012 14:04'!contextVignettes	"This set holds the (1:M) relation (context -> vignette)."	contextVignettes ifNil: [ contextVignettes := Set new. ]. 	self assert: (contextVignettes isKindOf: Set ).	^contextVignettes.! !!HumOntology methodsFor: 'about Vignettes' stamp: 'RichardAlexanderGreen 1/25/2012 14:05'!vignettesForContext: aVignetteContext	| vignettes |	self assert: ( aVignetteContext isKindOf: String ).	vignettes := self projectValuesOf:  (self contextVignettes ) from: aVignetteContext.	^vignettes.! !!HumOntology methodsFor: 'translate to' stamp: 'RichardAlexanderGreen 4/10/2012 09:25'!asJava	"This is crude version.	Futures:	- Roles become classes.	- Entity-Attribute relations become classes with get/set methods.	- Noun types are one of: ( Entity Category Enumeration String Measure TimeStamp ).	- Dialogs are become method calls with blocks.	- Views are still interpreted.	"	| code nounCode actionCode |	code := ''.	nounCode := self nounsAsJava.	code := code, nounCode.	actionCode := self rolesAsJava.	code := code, actionCode.	^ code.! !!HumOntology methodsFor: 'translate to' stamp: 'RichardAlexanderGreen 4/10/2012 09:25'!asJavaNew	"This is crude version.	Futures:	- Roles become classes.	- Entity-Attribute relations become classes with get/set methods.	- Noun types are one of: ( Entity Category Enumeration String Measure TimeStamp ).	- Dialogs are become method calls with blocks.	- Views are still interpreted.	"	| code nounCode actionCode |	code := ''.	nounCode := self nounsAsJava.	code := code, nounCode.	actionCode := self rolesAsJava.	code := code, actionCode.	^ code.! !!HumOntology methodsFor: 'translate to' stamp: 'RichardAlexanderGreen 4/10/2012 09:25'!asJavaOld	"This is crude version.	Futures:	- Roles become classes.	- Entity-Attribute relations become classes with get/set methods.	- Noun types are one of: ( Entity Category Enumeration String Measure TimeStamp ).	- Dialogs are become method calls with blocks.	- Views are still interpreted.	"	| code nounCode |	code := ''.	nounCode := self nounsAsJava.	code := code, nounCode.	self framesByName		keysAndValuesDo: [  :frameName :frame |			| frameCode |			frameCode := frame asJavaWithOntology: self.			code := code, frameCode.			].	^ code.! !!HumOntology methodsFor: 'translate to' stamp: 'RichardAlexanderGreen 4/2/2012 10:09'!asSmalltalk	"This is crude version.	Futures:	- Roles become classes.	- Entity-Attribute relations become class accessors.	- Noun types are one of: ( Entity Category Enumeration String Measure TimeStamp ).	- Dialogs are become method calls with blocks.	- Views are still interpreted.	"	| code |	code := ''.	self framesByName		keysAndValuesDo: [  :frameName :frame |			| frameCode |			frameCode := frame asSmalltalkWithOntology: self.			code := code, frameCode.			].	^ code.! !!HumOntology methodsFor: 'translate to' stamp: 'RichardAlexanderGreen 2/25/2013 18:16'!asSmalltalkOnFile: aFileName	"Open file and produce File-Out / File-In format."     "Following is template for file-out / file-in format.""@@Superclass subclass: #@@ClassName	instanceVariableNames: '@@InstanceVariables'	classVariableNames: ''	poolDictionaries: ''	category: '@@ClassCategory'!!!!@@ClassName commentStamp: '@@Stamp' prior: 0!!@@ClassComment!!!!@@ClassName methodsFor: '@@MethodCategory' stamp: '@@Stamp'!!@@MethodSelector	""@@MethodComment""	| @@LocalVariables |	@@MethodCode	!!!!"			| code |	self shouldBeImplemented.	code := ''.	"This is crude version.	Futures:	- Roles become classes.	- Entity-Attribute relations become class accessors.	- Noun types are one of: ( Entity Category Enumeration String Measure TimeStamp ).	- Dialogs become method calls with blocks.	- Views are translated to Seaside html onRender: methods.	"	self framesByName		keysAndValuesDo: [  :frameName :frame |			| frameCode |			frameCode := frame asSmalltalkWithOntology: self.			code := code, frameCode.			].! !!HumOntology methodsFor: 'translate to' stamp: 'RichardAlexanderGreen 4/10/2012 12:45'!nounsAsJava	"Emit java code that implements noun relations."	"Currently this emits all classes into a single code stream. 	In the future, we might want to find a way to map the stream into separate '.java' files.	"	| code entities cr tab semicolon space fnToGetSupertype |	code := ''.	cr := String cr.	tab := String tab.	semicolon := ';'.	space := String space.	"Get a list of the entities."	entities := Set new.	( self entityAttributes ) do: [ :eachMap |  entities add: (eachMap key) ].	"Define a private function that determines the correct supertype for a given noun."	fnToGetSupertype := [ :noun :default | 			|  typeName supertypes |			supertypes := self immediateSupertypesOf: noun.			( supertypes size = 0 ) ifTrue: [ typeName := default ].			( supertypes size > 0 ) ifTrue: [ typeName :=  ( HumOntology nounAsCamelCase:  ( supertypes asSortedCollection at: 1 ) ) capitalized ].			( supertypes size > 1 ) ifTrue: [Error signal: '// WARNING: Cannot correctly translate ', noun, ' to Java because it has more than one supertype.', cr. ].			"Function returns the discovered supertype or the default supertype"			typeName.		].	"Emit a class for each entity."	( entities asSortedCollection ) do: [ :entity | 		| attributes extendsSupertype  |		"Everything extends Entity class -- which provides toHTML(), toXML(), and persistence methods (TBD)."		extendsSupertype := fnToGetSupertype value:  entity value: 'Entity'.		code := code, cr, 'public class ', (HumOntology nounAsCamelCase:  entity) capitalized , ' extends ',extendsSupertype, ' {', cr.		"Get the entity's attributes."		attributes := self immediateAttributesOfEntity: entity.		"Emit instance variable declarations for each attribute. -- Default type is String."		( attributes asSortedCollection ) do: [ :attribute |			|  typeName |			typeName := fnToGetSupertype value: attribute value: 'String'.			( entities include:  attribute ) ifTrue: [typeName :=  ( HumOntology nounAsCamelCase:  attribute ) capitalized ].			code := code, tab, 'public ', typeName, space, ( HumOntology nounAsCamelCase: attribute), semicolon, cr.			].		"Class ends with closing brace and a comment."		code := code, '} // Entity: ', (HumOntology nounAsCamelCase:  entity) capitalized, cr.		].		^code.! !!HumOntology methodsFor: 'translate to' stamp: 'RichardAlexanderGreen 4/10/2012 12:56'!rolesAsJava	| code cr |	code := ''.	cr := String cr.	( self roles asSortedCollection   )		do: [ :role | 			| actions |			code := code, cr, '/** Actor: ', role capitalized, 			             cr, ' * Generated from Hum ontology: ', (self fromFile) asString, 			             cr, ' */'.			code := code, cr, 'public class ', role capitalized, ' extends Actor { ', cr, cr.			actions := self actionsOf: role.						( actions asSortedCollection )				do: [ :actionStatement |					| frame frameCode frameName |					frameName := role capitalized, ': ', actionStatement source.					frame := self fetchFrameByName: frameName.					frameCode := frame asJavaWithOntology: self.					code := code, frameCode.					].			code := code, cr, cr, '} // Actor: ', role capitalized, cr.			].	^code.! !!HumOntology methodsFor: 'translate to' stamp: 'RichardAlexanderGreen 4/10/2012 12:28'!rolesAsJavaOld	| code |	code := ''.	( self roleActions asSortedCollection ) 		do: [ :map | 			| role actionStatement frame frameCode frameName |			role := map key.			actionStatement := map value.			Transcript cr; show: 'in rolesAsJava role: ', role, ' action: ', actionStatement source; cr. 			frameName := role capitalized, ': ', actionStatement source.			frame := self fetchFrameByName: frameName.			frameCode := frame asJavaWithOntology: self.			code := code, frameCode.			].	^code.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumOntology class	instanceVariableNames: ''!!HumOntology class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 6/25/2013 09:52'!baseOntology	"Return a base ontology"	| instance |	instance := HumOntology new.	"TODO: Add base nouns and frames to the base ontology."	^instance.! !!HumOntology class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/9/2012 12:45'!nounAsCamelCase: aString 	| tokens result |	tokens := aString subStrings: '-'. 	result := ''.	tokens do: [ :token |		(result = '') 			ifTrue: [ result := token] 			ifFalse: [ result := result, (token capitalized )].		].	^result.! !!HumOntology class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/13/2012 12:05'!tokensInString: aString	"Return the tokens in the statement as an array of strings."	| punctuation whiteSpace tokens |	"Punctuation does not include hyphen because nouns may be hypenated."	punctuation := '~!!@#$%^&*()_+`={}|[[]\:";<>?,./'. 	"White space includes space, cr, tab."		whiteSpace := ' 			'.	"Tokens are all lower-case and include punctuation."	tokens := ( aString asLowercase ) findTokens: ( punctuation, whiteSpace ) keep: punctuation.	^tokens.! !HumFrame subclass: #HumFrame4View	instanceVariableNames: 'entity'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4View commentStamp: 'RichardAlexanderGreen 9/19/2012 11:00' prior: 0!A view frame indicates the organization of a user interface - as an interactive document.The view frame notation is a mark-up notation.Instance Variables:	entity	<a noun> -- The entity which is the subject of the view.!!HumFrame4View methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/9/2012 12:08'!addMarkUp: aSourceString 	self frameLines add: aSourceString.! !!HumFrame4View methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 18:09'!entity	^ entity! !!HumFrame4View methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2012 18:09'!entity: anObject	entity := anObject! !!HumFrame4View methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/9/2012 11:57'!viewEntity: anEntityType. 	"What entity-type is this view displaying."	entity := anEntityType.! !!HumFrame4View methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/18/2012 08:32'!asSeasideWithOntology: aHumOntology	"Implement the view frame via Seaside components.	This is a code generator.	"	| tab cr frameCode |	cr := String cr.	tab := String tab.	frameCode := String new.	frameCode := frameCode, tab, 'html form with: [ ', cr.	self frameLines		do: [ :line |			| lineCode |			"Generate Seaside code for each line in the view frame"			lineCode := line asSeasideWithOntology: aHumOntology.			frameCode := frameCode, tab, tab, lineCode, cr.			].	frameCode := frameCode, tab, tab,  ']', cr.	^frameCode.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrame4View class	instanceVariableNames: ''!!HumFrame4View class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 1/9/2012 12:05'!ontology: aHumOntology viewEntity: entityType 	| frame |	frame := self new.	frame viewEntity: entityType;	              titleLine: 'View: ', entityType, '.';			 ontology: aHumOntology.	^frame. ! !Object subclass: #HumStatement	instanceVariableNames: 'source errors nounValues jobTicket role translation'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumStatement commentStamp: 'RichardAlexanderGreen 9/28/2012 13:40' prior: 0!Some types of frame lines will contain a statement as part or all of their content.For example, an instruction line might contain a role prefix, a statement, a comment, and a annotation.This statement class is meant to provide a set of services for interpreting and analyzing statements.A statement is simply a sequence of tokens. Some of those tokens must be nouns. Otherwise the statement has no data to give it meaning at run-time  and there is no way for the compiler to check for data continuity.Instance Variables:	source	<String>	errors	<Set>	nounValues	<Dictionary>	jobTicket	<ProtoObject>!!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/30/2011 17:31'!asString	^ self source asString.! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/28/2011 09:13'!errors	^errors ifNil: [ errors := Set new.].! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2012 11:16'!isConditional	(source beginsWith: 'For ' ) ifTrue: [ ^true ].	( source beginsWith: 'If ')   ifTrue: [ ^true ].	( source beginsWith: 'Else:') ifTrue: [ ^true ].	^false.	! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/10/2013 09:34'!jobTicket	"The jobTicket is present when the statement  executed at run time."
	"TODO: Should we mix run-time functions with language functions? "	^ jobTicket ifNil: [ Error signal: 'No job ticket was provided!!' ].! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2013 08:25'!jobTicket: aHumJobTicket 	jobTicket := aHumJobTicket.! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/8/2013 10:13'!noun: nounString value: valueObject 	"Noun values are set at run-time just prior to executing the statement.	Record the name value pair for this noun.	(The noun is assumed to be one that appears in the statement source.)	"	(self nounValues ) at: nounString put: valueObject.! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/8/2013 10:09'!nounValues	"Noun values are set at run-time. 	Typically, they are found on a blackboard and transcribed as needed.	TODO: THINK: Why transcribe and when?	"	^ nounValues ifNil: [ nounValues := Dictionary new.].! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/11/2012 19:36'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		"nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);"		nextPutAll: title;		nextPutAll: '( ', self source, ' )';		nextPutAll: String cr.! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2013 08:26'!role	^role ifNil: [ Error signal: 'role was not set in HumStatement']! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2013 08:28'!role: aString	"What role is meant to execute this statement?	If this is an action statement, 	the resource manager will assign execution 	to an available actor that claims the role at run-time.	"	role := aString.! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2011 15:03'!source	^ source! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/17/2013 10:53'!source: aSource      "Set and check the source string."	|  lastCharacter |		"Remember my source string."	source := '*** SOURCE IS NOT VALID ***'.	( aSource isKindOf:  String )       ifTrue: [ source := aSource trimBoth.].	( aSource isKindOf:  HumStatement ) ifTrue: [ source := aSource source.].	( aSource isKindOf: HumPreconditionLine ) ifTrue: [ source := aSource source.].		self assert:	( source = '*** SOURCE IS NOT VALID ***' ) not.	"Reset errors."	errors := Set new. 		"Syntax check: A statement ends with a period or a colon."	lastCharacter :=  ( source at: ( source size )). 	( lastCharacter = $. ) ifTrue: [^self].	( lastCharacter = $: ) ifTrue: [^self].	"Last character was not a period or colon."	 self syntaxError: 'Statement must end with a period or colon.'.	! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/13/2012 12:08'!tokens	"Return the tokens in the statement as an array of strings."	|  tokens |	tokens := HumOntology tokensInString: (self source).	^tokens.! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2013 09:01'!translation	^translation! !!HumStatement methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2013 09:20'!translation: aString 	translation := aString! !!HumStatement methodsFor: 'testing' stamp: 'RichardAlexanderGreen 12/29/2011 15:04'!= aStatement 	( aStatement isKindOf: String )  ifTrue: [ ^source sameAs: aStatement ].	( aStatement isKindOf: HumStatement ) ifTrue: [ ^ source sameAs: aStatement source ].	^self halt.! !!HumStatement methodsFor: 'testing' stamp: 'RichardAlexanderGreen 1/23/2012 13:04'!hash 	"This HACK (which may be a bad idea) makes HumStatement hash the same as a matching string.	It makes set lookup work.	But maybe it makes some coding error too forgiven.	"	^ ( source hash ).! !!HumStatement methodsFor: 'testing' stamp: 'RichardAlexanderGreen 3/14/2013 16:22'!matchesStatement: aStatement 	self assert: ( aStatement isKindOf: String ).	"TODO: Refactor for polymorphism."	^source sameAs: aStatement.! !!HumStatement methodsFor: 'testing' stamp: 'RichardAlexanderGreen 3/15/2013 15:19'!matchesStatement: aCandidate inOntology: aHumOntology	"Does this statement match the argument -- accounting for supertypes."	| statement candidateTokens myTokens |	( aCandidate isKindOf: String )				ifTrue: [ "First try a shortcut"				(( self source) sameAs: aCandidate ) ifTrue: [^true].				"Otherwise: Convert string to statement."				statement := HumStatement from: aCandidate. 				].	( aCandidate isKindOf: HumStatement )			ifTrue: [ statement := aCandidate ].	"Guard against surprises. At this point, statement should be . . ."	self assert: ( statement isKindOf: HumStatement ).	"Get tokens minus articles."	candidateTokens := ( statement tokens ) difference: #('a' 'the').	myTokens := ( self tokens ) difference: #('a' 'the').	( myTokens size = candidateTokens size ) ifFalse: [ ^false ].	"Is my noun a supertype of the argument`s noun?"	( 1 to: (myTokens size) )		do: [ :x |			| myToken candidateToken |			myToken := myTokens at: x.			candidateToken := candidateTokens at: x.			( myToken sameAs: candidateToken )				ifTrue: ["continue"]				ifFalse: [ "Is myToken a noun? If so, see if my token is a supertype"					( aHumOntology yesNoun: candidateToken isAKindOf: myToken  )						ifTrue: ["continue"]						ifFalse: [ ^false ].					].			].	^ true.		! !!HumStatement methodsFor: 'testing' stamp: 'RichardAlexanderGreen 1/15/2012 10:02'!sameAs: aHumStatement 	^ (self source) sameAs: (aHumStatement source).! !!HumStatement methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 4/3/2012 11:14'!asSmalltalkConditional	| code |	code := ''.	(source beginsWith: 'For ' )		ifTrue: [ code := self asSmalltalkIteration ].	( source beginsWith: 'If ')		ifTrue: [ code := self asSmalltalkIf ].	( source beginsWith: 'Else:')		ifTrue: [ code := self asSmalltalkElse ].			self assert: ( code = '' ) not.	^code.! !!HumStatement methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/24/2012 15:53'!asSmalltalkIf	"Translate a Hum if-statement into a Smalltalk (  ) ifTrue: [] expression."	| code |	code := ''.	self onMatch: 'If 1 2 is greater than 3 4 :'				do: [ :entity1 :attribute2 :entity3 :attribute4 |					code := '(  ( blackboard entity: ',(self nounAsCamelCase: entity1 ) quoted					            , ' attribute: ',  (self nounAsCamelCase: attribute2 ) quoted							, ' ) > ( blackboard entity: ', (self nounAsCamelCase: entity3 ) quoted							, ' attribute: ', ( self nounAsCamelCase: attribute4 ) quoted							, ' ) )  ifTrue: ['.					^code.					].	self onMatch: 'If 1 2 > 3 4 :'				do: [ :entity1 :attribute2 :entity3 :attribute4 |					code := '(  ( blackboard entity: ',(self nounAsCamelCase: entity1 ) quoted					            , ' attribute: ',  (self nounAsCamelCase: attribute2 ) quoted							, ' ) > ( blackboard entity: ', (self nounAsCamelCase: entity3 ) quoted							, ' attribute: ', ( self nounAsCamelCase: attribute4 ) quoted							, ' ) )  ifTrue: ['.					^code.					].	self onMatch: 'If 1 2 is less than 3 4 :'				do: [ :entity1 :attribute2 :entity3 :attribute4 |					code := '(  ( blackboard entity: ',(self nounAsCamelCase: entity1 ) quoted					            , ' attribute: ',  (self nounAsCamelCase: attribute2 ) quoted							, ' ) < ( blackboard entity: ', (self nounAsCamelCase: entity3 ) quoted							, ' attribute: ', ( self nounAsCamelCase: attribute4 ) quoted							, ' ) )  ifTrue: ['.					^code.					].	self onMatch: 'If 1 2 < 3 4 :'				do: [ :entity1 :attribute2 :entity3 :attribute4 |					code := '(  ( blackboard entity: ',(self nounAsCamelCase: entity1 ) quoted					            , ' attribute: ',  (self nounAsCamelCase: attribute2 ) quoted							, ' ) < ( blackboard entity: ', (self nounAsCamelCase: entity3 ) quoted							, ' attribute: ', ( self nounAsCamelCase: attribute4 ) quoted							, ' ) )  ifTrue: ['.					^code.					].	self onMatch: 'If 1 2 = 3 4 :'				do: [ :entity1 :attribute2 :entity3 :attribute4 |					code := '(  ( blackboard entity: ',(self nounAsCamelCase: entity1 ) quoted					            , ' attribute: ',  (self nounAsCamelCase: attribute2 ) quoted							, ' ) = ( blackboard entity: ', (self nounAsCamelCase: entity3 ) quoted							, ' attribute: ', ( self nounAsCamelCase: attribute4 ) quoted							, ' ) )  ifTrue: ['.					^code.					].	self onMatch: 'If 1 2 is equal to 3 4 :'				do: [ :entity1 :attribute2 :entity3 :attribute4 |					code := '(  ( blackboard entity: ',(self nounAsCamelCase: entity1 ) quoted					            , ' attribute: ',  (self nounAsCamelCase: attribute2 ) quoted							, ' ) = ( blackboard entity: ', (self nounAsCamelCase: entity3 ) quoted							, ' attribute: ', ( self nounAsCamelCase: attribute4 ) quoted							, ' ) )  ifTrue: ['.					^code.					].			self assert: ( code = '' ) not.	^code.! !!HumStatement methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 4/3/2012 11:01'!asSmalltalkIteration	|     code |	code := ''.	self onMatch:  'For each 1 in the 2:' do: [ :item :container |		code := '( self blackboard entity: ', (self nounAsCamelCase: container) quoted		           , ' attribute: ', (self nounAsCamelCase: item ) quoted		           , ' ) do: [ :', (self nounAsCamelCase: item), ' | ' ].	^code.! !!HumStatement methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 4/3/2012 11:18'!asSmalltalkWithOntology: aHumOntology 	| nouns code  colon space |	"TODO -- This will fail if there is a comment appended to the statement."	( self isConditional ) 		ifTrue: [ code := self asSmalltalkConditional. 			^code ].	code := ''.	colon := ':'.	space := ' '.	code := code, ( self asCamelCase ), 'Q'.	nouns := aHumOntology nounsInStatement: self.	nouns		do: [ :aNoun | 			| camelCase |			camelCase := self nounAsCamelCase: aNoun.			code := code, camelCase, colon, space, 'a', camelCase capitalized, space.			].			^code! !!HumStatement methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 4/3/2012 13:58'!asJavaConditional	| code |	code := ''.	(source beginsWith: 'For ' )		ifTrue: [ code := self asJavaIteration ].	( source beginsWith: 'If ')		ifTrue: [ code := self asJavaIf ].	( source beginsWith: 'Else:')		ifTrue: [ code := self asJavaElse ].			self assert: ( code = '' ) not.	^code.! !!HumStatement methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 3/16/2013 12:01'!asJavaDeclarationWithOntology: aHumOntology 	| nouns code comma space parend |	code := ''.	space := ' '.	comma := ', '.	parend := ' )'.	code := code,'public void ', (self asCamelCaseWithOntology: aHumOntology),'( '.	nouns := aHumOntology nounsInStatement: self.	nouns		do: [ :aNoun | 			| javaNoun |			javaNoun := self nounAsCamelCase: aNoun.			code := code, javaNoun capitalized , space, 'a', javaNoun capitalized, comma.			].	code := code, parend.	( code endsWith: (comma, parend ) ) 		ifTrue: [ code := (code copyFrom: 1 to: (code findString: (comma, parend))-1), parend ].	self assert: ( code endsWith: parend ).	self assert: (( code endsWith: (comma, parend) ) not).				self assert: ( '*, )*' matches: code ) not.	^code.! !!HumStatement methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 4/3/2012 17:40'!asJavaIteration	| code |	self onMatch:  'For each 1 in the 2:' do: [ :item :container |	code := 'for ( ', (self nounAsCamelCase: item) capitalized				, ' ', (self nounAsCamelCase: item) 		           , ' : ', (self nounAsCamelCase: container ),'.',(self nounAsCamelCase: item),'s' 		           , ' )  {' ].	^code.! !!HumStatement methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 3/16/2013 12:02'!asJavaMethodCallWithOntology: aHumOntology 	| nouns code comma space parend |	code := ''.	space := ' '.	comma := ','.	parend := ' )'.	code := code, (self asCamelCaseWithOntology: aHumOntology),'('.	nouns := aHumOntology nounsInStatement: self.	nouns		do: [ :aNoun | 				| javaNoun |				javaNoun := self nounAsCamelCase: aNoun.				code := code, space, 'a', javaNoun capitalized, comma.				].	code := code, parend.	( code endsWith: (comma, parend ) ) 		ifTrue: [ code := (code copyFrom: 1 to: (code findString: (comma, parend))-1), parend ].	self assert: ( code endsWith: parend ).	self assert: (( code endsWith: (comma, parend) ) not).				self assert: ( '*, )*' matches: code ) not.	^code.! !!HumStatement methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 4/3/2012 14:13'!asJavaWithOntology: aHumOntology 	| code  |	"TODO -- This will fail if there is a comment appended to the statement."	( self isConditional ) 		ifTrue: [ code := self asJavaConditional ]		ifFalse: [code := self asJavaMethodCallWithOntology: aHumOntology. ].			^code! !!HumStatement methodsFor: 'pretty print' stamp: 'RichardAlexanderGreen 2/13/2012 15:13'!asHTML5withOntology: aHumOntology 	"REPLACED"	"^ self source"	"WITH"	^self asHTML5withOntology: aHumOntology keywords: 'if then else for for-each'.	! !!HumStatement methodsFor: 'pretty print' stamp: 'RichardAlexanderGreen 10/17/2012 11:24'!asHTML5withOntology: aHumOntology keywords: keywords	| tokenTypes html token type fragment |	html := ''.	tokenTypes := aHumOntology parseStatement: self keywords: keywords.	tokenTypes		do: [ :tokenType |   "For each token-type:"			token := tokenType key.			type := tokenType value.			fragment := ''.			"Assign a tag that the CSS can then style."			( type = #word ) ifTrue: [ fragment := ' ', token ].			( type = #noun ) ifTrue: [ fragment := ' <n>', token, '</n>' ].			( type = #keyword ) ifTrue: [ fragment := ' <k>', token, '</k>' ].			( type = #role ) ifTrue: [ fragment := ' <r>', token, '</r>' ].			"Just another token with no particular type."			( fragment = '' ) ifTrue: [ fragment := token ].			html := html, fragment.			].	^html! !!HumStatement methodsFor: 'logging' stamp: 'RichardAlexanderGreen 1/16/2012 14:45'!syntaxError: anErrorMessage 	"Error signal: anErrorMessage."	(self errors) add: anErrorMessage.! !!HumStatement methodsFor: 'translate' stamp: 'RichardAlexanderGreen 3/13/2013 18:11'!asCamelCase 	"Convert this statement to camelCase."	| tokens code   first |	code := ''.	first := true.	tokens := (self source) findTokens: ' ,.-'.	tokens		do: [ :token |				"TODO: Consider an option to drop articles ('a' or 'the')"								first ifTrue: [ code := code, token asLowercase .						            first := false.]					ifFalse: [ code := code, (token capitalized) ].			].		^code! !!HumStatement methodsFor: 'translate' stamp: 'RichardAlexanderGreen 3/14/2013 12:20'!asCamelCaseWithOntology: aHumOntology 	"Convert this statement to camelCase."	| tokens code   first |		code := ''.	first := true.	tokens := (self source) findTokens: ' ,.-'.	tokens		do: [ :token |				"TODO: Consider an option to drop articles ('a' or 'the')"								first ifTrue: [ code := code, token asLowercase .						first := false.]					ifFalse: [ code := code, (token capitalized) ].			].	"TODO: Deal with polymorphism by looking up the proper definition.	Can borrow algorithm from prior version of SimpleEnglish ?	However, by removing nouns from the camelCase, I could just let Java do the work.	"	^code! !!HumStatement methodsFor: 'translate' stamp: 'RichardAlexanderGreen 4/9/2012 12:46'!nounAsCamelCase: aString 	"Delegate to ontology class"	^ HumOntology nounAsCamelCase: aString.! !!HumStatement methodsFor: 'translate' stamp: 'RichardAlexanderGreen 3/23/2012 15:30'!onMatch: aPatternString do: aBlockClosure 	"When my source matches pattern, execute the block with matching arguments."	| match whitespace punctuation quote myTokens patternTokens xMe xPattern arguments myToken patternToken list |	"Parse me and the pattern."	whitespace := ' 			'.	quote := $' asString.	punctuation := '~!!@#$%^&*()_+`={}|[]\:";<>?,./', quote.		myTokens := self source asLowercase  findTokens: ( punctuation, whitespace ) keep: punctuation.	patternTokens := aPatternString asLowercase  findTokens: ( punctuation, whitespace ) keep: punctuation.	"Quick test: Exit if the first token does not match."	myToken := myTokens at: 1.	patternToken := patternTokens at: 1.	(            ( myToken sameAs: patternToken ) 	or: [ '123456789*' includesSubString: patternToken ] )		ifFalse: [^self ].	"Looks like the first word matches, go on."	xMe := 1.	xPattern := 0.	arguments := OrderedCollection new.	match := false.	patternTokens 		do: [ :token | "For each pattern token:"			patternToken := token.			match := false.			xPattern := xPattern + 1.			( '123456789' includesSubString: patternToken )				ifTrue: [ "Current token is an argument"					arguments add: (myTokens at: xMe). 					match := true.					].			( patternToken = '*' )				ifTrue: ["This only works when the next pattern token is also downstream in myTokens"					((myTokens copyFrom: xMe+1 to: myTokens size ) includes: ( patternTokens at: xPattern + 1))						ifFalse: [ ^self ]						ifTrue: ["Next argument is a list"							| stopper |							stopper := ( patternTokens at: xPattern + 1).							list := OrderedCollection new.							[ (myTokens at: xMe) sameAs: stopper ] 								whileFalse: [ 									( #( ',' 'and' ) includes: (myTokens at: xMe)  )									 	ifFalse: [list add: (myTokens at: xMe).].					 									xMe := xMe + 1. 									].							arguments add: list.							"At this point we have to jump to the conclusion and exit the outer-do."							"*** TODO *** This logic will only work for lists that are at the end of the statement, but not in the middle."							aBlockClosure valueWithArguments: arguments.							^self.							].						].			( patternToken sameAs: ( myTokens at: xMe ) )						ifTrue: ["myToken matches a keyword. Proceed to next token."						match := true.].					match ifTrue: [ xMe := xMe + 1 ] 
					ifFalse: ["Got to here with no match. But allow for dropped 'a', 'an', 'the', 'this', 'that'. "											    ( #('a' 'an' 'the' 'this' 'that' ) includes: patternToken )						                        ifFalse: [^self]					              ].					].	"If we've gotten this far, the pattern matched and we have zero or more arguments."		( arguments size = 0 )		ifTrue: [ aBlockClosure value ]		ifFalse: [ aBlockClosure valueWithArguments: arguments ].	^self.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumStatement class	instanceVariableNames: ''!!HumStatement class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 12/30/2011 14:12'!from: aSource	| newStatement |	newStatement := self basicNew.	newStatement source: aSource.	^newStatement.! !!HumStatement class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 1/16/2012 14:37'!source: aSource	| |	^ self from: aSource.! !!HumStatement class methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 1/2/2012 17:22'!isKeyWord: aString	| keyWordList answer |	keyWordList := #( 'if' 'else' 'for' 'each' 'in' 'giving' ).	answer := ( keyWordList includes: aString ).	^answer.! !HumFrameLine subclass: #HumTitleLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumTitleLine commentStamp: 'RichardAlexanderGreen 9/28/2012 12:52' prior: 0!Every frame has a title line. It is simply the first line of the frame.The title must uniquely identify the frame within the ontology.The title should be descriptive of the content.The title of a role-action frame consists of the role-name and the action statement.The title of a dialog-context frame consists of the dialog-title and the context-title.The title of a view or a dictionary frame is a single string.The title of a plan frame is the post-condition statement. (That means there can only be one way to reach the post-condition!!)!HumFrame subclass: #HumFrame4Dictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumFrame4Dictionary commentStamp: 'RichardAlexanderGreen 9/19/2012 10:55' prior: 0!A dictionary frame defines noun relationships.!!HumFrame4Dictionary methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!addDictionaryLine: aSourceString 	self frameLines add: ( HumDictionaryLine new statement: aSourceString ).! !!HumFrame4Dictionary methodsFor: 'testing' stamp: 'RichardAlexanderGreen 10/6/2012 10:27'!saveFrameToOntology: aHumOntology 	"Each dictionary line will have some additive effect on the ontology."	| syntaxErrors lineErrors |	"We may discover syntax errors while compiling."	syntaxErrors := OrderedCollection new.	(self frameLines select: [ :frameLine | frameLine isKindOf: HumDictionaryLine ] )		do: [ :dictionaryLine |			lineErrors := dictionaryLine compileLineToOntology: aHumOntology.			syntaxErrors := syntaxErrors, lineErrors.
			].	^syntaxErrors.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFrame4Dictionary class	instanceVariableNames: ''!!HumFrame4Dictionary class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 7/8/2013 09:45'!ontology: anOntology title: aString	"Create an instance with this ontology and title"	| instance |	instance := self new.	instance		ontology: anOntology;		titleLine: ('Dictionary: ', aString).	^instance! !HumFrameLine subclass: #HumPreconditionLine	instanceVariableNames: 'statement comment annotation isSatisfied'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Language'!!HumPreconditionLine commentStamp: 'RichardAlexanderGreen 9/28/2012 12:43' prior: 0!A precondition line occurs in a plan frame's preconditions section.As a matter of style, it should be stated as an assertion or declaration. (Present tense descript of the required state of the system.)A precondition line may contain a statement with an optional comment and/or annotation.Here is an example:___Post:  . . .Pre:. All necessary ingredients are on-hand. 	(In the local kitchen) 	[assumed]The comment is within round parentheses.The annotion is withing square brackets.Instance Variables:	statement	<HumStatement>	comment	<ProtoObject>	annotation	<ProtoObject>!!HumPreconditionLine methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/10/2012 12:19'!checkSyntaxWithOntology: aHumOntology 	|  nouns errors correspondingPlanFrame |	errors := OrderedCollection new.	statement := HumStatement from: (self statement).	nouns := aHumOntology nounsInStatement: statement.	( nouns isEmpty ) 		ifTrue: [ errors add:( 'Precondition {" ', statement source, ' "} has no known nouns!!' ) ].	"Is the precondition assumed?"	( ( self annotation ) sameAs: 'assumed' )		ifTrue: [ ^errors ].	"Otherwise: See if we have a plan for satisfying this precondition."	correspondingPlanFrame := aHumOntology getPlanFrameForGoal: statement.	"#getPlanFrameForGoal: will return an empty plan frame  if there is none in the ontology. 	Also, the ontology might contain an empty frame. 	In either case, an empty frame is not a usable subplan.	"	( correspondingPlanFrame isNoPlan ) 		ifTrue: [ errors add:  'Precondition {" ', statement source, ' "} has no plan.'].	^errors.! !!HumPreconditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/11/2012 13:51'!annotation	^ annotation ifNil: [ '' ].! !!HumPreconditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/11/2012 13:51'!comment	^ comment ifNil: [ '' ].! !!HumPreconditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/8/2013 11:23'!isSatisfied	"Is this precondition satisfied?"	^ isSatisfied ifNil: [ isSatisfied := false ].! !!HumPreconditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/8/2013 11:24'!isSatisfied: aBoolean	"Is this precondition satisfied?"	self assert: ( aBoolean isKindOf: Boolean ).	isSatisfied := aBoolean.! !!HumPreconditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2012 11:13'!source
	| s |	s := self statement asString.	(self comment isEmpty) ifFalse: [ s := s, ( self comment ) ].	(self annotation isEmpty) ifFalse: [ s := s, ( self annotation ) ].	^ s. ! !!HumPreconditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/11/2012 13:50'!statement		^ statement ifNil: [ '' ].! !!HumPreconditionLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/16/2012 14:20'!statement: aSource 	"Set my statement."	statement := nil.	( aSource isKindOf:  String ) ifTrue: [ statement := HumStatement from: aSource ].	( aSource isKindOf: HumStatement ) ifTrue: [ statement := aSource ].	self assert: ( statement isKindOf: HumStatement ).	! !