	<head>		<style>			body {font-family: MONOSPACE;}				method {   }		comment { color: DarkGreen; }		todo { color: Red; }		r { color: Red; }		return { color: Blue; }		</style>	</head><body><h1>Hum Code Base</h1><h3>Hum-FileIn -- HumFileInSubclass</h3><pre>subclassMethod: anArgument3</pre><h3>Hum-FileIn -- HumFileIn</h3><pre>anotherMethod: anArgument2   "This is a second method to check for iteration anomolies."</pre><pre>someMethod: anArgument   "This method provides means to test file in from generated code."</pre><h3>Hum-FileIn -- HumFileOut</h3><pre>myInstanceVariable   ^ myInstanceVariable.</pre><h3>Hum-Graph -- HumGraphTests</h3><pre>test110GraphHasNodes   "A graph has a collection (set) of nodes"</pre><pre>test120GraphHasConnections   "A graph has a collection (set) of connections."</pre><pre>test130PutGetNode   "A graph has a collection (set) of nodes"</pre><pre>test140PutGetConnector   "A graph has a collection (set) of connections."</pre><pre>test150PutGetLabeledConnections   "A graph has a collection (set) of connections"</pre><pre>test152PutGetParallelConnections   "A graph has a collection (set) of nodes"</pre><pre>test160DetectCycle   "A graph has a collection (set) of nodes"</pre><h3>Hum-Graph -- HumGraph</h3><pre>addConnection: anAssociation </pre><pre>addConnection: anAssociation label: aString   "Note: A pair of nodes may have more than one relation."</pre><pre>addNode: anObject    "Add the given object to the set of nodes"</pre><pre>addNode: anObject label: aString   "Add the given object to the Set of node-labels"</pre><pre>connectionLabels   "Note: A pair of nodes may have more than one relation."</pre><pre>connections   "Return the connections (associations) in this graph."</pre><pre>connectionsFrom: aNode    "Get the outbound connections from this node. "</pre><pre>countNeighborsOfNode: aNode   "Return the number of neighbors of this node.</pre><pre>hasCycle   "Does the graph contain at least one cycle?"</pre><pre>nodeLabels   ^nodeLabels ifNil: [ nodeLabels := Set new ].</pre><pre>nodes   "Return the nodes in this graph."</pre><pre>nodesDownStreamFrom: aRootNode    "Collect the nodes that are down-stream from a root node."</pre><pre>nodesDownStreamFrom: aRootNode butNotIn: upStreamNodes    "Find nodes that are down-stream from the root node but not in the upStreamNodes."</pre><h3>Hum-IDE -- HumCodeBase</h3><pre>everythingIsClassSide   "This is organized as a singleton - all the methods are on the class side."</pre><h3>Hum-IDE -- HumCodeStream</h3><pre>&lt;&lt; aString </pre><pre>asString   ^self printString.</pre><pre>contents   ^(self stream) contents.</pre><pre>limit   "At what point do we assume code generation has run amock?"</pre><pre>limit: aSmallInteger </pre><pre>printString   ^(self stream) contents.</pre><pre>stream</pre><h3>Hum-IDE -- HumFrameUpdater</h3><pre>addActionLine: aSourceString </pre><pre>addDictionaryLine: aSourceString </pre><pre>addMarkUp: aSourceString </pre><pre>addPlanLine: aSourceString    "The kind of line is modal."</pre><pre>addVignetteInstruction: anInstructionLine </pre><pre>addVignetteLine: aSourceString </pre><pre>addVignetteResponse: aResponseString </pre><pre>appendFrameLine: aSourceString    "Create appropriate frameLine type and append to frame."</pre><pre>appendInstructionRole: aRole statement: aStatement </pre><pre>appendInstructionRole: aRole statement: aStatement comment: aComment </pre><pre>appendInstructionStatement: aStatement    "Append a simple instruction (no delegation, no comment) to the frame."</pre><pre>appendPrecondition: aPreconditionStatement </pre><pre>appendRole: aRole action: aStatement    "Pass through to frame."</pre><pre>checkFrameSyntax</pre><pre>compileToOntology: aHumOntology    "Delegate to the frame."</pre><pre>frame   "If frame is not initialized before this call, we have a logic error."</pre><pre>frame: aFrame    "What frame am I editing ?"</pre><pre>getInstructionAt: aSmallInteger    ^self lines at: aSmallInteger .</pre><pre>isEmpty   ^ (frame isNil) or: [frame isEmpty].</pre><pre>lines   ^ (self frame) lines.</pre><pre>nextVignetteContext: aString </pre><pre>ontology   ^ (ontology) ifNil: [ Error signal: 'Frame Updater instance must have an ontology.']</pre><pre>ontology: aHumOntology </pre><pre>parseInstruction: sourceWith </pre><pre>prettyPrint   "Pretty print the frame content (rendering as HTML)."</pre><pre>programmersAssistant   ^ programmersAssistant ifNil: [programmersAssistant := HumProgrammersAssistant new].</pre><pre>putInstruction: aHumInstruction at: aSmallInteger </pre><pre>storeFrameInOntology   "Store my frame in my ontology"</pre><pre>stripLeaderFrom: aLine </pre><pre>vignetteContext</pre><pre>vignetteMode   "What mode is the vignette parser in?"</pre><pre>vignetteMode: newMode   "What mode is the vignette parser in?"</pre><h3>Hum-IDE -- HumProgrammersAssistant</h3><pre>clearOntology</pre><pre>getAnnotationFromSource: aSourceString    "Match '[...]' if any, and extract it from source."</pre><pre>getCommentFromSource: aSourceString    "Match '(...)' if any, and extract it from source."</pre><pre>getLabelFromSource: aSourceString   "Match 'word:' at the front of the string.</pre><pre>loadOntology: anOntology fromTextFileNamed: fileName   "Load an ontology from the given text file."</pre><pre>loadOntologyFromSaveFileNamed: aFileNameString    "Reload an ontology from the given save file."</pre><pre>loadOntologyFromTextFileNamed: fileName   "Load an ontology from the given text file."</pre><pre>loadOntologyFromTextStream: aStream    "Discover frame type and store each frame in ontology."</pre><pre>makeFramePerTitleLine: source    "The label on the title line indicates the kind of frame."</pre><pre>ontology   "Return the ontolgy. If nil initialize one."</pre><pre>ontology: aHumOntology</pre><pre>parseActionLine: source    "An action line begins with 'Action:' or 'To:' label.</pre><pre>parseActionLine: aString keywords: aCollection    "An action line begins with 'Action:' or 'To:' keyword.</pre><pre>parseInstructionSource: source keywords: keywords   "Parse the source -- Return a list of token-type pairs: ( token -&gt; tokenType ).</pre><pre>parseMarkupSource: aSourceString </pre><pre>parseSource: source keywords: keywords   "Parse the source -- Return a list of token-type pairs: ( token -&gt; tokenType ).</pre><pre>removeAnnotationFromSource: aSourceString </pre><pre>removeCommentFromSource: aSourceString </pre><pre>removeLabelFromSource: aSourceString    "If there is a label, remove it and return the remainder."</pre><pre>saveOntologyOnFileNamed: aFileName    "Save my ontology on the given ReferenceStream file."</pre><pre>writeFrame: aFrame onStream: aStream   "Write frame-lines to given stream in canonical format.    *** NO SENDERS ***</pre><pre>writeOntologyContextVignettesOnStream: aStream</pre><pre>writeOntologyFrame: aFrame onStream: aStream   "Write to given stream - customize per frame-type as needed."</pre><pre>writeOntologyFrameWithIndents: aSubFrame onStream: aStream   "Vignette and View frames use dot-leader only for instruction lines."</pre><pre>writeOntologyFramesOfType: aFrameClass onStream: aStream   "Select frames of given class and write them on the stream."</pre><pre>writeOntologyOnTextFileNamed: aFileName    "Save my ontology in text format on the file with the given name. "</pre><pre>writeOntologyRoleActionsOnStream: aStream   "Write role-action frames ordered by role and action."</pre><pre>writeOntologyVFrame: aFrame onStream: aStream   "Write UI frames: Vignette and View frames only use dot-leader for instruction lines."</pre><h3>Hum-IDE -- HumTextEditor</h3><pre>beep   "Signal that cursor is out-of-bounds."</pre><pre>bumpColumn: anInteger </pre><pre>bumpRow: anInteger </pre><pre>column   "What is the current column position of the cursor?"</pre><pre>column: anInteger    "Move cursor to given column position."</pre><pre>currentLine   ^self lineAt: (self row).</pre><pre>currentLine: aString </pre><pre>cursorPosition   "Where is the insert point?"</pre><pre>deleteOrMerge   "Delete character to left of cursor.</pre><pre>drawTextOnCanvas: aHumCanvas font: aFont </pre><pre>drawTextOnPane: aHumPane font: aFont </pre><pre>hasNewContent   "Has the content been changed? -- (Dirty data flag)"</pre><pre>hasNewContent: aBoolean    "Set true whenever the content has been changed."</pre><pre>insertCharacter: aCharacter </pre><pre>keyStroke: aCharacter   "Respond to simple keyboard input. (KISS: a character)</pre><pre>lineAt: anInteger    "Get string for given row"</pre><pre>lines   "PRIVATE: My text lines. </pre><pre>row   "What is the current row position of the cursor?"</pre><pre>row: anInteger    "Move cursor to given row position."</pre><pre>splitRow</pre><h3>Hum-Language -- HumCommentLine</h3><pre>source: aString   "override supertype parsing"</pre><h3>Hum-Language -- HumConditionLine</h3><pre>&lt;= aHumConditionLine    "Provide a way to order preconditions</pre><pre>annotation   ^ annotation ifNil: [ '' ].</pre><pre>annotation: aString    "Annotation may indicate that condition is 'assumed'.  Other cases are not yet defined."</pre><pre>checkSyntaxWithOntology: aHumOntology </pre><pre>comment   ^ comment ifNil: [ '' ].</pre><pre>compileLineToOntology: aHumOntology    "compile a precondition line into the ontology.</pre><pre>source
   | s |</pre><pre>source: aString   "DEBUG: Should not be 'Precondition' or: 'Pre'"</pre><pre>statement</pre><pre>statement: aSource    "Set my statement."</pre><h3>Hum-Language -- HumDictionaryLine</h3><pre>comment   ^ comment ifNil: [ comment := String new. ].</pre><pre>compileLineToOntology: aHumOntology    "Add nouns and noun-relations to the ontology.</pre><pre>getListAfter: aString </pre><pre>source   "Construct a source line based on convention and content of my attributes."</pre><pre>statement   ^ statement ifNil: [ statement := HumStatement source: (self source). ]</pre><pre>statement: aStatementString </pre><h3>Hum-Language -- HumFrame4Action</h3><pre>actionStatement   ^ actionStatement ifNil:[ Error signal: 'Action frame must have an action statement']. </pre><pre>actionStatement: anObject</pre><pre>appendInstructionRole: aRole statement: aStatement </pre><pre>appendInstructionRole: aRole statement: aStatement comment: aComment   </pre><pre>appendInstructionStatement: aSource </pre><pre>checkSyntaxWithOntology: anOntology    "Critique the instructions for this role action."</pre><pre>compileToOntology: aHumOntology    "Compile the frame into the ontology."</pre><pre>instructionLines   ^ instructions ifNil: [ instructions := OrderedCollection new ].</pre><pre>instructions   ^ instructions ifNil: [ instructions := OrderedCollection new. ].</pre><pre>instructions: anObject</pre><pre>role   ^ role.</pre><pre>role: anObject</pre><pre>titleLine   "Format a cannonical title line."</pre><h3>Hum-Language -- HumFrame4Comment</h3><pre>appendFrameLine: aLine</pre><h3>Hum-Language -- HumFrame4Data</h3><pre>appendEntity: aEntityName attrribute: anAttributeName value: aValueString </pre><pre>asString</pre><h3>Hum-Language -- HumFrame4Dictionary</h3><pre>addDictionaryLine: aSourceString </pre><pre>compileToOntology: aHumOntology    "Each dictionary line will have some additive effect on the ontology."</pre><h3>Hum-Language -- HumFrame4Plan</h3><pre>actionStatements   ^self planActions.</pre><pre>appendInstructionRole: aRole statement: aStatement </pre><pre>appendPrecondition: aSource </pre><pre>appendPrecondition: aStatement annotation: anAnnotation</pre><pre>appendRole: aRole action: aSource    "Add 'role: action-statement' to plan-frame"</pre><pre>appendRole: aRole action: aSource comment: aComment   "Add 'role: action-statement. (comment)' to plan-frame"</pre><pre>check   "Check the basic integrity of the plan frame."</pre><pre>checkSyntaxWithOntology: anOntology</pre><pre>compileToOntology: aHumOntology    "Check the basic integrity of the plan frame.</pre><pre>goal   "Get the plan frame's goal statement."</pre><pre>goal: aSource    "This instance variable contains the plan frame's goal statement."</pre><pre>isNoPlan   "Frame is no plan if there are no preconditions and no actions.</pre><pre>planActions  "A sequence of actions to be performed after preconditions are satisfied.</pre><pre>preconditions   "Preconditions are ordered to preserve the author`s sequence,</pre><h3>Hum-Language -- HumFrame4View</h3><pre>addMarkUp: aSource </pre><pre>compileToOntology: aHumOntology   ""</pre><pre>entity   ^ entity ifNil: [ entity := HumCalculator given: (self titleLine) extractAfter: ': '].</pre><pre>entity: anObject</pre><pre>viewEntity: anEntityType.    "What entity-type is this view displaying."</pre><pre>viewName: aString   "Caller passes the name of the view - to be used in calls."</pre><h3>Hum-Language -- HumFrame4Vignette</h3><pre>addPattern: aPatternString    "Enter a pattern -- What pattern will the vignette respond to?"</pre><pre>addVignetteInstruction: anInstructionLine    "Append an instruction to be executed in response to the user / client."</pre><pre>addVignettePattern: patternString    "Append an Pattern to be matched in response to the user / client."</pre><pre>addVignetteResponse: aResponseString    "Append a verbal response line."</pre><pre>checkSyntaxWithOntology: anOntology   "Check the vignette for syntax problems."</pre><pre>compileToOntology: anOntology   "Update the ontology with this vignette."</pre><pre>inputToken: inputToken isEquivalentTo: patternToken   "Is the input equivalent to the pattern?</pre><pre>inputTokensIn: aString   "Return the pattern tokens in the given string."</pre><pre>instructionLines   "Return the vignette's instruction lines. "</pre><pre>nextVignetteContext   "By default, the next context is the current context."</pre><pre>nextVignetteContext: aContextName    "What will be the context after the response is rendered?</pre><pre>patternFields: pattern   "Parse the pattern and return the [noun] fields - including the brackets.</pre><pre>patternMatchScore: aString   "How well does the string (from client) match the pattern int this vignette?</pre><pre>patternNouns   "TODO: DOES THIS BELONG IN HumVignettePatternLine ?"</pre><pre>patternNouns: pattern   "Parse the pattern and return the nouns referenced in [noun] fields. </pre><pre>patternTokensIn: aString    "Return the pattern tokens in the given string.</pre><pre>patterns   ^ patterns ifNil: [ patterns := OrderedCollection new ].</pre><pre>responseLines   "What will be the verbal response? "</pre><pre>titleLine</pre><pre>vignetteContext   "The context is used to prioritize responses when two or more patterns match a user input.</pre><pre>vignetteContext: aContextString    "The context is used to prioritize responses when two or more patterns match a user input.</pre><pre>zpatternMatchScore: aString   "How well does the string (from client) match the pattern int this vignette?</pre><h3>Hum-Language -- HumFrameLine</h3><pre>checkForAntecedantsIn: aHumStatement withOntology: aHumOntology </pre><pre>checkSyntaxWithOntology: aHumOntology </pre><pre>comment   "Any frame line can have a comment."</pre><pre>comment: aString   "Any frame line can have a comment."</pre><pre>compileLineToOntology: aHumOntology    "Compile this instruction line."</pre><pre>doTokensIn: input at: x matchPatternTokensIn: patternTokens at: xPattern   "See if we can get any matching sequence."</pre><pre>extractPatternParameters: aPatternString    "Extract parameters (tokens) from source that match the pattern."</pre><pre>generateCodeFrom: aTemplateString using: parameterValues    "Generate code (string) from the template replacing parameters with values in the parameter list."</pre><pre>getParametersIn: input at: x thatMatchParametersIn: patternTokens at: xPattern accumulating: parameters   "See if we can get any matching sequence."</pre><pre>getTokensIn: aString   "This is a helper for #matchesPattern: (). It implements a Hum-friendly tokenizer."</pre><pre>matchesPattern: aPatternString    "Does some part of the frame-line match the given pattern?"</pre><pre>onMatch: aPatternString generate: aTemplateString    "When some part of the content in the current line matches the pattern,</pre><pre>printOn: aStream   "Append to the argument, aStream, a sequence of characters that  </pre><pre>sameAs: anotherFrameLine</pre><pre>source   ^ source</pre><pre>source: aString </pre><h3>Hum-Language -- HumFrame</h3><pre>appendFrameLine: aFrameLine   "Append a line to the frame."</pre><pre>checkSyntaxWithOntology: anOntology</pre><pre>compileToOntology: aHumOntology </pre><pre>debug   "Am I in debug mode?"</pre><pre>debug: aBoolean </pre><pre>delegateToTranslator</pre><pre>delegated</pre><pre>frameLines   ^frameLines ifNil: [ frameLines := OrderedCollection new.]</pre><pre>frameName   "The name of the frame is guaranteed to be a string.</pre><pre>initialize   "The instance should always be a subtype."</pre><pre>isEmpty</pre><pre>linesAsHTMLwithOntology: anOntology</pre><pre>ontology   ^ ontology</pre><pre>ontology: anOntology</pre><pre>origin   "Where did this frame come from?"</pre><pre>origin: aString   "Where did this frame come from?"</pre><pre>prettyPrintWithOntology: aHumOntology   "Pretty-print using HTML5 and CSS</pre><pre>printOn: aStream   "Append to the argument, aStream, a sequence of characters that  </pre><pre>title   ^ self titleLine </pre><pre>titleLine   ^titleLine</pre><pre>titleLine: anObject</pre><pre>uniqueIdentifier   "Note: Lazy initialization for this frame`s identifier."</pre><pre>zcompileToOntology: aHumOntology </pre><h3>Hum-Language -- HumInstructionLine</h3><pre>= anInstruction   "??? Looks like bad code ???  "</pre><pre>annotation   ^ annotation ifNil: [^'' ].</pre><pre>annotation: aString    "Annotation may indicate timing for simulations. </pre><pre>checkSyntaxWithOntology: aHumOntology </pre><pre>checkSyntaxWithOntology: aHumOntology defaultRole: aRole</pre><pre>comment   ^ comment ifNil: [''].</pre><pre>comment: aString    "Comment is not executable. May be displayed in certain contexts."</pre><pre>compileLineToOntology: aHumOntology    "Compile this instruction line."</pre><pre>compileLineToOntology: aHumOntology defaultRole: aRole   "Compile this instruction line."</pre><pre>indent   "How many indents (tabs) before the start of the code-text ?"</pre><pre>indent: aSmallInteger   "How many indents (tabs) before the start of the code-text ?"</pre><pre>jobTicket   "There should be a job ticket if the (run-time) caller expects one."</pre><pre>jobTicket: aJobTicket   "At run-time, a job ticket may be associated with action request."</pre><pre>onComment: aBlockClosure    "If instruction includes a comment, execute the block."</pre><pre>onRole: aBlockClosure    "If instruction includes a role prefix, execute the block."</pre><pre>role   "What role am I delegating to? If none, the instruction is to myself."</pre><pre>role: aString    "Delegate the task (statement) to this role at run-time. "</pre><pre>source   "Construct a source line based on convention and content of my attributes."</pre><pre>source: aString   "Should not be: 'Action:' block-label."</pre><pre>statement   "What will be done . . . will be done at run-time."</pre><pre>statement: aSource    "What to do  at run-time?"</pre><pre>title   ^ self titleLine.</pre><pre>titleLine   ^ ( self role), ': ', ( self statement asString ).</pre><pre>translation: aString </pre><h3>Hum-Language -- HumMarkupLine</h3><pre>checkSyntaxWithOntology: aHumOntology    "Syntax errors in mark-up mainly have to do with widgets that won't work.</pre><pre>compileLineToOntology: aHumOntology </pre><pre>generateCodeOfType: aSymbol fromTokens: tokens at: xToken   "Generate code of the given type HTML/Seaside/JavaScript based on token stream."</pre><pre>generateHtmlTableFor: aNoun withOntology: anOntology</pre><pre>getWidgetArgument: aWidgetString   "Parse the widget string to get verb`s argument, if any."</pre><pre>getWidgetNoun: aWidgetString   "Parse the widget-string to get the widget`s noun (blackboard entity-attribute-name), if any."</pre><pre>getWidgetVerb: aWidgetString   "Parse the widget-string to get the widget`s verb, if any."</pre><pre>widgets   "Scan the source matching pairs of [. . .] or [[. . .]]."</pre><h3>Hum-Language -- HumOntologyTranslator</h3><pre>asJava   "This is crude version.</pre><pre>attachAction: aMethodName toActorClass: aClassName fromSource: aSource   "Attach the given method source </pre><pre>attachPrologToActorClass: aClassName fromSource: aSourceString    "Attach the given prologue source code to the named class."</pre><pre>contextEntity: aString </pre><pre>countLeading: aCharacter inString: line   "Count leading"</pre><pre>genHTML: generatedCodeString   "Append generated code to 'html' instance variable. (YIKES!)"</pre><pre>generateErlangDocumentation</pre><pre>generateErlangForActionCall: aString   "Translate a Hum Action call into an Erlang OTP call."</pre><pre>generateErlangForActionHeader: aString    "Then: The do header looks like 'do( { action-statement, noun-values } )' "</pre><pre>generateErlangForEntity: anEntity   "Translate entity into an Erlang record data structure. &lt;&lt;&lt; OBSOLETE</pre><pre>generateErlangForInstruction: aHumInstructionLine    "Generate self-call or RPC for given instruction."</pre><pre>generateErlangForPlanFrame: aHumFrame4Plan    "Translate the plan frame into an Erlang data structure.</pre><pre>generateErlangForRole: aRoleName   "Generate Erlang code for the given role-name."</pre><pre>generateErlangForRoles   "Generate a Erlang module file for each Hum role."</pre><pre>generateErlangForSelfCall: aString   "Translate a Hum Self call into an Erlang self call."</pre><pre>generateErlangNounValuesForStatement: aStatementString</pre><pre>generateHTMLforMarkupLines: aListOfFrameLines blackboard: aBlackboard   "Build HTML for the given list of frame-lines"</pre><pre>generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard   "Build output until we see a substring matching aStopString."</pre><pre>generateHTMLforViewFrame: aHumFrame4View blackboard: aHumBlackBoard    "Wrap viewframe lines with  HTML form and submit logic."</pre><pre>generateJavaCallForFrameLine: aHumInstructionLine </pre><pre>generateJavaCallForStatement: aHumStatement </pre><pre>generateJavaConditionalForStatement: aHumStatement </pre><pre>generateJavaForFrame: aHumFrame4Action    "Translate frame to Java using the nouns given in the ontology."</pre><pre>generateJavaForFrameLine: aHumInstructionLine </pre><pre>generateJavaForPlanFrame: aHumFrame4Plan    "The plan is data, so translation involves translating each goal frame into a series of Java setters.</pre><pre>generateJavaForStatement: aHumStatement </pre><pre>generateJavaIterationForStatement: aHumStatement    "Given a Hum for-statement, generate a Java for-statement."</pre><pre>generateJavaMethodDeclarationForStatement: aHumStatement </pre><pre>generateJavaScriptAngularReadMe   "Angular is a JavaScript user interface framework."</pre><pre>generateSeasideForView: aHumFrame4View    "Implement the view frame via Seaside components.</pre><pre>generateSeasideForViewMarkup: aHumMarkupLine    "Generate Seaside code to implement a view mark-up line."</pre><pre>generateSeasideHeadingFor: source   "Generate Seaside heading code for the given heading line."</pre><pre>generateSeasideWidgetForField: fieldName</pre><pre>generateSeasideWidgetsForSource: aSourceString   "Generate Seaside calls for the widgets found in this mark-up line."</pre><pre>generateSmalltalk   "This is crude version.</pre><pre>generateSmalltalkActionFor: aHumFrame4Action    "Translate frame to Smalltalk using the nouns given in the ontology."</pre><pre>generateSmalltalkForConditional: aHumStatement </pre><pre>generateSmalltalkForFrame: aHumFrame   "Translate frame to Smalltalk using the nouns given in the ontology."</pre><pre>generateSmalltalkForFrameLine: anInstructionLine </pre><pre>generateSmalltalkForStatement: aHumStatement </pre><pre>generateSmalltalkIfFor: aHumStatement    "Translate a Hum if-statement into a Smalltalk (  ) ifTrue: [] expression."</pre><pre>generateSmalltalkIterationFor: aHumStatement </pre><pre>generateSmalltalkOnFile: aFileName   "Open file and produce File-Out / File-In format."</pre><pre>generateXamarinReadMe   "Xamarin runs on Windows, iOS, and Android devices.  (client side)</pre><pre>getMethodsForClass: aClassName   "Get the methods colletion (a Dictionary) for the given Class"</pre><pre>html   ^html ifNil: [html := ReadWriteStream on: ''.].</pre><pre>humParserError: aComplaint inCodeFragment: aCodeFragment</pre><pre>methodsForClasses   ^ methodsForClasses ifNil: [ methodsForClasses := Dictionary new ].</pre><pre>moveCodeGenerator</pre><pre>nounAsCamelCase: aNoun    "Generate camel-case string the the given noun."</pre><pre>nounsAsJava   "Emit java code that implements noun relations."</pre><pre>ontology   ^ ontology ifNil: [ontology := HumOntology new.]</pre><pre>ontology: aHumOntology </pre><pre>prologues   ^ prologues ifNil: [ prologues := Dictionary new ].</pre><pre>rolesAsJava</pre><pre>when: aSource matchesPattern: aPattern produce: aBlock</pre><h3>Hum-Language -- HumOntologyViewer</h3><pre>asHTML5   "Render the ontology as an HTML5 page.</pre><pre>asHTML5withCritique   "Render the ontology as an HTML5 page.</pre><pre>asHTML5withCritique: withCritique withBase: withBase   "Render the ontology as an HTML5 page.</pre><pre>asHTML5withCritiqueSkippingBaseOntology   "Render the ontology as an HTML5 page.</pre><pre>buildDiagramForNoun: aNoun onDiagram: aDiagram   "Add the noun`s relationships to that diagram."</pre><pre>buildNounTreeForNoun: aNoun indent: anIndentLevel    ""</pre><pre>css   "generate HTML Cascading Style Sheet (CSS) code segment"</pre><pre>generateCategoryPullDownFor: aNoun    "Render category noun as a pull-down selection."</pre><pre>generateHtmlTableFor: anEntity   "Generate a dummy table showing the attributes for this entity-name." </pre><pre>initialize</pre><pre>modeStack   "Stack to track list-type modes."</pre><pre>ontology: aHumOntology </pre><pre>render: asSymbol onFileNamed: aNewFile</pre><pre>renderActionFrame: aHumFrame4Action    "Render action frame with indentation.</pre><pre>renderActionFrame: aHumFrame4Action withCritique: aBoolean   "Render source code. </pre><pre>renderActionLine: aHumFrameLine </pre><pre>renderAs: aSymbol    "FUTURE: Render as X -- Currently not needed."</pre><pre>renderAsHTMLonFileNamed: aNewFile    "Render as HTML5 and echo on given file."</pre><pre>renderAsHTMLwithCritique: withCritique withBase: withBase onFileNamed: aNewFile    "Render as HTML5 and echo on given file."</pre><pre>renderAsHTMLwithCritiqueOnFileNamed: aNewFile    "Render as HTML5 and echo on given file."</pre><pre>renderCommentIn: aFrameLine    "Render comment (if any) as HTML"</pre><pre>renderConditionLine: aHumConditionLine  </pre><pre>renderCritiqueForFrame: aHumFrame    "Return (HTML5) rendering of the frame`s critique"</pre><pre>renderDictionaryLine: aHumDictionaryLine </pre><pre>renderFrame: aHumFrame  withCritique: withCritique   "Render (pretty print) source code. </pre><pre>renderFrame: aHumFrame  withCritique: withCritique withBase: withBaseOntology   "Render (pretty print) source code. </pre><pre>renderFrameLine: frameLine     "Dispatch frameLine to rendering specialist."</pre><pre>renderFrameLinesIn: aHumFrame    "Iterate throught the frame lines" </pre><pre>renderInstruction: aHumStatement   "Pretty-print statement as HTML"</pre><pre>renderInstructionLine: aHumInstructionLine     "Pretty-print using HTML5 tags and CSS."</pre><pre>renderMarkupAsHTML5: markupSource   "Render the given mark-up text as HTML headings, lists, emphasis."</pre><pre>renderMarkupEmphasisAsHTML5: aString    "Render bold, italic, underscore emphasis."</pre><pre>renderNounTreeForNoun: aNoun    "Render a noun-tree rooted at the given noun (entity)."</pre><pre>renderNounTreeForNounAsHTML: aNoun    "Render a noun-tree rooted at the given noun (entity)."</pre><pre>renderPlanActionsIn: aHumFrame4Plan    "render precondition lines"</pre><pre>renderPlanFrame: aHumFrame4Plan    "Render source code. </pre><pre>renderPlanPreconditionsIn: aHumFrame4Plan    "render precondition lines"</pre><pre>renderPlanTreeForGoal: aGoal   "Render HTML for a previous created planTree (generated by  buildPlanTreeForGoal: )"</pre><pre>renderStatement: aHumStatement keywords: keywords </pre><pre>renderStatement: aHumStatement triggerWords: triggerWords keywords: keywords </pre><pre>renderView: aHumViewFrame    "Views are rendered as HTML forms -- which is different from other frames."</pre><pre>renderWidgetsInMarkup: aSourceString    "Return HTML5 equivalent of the widgets found in this mark-up line."</pre><pre>showPlanTree: aPlanTree   "Display a previous created planTree (generated by  buildPlanTreeForGoal: )"</pre><pre>showPlanTreeForGoal: aGoal   "Display a previous created planTree (generated by  buildPlanTreeForGoal: )"</pre><h3>Hum-Language -- HumOntology</h3><pre>actionsOf: aRole   "The actions of a role define its public interface. (API).</pre><pre>addEntity: anEntity attribute: anAttribute       "Define these nouns and their relationship."</pre><pre>addEntity: anEntity attributes: anAttributeCollection       "Define these nouns and their relationship."</pre><pre>addNoun: aNoun    "Remember noun."</pre><pre>addNoun: aSubType isA: aSuperType       "Add these nouns and add is-A relation."</pre><pre>addNoun: aNoun isDerivedFrom: anotherNoun</pre><pre>addNoun: aSynonym isSynonymFor: aStandardNoun    "Add these nouns and add is-A relation."</pre><pre>addNoun: aNounString reference: aFrameLine    "Remember where nouns are referenced."</pre><pre>addNouns: anArrayOfNouns </pre><pre>addPlanFrame: aPlanFrame ForGoal: aGoalString    "Store frame as a plan frame - index as needed."</pre><pre>addRole: aRole </pre><pre>addViewFrame: aHumFrame4View </pre><pre>addVignette: aFrame4Vignette toContext: aContext    "Add to store"</pre><pre>allAttributesOfEntity: anEntity    "Get the attributes, the attributes of the attributes, and the attributes of the supertypes."</pre><pre>allSubtypesOf: aSuperType    "Get the subtypes (if any) of this noun and the subtypes of the subtypes all the way down"</pre><pre>allSupertypesOf: aSubType    "Get the Supertypes (if any) of this noun and the Supertypes of the Supertypes all the way down"</pre><pre>appendInstruction: aHumInstruction toRole: aRole action: anAction    "Append the given instruction to the action's sequence of instructions."</pre><pre>appendRole: aRole action: actionStatement    "Add role and action statement."</pre><pre>asString</pre><pre>attributeChain   ^attributeChain ifNil: [ attributeChain := Stack new.]</pre><pre>attributeChainPop: anAttribute </pre><pre>attributeChainPush: anAttribute </pre><pre>buildPlanTreeForGoal: aGoal indent: anIndentLevel   "Build a list of associations: ( goalStatement -&gt; { anIndentLevel. precondition statement.} )"</pre><pre>categoriesOf: anAttributeName </pre><pre>categoriesOf: anAttributeName include: anArrayOfCategoryNames   "Add this noun in case it is not already added;"</pre><pre>checkPlanTreeForGoal: aGoal </pre><pre>cleanKey: aString   "Assure that the string will be a clean key -- convert to lower-case, trim blanks."</pre><pre>codeGenerator   "Return a translator."</pre><pre>collectPlanFramesForGoal: aGoalStatement    "| goalStatement planTree subTree rootFrame |</pre><pre>compileAllFrames   "Compile the dictionary frames first, then the others." </pre><pre>contextVignettes   "This list holds the (1:M) relation (context -&gt; vignette)."</pre><pre>contexts   ^ contexts ifNil: [  contexts := Set new. ]</pre><pre>critiqueRole: aRole action: anAction    "Critique the instructions for this role action."</pre><pre>debug   "Am I in debug mode?"</pre><pre>entityAttributes   "This instance variable is a map, a set of associations ( anEntity -&gt; anAttribute )"</pre><pre>fetchFrameByIdentifier: aPrimaryKey    "Fetch the frame with this identifier."</pre><pre>fetchFrameByName: aString </pre><pre>file   ^ fromFile ifNil: [ fromFile := 'HumOntologyFile.ontology' ].</pre><pre>file: aString </pre><pre>findBestMatchingVignetteForInput: aString inContextStack: aStack    "Search the vignette frames for the one whose pattern is the best match</pre><pre>frameRelations   "The cross index collection tracks relationships between frames."</pre><pre>frameRelationsWhere:  aBlock   "Return frame relations where aBlock evaluates as true"</pre><pre>frames   ^ frames ifNil: [ frames := Set new. ].</pre><pre>framesByIdentifier   "Each frame is given a unique identifier. </pre><pre>framesByName   "Enable access to frames by their name (title line string)."</pre><pre>fromFile   "The file name serves as a natural identifier. "</pre><pre>getEntityAttributePhraseFromStatement: aHumStatement    "Return collection of 'entity attribute' pairs when statement contains possessive nouns."</pre><pre>getFrameForRole: aRole action: anAction    "Get the frame that matches given role and action."</pre><pre>getFramesThatDefineContext: aContextName    "Get the vignette frames that define the given context."</pre><pre>getFramesThatInvokeAction: anActionString    "Lookup the frames where action is invoked."</pre><pre>getFramesThatInvokeContext: aContextName    "Get frames with 'Push context &lt;aContextName&gt;.'  instructions."</pre><pre>getFramesThatInvokePrecondition: aStatementString    "Lookup the frames where precondition is invoked."</pre><pre>getFramesThatInvokeView: aViewName   "A view may be invoked by another view or by a vignette."</pre><pre>getFramesWithRelation: aSymbol object: aName   "Get frames that are indexed with given relation and object."</pre><pre>getPlanFrameForGoal: aGoalString </pre><pre>getRole: aRole action: aStringOrStatement    "Get the action if it already exists."</pre><pre>getViewFrame: nameString    "Get the view frame with the given name."</pre><pre>hasNoVignetteMatchFor: aString </pre><pre>immediateAttributesOfEntity: anEntity    ^ self projectValuesOf: (self entityAttributes) from: anEntity.</pre><pre>immediateSubtypesOf: aSuperType    "Get the subtypes (if any) of this noun."</pre><pre>immediateSupertypesOf: aNoun   "Get the immedate supertypes (if any) for this noun." </pre><pre>indexFrame: aHumFrame relation: aSymbol object: aKeyString    "Add the given frame to the index"</pre><pre>indexRole: aRole action: actionStatement    "Index role and action statement."</pre><pre>instructionsForRole: aRole action: anAction</pre><pre>isActionDefined: anInstructionLine inRole: aRole   "Has the given statement been defined as an action for the given role?"</pre><pre>isActionDefinedV01: anInstructionLine    "See if we have a definition for the given action."</pre><pre>isAttribute: aNameString   "Does the string name an attribute? (An attribute has no attributes of its own.)"</pre><pre>isCategory: aNameString   "Does the string name an attribute? (An attribute has no attributes of its own.)"</pre><pre>isEntity: aNameString   "Does the string name an entity?"</pre><pre>isEntity: entityName attribute: attributeName   "Does this combination make sense? "</pre><pre>isNoun: aNounString       "Is the given string a noun?"</pre><pre>isPluralNoun: aNoun   "Return true if the noun is plural."</pre><pre>isViewName: aString    "Does the string name a view frame?"</pre><pre>nounAsCamelCase: aString </pre><pre>nounCategories   "(self nounCategories) at: attribute put: setOfCategories."</pre><pre>nounReferences   "(self nounReferences ) add: ( aNounString -&gt; aFrameLine )."</pre><pre>nounSubtypes   "This instance variable is a map, a set of associations ( aSuperType -&gt; aSubType )."</pre><pre>nounSynonyms   "(self nounSynonyms) add: ( theSynonym -&gt; theNoun)."</pre><pre>nouns   "This instance variable is the set of all nouns that have been defined so far."</pre><pre>nounsInStatement: aHumStatement    "Return the (known) nouns found in the statement."</pre><pre>parseFrameLine: frameLine keywords: keywords   "Parse the frameLine -- Return a list of token-type pairs: ( token -&gt; tokenType ).</pre><pre>parseStatement: aHumStatement triggerWords: triggerWords keywords: keywords    "Parse the statement -- Return a list of token-type pairs: ( token -&gt; tokenType ).</pre><pre>planFrames</pre><pre>printOn: aStream</pre><pre>projectValuesOf: aSetOfAssociations from: aKey   "encapsulate a bit of recurring code"</pre><pre>roleActions   "This instance variable is a map, a set of associations  ( role -&gt; actionStatement ) "</pre><pre>roles   "This instance variable contains the set of all roles that have been defined so far."</pre><pre>setAutomaticSupertypeForNoun: aNoun    "If a hyphenated nouns ends with the name of another noun,</pre><pre>singularFormOfNoun: aNoun    "If noun ends in 's'  remove the 's'.  Crude."</pre><pre>storeFrame: aFrame    "Store this frame in the ontology.</pre><pre>title   ^ title ifNil: [ title :=  (self fromFile), ' -- No title yet.'. ].</pre><pre>title: aString </pre><pre>view   ^viewer ifNil: [ viewer := HumOntologyViewer ontology: self. ].</pre><pre>vignettesForContext: aRequestedContext</pre><pre>xparseString: aStatementString keywords: keywords    "Coding experiment to see if I can tweak existing code to handle quoted strings."</pre><pre>yesNoun: aSubtype isAKindOf: aSuperType    "Is the noun a subtype of the given supertype? Used when matching action statements."</pre><pre>yesRole: aRole hasAction: aSource   "Is the given action defined for the given role?"</pre><h3>Hum-Language -- HumParser2</h3><pre>alphanumeric: aString    "Match that part of the string that is alpha-numeric"</pre><pre>checkbox: aSource   "Does the current source start with a check box widget?"</pre><pre>checkbox: aSource produce: aProductionBlock   "Does the current source start with a check box widget?"</pre><pre>digits: source    "Match leading part of source that is digits"</pre><pre>generateChoicesFor: anAttributeName inOntology: aHumOntology    "Generate HTML choice tags"</pre><pre>generatedCode   ""</pre><pre>ignoreNext   ^ignoreNext ifNil: [ ignoreNext := false. ].</pre><pre>ignoreNext: aBoolean </pre><pre>markupSyntax   "Experimental BNF syntax"</pre><pre>markupSyntaxWithOntology: anOntology   "Experimental BNF syntax"</pre><pre>markupSyntaxWithOntology: anOntology blackBoard: aBlackBoard   "Experimental BNF syntax"</pre><pre>match: source oneOf: anArrayOfSyntaxThings</pre><pre>match: source oneOf: anArrayOfSyntaxThings produce: productionBlock   "Does current source match array? If so, run the production."</pre><pre>match: source repeat: anArrayOfSyntaxThings   "Does current source match array?"</pre><pre>match: source sequence: anArrayOfSyntaxThings   "Does current source match array?"</pre><pre>match: source sequence: anArrayOfSyntaxThings produce: productionBlock   "Does current source match array? If so, run the production."</pre><pre>match: aString with: syntaxThing    "Does aString match with syntaxThing?"</pre><pre>noun: source    "Match that part of the string that might name a Hum noun"</pre><pre>ontology: aHumOntology blackBoard: aBlackBoard produceView: aViewName    "Produce the HTML for the given view frame."</pre><pre>ontology: aHumOntology isAttribute: aSource    "Does the current source, upto some delimiter, match an ontology attribute name?"</pre><pre>ontology: aHumOntology isCategory: aSource    "Does the current source, upto some delimiter, match an ontology category name?"</pre><pre>ontology: aHumOntology isEntity: aSource    "Does the current source, upto some delimiter, match an ontology entity name?"</pre><pre>ontology: aHumOntology isViewName: aSource    "Does the current source, upto some delimiter, match an ontology view name?"</pre><pre>ontology: aHumOntology isViewName: aSource produce: productionBlock    "Does the current source, upto some delimiter, match an ontology view name? </pre><pre>ontology: aHumOntology produceView: aViewName    "Produce the HTML for the given view frame."</pre><pre>pop: aSmallInteger </pre><pre>push: aString </pre><pre>pushIgnore: aString </pre><pre>radioButton: aSource produce: aProductionBlock   "Does the current source start with a radio button widget?"</pre><pre>spaces: source    "Match leading part of source that is digits"</pre><pre>stack   ^stack ifNil: [ stack := OrderedCollection new.]</pre><pre>text: aString    "Return that part of string that contains no mark-up."</pre><pre>top</pre><pre>url: source   "Does current source match a URL pattern?"</pre><h3>Hum-Language -- HumStatement</h3><pre>= aStatement </pre><pre>asCamelCase    "Convert this statement to camelCase."</pre><pre>asCamelCaseWithOntology: aHumOntology    "Convert this statement to camelCase."</pre><pre>asString   ^ self source asString.</pre><pre>delegateToTranslator</pre><pre>errors   ^errors ifNil: [ errors := Set new.].</pre><pre>hash    "This HACK (which may be a bad idea) makes HumStatement hash the same as a matching string.</pre><pre>isConditional</pre><pre>isSatisfied: aBoolean </pre><pre>matchesCandidateStatement: aCandidate inOntology: aHumOntology   "Does the candidate match me? (Candidate nouns might be subtypes of my nouns.)"</pre><pre>matchesTemplateStatement: aStatementTemplate inOntology: aHumOntology    "Do I match the given template? (My nouns may be subtypes of template nouns)"</pre><pre>noun: aNoun value: aValueObject    "Noun values are set at run-time just prior to executing the statement.</pre><pre>nounAsCamelCase: aString    "Delegate to ontology class"</pre><pre>nounValues   "Noun values are set at run-time. </pre><pre>onMatch: aPatternString do: aBlockClosure    "When my source matches pattern, execute the block with matching arguments.</pre><pre>printOn: aStream   "Append to the argument, aStream, a sequence of characters that  </pre><pre>role   ^role ifNil: [ Error signal: 'role was not set in HumStatement']</pre><pre>role: aString   "What role is meant to execute this statement?</pre><pre>sameAs: aHumStatement    "Return true if receiver is semantically equivalent to (argument) aHumStatement."</pre><pre>source   ^ source ifNil: [ source := '' ].</pre><pre>source: aSource      "Set and check the source string."</pre><pre>stripRole   "Source should not contain a role prefix in this context.</pre><pre>syntaxError: anErrorMessage    "Error signal: anErrorMessage."</pre><pre>tokens   "Return the tokens in the statement as an array of strings."</pre><pre>translation   "How might the statement be translated into another programming language?"</pre><pre>translation: aString    "How might the statement be translated into another programming language?"</pre><h3>Hum-Language -- HumVignettePatternLine</h3><pre>checkSyntaxWithOntology: aHumOntology   "TODO: Look for [noun]. Is the noun defined in the ontology?"</pre><h3>Hum-Language -- HumVignetteResponseLine</h3><pre>checkSyntaxWithOntology: aHumOntology   "TODO: Look for [noun]. Is the noun defined in the ontology?"</pre><h3>Hum-RunTime -- HumActor</h3><pre>blackboard   ^ blackboard ifNil: [ blackboard := HumBlackBoard new. ].</pre><pre>blackboard: aHumBlackBoard </pre><pre>checkIn</pre><pre>checkOut   "Tell the Dispather that this actor is no longer available for assignments."</pre><pre>completedAction: anAction inRole: aRoleString onJob: aHumJobTicket    "Following is first-cut direct call.</pre><pre>completedInstruction: aHumInstructionLine inRole: aRoleString onJob: aHumJobTicket    "Following is first-cut direct call.</pre><pre>delegateAction: anAction toRole: aRole onJob: aJobTicket   "Delegate action to another role."</pre><pre>dispatcherID   ^self configuration dispatcherID.</pre><pre>ontology   ^self configuration ontology.</pre><pre>roles</pre><pre>roles: anArray </pre><pre>runAction: anAction inRole: aRole onJob: aHumJobTicket   "Run the action frame named ..." </pre><pre>runInstruction: anInstruction inRole: aRole onJob: aJobTicket   "Execute, simulate, or log the given statement"</pre><pre>updateBlackBoardFromBlackBoard: aHumBlackBoard    "Update my blackboard with entries from callers blackboard."</pre><pre>zrunInstruction: anInstruction inRole: aRole onJob: aJobTicket   "Execute, simulate, or log the given statement"</pre><h3>Hum-RunTime -- HumBase</h3><pre>entitiesOfType   ^ entitiesOfType ifNil: [ entitiesOfType := Dictionary new ].</pre><pre>entitiesWithValue   "A dictionary of sets. The set of entities with the given { attribute value }."</pre><pre>entityAttributeValue   "A dictionary holding a temporal stack of {value event} for each {entity attribute}.</pre><pre>entityID: anID entityType: aType attribute: anAttribute value: aValue event: anEvent   "Create a record of entity-attribute-value from event."</pre><pre>eventWho: aWho what: aWhat where: aWhere why: aWhy </pre><pre>events   ^ events ifNil: [ events := Dictionary new].</pre><pre>findEntitiesOfType: anEntityType </pre><pre>findEntitiesWhereAttribute: anAttributeType satisfies: aBlockClosure    "Get collections of entities where current attribute value satisfies condition"</pre><pre>getEntityID: anEntityID attribute: anAttributeType    "Get the current value for given entityID attributeType"</pre><pre>insert: anItem at: aKey into: aDictionaryOfSets   "Insert the item into a set at the given key."</pre><pre>push: anItem at: aKey onto: aDictionaryOfStacks   "Insert the item into a list at the given key."</pre><pre>remove: anEntityID at: aKey from: aDictionaryOfSets    "Remove the entityID from the set associated with the key."</pre><h3>Hum-RunTime -- HumBlackBoard</h3><pre>appendEntity: childEntityID toEntity: parentEntityID list: anAttributeName    "Append the given child entity to the named list attribute"</pre><pre>businessEvent   "What business event is in progress?"</pre><pre>businessEvent: aString   "What business event is in progress?"</pre><pre>cleanAttribute: anAttributeNameString </pre><pre>cleanEntity: anEntityTypeString    "Assure that the type-name is properly-trimmed, lowercase string"</pre><pre>clearEntity: anEntityType    "Clear all data for the given entity-name / entity-type."</pre><pre>entityIdentifiers   "What identifier is associated with a entity type noun (entity name)?"</pre><pre>generateNewIdentifierForEntityName: anEntityName   "Create a unique identifier for an instance of the given entity-name noun."</pre><pre>getEntityID: entityID attribute: anAttributeName    " Get requested value (if any) from the blackboard instance "</pre><pre>getEntityName: anEntityName attribute: anAttributeName    "Get the entityID for that entity-name and fetch the requested attribute."</pre><pre>identifierForEntityName: anEntityName    "Do I already have an entity of that name? </pre><pre>makeEntityOfType: anEntityType    "Add a new entity ID for the given entity type. (entity name)."</pre><pre>quads   "a dictionary of { aValue. tau. } keyed by ( entityID -&gt; attribute )"</pre><pre>setEntityID: entityID attribute: anAttributeName toValue: aValue   "Store given value in the blackboard with a time-stamp. </pre><pre>setEntityName: anEntityName attribute: anAttributeName toValue: aValue   "for now -- same as:"</pre><pre>updateBlackBoardFromBlackBoard: aHumBlackBoard    "Update myself from entries in the other blackboard."</pre><pre>worldbase   ^ worldbase ifNil: [Error signal: 'Blackboard configured without a world base.']</pre><pre>worldbase: aHumWorldBase </pre><h3>Hum-RunTime -- HumBookkeeper</h3><pre>chargesBy: attribute   "Produce dictionary of sums for given subdivision type."</pre><pre>chargesByAction   "Produce dictionary of sums keyed by action."</pre><pre>chargesByActor   "Produce dictionary of sums keyed by actor."</pre><pre>chargesByJob   "Produce dictionary of sums keyed by job."</pre><pre>chargesByMetric   "Produce dictionary of sums keyed by unit of measure. "</pre><pre>chargesByRole   "Produce dictionary of sums keyed by role-name.."</pre><pre>jobTickets   ^ jobTickets ifNil: [ jobTickets := OrderedCollection new. ].</pre><pre>recordJobTicket: aHumJobTicket    "Add the given job ticket to my collection of job tickets."</pre><h3>Hum-RunTime -- HumBusinessEvent</h3><pre>what: aString   "What is the cause/actor doing in the business event?"</pre><pre>when: aTimeStamp   "When (at what date-time) is business event happening?"</pre><pre>where: aString   "Where (at what location/context) is business event happening?"</pre><pre>who: aString   "Who is the cause/actor in the business event"</pre><pre>who: aWho what: aWhat when: aTimeStamp where: aWhere why: aJobTicket   "Set the business event attributes."</pre><pre>why: aJobTicket   "Why (job-ticket) is business event happening?"</pre><h3>Hum-RunTime -- HumCalculator</h3><pre>cases   "Initialize case cascade.</pre><pre>doTokensIn: input at: xInput matchPatternTokensIn: pattern at: xPattern</pre><pre>exdent   "Remove a tab from the global indent string."</pre><pre>fillTemplate: template fromDictionary: dictionary   "Create a String based on the given template and parameters."</pre><pre>given: sourceString extractAfter: stringA    "Return the substring in the sourceString between the two."</pre><pre>given: input extractAfterSecond: marker    "Parse cases like matching quotes or markup emphasis."</pre><pre>given: sourceString extractBetween: stringA and: stringB   "Return the substring in the sourceString between the two."</pre><pre>given: sourceString extractUpto: stringA    "Return the substring in the sourceString between the two."</pre><pre>given: inputString onMatch: aPatternString do: aBlockClosure    "When the inputString matches pattern, execute the block with matching arguments.</pre><pre>given: input replaceAll: old with: new </pre><pre>given: s topic: aTopic doOnce: aBlock   "Use this to produce subheadings."</pre><pre>indent   "Append a tab to the global indent string."</pre><pre>indentLevel: n    "Reset the indent level. Produce indent string (tabs)."</pre><pre>initialize</pre><pre>justTheWordsIn: aString   ^self class justTheWordsIn: aString.</pre><pre>on: aValue do: aBlockClosure </pre><pre>otherwise: thenBlock   "If a prior case was true, ignore this case. </pre><pre>parse: aString   "Parse into { token. type. start. stop. }"</pre><pre>priorCaseIsTrue   ^ priorCaseIsTrue ifNil: [priorCaseIsTrue := false ].</pre><pre>scoreCandidate: candidateString againstPattern: patternString   "Return a score indicating the number of tokens that match." </pre><pre>string: stringA isLike: stringB    "Compare ignoring differences in whitespace."</pre><pre>string: aString isLike: aString2 ignore: aString3    ^self class string: aString isLike: aString2 ignore: aString3.</pre><pre>switch: aCharacter </pre><pre>testValue: anObject </pre><pre>when: whenBlock then: thenBlock   "If the whenBlock evaluated to true, execute the thenBlock."</pre><pre>xml: aTagString dictionary: aDictionaryOrList    "Create a stand-alone tag (ending with '/&gt;') with the given attribute values."</pre><pre>xml: aTagString dictionary: aDictionary with: aBlockClosure    "Generate the front tag and the end tag with block to produce the middle"</pre><pre>xml: tagString list: anArray    "Iterate: Enclose each item with given tagString"</pre><pre>xml: aTag with: aBlock    "Fix up the indent after we get this working."</pre><pre>xmlOpen: aTagString dictionary: aDictionary    "Create an opening tag ( NOT ending with '/&gt;' ) with the given attribute values."</pre><h3>Hum-RunTime -- HumConfiguration</h3><pre>bookkeeperID   ^ bookkeeperID</pre><pre>bookkeeperID: anObject</pre><pre>clock   "What object is providing time-keeping?"</pre><pre>clock: anObjectThatImplementsNow   "Clock must be an object that imlements &gt;&gt;now as a number of seconds (an Integer)."</pre><pre>configuration: aHumConfiguration    "Copy configuration."</pre><pre>debug   "Am I in debug mode?"</pre><pre>dispatcherID   ^ dispatcherID ifNil: [ Error signal: 'A configuration must have a Dispatcher.' ].</pre><pre>dispatcherID: anObject</pre><pre>getWorldBase   "Get this configuration`s worldbase instance."</pre><pre>isTest  "Are we running in TEST mode?"</pre><pre>isTest: aBoolean   "Are we running in TEST mode?"</pre><pre>messenger   ^ messengerProxy </pre><pre>messenger: aHumMessenger   "Set the messenger -- Use to configure mocks when needed."</pre><pre>messengerID   ^ messengerID</pre><pre>messengerID: aString</pre><pre>messengerID: idMessenger dispatcherID: idDispatcher bookkeeperID: idBookkeeper worldbaseID: idWorldbase</pre><pre>now   "What time is it in configured world (may be simulation)?"</pre><pre>ontology   ^ ontology ifNil: [ Error signal: 'ontology is missing from configuration'].</pre><pre>ontology: aHumOntology </pre><pre>openWorldBase   "Create world base instance and register with messenger."</pre><pre>worldbaseID   ^ worldbaseID</pre><pre>worldbaseID: anObject</pre><h3>Hum-RunTime -- HumCoordinator</h3><pre>conditionIsSatisfied: precondition    "Note that condition is satisfied.</pre><pre>context: aHumActor</pre><pre>coordinatorID: anID uri: aURI goal: aGoalStatementString dialog: aHumDialogAgent configuration: aHumConfiguration</pre><pre>dialogAgent: aHumDialogAgent    "Concept: The dialog agent provides noun values </pre><pre>getActionSequence   "Parse the job ticket to show the sequence of actions."</pre><pre>goal: aStatement</pre><pre>goalStatement   "Translate goal string to goal statement"</pre><pre>isPlanFrameRunnable: aHumFrame4Plan   "Determine if the given plan frame is runnable.</pre><pre>jobTicket   ^ jobTicket ifNil: [ jobTicket := HumJobTicket title: goal ].</pre><pre>planIsRunnable   "TODO: ADD NEEDED CHECKS TO THIS STUB."</pre><pre>remainingConditions   ^ remainingConditions ifNil: [ remainingConditions := Set new.] .</pre><pre>runAction: anInstructionLine    "Run the given action statement."</pre><pre>runPlan   "Run my plan.</pre><pre>runPlanFrameForCondition: aGoalString   "This visits the subtree and runs each frame that is ready to run.</pre><pre>runPlanSetup   "Setup to run a plan:</pre><h3>Hum-RunTime -- HumDecimal</h3><pre>fromString: aString   "Count the digits in the string to estimate accuracy."</pre><pre>nDecimal   "How many decimal places should we display."</pre><pre>nDecimal: anInteger    "How many decimal places should we display."</pre><pre>printOn: aStream</pre><h3>Hum-RunTime -- HumDialogAgent</h3><pre>askView: aViewName</pre><pre>buildDialogAgentOntology   "Return ontology with Dialog Agent actions defined and executable in Smalltalk."</pre><pre>clearEntity: entityType   "Clear prior data in my blackboard for the given entity type."</pre><pre>client: aString </pre><pre>clientSays: aString    "Match user utterance to vignette patterns in the ontology</pre><pre>contextStack   ^ contextStack ifNil: [ contextStack := Stack new. self pushContext: 'Start.'. contextStack ].</pre><pre>dialogAgentOntology   "Return ontology with Dialog Agent actions defined and executable in Smalltalk."</pre><pre>dialogOntologySourceStream   "Return a stream of frames defining Dialog Agent actions."</pre><pre>extractFieldValuesFromUserInput: inputString pattern: patternString    "Extract values from user input and post to my blackboard. </pre><pre>fillInSlotIn: aMarkupString    " Fill-in first [entity attribute] dialog-response-slot with data from blackboard.</pre><pre>interpretVignette: aHumFrame4Vignette withInput: aUserInput   "Send response lines. Execute response instructions."</pre><pre>newEntity: anEntityType    "Create a new entity to be associated with the given entity-type/entity-name."</pre><pre>pushContext: aString </pre><pre>runAction: anAction inRole: aRole onJob: aHumJobTicket   "Dialog Agent knows: 'Ask view', 'Show view', 'Push context ...'" </pre><pre>sayToClient: aHumMarkupLine    "Say something to the client. </pre><pre>scribeProxy   "Return an instance that understands #systemSays:</pre><pre>showView: aViewName</pre><h3>Hum-RunTime -- HumDispatcher</h3><pre>actor: anActor completedAction: aHumStatement   "Dispatcher is informed that the actor completed the assigned action.</pre><pre>assignAction: aHumInstructionLine toRole: aByteString forJob: aHumJobTicket </pre><pre>assignRole: roleString action: actionInstruction    "Assign the given action to an actor advertising the given role."</pre><pre>availableActors   ^ availableActors ifNil: [ availableActors := Set new. ].</pre><pre>busyActors   ^ busyActors ifNil: [ busyActors := Set new ].</pre><pre>checkInActor: actorID at: aURI withRoles: actorKnowsRoles    "The Dispatcher should delegate finding the URI to messenger."</pre><pre>checkOutActor: anActorID at: anActorURI    "Actor is no longer available for assignments."</pre><pre>roleActor   "Return the role-&gt;actor map set."</pre><pre>runAction: anAction inRole: aRole onJob: aHumJobTicket   "Dispatch the action to an actor in the given role." </pre><pre>sendMessage: aMessageObject to: recipientID.   "TODO: HumActor does not need to know that delegating a statement is a message send.</pre><h3>Hum-RunTime -- HumEntity</h3><pre>asString   ^self title.</pre><pre>debug   "Am I in debug mode?"</pre><pre>id   "Return a unique identifier."</pre><pre>id: aString    "Set the entity`s identifier."</pre><pre>printOn: aStream</pre><pre>title   "a display string describing this entity" </pre><pre>title: aString   "a display string describing this entity" </pre><h3>Hum-RunTime -- HumFuzzy</h3><pre>* aHumFuzzy </pre><pre>+ aHumFuzzy </pre><pre>- aHumFuzzy </pre><pre>/ aHumFuzzy </pre><pre>asCrudeMorph</pre><pre>asCrudeMorph2</pre><pre>asCrudeMorphInRectangle: aRectangle   "Display a plot in a Morph with the origin and extent indicated by the given Rectangle."</pre><pre>atP: aFloat    "Return the appropriate value from the distribution.</pre><pre>correctInterceptInDistribution: aDistribution   "-- Use slope-intercept to get a better estimate of the S-curve value at probability 0.</pre><pre>distribution: aDictionary    "Distribution is an S-curve that maps probability to value.</pre><pre>distributionDo: pvBlock   "Vist the key-&gt;value (probability-&gt;value) entries in the distribution."</pre><pre>fromScaledDecimal: aScaledDecimal   "Set the distribution from the given string.</pre><pre>fromString: aString   "Set the distribution from the given string.</pre><pre>initialize</pre><pre>interpolate: aProbability   "Return the predicted value at aProbability using linear interpolation."</pre><pre>mean</pre><pre>median   "find the point that represents the median"</pre><pre>op: aSymbol with: aHumFuzzy "Add two fuzzy distibutions using Monte Carlo sampling"</pre><pre>sampleSize: anInteger   "Reset the sample size used in Monte Carlo sampling of input distributions.</pre><pre>sampleSize: aSampleSize resultDivisions: aDivisionCount   "Reset the sample size used in Monte Carlo sampling of input distributions.</pre><pre>sampleWithBlock: aBlock "Operate on fuzzy distibution using Monte Carlo sampling"</pre><h3>Hum-RunTime -- HumHttpRequest</h3><pre>atField: aKey put: aValue   "The Http Request form included this input name:value pair."</pre><pre>fields</pre><h3>Hum-RunTime -- HumIdentifier</h3><pre>&lt; aHumIdentifier </pre><pre>&lt;= aHumIdentifier </pre><pre>asString</pre><pre>entityName   "Return entity name -- force nil to string if needed."</pre><pre>generateForEntityName: anEntityName inContext: aBusinessEvent   "Make self a unique identifier for given entity context."</pre><pre>initialize   "This UUID represents the run-time. </pre><pre>printOn: aStream</pre><pre>uuid: aUUID </pre><h3>Hum-RunTime -- HumJobTicket</h3><pre>appendCharge: aHumMeasure forAction: action byActor: anID inRole: aRoleName onJob: aJobID </pre><pre>charges   ^charges ifNil: [ charges := OrderedCollection new.]</pre><pre>getActionSequence   "Parse the job ticket to show the sequence of actions."</pre><pre>printOn: aStream</pre><h3>Hum-RunTime -- HumMeasure</h3><pre>* multiplier </pre><pre>+ operand </pre><pre>- operand </pre><pre>/ aDivisor </pre><pre>&lt; operand </pre><pre>= operand </pre><pre>&gt; operand </pre><pre>@ aHumMeasure </pre><pre>abs</pre><pre>adaptToCollection: aCollection andSend: aSymbol </pre><pre>arcTan: aDenominator    "Return the arc-tangent (angle) for self divided by aDenominator"</pre><pre>as: aSymbol   "Convert to the unit of measure indicated by aSymbol, and renders as String"</pre><pre>asFloat</pre><pre>asMillimeter   "Convert pixel dimensions to millimeter dimensions"</pre><pre>asMillimeters   ^self asMillimeter.</pre><pre>asPercent</pre><pre>asString</pre><pre>compareAngle: aRadianMeasure   "Handle special arithmetic for comparing angles."</pre><pre>cos</pre><pre>cubed</pre><pre>dimensions   "Tracks units and powers of units -- "</pre><pre>dimensions: aDictionary </pre><pre>displayUnits</pre><pre>incrementDimensionsAt: aUnit by: anIncrement   "Increment / Decrement dimension exponent by given increment (negative when decrementing).</pre><pre>isDimensionless   "Is the current measure dimensionless?"</pre><pre>isPixels</pre><pre>isRadian</pre><pre>negated</pre><pre>printOn: aStream   "Append to the argument, aStream, a sequence of characters that  </pre><pre>quantity   "Return the quantity that was observed for this instance."</pre><pre>quantity: aNumber </pre><pre>quantity: aNumber per: denominatorUnits   "Set instance denominator units.</pre><pre>quantity: aNumber units: numeratorUnits    "Set instance numerator units</pre><pre>quantity: aNumber units: numeratorUnits per: denominatorUnits   "Set instance numerator and denominator units.</pre><pre>quantityAsString   "Return the quantity that was observed for this instance."</pre><pre>quantityAsString: q   "Return the quantity that was observed for this instance."</pre><pre>sin</pre><pre>sqrt</pre><pre>standardNameFor: aString    "Fix up names of units to assure consistency."</pre><pre>units   "Render dimensions as a string"</pre><pre>unitsSynonyms   ^ self class unitsSynonyms</pre><h3>Hum-RunTime -- HumMessage</h3><pre>nounValues: associations    "TODO: Consider: a HumStatement also has nounValues. Which noun values are which?"</pre><pre>receiver: aString </pre><pre>sender: aString </pre><pre>statement: aHumStatement </pre><pre>whenSent: aTimeStamp    " "</pre><h3>Hum-RunTime -- HumMessenger</h3><pre>getActorInstanceFromID: actorID   "*** Backdoor *** during debug to bypass the messenger"</pre><pre>logInstruction: aHumStatement sentFrom: senderURI to: recipientURI </pre><pre>network   "Return the chosen physical implementation of network service."</pre><pre>nodeIDtoURI   "actorURI contains (actor-&gt;URI) maps"</pre><pre>ping: aURI   "MOCK: Return the ID of the given URI"</pre><pre>playbackLog   ^playbackLog ifNil: [ playbackLog := Dictionary new].</pre><pre>playbackLogFromActor: aHumActor    "Extract/Get log entries sent to/from a specific actor.</pre><pre>playbackLogFromURI: aURI    "Extract/Get log entries sent to/from a specific actor.</pre><pre>playbackLogToURI: aURI    "Extract/Get log entries sent to/from a specific actor.</pre><pre>registerActor: anActor atURI: aURI    "Track actor."</pre><pre>registerNode: aNode atURI: aURI    "Track actor."</pre><pre>sendAction: anInstructionLine toID: recipientID fromID: senderID    "Transmit action request between actors."</pre><pre>sendAction: anInstruction toURI: recipientURI fromURI: senderURI    "Send the (action) statement to the given actor."</pre><pre>sendInstruction: anInstruction toURI: recipientURI fromURI: senderURI   "Send the (action) statement to the given actor."</pre><pre>uriToNodeID   "What actor ID is associated with URI?"</pre><h3>Hum-RunTime -- HumNetwork</h3><pre>sendAction: anInstruction toURI: recipientURI fromURI: senderURI    "Send the (action) statement to the given actor."</pre><pre>uriToNode   "Return dictionary that maps a URI to an actual actor instance"</pre><h3>Hum-RunTime -- HumNode</h3><pre>asString   ^ self id ifNil: [ 'no ID'].</pre><pre>checkIn</pre><pre>clock   ^ clock ifNil: [clock := DateAndTime "class singleton"].</pre><pre>clock: anObjectThatImplementsNow</pre><pre>configuration   ^ configuration ifNil: [Error signal: 'Node has not been configured.'].</pre><pre>configuration: aHumConfiguration </pre><pre>htmlAgent   "Return http/html agent implementation.</pre><pre>id   ^myID</pre><pre>id: aString </pre><pre>log   ^ log ifNil: [ log := OrderedCollection new ].</pre><pre>messenger   ^self configuration messenger.</pre><pre>printOn: aStream   "Append to the argument, aStream, a sequence of characters that  </pre><pre>sendHTML: htmlString    "This is a dummy/mock for testing."</pre><pre>sendHTML: htmlString to: aURL   "This is a dummy/mock for testing. TODO: Make this real."</pre><pre>stepLog   ^ stepLog ifNil: [ stepLog := OrderedCollection new.].</pre><pre>stepLogDisplay   "Display the step log"</pre><pre>uri   ^myURI.</pre><pre>uri: aURI</pre><h3>Hum-RunTime -- HumNumberParser</h3><pre>nDigits   ^nDigits.</pre><h3>Hum-RunTime -- HumScribe</h3><pre>about"See also: HumRunTimeTests&gt;&gt;testS100ScribeReadMe"</pre><pre>askView: viewFrame withBlackBoard: aBlackBoard   "Current implementation assumes user interface is a HTML browser."</pre><pre>askViewCompleted   "Inform caller that the 'Ask viewName' task </pre><pre>blackboard   "This instance variable should be set by the instance-creation logic. "</pre><pre>client: aClientConection    "synonym"</pre><pre>clientConnection   ^ clientConnection ifNil:[ clientConnection := myURI ].</pre><pre>clientConnection: aConnectionOfSomeKind    "How does the Scribe connect to the user/client sensors?"</pre><pre>clientSays: aString    "After a client sensor input is interpreted,</pre><pre>dialogAgent   "Returns the Dialog Agent that was attached to this Scribe when the Scribe was instantiated."</pre><pre>dialogAgent: aHumDialogAgent</pre><pre>dialogAgentURI   "Returns an instance of HumDialogAgent."</pre><pre>dialogAgentURI: aHumDialogAgentURI </pre><pre>handleHttpPostRequest: aHumHttpRequest    "The scribe handles the post request by </pre><pre>htmlStyle   "Return CSS style element."</pre><pre>initialize   "DEBUG Check: Scribe should be initialized with a dialogAgent at creation."</pre><pre>mockDataEntry: userData    "Mock the user entering given data into view.</pre><pre>runAction: anAction inRole: aRole onJob: aHumJobTicket   "Over-ride HumActor to handle Scribe actions."</pre><pre>runInstruction: anInstruction inRole: aRole onJob: aJobID   "Override the HumActor -- (Why?)"</pre><pre>sendToDialogAgent: aClientSpeechString    "Send the string to my Dialog Agent."</pre><pre>sendView: htmlView   "Wrap the view element with HTML header, navigation, epilog, etc." </pre><pre>systemSays: aString    "The Dialog Agent has responded with this String.</pre><pre>zdialogAgent: aHumDialogAgent </pre><h3>Hum-RunTime -- HumSimulator</h3><pre>after: aDuration sendSpeech: aString from: aClientID    "Put this event into my queue."</pre><pre>buildDialogAgentNamed: clientID   "Build a dialog agent configured for our simulation."</pre><pre>clientScribes   ^clientScribes ifNil: [ clientScribes := Dictionary new.]</pre><pre>dialogAgents   ^ dialogAgents ifNil: [ dialogAgents := Dictionary new ].</pre><pre>dialogSequence: anArrayOfString    "Identify the sequence of dialog responses to be sent during this simulation."</pre><pre>getDialogAgentNamed: aClientID </pre><pre>getScribeForClient: aClientID    "Get the Scribe instance corresponding to the client ID."</pre><pre>initialize</pre><pre>log4Dialog   ^ log4Dialog ifNil: [ log4Dialog := OrderedCollection new. ].</pre><pre>logDialogWhen: aDuration who: aClientID why: clientSaid what: systemSaid</pre><pre>now   ^ self simulatedClockSecond.</pre><pre>now: aDuration </pre><pre>numberOfDialogs: aSmallInteger    "How many dialogs are to be run simulataneously?"</pre><pre>queue   ^ queue </pre><pre>randomStartingIntervals: aDistribution      "Express the distribution as an S-curve in seconds."</pre><pre>simulatedClockSecond   ^ simulatedClockSecond ifNil: [simulatedClockSecond := 0 seconds].</pre><pre>step   "Send all events with timing that matches the top event."</pre><pre>stepUntilDone</pre><h3>Hum-RunTime -- HumText</h3><pre>= anotherHumText   "Does this text have same content as the other"</pre><h3>Hum-RunTime -- HumTextLine</h3><pre>copy</pre><pre>indentLevel   "The indent level indicates the level of indentation,</pre><pre>indentLevel: aSmallInteger</pre><pre>size   ^ self string size</pre><pre>string</pre><pre>string: aByteString </pre><h3>Hum-RunTime -- HumText</h3><pre>addLine: aString    "Append given line at bottom of text."</pre><pre>copy</pre><pre>insertEmptyLineAfter: lineIndex </pre><pre>lines   "Return the HumText list of HumTextLine instances"</pre><pre>lines: anOrderedCollection </pre><pre>printOn: aStream   "Append to the argument, aStream, a sequence of characters that  </pre><pre>string   "Return self as a string. (Lines with CR inserted as needed.)"</pre><h3>Hum-RunTime -- HumVMInstruction</h3><pre>opCodeName</pre><pre>operand   ^ operand ifNil: [ Error signal: 'operand not set in HumInstruction'.  operand := 000].</pre><pre>operand: objectIndex </pre><pre>operation   ^ operation ifNil: [ Error signal: 'op code not set in HumInstruction'.  operation := 000].</pre><pre>operation: opCode </pre><pre>slotName</pre><h3>Hum-RunTime -- HumVM</h3><pre>measureRegister   ^ measure ifNil: [ measure := HumMeasure new. ].</pre><pre>runInstruction: aHumInstruction </pre><pre>setSlot: slotIndex to: aHumObject    "The slots allow objects to be referenced by byte-code indices."</pre><pre>slots   "slots allow objects to be referenced by byte-code indices."</pre><pre>transferVector</pre><h3>Hum-RunTime -- HumVector</h3><pre>asString   "render my value as a string"</pre><pre>at: index</pre><pre>at: k put:  aValue</pre><pre>cross: anotherHumVector   "Return the 3-dimensional vector cross product U x V</pre><pre>dot: aHumVector</pre><pre>length</pre><pre>lengthSquared</pre><pre>pitch: anAngleInRadians   "Transform receiver by a rotation about x (East pointing) axis."</pre><pre>pitch: anAngleInRadians aboutPivot: pivot   "Transform receiver by a rotation about X (side pointing) axis."</pre><pre>quantityAsString</pre><pre>roll: anAngleInRadians   "Transform receiver by a rotation about y (North pointing) axis."</pre><pre>roll: anAngleInRadians aboutPivot: pivot   "Transform receiver by a rotation about Y (forward pointing) axis."</pre><pre>size   "compatibility"</pre><pre>x   ^(self at: 1).</pre><pre>x: xValue y: yValue z: zValue   "Hum coordinates are plan-view. x points East. y North. z Up."</pre><pre>y   ^self at: 2.</pre><pre>yaw: anAngleInRadians   "Transform receiver by a rotation about z (Up pointing) axis."</pre><pre>yaw: anAngleInRadians aboutPivot: pivot   "Transform receiver by a rotation about Z (Up pointing) axis."</pre><pre>z   ^z := self at: 3.</pre><h3>Hum-RunTime -- HumWorldBase</h3><pre>checkTau: aTau </pre><pre>getEntityID: entityID attribute: attributeType    " Get requested value (if any) from the world base instance "</pre><pre>history   ^ history ifNil: [ history := Dictionary new. ].</pre><pre>initialize</pre><pre>quads   "For quad internal structure see </pre><pre>setEntityID: entityID attribute: attributeType toValue: aValue   "Put attribute-value (if any) into the world base instance. "</pre><pre>title   ^ title ifNil: [ Error signal: 'A world base instance must have a title.'].</pre><pre>title: aWorldBaseName </pre><pre>whereAttribute: attributeType satisfies: aBlockClosure   "Return a set of entity identifiers where the attribute value satisfies the block"</pre><h3>Hum-Seaside -- HumApplication</h3><pre>bookkeeper: aHumBookkeeper   "This application instance will be served by this bookkeeper instance."</pre><pre>dispatcher: aHumResourceManager   "This application instance will be served by this Dispatcher instance."</pre><pre>messenger: aHumMessenger   "This application instance will be served by this messenger instance."</pre><pre>ontology: aHumOntology   "This application a run-time manifestation of that ontology."</pre><pre>worldBase: aHumWorldBase   "This application instance will be served by this world-base instance."</pre><h3>Hum-Seaside -- HumBrowserEditFrame</h3><pre>critic   ^ critic ifNil: [ critic := '*** No frame critique yet ***' ].</pre><pre>critic: aTextString   "This is a dummy to accomodate a side-effect of using a TextArea to display the critique.</pre><pre>fetchCodeForTitle: aString</pre><pre>firstLine</pre><pre>frameCode   ^ frameCode ifNil: [ frameCode := '*** No frame code yet. ***']</pre><pre>frameCode: aTextString</pre><pre>initialize</pre><pre>lastSaved   ^ lastSaved ifNil: [ lastSaved := '*** NOT SAVED YET ***' ].</pre><pre>lastSaved:  anObject</pre><pre>layoutFrameAsColumnsOnCanvas: aWAHtmlCanvas   "Generate the column style layout"</pre><pre>layoutFrameAsRowsOnCanvas: aWAHtmlCanvas   "Generate the row style layout."</pre><pre>renderContentOn: html</pre><pre>runCritic   "Run the ontology critic that is appropriate to this type of frame."</pre><pre>setCritique: aTextString   "Set the critique value.</pre><pre>title   ^ title ifNil: [ title := 'TBD']</pre><pre>title: aString</pre><pre>trace: aString</pre><h3>Hum-Seaside -- HumBrowserSession</h3><pre>currentFrame   "What frame is currently being editted?"</pre><h3>Hum-Seaside -- HumBrowser</h3><pre>blackboard   ^ blackboard ifNil: [blackboard := HumBlackBoard worldbase: 'none'.]</pre><pre>clearOntology</pre><pre>contextDiagram   ^ contextDiagram ifNil: [ contextDiagram := HumDiagram new title: 'Context Diagram '].</pre><pre>currentFrame   "What frame is currently being editted?"</pre><pre>dialog   ^ dialog ifNil: [ dialog := HumSeasideComponentThingy new. ].</pre><pre>editActionFrame: aTitleString forRole: aRoleString   "Create / View / Edit the frame with the given title."</pre><pre>editDialogFrame: aString    "Create / View / Edit the frame with the given title."</pre><pre>editDictionaryFrame: aString    "Create / View / Edit the frame with the given title."</pre><pre>editPlanFrame: aString    "Create / View / Edit the frame with the given title. (Use goal statement as title.)"</pre><pre>editViewFrame: aString    "Create / View / Edit the frame with the given title."</pre><pre>hideDiagrams   ^ hideDiagrams ifNil: [ hideDiagrams = False ].</pre><pre>hideDiagrams: aBoolean   ^ hideDiagrams := aBoolean.</pre><pre>initialize</pre><pre>layout   "What style of browser layout (#rows or #columns)?</pre><pre>layout: aSymbol   "What style of browser layout (#rows or #columns)?</pre><pre>layoutDiagramsAsColumnOnCanvas: aWAHtmlhtml</pre><pre>layoutDiagramsAsRowOnCanvas: aWAHtmlCanvas</pre><pre>layoutMenuActionsAsColumnOnCanvas: html   "Identify the actions that the user may invoke via menu navigation."</pre><pre>layoutWindowAsColumns   "*** This is a design document defining layout in Hum markup. ***</pre><pre>layoutWindowAsColumnsOnCanvas: aWAHtmlCanvas   "This layout is visually two columns with editor on left and diagrams on right."</pre><pre>layoutWindowAsRows   "This layout is visually two rows with editor on bottom row and diagrams on top row."</pre><pre>layoutWindowAsRowsOnCanvas: aWAHtmlCanvas   "This layout is visually two Rows with diagrams in top row and editor in lower row."</pre><pre>loadOntologyFile: aFileSpec </pre><pre>loadOntologyInstance: ontologyTitle </pre><pre>log: aString   "Use #logUserAction instead."</pre><pre>logUserAction: aString   "Log the user action for potential analysis / diagnosis."</pre><pre>menuActions   "Identify the actions that the user may invoke via menu navigation."</pre><pre>newOntology   "Start with a fresh new ontology and clear any related views."</pre><pre>nounDiagram   ^ nounDiagram ifNil: [ nounDiagram := HumDiagram new title: 'Noun Diagram '].</pre><pre>ontology   ^ ontology ifNil: [ ontology := HumOntology new. ].</pre><pre>openOntology   "Clear all views and load an ontology from a save file."</pre><pre>openOntologyDialog</pre><pre>planDiagram   ^ planDiagram ifNil: [ planDiagram := HumDiagram new title: 'Plan Diagram '].</pre><pre>printOntology   "Document the current ontology in a HTML document"</pre><pre>programmersAssistant   ^ programmersAssistant ifNil: [ programmersAssistant := HumProgrammersAssistant new ].</pre><pre>renderContentOn: html</pre><pre>roleDiagram   ^ roleDiagram ifNil: [ roleDiagram := HumDiagram new title: 'Role Diagram '].</pre><pre>saveOntology   "Write the current ontology into a save file."</pre><pre>showSubMenu: aMenu title: aString onCanvas: html   "aMenu is an OrderedCollection of ( name -&gt; action ).</pre><pre>toggleDiagramView</pre><pre>toggleFullScreen</pre><pre>transposeLayout</pre><pre>userActions   ^ userActions ifNil: [ userActions := OrderedCollection new.].</pre><h3>Hum-Seaside -- HumSeasideComponentThingy</h3><pre>ask: aSymbol    "Ask, set, and return the requested attrbute."</pre><pre>ask: aString choice: anArrayOfSymbol   "The array of symbols liimits the user's choices"</pre><pre>askFile: aString    "Initiate a file spec dialog."</pre><pre>askV00: aSymbol    "Ask, set, and return the requested attrbute."</pre><pre>attributes   ^ attributes ifNil: [ attributes := Dictionary new. ].</pre><pre>logDialogAction: aString </pre><pre>renderView: anEntityID onCanvas: html   "**** Check generated code by pasting it below. ****"</pre><pre>valueOfAttribute: aSymbol    "Return the requested attrbute."</pre><h3>Hum-Tests -- GivenWhenThen4Seaside</h3><pre>assert: aBlock match: aPatternString    "This is a utility function to improve readability."</pre><pre>assert: aBlock matches: aPatternString    "This is a utility function to improve readability."</pre><pre>assertString: stringA includesSubstring: stringB    " stringB should be a substring in stringA "</pre><pre>expect: expectedValue actual: actualValue </pre><pre>given: aDescriptionString code: aBlock   "Given in a given-when-then triplet </pre><pre>givenWhenThenComment   "The #given:code: and #when:code: and #then:code: methods are designed to be cascaded.</pre><pre>log   ^ log ifNil: [ log := OrderedCollection new. ].</pre><pre>log: aString</pre><pre>test105GivenWhenThenSuccess   "Test the test utility - In this situation the test assertion is true."</pre><pre>test106GivenWhenThenFail   "Test the test utility - In this situation the test assertion is true."</pre><pre>test110BasicLog   "Test the testcase`s own log"</pre><pre>test120GivenWhenThenLogging   "Test the testcase`s own log"</pre><pre>then: aDescriptionString code: aBlock   "*Then* in a given-when-then triplet </pre><pre>when: aDescriptionString code: whenBlock   "*When* in a given-when-then triplet </pre><h3>Hum-Tests -- GivenWhenThen</h3><pre>assertString: stringA includesSubstring: stringB    " stringB should be a substring in stringA "</pre><pre>given: aDescriptionString code: aBlock   "Given in a given-when-then triplet </pre><pre>givenWhenThenComment   "The #given:code: and #when:code: and #then:code: methods are designed to be cascaded.</pre><pre>log   ^ log ifNil: [ log := OrderedCollection new. ].</pre><pre>log: aString</pre><pre>test105GivenWhenThenSuccess   "Test the test utility - In this situation the test assertion is true."</pre><pre>test106GivenWhenThenFail   "Test the test utility - In this situation the test assertion is true."</pre><pre>test110BasicLog   "Test the testcase`s own log"</pre><pre>test120GivenWhenThenLogging   "Test the testcase`s own log"</pre><pre>then: aDescriptionString code: aBlock   "*Then* in a given-when-then triplet </pre><pre>when: aDescriptionString code: whenBlock   "*When* in a given-when-then triplet </pre><h3>Hum-Tests -- Hum000RefactoringTests</h3><pre>givenOntology</pre><pre>humClassResponsiblityCollaboration^'Collaborative Roles and Responsibilities</pre><pre>strategyForSeaside^'TBD -- Currently considering subtyping HumWidgets as WAComponents</pre><pre>test110addFrame   "Add frame to ontology"</pre><pre>test121getFrameForGoal   "Get the plan frame that defines a goal."</pre><pre>test122getFrameForAction   "Get frame where action statement is defined."</pre><pre>test123getFrameForView   "Get frame where view is defined."</pre><pre>test131getFramesInvokingPrecondition   "Get the goal frames that invoke a given precondition."</pre><pre>test132getFramesInvokingAction   "Get the frames that invoke a given action."</pre><pre>test133getFramesInvokingView   "Get views frames and vignettes that invoke a view."</pre><pre>test134getFramesDefiningContext   "Get vignettes that define a context."</pre><pre>test135getFramesInvokingContext   "Get vignettes that define a context."</pre><pre>test210prettyPrintOntologyAsHTML   "Refactor so that this function is view OntologyViewer"</pre><pre>test211prettyPrintOntologyAsHTMLonFile   "Pretty print the given ontology on an HTML file."</pre><pre>test220renderCollectionAsHtmlTable   "A plural noun indicates a collection.</pre><pre>test221renderCollectionAsHtmlTableOnFile   "A plural noun indicates a collection.</pre><pre>test230renderEmphasisAsHTML   "Render emphasis in the markup as underscore, italic, bold. </pre><h3>Hum-Tests -- Hum000TestPlanOverview</h3><pre>aReadMe   "See the class description for the intended (future) tests."</pre><pre>givenWhenThenInHTML   "HTML GivenWhenThen frames."</pre><pre>progress   ^ ' </pre><h3>Hum-Tests -- HumBaseTest</h3><pre>test110putGetValue   "Save entity-attribute-value and fetch."</pre><pre>test120updateGetValue   "Save entity-attribute-value and fetch."</pre><pre>test130putGetEvent   "put get event"</pre><h3>Hum-Tests -- HumByteCodeTests</h3><pre>setUp   "For convenience, create a Hum VM instance for all of the tests to use."</pre><pre>test110EachInstructionHasTwoBytes   "A Hum byte code instruction has two bytes -- one for operation and one for operand."</pre><pre>test120OpCode000IsHalt   "An opCode of 000 is a halt instruction. (operand is ignored)"</pre><pre>test130Operand000IsNone   "An operand index of zero is treated as None.</pre><pre>test210MeasureLoad   "Load measure into measure-arithmetic register."</pre><pre>test220MeasureAdd   "Add measure into measure-arithmetic register."</pre><pre>test230MeasureMinus   "Add measure into measure-arithmetic register."</pre><h3>Hum-Tests -- HumCalculatorTests</h3><pre>test110substringAfter   "Test helper method that finds a substring between two given substrings."</pre><pre>test115substringBefore   "Test helper method that finds a substring between two given substrings."</pre><pre>test120substringBetween   "Test helper method that finds a substring between two given substrings."</pre><pre>test130substringBetweenBrackets   "Test helper method that finds a substring between a pair of brackets or similar pairs."</pre><pre>test210templateFill</pre><pre>test305parse   "Test the simple parser."</pre><pre>test310parse   "calc parse: s - recognizes quoted strings as single tokens."</pre><pre>test311parse   "What if string ends with quoted text?"</pre><pre>test312parse   "Test parse with quote within string."</pre><pre>test313parse   "calc parse: s - recognizes quoted strings as single tokens."</pre><pre>test314parse   "Test parse with quote within string."</pre><pre>test510measurePlusSameUnits   "Measures may be added if same units."</pre><pre>test520measureMinusSameUnits   "Measures may be added if same units."</pre><pre>test540CommonUnits</pre><pre>test542UnitsShouldCancel</pre><pre>test545Conversions</pre><pre>test546ConvertVolumeMeasures</pre><pre>test550CasualMeasures   "Work with non-KMS measures. Develop HumMeasure2"</pre><pre>test552CasualMeasuresAdd   "Work with non-KMS measures. Develop HumMeasure2"</pre><pre>test553CasualMeasuresSubtract   "Work with non-KMS measures. Develop HumMeasure2"</pre><pre>test554AsPercent   "Work with non-KMS measures. Develop HumMeasure2"</pre><pre>test555CasualMeasuresAsString   "Test asString"</pre><pre>test556CasualMeasuresSquares   "Test asString"</pre><pre>test557CasualMeasuresCubics   "Test asString"</pre><pre>test560coefficientOfExpansion   "Sometimes the exponents are all negative."</pre><pre>test570CreateMeasureFromString   "Create a measure from a sting of the form: -999 units"</pre><pre>test580exampleBussardRamJet</pre><pre>test581megaWattToAcceleration   "What kind of acceleration does a megaWatt per tonne give?"</pre><pre>test582exampleBussardRamJet</pre><pre>test582megaWattToAcceleration   "What level of acceleration does a megaWatt give to 100 tonnes of ship mass?"</pre><pre>test590examples   "Class-side examples should not fail"</pre><pre>testV110VectorCrossProduct   "Check the vector cross product"</pre><pre>testV111VectorCrossProduct   "Check the vector cross product"</pre><pre>testV112VectorCrossProduct   "Check the vector cross product"</pre><pre>testV113VectorCrossProduct   "Check the vector cross product"</pre><pre>testV115VectorCrossProduct   "Check the vector cross product"</pre><pre>testV117VectorCrossProduct   "Check the vector cross product"</pre><pre>testV210IdentityVector   "Creat a identity vector I * V = V.</pre><pre>ztest530measureTimesPercent   "Percent times percent produces percent"</pre><h3>Hum-Tests -- HumCodeBaseTests</h3><pre>test110MyPackages</pre><pre>test120MyClasses</pre><pre>test130GetPackageClassTuples</pre><pre>test140GetPackageClassMethodTuples</pre><pre>test146CountTestModules</pre><pre>test147CountLongModules</pre><pre>test148CountLongModules   "Count modules whose listing will exceed one page. "</pre><pre>test150gatherSources</pre><pre>test160LinesOfCode</pre><pre>test161LinesOfCodePerModule</pre><pre>test170FindToDoLines</pre><pre>test171FindCommentLines</pre><pre>test175FindAssertLines</pre><pre>test180listOnHTML</pre><pre>test182listOnHTML2Lines</pre><pre>test183listOnHTMLcomments</pre><h3>Hum-Tests -- HumFuzzyTests</h3><pre>testF100FuzzyArithmeticReadMe   "</pre><pre>testF110CreateFuzzyWithDistribution   "Create a fuzzy quantity from a given distribution."</pre><pre>testF112CheckEdgeCases   "Create a fuzzy quantity from a given distribution."</pre><pre>testF120Interpolation   "Create a fuzzy quantity from a given distribution."</pre><pre>testF125Mean   "Create a fuzzy quantity from a given distribution."</pre><pre>testF130Plus   "Add fuzzy distributions.</pre><pre>testF140Op   "Test op:with:"</pre><pre>testF150MinusOp   "Subtract fuzzy distributions."</pre><pre>testF155Minus   "Subtract fuzzy distributions."</pre><pre>testF160Division   "Divide fuzzy distributions."</pre><pre>testF170Product   "Multiply fuzzy distributions."</pre><pre>testF210PlusOrMinus   "A measure stated as plus-or-minus </pre><pre>testF230Plus   "Add fuzzy distributions."</pre><pre>testF310Mode   "Estimate the mode of a distribution by calculating expected value."</pre><pre>testF410Plot   "Estimate the mode of a distribution by calculating expected value."</pre><pre>testF430PlotPlus   "Add fuzzy distributions.</pre><pre>testF431PlotPlus   "Add fuzzy distributions.</pre><pre>ztestF410LearnToPlot   "Estimate the mode of a distribution by calculating expected value."</pre><h3>Hum-Tests -- HumOntologyTests</h3><pre>test001newOntology   "create a new Ontology"</pre><pre>test100nounTypes   "An entity noun will have attributes."</pre><pre>test102addOneNoun   "Add one noun to current set."</pre><pre>test103addTwoNouns   "Add two nouns to current set."</pre><pre>test104addArrayOfNouns   "Add array of nouns to current set."</pre><pre>test110addEntityAttribute   "Add an entity-attribute relation."</pre><pre>test111getAllAttributesOfNoun   "Add an is-A relation."</pre><pre>test120addSubtype   "Add an is-A relation."</pre><pre>test121automaticSubtype   "Add an is-A relation."</pre><pre>test122getAllSubtypesOfNoun   "Get all subtypes of a noun -- Use at run-time for polymorphism."</pre><pre>test123getImmediateSupertypesOfNoun   "Get immediate super types of a noun -- Use when translating to another language ."</pre><pre>test124getAllSupertypesOfNoun   "Get immediate super types of a noun -- Use when translating to another language ."</pre><pre>test130getSingularFormOfPluralNoun   "Return the singular form of a plural noun."</pre><pre>test220addOneRole   "Add one role to current set."</pre><pre>test230addTwoRoles   "Add two roles  to current set."</pre><pre>test310statementTokens   "A statement is made up of tokens."</pre><pre>test320statementEndsWithPeriodOrColon   "A statement must end with a period or a colon."</pre><pre>test330statementHasNouns   "A statement has nouns."</pre><pre>test340statementParsing   "The parser recognizes that tokens are nouns, punctuation, keywords, or just words."</pre><pre>test342statementParsingConsolidatesStrings   "A string is delimited by double quotes."</pre><pre>test350frameLineSeparateLabelStatementCommentAnnotation   "Generic frameline = ( indent ) ( label : ) ( statement '.' ) ( '(' comment ')' ) ( '[' annotation ']' )</pre><pre>test351frameLineParsingRemovesComments   "The parser recognizes that tokens are nouns, punctuation, keywords, or just words."</pre><pre>test353frameLineParsingSeparatesAnnotation   "The parser recognizes that tokens are nouns, punctuation, keywords, or just words."</pre><pre>test360statementMatchesPatternForEach   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "</pre><pre>test361statementMatchesPatternForEachInThe   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "</pre><pre>test362statementMatchesPatternIsA   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "</pre><pre>test363statementMatchesElse   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "</pre><pre>test364statementMatchesCategories   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "</pre><pre>test365statementMatchesCategoriesAnd   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "</pre><pre>test366statementMatchesAttributes   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "</pre><pre>test367statementMatchesAttributesAnd   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "</pre><pre>test410addOneAction   "An action belongs to a role."</pre><pre>test420actionInstructions   "An action statement is defined by a sequence of instructions."</pre><pre>test430createInstructionsInline   "Create instructions in-line using Class methods"</pre><pre>test440getRoleActionStatement   "An action belongs to a role."</pre><pre>test441matchActionStatementAgainstCandidate   "Retrieve statement object from ontology when given a similar string."</pre><pre>test442matchActionStatementPolymorphic   "Retrieve appropriate statement with supertype </pre><pre>test450instructionNounAntecedents   "Nouns in instructions should have antecedants in the action statement.</pre><pre>test461Frame4ActionCrossReferences   "Given: An action instruction delegates to another role (or same role).</pre><pre>test510CreatePlanFrame   "Make one plan frame. (TDD to drive basic parts)"</pre><pre>test520CheckPlanFrame   "A plan frame SHOULD have a goal and at least two preconditions.</pre><pre>test530AddPlanFrame   "Make one plan frame. (TDD to drive basic parts)"</pre><pre>test540GetPlanTree   "Make several plan frames. Get the resulting plan tree."</pre><pre>test545DrawPlanTree   "Make several plan frames. Get the resulting plan tree."</pre><pre>test550CheckPlanTree   "Check for an incomplete plan."</pre><pre>test610renderStatementAsHTML   "In the HTML rendering, statement nouns are enclosed in &lt;n&gt;...&lt;/n&gt; to enable style sheet rendering."</pre><pre>test611renderInstructionLines   "Create instructions in-line using Class methods"</pre><pre>test620renderFrame4PlanAsHTML   "The frame editor instance knows what kind of frame it is editing.</pre><pre>test625renderPlanTreeAsHTML   "Make several plan frames. Get the resulting plan tree."</pre><pre>test626renderNounTreeAsHTML   "Define a dictionary with more than one level. Render as a noun tree."</pre><pre>test630renderFrame4ActionAsHTML   "Given: The frame editor contains a role-action frame.</pre><pre>test640renderFrame4ViewAsHTML   "Given: The frame editor instance knows what kind of frame it is editing.</pre><pre>test641renderRadioButtonAsHTML   "Given: The frame editor instance knows what kind of frame it is editing.</pre><pre>test642renderCheckBoxAsHTML   "Given: The frame editor instance knows what kind of frame it is editing.</pre><pre>test643renderTextAsHTML   "Given: The frame editor instance knows what kind of frame it is editing.</pre><pre>test650renderFrame4DictionaryAsHTML   "The frame editor instance knows what kind of frame it is editing.</pre><pre>test680renderOntologyAsHTML   "Render an ontology object in HTML and store on given filename."</pre><pre>test690renderOntologyAsHTMLonFile   "Render an ontology object in HTML and store on given filename."</pre><pre>test900checkUsability   "Test the pattern matching.</pre><pre>test910lineMatchesPattern   "Test the pattern matching.</pre><pre>test911lineDoesNotMatchPattern   "Test the pattern matching.</pre><pre>test912lineMatchesFloatingPattern   "Test the pattern matching.</pre><pre>test913lineMatchesFloatingPattern   "Test the pattern matching.</pre><pre>test914lineMatchesFloatingPattern   "Test the pattern matching.</pre><pre>test915lineFailsFloatingPattern   "Test the pattern matching.</pre><pre>test920lineMatchesPatternParameters   "Test the pattern matching.</pre><pre>test922lineMatchesFloatingPatternParameters   "Test the pattern matching.</pre><pre>test923lineMatchesFloatingPatternParameters   "Test the pattern matching.</pre><pre>test930generateCode   "Generate some code that does not require that we find a singular noun.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests</h3><pre>assertExpectedTokensIn: expected matchesTokensIn: actual   "Compare the two strings as a stream of tokens.</pre><pre>bakeThePanInTheOvenForTheTimeGivenInTheRecipeQpan: aPan oven: aOven time: aTime recipe: aRecipe </pre><pre>fulfillOrderQorder: aOrder    "For each order-item in the order: "</pre><pre>test010AssertExpectedTokensInAMatchesTokensInB   "Test the utility with the cases that matter to me."</pre><pre>test110AttachMethodToClass   "Attach a method to a class."</pre><pre>test111GetMethodsForClass   "Attach a method and get it back."</pre><pre>test120AttachClassPrologue   "Attach prologue source lines to an actor class.</pre><pre>test370forStatementAsSmalltalk   "Translate for . . .    to Smalltalk"</pre><pre>test380ifStatementAsSmalltalk   "Translate if . . .   to  Smalltalk"</pre><pre>test381ifStatementAsSmalltalk   "Translate if . . .   to  Smalltalk"</pre><pre>test382ifStatementAsSmalltalk   "Translate if . . .   to  Smalltalk"</pre><pre>test383ifStatementAsSmalltalk   "Translate if . . .   to  Smalltalk"</pre><pre>test384ifStatementAsSmalltalk   "Translate if . . .   to  Smalltalk"</pre><pre>test385ifStatementAsSmalltalk   "Translate if . . .   to  Smalltalk"</pre><pre>test390elseStatementAsSmalltalk   "Translate if . . .  else . . .  to Smalltalk"</pre><pre>test710translateFrame4ActionToSmalltalk   "Given: a Hum action frame.</pre><pre>test720translateFrame4ActionToSmalltalk   "Given: a Hum action frame.</pre><pre>test730translateFrame4ActionToSmalltalkExdentToBlockEnd   "Given: a Hum action frame.</pre><pre>testE210translateActionHeaderToErlang   "Translate Hum action header to Erlang do pattern.</pre><pre>testE220translateActionCallToErlang   "Translate a Hum action call to an Erlang call."</pre><pre>testE230translateInstructionToErlang   "Translate Hum instruction (invoke) to Erlang do()."</pre><pre>testE310translatePlanFramesToErlang   "TODO: Decide how to do this.</pre><pre>testE311translatePreconditionsToErlangList   "Translate a plan-frame`s preconditions to an Erlang list.</pre><pre>testE400ReadMe</pre><pre>testE410translateEntityToErlang   "An entity is translated into an Erlang record structure.</pre><pre>testE500RoleReadMe   "Strategy: Each each role becomes an Erlang module."</pre><pre>testE510RoleModuleHeader   "A role becomes a module. Here we check the module declaration."</pre><pre>testE520RoleModuleHeaderExport   "A role becomes a module. Here we check the module header export declarations."</pre><pre>testE525RoleModuleHeaderMacros   "When a role delegates an action, a ?CALL macro is invoked. "</pre><pre>testE530RoleModuleActionFrames   "A role becomes a module. Here we check the module header export declarations."</pre><pre>testH110tranlateEmphasis   "*text* becomes bold, ~text~ becomes italic, _text_ becomes underline, ^text^ becomes superscript"</pre><pre>testH115tranlateEmphasisAtEnd   "*text* becomes bold, ~text~ becomes italic, _text_ becomes underline, ^text^ becomes superscript"</pre><pre>testH120tranlatePageWidget   "Translate [page:text] into HTML anchor element"</pre><pre>testH125tranlatePageWidgetAtEnd   "Translate [page:text] into HTML anchor element - test for bug when widget is at line end."</pre><pre>testH130tranlateLinkWidget   "Translate [link: text | URL ] into HTML anchor element"</pre><pre>testH140tranlateImageWidget   "Translate [link: text | URL ] into HTML anchor element"</pre><pre>testH210tranlateButtonWidget   "Translate [[label]] into HTML button element"</pre><pre>testH215tranlateButtonWidgetAtLineEnd   "Translate [[label]] into HTML button element -- Test for bug when widget is at end of line."</pre><pre>testH216tranlateButtonWidgetAtLineEnd   "Translate [[label]] into HTML button element -- Test for bug when widget is at end of line."</pre><pre>testH220tranlateCheckBox   "Translate [z] into HTML checkbox element."</pre><pre>testH230tranlateRadioButtons   "Translate (a) into HTML radio-button element."</pre><pre>testH310tranlateTableRow   "Translate | ... | ... | into table elements."</pre><pre>testH320tranlateTableRowWithEmphasis   "Translate | ... | ... | into table elements."</pre><pre>testH330tranlateHeading   "Translate !!! into HTML heading"</pre><pre>testH340tranlateHeadingWithEmphasis   "Translate !!! into HTML heading"</pre><pre>testH350tranlateListItem   "Translate !!! into HTML heading"</pre><pre>testH360tranlateListItemWithEmphasis   "Translate !!! into HTML heading"</pre><pre>testH410tranlateAttributeWidget   "Translate [attribute] into input tag."</pre><pre>testH420tranlateTextAreaWidget   "Translate [attribute 9] into textarea tag."</pre><pre>testH430tranlateEntityAttributeWidget   "Translate [entity`s attribute] into input tag."</pre><pre>testJ805translateStatementToCamelcase   "A statement is translated directly to CamelCase."</pre><pre>testJ806translateStatementToCamelcase   "A statement is translated directly to CamelCase, but articles are dropped."</pre><pre>testJ810translateFrame4ActionToJava   "Given: a Hum action frame.</pre><pre>testJ811translateFrame4ActionToJava   "Given: a Hum action frame with a hyphenated noun.</pre><pre>testJ820translateDictionaryToJava   "Entity becomes class. Attribute becomes String, Category, ..."</pre><pre>testJ825translateCollectionNounToJava   "Test a more complicated dictionary with a collection and recursive structure."</pre><pre>testJ830translateFrame4ActionToJavaExdentToBlockEnd   "Given: a Hum action frame.</pre><pre>testJ840translatePlanFrameToJava   "The plan is data, so translation involves translating each goal frame into a series of Java setters.</pre><h3>Hum-Tests -- HumProgrammersAssistantTests</h3><pre>aReadMe   "See the class description for the intended (future) tests."</pre><pre>storeInOntology: aHumOntology fromFrameUpdater: frameUpdater1</pre><pre>test110newOntology   "PA initializes (re-initializes) to an empty ontology."</pre><pre>test120saveOntology   "PA saves (writes) the ontology to a file."</pre><pre>test130loadOntology   "PA loads (reads) the ontology fram a file where it was saved previously."</pre><pre>test200createFrame   "There are seven types of frame: (See HumFrame hierarchy)</pre><pre>test220createFrame4Plan   "Test a plan frame (goal frame).</pre><pre>test230createFrame4Action   "The frame editor instance knows what kind of frame it is editing.</pre><pre>test231formatFrame4Action  "The frame editor instance knows what kind of frame it is editing.</pre><pre>test240createFrame4View   "The frame editor instance knows what kind of frame it is editing.</pre><pre>test250createFrame4Dictionary   "The frame editor instance knows what kind of frame it is editing.</pre><pre>test260createFrame4Vignette   "Create a dialog vignette..</pre><pre>test261updateFrame4Vignette   "Create a dialog vignette.</pre><pre>test270createFrame4Comment   "Create with a comment frame..</pre><pre>test300codeCriticFeatures   "The code critic generates errors and warnings for each type of frame."</pre><pre>test320critiqueFrame4Plan   "Check plan frame - no known nouns - no plans</pre><pre>test321critiqueFrame4Plan   "Detect: Every precondition has a noun that traces back to the goal statement.</pre><pre>test322critiqueFrame4PlanMissingAntecedant   "Detect: One or more preconditions have a noun with no antecedant in the goal statement.</pre><pre>test330critiqueFrame4Action   "Detect: No known nouns.</pre><pre>test331critiqueFrame4Action   "Detect: Some nouns, but still not enough.</pre><pre>test332critiqueFrame4ActionForAntecedants   "Detect: 'No known noun' and/or  'no antecedant'</pre><pre>test345critiqueFrame4View   "Detect: No nouns in a view frame.</pre><pre>test346critiqueFrame4View   "When the nouns are defined, there are no complaints. s</pre><pre>test350critiqueFrame4Dictionary   "Critique a dictionary frame.</pre><pre>test351critiqueFrame4Dictionary   "Critique a dictionary frame.</pre><pre>test361critiqueFrame4Vignette   "Critique a dialog vignette.</pre><pre>test421compileFrame4Plan   "In this context, 'compile' means that the plan frame is inserted into the ontology,</pre><pre>test431compileFrame4Action   "In this case, 'compile' means adding the frame to the ontology,</pre><pre>test446compileFrame4View   "Compile a view frame.</pre><pre>test450compileFrame4Dictionary   "In this context, </pre><pre>test461compileFrame4Vignette   "Compile a dialog vignette.</pre><pre>test510storeFrame   "Store the frame in the given ontology.</pre><pre>test520fetchFrameByID   "Store a dictionary frame and then get it back using its uniqueIdentifier.</pre><pre>test531fetchFrame4PlanByID   "Create a plan frame in editor; store it; get it back via its ID.</pre><pre>test532fetchFrame4PlanByTitle   "Create a plan frame in editor; store it; get it back via its title.</pre><pre>test540fetchFrame4DictionaryByID</pre><pre>test541fetchFrame4DictionaryByTitle   "Ontology will fetch a dictionary frame given its title."</pre><pre>test551fetchFrame4ActionByTitle   "The title of an action includes the role and the statement."</pre><pre>test561fetchFrame4ViewByTitle   "This should be easy."</pre><pre>test571fetchFrame4VignetteByTitle   "TODO: Think about how vignettes would be identified to users.</pre><pre>test620storeFrame4Plan   "Store plan frame.</pre><pre>test630storeFrame4Action   "Store an action frame.</pre><pre>test640storeFrame4View   "Store a view frame.</pre><pre>test650storeFrame4Dictionary   "Store a dictionary frame.</pre><pre>test660storeFrame4Vignette   "Store a dictionary frame.</pre><pre>test700parseSourceLineReadMe   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</pre><pre>test701parseInstructionLine   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</pre><pre>test702parseInstructionLineWithComment   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</pre><pre>test703parseInstructionLineWithString   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</pre><pre>test704parseInstructionLineWithTwoComments   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</pre><pre>test705parseActionLine   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</pre><pre>test706parseActionLineWithComment   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</pre><pre>test707parseActionLineWithAnnotation   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</pre><pre>test708parseActionLineWithCommentAndAnnotation   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</pre><pre>test710getLabel   "Some framelines have labels. Some don't."</pre><pre>test711parseDictionaryLine   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</pre><pre>test712parseDictionaryLineWithComment   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</pre><pre>test713parseDictionaryCategoriesLine   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"</pre><pre>test720getComment   "Some framelines have comments. Some don't."</pre><pre>test725noComment   "Some framelines have comments. Some don't."</pre><pre>test730getAnnotation   "Some framelines have annotations. Some don't."</pre><pre>test735noAnnotation   "Some framelines have annotations. Some don't."</pre><pre>test741getOneWidget   "Markup-line class includes own parser.  </pre><pre>test742getTwoWidgets   "Markup-line includes a parser."</pre><pre>test743getTwoWidgetsAndButton   "Markup-line includes a parser."</pre><pre>test751parseOneWidget   "Parse a markup-line containing a widget."</pre><pre>test752parseMultipleWidgets   "Parse a markup line containing multiple widgets."</pre><pre>test753parseRadioButtons   "Parse a line containing radio button widgets."</pre><pre>test754parseActionButton   "Parse a line containing an action button."</pre><pre>test755parseLinkWidget   "Parse a mark-up line with a link widget."</pre><pre>test760parseEmphasisMarkup   "Parse a mark-up line with emphasis markup."</pre><pre>test770parseHeadingMarkup   "Parse a mark-up line with emphasis markup."</pre><pre>test772parseBulletListMarkup   "Parse a mark-up line with bullet list markup."</pre><pre>test773parseNumberListMarkup   "Parse a mark-up line with emphasis markup."</pre><pre>test800LoadFileReadMe   "The Programmers Assistant may load and parse a text file.</pre><pre>test810FramesAreSeparatedByFrameDelimiter   "Frames are separated by lines beginning with ===.</pre><pre>test811StreamStartsWithFrameDelimiter   "Test where file starts with a frame-delimiter."</pre><pre>test812StreamEndsWithEndOfFile   "Test where frame ends on end-of-file"</pre><pre>test813StreamStartsWithFrameDelimiterEndsWithEOF   "Test where file starts with a frame-delimiter and ends on end-of-file."</pre><pre>test814StreamHasViewAndDictionaryFrames   "Load two frames: a view frame and a dictionary frame."</pre><pre>test815StreamHasViewDictionaryAndPlanFrame   "Load three frames: a view, a dictionary, and a plan frame."</pre><pre>test816StreamHasViewDictionaryPlanAndCommentFrames   "Load four frames: a view, a dictionary, a plan, and a comment frame."</pre><pre>test817StreamHasViewDictionaryPlanAndActionFrames   "Load four frames: a view, a dictionary, a plan, and an action frame."</pre><pre>test820StreamHasVignettes   "Test that vignettes are properly parsed, loaded, and indexed."</pre><pre>test830LoadActionFrame   "Load, parse, and render a slightly tricky action frame."</pre><pre>test910LoadFromTextFile   "Load from pizza-ontology.txt"</pre><pre>test912LoadDonutShop   "Load from pizza-ontology.txt"</pre><pre>test913LoadBarista   "Load from pizza-ontology.txt"</pre><pre>test914LoadClubMech   "Load from pizza-ontology.txt"</pre><pre>test920LoadFromTextFileAndRenderAsHTML   "Load from pizza-ontology.txt"</pre><pre>test922LoadDonutShopAndRenderAsHTML   "Load from some-ontology.txt"</pre><pre>test923LoadBaristaAndRenderAsHTML   "Load from some-ontology.txt"</pre><pre>test924LoadClubMechAndRenderAsHTML   "Load from some-ontology.txt"</pre><pre>test925LoadClubMechAndRenderAsHTMLwithCritique   "Load from some-ontology.txt"</pre><pre>test926LoadDonutShopAndRenderAsHTMLwithCritique   "Load from some-ontology.txt"</pre><pre>test927LoadBaseOntologyAndRenderAsHTMLwithCritique   "Load from some-ontology.txt"</pre><pre>test928LoadVROntologyAndRenderAsHTMLwithCritique   "Load from some-ontology.txt"</pre><pre>test929LoadMarkupViewAndRenderAsHTMLwithCritique   "Load from some-ontology.txt"</pre><pre>test930LoadToDoListAndRenderAsHTMLwithCritique   "Load from some-ontology.txt"</pre><pre>test931LoadBootStrapOntologyAndRenderAsHTMLwithCritique   "Load from some-ontology.txt"</pre><pre>test944LoadClubMechSaveReload   "Load from some-ontology.txt, save it, reload it."</pre><pre>test945LoadDonutShopSaveReload   "Load from some-ontology.txt, save it, reload it."</pre><pre>test954LoadClubMechSaveReload   "Load from some-ontology.txt, save it, reload it."</pre><pre>test971CreateNounTreeGraph   "Create a graph of the base ontology noun tree."</pre><pre>testU000UserInitiatedEvents"Plan for user-initiated events."</pre><pre>testU100KeyBoardEvents"KeyboardEvents:</pre><pre>testU200NewRelationEvents"NewRelationEvents:</pre><pre>testU300RenameEvents"RenameEvents:</pre><pre>text930expected   ^'&lt;html&gt;</pre><h3>Hum-Tests -- HumRunTimeTests</h3><pre>aReadMe   "See the class description for the intended (future) tests."</pre><pre>expect: actualValue is: expectedValue    ""</pre><pre>expected:  expectedValue actual: actualValue    ""</pre><pre>setUp   "This setup is used by many run-time tests. </pre><pre>setUpKnockKnockOnOntology: anOntology</pre><pre>tearDown   "Transcript cr; show: 'completed: ', (testSelector asString)."</pre><pre>test000ApplicationConfigurationReadMe   "An application has a run-time configuration."</pre><pre>test005ApplicationConfigurationSetup   "This setup is used by several tests. "</pre><pre>test100ActorReadMe   "</pre><pre>test100ReadMe   "Network is a wrapper on whatever technology is used to communicate between Actors."</pre><pre>test105actorConfiguration   "A Hum Actor is configured with the address of a messenger node.</pre><pre>test110workerChecksIn   "Worker checks-in, announcing roles."</pre><pre>test120workerCheckInMessage   "Worker checks-in, announcing roles."</pre><pre>test130workerChecksInViaMessenger   "Worker checks-in, announcing roles."</pre><pre>test135workerChecksOutViaMessenger   "Worker checks-in, announcing roles."</pre><pre>test200DispatcherReadMe"The Dispatcher (RM) - assigns tasks to actors.</pre><pre>test210DispatcherAssignsAction   "Some actor delegates a task to a role.</pre><pre>test300CoordinatorReadMe"Coordinator - controls execution of plans and dialogs.</pre><pre>test310coordinatorRunsPlan   "Dialog:</pre><pre>test320coordinatorInvokesAction   "Goal: Plan has one frame with no preconditions.</pre><pre>test330twoPlanFrames   "Test with two plan frames.</pre><pre>test340planTreeBranches   "Test a plan tree with several levels and significant branching.</pre><pre>test400BookkeeperReadMe   "A Bookkeeper tracks resource utilization.</pre><pre>test410BookkeeperRecordsJobTickets   "If we ask the bookkeeper to 'run' a jobTicket, it stores it in its jobTickets collection.'"</pre><pre>test420BookkeeperSums   "The bookkeeper tracks utilization of an actor by action, actor, role, job.</pre><pre>test600WorldBaseReadMe   "</pre><pre>test610CreateWorldBaseInstance   "Create an instance of a Hum World Base (a database to be shared by multiple actors)."</pre><pre>test615CreateUniqueIdentifier   "Create an instance of a Hum World Base (a database to be shared by multiple actors)."</pre><pre>test616CreateUniqueIdentifierDoesNotBreak   "Create an instance of a Hum World Base (a database to be shared by multiple actors)."</pre><pre>test620setAndGet   "set entity-attribute value"</pre><pre>test630setGetReplace   "set entity-attribute value"</pre><pre>test640FindWhere   "set entity-attribute value"</pre><pre>test700BlackBoardReadMe   "</pre><pre>test710setAndGet   "set entity-attribute value"</pre><pre>test720setGetReplace   "Update entity-attribute value"</pre><pre>test730clearEntity   "Update entity-attribute value"</pre><pre>test800DialogAgentReadMe   "</pre><pre>test810createSimpleVignette   "Create a vignette frame."</pre><pre>test820createDialogAgent   "Create a dialog agent."</pre><pre>test825DialogAgentHasScribe   "When a dialog agent is activated, a Scribe is already present."</pre><pre>test830dialogAgentMatchesInputToVignette   "Pattern 'Hello *.' matches 'Hello.'.</pre><pre>test832dialogAgentMatchesInputToVignette2   "Pattern 'Hello *.' matches 'Hello Ms. Robot.'</pre><pre>test833dialogAgentMatchesInputToVignette3   "Pattern ('Hello *.' 'Hi *.') matches 'Hi there.'.</pre><pre>test834dialogAgentMatchesInputWithAlternatePunctuations   "Pattern ('Hello *.' 'Hi *.' 'Hi *!' 'Hello * ?') matches 'Hi there.'.</pre><pre>test840dialogAgentSorry   "Stimulus 'Help' returns 'Sorry ...'</pre><pre>test850dialogAgentMatchesInputWithAlternatePunctuations   "Pattern ('Hello *.' 'Hi *.') matches 'Hi!'.</pre><pre>test860dialogAgentMatchesInputWithNounSlot   "Pattern ('My name is [full-name].') matches 'My name is Tessie Tester.'.</pre><pre>testM110MessengerRemembersActors</pre><pre>testM120MessageAttributes   "The components of a message include sender, receiver, when sent, statement, and noun-values. "</pre><pre>testS100ScribeReadMe   "These Scribe tests generally involve a Scribe that is independent of Seaside.</pre><pre>testS110SetupScribe   "A scribe is attached to a dialogAgent Agent.</pre><pre>testS131ScribeHandlesHttpPostRequest   "Scribe: Captures data from Http Response and returns data to Dialog Agent in task-completion message. "</pre><pre>testS132ScribeHandlesViewReturn   "Scribe: Captures data from Http Response and returns data to Dialog Agent in task-completion message. "</pre><pre>testS134ScribeMocksViewDataEntry   "Scribe: Captures data from Http Response and returns data to Dialog Agent in task-completion message. "</pre><pre>testV100ReadMe   "Test HumVector - which is a subclass of FloatArray"</pre><pre>testV105GetPutXYZ   "Test HumVector - which is a subclass of HumMeasure"</pre><pre>testV110TestVplusV   "Test HumVector - which is a subclass of . . ."</pre><pre>testV120TestVminusV   "Test HumVector - which is a subclass of . . ."</pre><pre>testV130TestVdotV   "Test HumVector - which is a subclass of . . ."</pre><pre>testV140TestVcrossV   "Test HumVector - which is a subclass of . . ."</pre><pre>testV150TestVtimesScalar   "Test HumVector - which is a subclass of . . ."</pre><pre>testV160TestVdividedByScalar   "Test HumVector - which is a subclass of . . ."</pre><h3>Hum-Tests -- HumSeasideProgrammersAssistantTests</h3><pre>aReadMe   "</pre><pre>test110newOntology   "Browser initializes (re-initializes) to an empty ontology."</pre><pre>test121loadOntologyInstance   "Browser saves (writes) the ontology to a file."</pre><pre>test130saveOntology   "Browser saves (writes) the ontology to a file."</pre><pre>test222OpenOntologyInstance   "Test the dialog that asks the user for the file name."</pre><h3>Hum-Tests -- HumSeasideUserInterfaceTests</h3><pre>checkGeneratedCode   "This is a place to see if generated code will compile."</pre><pre>setUpViewFrameInOntology: aHumOntology   "Generate a view frame and dictionary entries for several tests.</pre><pre>test310ViewBecomesForm   "A Hum view frame is rendered as a Seaside Form.</pre><pre>test311ViewHasMultipleLines   "A Hum view frame is rendered as a Seaside Form.</pre><pre>test312ViewHeader   "A Hum view frame is rendered as a Seaside Form.</pre><pre>test313ViewField   "A Hum view frame is rendered as a Seaside Form.</pre><pre>test314CheckGeneratedCode   "This is a place to see if generated code will compile and run."</pre><h3>Hum-Tests -- HumSeasideWidgetTests</h3><pre>setUpViewFrameInOntology: aHumOntology   "Generate a view frame and dictionary entries for several tests.</pre><pre>test010GivenWhenThen   "Test the test frame"</pre><pre>test011GivenWhenThenFail   "Dry test the test frame"</pre><pre>test100BasicWiring   "A Hum view frame is rendered as a Seaside Form."</pre><pre>test102BasicWiring2   "A Hum view frame is rendered as a Seaside Form."</pre><pre>test105BindWidgetToBlackboard   "A widget may be bound to blackboard"</pre><pre>test107BindWidgetToCategory   "A widget may be bound to blackboard"</pre><pre>test110ViewHasViewTag   "A Hum view frame is rendered as a Seaside Form.   "</pre><pre>test120ViewHasFormTag   "A Hum view frame is rendered as a Seaside Form.   "</pre><pre>test130ViewHasMarkupLines   "A Hum view frame is rendered as a Seaside Form ...</pre><pre>test132ViewHasHeadingLine   "A Hum view frame is rendered as a Seaside Form ...</pre><pre>test134ViewHasStringWidget   "A Hum view frame is rendered as a Seaside Form ...</pre><pre>test135ViewUptoWidget   "A Hum view frame is rendered as a Seaside Form ...</pre><pre>test136ViewHasTextWidget   "A Hum view frame is rendered as a Seaside Form ...</pre><pre>test138ViewHasDateWidget   "A Hum view frame is rendered as a Seaside Form ...</pre><pre>test139ViewHasCategoryWidget   "A Hum view frame is rendered as a Seaside Form ...</pre><pre>test140ViewHasMeasureWidget   "A Hum view frame is rendered as a Seaside Form ...</pre><pre>test150ViewLineHasSeveralWidgets   "A Hum view frame is rendered as a Seaside Form ...</pre><h3>Hum-Tests -- HumSimulatorTests</h3><pre>aDesignNoteEventQueue   "The Simulator provides the means for 'regression testing'.</pre><pre>setUpBasicConfigurationOn: aHumSimulator </pre><pre>setUpDogAndPonyConfigurationOn: aHumSimulator </pre><pre>setUpDogAndPonyOntology   "When this ontology runs,</pre><pre>setUpHotelOntology</pre><pre>setUpKnockKnockOnOntology: anOntology</pre><pre>testX100SimulatorReadMe   "The Simulator provides the means for 'regression testing'.</pre><pre>testX101RepresentDialogSequence   "Simulations 'load' the system under test by starting dialog sequences </pre><pre>testX102RepresentRandomIntervals   "Simulations 'load' the system under test by starting dialog sequences </pre><pre>testX103RepresentNumberOfDialogs   "Simulations 'load' the system under test by starting dialog sequences </pre><pre>testX110AddEventToQueue   "A simulation loads client speech-acts into a queue with a specified delay.</pre><pre>testX112AddTwoEventsToQueue   "A simulation loads client speech-acts into a queue with a specified delay.</pre><pre>testX120Step   "A simulation loads client speech-acts into a queue with a specified delay.</pre><pre>testX122StepStep   "A simulation loads client speech-acts into a queue with a specified delay.</pre><pre>testX124StepUntilDone   "A simulation loads client speech-acts into a queue with a specified delay.</pre><pre>testX130DialogUsesScribe   "There should be a Scribe in the chain.</pre><pre>testX140VignetteTriggersGoal   "A vignette may trigger a goal."</pre><pre>testX142RunClubMech   "A vignette may trigger a goal."</pre><pre>testX143RunBarista   "A vignette may trigger a goal."</pre><pre>testX144RunDonutShop   "A vignette may trigger a goal."</pre><pre>testX150RunParallel   "A vignette may trigger a goal."</pre><h3>Hum-Tests -- HumTestCase</h3><pre>assert: stringA sameAs: stringB </pre><pre>assertPattern: stringPattern matches: string </pre><pre>ensure   "I think this belongs under HClientServerTests"</pre><pre>ensureBlock: aBlock   "I think this belongs under HClientServerTests"</pre><pre>eventSeen   ^ eventSeen ifNil: [ eventSeen := 'No value was preset.' ]</pre><pre>eventSeen: anObject    "Set my one-shot memory of the last event seen."</pre><pre>expect: expectedValue actual: actualValue </pre><pre>expect: expectedValue actual: actualValue description: aDescription </pre><pre>pattern: stringPattern matches: string </pre><pre>signal   "I think method this belongs under HClientServerTests"</pre><pre>update: anObject   "This is called by event handler."</pre><h3>Hum-Tests -- HumTextEditorTests</h3><pre>test110ArrowKeys</pre><pre>test120NormalKeys</pre><pre>test130BreakLine</pre><pre>test140DeleteKey   "If cursor column &gt; 1, delete character to the left of cursor and decrement column position."</pre><pre>test150DeleteLine   "If cursor column = 1, append current line to prior line and move remaining lines up."</pre><pre>test208CharacterizeStringDraw   "Tinker until we learn what we need to know about canvas, form, font integration."</pre><pre>test209CharacterizeStringDraw   "Tinker until we learn what we need to know about canvas, form, font integration."</pre><pre>test226DrawSeveralTextLinesOnPane   "TextEditor draws its lines on a HumPane -- ???"</pre><h3>Hum-Tests -- HumUserInterfaceTests</h3><pre>aReadMe   "See the class description for the intended (future) tests."</pre><pre>aReadMe2"</pre><pre>aReadMe3^'</pre><pre>aReadMe4^'Test Driven Design       (Decide if the following cascade makes sense.)</pre><pre>assert: x equals: a or: b</pre><pre>buildAvatar   "Create example to indicate development idea/s."</pre><pre>buildTrailerAssembly   "Build trailer - to be used in other tests."</pre><pre>buildTrailerNoseCurve   "Return curve of #(x y) where x = 0 is front-most point, y is offset from centerline"</pre><pre>buildTrailerScene   "Build trailer scene - to be used in other tests."</pre><pre>checkViewPortMorph   ^ checkViewPortMorph ifNil: [ checkViewPortMorph := false ].</pre><pre>checkViewPortMorph: aBoolean</pre><pre>expect: actualValue is: expectedValue    "syntax sugar"</pre><pre>for: someExpression expect: someResult</pre><pre>lastChange   ^ lastChange </pre><pre>showViewPort: aHumViewPort </pre><pre>test110surfaceHasOrigin   "A surface is initialized with a origin object which is zerosized and at 0,0."</pre><pre>test120surfaceSizeIsDurable   "A surface is initialized with a origin object which is zero-sized and at 0,0."</pre><pre>test130surfaceLayers   "An Surface Assembly has multiple shapes in one or more layers ."</pre><pre>test135surfaceBoundingBox   "An pane has a bounding box determined by the min/max of its collection of shapes."</pre><pre>test140surfaceLayout   "A surface is initialized with a origin shape which is zero-sized and at 0,0."</pre><pre>test150surfaceLayoutForPA   "Test for API usability -- Consider a layout like the PA."</pre><pre>test210boxHasOrigin   "A box is initialized with a origin object which is zero-sized and at 0,0."</pre><pre>test210surfaceAsSVG   "Test for usability -- Consider a layout like the PA."</pre><pre>test220boxSizeIsDurable   "When we move an edge, the width, height, and length are not affected."</pre><pre>test220surfaceAsSvgViewBox   "Test for usability -- Consider a layout like the PA."</pre><pre>test230boxIsAContainer   "HumAssembly (subtype of HumBox) may contain other boxes/spaces. "</pre><pre>test240boxLayout   "We can position boxes using absolute position values and relative positions."</pre><pre>test250boxCentering   "Center one box on top of another."</pre><pre>test255surfaceAssemblyAsSVG   "Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."</pre><pre>test260surfaceAssemblyAsSvgPercent   "Test for usability -- Consider a layout like the PA."</pre><pre>test270surfaceAssemblyAsSvgInch   "Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."</pre><pre>test310spaceHasOrigin   "A space is initialized with a origin object which is zero-sized and at 0,0."</pre><pre>test310surfaceAsXML   "First principle: Express a hum surface as XML.</pre><pre>test320spaceSizeIsDurable   "When an edge is moved, the opposite edge is also moved."</pre><pre>test320surfaceAssemblyAsXML   "Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."</pre><pre>test330spaceContainer   "We can specify a box position in terms of its centroid."</pre><pre>test340spaceLayout   "HumAssembly may position its parts relative to itself and each other."</pre><pre>test350assemblyDimensions   "A HumAssembly dimensions enclose whatever is inside the assembly"</pre><pre>test410surfaceAsHTML   "Test for usability -- Consider a layout like the PA."</pre><pre>test470surfaceAssemblyAsHTML   "Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."</pre><pre>test510surfaceAsHumScript   "Test first principle: Produce a Hum action call.</pre><pre>test570surfaceAssemblyAsHumScript   "Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."</pre><pre>testA110addPart   "Add a part to an assembly. Check content and event handling"</pre><pre>testA210assembleAvatar   "Create example to indicate development idea/s."</pre><pre>testA220colorAvatar   "Create example to indicate development idea/s."</pre><pre>testA410x3dAssembly   "render the objects in HumAssembly"</pre><pre>testA420trailerExample   "Test DSL usability - No code is generated by this test."</pre><pre>testA425trailerExample2   "Test DSL usability -- change #depth to #length -- No code is generated."</pre><pre>testA430showTrailerLayoutTable   "Display a table of the trailer parts edges.</pre><pre>testA530assemblyAsThreeJS   "Render a box as a ThreeJS cube"</pre><pre>testA540sceneAsThreeJS   "Render a box as a ThreeJS cube"</pre><pre>testA550sceneAsThreeJSinHTML   "Render a box as a ThreeJS cube"</pre><pre>testA600VPythonReadMe   "I started this when my VPython environment started working again.</pre><pre>testA625VPythonTrailer</pre><pre>testC210CreateHumCanvas   "HumCanvas provides a wrapper on actual implementation."</pre><pre>testC211CreateHumCanvas   "HumCanvas provides a wrapper on actual implementation."</pre><pre>testC220DrawRawPolygon   "HumCanvas provides a wrapper on actual implementation."</pre><pre>testC222DrawHumPolygon   "HumCanvas provides a wrapper on actual implementation."</pre><pre>testD110CreateDiagram   "Create a diagram with three nodes and two connections."</pre><pre>testD210LayoutDiagram   "Create a diagram with three nodes and two connections."</pre><pre>testD220LayoutDiagram   "Create a diagram with four nodes and three connections."</pre><pre>testD230LayoutDiagram   "Create a diagram with five nodes and four connections."</pre><pre>testD310DistanceBetweenNodes   "Calculate the (layout) distance between two nodes."</pre><pre>testD321EnergyBetweenNodes   "Calculate the (layout) force between two nodes."</pre><pre>testE110EditorPosition   "The editor owns a (cursor) position."</pre><pre>testE120EditorInsertCharacterAtEndOfLine   "When we insert a character, the cursor advances and the character is in the text string."</pre><pre>testE121EditorInsertCharacterAtFrontOfLine   "When we insert a character, the cursor advances and the character is in the text string."</pre><pre>testE130EditorInsertLine   "When we insert a line, the cursor advances to the beginning of the new line."</pre><pre>testE131EditorInsertTwoLines   "When we insert a line, the cursor advances to the beginning of the new line."</pre><pre>testE140EditorDeleteCharacterAtEndOfLine   "When we delete a character, the cursor decrements </pre><pre>testE141EditorDeleteCharacterAtStartOfLine   "When we delete a character, the cursor decrements </pre><pre>testE142EditorIgnoresDeleteWhenCursorAtStartOfLine   "When we delete a character, the cursor decrements </pre><pre>testE143EditorDeleteCharactersWillNotBackOverBeginningOfLine   "When we delete a character, the cursor decrements </pre><pre>testE210InterpretArrowKeys   "The arrow keys move the cursor and forget the selection.</pre><pre>testE220InterpretAltArrowKeys   "The arrow keys move the cursor and forget the selection.</pre><pre>testE230InterpretShiftArrowKeys   "The shift arrow keys move the cursor and update the selection.</pre><pre>testE310EditorSupportsUnDo   "Editor supports multiple levels of undo."</pre><pre>testE315EditorSupportsUnDoAtBottom   "Editor supports multiple levels of undo - tolerates too many pops."</pre><pre>testE320EditorSupportsReDo   "Editor supports multiple levels of undo and redo."</pre><pre>testE325EditorSupportsReDoToBottom   "Editor supports multiple levels of undo and redo."</pre><pre>testS110boxFacesAsPolygons</pre><pre>testS120boxVolumeMassWeight</pre><pre>testS200x3dReadMe   "   TODO: X3D is my preferred target language for 3D visualization.</pre><pre>testS210x3dColor   "HumSolid x3dColor should produce a X3D color string"</pre><pre>testS220x3dExtent   "Produce a x3d box extent from my length width height"</pre><pre>testS230x3dCenter      "Produce a x3d box position from my length width height (and default position)"</pre><pre>testS310x3dMaterial   "HumSolid x3dMaterial should produce a X3D xml string"</pre><pre>testS320x3dShape   "Produce a x3d box extent from my length width height"</pre><pre>testS330changed   "#changed is propagated to parent, dependents."</pre><pre>testS500ThreeJSReadMe   "The advantage of ThreeJS is that it runs WebGL in a relatively straight-forward manner.</pre><pre>testS505ThreeJSColor   "HumSolid three.js needs HTML color string"</pre><pre>testS520ThreeJSBox   "Produce a Three.js cube with my length width height and position"</pre><pre>testS610VPythonThing   "Produce a VPython Thing.py box with my length width height and position"</pre><pre>testS615VPythonSpace   "Produce a VPython Thing.py box with my length width height and position, but not visible"</pre><pre>testS620VPythonPreamble   "Produce a general purpose VPython scene preamble "</pre><pre>testT110initialTextHasOneEmptyLine   "When it is initialized, there is one empty line.</pre><pre>testT115initialTextCopyHasOneEmptyLine   "When it is initialized, there is one empty line.</pre><pre>testT210TurtleCreation   "Create a new turtle and check initial state."</pre><pre>testT220TurtleHeading   "Test methods that change the heading."</pre><pre>testT230TurtleStepping   "Test methods that change the heading."</pre><pre>testT240TurtleSpeeding   "Test methods that change the heading."</pre><pre>testV100ReadMe   "The current viewport uses low-level graphics functions rather than Morph. </pre><pre>testV105CreateCamera   "The camera is modeled by a pin-hole box camera."</pre><pre>testV110PositionCameraFacingBillboard   "The default/initial viewport frustrum is laid directly onto the surface.</pre><pre>testV115PanCameraUpDownLeftRight   "Move the camera in the scene to effect pan motion."</pre><pre>testV116CameraRotateSlideForward   "Move the camera in the scene to effect pan motion."</pre><pre>testV117CameraRotateSlideSideways   "Move the camera in the scene to effect pan motion."</pre><pre>testV118CameraRotateSlideUpDown   "Move the camera in the scene to effect pan motion."</pre><pre>testV120MapPointsFromSceneToViewport   "In an orthographic projection, </pre><pre>testV200ReadMe   "This group characterizes the low level drawing infrastructure </pre><pre>testV300checkViewPortMorph   "This group characterizes the low level drawing infrastructure </pre><pre>testV310ConnectViewPortToHumCanvas   "HumCanvas provides a wrapper on actual implementation."</pre><pre>testV320DrawPolygonOnBillboard   "Draw a 2D polygon on the viewport canvas."</pre><pre>testV330DrawABox   "Draw a 3D box on the viewport - use perspective projection."</pre><pre>testV331PaintABox   "Draw a 3D box on the viewport - use perspective projection."</pre><pre>testV332PaintAPyramid   "Draw a 3D box on the viewport - use perspective projection."</pre><pre>testV333PaintARotation   "Draw a 3D box on the viewport - use perspective projection."</pre><pre>testV334PaintACylinder   "Draw a 3D box on the viewport - use perspective projection."</pre><pre>testV334PaintAnElipsoid   "Draw a 3D box on the viewport - use perspective projection."</pre><pre>testV335PaintAThing   "Draw a 3D thing on the viewport - use perspective projection."</pre><pre>testV335PaintATorus   "Draw a 3D thing on the viewport - use perspective projection."</pre><pre>testV335PaintExtrusion   "Draw a 3D thing on the viewport - use perspective projection."</pre><pre>testV336DrawAThing   "Draw a 3D thing on the viewport - use perspective projection."</pre><pre>testV336WireframeATorus   "Draw a 3D thing on the viewport - use perspective projection."</pre><pre>testV337DrawAThingWireFrame   "Draw a 3D box on the viewport - use perspective projection."</pre><pre>testV338DrawABoxAsTriangles   "Draw a 3D box on the viewport - use perspective projection."</pre><pre>testV345DrawASolidRotated   "Draw a 3D box on the viewport - use perspective projection."</pre><pre>testV346DrawASolidTilted   "Draw a 3D box on the viewport - use perspective projection."</pre><pre>testV347DrawASolidRotatedAndTilted   "Draw a 3D box on the viewport - use perspective projection."</pre><pre>testV350paintAvatar</pre><pre>testW100ReadMe   "Hum Widgets are wrappers on various presentation layer technologies.</pre><pre>testW110LayoutContainsOtherWidgets   "A layout widget contains one or more other widgets."</pre><pre>testW120RowLayout   "A row layout arranges child widgets in a row."</pre><pre>testW130ColumnLayout   "A column layout arranges child widgets in a column."</pre><pre>testW220RowLayoutHTML   "A row layout arranges child widgets in a row."</pre><pre>testW230ColumnLayoutHTML   "A row layout arranges child widgets in a row."</pre><pre>testW320RowLayoutAsMorph   "A row layout arranges child widgets in a row."</pre><pre>testW330ColumnLayoutAsMorph   "A row layout arranges child widgets in a row."</pre><pre>update: someObject   "Record fact that someObject was updated by a test.</pre><h3>Hum-Tests -- HumVRTests</h3><pre>test100CreateVRwith2scenes   "A virtual reality has one or more scenes."</pre><h3>Hum-UI -- HumAssembly</h3><pre>addPart: aHumBox   "Add the component to my parts list"</pre><pre>addParts: aCollection   "Add the component to my parts list"</pre><pre>advance: aBox by: anArray    "Move the box by the given increments.</pre><pre>asPolygons   "Return polygons for my parts."</pre><pre>asPolygonsColorCoded   "Return polygons for my parts."</pre><pre>asThreeJS   "render the parts contained in this assembly"</pre><pre>asVPython   "Render my parts via Visual Python Things"</pre><pre>asX3D   "Return a string representing this assembly as a X3D element and scene.</pre><pre>bbBottomEdge   "Find my bounding box edge."</pre><pre>bbDepth   "Depth is another name for length."</pre><pre>bbEastEdge   "Find my bounding box edge."</pre><pre>bbHeight   "height of my bounding box"</pre><pre>bbLength   "length of my bounding box"</pre><pre>bbNorthEdge   "Find my bounding box edge."</pre><pre>bbSouthEdge   "Find my bounding box edge."</pre><pre>bbTopEdge   "Find my bounding box edge."</pre><pre>bbWestEdge   "Find my bounding box edge."</pre><pre>bbWidth   "width of my bounding box"</pre><pre>center: aHumBox above: aHumBox2    "synonym"</pre><pre>center: aBox at: a3Vector    "Center the part (aBox) at the given coordinates. { east. north. up. }</pre><pre>center: boxB below: boxA   "Center boxB over boxA"</pre><pre>center: boxB eastOf: boxA   "Center boxB over boxA"</pre><pre>center: boxB northOf: boxA   "Center boxB over boxA"</pre><pre>center: boxB onTopOf: boxA   "Center boxB over boxA"</pre><pre>center: aHumBox over: aHumBox2    "synonym"</pre><pre>center: boxB southOf: boxA   "Center boxB over boxA"</pre><pre>center: boxB westOf: boxA   "Center boxB over boxA"</pre><pre>changed</pre><pre>exploded   "Explode assemblies so that all the parts of parts become visible."</pre><pre>parts   ^ parts ifNil: [ parts := Set new ].</pre><pre>position: boxA above: boxB   "synonym"</pre><pre>position: boxA below: boxB   "synonym"</pre><pre>position: boxA eastOf: boxB   "Position A on East edge of B."</pre><pre>position: boxA northOf: boxB   "Position A on North edge of B."</pre><pre>position: boxA onBottomOf: boxB   "Position A on bottom of B."</pre><pre>position: boxA onTopOf: boxB   "Position A on top of B."</pre><pre>position: boxA over: boxB   "synonym"</pre><pre>position: boxA southOf: boxB   "Position A on South edge of B."</pre><pre>position: boxA under: boxB   "synonym"</pre><pre>position: boxA westOf: boxB   "Position A on West edge of B."</pre><pre>update:  anObject    "TBD"</pre><pre>update: anAspect with: anObject    "TBD"</pre><pre>x3DOM   "TODO: Generate HTML to enable X3DOM viewing in Browser."</pre><pre>x3dBackground   "Provide (default) X3D background element (skybox)"</pre><pre>x3dBoilerPlate   "Provide boilerplate attributes for X3D element"</pre><pre>x3dObjects   "Render each of the objects in my collection"</pre><pre>x3dScene   "Return a string representing this assembly as a X3D scene.</pre><pre>zcenter: aBox at: anArray    "Center the part (aBox) at the given coordinates. { east. north. up. }</pre><pre>zcenter: boxB onTopOf: boxA   "Center boxB over boxA"</pre><h3>Hum-UI -- HumBox</h3><pre>aboutEdges   ^'WARNING: The set/get methods for edges assume a default orientation.'.</pre><pre>addPolygon: aHumPolygon </pre><pre>asCamelCase   "Return identifier as a camelcase string."</pre><pre>asMeasure: aQuantity   "Convert string/number/measure to a measure. (default unit is meter)"</pre><pre>asThreeJS   "Render this as a box in Three.js"</pre><pre>asX3D   "Return a string in X3D notation representing this box / thing.</pre><pre>bottomEdge   ^ bottomEdge</pre><pre>bottomEdge: aQuantity   "WARNING: Assumes the box has default orientation."</pre><pre>center   "Center of box (and/or center of bounding box) -- { x y z } = { east north up }"</pre><pre>centerAt: a3Vector    "Center myself at the given coordinates. { east. north. up. }</pre><pre>centerX   "X axis points East"</pre><pre>centerY   "Y dimension points North"</pre><pre>centerZ   "Z dimension points up."</pre><pre>changed   "Notify my rendering engine that I am changed."</pre><pre>depth  "synonym"</pre><pre>depth: aHumMeasure    "synonym"</pre><pre>eastEdge   ^ eastEdge</pre><pre>eastEdge: aQuantity</pre><pre>equationOfMotion   "The equation-of-motion should be a block with args: box and time"</pre><pre>equationOfMotion: fcSelfAndTime   "The equation-of-motion should be a block with args: box and time"</pre><pre>exploded   ^{ self }.</pre><pre>height   "Get the height. By convention, height runs up and down."</pre><pre>height: aQuantity   "Reset the up-down dimension."</pre><pre>id   "Identifier used in rendering context"</pre><pre>id: aString   "Identifier used in rendering contexts"</pre><pre>id: aString height: aHeight width: aWidth depth: aDepth    "synonym"</pre><pre>id: aString height: aHeight width: aWidth length: aLength </pre><pre>initialize   "Set dimensions to zero."</pre><pre>jump: aTime</pre><pre>length   "Get the length. By convention, length runs North and South."</pre><pre>length: aQuantity   "set North-South dimension"</pre><pre>mm: aMeasure   "Format this measure to 3 digits accuracy - i.e. millimeter accuracy"</pre><pre>mmShave: aMeasure   "Format this measure to 3 digits accuracy - i.e. millimeter accuracy.</pre><pre>nextColor    "Select from a sequence of colors. Enables reproducable result."</pre><pre>northEdge   ^ northEdge</pre><pre>northEdge: aQuantity</pre><pre>origin   "Origin is always a zero-sized object at (0 0 0)."</pre><pre>polygons   "TODO: DANGER -- asPolygons is not defined in this supertype."</pre><pre>polygons: aCollection    "Computed polygons *may* be stored here."</pre><pre>printOn: aStream   "Append to the argument, aStream, a sequence of characters that  </pre><pre>rSquared   "How far am I from the origin? Use R-squared of my centroid as metric."</pre><pre>resetColoring</pre><pre>rotateLeft: angleInDegrees   "Set rotation (yaw) in scene coordinates - Note: This is not additive."</pre><pre>rotatePolygons: inputPolygons    "Correct the polygons for my rotation (yaw)."</pre><pre>rotateRight: angleInDegrees   "Set rotation (yaw) in scene coordinates - Note: This is not additive."</pre><pre>rotation   "Get my rotation (yaw) in scene coordinates as a value expressed in radians "</pre><pre>rotation: angle   "Set my rotation (yaw) in scene coordinates as a value expressed in radians "</pre><pre>rotationDegrees: angle   "Set my rotation (yaw) angle in scene coordinates. "</pre><pre>slideBackward: aHumMeasure    "Slide in the South direction - TODO: adjust for camera rotation."</pre><pre>slideDown: aHumMeasure    "Move box (e.g. camera) up or down in the scene coordinates."</pre><pre>slideForward: aHumMeasure    "Slide in the North direction - TODO: adjust for camera rotation."</pre><pre>slideLeft: aHumMeasure    ^self slideRight: (aHumMeasure negated).</pre><pre>slideRight: aHumMeasure    "Move camera left or right --- TODO: Correct this for camera orientation."</pre><pre>slideUp: aHumMeasure    ^self slideDown: (aHumMeasure negated).</pre><pre>solidColor: aColor   "What color should be used to render box or bounding-box in a view?"</pre><pre>southEdge   ^ southEdge</pre><pre>southEdge: aQuantity</pre><pre>tilt   "Get my tilt (pitch) in scene coordinates as a value expressed in radians.</pre><pre>tilt: tiltInRadians   "Set my tilt (pitch) in scene coordinates as a value expressed in radians.</pre><pre>tiltDegrees: angleInDegrees   "Set my tilt (pitch) angle in scene coordinates. "</pre><pre>tiltDown: angleInDegrees   "Set tilt  (pitch)  in scene coordinates - Note: This is not additive."</pre><pre>tiltPolygons: inputPolygons    "Correct the polygons for my tilt (pitch)."</pre><pre>tiltUp: angleInDegrees   "Set tilt (pitch) in scene coordinates - Note: This is not additive."</pre><pre>topEdge   ^ topEdge</pre><pre>topEdge: aQuantity</pre><pre>velocity: aHumVector   "What is the 3D object`s current velocity?"</pre><pre>volume   "Calculate the volume"</pre><pre>westEdge   ^ westEdge</pre><pre>westEdge: aQuantity</pre><pre>width   "Get the width. By convention, the width runs East and West."</pre><pre>width: aQuantity   "Reset the East-West dimension"</pre><pre>x3dCenter   "Center of box (and/or center of bounding box) -- { x y z }</pre><pre>x3dExtent   "Return x y z extents as a string</pre><pre>xyzString</pre><pre>zslideRight: aHumMeasure    "Move camera left or right --- TODO: Correct this for camera orientation."</pre><h3>Hum-UI -- HumCamera</h3><pre>eyeX   "Eye in scene coordinates.  </pre><pre>eyeY   "Eye in scene coordinates."</pre><pre>eyeZ   "Eye in scene coordinates."</pre><pre>isPointInFieldOfView: a3Dpoint    "Is the given 3D point within my field of view.  </pre><pre>slideBackward: aDistance</pre><pre>slideForward: aDistance   "Move in the direction the camera is pointing."</pre><pre>slideLeft: aDistance   ^self slideRight: (aDistance negated).</pre><pre>slideRight: aDistance   "Move in the direction the camera is pointing."</pre><pre>slideUpward: aDistance   "Move in the direction the camera is pointing."</pre><pre>unitForward   "Return unit vector pointing along my internal y axis due to my rotation and tilt."</pre><pre>unitSideways   "Return unit vector pointing along my internal x axis due to my rotation and tilt."</pre><pre>unitUpDown   "Return unit vector pointing along my internal x axis due to my rotation and tilt."</pre><h3>Hum-UI -- HumCanvas</h3><pre>about"</pre><pre>asMorph</pre><pre>borderWidth: aWidth borderColor: aColor </pre><pre>brushColor   "Get my brush color."</pre><pre>brushColor: aColor    "Set my brush color."</pre><pre>brushPosition   "Get my latest brush position."</pre><pre>brushPosition: aPoint    "Remember my latest brush position."</pre><pre>drawHumPolygon: aHumPolygon    "The HumPolygon contains 3D points  and specifies fill and border colors. </pre><pre>drawPolygon: aHumPolygon scale: pxPerMeter </pre><pre>drawTextLines: textLines withFont: aFont</pre><pre>extent   "What is my height and width?"</pre><pre>fillBackground</pre><pre>formCanvas    "What form should I draw on."</pre><pre>formCanvas: aFormCanvas    "What form should I draw on."</pre><pre>height   "What is my height?"</pre><pre>moveBrushTo: aCanvasPoint   "Position the brush, but do not paint yet."</pre><pre>paintTo: aCanvasPoint </pre><pre>projectScenePoint: aScenePoint cameraDepth: aCameraDepth   "Translate from scene coordinates (meters) to canvas coordinates (px)"</pre><pre>scalePixelsPerMillimeter   "How many pixels per millimeter of camera viewbox?"</pre><pre>scalePixelsPerMillimeter: aNumber   "How many pixels per millimeter of viewbox?"</pre><pre>scalePoint: aScenePoint scaleRatio: pxPerMeter    "Return a x@y point by scaling the given scene point"</pre><pre>skyColor   "What color to use for background fill?"</pre><pre>skyColor: aColor   "What color to use for background fill?"</pre><pre>width   "What is my width?"</pre><h3>Hum-UI -- HumCategoryWidget</h3><pre>categories   ^categories ifNil: [Error signal: 'categories have not been initialized']</pre><pre>categories: anArrayOfCategoryNames </pre><pre>renderContentOn: aWAHtmlCanvas   "render self via a simple input tag"</pre><h3>Hum-UI -- HumColumnLayoutWidget</h3><pre>asHTML   "Generate a div containing child widget renderings."</pre><pre>asMorph</pre><h3>Hum-UI -- HumDateWidget</h3><pre>renderContentOn: aWAHtmlCanvas   "render self via a simple input tag"</pre><h3>Hum-UI -- HumDiagram</h3><pre>addConnection: anAssociation    "anAssociation := ( fromNode -&gt; toNode )"</pre><pre>addConnection: anAssociation label: aString   "anAssociation := ( fromNode -&gt; toNode )"</pre><pre>addNode: anObject   "A node object should have a title. </pre><pre>asSVGonHtml: html width: aWidth height: aHeight    "TODO: REFACTOR to render as HTML string."</pre><pre>asSVGonHtmlCanvas: html width: aWidth height: aHeight    "Render this diagram on the given Seaside canvas.</pre><pre>asSVGonSeasideCanvas: html width: aWidth height: aHeight    "Render this diagram on the given Seaside canvas.</pre><pre>connections   "Model connections as a set of associations."</pre><pre>countNeighborsOfNode: aNode   "Return the number of neighbors of this node.</pre><pre>getNodesDownstreamFromNode: thisNode    "Return nodes that are connected downstream from this node."</pre><pre>getNodesUpstreamFromNode: thisNode    "Return nodes that are connected upstream from this node."</pre><pre>getPositionForNode: aNodeObject   ^ self mapNodePosition at: aNodeObject ifAbsent: [ ^nil ].</pre><pre>graph   ^graph ifNil: [ graph := HumGraph new. ].</pre><pre>initialize   "Set up the graph instance that backs this diagram."</pre><pre>layoutDiagramWithNodeExtent: extentPoint nodeSpacing: spacingPoint   "Layout the diagram using the given node extent and spacing between node edges."</pre><pre>layoutDistanceFromNode: nodeA toNode: nodeB   "Calculate the length of the connection between the nodes."</pre><pre>layoutEnergyOnNode: nodeA fromNode: nodeB   "Calculate a energy scalar. </pre><pre>layoutNode: aNode from: aPosition by: anIncrement   "Find a place for the given node starting from the given position.</pre><pre>layoutRecursiveWithNode: node relativePosition: relativePosition seenBefore: priorNodes   "Assign initial position to this node, and then, using recursion, to its neighbors.</pre><pre>mapNodePosition   ^ mapNodePosition ifNil: [ mapNodePosition := Dictionary new. ].</pre><pre>mapPositionNode   " What node is at a position"</pre><pre>nodeExtent: aPoint </pre><pre>nodeSpacing: aPoint </pre><pre>nodes   "Model nodes as a set of objects."</pre><pre>setNode: aNodeObject position: aPosition   "Node should also be in nodes collection for internal consistency."</pre><pre>title   ^ title ifNil: [ title := '** Diagram has no title! **'].</pre><pre>title: aString</pre><h3>Hum-UI -- HumEditor</h3><pre>addLine: aString    "Delegate to HumText instance."</pre><pre>beep   "If sound is enabled, beep."         </pre><pre>characterIndex   "Character index is equal to the number of charactes to the left of the cursor."</pre><pre>characterIndex: aSmallInteger    "character index ranges from 0 (left of line) to ()"</pre><pre>currentLine</pre><pre>deletePriorCharacter   "Insert a character into the text at the current (cursor) position"</pre><pre>emptySelection   "The selection is empty.</pre><pre>initialize   "Set up undo stack and notification."</pre><pre>insertCharacter: aCharacter    "Insert a character into the text at the current (cursor) position"</pre><pre>insertLine   "Delegate to our HumText instance"</pre><pre>interpretKey: aSymbol    "Interpret various keyboard gestures."</pre><pre>lineIndex   ^ lineIndex ifNil: [ lineIndex := 1 ].</pre><pre>lineIndex: aSmallInteger </pre><pre>lines   ^ self text lines.</pre><pre>redo   "Replace text with text that was replaced at last undo."</pre><pre>redoStack   ^ redoStack ifNil: [ redoStack := OrderedCollection new ].</pre><pre>selectedText   "Return selected text as a string with CR inserted as needed at ends of lines."</pre><pre>selectionAnchor   "Return selection anchor."</pre><pre>text   ^ text ifNil: [ text := HumText new ].</pre><pre>undo   "Replace text with last item from undo stack."</pre><pre>undoStack</pre><pre>update: aText   "When text is updated, we are informed. Put on undo stack."</pre><pre>updateSelection   "Selection extends from an anchor-point to current cursor position.</pre><h3>Hum-UI -- HumElipsoid</h3><pre>asPolygons   ^ self asPolygonsColoredBy: [ self solidColor ].</pre><pre>asPolygonsColorCoded   ^ self asPolygonsColoredBy: [ self nextColor ].</pre><pre>asPolygonsColoredBy: aBlockRule   "Produce polygons from the xyList points and the rotation nWedges."</pre><pre>asVPython</pre><h3>Hum-UI -- HumExtrusion</h3><pre>asPolygonsColoredBy: aColorRule   "Translate the moldLoop`s points </pre><pre>asVPython</pre><pre>centerX   "centerX = average value of x from polygon vertices"</pre><pre>centerY   "centerY = average value of Y values from polygon vertices"</pre><pre>centerZ   "centerZ = average value of Z values from polygon vertices"</pre><pre>changed   "Force recalculation of geometry when next asked."</pre><pre>extrusionPath   "The moldLoop origin is translated along this path to outline the extrusion."</pre><pre>extrusionPath: a3Dpath   "The moldLoop origin is translated along this path to outline the extrusion."</pre><pre>moldLoop   "This loop defines the edges of the extrusion. See also: #extrusionPath:"</pre><pre>moldLoop: a3Dpath   "This loop defines the edges of the extrusion. See also: #extrusionPath:"</pre><pre>volume</pre><h3>Hum-UI -- HumFormWidget</h3><pre>renderContentOn: aWAHtmlCanvas</pre><pre>renderOn: aWAHtmlCanvas</pre><pre>view  "Return my view"</pre><pre>view: aHumView </pre><h3>Hum-UI -- HumLayoutWidget</h3><pre>addWidget: aHumWidget </pre><pre>reorder: aSortBlock   "Re-order the widgets according to the given sort criteria."</pre><pre>widgets   ^ widgets ifNil: [ widgets := OrderedCollection new. ]</pre><h3>Hum-UI -- HumMeasureWidget</h3><pre>renderContentOn: aWAHtmlCanvas   "render self via a simple input tag"</pre><h3>Hum-UI -- HumPane</h3><pre>drawTextLines: textLines onCanvas: aCanvas font: aFont </pre><pre>textChanged: aHumTextEditor    "Text to be displayed in this pane has changed."</pre><h3>Hum-UI -- HumPolygon</h3><pre>&lt;= aHumPolygon    "Z-ordering: Is my north-most point more northerly than the other."</pre><pre>&gt; aHumPolygon    "Is my north-most point more northerly than the other."</pre><pre>addVertex: aScenePoint    "The convention is to list vertices in a counter-clockwise direction as seen from the 'outside' of a solid."</pre><pre>asTriangles</pre><pre>borderColor   ^ borderColor ifNil: [ borderColor := Color blue ].</pre><pre>borderColor: aColor </pre><pre>bottom   "If points are 2D, Return min y or zero."</pre><pre>centroid   "Compute the centroid of the vertices."</pre><pre>color: aColor    "Specify border-color or fll-color instead."</pre><pre>drawOn: aHumCanvas </pre><pre>fillColor   ^ fillColor ifNil: [  fillColor := Color gray. ].</pre><pre>fillColor: aColor </pre><pre>inFrontOfCamera   "Return true if at least one y-value is positive."</pre><pre>left</pre><pre>maxRsquared   "Compute the centroid of the vertices."</pre><pre>meanRsquared   "Compute the centroid of the vertices."</pre><pre>minRsquared   "Compute the centroid of the vertices."</pre><pre>northMostPoint   "Find the value of the point that is furtherest North (z-Ordering)"</pre><pre>parentSolid   "Remember where I came from."</pre><pre>parentSolid: aHumSolid    "Remember where I came from."</pre><pre>path   ^self vertices.</pre><pre>pitch: pitchAngle    "Return a new polygon with my points adjusted by pitch about origin."</pre><pre>rSquared</pre><pre>right</pre><pre>roll: rollAngle    "Return a new polygon with my points adjusted by roll about origin."</pre><pre>top   "If points are 2D, Return max y."</pre><pre>vertices   "The convention is to list vertices in a counter-clockwise direction as seen from the 'outside' of a solid."</pre><pre>verticesDo: aBlockClosure </pre><pre>xyPoints   "Flatten my 3D points to 2D points in X-Y (floor plan) plane"</pre><pre>xzPoints   "Flatten my 3D points to 2D points in X-Z (viewport/billboard) plane. "</pre><pre>yaw: yawAngle    "Return a new polygon with my points adjusted by yaw about origin."</pre><pre>yaw: yawAngle aboutPivot: pivot   "Return a new polygon with my points adjusted by yaw about origin."</pre><h3>Hum-UI -- HumRotation</h3><pre>asPolygonsColoredBy: aColorRule   "Produce polygons from the xyList points and the rotation nWedges."</pre><pre>asVPython</pre><pre>nWedges: numberOfWedges</pre><pre>xyList: aCollection    "List of XY (XZ) points that define surface of revolution."</pre><h3>Hum-UI -- HumRowLayoutWidget</h3><pre>asHTML   "Generate a div containing child widget renderings."</pre><pre>asMorph</pre><h3>Hum-UI -- HumScene</h3><pre>asThreeJS   "Render the scene as ThreeJS"</pre><pre>asThreeJSGeometry   "Render the assembly as ThreeJS geometry"</pre><pre>asThreeJSinHTML   "Wrap ThreeJS rendering with HTML5."</pre><pre>asVPython   "render scene and the objects in it via VPython."</pre><pre>asVPythonPreamble</pre><pre>jump: aTime   "TODO: Is this consistent with HumSimulator?"</pre><pre>setupFloor4ThreeJS   "Provide boilerplate that creates a visible floor."</pre><pre>setupScene4ThreeJS   ""</pre><h3>Hum-UI -- HumSolid</h3><pre>asPolygons   "Translate each face into a list of 3D points."</pre><pre>asPolygonsColorCoded   "Color code the facets of the solid."</pre><pre>asPolygonsColoredBy: aColorRule   "Generate polygons from the solid`s dimension. - Subtypes should over-ride."</pre><pre>asThreeJS   "Render this solid  as a cube via three.js"</pre><pre>asVPython</pre><pre>asVPythonPosition   "Generate VPythgon code giving position."</pre><pre>asVPythonThing   "A solid has color and is visible."</pre><pre>asX3D   "Return a string in X3D notation representing this box / thing.</pre><pre>attachCanvas: aCanvas toFace: aSymbol    "Attach the  canvas to the face. -- Used for billboards. </pre><pre>color   ^solidColor ifNil: [ solidColor := Color gray. ].</pre><pre>color: aColor    "What id the default (background) color of the surface and interior of this solid 3D object?"</pre><pre>density   "Return set density otherwise lookup the density of my material."</pre><pre>density: aMeasure   "What is the average density (mass per cube) of this solid?</pre><pre>densityOfMaterial</pre><pre>faces   "Hold image/canvas to be attached to a face."</pre><pre>initialize</pre><pre>mass   ^ mass ifNil: [ mass := (self volume) * (self density)].</pre><pre>mass: aMeasure   "What is the mass of this object?"</pre><pre>material   ^ material ifNil: [ Error signal: 'Material has not been set for this solid'].</pre><pre>material: aString    "See also: #densityOfMaterial for names of standard materials. "</pre><pre>solidColor   ^solidColor ifNil: [ solidColor := Color gray. ]</pre><pre>type: aSymbol    "TODO: Why was this coded? </pre><pre>weight   "Get the Earth-bound weight of the object.  (in Newtons)."</pre><pre>wireFrameColor   ^wireFrameColor ifNil: [ wireFrameColor := Color black ].</pre><pre>x3dColor   "Translate my Smalltalk Color to x3dColor string"</pre><pre>x3dExampleJSON</pre><pre>x3dExampleXML   "Example to aid design </pre><pre>x3dMaterial   "Return X3D element for appearance/material of this color and opacity.</pre><pre>x3dMaterialColorRed: red green: green blue: blue alpha: alpha    "Return X3D element for appearance/material of this color and opacity."</pre><pre>x3dShape   "Produce X3D XML shape element"</pre><pre>x3dShape: typeOfShape diffuseColor: diffuseColor specularColor: specularColor   "Produce X3D XML shape element - override instance variable color?"</pre><h3>Hum-UI -- HumSpace</h3><pre>asPolygons   "Return an empty collection of polygons - HumSpace is not drawn. It is used for spacing in layout logic."</pre><pre>asPolygonsColorCoded   "Return an empty collection of polygons - HumSpace is not drawn. It is used for spacing in layout logic."</pre><pre>asVPythonThing   "A space has no color and is not visible."</pre><h3>Hum-UI -- HumStringWidget</h3><pre>asHTML   "Generate HTML input element"</pre><pre>asMorph</pre><pre>renderContentOn: aWAHtmlCanvas   "render self via a simple input tag"</pre><h3>Hum-UI -- HumSurface</h3><pre>about"</pre><pre>addShape: aHumSurface </pre><pre>asBillBoard   "Convert the surface to a thin HumBox, facing South, hung at eye-level."</pre><pre>asHTML   " Render surface as HTML"</pre><pre>asHtmlCanvasOffsetX: offsetX y: offsetY   "Return a HTML &lt;rect . . . /&gt; element for this surface."</pre><pre>asMeasure: aQuantity</pre><pre>asMorph</pre><pre>asSVG   "Generate the opening &lt;svg . . . &gt; element."</pre><pre>asSvgRect   "Return a SVG &lt;rect . . . /&gt; element for this surface."</pre><pre>asSvgRectOffsetX: offsetX y: offsetY   "Return a SVG &lt;rect . . . /&gt; element for this surface."</pre><pre>asSvgViewBox</pre><pre>asXML</pre><pre>asXMLRectOffsetX: offsetX y: offsetY    "Return a hum &lt;surface . . . /&gt; element for this surface."</pre><pre>backgroundColor</pre><pre>backgroundColor: aColor   "Set color to be used when background is rendered."</pre><pre>bbBottom   "Find my bounding box edge."</pre><pre>bbEdge: aSymbol   "Find my bounding box edge. </pre><pre>bbHeight   "Find my bounding box edge."</pre><pre>bbLeft   "Find my bounding box edge."</pre><pre>bbRight   "Find my bounding box edge."</pre><pre>bbTop   "Find my bounding box edge."</pre><pre>bbWidth   "Find my bounding box edge."</pre><pre>borderColor   "What color is my border, ifany?"</pre><pre>bottom   ^ bottom ifNil: [ self bottom: 0 meter ].</pre><pre>bottom: aNumber   "Reset the bottom edge."</pre><pre>canvas   "Attach a canvas - for placing drawings and images on the surface"</pre><pre>defaultUnits   ^defaultUnits ifNil: [ defaultUnits := 'px' ].</pre><pre>defaultUnits: aSymbol   ^defaultUnits := aSymbol.</pre><pre>drawOn: aHumCanvas    "Draw self on the given canvas."</pre><pre>expandToFit</pre><pre>fillColor   "What color is my fill, ifany?"</pre><pre>generateHumScript   "Proof of concept: Generate Hum code."</pre><pre>height   "What is the height of this object?</pre><pre>height: aNumber.   "Reset the distance between top and bottom edges."</pre><pre>id</pre><pre>id: aString </pre><pre>initialize</pre><pre>initialize: units</pre><pre>layer   "What layer is the surface in?</pre><pre>layer: aNumber</pre><pre>left   ^ left ifNil: [ self left: 0 meter ].</pre><pre>left: aNumber</pre><pre>origin   "a zero-size object positioned at ( left top layer ) = ( 0 0 0 )"</pre><pre>overlay: aHumSurfaceB onTopOf: aHumSurfaceA    "Both shapes are assumed (forced) to be present in my collection."</pre><pre>place: aHumSurfaceB above: aHumSurfaceA    "Place B above A on the surface. </pre><pre>place: aHumSurface at: anArray </pre><pre>place: aHumSurfaceB below: aHumSurfaceA    "Place B below A on the surface. (Not to be confused with putting B on a different  layer.)"</pre><pre>place: aHumSurfaceB leftOf: aHumSurfaceA    "Place B left of A on the surface. "</pre><pre>place: aHumSurfaceB rightOf: aHumSurfaceA    "Place B right of A on the surface. "</pre><pre>right   ^ right ifNil: [self right: 0 meter ].</pre><pre>right: aNumber</pre><pre>shapes   "I remember the 2d objects placed on me."</pre><pre>title   ^ title ifNil: [ self id ].</pre><pre>title: aString</pre><pre>top   ^ top ifNil: [ top := 0 ].</pre><pre>top: aNumber   "Reset the top edge."</pre><pre>width   ^ width ifNil: [ self width: 0 meter. ]</pre><pre>width: anObject   "Reset the width. </pre><h3>Hum-UI -- HumTextPrettyPrinter</h3><pre>addCommentToEndOfLineStartsWith: aString </pre><pre>parse: aHumTextLine </pre><h3>Hum-UI -- HumTextPrettyToken</h3><pre>string</pre><pre>string: aString </pre><h3>Hum-UI -- HumTextWidget</h3><pre>asHTML   "Generate HTML textarea element"</pre><pre>asMorph</pre><pre>renderContentOn: aWAHtmlCanvas   "render self via a text area tag"</pre><pre>rows   "How many rows should we display?" </pre><pre>rows: aSmallInteger   "How many rows should we display?" </pre><h3>Hum-UI -- HumTurtle</h3><pre>headEast</pre><pre>headNorth</pre><pre>headSouth</pre><pre>headWest</pre><pre>heading   ^heading ifNil: [ heading := (0 degrees) ].</pre><pre>heading: compassHeading   "North is 0 degrees. East is 90 degrees. West is minus 90. South is 180."</pre><pre>initialize   "The initial turtle position is at origin (0@0) facing North."</pre><pre>position   ^ position ifNil: [ position := 0.0@0.0. ]</pre><pre>position: aPoint   "Move turtle to aPoint without painting."</pre><pre>speed   "Distance traveled on each step."</pre><pre>speed: aFloat   "Distance traveled on each step."</pre><pre>step   "Move forward one step"</pre><pre>tail   ^ tail ifNil: [ tail := #up ].</pre><pre>tail: aSymbol   "tail = #up means no paint, otherwise lines are drawn with tailColor."</pre><pre>tailColor   "What color am I painting at this time?"</pre><pre>tailColor: aColor   "What color am I painting at this time?"</pre><pre>turn: degreeIncrement   "Change heading by given amount."</pre><pre>turnLeft</pre><pre>turnRight</pre><h3>Hum-UI -- HumVR</h3><pre>addScene: aHumScene </pre><pre>jump:  aTime   "Execute equations of motion, etc."</pre><pre>jumpTime   "Get the latest VR-world time. This is set by the last time-jump. See: #jump: "</pre><pre>jumpTime: aTime   "Set the VR-world time. (Use to synchronize state across scenes) - called from #jump:"</pre><pre>scenes   "A VR world has one or more scenes identified and accessed by their IDs. "</pre><pre>start   "Start stepping."</pre><pre>stop   "Stop stepping"</pre><h3>Hum-UI -- HumViewPortMorph</h3><pre>camera</pre><pre>handleKeystroke: anEvent</pre><pre>handlesMouseOver: evt   ^true.</pre><pre>mouseEnter: anEvent</pre><pre>mouseLeave: anEvent</pre><pre>viewPort   ^ viewPort</pre><pre>viewPort: aHumViewPort </pre><h3>Hum-UI -- HumViewPort</h3><pre>asMorph</pre><pre>camera   "Which camera (in the scene)?"</pre><pre>camera: aCamera    "Which camera (in the scene)?"</pre><pre>cameraCanSeePolygon: aHumPolygon    "The camera can see the polygon </pre><pre>changed</pre><pre>getPolygonsForSolids: aCollectionOfSolids    "Return polygons corresponding to the surfaces of the given solids."</pre><pre>getPolygonsForSolids: aCollectionOfSolids colorRule: aOneArgumentBlock   "Return polygons corresponding to the surfaces of the given solids."</pre><pre>mapPolygonsFrom3Dto2D   "Each solid in the scene provides a collection of polygons with points in 3D scene coordinates. </pre><pre>mapPolygonsFrom3Dto2DcolorCoded   "Each solid in the scene provides a collection of polygons with points in 3D scene coordinates. </pre><pre>mapPolygonsToViewPort: aCollectionOfPolygons    "Map from 3D to 2D"</pre><pre>mapToCanvas: aHumCanvas bounds: aRectangle    "Declare where to draw me. Drawing is defered. See . . ."</pre><pre>mapTrianglesFrom3Dto2D   "Each solid in the scene provides a collection of polygons with points in 3D scene coordinates. </pre><pre>paintHumPolygon: aHumPolygon    "The HumPolygon may contain 3D points and specifies fill and border colors. </pre><pre>paintScene   "Render solids in my scene as polygons projected onto my canvas."</pre><pre>paintSceneAsTriangles   "Render solids in my scene as polygons projected onto my canvas."</pre><pre>paintSceneColorCoded   "Render solids in my scene as polygons projected onto my canvas."</pre><pre>projectPolygon: aScenePolygon    "Return a new polygon with the points transformed into camera`s coordinate system."</pre><pre>projectScenePoint: aViewPoint cameraDepth: aCameraDepth   "Translate from camera view coordinates (meters) to canvas coordinates (px)"</pre><pre>projectionMode   "Map the scene polygons onto the viewport using orthogonal or perspective projection?"</pre><pre>projectionMode: aSymbol </pre><pre>renderScene   "Render solids in my scene as polygons projected onto my canvas."</pre><pre>renderSceneAsTriangles      "Render solids in my scene as polygons projected onto my canvas."</pre><pre>renderSceneAsWireFrame   "Render solids in my scene as polygons projected onto my canvas."</pre><pre>repaint   "Repaint using stored block."</pre><pre>repaint: aBlock   "Which method to use when repainting?"</pre><pre>scalePixelsPerMillimeter   ^pixelsPerMillimeter ifNil: [ pixelsPerMillimeter := (5 px) / (1 millimeter) ].</pre><pre>scalePoint: aScenePoint scaleRatio: pxPerMeter    "Return a x@y point by scaling the given scene point"</pre><pre>scene: aScene </pre><pre>selectSolidsInFrontOfCamera   "Return collection of solids whose centers are in front of camera."</pre><pre>transformPointIntoCameraFrame: aPoint3D    "Transform the point into the camera`s coordinate system."</pre><pre>transformPolygonToCameraFrame: aScenePolygon    "Return a new polygon with the points transformed into camera`s coordinate system."</pre><pre>update: anObject    "Something in my model has been changed."</pre><pre>zmapPolygonsFrom3Dto2D   "Each solid in the scene provides a collection of polygons with points in 3D scene coordinates. </pre><pre>zrenderScene   "Render solids in my scene as polygons projected onto my canvas."</pre><h3>Hum-UI -- HumView</h3><pre>asWidget   "Initialize a HumFormWidget for this view"</pre><pre>blackboard   ^ blackboard ifNil: [ Error signal: 'No blackboard has been assigned to this view.'].</pre><pre>blackboard: aHumBlackBoard</pre><pre>calc   "Create a calculator to be shared . . ."</pre><pre>entityName   "get"</pre><pre>entityName: aString   "Set"</pre><pre>interpretEmphasisIn: aString on: aWAHtmlCanvas    "TODO: THIS IS A STUB - Expect aString contains Hum Markup."</pre><pre>ontology: aHumOntology </pre><pre>renderFrameLine: aHumMarkupLine viaSeasideCanvas: aWAHtmlCanvas </pre><pre>renderMarkupLinesViaSeasideOn: aWAHtmlCanvas    "Render the ontology view frame lines via Seaside"</pre><pre>renderUpToNextWidget: aMarkupString on: html   "Render mark-up that does not involve heading/list/widget"</pre><pre>view   ^ viewFrame ifNil: [Error signal: (self class asString),' not initialized']</pre><pre>view: aViewNameString    "Fetch the view frame of that name."</pre><h3>Hum-UI -- HumWidget</h3><pre>about" The traditional idea of a widget is that it is a component in a view. (MVC concept)</pre><pre>asGlamorBrick   "Render widget and data as Glamor Brick object"</pre><pre>asHTML   "Render widget and data as HTML code"</pre><pre>asJSF   "Render widget and data as Jave Server Face code"</pre><pre>asMagritteMorph   "Render widget and data as Magritte Morph object"</pre><pre>asMorph   "Render widget and data as Morph object  </pre><pre>asXUL   "Render widget and data as XUL code"</pre><pre>attributeName   ^attributeName</pre><pre>attributeName: aString   "name of attribute"</pre><pre>attributeValue   ^ attributeValue ifNil: [ '' ].</pre><pre>attributeValue: aString   "Set current value of attribute -- in display/input format."</pre><pre>blackboard: aHumBlackBoard </pre><pre>canvas   "Canvas on which to draw the widget - "</pre><pre>canvas: aHumCanvas    "Canvas on which to draw the widget - "</pre><pre>entityName: aString </pre><pre>formCanvas   ^self canvas formCanvas.</pre><pre>renderContentOn: aWAHtmlCanvas   "Default: Render self via a simple input tag"</pre><pre>store: anObject    "Set my attribute value and store it on my blackboard."</pre><h3>Hum-X -- H3dCamera</h3><pre>depth   "Distance from eye point to viewport rectangle."</pre><pre>depth: aHumMeasure    "Distance from eye point to viewport rectangle."</pre><pre>projectScenePointToScreenPoint: aScenePoint   "Map a scene point onto a screen point ( x y z ) ==&gt; ( x' y' z').</pre><pre>scene: aScene   "Scene (or layer) the camera is viewing."</pre><h3>Hum-X -- H3dObjectTests</h3><pre>test110buildBox</pre><pre>test120yawBox90degrees   "90 degree yaw exchanges X and Y"</pre><pre>test122yawBox90degreesAroundPivot   "90 degree yaw exchanges X and Y"</pre><pre>test125yawBox180degrees   "180 degree rotations should leave bounds the same."</pre><pre>test130pitchBox90degrees   "90 degree pitch exchanges Y and Z"</pre><pre>test132pitchBox90degreesAboutPivot   "90 degree pitch exchanges Y and Z"</pre><pre>test135pitchBox180degrees   "180 degree rotations should leave bounds the same."</pre><pre>test140rollBox90degrees   "90 degree roll exchanges X and Z"</pre><pre>test142rollBox90degreesAboutPivot   "90 degree roll exchanges X and Z"</pre><pre>test143rollBox90degreesAboutPivot   "90 degree roll exchanges X and Z"</pre><pre>test145rollBox180degrees   "180 degree rotations should leave bounds the same."</pre><pre>test150yawPitchRollBox   "180 degree rotations should leave it looking the same."</pre><pre>test220moveBoxEast</pre><pre>test225moveBoxWest</pre><pre>test230moveBoxNorth</pre><pre>test235moveBoxSouth</pre><pre>test240moveBoxTop</pre><pre>test245moveBoxBottom</pre><pre>test310stepVelocity</pre><pre>test320stepYawRate</pre><pre>test325stepVelocityAndYawRate</pre><pre>test330stepPitchRate</pre><pre>test335stepVelocityAndPitchRate</pre><pre>test340stepRollRate</pre><pre>test345stepVelocityAndRollRate</pre><pre>test350stepEverything</pre><pre>test610buildElipsoid</pre><pre>test620yawElipsoid90degrees   "90 degree yaw exchanges X and Y"</pre><pre>test630pitchElipsoid90degrees   "90 degree pitch exchanges Y and Z"</pre><pre>test640rollElipsoid90degrees   "90 degree roll exchanges X and Z bounds"</pre><pre>test710buildRotation</pre><pre>test711buildRotationAroundX</pre><pre>test712buildRotationAroundY</pre><pre>test810buildAssembly</pre><pre>test820stackBoxes</pre><pre>test821stackAndYaw90</pre><pre>test822stackAndPitch90</pre><pre>test824stackAndRoll90</pre><h3>Hum-X -- H3dObject</h3><pre>addPart: anH3dObject   "Add a part (or subassembly) to my assembly."</pre><pre>addParts: aPartsList   "Add each part to my set of parts."</pre><pre>assertRadians: anAngleInRadians</pre><pre>assertRadiansPerSecond: radiansPerSecond</pre><pre>axis: anAxisSymbol   "Which axis is rotation around? </pre><pre>borderColor   ^ borderColor ifNil: [ borderColor := (self fillColor) lighter. ].</pre><pre>bottom   "Value without yaw, pitch, roll - Use minZ to see value with yaw, pitch, roll."</pre><pre>bottom: aMeasure   "Move so that bottom is at given z value."</pre><pre>buildAndOrient   "Return polygons in scene coordinates.</pre><pre>buildAssembly   "Build the polygons for the assembly by aggregating and translating polygons from the parts."</pre><pre>buildBasePolygons   "Return my base polygons. Polygons before pitch, yaw, roll."</pre><pre>buildBox   "Create polygons for a box"</pre><pre>buildElipsoid   "Create polygons forming the elipsoid."</pre><pre>buildRotation   "Given curve and an axis, build a rotation as a collection of polygons."</pre><pre>center   ^ center ifNil: [ center := (HumVector newFrom: { 0.0 meter. 0.0 meter. 0.0 meter. } ) ].</pre><pre>center: aVector   "Set my center in container coordinates."</pre><pre>clearance   "Default value for clearance is one millimeter."</pre><pre>curve: xyPoints   "Curve to use when building a rotation.</pre><pre>east   "Value without yaw, pitch, roll - Use maxX to see value with yaw, pitch, roll."</pre><pre>east: aMeasure   "Move so that east edge is at the given value."</pre><pre>fillColor   ^ fillColor ifNil: [ fillColor := Color gray. ].</pre><pre>height   "What is my Up-Down height? (prior to pitch, yaw, roll).</pre><pre>height: aHeight   "What is my Up-Down height? (prior to pitch, yaw, roll).</pre><pre>initialize   "Set initial position, orientation, velocity, and rotation rates to zero."</pre><pre>length   "What is my North-South length? (prior to pitch, yaw, roll)</pre><pre>length: aLength   "What is my North-South length? (prior to pitch, yaw, roll)</pre><pre>maxX</pre><pre>maxY</pre><pre>maxZ</pre><pre>minX</pre><pre>minY</pre><pre>minZ</pre><pre>move: aH3dObject toMyCoordinate: aHumVector </pre><pre>north   "Value without yaw, pitch, roll - Use maxY to see value with yaw, pitch, roll."</pre><pre>north: aMeasure   "Move so that north edge is at given value."</pre><pre>numberOfWedges   "Number of wedges to produce when drawing rotation or elipsoid."</pre><pre>numberOfWedges: anInteger </pre><pre>parts   "Return my set of parts/subassemblies - each part is unique - hence a member of a set."</pre><pre>pitch   "Amount of current pitch = rotation about x-axis"</pre><pre>pitch: anAngleInRadians   "Amount of current pitch = rotation about x-axis"</pre><pre>pitchRate: randiansPerSecond   "pitch rate (angular velocity) "</pre><pre>pivot   "Return the pivot in scene coordinates."</pre><pre>pivotPoint   "Pivot-point is relative to object`s center. </pre><pre>pivotPoint: aVector   "Pivot-point is relative to object`s center.</pre><pre>place: aH3dObjectA onTopOf: aH3dObjectB    "Position so that  bottom matches top with a little clearance."</pre><pre>polygons</pre><pre>roll   "Amount of current roll. = rotation about y-axis"</pre><pre>roll: anAngleInRadians   "Amount of current roll. = rotation about y-axis"</pre><pre>rollRate: randiansPerSecond   "roll rate (angular velocity) "</pre><pre>south   "Value without yaw, pitch, roll - Use minY to see value with yaw, pitch, roll."</pre><pre>south: aMeasure   "Move so that south edge is at given value."</pre><pre>step: aTimeIncrement   "Step the position and orientation."</pre><pre>top   "Value without yaw, pitch, roll - Use maxZ to see value with yaw, pitch, roll."</pre><pre>top: aMeasure   "Move so that top is at given z value."</pre><pre>type: aType   "What type of 3D object am I?"</pre><pre>velocity: aVector   "Set my velocity in container coordinates."</pre><pre>volume   "Return volume of box."</pre><pre>west   "Value without yaw, pitch, roll - Use minX to see value with yaw, pitch, roll."</pre><pre>west: aMeasure   "Move so that west edge is at the given value."</pre><pre>width   ^ width ifNil: [ Error signal: 'width has not been set' ].</pre><pre>width: aWidth   "What is my East-West width? (prior to pitch, yaw, roll)</pre><pre>yaw   "Amount of current yaw. = rotation about z-axis"</pre><pre>yaw: anAngleInRadians   "Amount of current yaw. = rotation about z-axis"</pre><pre>yawRate: randiansPerSecond   "yaw rate (angular velocity) = rotation about z-axis"</pre><h3>Hum-X -- H3dPath</h3><pre>= anotherPath   "Are the two paths equal."</pre><pre>addVertex: xyzCoordinates </pre><pre>allButFirstDo: aBlockClosure    ^self vertices allButFirstDo: aBlockClosure.</pre><pre>at: anInteger   "Return the vertex at: ..."</pre><pre>borderColor   ^ borderColor ifNil: [ borderColor := (self fillColor) lighter ].</pre><pre>borderColor: aColor    "Color to use when rendering path (polygon edges)."</pre><pre>do: aBlockClosure    ^self vertices do: aBlockClosure.</pre><pre>fillColor   ^ fillColor ifNil: [ fillColor := Color gray ].</pre><pre>fillColor: aColor    "Color to use when rendering path as a polygon"</pre><pre>first</pre><pre>last</pre><pre>max: aBlockClosure    ^self vertices max: aBlockClosure.</pre><pre>pitch: pitchAngle    "Return a new path with my points adjusted by pitch about origin."</pre><pre>pitch: pitchAngle aboutPivot: aPivot   "Return a new path with my points adjusted by pitch about origin."</pre><pre>roll: rollAngle    "Return a new path with my points adjusted by roll about origin."</pre><pre>roll: rollAngle aboutPivot: aPivot   "Return a new path with my points adjusted by roll about origin."</pre><pre>size   ^ self vertices size.</pre><pre>translateBy: aHumVector    "Return a path with vertices translated by the given vector."</pre><pre>translatedBy: aHumVector   "Return a new path with my vertices translated by the given vector"</pre><pre>vertices   ^ vertices ifNil: [ vertices := OrderedCollection new ].</pre><pre>yaw: yawAngle    "Return a new path with my points adjusted by yaw about origin."</pre><pre>yaw: yawAngle aboutPivot: pivot   "Return a new path with my points adjusted by yaw about origin."</pre><h3>Hum-X -- H3dViewPortTests</h3><pre>test110CreateCamera</pre><pre>test120ProjectScenePointToCameraViewPort</pre><pre>test130PitchCamera</pre><pre>test140RollCamera</pre><pre>test150YawCamera</pre><pre>test160TranslateCamera</pre><pre>test210CreateViewPort   "A viewport is a view on a scene via a camera in the scene."</pre><h3>Hum-X -- H3dViewPort</h3><pre>camera: anH3dCamera    "The viewport is attached to this camera."</pre><pre>mapScenePoint: aScenePoint    "Map scene point to camera image, camera image to my image."</pre><pre>origin: pointOrigin extent: pointExtent     "What is my origin and extent in container coordinates and pixel metrics?"</pre><pre>resolutionAt: aDistance   "What is the resolution per pixel at given distance"</pre><pre>scale   ^scale ifNil: [ Error signal: 'This viewport`s scale has not been set yet.' ].</pre><pre>scale: measureNumerator per: measureDenominator    "Multiply camera screen coordinates by scale to get my coordinates."</pre><h3>Hum-X -- HApplication</h3><pre>handleRequest: aZnRequest    "Return a response for given request"</pre><pre>handler: aBlockClosure    "Use the block to handle request"</pre><h3>Hum-X -- HBaseTests</h3><pre>test240WorldBaseBacksBlackBoard   "Blackboard calls on World Base to persist events, state-changes."</pre><h3>Hum-X -- HBase</h3><pre>entities   "Dictionary of (id -&gt; entity)"</pre><pre>events   ^events ifNil: [ events := Dictionary new ].</pre><pre>putEntity: anEntity attribute: anAttribute value: aValue event: anEvent    "Record entity attribute value"</pre><pre>putEvent: anEvent    "Record the given event in my store."</pre><h3>Hum-X -- HBlackboardTests</h3><pre>test140BlackboardSaveFetch   "A blackboard records events, noun values"</pre><pre>test145BlackboardSaveFetchNouns   "A blackboard records events, noun values"</pre><pre>test150BlackboardSaveFetchUpdate   "A blackboard records events, noun values"</pre><pre>test160BlackboardToStream   "A blackboard records events, noun values"</pre><h3>Hum-X -- HBlackboard</h3><pre>asStream   "Show the values in the blackboard on a stream."</pre><pre>events   ^ events ifNil: [ events := OrderedCollection new.]</pre><pre>getEntity: anEntity attribute: anAttribute </pre><pre>getEntityNamed: aNoun </pre><pre>getNoun: aNoun </pre><pre>nouns   ^ nouns ifNil: [ nouns := Dictionary new ].</pre><pre>putEntity: anEntity attribute: anAttribute value: aValue event: anEvent </pre><pre>putEntityNamed: aNoun </pre><pre>putEvent: anEvent </pre><pre>worldBase: aWorldBase    "MOCK: Pretend we are persisting values on world base.</pre><h3>Hum-X -- HClientServerTests</h3><pre>setUp</pre><pre>tearDown</pre><pre>test110CharacterizeZnHttpClient   "Characterize ZnHttpClient"</pre><pre>test112CharacterizeZnHttpClientNotFound   "Characterize ZnHttpClient"</pre><pre>test114CharacterizeZnHttpConnected   "Characterize ZnHttpClient"</pre><pre>test115CharacterizeZnHttpHead   "Characterize ZnHttpClient"</pre><pre>test116CharacterizeZnHttpConnectExternal   "Characterize ZnHttpClient"</pre><pre>test120CharacterizeZnHTTPSocketFacade   "Characterize ZnHttpClient"</pre><pre>test190CharacterizeHClient   "HClient is light wrapper on ZnHTTPSocketFacade."</pre><pre>test210CharacterizeZnServer</pre><pre>test211CharacterizeZnServer</pre><pre>test212CharacterizeZnHTTPSocketFacadeNotFound   "Characterize ZnHttpClient"</pre><pre>test212CharacterizeZnServer</pre><pre>test214CharacterizeZnHTTPSocketFacadeConnected   "Characterize ZnHttpClient"</pre><pre>test216CharacterizeZnHTTPSocketFacadePost   "Characterize ZnHttpClient"</pre><pre>test220CharacterizeZnServerGetResponse</pre><pre>test221CharacterizeZnServerPutResponse</pre><pre>test222CharacterizeZnServerPostResponse</pre><pre>test223CharacterizeZnServerDeleteResponse</pre><pre>test224CharacterizeZnServerHeadResponse</pre><pre>test226CharacterizeZnHTTPSocketFacadePost   "Characterize ZnHttpClient"</pre><pre>test310CharacterizeZnRequest   ""</pre><pre>test324CharacterizeZnServerGetResponse   "Use Case: (Single Threaded) Server with HApplication responds to client GET request."</pre><pre>test325CharacterizeZnServerGetResponse   "Use Case: (Multi-Threaded) Server with HApplication responds to client GET request."</pre><pre>test326CharacterizeZnServerGetResponse   "Use Case: (Multi-Threaded) Server with HApplication responds to HClient GET request."</pre><h3>Hum-X -- HClient</h3><pre>clientSettings</pre><h3>Hum-X -- HEntityTests</h3><pre>test110EntityHasAttributes   "An entity has one or more attributes"</pre><pre>test120SetAttributeValueInEvent   "An entity has one or more attributes"</pre><pre>test125EntityPrintOn   "An entity has one or more attributes"</pre><pre>test130UpdateAttributeValueInEvent   "An entity has one or more attributes"</pre><h3>Hum-X -- HEntity</h3><pre>attribute: anAttributeName value: anAttributeValue    "Initialize entity-attribute value. (No event, no history)</pre><pre>attribute: anAttributeType value: aValue event: anEvent    "Record a state-change associated with the given event."</pre><pre>attributes   "Return my dictionary of current attribute values."</pre><pre>getAttribute: anAttributeName    "What is the value of the given attribute?"</pre><pre>history   "Return history of state-changes."</pre><pre>id   ^ id</pre><pre>id: aLargePositiveInteger    "Set unique identifier.</pre><pre>printOn: aStream   "Format my data for easy reading. </pre><pre>title   "Entity should be given a contextually unique name (noun)"</pre><pre>title: aString    "Set my title - something appropriate to usage and unique within the context.</pre><h3>Hum-X -- HEvent</h3><pre>&gt; otherEvent </pre><pre>attributes</pre><pre>id: aLargePositiveInteger </pre><pre>what: aWhat    "What happened? (Relate to business process event.)"</pre><pre>when   ^ when</pre><pre>when: aTimeStamp    "When did the event occur? Real clock or simulated clock"</pre><pre>where: aWhere    "Where did event occur? - Test/Simulation/Host/Application/Service"</pre><pre>who: aWho    "Who caused the event? - User/Robot/Actor/Test"</pre><pre>why: aWhy    "Why did the event occur? - Authorization/JobTicket"</pre><h3>Hum-X -- HGlamourTest</h3><pre>test100ReadMe   "This group of tests follows 'Deep into Pharo - chapter 10' "</pre><pre>test110Page192   "Example at page 192"</pre><pre>test110Page193a   "Example at page 193"</pre><pre>test110Page193b   "Example at page 193"</pre><pre>test110Page194   "Example at page 194"</pre><h3>Hum-X -- HTimeTests</h3><pre>test110timestampIsBigInteger   ""</pre><pre>test120timestampIsUnique   ""</pre>