TestCase subclass: #HumCalculatorTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumCalculatorTests commentStamp: 'RichardAlexanderGreen 1/13/2012 15:25' prior: 0!The Calculator role (agent) provides - base level arithmetic (using measures)- string utilities used to parse Hum source code.!!HumCalculatorTests methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 1/13/2012 15:26'!test110substringAfter	"Test helper method that finds a substring between two given substrings."	| stringIn stringOut |	stringIn := 'This is just the begining. We are expecting content after this colon: And this is it.'.	stringOut := HumCalculator substringFrom: stringIn after: ':'.	self assert: ( stringOut sameAs: ' And this is it.' ).! !!HumCalculatorTests methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 1/13/2012 15:26'!test110substringBefore	"Test helper method that finds a substring between two given substrings."	| stringIn stringOut |	stringIn := 'We are expecting content before this colon: And this is it.'.	stringOut := HumCalculator substringFrom: stringIn before: ':'.	self assert: ( stringOut sameAs: 'We are expecting content before this colon' ). ! !!HumCalculatorTests methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 1/13/2012 15:26'!test120substringBetween	"Test helper method that finds a substring between two given substrings."	| stringIn stringOut |	stringIn := 'This is just the begining. We are expecting the stuff between [ and ].'.	stringOut := HumCalculator substringFrom: stringIn after: '[' before: ']'.	self assert: ( stringOut sameAs: ' and ' ).! !!HumCalculatorTests methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 12/19/2012 12:19'!test130substringBetweenBrackets	"Test helper method that finds a substring between a pair of brackets or similar pairs."	| stringIn stringOut |	stringIn := 'We are expecting the stuff between [[ and ]], including the brackets, but nothing else.'.	stringOut := HumCalculator substringFrom: stringIn includingMatching: '[]'.	self assert: ( stringOut sameAs: '[[ and ]]' ).! !TestCase subclass: #HumRunTimeTests	instanceVariableNames: 'setupMessenger setupManager setupBookkeeper setupWorker setupEnvironment setupConfiguration'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumRunTimeTests commentStamp: 'RichardAlexanderGreen 1/13/2012 15:27' prior: 0!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Run-Time Test Cases--- See also: HumCalculatorTests%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%A. Messenger   1. The actors (agents) communicate via the Messenger.   2. Messenger is addressed via a URI.   3. Messenger records each message in a log file.   4. In test mode,          the messenger can replay the messages          that were sent to an actor during some period of time.          (This capability enables simulations.)   5. In test mode,          messages can only be communicated          between actors that are also in test mode.B. Resource Manager (RM) - assigns tasks to actors.   1. Actor checks-in (announces availability to perform specific roles).   2. Assign task (action-statement) to actor.      a) Job-ticket contains action-statement, noun-values,             request context (requesting actor, and instruction-pointer).      b) The RM assigns an available actor.      c) The RM sends the job-ticket to the assigned actor.             (via Messenger)   3. Actor has completed task.      a) The resources consumed (actor’s time, etc) are recorded on the job ticket.      b) Any computed results are added to the job-ticket.            (Convention: Actions with results have a "giving" clause.)      c) RM sends resource consumption data to Bookkeeper.      d) Task complete notice (with job-ticket) is sent to requester.            (The requester resumes execution of the plan.)C. Bookkeeper - tracks resource consumption   1. Job-ticket resource consumption is recorded.   2. Resource dimensions include job, resource,          provider (actor, role), consumer (actor, role), and date-time.   3. Actors may decrement, increment inventories.   4. Actors may set inventory level (initialization, audit).D. Supervisor - controls execution of plans and dialogs.   1. Delegate task.         (The current actor has delegated a task to another role.)      a) Send delegated task to Resource Manager. (RM)         (The RM will assign the task to an available actor.)    2. Resume suspended action.         (When a task is delegated to another role,             the current task execution is suspended.)!!HumRunTimeTests methodsFor: 'Supervisor Tests' stamp: 'RichardAlexanderGreen 10/6/2012 10:27'!test310supervisorInvokesAction	"Dialog:	Supervisor to ResourceManager: Run action A for job J.	ResourceManager to Supervisor: Action A completed on job J.	"	| actionStatement ontology planFrame  supervisor actionFrame dialogAgent |			true ifFalse: [ Transcript cr; show: 'test310supervisorInvokesAction turned off'; cr. ^self].	"Define a simple plan."	ontology := HumOntology new.	setupConfiguration ontology: ontology.	planFrame := HumFrame4Plan ontology: ontology goal: 'Plan has one frame with no preconditions.'.	planFrame addActionRole: 'cook' statement: 'Sing.'.		actionFrame := HumFrame4Action ontology: ontology role: 'cook' action: 'Sing'.	"Store it in the ontology."	ontology storeFrame: planFrame.	ontology storeFrame: actionFrame.		"Compile it."	planFrame saveFrameToOntology: ontology.	actionFrame saveFrameToOntology: ontology.	""	dialogAgent := HumActor dialog: 'test dialog ID' uri: 'test dialog URL' client: 'client ID' configuration: setupConfiguration.	"Create a running instance of the plan and supervisor to run it."	supervisor := HumActor supervisor: 'test supervisor ID' 	                                                       uri: 'test supervisor URL' 	                                                    goal: 'Plan has one frame with no preconditions.'								       dialog: dialogAgent	                                       configuration: setupConfiguration.									"At this point there are no changes on the job ticket."		"Run an action statement."	actionStatement := HumInstructionLine role: 'cook' statement: 'TBD'. 	supervisor runAction: actionStatement.		"Now there should be at least one change on the job ticket."		"After that action has run. The goal will be fulfilled."	 self assert: ( supervisor remainingConditions = 0 ).	 	! !!HumRunTimeTests methodsFor: 'Resource Manager Tests' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test210managerAssignsAction	"Some actor delegates a task to a role.	The resource manager assigns the task to an actor that advertises that role	and sends the task (work order) to the assigned actor.	"	| cook manager bookkeeper oven ontology frameEditor jobTicket actionStatement |	true ifFalse: [ Transcript cr; show: 'test210managerAssignsAction turned off'; cr. ^self].		"Get the worker from the setup."	cook := setupWorker.	self assert: ( cook isKindOf: HumActor ).	self assert: ( cook roles include: 'cook' ).		"Get the resource manager from the setup."	manager := setupManager.	self assert: ( manager isKindOf: HumResourceManager ).	"Tell the worker to check-in."	cook checkIn.	self assert: ( ( manager actorURI at: (cook id)  ) sameAs: cook uri) .		"Create another actor to be oven. " 	oven := HumActor worker: 'test oven' uri: 'mock oven URI' roles: #( 'oven ' ) configuration: setupConfiguration.	self assert: ( oven uri sameAs:  'mock oven URI'  ).	"Tell the oven  to check-in."	oven checkIn.		"======= Set up the action frame  =========="	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameEditor ontology: ontology  	                                               role: 'Cook' action: 'Bake the pan in the oven for the time given in the recipe.'.	"Append an instruction that is delegated"	frameEditor addInstructionRole: 'Oven' statement: 'Bake for the time given in recipe.'.	"Run store and fetch test routine"	 frameEditor storeFrameInOntology .	"We need at least one noun."	ontology addNoun: 'recipe'.	"============== ================="	"We will pretend to be Supervisor running a plan.	There will be a Job Ticket for the plan.	The Supervisor will ask the Resource Manager to assign an actor to run the action.	"	jobTicket := ( HumJobTicket new ) ontology: ontology; titleLine: 'This is only a test.'; yourself.	self assert: ( jobTicket isKindOf: HumFrame4Data ).	actionStatement := HumStatement source:  'Bake the pan in the oven for the time given in the recipe.'.	actionStatement noun: 'recipe' value: 'white cake'.	actionStatement job: jobTicket.	manager assignRole: 'Cook' action: actionStatement.	"After the task is done, a resource usage entry will be sent to the bookkeeper."	bookkeeper := setupBookkeeper.	self assert: ( bookkeeper isKindOf: HumBookkeeper ).	self assert: ( bookkeeper jobTickets size > 0 ).	! !!HumRunTimeTests methodsFor: 'Messenger Tests' stamp: 'RichardAlexanderGreen 2/13/2012 11:21'!test010MessengerRemembersActors	| messenger cook server |	"Create an actor -- The actor automatically registers itself with the messenger in its configuration."	cook := HumActor worker: 'cook ID' uri: 'cook URI' roles: #('cook')  configuration: setupConfiguration.	messenger := setupConfiguration messenger.	self assert: ( messenger ping: 'cook URI' ) == cook.	"One more should make no problem."	server := HumActor worker: 'server ID' uri: 'server URI' roles: #('server') configuration: setupConfiguration.	self assert: ( messenger ping: 'server URI' )= server.	self assert: ( messenger ping: 'cook URI' ) == cook.	! !!HumRunTimeTests methodsFor: 'Bookkeeper Tests' stamp: 'RichardAlexanderGreen 2/13/2012 11:26'!test410BookkeeperRecordsJobTickets	"If we ask the bookkeeper to 'run' a jobTicket, it stores it in its jobTickets collection.'"	| ticket bookie |	ticket := HumJobTicket new.	bookie := setupBookkeeper.	bookie run: ticket.	self assert: ( bookie jobTickets includes: ticket ) .! !!HumRunTimeTests methodsFor: 'Bookkeeper Tests' stamp: 'RichardAlexanderGreen 2/13/2012 12:54'!test420BookkeeperSumsToActor	"The bookkeeper can sum utilization of an actor."	| ticket bookie aHumMeasure action anID aRoleName aJobID |	ticket := HumJobTicket new.	aHumMeasure := HumMeasure quantity: 1 units: 'call'.	action := 'This is only a test of the bookkeeper.'.	anID := 'test actor ID'.	aRoleName := 'tester'.	aJobID := UUID new.	ticket appendCharge: aHumMeasure forAction: action byActor: anID inRole: aRoleName onJob: aJobID .	bookie := setupBookkeeper.	bookie run: ticket.	self assert: ( bookie jobTickets includes: ticket ) .	Transcript cr; show: ticket  asString; cr.! !!HumRunTimeTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 5/29/2012 18:39'!test510measurePlusSameUnits	"Measures may be added if same units."	| m1 m2 m3 |	m1 := HumMeasure quantity: 10 units: 'meters'.	m2 := HumMeasure quantity: 20 units: 'meters'.	m3 := m1 + m2.	self expect: m3 quantity is: 30.	self expect: m3 units is: 'meters'.	! !!HumRunTimeTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 5/29/2012 18:39'!test520measureMinusSameUnits	"Measures may be added if same units."	| m1 m2 m3 |	m1 := HumMeasure quantity: 10 units: 'meters'.	m2 := HumMeasure quantity: 25 units: 'meters'.	m3 :=  m2 - m1.	self expect: m3 quantity is: 15.	self expect: m3 units is: 'meters'.	! !!HumRunTimeTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 3/8/2012 20:33'!test530measureTimesPercent	"Measures may be added if same units."	| m1 m2 m3 |	m1 := HumMeasure quantity: 10 units: '%'.	m2 := HumMeasure quantity: 25 units: '%'.	m3 :=  m2 * m1.	self expect: m3 quantity is: (0.10 * 0.25 * 100).	! !!HumRunTimeTests methodsFor: 'Actor Tests' stamp: 'RichardAlexanderGreen 2/13/2012 10:57'!setUp	"This setup is used by several tests. "	"Define a Hum configuration."	| |	setupConfiguration := HumConfiguration messenger: 'mock messenger URI' 	                                                                  manager: 'mock manager URI' 	                                                             bookkeeper: 'mock bookkeeper URI'                                                                     worldbase: 'mock worldbase URI'.		"Create the (mock) messenger service"	"setupMessenger := HumBus uri: 'mock messenger URI'.	self assert: ( setupMessenger uri  sameAs: 'mock messenger URI' )."		"A resource manager must know a messenger and a bookkeeper."	setupManager := HumActor manager: 'test manager'  uri: 'mock manager URI'  configuration: setupConfiguration.						 		self assert: ( setupManager isKindOf: HumResourceManager ).	self assert: ( setupManager id sameAs: 'test manager' ).	self assert: ( setupManager uri sameAs: 'mock manager URI'  ).	self assert: ( setupManager configuration == setupConfiguration ).		"A bookkeeper must know a messenger and a world base."						setupBookkeeper := HumActor bookkeeper: 'test bookkeeper' uri: 'mock bookkeeper URI'  configuration: setupConfiguration.		self assert: ( setupBookkeeper isKindOf: HumBookkeeper ).	self assert: ( setupBookkeeper id sameAs: 'test bookkeeper' ).	self assert: ( setupBookkeeper uri sameAs: 'mock bookkeeper URI'  ).	self assert: ( setupBookkeeper configuration == setupConfiguration ).							"A worker must know a messenger and a manager and some roles"	setupWorker := HumActor worker: 'test worker'  uri: 'mock cook URI' roles: #( 'cook' )   configuration: setupConfiguration.		self assert: ( setupWorker isKindOf: HumActor ).	self assert: ( setupWorker uri sameAs:  'mock cook URI'  ).	self assert: ( setupWorker id  sameAs: 'test worker').	self assert: ( setupWorker roles = ( #( 'cook' )  )   ).		"Messenger should know about all of these actors now."	setupMessenger := setupConfiguration messenger.	self assert: ( setupMessenger isKindOf: HumBus ).	self assert: ( setupMessenger ping: 'mock manager URI' ) == setupManager.	self assert: ( setupMessenger ping: 'mock bookkeeper URI' ) == setupBookkeeper.	self assert: ( setupMessenger ping: 'mock cook URI' ) == setupWorker.! !!HumRunTimeTests methodsFor: 'Actor Tests' stamp: 'RichardAlexanderGreen 10/31/2012 09:55'!test100actorConfiguration	"A Hum Actor is configured with the address of a messenger node.	Actors communicate by sending predefined message types via the messenger.	"	|   messenger worker manager   bookkeeper |	true ifFalse: [ Transcript cr; show: 'test100actorConfiguration is TURNED OFF'; cr. ^self].	"Create the (mock) messenger service"	messenger := HumBus uri: 'mock messenger URI'.	self assert: ( messenger uri  sameAs: 'mock messenger URI' ).		"A resource manager must know a messenger and a bookkeeper."	manager := HumActor manager: 'test manager'  uri: 'mock manager URI' configuration: setupConfiguration.	self assert: ( manager isKindOf: HumResourceManager ).	self assert: ( manager uri sameAs: 'mock manager URI'  ).		"A bookkeeper must know a messenger and a world base."						bookkeeper := HumActor bookkeeper: 'test bookkeeper'  uri: 'mock bookkeeper URI' configuration: setupConfiguration.	self assert: ( bookkeeper uri sameAs: 'mock bookkeeper URI' ).									"A worker must know a messenger and a manager and some roles"	worker := HumActor worker: 'test worker'   	                                          uri: 'mock worker URI' 	                           messenger: 'mock messenger URI' 	                               manager: 'mock manager URI'							roles: #( 'cook' 'bottle-washer' 'bar-tender' 'psych' ).	self assert: ( worker uri sameAs:  'mock worker URI'  ).				! !!HumRunTimeTests methodsFor: 'Actor Tests' stamp: 'RichardAlexanderGreen 2/13/2012 09:25'!test110workerChecksIn	"Worker checks-in, announcing roles."	"The check-in protocol has the worker-side and the resource manager side."	"Worker says:	. Manager: Check-in worker W with roles R.	The manager adds the worker to its (role -> worker) knowledge."	|  worker manager |		"Get the worker from the setup."	worker := setupWorker.	self assert: ( worker isKindOf: HumActor ).	self assert: ( worker roles include: 'cook' ).		"Get the resource manager from the setup."	manager := setupManager.	self assert: ( manager isKindOf: HumResourceManager ).		"Execute the check-in directly."	manager checkInActor: 'worker id' at: 'worker uri' withRoles: worker roles.		"Manager now includes worker in set of those who know that role."	self assert: ( manager roleActor includes: ( 'cook' -> 'worker id' ) ).		"Manager knows how to contact this worker."	self assert:  ( ( manager actorURI at: ('worker id') ) sameAs: ('worker uri')  ).			! !!HumRunTimeTests methodsFor: 'Actor Tests' stamp: 'RichardAlexanderGreen 2/13/2012 09:24'!test120workerCheckInMessage	"Worker checks-in, announcing roles."	"The check-in protocol has the worker-side and the resource manager side."	"Worker says:	. Manager: Check-in worker W with roles R.	The manager adds the worker to its (role -> worker) knowledge."	|  worker manager message |		"Get the worker from the setup."	worker := setupWorker.	self assert: ( worker isKindOf: HumActor ).	self assert: ( worker roles include: 'cook' ).		"Get the resource manager from the setup."	manager := setupManager.	self assert: ( manager isKindOf: HumResourceManager ).	"Use a Smalltalk coded message to tell manager."	"To: Execute the check-in directly, we would say:"	"manager checkInActor: worker name at: 'worker uri' withRoles: worker roles."		message := 'self checkInActor: ', ('worker id') quoted, ' at: ', ('worker uri') quoted, ' withRoles: #(', ('cook') quoted, ').'.	Compiler evaluate: message for: manager logged: false.		"Manager now includes worker in set of those who know that role."	self assert: ( manager roleActor includes: ( 'cook' -> 'worker id' ) ).		"Manager knows how to contact this worker."	self assert:  ( ( manager actorURI at: ('worker id') ) sameAs: ('worker uri')  ).! !!HumRunTimeTests methodsFor: 'Actor Tests' stamp: 'RichardAlexanderGreen 2/13/2012 09:53'!test130workerChecksInViaMessenger	"Worker checks-in, announcing roles."	"The check-in protocol has the worker-side and the resource manager side."	"Worker says:	. Manager: Check-in worker W with roles R.	The manager adds the worker to its (role -> worker) knowledge."	|  worker manager |		"Get the worker from the setup."	worker := setupWorker.	self assert: ( worker isKindOf: HumActor ).	self assert: ( worker uri sameAs:  'mock cook URI'  ).	self assert: ( worker id  sameAs: 'test worker').	self assert: ( worker roles = ( #( 'cook' )  )   ).	self assert: ( worker roles include: 'cook' ).		"Get the resource manager from the setup."	manager := setupManager.	self assert: ( manager isKindOf: HumResourceManager ).	"Tell the worker to check-in."	worker checkIn.		"Manager now includes worker in set of those who know that role."	self assert: ( manager roleActor includes: ( 'cook' -> worker id ) ).		"Manager knows how to contact this worker."	self assert:  ( ( manager actorURI at: ( worker id ) ) sameAs: ( worker uri )  ).! !!HumRunTimeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/13/2012 15:23'!aReadMe	"See the class description for the intended (future) tests."	^'See the class description for the intended (future) tests.'	! !!HumRunTimeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/8/2012 20:27'!expect: actualValue is: expectedValue 	""	^ self		assert: (expectedValue = actualValue)		description: ( self comparingStringBetween: expectedValue and: actualValue ).! !!HumRunTimeTests methodsFor: 'WorldBase Tests' stamp: 'RichardAlexanderGreen 10/12/2012 10:28'!test610CreateWorldBaseInstance	"Create an instance of a Hum World Base (a database to be shared by multiple actors)."	| worldBase |	worldBase := HumWorldBase openWorldBase: 'Instance for Hum Run Time Tests'.	self assert: worldBase notNil.	self assert: ( worldBase title = 'Instance for Hum Run Time Tests' ).! !TestCase subclass: #HumOntologyTranslatorTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumOntologyTranslatorTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/28/2013 09:58'!test110AttachMethodToClass	"Attach a method to a class."	| translator aMethodName aClassName aSource |	translator := HumOntologyTranslator new.	"Example in Java syntax with Hum accounting"	aSource := '			/** Move portable-object to location. */		public Expense movePortableObjectToLocation( Entity portableObject, Entity location ) {			// TBD - The body of the method goes here.			Timer timer = new Timer.start();			timer.tick( self.randomDuration() );  // Fuzzy number for simulation.			return new Expense( self.class(), self.id(), timer.stop() );		}						'.	aMethodName := 'Move portable-object to location.'.	aClassName := 'MaterialTransporter'.	translator attachMethodNamed: aMethodName toClass: aClassName fromSource: aSource.! !!HumOntologyTranslatorTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2013 07:28'!test111GetMethodsForClass	"Attach a method and get it back."	| translator aMethodName aClassName aSource methods source |	translator := HumOntologyTranslator new.	"Example in Java syntax with Hum accounting"	aSource := '			/** Move portable-object to location. */		public Expense movePortableObjectToLocation( Entity portableObject, Entity location ) {			// TBD - The body of the method goes here.			Timer timer = new Timer.start();			timer.tick( self.averageDuration() );  // Use average duration for fairness.			return new Expense( self.class(), self.id(), timer.stop() );		}						'.	aMethodName := 'Move portable-object to location.'.	aClassName  := 'MaterialTransporter'.	translator attachMethodNamed: aMethodName toClass: aClassName fromSource: aSource.		"Now get it back."	methods := translator getMethodsForClass: aClassName.	self assert: ( methods size = 1 ).	source := methods at: aMethodName.	self assert: aSource equals: source.	! !TestCase subclass: #HumByteCodeTests	instanceVariableNames: 'humVM'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumByteCodeTests commentStamp: 'RichardAlexanderGreen 7/26/2012 12:02' prior: 0!After a bit of experimentation with these tests, I have decided that the HumVM is not a worthwhile feature.Basically, the code and effort required to load the slots will overwhelm any savings in code space by compressing to byte code.I had also thought that byte code would simplify translation to multiple languages, but I don't see that working out either.'!!HumByteCodeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 7/26/2012 10:07'!setUp	"For convenience, create a Hum VM instance for all of the tests to use."		humVM := HumVM new.! !!HumByteCodeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 9/20/2012 07:37'!test110EachInstructionHasTwoBytes	"A Hum byte code instruction has two bytes -- one for operation and one for operand."	| instruction |	instruction := HumVMInstruction new.	instruction operation: 255.	instruction operand: 254.	self assert: 255 equals: ( instruction operation).	self assert: 254 equals: ( instruction operand).	! !!HumByteCodeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 9/20/2012 07:37'!test120OpCode000IsHalt	"An opCode of 000 is a halt instruction. (operand is ignored)"	| instruction |	instruction := HumVMInstruction opCode: 000 value: 000.	self assert: 'Halt' equals: ( instruction opCodeName ).! !!HumByteCodeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 9/20/2012 07:37'!test130Operand000IsNone	"An operand index of zero is treated as None.	(For some operators, this will be nonsence and should not compile.)"	| instruction |	instruction := HumVMInstruction opCode: 000 value: 000.	self assert: 'None' equals: instruction slotName. ! !!HumByteCodeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 9/20/2012 07:37'!test210MeasureLoad	"Load measure into measure-arithmetic register."	| instruction measure |	measure := (HumMeasure quantity: 210 units: 'meters').	humVM setSlot: 001 to: measure.	instruction := HumVMInstruction opCode: 001 value: 001.	humVM run: instruction.	self assert: ( humVM measureRegister ) equals: measure.! !!HumByteCodeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 9/20/2012 07:37'!test220MeasureAdd	"Add measure into measure-arithmetic register."	| instruction measureA measureB measureC |		"First load a measure into the register."	measureA := HumMeasure quantity: 220 units: 'meters'.	humVM setSlot: 001 to: measureA.	instruction := HumVMInstruction opCode: 001 value: 001.	humVM run: instruction.	self assert: ( humVM measureRegister ) equals: measureA.		"Add another measure into the register."	measureB := HumMeasure quantity: 330 units: 'meters'.	humVM setSlot: 002 to: measureB.	instruction := HumVMInstruction opCode: 002 value: 002.	humVM run: instruction.		measureC := HumMeasure quantity: 550 units: 'meters'.	self assert: ( humVM measureRegister ) equals: measureC.	! !!HumByteCodeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 9/20/2012 07:37'!test230MeasureMinus	"Add measure into measure-arithmetic register."	| instructionA instructionB measureA measureB measureC |		"First load a measure into the register."	measureA := HumMeasure quantity: 330 units: 'meters'.	humVM setSlot: 001 to: measureA.	instructionA := HumVMInstruction opCode: 001 value: 001.	humVM run: instructionA.	self assert: ( humVM measureRegister ) equals: measureA.		"Subtract another measure from the register."	measureB := HumMeasure quantity: 220 units: 'meters'.	humVM setSlot: 002 to: measureB.	instructionB := HumVMInstruction opCode: 003 value: 002.	humVM run: instructionB.		measureC := HumMeasure quantity: 110 units: 'meters'.	self assert: ( humVM measureRegister ) equals: measureC.	! !TestCase subclass: #GivenWhenThen	instanceVariableNames: 'log givenBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!GivenWhenThen commentStamp: 'RichardAlexanderGreen 2/19/2013 10:53' prior: 0!This is an implementation of Given-When-Then (behavior driven development) style of testing.Note: Methods are duplicated under HumSeasideTests because I did not want to deal with Pharo "traits" and Smalltalk does not support multiple inheritance.!!GivenWhenThen methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 11:06'!assertString: stringA includesSubstring: stringB	 " stringB should be a substring in stringA "	| quote x |	quote := $' asString.	x := stringA findString: stringB.	self assert: (x > 0) description: 'Expecting ', quote, stringA, quote, ' contains ', quote, stringB, quote.! !!GivenWhenThen methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 10:50'!given: aDescriptionString code: aBlock	"Given in a given-when-then triplet 	-- use to setup test context (initial state).	The code may contain asserts to self-check.	"	self log:  ( String cr, 'Given: ', aDescriptionString ).	"Save the block so that multiple *when* can restore initial state before running."	givenBlock := aBlock.	^self.	! !!GivenWhenThen methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 10:46'!givenWhenThenComment	"The #given:code: and #when:code: and #then:code: methods are designed to be cascaded.	Note that #when:code: runs the block provided in the call to #given:code: to set-up initial condition.	That enables multiple *when-then* sequences to run even if they might interfere with each other.	However, you still need to be careful of side-effects.	"	^ 'The #given:code: and #when:code: and #then:code: methods are designed to be cascaded.	Note that #when:code: runs the block provided in the call to #given:code: to set-up initial condition.	That enables multiple *when-then* sequences to run even if they might interfere with each other.	However, you still need to be careful of side-effects.'! !!GivenWhenThen methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 10:46'!log	^ log ifNil: [ log := OrderedCollection new. ].! !!GivenWhenThen methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 10:47'!log: aString	| entry |	"Prepend a CR to make inspection more readable."	( aString beginsWith: (String cr) )		ifTrue: [ entry := aString ] ifFalse: [ entry := String cr, aString ].	( self log ) add: aString.! !!GivenWhenThen methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 10:48'!then: aDescriptionString code: aBlock	"*Then* in a given-when-then triplet 	-- Use to test post-condition after the given and then have run.	The code may contain asserts to self-check.	"	self log:  ( 'Then: ', aDescriptionString ).	"Run my assertions."	aBlock value.	^self.	! !!GivenWhenThen methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 11:02'!when: aDescriptionString code: whenBlock	"*When* in a given-when-then triplet 	-- Use to trigger events or add to state.	The code may contain asserts to self-check.	"	"Run the given block to reset to initial state.	This enables a sequence such as: Given, When, Then, When, Then.	It allows the When blocks to create contradicting states.	"	givenBlock value.	"Now run my block"	self log:  ( 'When: ', aDescriptionString, String cr ).	whenBlock value.	^self.	! !!GivenWhenThen methodsFor: 'self test' stamp: 'RichardAlexanderGreen 2/19/2013 10:58'!test105GivenWhenThenSuccess	"Test the test utility - In this situation the test assertion is true."	| test x y z |	test := self class basicNew.	"A typical test looks like this."		test		given: 'given description' code: [ x:= 'given set'];		when: 'when description'  code: [ y := 'when set'];		then: 'then description' code: [ z := 'then set'. self assert: (true) ].	"Blocks should have executed."	self assert: ( x sameAs: 'given set' ).	self assert: ( y sameAs: 'when set' ).	self assert: ( z sameAs: 'then set' ).		! !!GivenWhenThen methodsFor: 'self test' stamp: 'RichardAlexanderGreen 2/19/2013 10:58'!test106GivenWhenThenFail	"Test the test utility - In this situation the test assertion is true."	| test x y z |	test := self class basicNew.	"Normally, this test is not needed."	false ifFalse: [^self].	test := self class basicNew.		"A typical test looks like this."		test		given: 'given description' code: [ x:= 'given set'];		when: 'when description'  code: [ y := 'when set'];		"Following should show assertion fails."		then: 'then description' 			code: [ z := 'then set'. 							self assert: (false).							 ].		! !!GivenWhenThen methodsFor: 'self test' stamp: 'RichardAlexanderGreen 2/19/2013 10:48'!test110BasicLog	"Test the testcase`s own log"	| test |	test := HumSeasideTests new.	test log: 'This is only a test'.	self assert: ( (test log at: 1 ) sameAs: 'This is only a test' ).! !!GivenWhenThen methodsFor: 'self test' stamp: 'RichardAlexanderGreen 2/19/2013 10:59'!test120GivenWhenThenLogging	"Test the testcase`s own log"	| test x y z |	test := self class basicNew.	"A typical test looks like this."		test		given: 'given description' code: [ x:= 'given set'];		when: 'when description'  code: [ y := 'when set'];		then: 'then description' code: [ z := 'then set'. self assert: (true) ].	"The log should contain the descriptions."	self assertString: ( test log at: 1 ) includesSubstring: 'given description'.		self assertString: ( test log at: 2 ) includesSubstring: 'when description'.		self assertString: ( test log at: 3 ) includesSubstring: 'then description'.			! !TestCase subclass: #HumProgrammersAssistantTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumProgrammersAssistantTests commentStamp: 'RichardAlexanderGreen 1/2/2012 14:42' prior: 0!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Programmer Assistant (PA) User-Dialogs%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%A. Ontology Actions   1. New ontology.   2. Save ontology on file. (Save As on new file)   3. Load ontology from file(futures:)   4. Merge ontology from (TBD: file or another PA).   5. Test run ontology.   6. Deploy ontology?  (??? What does ‘deploy’ portend ???)B. Frame Editor Actions   1. Usual text edit actions:      a) commands: (copy, cut, paste, un-do, save, open, print?, close window)      b) cursor moves: (up, down, left, right, top, bottom, . . .)   2. PA-specific actions:      a) [Line updated] event causes the logical-line and frame to be checked.         (1) The logical-line is rendered. 	           Keywords and nouns are emphasized. Nouns have links.          (2) If the logical-line is not understood (no definition in ontology or DSL),                the line is flagged (with a question-mark).         (3) If a noun lacks an antecedent in the frame, the noun is flagged (color code).      b) [Insert/Append Instruction] - Instructions are indented.         (1) In an action frame,                the automatic indent matches the preceding statement’s indent                unless it was a control statement (ending with a colon).                   And then, the indentation is increased by one.         (2) In plan and dialog frames,                instructions have only one level of indent                because control statements are not allowed in those contexts.         (3) In dialog frames,                the user indicates an instruction by starting the line with dot [tab].      c) [Submit frame] command causes the ontology to be          (1) updated.         (2) versioned.         (3) re-evaluated. (problems flagged)         (4) re-displayed. (all views rebuilt)      d) [Test Dialog] - in dialog run-time with mock agents.!!HumProgrammersAssistantTests methodsFor: 'PA100 Ontology Actions' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!storeInOntology: aHumOntology fromFrameEditor: frameEditor1	| frame1 identifier frameEditor2 frame2 frameEditor3 frame3 |		"The frame editor receives the command to store the frame from the user interface (Scribe)."	frameEditor1 storeFrameInOntology.	"The frame will now have a uniqueIdentifier."	frame1 := frameEditor1 frame.	self assert: ( frame1 isKindOf: HumFrame ).	identifier := frame1 uniqueIdentifier.	self assert: ( identifier isKindOf: UUID ).	"We can use the identifier to fetch the frame into another frameEditor."	frameEditor2 := HumFrameEditor ontology: aHumOntology loadFrameByIdentifier: identifier.	self assert: (frameEditor2 isKindOf: HumFrameEditor ).	"Check the content."	frame2 := frameEditor2 frame.	self assert: ( frame2 isKindOf:  (frame1 class) ).	self assert: ( frame1 titleLine = frame2 titleLine ).	self assert: ( frame1 titleLine sameAs: frame2 titleLine ).	self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).	self assert: ( frame1 frameLines at: 1) = ( frame2 frameLines at: 1 ).	self assert: (( frame1 frameLines at: 1) sameAs: ( frame2 frameLines at: 1 )).		frameEditor3 := HumFrameEditor ontology: aHumOntology loadFrameByName: (frame1 frameName).	self assert: (frameEditor2 isKindOf: HumFrameEditor ).	"Check the content."	frame3 := frameEditor3 frame.	self assert: ( frame3 isKindOf:  (frame1 class) ).	self assert: ( frame1 titleLine = frame3 titleLine ).	self assert: ( frame1 titleLine sameAs: frame3 titleLine ).	self assert: ( frame1 frameLines size ) = ( frame3 frameLines size ).	self assert: ( frame1 frameLines at: 1) = ( frame3 frameLines at: 1 ).	self assert: (( frame1 frameLines at: 1) sameAs: ( frame3 frameLines at: 1 )).	! !!HumProgrammersAssistantTests methodsFor: 'PA100 Ontology Actions' stamp: 'RichardAlexanderGreen 12/8/2012 11:03'!test110newOntology	"PA initializes (re-initializes) to an empty ontology."	| zPA |	zPA := HumProgrammersAssistant new.	zPA clearOntology.	self assert: (zPA ontology nouns isEmpty).! !!HumProgrammersAssistantTests methodsFor: 'PA100 Ontology Actions' stamp: 'RichardAlexanderGreen 12/8/2012 11:03'!test120saveOntology	"PA saves (writes) the ontology to a file."	| zPA |	zPA := HumProgrammersAssistant new.	zPA clearOntology.	zPA saveOntologyOnFileNamed: 'HumPA-test.ontology'.	! !!HumProgrammersAssistantTests methodsFor: 'PA100 Ontology Actions' stamp: 'RichardAlexanderGreen 12/8/2012 11:02'!test130loadOntology	"PA loads (reads) the ontology fram a file where it was saved previously."	| zPA |	zPA := HumProgrammersAssistant new.	zPA clearOntology.	zPA saveOntologyOnFileNamed: 'HumPA-test.ontology'.	zPA loadOntologyFromFileNamed: 'HumPA-test.ontology'.	! !!HumProgrammersAssistantTests methodsFor: 'PA100 Ontology Actions' stamp: 'RichardAlexanderGreen 9/15/2012 10:58'!test341getOneWidget	"The frame editor instance knows what kind of frame it is editing.	"	|  markupLine widgets |	markupLine :=  HumMarkupLine source: 'This string contains a widget between brackets: [widget-content]'.	widgets := markupLine widgets.		self assert: ( widgets includes: '[widget-content]')		! !!HumProgrammersAssistantTests methodsFor: 'PA100 Ontology Actions' stamp: 'RichardAlexanderGreen 9/15/2012 10:58'!test342getTwoWidgets""	| markupLine widgets |	markupLine :=  HumMarkupLine 						source: 'This string contains two widgets between brackets: [widget-content-1] and also [widget-content-2]'.	widgets := markupLine widgets.		self assert: ( widgets includes: '[widget-content-1]').	self assert: ( widgets includes: '[widget-content-2]').	! !!HumProgrammersAssistantTests methodsFor: 'pa210 Create frame' stamp: 'RichardAlexanderGreen 11/7/2012 11:36'!test220createFrame4Plan	"Test a plan frame (goal frame).	---	Goal: Cake is baked according to recipe.	Preconditions:	. Oven is preheated to the temperature given in the recipe.	. The recipe`s batter is in a prepared cake pan.	Action:	. Oven: Bake the pan in the oven for the time given in the recipe.	---	"	| frameEditor ontology |	ontology := HumOntology new.		"Initialize for a Plan Frame."	frameEditor := HumFrameEditor ontology: ontology goal: 'Cake is baked according to recipe.'.	"Append precondition lines."	frameEditor addPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameEditor addPrecondition: 'The recipe`s batter is in a prepared cake pan.'.	"Finish with action statement."	frameEditor addActionRole: 'Oven' statement: 'Bake the pan in the oven for the time given in the recipe.' .		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Plan ).		self assert: (frameEditor frame frameLines size = 3 ).	! !!HumProgrammersAssistantTests methodsFor: 'pa210 Create frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test230createFrame4Action	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameEditor ontology: ontology  	                                               role: 'Role' action: 'Bake the pan in the oven for the time given in the recipe.'.	"Append instruction lines."	frameEditor addInstructionStatement: 'Open the oven door.'.	frameEditor addInstructionStatement: 'Place the pan in the oven.'.	frameEditor addInstructionStatement: 'Close the oven door.'.	"Append an instruction that is delegated"	frameEditor addInstructionRole: 'Oven' statement: 'Bake for the time given.'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Action ).				self assert: ( frameEditor frame frameLines size = 4 ).		! !!HumProgrammersAssistantTests methodsFor: 'pa210 Create frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test240createFrame4View	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology |	ontology := HumOntology new.		"Initialize for a View Frame."	frameEditor := HumFrameEditor ontology: ontology viewEntity: 'recipe.'.	"Add markup lines."	frameEditor addMarkUp: '!!!! Recipe'.	frameEditor addMarkUp: ' recipe-name: [name]'.	frameEditor addMarkUp: '   description: [description 5]'.	frameEditor addMarkUp: '   ingredients: [ingredients]'.	frameEditor addMarkUp: '            steps: [steps]'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4View ).	! !!HumProgrammersAssistantTests methodsFor: 'pa210 Create frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test250createFrame4Dictionary	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameEditor := HumFrameEditor ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	"Add dictionary lines."	"attributes"	frameEditor addDictionaryLine: 'Recipe attributes include recipe-name, description, ingrediants steps.'.	"set collection"	frameEditor addDictionaryLine: 'Recipe includes a set of ingrediants.'.	"list collection"	frameEditor addDictionaryLine: 'Recipe includes a list of steps.'.	"Attribute used in  set above is an entity with its own attributes. Entities are members of set."	frameEditor addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	"Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"	frameEditor addDictionaryLine: 'Step attributes include step-number, step-description'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Dictionary ).	! !!HumProgrammersAssistantTests methodsFor: 'pa210 Create frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test260createFrame4Vignette	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameEditor := HumFrameEditor ontology: ontology vignetteContext: 'hello' pattern: 'Knock, knock.'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Vignette ).	! !!HumProgrammersAssistantTests methodsFor: 'pa210 Create frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test261updateFrame4Vignette	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameEditor := HumFrameEditor ontology: ontology vignetteContext: 'Expecting Hello.' pattern: 'Knock, knock.'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Vignette ).		"Add response lines."	"There are two kinds of resonse, verbal responses and actions."	frameEditor addVignetteResponse: 'Who is there?'.	frameEditor addVignetteInstruction: 'Next context "Expecting who.".'.		self assert: ( ( frameEditor frame responseLines at: 1) sameAs:  ( HumMarkupLine source: 'Who is there?' ) ).	self assert: ( ( frameEditor frame frameLines at: 1) sameAs:  ( HumMarkupLine source: 'Who is there?' ) ).		self assert: ( ( frameEditor frame instructionLines at: 1) sameAs:  ( HumInstructionLine statement: 'Next context "Expecting who.".' ) ).	self assert: ( ( frameEditor frame frameLines at: 2) sameAs:  ( HumInstructionLine statement: 'Next context "Expecting who.".' ) ).							! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test320critiqueFrame4Plan	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology errors |	ontology := HumOntology new.	"Initialize for a Plan Frame."	frameEditor := HumFrameEditor ontology: ontology goal: 'Cake is baked according to recipe..'.	"Append precondition lines."	frameEditor addPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameEditor addPrecondition: 'The recipe`s batter is in a prepared cake pan.'.	"Finish with action statement."	frameEditor addActionRole: 'Oven' statement: 'Bake the pan in the oven for the time given in the recipe.' .		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Plan ).		"Expect complaints about no nouns."	errors := frameEditor checkFrameSyntax.	self assert: ( errors isEmpty not ).	self assert: ( errors anySatisfy: [ :error | '*no known nouns*' matches: error ] ).	"Expect complaints about preconditions with no plans."	self assert: ( errors anySatisfy: [ :error | '*no plan*' matches: error ] ).		Transcript cr; show: 'Errors: ', errors asString; cr.	! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test321critiqueFrame4Plan	"The frame editor instance knows what kind of frame it is editing.	In this case, every precondition has a noun that traces back to the goal statement.	"	| frameEditor ontology errors |	ontology := HumOntology new.	"Initialize for a Plan Frame."	frameEditor := HumFrameEditor ontology: ontology goal: 'Cake is baked according to recipe..'.	"Append precondition lines."	frameEditor addPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameEditor addPrecondition: 'The recipe`s batter is in a prepared cake pan.'.	"Finish with action statement."	frameEditor addActionRole: 'Oven' statement: 'Bake the pan in the oven for the time given in the recipe.' .		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Plan ).		"Every line has recipe as a noun."	ontology addNouns: #( 'recipe' ).		"Expect no complaints about no nouns. "	errors := frameEditor checkFrameSyntax.	self assert: ( errors count: [ :error | '*no nouns*' matches: error ]  ) = 0.	! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test322critiqueFrame4PlanMissingAntecedant	"The frame editor instance knows what kind of frame it is editing.	In this case, one or more preconditions have a noun with no antecedant in the goal statement.	"	| frameEditor ontology errors |	ontology := HumOntology new.	"Initialize for a Plan Frame."	frameEditor := HumFrameEditor ontology: ontology goal: 'Cake is baked according to recipe..'.	"Append precondition lines."	frameEditor addPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameEditor addPrecondition: 'The recipe`s batter is in a prepared cake pan.'.	"Finish with action statement."	frameEditor addActionRole: 'Oven' statement: 'Bake the pan in the oven for the time given in the recipe.' .		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Plan ).		"Every line has recipe as a noun."	ontology addNouns: #( 'recipe' 'pan' ).		"Expect no complaints about no nouns. "	errors := frameEditor checkFrameSyntax.	self assert: ( errors count: [ :error | '*no antecedant*' matches: error ]  ) > 0.	! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test330critiqueFrame4Action	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology errors |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameEditor ontology: ontology  	                                               role: 'Role' action: 'Bake the pan in the oven for the time given in the recipe.'.	"Append instruction lines."	frameEditor addInstructionStatement: 'Open the oven door.'.	frameEditor addInstructionStatement: 'Place the pan in the oven.'.	frameEditor addInstructionStatement: 'Close the oven door.'.	"Append an instruction that is delegated"	frameEditor addInstructionRole: 'Oven' statement: 'Bake for the time given in the recipe.'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Action ).		self assert: ( frameEditor frame frameLines size = 4 ).			"Expect  complaints about no nouns on every line because the ontology has not been informed."	errors := frameEditor checkFrameSyntax.	"Check the simple instructions."	self assert: (errors includes: 'Statement: {Open the oven door.} has no known nouns!!' ).	self assert: (errors includes: 'Statement: {Place the pan in the oven.} has no known nouns!!').	self assert: (errors includes: 'Statement: {Close the oven door.} has no known nouns!!' ).	"Check the last one - It is delegated."	self assert: (errors includes: 'Statement: {Bake for the time given in the recipe.} has no known nouns!!' ).	"The action line should have nouns too."	self assert: (errors includes: 'Action statement {Bake the pan in the oven for the time given in the recipe.} has no known nouns!!' ).			self assert: ( errors count: [ :error | '*no known nouns*' matches: error] ) = 5.		! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test331critiqueFrame4Action	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology errors |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameEditor ontology: ontology  	                                               role: 'Role' action: 'Bake the pan in the oven for the time given in the recipe.'.	"Append instruction lines."	frameEditor addInstructionStatement: 'Open the oven door.'.	frameEditor addInstructionStatement: 'Place the pan in the oven.'.	frameEditor addInstructionStatement: 'Close the oven door.'.	"Append an instruction that is delegated"	frameEditor addInstructionRole: 'Oven' statement: 'Bake for the time given.'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Action ).		ontology addNouns: #( 'recipe' 'oven').		"Still expect one complaints about no nouns on the last line."	errors := frameEditor checkFrameSyntax.	self assert: ( errors count: [ :error | '*no known nouns*' matches: error ] ) = 1.		! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test332critiqueFrame4ActionForAntecedants	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology errors |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameEditor ontology: ontology  	                                               role: 'Role' action: 'Bake the pan in the oven for the time given in the recipe.'.	"Append instruction lines."	frameEditor addInstructionStatement: 'Open the oven door.'.	frameEditor addInstructionStatement: 'Place the pan in the oven.'.	frameEditor addInstructionStatement: 'Close the oven door.'.	"Append an instruction that is delegated"	frameEditor addInstructionRole: 'Oven' statement: 'Bake for the time given.'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Action ).		ontology addNouns: #( 'recipe' 'oven').		"Still expect one complaints about no nouns on the last line."	errors := frameEditor checkFrameSyntax.	self assert: ( errors count: [ :error | '*no known nouns*' matches: error ] ) = 1.		"Check for antecedants - Happy path: 'door' is not a noun and needs no antecedant."	self assert: ( errors count: [: error | '*no antecedant*' matches: error ] ) = 0.		"But if we make door a noun, it will now lack an antecedant."	ontology addNoun: 'door'.	errors := frameEditor checkFrameSyntax.	self assert: ( errors count: [: error | '*no antecedant*' matches: error ] ) = 2.			! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 9/24/2012 17:48'!test345critiqueFrame4View	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology errors testMe |		"Turn this off for now."	testMe := true.	testMe ifFalse: [ Transcript cr; show: 'test345critiqueFrame4View is turned off.'; cr. ^self].		ontology := HumOntology new.		"Initialize for a View Frame."	frameEditor := HumFrameEditor ontology: ontology viewEntity: 'recipe.'.	"Add markup lines."	frameEditor addMarkUp: '!!!! Recipe'.	frameEditor addMarkUp: ' recipe-name: [name]'.	frameEditor addMarkUp: '   description: [description 5]'.	frameEditor addMarkUp: '   ingredients: [ingredients]'.	frameEditor addMarkUp: '            steps: [steps]'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4View ).			"Expect complaints about no nouns."	errors := frameEditor checkFrameSyntax.	self assert: ( errors isEmpty not ).		self assert: (errors size = 4 ).		"Transcript show: errors; cr."	! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test346critiqueFrame4View	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology errors testMe |		"Turn this off for now."	testMe := true.	testMe ifFalse: [ Transcript cr; show: 'test345critiqueFrame4View is turned off.'; cr. ^self].		ontology := HumOntology new.		"Initialize for a View Frame."	frameEditor := HumFrameEditor ontology: ontology viewEntity: 'recipe.'.	"Add markup lines."	frameEditor addMarkUp: '!!!! Recipe'.	frameEditor addMarkUp: ' recipe-name: [name]'.	frameEditor addMarkUp: '   description: [description 5]'.	frameEditor addMarkUp: '   ingredients: [ingredients]'.	frameEditor addMarkUp: '            steps: [steps]'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4View ).		ontology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).			"Expect no complaints about no nouns."	errors := frameEditor checkFrameSyntax.	self assert: ( errors isEmpty  ).		"Transcript show: errors; cr."	! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test350critiqueFrame4Dictionary	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology errors |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameEditor := HumFrameEditor ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	"Add dictionary lines."	"attributes"	frameEditor addDictionaryLine: 'Recipe attributes include recipe-name, description, ingrediants steps.'.	"set collection"	frameEditor addDictionaryLine: 'Recipe includes a set of ingrediants.'.	"list collection"	frameEditor addDictionaryLine: 'Recipe includes a list of steps.'.	"Attribute used in  set above is an entity with its own attributes. Entities are members of set."	frameEditor addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	"Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"	frameEditor addDictionaryLine: 'Step attributes include step-number, step-description'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Dictionary ).					"Expect complaints about no nouns."	errors := frameEditor checkFrameSyntax.	self assert: ( errors isEmpty not ).		self assert: (errors size = 5 ).		"Transcript  cr; show: errors; cr."	! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test351critiqueFrame4Dictionary	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology errors |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameEditor := HumFrameEditor ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	"Add dictionary lines."	"attributes"	frameEditor addDictionaryLine: 'Recipe attributes include recipe-name, description, ingrediants steps.'.	"set collection"	frameEditor addDictionaryLine: 'Recipe includes a set of ingrediants.'.	"list collection"	frameEditor addDictionaryLine: 'Recipe includes a list of steps.'.	"Attribute used in  set above is an entity with its own attributes. Entities are members of set."	frameEditor addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	"Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"	frameEditor addDictionaryLine: 'Step attributes include step-number, step-description'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Dictionary ).		ontology addNouns: #( 'recipe' 'name' 'description' 'ingredient' 'step' ).				"Expect no complaints about no nouns."	errors := frameEditor checkFrameSyntax.	self assert: ( errors isEmpty  ).		self assert: (errors size =0 ).		"Transcript  cr; show: errors; cr."	! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 10/6/2012 10:27'!test361critiqueFrame4Vignette	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor1 frameEditor2 frameEditor3 ontology errors1 errors2 errors3 |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameEditor1 := HumFrameEditor ontology: ontology vignetteContext: 'Expecting Hello.' pattern: 'Knock, knock.'.	frameEditor1 addVignetteResponse: 'Who is there?'.	frameEditor1 nextVignetteContext: 'Expecting first name.'.	errors1 := frameEditor1 checkFrameSyntax.	self assert: (errors1 isEmpty ) not.	 	frameEditor2 := HumFrameEditor ontology: ontology vignetteContext: 'Expecting first name.' pattern: '[first-name]'.	frameEditor2 addVignetteResponse: '[first-name] who?'.	frameEditor2 nextVignetteContext: 'Expecting whole-name.'.	errors2 := frameEditor2 checkFrameSyntax.	self assert: (errors2 isEmpty ) not.			frameEditor3 :=  HumFrameEditor ontology: ontology vignetteContext: 'Expecting whole-name.' pattern: '[first-name] [last-name]'.	frameEditor3 addVignetteResponse: 'Hello [first-name] [last-name]. What do you want to do?'.	frameEditor3 addVignetteInstruction: 'Ask menu.'.	errors3 := frameEditor3 checkFrameSyntax.	self assert: (errors3 isEmpty ) not.		ontology addNouns: #( 'name' 'first-name' 'last-name' 'menu' ).		frameEditor1 saveFrameToOntology: ontology.	frameEditor2 saveFrameToOntology: ontology.	frameEditor3 saveFrameToOntology: ontology.		errors1 := frameEditor1 checkFrameSyntax.	self assert: (errors1 isEmpty ).		errors2 := frameEditor2 checkFrameSyntax.	self assert: (errors2 isEmpty ).		errors3 := frameEditor3 checkFrameSyntax.	"{Ask menu.} is not defined in this ontology."	self assert: (errors3 isEmpty ) not.											! !!HumProgrammersAssistantTests methodsFor: 'pa410 Compile frame' stamp: 'RichardAlexanderGreen 10/6/2012 10:27'!test421compileFrame4Plan	"The frame editor instance knows what kind of frame it is editing.	In this context, 'compile' means that the plan frame is inserted into the ontology,	and the frame is checked for problems that would prevent the plan from executing.	"	| frameEditor ontology errors goalSourceString frameIn frameOut  |	ontology := HumOntology new.	"Initialize for a Plan Frame."	goalSourceString := 'Cake is baked according to recipe.'.	frameEditor := HumFrameEditor ontology: ontology goal: goalSourceString.	"Append precondition lines."	frameEditor addPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameEditor addPrecondition: 'The recipe`s batter is in a prepared cake pan.'.	"Finish with action statement."	frameEditor addActionRole: 'Oven' statement: 'Bake the pan in the oven for the time given in the recipe.' .		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Plan ).		"Every line has recipe as a noun."	ontology addNouns: #( 'recipe' ).		"Expect no complaints about no nouns. "	errors := frameEditor checkFrameSyntax.	self assert: ( errors count: [ :error | '*no nouns*' matches: error ]  ) = 0.		errors := frameEditor saveFrameToOntology: ontology.		self assert: (errors size) = 0.		"Now we should see frame in the ontology."	frameIn := frameEditor frame.	frameOut := ontology getPlanFrameForGoal: goalSourceString. 	self assert: ( frameOut = frameIn ).	! !!HumProgrammersAssistantTests methodsFor: 'pa410 Compile frame' stamp: 'RichardAlexanderGreen 10/6/2012 10:27'!test431compileFrame4Action	"The frame editor instance knows what kind of frame it is editing.	In this case, 'compile' means adding the frame to the ontology,	and the syntax checks for problems that would prevent the frame from executing. 	"	| actionSourceString frameEditor ontology errors instructionSequence |	ontology := HumOntology new.		"Initialize for an Action Frame."	actionSourceString :=  'Bake the pan in the oven for the time given in the recipe.'.	frameEditor := HumFrameEditor ontology: ontology role: 'Baker' action:  actionSourceString.	"Append instruction lines."	frameEditor addInstructionStatement: 'Open the oven door.'.	frameEditor addInstructionStatement: 'Place the pan in the oven.'.	frameEditor addInstructionStatement: 'Close the oven door.'.	frameEditor addInstructionStatement: 'Set the oven-temperature per recipe.'.		"Append an instruction that is delegated"	frameEditor addInstructionRole: 'Oven' statement: 'Bake for the baking-time given in the recipe.'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Action ).		ontology addNouns: #( 'recipe' 'oven' 'pan' 'baking-time' 'oven-temperature' ).		errors := frameEditor checkFrameSyntax.	self assert: ( errors count: [ :error | '*no known nouns*' matches: error ] ) = 0.		errors := frameEditor saveFrameToOntology: ontology.		self assert: (errors size) = 7.		"Now we can get the action from the ontology"	self assert: ( ( ontology getRole: 'Baker'  action:  actionSourceString ) isKindOf: HumStatement ).			"Now we can also get the instruction sequence "	instructionSequence := ( ontology instructionsForRole: 'Baker' action: actionSourceString ).	self assert: ( instructionSequence isKindOf: OrderedCollection ).	self assert:( ( instructionSequence at: 1) isKindOf: HumInstructionLine ).		"And the role`s actions includes "	self assert: (( ontology actionsOf: 'Baker' ) include: actionSourceString ).		! !!HumProgrammersAssistantTests methodsFor: 'pa410 Compile frame' stamp: 'RichardAlexanderGreen 10/6/2012 10:27'!test446compileFrame4View	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology errors testMe |		"Turn this off for now."	testMe := true.	testMe ifFalse: [ Transcript cr; show: 'test345critiqueFrame4View is turned off.'; cr. ^self].		ontology := HumOntology new.		"Initialize for a View Frame."	frameEditor := HumFrameEditor ontology: ontology viewEntity: 'recipe.'.	"Add markup lines."	frameEditor addMarkUp: '!!!! Recipe'.	frameEditor addMarkUp: ' recipe-name: [name]'.	frameEditor addMarkUp: '   description: [description 5]'.	frameEditor addMarkUp: '   ingredients: [ingredients]'.	frameEditor addMarkUp: '            steps: [steps]'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4View ).		ontology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).			"Expect no complaints about no nouns."	errors := frameEditor saveFrameToOntology: ontology.	self assert: ( errors isEmpty  ).		"Transcript show: errors; cr."	! !!HumProgrammersAssistantTests methodsFor: 'pa410 Compile frame' stamp: 'RichardAlexanderGreen 10/6/2012 10:27'!test450compileFrame4Dictionary	"In this context, 'compile' means that the ontology will be updated with nouns and their supertypes.	"	| frameEditor ontology errors |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameEditor := HumFrameEditor ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	"Add dictionary lines."	"supertype"	frameEditor addDictionaryLine: 'Description is a text.'.	"attributes"	frameEditor addDictionaryLine: 'Recipe attributes include recipe-name, recipe-description, ingredients, steps.'.	"set collection"	frameEditor addDictionaryLine: 'Recipe includes a set of ingredients.'.	"list collection"	frameEditor addDictionaryLine: 'Recipe includes a list of steps.'.	"Attribute used in  set above is an entity with its own attributes. Entities are members of set."	frameEditor addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	"Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"	frameEditor addDictionaryLine: 'Step attributes include step-number, step-description'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Dictionary ).		errors := frameEditor saveFrameToOntology: ontology.		"There are no syntax errors."	self assert: ( errors isEmpty ).		"Check that ontology has all that stuff."	self assert: (ontology nouns includesAllOf: #( 'recipe' 'recipe-name' 'description' 'ingredient' 'step' 'ingredient-name' 'quantity' 'alternate-ingredient' 'step-number' 'step-description' )).		"Check that the supertypes are recorded also."	self assert: (ontology nounSubtypes include: ( 'description' -> 'step-description' )).	self assert: (ontology nounSubtypes include: ( 'ingredient' -> 'alternate-ingredient' )).		"Transcript cr; show: (ontology nounSubtypes); cr."		! !!HumProgrammersAssistantTests methodsFor: 'pa410 Compile frame' stamp: 'RichardAlexanderGreen 10/6/2012 10:27'!test461compileFrame4Vignette	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor1 frameEditor2 frameEditor3 ontology frame1 frame2 frame3 |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameEditor1 := HumFrameEditor ontology: ontology vignetteContext: 'Expecting Hello.' pattern: 'Knock, knock.'.	frameEditor1 addVignetteResponse: 'Who is there?'.	frameEditor1 nextVignetteContext: 'Expecting first name'.	frameEditor1 saveFrameToOntology: ontology.	 	frameEditor2 := HumFrameEditor ontology: ontology vignetteContext: 'Expecting first name.' pattern: '[first-name]'.	frameEditor2 addVignetteResponse: '[first-name] who?'.	frameEditor2 nextVignetteContext: 'Expecting whole-name'.	frameEditor2 saveFrameToOntology: ontology.		frameEditor3 :=  HumFrameEditor ontology: ontology vignetteContext: 'Expecting whole-name.' pattern: '[first-name] [last-name]'.	frameEditor3 addVignetteResponse: 'Hello [first-name] [last-name]. What do you want to do?'.	frameEditor3 addVignetteInstruction: 'Ask menu.'.	frameEditor3 saveFrameToOntology: ontology.		"The ontology should have these frames."	frame1 := frameEditor1 frame.	frame2 := frameEditor2 frame.	frame3 := frameEditor3 frame.	self assert: ( frame1 uniqueIdentifier < frame2 uniqueIdentifier).	self assert: ( frame2 uniqueIdentifier < frame3 uniqueIdentifier ).	self assert: ( ( ontology fetchFrameByIdentifier: ( frame1 uniqueIdentifier  )) = frame1 ).	self assert: ( ( ontology fetchFrameByIdentifier: ( frame2 uniqueIdentifier  )) = frame2 ).	self assert: ( ( ontology fetchFrameByIdentifier: ( frame3 uniqueIdentifier  )) = frame3 ).		""							! !!HumProgrammersAssistantTests methodsFor: 'pa510 Store and fetch frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test510storeFrame	"Store the frame in the given ontology.	The frame may be stored even if it has errors.	"	| frameEditor ontology |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameEditor := HumFrameEditor ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	"Add dictionary lines."	"supertype"	frameEditor addDictionaryLine: 'Description is a text.'.	"attributes"	frameEditor addDictionaryLine: 'Recipe attributes include recipe-name, recipe-description, ingredients, steps.'.	"set collection"	frameEditor addDictionaryLine: 'Recipe includes a set of ingredients.'.	"list collection"	frameEditor addDictionaryLine: 'Recipe includes a list of steps.'.	"Attribute used in  set above is an entity with its own attributes. Entities are members of set."	frameEditor addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	"Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"	frameEditor addDictionaryLine: 'Step attributes include step-number, step-description'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Dictionary ).		"The frame editor receives the command to store the frame from the user interface (Scribe)."	frameEditor storeFrameInOntology.		! !!HumProgrammersAssistantTests methodsFor: 'pa510 Store and fetch frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test520fetchFrameByID	"Store the frame and then get it back using its uniqueIdentifier.	"	| frameEditor1 ontology identifier frameEditor2 frame1 frame2 |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameEditor1 := HumFrameEditor ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	"Add dictionary lines."	"supertype"	frameEditor1 addDictionaryLine: 'Description is a text.'.	"attributes"	frameEditor1 addDictionaryLine: 'Recipe attributes include recipe-name, recipe-description, ingredients, steps.'.	"set collection"	frameEditor1 addDictionaryLine: 'Recipe includes a set of ingredients.'.	"list collection"	frameEditor1 addDictionaryLine: 'Recipe includes a list of steps.'.	"Attribute used in  set above is an entity with its own attributes. Entities are members of set."	frameEditor1 addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	"Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"	frameEditor1 addDictionaryLine: 'Step attributes include step-number, step-description'.		self assert: ( frameEditor1 notNil ).	self assert: ( frameEditor1 frame isMemberOf: HumFrame4Dictionary ).		"The frame editor receives the command to store the frame from the user interface (Scribe)."	frameEditor1 storeFrameInOntology.	"The frame will now have a uniqueIdentifier."	frame1 := frameEditor1 frame.	self assert: ( frame1 isKindOf: HumFrame4Dictionary ).	identifier := frame1 uniqueIdentifier.	self assert: ( identifier isKindOf: UUID ).	"We can use the identifier to fetch the frame into another frameEditor."	frameEditor2 := HumFrameEditor ontology: ontology loadFrameByIdentifier: identifier.	self assert: (frameEditor2 isKindOf: HumFrameEditor ).	"Check the content."	frame2 := frameEditor2 frame.	self assert: ( frame2 isKindOf: HumFrame4Dictionary ).	self assert: ( frame1 titleLine = frame2 titleLine ).	self assert: ( frame1 titleLine sameAs: frame2 titleLine ).	self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).	self assert: ( frame1 frameLines at: 1) = ( frame2 frameLines at: 1 ).	self assert: (( frame1 frameLines at: 1) sameAs: ( frame2 frameLines at: 1 )).		! !!HumProgrammersAssistantTests methodsFor: 'pa510 Store and fetch frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test531fetchFrame4PlanByID	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor1 frameEditor2 ontology errors frame1 frame2 identifier |	ontology := HumOntology new.	"Initialize for a Plan Frame."	frameEditor1 := HumFrameEditor ontology: ontology goal: 'Cake is baked according to recipe..'.	"Append precondition lines."	frameEditor1 addPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameEditor1 addPrecondition: 'The recipe`s batter is in a prepared cake pan.'.	"Finish with action statement."	frameEditor1 addActionRole: 'Oven' statement: 'Bake the pan in the oven for the time given in the recipe.' .		self assert: ( frameEditor1 notNil ).	self assert: ( frameEditor1 frame isMemberOf: HumFrame4Plan ).		"Every line has recipe as a noun."	ontology addNouns: #( 'recipe' ).		"Expect no complaints about no nouns. "	errors := frameEditor1 checkFrameSyntax.	self assert: ( errors count: [ :error | '*no known nouns*' matches: error]  ) = 0.				self assert: ( frameEditor1 notNil ).	self assert: ( frameEditor1 frame isMemberOf: HumFrame4Plan ).		"The frame editor receives the command to store the frame from the user interface (Scribe)."	frameEditor1 storeFrameInOntology.	"The frame will now have a uniqueIdentifier."	frame1 := frameEditor1 frame.	self assert: ( frame1 isKindOf: HumFrame4Plan ).	identifier := frame1 uniqueIdentifier.	self assert: ( identifier isKindOf: UUID ).	"We can use the identifier to fetch the frame into another frameEditor."	frameEditor2 := HumFrameEditor ontology: ontology loadFrameByIdentifier: identifier.	self assert: (frameEditor2 isKindOf: HumFrameEditor ).	"Check the content."	frame2 := frameEditor2 frame.	self assert: ( frame2 isKindOf: HumFrame4Plan ).	self assert: ( frame1 titleLine = frame2 titleLine ).	self assert: ( frame1 titleLine sameAs: frame2 titleLine ).	self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).	self assert: ( frame1 frameLines at: 1) = ( frame2 frameLines at: 1 ).	self assert: (( frame1 frameLines at: 1) sameAs: ( frame2 frameLines at: 1 )).			! !!HumProgrammersAssistantTests methodsFor: 'pa510 Store and fetch frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test532fetchFrame4PlanByTitle	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor1 frameEditor2 ontology errors frame1 frame2 name |	ontology := HumOntology new.	"Initialize for a Plan Frame."	frameEditor1 := HumFrameEditor ontology: ontology goal: 'Cake is baked according to recipe..'.	"Append precondition lines."	frameEditor1 addPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameEditor1 addPrecondition: 'The recipe`s batter is in a prepared cake pan.'.	"Finish with action statement."	frameEditor1 addActionRole: 'Oven' statement: 'Bake the pan in the oven for the time given in the recipe.' .		self assert: ( frameEditor1 notNil ).	self assert: ( frameEditor1 frame isMemberOf: HumFrame4Plan ).		"Every line has recipe as a noun."	ontology addNouns: #( 'recipe' ).		"Expect no complaints about no nouns. "	errors := frameEditor1 checkFrameSyntax.	self assert: ( errors count: [ :error | '*no known nouns*' matches: error] ) = 0.				self assert: ( frameEditor1 notNil ).	self assert: ( frameEditor1 frame isMemberOf: HumFrame4Plan ).		"The frame editor receives the command to store the frame from the user interface (Scribe)."	frameEditor1 storeFrameInOntology.	"The frame will now have a uniqueIdentifier."	frame1 := frameEditor1 frame.	self assert: ( frame1 isKindOf: HumFrame4Plan ).	name := frame1 frameName.	self assert: ( name isKindOf: String ).	"We can use the identifier to fetch the frame into another frameEditor."	frameEditor2 := HumFrameEditor ontology: ontology fetchFrameByName: name.	self assert: ( frameEditor2 isKindOf: HumFrameEditor ).	"Check the content."	frame2 := frameEditor2 frame.	self assert: ( frame2 isKindOf: HumFrame4Plan ).	self assert: ( frame1 titleLine = frame2 titleLine ).	self assert: ( frame1 titleLine sameAs: frame2 titleLine ).	self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).	self assert: ( frame1 frameLines at: 1) = ( frame2 frameLines at: 1 ).	self assert: (( frame1 frameLines at: 1) sameAs: ( frame2 frameLines at: 1 )).			! !!HumProgrammersAssistantTests methodsFor: 'pa510 Store and fetch frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test620storeFrame4Plan	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology |	ontology := HumOntology new.		"Initialize for a Plan Frame."	frameEditor := HumFrameEditor ontology: ontology goal: 'Cake is baked according to recipe..'.	"Append precondition lines."	frameEditor addPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameEditor addPrecondition: 'The recipe`s batter is in a prepared cake pan.'.	"Finish with action statement."	frameEditor addActionRole: 'Oven' statement: 'Bake the pan in the oven for the time given in the recipe.' .		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Plan ).		self assert: (frameEditor frame frameLines size = 3 ).		"Run store and fetch test routine"	self storeInOntology: ontology fromFrameEditor: frameEditor.	! !!HumProgrammersAssistantTests methodsFor: 'pa510 Store and fetch frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test630storeFrame4Action	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameEditor ontology: ontology  	                                               role: 'Role' action: 'Bake the pan in the oven for the time given in the recipe.'.	"Append instruction lines."	frameEditor addInstructionStatement: 'Open the oven door.'.	frameEditor addInstructionStatement: 'Place the pan in the oven.'.	frameEditor addInstructionStatement: 'Close the oven door.'.	"Append an instruction that is delegated"	frameEditor addInstructionRole: 'Oven' statement: 'Bake for the time given.'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Action ).			self assert: ( frameEditor frame frameLines size = 4 ).		"Run store and fetch test routine"	self storeInOntology: ontology fromFrameEditor: frameEditor.		! !!HumProgrammersAssistantTests methodsFor: 'pa510 Store and fetch frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test640storeFrame4View	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology |	ontology := HumOntology new.		"Initialize for a View Frame."	frameEditor := HumFrameEditor ontology: ontology viewEntity: 'recipe.'.	"Add markup lines."	frameEditor addMarkUp: '!!!! Recipe'.	frameEditor addMarkUp: ' recipe-name: [name]'.	frameEditor addMarkUp: '   description: [description 5]'.	frameEditor addMarkUp: '   ingredients: [ingredients]'.	frameEditor addMarkUp: '            steps: [steps]'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4View ).			"Run store and fetch test routine"	self storeInOntology: ontology fromFrameEditor: frameEditor.	! !!HumProgrammersAssistantTests methodsFor: 'pa510 Store and fetch frame' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test650storeFrame4Dictionary	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameEditor := HumFrameEditor ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	"Add dictionary lines."	"attributes"	frameEditor addDictionaryLine: 'Recipe attributes include recipe-name, description, ingrediants steps.'.	"set collection"	frameEditor addDictionaryLine: 'Recipe includes a set of ingrediants.'.	"list collection"	frameEditor addDictionaryLine: 'Recipe includes a list of steps.'.	"Attribute used in  set above is an entity with its own attributes. Entities are members of set."	frameEditor addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	"Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"	frameEditor addDictionaryLine: 'Step attributes include step-number, step-description'.		self assert: ( frameEditor notNil ).	self assert: ( frameEditor frame isMemberOf: HumFrame4Dictionary ).				"Run store and fetch test routine"	self storeInOntology: ontology fromFrameEditor: frameEditor.	! !!HumProgrammersAssistantTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/13/2012 15:24'!aReadMe	"See the class description for the intended (future) tests."	^'See the class description for the intended (future) tests.'	! !TestCase subclass: #HumUserInterfaceTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumUserInterfaceTests commentStamp: 'RichardAlexanderGreen 1/22/2012 08:35' prior: 0!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%USER INTERFACE TEST PLAN%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Assemble user interface from components   =======================================A. Scribe interprets keyboard, mouse, and menu gestures.   1. Keyboard has control or command or option pressed.      a) Conventional commands            (copy, cut, paste, un-do, save, open, print, close window, quit application).      b) Commands defined by the user, menu, or application default preferences.   2. Mouse actions      a) Mouse over. (May cause display.)      b) Mouse button pressed.       c) Mouse moved.      d) Mouse button released. (Buttons invoke commands.)   3. User selects action from menu.      a) Define menu | submenu | toolbar.      b) Respond to user navigation.      c) Send (user-selected) command.B. Painter renders 2-D objects in the user’s viewport.   1. Define billboard in anchored location   2. Define floating billboard in front of camera. (or near mouse cursor).   3. Define window (viewport).   4. Move billboard’s text-cursor (left, right, up, down, jump to).   5. Move billboard to a new anchored location.   6. Draw text on billboard at cursor.           (Side-effect: Cursor moves to end of text).   7. Draw lines and shapes on billboard.           (A diagram may direct the painter.) C. Sculptor renders 3-D objects in the user’s viewport.   1. Define 3-D shapes via      a) rotations.       b) extrusion.      c) cut.      d) fill with material.      e) cover with texture.   2. Common tasks (scripts / macros / routines)      a) Define deck, wall, door, window.      b) Define light.      c) Define room.      d) Place billboard on wall.   3. Create, move, animate avatar.      a) Create avatar.      b) Move avatar.      c) Animate avatar.D. Viewport actions affect a window (viewport).   1. Slide, pan, and zoom viewport.      a) Slice actions are like document-centric scrolling.      b) Pan actions are like rotating a camera up-down, left-right.      c) Zoom actions are like a zoom lens widening or narrowing the field of view             (as if the camera moved, but the camera does not move).   2. Move viewport to a new place in virtual world.      a) Rotate camera (same as pan actions).      b) Step forward | backward.      c) Side-step left | right.      d) Step-Turn left | right.      e) Step up (rise) | down (descend).      f) Move viewport to floor location under cursor.      g) Move viewport to face wall under cursor.!!HumUserInterfaceTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/13/2012 15:24'!aReadMe	"See the class description for the intended (future) tests."	^'See the class description for the intended (future) tests.'	! !!HumUserInterfaceTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/14/2012 20:53'!expect: actualValue is: expectedValue 	""	^ self		assert: ( actualValue = expectedValue)		description: ( self comparingStringBetween: expectedValue and: actualValue ).! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 2/27/2012 14:27'!test210boxHasOrigin	"A box is initialized with a origin object which is zero-sized and at 0,0."	| box |	box := HumBox new.	self assert: ( box origin height = 0 ).	self assert: ( box origin width = 0 ).	self assert: ( box origin length = 0 ).		self assert: ( box origin westEdge = 0 ).	self assert: ( box origin eastEdge = 0 ).		self assert: ( box origin northEdge = 0 ).		self assert: ( box origin southEdge = 0 ).		self assert: ( box origin topEdge = 0 ).		self assert: ( box origin bottomEdge = 0 ).! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 2/27/2012 14:27'!test220boxSizeIsDurable	"A box is initialized with a origin object which is zero-sized and at 0,0."	| box |	box := HumBox new.	box width: 1; height: 1; length: 1.	"Bump box over to the the East by pushing on the West edge."	box westEdge: 1.	self assert: ( box eastEdge = 2 ).	"Bump box up."	box topEdge: 3.	self assert: ( box bottomEdge = 2 ).	"Bump box from bottom."	box bottomEdge: 3.	self assert: ( box topEdge = 4 ).	"Pull box via the East edge."	box eastEdge: 5.	self assert: ( box westEdge = 4 ).	"Bump box to the South by pushing on the North edge."	box northEdge: 7.	self assert: ( box southEdge = 6 ).	"Pull box to the South by pulling on the South edge."	box southEdge: -2.	self assert: ( box northEdge = -1 ).! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 2/27/2012 14:28'!test230boxIsAContainer	"Spaces may contain other spaces. Spaces are container-like."	| container box  |		""	container := HumBox new.	container length: 100; width: 100; height: 100.		box :=( HumBox new ) length: 10; width: 10; height: 10.		container center: box at: #( 20 30 50 ).	self assert: ( box eastEdge = 25 ).	self assert: ( box northEdge = 35 ).	self assert: ( box bottomEdge = 45 ).! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 2/27/2012 14:29'!test240boxLayout	"Spaces may contain other spaces. Spaces are container-like."	| container boxA boxB |		""	container := HumBox new.	container length: 100; width: 100; height: 100.		boxA :=( HumBox new ) length: 10; width: 10; height: 10.	boxB :=( HumBox new ) length: 10; width: 10; height: 10.		container center: boxA at: #( 20 30 50 ).	self assert: ( boxA eastEdge = 25 ).	self assert: ( boxA northEdge = 35 ).	self assert: ( boxA bottomEdge = 45 ).		self assert: ( boxA westEdge = 15 ).	self assert: ( boxA southEdge = 25 ).	self assert: ( boxA topEdge = 55 ).		"Place B on top of A."	container position: boxB onTopOf: boxA.	self assert: ( boxB bottomEdge ) = ( boxA topEdge ).		"Place B under A."	container position: boxB onBottomOf: boxA.	self assert: ( boxB topEdge ) = ( boxA bottomEdge ).		"Place B on East side of A."	container position: boxB eastOf: boxA.	self assert: ( boxB westEdge ) = ( boxA eastEdge ).		"Place B on West side of A."	container position: boxB westOf: boxA.	self assert: ( boxB eastEdge ) = ( boxA westEdge ).		"Place B on North side of A."	container position: boxB northOf: boxA.	self assert: ( boxB southEdge ) = ( boxA northEdge ).		"Place B on South side  of A."	container position: boxB southOf: boxA.	self assert: ( boxB northEdge ) = ( boxA southEdge ).		! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 3/30/2012 19:13'!test250boxCentering	"Spaces may contain other spaces. Spaces are container-like."	| container boxA boxB |		""	container := HumBox new.	container length: 100; width: 100; height: 100.		boxA :=( HumBox new ) length: 20; width: 20; height: 20.	boxB :=( HumBox new ) length: 10; width: 10; height: 10.		"Center B on top of A."	container center: boxB onTopOf: boxA.	self assert: ( boxB center at: 1) = ( boxA center at: 1 ).	self assert: ( boxB center at: 2 ) = (  boxA center at: 2 ).	self assert: ( boxB bottomEdge ) = (  boxA topEdge ).! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 2/27/2012 14:23'!test310spaceHasOrigin	"A space is initialized with a origin object which is zero-sized and at 0,0."	| space |	space := HumSpace new.	self assert: ( space origin height = 0 ).	self assert: ( space origin width = 0 ).	self assert: ( space origin length = 0 ).		self assert: ( space origin westEdge = 0 ).	self assert: ( space origin eastEdge = 0 ).		self assert: ( space origin northEdge = 0 ).		self assert: ( space origin southEdge = 0 ).		self assert: ( space origin topEdge = 0 ).		self assert: ( space origin bottomEdge = 0 ).! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 2/27/2012 14:23'!test320spaceSizeIsDurable	"A space is initialized with a origin object which is zero-sized and at 0,0."	| space |	space := HumSpace new.	space width: 1; height: 1; length: 1.	"Bump space over to the the East by pushing on the West edge."	space westEdge: 1.	self assert: ( space eastEdge = 2 ).	"Bump space up."	space topEdge: 3.	self assert: ( space bottomEdge = 2 ).	"Bump space from bottom."	space bottomEdge: 3.	self assert: ( space topEdge = 4 ).	"Pull space via the East edge."	space eastEdge: 5.	self assert: ( space westEdge = 4 ).	"Bump space to the South by pushing on the North edge."	space northEdge: 7.	self assert: ( space southEdge = 6 ).	"Pull space to the South by pulling on the South edge."	space southEdge: -2.	self assert: ( space northEdge = -1 ).! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 2/27/2012 14:26'!test330spaceContainer	"Spaces may contain other spaces. Spaces are container-like."	| container box  |		""	container := HumSpace new.	container length: 100; width: 100; height: 100.		box :=( HumBox new ) length: 10; width: 10; height: 10.		container center: box at: #( 20 30 50 ).	self assert: ( box eastEdge = 25 ).	self assert: ( box northEdge = 35 ).	self assert: ( box bottomEdge = 45 )! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 2/27/2012 14:25'!test340spaceLayout	"Spaces may contain other spaces. Spaces are container-like."	| container spaceA spaceB |		""	container := HumSpace new.	container length: 100; width: 100; height: 100.		spaceA :=( HumSpace new ) length: 10; width: 10; height: 10.	spaceB :=( HumSpace new ) length: 10; width: 10; height: 10.		container center: spaceA at: #( 20 30 50 ).	self assert: ( spaceA eastEdge = 25 ).	self assert: ( spaceA northEdge = 35 ).	self assert: ( spaceA bottomEdge = 45 ).		self assert: ( spaceA westEdge = 15 ).	self assert: ( spaceA southEdge = 25 ).	self assert: ( spaceA topEdge = 55 ).		"Place B on top of A."	container position: spaceB onTopOf: spaceA.	self assert: ( spaceB bottomEdge ) = ( spaceA topEdge ).		"Place B under A."	container position: spaceB onBottomOf: spaceA.	self assert: ( spaceB topEdge ) = ( spaceA bottomEdge ).		"Place B on East side of A."	container position: spaceB eastOf: spaceA.	self assert: ( spaceB westEdge ) = ( spaceA eastEdge ).		"Place B on West side of A."	container position: spaceB westOf: spaceA.	self assert: ( spaceB eastEdge ) = ( spaceA westEdge ).		"Place B on North side of A."	container position: spaceB northOf: spaceA.	self assert: ( spaceB southEdge ) = ( spaceA northEdge ).		"Place B on South side  of A."	container position: spaceB southOf: spaceA.	self assert: ( spaceB northEdge ) = ( spaceA southEdge ).		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 1/20/2012 15:21'!test110surfaceHasOrigin	"A surface is initialized with a origin object which is zero-sized and at 0,0."	| surface |	surface := HumSurface new.	self assert: ( surface origin left = 0 ).	self assert: ( surface origin right = 0 ).		self assert: ( surface origin top = 0 ).		self assert: ( surface origin bottom = 0 ).	self assert: ( surface origin height = 0 ).	self assert: ( surface origin width = 0 ).	self assert: ( surface origin layer = 0 ).! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 3/7/2012 21:26'!test120surfaceSizeIsDurable	"A surface is initialized with a origin object which is zero-sized and at 0,0."	| surface |	"Note: Dimensions used here are meaningless - They are just for testing convenience."		surface := HumSurface new.	surface width: 1; height: 1.	"Bump surface over the the right."	surface left: 1.	self assert: ( surface right = 2 ).	"Bump surface up."	surface top: 3.	self assert: ( surface bottom = 2 ).	"Bump surface from bottom."	surface bottom: 3.	self assert: ( surface top = 4 ).	"Pull surface via the right edge."	surface right: 5.	self assert: ( surface left = 4 ).! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 3/7/2012 21:27'!test130surfaceLayers	"A surface is initialized with a origin object which is zero-sized and at 0,0."	| surface rectangleA rectangleB |	"Note: Dimensions used here are meaningless - They are just for testing convenience."	surface := HumSurface new.	rectangleA := ( HumSurface new ) width: 20; height: 10.	rectangleB := ( HumSurface new ) width: 30; height: 40.		"Put rectangle A on the surface."	surface place: rectangleA at: #(5 5 0).	self assert: ( rectangleA left = 5 ).	self assert: ( rectangleA top = 5 ).	self assert: ( rectangleA layer = 0 ).		"Put rectange B on top of rectangle A"	surface overlay: rectangleB onTopOf: rectangleA.	"By convention, the top and left edges will align."	self assert: ( rectangleB left = 5 ).	self assert: ( rectangleB top = 5 ).	"By convention, the layer is greater for the thing on top."	self assert: ( rectangleB layer ) > ( rectangleA layer ).			! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 3/7/2012 21:27'!test140surfaceLayout	"A surface is initialized with a origin object which is zero-sized and at 0,0."	| surface rectangleA rectangleB |		"Note: Dimensions used here are meaningless - They are just for testing convenience."	surface := HumSurface new.	rectangleA := ( HumSurface new ) width: 20; height: 10.	rectangleB := ( HumSurface new ) width: 30; height: 40.		"Put rectangle A on the surface."	surface place: rectangleA at: #(5 5 1).	self assert: ( rectangleA left = 5 ).	self assert: ( rectangleA top = 5 ).	self assert: ( rectangleA layer = 1 ).		"Put B below A."	surface place: rectangleB below: rectangleA.	self assert: ( rectangleB top ) = ( rectangleA bottom ).	"By convention B is in same layer as A. (They are side by side in the same layer. )"	self assert: ( rectangleB layer ) = ( rectangleA layer ).		"Now put B above A. "	rectangleA layer: 3.	surface place: rectangleB above: rectangleA.	self assert: ( rectangleB bottom ) = ( rectangleA top ).	self assert: ( rectangleB layer ) = ( rectangleA layer ).		"Now put B left of A."	rectangleA layer: 4.	surface place: rectangleB leftOf: rectangleA.	self assert: ( rectangleB left ) = ( rectangleA right ).	self assert: ( rectangleB layer ) = ( rectangleA layer ).		"Now put B right of A."	rectangleA layer: 5.	surface place: rectangleB rightOf: rectangleA.	self assert: ( rectangleB left ) = ( rectangleA right ).	self assert: ( rectangleB layer ) = ( rectangleA layer ).		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 3/7/2012 21:31'!test150surfaceLayoutForPA	"Test for usability -- Consider a layout like the PA."	| window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram |	"NOTE: Dimensions used here are percentages of the container !!!!!!"		"Create the main divisions."	window := HumSurface new width: 100; height: 100.	menuStack := HumSurface new width: 100; height: 10; top: 0; left: 0.	editStack := HumSurface new width: 75; height: 90; left: 0.	diagramStack := HumSurface new width: 25; height: 90.	"Assemble them."	window place:  editStack below: menuStack.	self expect: editStack bottom is: -100 .	window place: diagramStack below: menuStack.	self expect: diagramStack bottom is: -100 .	window place: diagramStack rightOf: editStack.	self expect:  diagramStack right is: 100 .		"Create editStack divisions and assemble them."	editMenu := HumSurface new width: 100; height: 10; top: 0; left: 0.	codeView := HumSurface new width: 100; height: 80.	critiqueView := HumSurface new width: 100; height: 10.		editStack place: codeView below: editMenu.	editStack place: critiqueView below: codeView.	self expect:  critiqueView bottom is: -100.		"Create diagramStack divisions."	planTreeDiagram := HumSurface new width: 100; height: 25; left: 0; top: 0.	roleRelationsDiagram := HumSurface new width: 100; height: 25.	wordRelationsDiagram := HumSurface new width: 100; height: 25.	vignetteDiagram := HumSurface new width: 100; height: 25.		diagramStack place: roleRelationsDiagram below:  planTreeDiagram.	diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.	diagramStack place: vignetteDiagram below: wordRelationsDiagram.	self expect: vignetteDiagram bottom is: -100 .	self expect: vignetteDiagram top is: -75 .	self expect: vignetteDiagram left is: 0 .	self expect: vignetteDiagram right is: 100 .	 		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 3/14/2012 22:03'!test210surfaceAsSVG	"Test for usability -- Consider a layout like the PA."	| window svgString |		true ifFalse: [Transcript cr; show: 'test210surfaceAsSVG turned off'; cr.  ^self ].		window := HumSurface new width: '1600 px'; height: '900 px'; id: 'window'.	"Get the SVG string for this assembly."	svgString := window asSVG.		self assert: ( svgString beginsWith: '<svg ' ).	self assert: ( svgString includesSubString: '<rect ' ).	self assert: ( svgString includesSubString: ' id="window" ' ).	self assert: ( svgString includesSubString: ' width="1600 px" ' ).	self assert: ( svgString includesSubString: ' height="900 px" ' ).		 		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 10/31/2012 09:37'!test220surfaceAsSvgViewBox	"Test for usability -- Consider a layout like the PA."	| window svgString |		true ifFalse: [Transcript cr; show: 'test220surfaceAsSvgViewBox turned off'; cr.  ^self ].		window := HumSurface new width: '1600 px'; height: '900 px'; id: 'window'.	"Get the SVG string for this assembly."	svgString := window asSvgViewBox.		self assert: ( svgString beginsWith: '<svg ' ).	self assert: ( svgString includesSubString: '<rect ' ).	self assert: ( svgString includesSubString: ' id="window" ' ).	self assert: ( svgString includesSubString: ' width="1600 px" ' ).	self assert: ( svgString includesSubString: ' height="900 px" ' ).	self assert: ( svgString includesSubString: ' viewBox="0 0 1600 900" ').			 		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 3/14/2012 06:53'!test255surfaceAssemblyAsSVG	"Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."	| window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram svgString diagramMenu |	true ifFalse: [Transcript cr; show: 'test250surfaceAssemblyAsSVG turned off'; cr. ^self ].	"NOTE: Dimensions used here are percentages of the container !!!!!!"		"Create the main divisions."	window := HumSurface new width: 13.0; height: 8.0; id: 'window'.	menuStack := HumSurface new width: 12.0; height: 0.25; top: 0; left: 0; id: 'menu stack'.	editStack := HumSurface new width: 8.0; height: 7.5; left: 0; id: 'edit stack'.	diagramStack := HumSurface new width: 5.0; height: 7.5; id: 'diagram stack'.	"Assemble them."	window place:  editStack below: menuStack.	window place: diagramStack below: menuStack.	window place: diagramStack rightOf: editStack.		"Create editStack divisions and assemble them."	editMenu := HumSurface new width: 8.0; height: 0.25; top: 0; left: 0; id: 'edit menu'.	codeView := HumSurface new width: 8.0; height: 7.0; id: 'code view'.	critiqueView := HumSurface new width: 8.0; height: 0.25; id: 'critique view'.		editStack place: codeView below: editMenu.	editStack place: critiqueView below: codeView.		"Create diagramStack divisions."	diagramMenu := HumSurface new width: 5.0; height: 0.25; left: 0; top: 0; id: 'diagram menu'.	planTreeDiagram := HumSurface new width: 5.0; height: 2.0; left: 0; top: 0; id: 'plan tree'.	roleRelationsDiagram := HumSurface new width: 5.0; height: 2.0; id: 'role relations'.	wordRelationsDiagram := HumSurface new width: 5.0; height: 2.0; id: 'word relations'.	vignetteDiagram := HumSurface new width: 5.0; height: 2.0; id: 'vignette relations'.  		diagramStack place: planTreeDiagram below: diagramMenu.	diagramStack place: roleRelationsDiagram below:  planTreeDiagram.	diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.	diagramStack place: vignetteDiagram below: wordRelationsDiagram.		"Get the SVG string for this assembly."	svgString := window asSvgViewBox .		self assert: ( svgString beginsWith: '<svg ' ).	self assert: ( svgString includesSubString: '<rect ' ).	self assert: ( svgString includesSubString: ' id="window" ' ).	self assert: ( svgString includesSubString: ' id="edit stack" ' ).	self assert: ( svgString includesSubString: ' id="diagram stack" ' ).	self assert: ( svgString includesSubString: ' id="critique view" ' ).		"Transcript cr; show: svgString; cr."		 		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 3/15/2012 14:33'!test260surfaceAssemblyAsSvgPercent	"Test for usability -- Consider a layout like the PA."	| window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram svgString |	true ifFalse: [Transcript cr; show: 'test260surfaceAssemblyAsSvgPercent turned off'; cr. ^self ].	"NOTE: Dimensions used here are percentages of the container !!!!!!"		"Create the main divisions."	window := HumSurface new width: '100%'; height: '100%'; id: 'window'.	menuStack := HumSurface new width: '100%'; height: '10%'; top: '0%'; left: '0%'.	editStack := HumSurface new width: '75%'; height: '90%'; left: '0%'; id: 'edit stack'.	diagramStack := HumSurface new width: '25%'; height: '90%'; id: 'diagram stack'.	"Assemble them."	window place:  editStack below: menuStack.	window place: diagramStack below: menuStack.	window place: diagramStack rightOf: editStack.		"Create editStack divisions and assemble them."	editMenu := HumSurface new width: '100%'; height: '10%'; top: '0%'; left: '0%'.	codeView := HumSurface new width: '100%'; height: '80%'.	critiqueView := HumSurface new width: '100%'; height: '10%'; id: 'critique view'.		editStack place: codeView below: editMenu.	editStack place: critiqueView below: codeView.		"Create diagramStack divisions."	planTreeDiagram := HumSurface new width: '100%'; height: '25%'; left: '0%'; top: '0%'.	roleRelationsDiagram := HumSurface new width: '100%'; height: '25%'.	wordRelationsDiagram := HumSurface new width: '100%'; height: '25%'.	vignetteDiagram := HumSurface new width: '100%'; height: '25%'.		diagramStack place: roleRelationsDiagram below:  planTreeDiagram.	diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.	diagramStack place: vignetteDiagram below: wordRelationsDiagram.		"Get the SVG string for this assembly."	svgString := window asSVG.		self assert: ( svgString beginsWith: '<svg ' ).	self assert: ( svgString includesSubString: '<rect ' ).	self assert: ( svgString includesSubString: ' id="window" ' ).	self assert: ( svgString includesSubString: ' id="edit stack" ' ).	self assert: ( svgString includesSubString: ' id="diagram stack" ' ).	self assert: ( svgString includesSubString: ' id="critique view" ' ).		"Transcript cr; show: 'from test260surfaceAssemblyAsSvgPercent: '; cr; show: svgString; cr."		 		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 10/31/2012 09:48'!test270surfaceAssemblyAsSvgInch	"Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."	| window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram svgString diagramMenu |	true ifFalse: [Transcript cr; show: 'test270surfaceAssemblyAsSvgInch turned off'; cr. ^self ].	"NOTE: Dimensions used here are percentages of the container !!!!!!"		"Create the main divisions."	window := HumSurface new width: '13.0 inch' ; height: '8.0 inch'; id: 'window'.	menuStack := HumSurface new width: '13.0 inch'; height: '0.25 inch'; top: '0 inch'; left: '0 inch'; id: 'menu stack'.	editStack := HumSurface new width: '8.0 inch'; height: '7.5 inch'; left: '0 inch'; id: 'edit stack'.	diagramStack := HumSurface new width: '5.0 inch'; height: '7.5 inch'; id: 'diagram stack'.	"Assemble them."	window place:  editStack below: menuStack.	window place: diagramStack below: menuStack.	window place: diagramStack rightOf: editStack.		"Create editStack divisions and assemble them."	editMenu := HumSurface new width: '8.0 inch'; height: '0.25 inch'; top: '0 inch'; left: '0 inch'; id: 'edit menu'.	codeView := HumSurface new width: '8.0 inch'; height: '7.0 inch'; id: 'code view'.	critiqueView := HumSurface new width: '8.0 inch'; height: '0.25 inch'; id: 'critique view'.		editStack place: codeView below: editMenu.	editStack place: critiqueView below: codeView.		"Create diagramStack divisions."	diagramMenu := HumSurface new width: '5.0 inch'; height: '0.25 inch'; left: '0 inch'; top: '0 inch'; id: 'diagram menu'.	planTreeDiagram := HumSurface new width: '5.0 inch'; height: '2.0 inch'; left: '0 inch'; top: '0 inch'; id: 'plan tree'.	roleRelationsDiagram := HumSurface new width: '5.0 inch'; height: '2.0 inch'; id: 'role relations'.	wordRelationsDiagram := HumSurface new width: '5.0 inch'; height: '2.0 inch'; id: 'word relations'.	vignetteDiagram := HumSurface new width: '5.0 inch'; height: '2.0 inch'; id: 'vignette relations'.  		diagramStack place: planTreeDiagram below: diagramMenu.	diagramStack place: roleRelationsDiagram below:  planTreeDiagram.	diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.	diagramStack place: vignetteDiagram below: wordRelationsDiagram.		"Get the SVG string for this assembly."	svgString := window asSvgViewBox .		self assert: ( svgString beginsWith: '<svg ' ).	self assert: ( svgString includesSubString: '<rect ' ).	self assert: ( svgString includesSubString: ' id="window" ' ).	self assert: ( svgString includesSubString: ' id="edit stack" ' ).	self assert: ( svgString includesSubString: ' id="diagram stack" ' ).	self assert: ( svgString includesSubString: ' id="critique view" ' ).		"Transcript cr; show: svgString; cr."		 		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 3/16/2012 12:17'!test310surfaceAsXML	"First principle: Express a hum surface as XML.	The recipient of the XML may interpret it using some local framework.	For example: The Hum RunTime may provide a JavaScript interpreter.	"	| window xmlString |		true ifFalse: [Transcript cr; show: 'test310surfaceAsXML turned off'; cr.  ^self ].		window := HumSurface new width: '800 px'; height: '450 px'; id: 'window'.	"Get the SVG string for this assembly."	xmlString := window asXML.		self assert: ( xmlString beginsWith: '<script ' ).	self assert: ( xmlString includesSubString: '<hum:surface ' ).	self assert: ( xmlString includesSubString: ' id="window" ' ).	self assert: ( xmlString includesSubString: ' width="800 px" ' ).	self assert: ( xmlString includesSubString: ' height="450 px" ' ).		 	Transcript cr; show: 'from test310surfaceAsXML : '; cr; show: xmlString; cr.	! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 3/16/2012 12:13'!test320surfaceAssemblyAsXML	"Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."	| window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram xmlString diagramMenu |	true ifFalse: [Transcript cr; show: 'test320surfaceAssemblyAsXML turned off'; cr. ^self ].	"NOTE: Dimensions used here are percentages of the container !!!!!!"		"Create the main divisions."	window := HumSurface new width: '1300' ; height: '800'; id: 'window'.	menuStack := HumSurface new width: '1300'; height: '25'; top: 0; left: 0; id: 'menu stack'.	editStack := HumSurface new width: '800'; height: '75'; left: 0; id: 'edit stack'.	diagramStack := HumSurface new width: '500'; height: '75'; id: 'diagram stack'.	"Assemble them."	window place:  editStack below: menuStack.	window place: diagramStack below: menuStack.	window place: diagramStack rightOf: editStack.		"Create editStack divisions and assemble them."	editMenu := HumSurface new width: '800'; height: '25'; top: 0; left: 0; id: 'edit menu'.	codeView := HumSurface new width: '800'; height: '700'; id: 'code view'.	critiqueView := HumSurface new width: '800'; height: '25'; id: 'critique view'.		editStack place: codeView below: editMenu.	editStack place: critiqueView below: codeView.		"Create diagramStack divisions."	diagramMenu := HumSurface new width: '500'; height: '25'; left: 0; top: 0; id: 'diagram menu'.	planTreeDiagram := HumSurface new width: '500'; height: '200'; left: 0; top: 0; id: 'plan tree'.	roleRelationsDiagram := HumSurface new width: '500'; height: '200'; id: 'role relations'.	wordRelationsDiagram := HumSurface new width: '500'; height: '200'; id: 'word relations'.	vignetteDiagram := HumSurface new width: '500'; height: '200'; id: 'vignette relations'.  		diagramStack place: planTreeDiagram below: diagramMenu.	diagramStack place: roleRelationsDiagram below:  planTreeDiagram.	diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.	diagramStack place: vignetteDiagram below: wordRelationsDiagram.		"Get the SVG string for this assembly."	xmlString := window asXML .		self assert: ( xmlString beginsWith: '<script' ).	self assert: ( xmlString includesSubString: '<hum:surface ' ).	self assert: ( xmlString includesSubString: '<hum:surface id="window" ' ).	self assert: ( xmlString includesSubString: '<hum:surface id="edit stack" ' ).	self assert: ( xmlString includesSubString: '<hum:surface id="diagram stack" ' ).	self assert: ( xmlString includesSubString: '<hum:surface id="critique view" ' ).		"Transcript cr; show: 'from test320surfaceAssemblyAsXML'; cr; show: xmlString; cr."		 		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 10/31/2012 09:54'!test410surfaceAsHTML	"Test for usability -- Consider a layout like the PA."	| window htmlString |		"This #asHTML  feature is deferred until javascript code is written to enable it."	false ifFalse: [Transcript cr; show: '*** test410surfaceAsHTML TURNED OFF until javascript code is written to enable it '; cr.  ^self ].		window := HumSurface new width: '800 px'; height: '450 px'; id: 'window'.	"Get the SVG string for this assembly."	htmlString := window asHTML.		self assert: ( htmlString beginsWith: '<html' ).	self assert: ( htmlString includesSubString: '<canvas ' ).	self assert: ( htmlString includesSubString: ' id="window" ' ).	self assert: ( htmlString includesSubString: ' width="800 px" ' ).	self assert: ( htmlString includesSubString: ' height="450 px" ' ).		 	Transcript cr; show: 'from test410surfaceAsHTML '; cr; show: htmlString; cr.	! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 10/31/2012 09:53'!test470surfaceAssemblyAsHTML	"Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."	| window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram htmlString diagramMenu |	"This feature is deferred until javascript code is written to enable it."	false ifFalse: [Transcript cr; show: '*** test470surfaceAssemblyAsHTML TURNED OFF until javascript code is written to enable it'; cr. ^self ].	"NOTE: Dimensions used here are percentages of the container !!!!!!"		"Create the main divisions."	window := HumSurface new width: '1300' ; height: '800'; id: 'window'.	menuStack := HumSurface new width: '1300'; height: '25'; top: 0; left: 0; id: 'menu stack'.	editStack := HumSurface new width: '800'; height: '75'; left: 0; id: 'edit stack'.	diagramStack := HumSurface new width: '500'; height: '75'; id: 'diagram stack'.	"Assemble them."	window place:  editStack below: menuStack.	window place: diagramStack below: menuStack.	window place: diagramStack rightOf: editStack.		"Create editStack divisions and assemble them."	editMenu := HumSurface new width: '800'; height: '25'; top: 0; left: 0; id: 'edit menu'.	codeView := HumSurface new width: '800'; height: '700'; id: 'code view'.	critiqueView := HumSurface new width: '800'; height: '25'; id: 'critique view'.		editStack place: codeView below: editMenu.	editStack place: critiqueView below: codeView.		"Create diagramStack divisions."	diagramMenu := HumSurface new width: '500'; height: '25'; left: 0; top: 0; id: 'diagram menu'.	planTreeDiagram := HumSurface new width: '500'; height: '200'; left: 0; top: 0; id: 'plan tree'.	roleRelationsDiagram := HumSurface new width: '500'; height: '200'; id: 'role relations'.	wordRelationsDiagram := HumSurface new width: '500'; height: '200'; id: 'word relations'.	vignetteDiagram := HumSurface new width: '500'; height: '200'; id: 'vignette relations'.  		diagramStack place: planTreeDiagram below: diagramMenu.	diagramStack place: roleRelationsDiagram below:  planTreeDiagram.	diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.	diagramStack place: vignetteDiagram below: wordRelationsDiagram.		"Get the SVG string for this assembly."	htmlString := window asHTML .		self assert: ( htmlString beginsWith: '<html' ).	self assert: ( htmlString includesSubString: '<canvas ' ).	self assert: ( htmlString includesSubString: ' id="window" ' ).	self assert: ( htmlString includesSubString: ' id="edit stack" ' ).	self assert: ( htmlString includesSubString: ' id="diagram stack" ' ).	self assert: ( htmlString includesSubString: ' id="critique view" ' ).		Transcript cr; show: 'from test470surfaceAssemblyAsHTML'; cr; show: htmlString; cr.		 		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 3/16/2012 12:43'!test510surfaceAsHumScript	"Test first principle: Produce a hum action call.	The hum script may be translated into some target language.	The target language could be a series of openGL calls, or PyQt, JavaScript canvas, et cetera.	"	| window script |		"This #asHTML  feature is deferred until javascript code is written to enable it."	true ifFalse: [Transcript cr; show: 'test510surfaceAsHumScript turned off'; cr.  ^self ].		window := HumSurface new width: '800 px'; height: '450 px'; id: 'window'.	"Get the SVG string for this assembly."	script := window asHumScript.		"Expect something like '. Painter: Paint surface with id 'window' width '800 px' height '450 px'.   "	self assert: ( script beginsWith: '. Painter:' ).	self assert: ( script includesSubString: 'Paint surface ' ).	self assert: ( script includesSubString: ' id ''window''' ).	self assert: ( script includesSubString: ' width ''800 px''' ).	self assert: ( script includesSubString: ' height ''450 px''' ).	self assert: ( script includesSubString: ' left ''0 px''' ).	self assert: ( script includesSubString: ' top ''0 px''' ).	self assert: ( script endsWith: '.' ).		 	Transcript cr; show: 'from test510surfaceAsHumScript '; cr; show: script; cr.	! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 3/30/2012 15:45'!test570surfaceAssemblyAsHumScript	"Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."	| window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram script diagramMenu |	"This feature is deferred until javascript code is written to enable it."	true ifFalse: [Transcript cr; show: 'test570surfaceAssemblyAsHumScript turned off'; cr. ^self ].	"NOTE: Dimensions used here are percentages of the container !!!!!!"		"Create the main divisions."	window := HumSurface new width: '1300' ; height: '800'; id: 'window'.	menuStack := HumSurface new width: '1300'; height: '25'; top: 0; left: 0; id: 'menu stack'.	editStack := HumSurface new width: '800'; height: '75'; left: 0; id: 'edit stack'.	diagramStack := HumSurface new width: '500'; height: '75'; id: 'diagram stack'.	"Assemble them."	window place:  editStack below: menuStack.	window place: diagramStack below: menuStack.	window place: diagramStack rightOf: editStack.		"Create editStack divisions and assemble them."	editMenu := HumSurface new width: '800'; height: '25'; top: 0; left: 0; id: 'edit menu'.	codeView := HumSurface new width: '800'; height: '700'; id: 'code view'.	critiqueView := HumSurface new width: '800'; height: '25'; id: 'critique view'.		editStack place: codeView below: editMenu.	editStack place: critiqueView below: codeView.		"Create diagramStack divisions."	diagramMenu := HumSurface new width: '500'; height: '25'; left: 0; top: 0; id: 'diagram menu'.	planTreeDiagram := HumSurface new width: '500'; height: '200'; left: 0; top: 0; id: 'plan tree'.	roleRelationsDiagram := HumSurface new width: '500'; height: '200'; id: 'role relations'.	wordRelationsDiagram := HumSurface new width: '500'; height: '200'; id: 'word relations'.	vignetteDiagram := HumSurface new width: '500'; height: '200'; id: 'vignette relations'.  		diagramStack place: planTreeDiagram below: diagramMenu.	diagramStack place: roleRelationsDiagram below:  planTreeDiagram.	diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.	diagramStack place: vignetteDiagram below: wordRelationsDiagram.		"Get the SVG string for this assembly."	script := window asHumScript .		self assert: ( script beginsWith: '. Painter: ' ).	self assert: ( script includesSubString: 'surface' ).	self assert: ( script includesSubString: ' id ''window'' ' ).	self assert: ( script includesSubString: ' id ''edit stack'' ' ).	self assert: ( script includesSubString: ' id ''diagram stack'' ' ).	self assert: ( script includesSubString: ' id ''critique view'' ' ).	"	Transcript cr; show: 'from test570surfaceAssemblyAsHumScript'; cr; show: script; cr.	"	 		! !!HumUserInterfaceTests methodsFor: 'HumParser Tests' stamp: 'RichardAlexanderGreen 8/27/2012 09:22'!humParserReadMe	"The Hum Parser is meant to be a generic parser that a programmer can modify or subclass	to build custom parsers.	- Example usage:	( comment := self between: '/*' upto: '*/' )	will evaluate to true if the next non-white-space subtring begins with  '/*' 	and the '*/' termination can be found in the stream.	- Choices:	( name := (self letter) or: [(self letter) and: (self alphastring) ] )	. . . self letter will be true if the next non-white-space character is a letter.	. . . The 'or:' part allows an alternate match.	. . . If the and part succeeds, the selection will include a sequence of 'alpha' characters.	letter := [ text next isAlpha ].	digit := [ text next isDigit ].	alphanumeric :=[ letter or: digit ].	statement := [conditionalStatement or: instruction].		"! !!HumUserInterfaceTests methodsFor: 'HumParser Tests' stamp: 'RichardAlexanderGreen 2/24/2013 09:35'!resultingRenderOn: html	| anEntityID |	html form with: [ 		html break. html heading level: 2; with: ' Recipe'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #name toValue: datum ]; name: 'name'; value: 'name'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #description toValue: datum ]; name: 'description 5'; value: 'description 5'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #ingredients toValue: datum ]; name: 'ingredients'; value: 'ingredients'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #steps toValue: datum ]; name: 'steps'; value: 'steps'.		]! !!HumUserInterfaceTests methodsFor: 'HumParser Tests' stamp: 'RichardAlexanderGreen 8/27/2012 12:10'!testP000Definitions	"Try out this DSL idea."	| proceed stream word statement alphaString letter conditionalStatement instruction delegatedAction roleName colon words period dummy localAction if else for keyword |		"I am going to try a different approach to parsing."	proceed := false.	proceed ifFalse: [Transcript show: 'testP000Definitions removed'; cr.   ^self ].	dummy := [ Error signal: 'This should not be called if definitions are complete.' ].	stream := HumParseString new.	"Some terminators"	colon := [ stream nextEquals: ':' ].	stream string: ':'.	self assert: ( colon match ).	period := [ stream nextEquals: '.' ].	stream string: '.'.	self assert: ( period match ).		"The word comes first."	letter := [ stream next isLetter ].	stream string: 'Z'.	self assert: ( letter match ).		alphaString := [ stream uptoDelimiter isAlphaNumeric ].	word := [ letter or: [letter followedBy: alphaString ] ] andNot: [period].          "Recursive definition for a stream of words."	dummy := [ Error signal: 'This should not be called if definitions are complete.' ].	words := dummy. "Trick to make syntax scan happy."	words := [ word or: [ words followedBy: word ] ].		"key words"	if := [ stream uptoDelimiterEquals:  'if'].	else := [ stream uptoDelimiterEquals:  'else'].	for := [ stream uptoDelimiterEquals:  'for'].	keyword := [ if or: else or: for ].		"Statement"	roleName := [word].	delegatedAction := [ roleName followedBy: colon followedBy: words followedBy: period ].	localAction :=  [ words followedBy: period ].	instruction := [ delegatedAction or: localAction ].	conditionalStatement := [ keyword followedBy: words followedBy: colon ].	statement := [ instruction or: conditionalStatement ]. 		"Test and also satisfy need for statement being used."	stream string: 'RoleName : Please do something for me.'.	self assert: ( statement match ).! !!HumUserInterfaceTests methodsFor: 'HumParser Tests' stamp: 'RichardAlexanderGreen 8/27/2012 09:12'!testP110ParserReturnsTree	"The parser returns a tree of (symbol -> source or tree).	Source includes the start-end coordinates (line@character -> line@character),	and the type of  . . . "! !!HumUserInterfaceTests methodsFor: 'HumParser Tests' stamp: 'RichardAlexanderGreen 8/27/2012 10:03'!tryThis	"Try out this DSL idea."	| stream word statement alphaString letter conditionalStatement instruction delegatedAction roleName colon words period dummy localAction if else for keyword |	dummy := [ Error signal: 'This should not be called if definitions are complete.' ].	stream := HumParseString new.	"Some terminators"	colon := [ stream nextEquals: ':' ].	period := [ stream nextEquals: '.' ].	"The word comes first."	letter := [ stream next isLetter ].	alphaString := [ stream uptoDelimiter isAlphaNumeric ].	word := [ letter or: [letter followedBy: alphaString ] ] andNot: [period].	words := dummy. "Trick to make syntax scan happy."	words := [ word or: [ words followedBy: word ] ].	"key words"	if := [ stream uptoDelimiterEquals:  'if'].	else := [ stream uptoDelimiterEquals:  'else'].	for := [ stream uptoDelimiterEquals:  'for'].		keyword := [ if or: else or: for ].	"Statement"	roleName := [word].	delegatedAction := [ roleName followedBy: colon followedBy: words followedBy: period ].	localAction :=  [ words followedBy: period ].	instruction := [ delegatedAction or: localAction ].	conditionalStatement := [ keyword followedBy: words followedBy: colon ].	statement := [ instruction or: conditionalStatement ]. 	"Test and also satisfy need for statement being used."	stream string: 'RoleName : Please do something for me.'.	self assert: ( statement value ).! !!HumUserInterfaceTests methodsFor: 'HumParser Tests' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!xxxTest000Definitions	"Try out this DSL idea."	| stream word statement alphaString letter conditionalStatement instruction delegatedAction roleName colon words period dummy localAction if else for keyword |		dummy := [ Error signal: 'This should not be called if definitions are complete.' ].	stream := HumParseString new.	"Some terminators"	colon := [ stream nextEquals: ':' ].	stream string: ':'.	self assert: ( colon match ).	period := [ stream nextEquals: '.' ].	stream string: '.'.	self assert: ( period match ).		"The word comes first."	letter := [ stream next isLetter ].	stream string: 'Z'.	self assert: ( letter match ).		alphaString := [ stream uptoDelimiter isAlphaNumeric ].	word := [ letter or: [letter followedBy: alphaString ] ] andNot: [period].          "Recursive definition for a stream of words."	dummy := [ Error signal: 'This should not be called if definitions are complete.' ].	words := dummy. "Trick to make syntax scan happy."	words := [ word or: [ words followedBy: word ] ].		"key words"	if := [ stream uptoDelimiterEquals:  'if'].	else := [ stream uptoDelimiterEquals:  'else'].	for := [ stream uptoDelimiterEquals:  'for'].	keyword := [ if or: else or: for ].		"Statement"	roleName := [word].	delegatedAction := [ roleName followedBy: colon followedBy: words followedBy: period ].	localAction :=  [ words followedBy: period ].	instruction := [ delegatedAction or: localAction ].	conditionalStatement := [ keyword followedBy: words followedBy: colon ].	statement := [ instruction or: conditionalStatement ]. 		"Test and also satisfy need for statement being used."	stream string: 'RoleName : Please do something for me.'.	self assert: ( statement match ).! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 7/31/2012 10:46'!testE110EditorPosition	"The editor owns a (cursor) position."	| editor |	editor := HumEditor new.	self assert: editor lineIndex equals: 1.	self assert: editor characterIndex equals: 0.	! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 7/31/2012 10:47'!testE120EditorInsertCharacterAtEndOfLine	"When we insert a character, the cursor advances and the character is in the text string."	| editor |	"Initial position of the cursor is line 1, column 1"	editor := HumEditor new.	self for: ( editor lineIndex ) expect:  1.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('',String cr).		"When a character is inserted at the cursor position, the cursor advances."	editor insertCharacter: $x.	self for: ( editor characterIndex ) expect:  1.		"And, of course, the text has the new character."	self for: ( editor text string ) expect:  ('x',String cr).				"Insert another character . . ."	editor insertCharacter: $y.	self for: ( editor characterIndex ) expect:  2.	self for: ( editor text string ) expect:  ('xy',String cr).		! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 7/31/2012 10:48'!testE121EditorInsertCharacterAtFrontOfLine	"When we insert a character, the cursor advances and the character is in the text string."	| editor |	"Initial position of the cursor is line 1, column 1"	editor := HumEditor new.	self for: ( editor lineIndex ) expect:  1.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('',String cr).		"When a character is inserted at the cursor position, the cursor advances."	editor insertCharacter: $x.	self for: ( editor characterIndex ) expect:  1.		"And, of course, the text has the new character."	self for: ( editor text string ) expect:  ('x',String cr).				"Insert another character . . ."	editor characterIndex: 0.	editor insertCharacter: $y.	self for: ( editor characterIndex ) expect:  1.	self for: ( editor text string ) expect:  ('yx',String cr).		! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 7/31/2012 10:50'!testE130EditorInsertLine	"When we insert a line, the cursor advances to the beginning of the new line."	| editor |	"Initial position of the cursor is line 1, column 1"	editor := HumEditor new.	self for: ( editor lineIndex ) expect:  1.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('',String cr).		"When a character is inserted at the cursor position, the cursor advances."	editor insertCharacter: $x.	self for: ( editor characterIndex ) expect:  1.		"And, of course, the text has the new character."	self for: ( editor text string ) expect:  ('x',String cr).				"Insert another character . . ."	editor insertCharacter: $y.	self for: ( editor characterIndex ) expect:  2.	self for: ( editor text string ) expect:  ('xy',String cr).				"Insert an empty line."	editor insertLine.	self for: ( editor lineIndex ) expect:  2.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('xy',String cr, String cr).		! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 7/31/2012 10:52'!testE140EditorDeleteCharacterAtEndOfLine	"When we delete a character, the cursor decrements 	and the character is no longer in the text string."	| editor |	"Initial position of the cursor is line 1, column 1"	editor := HumEditor new.	self for: ( editor lineIndex ) expect:  1.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('',String cr).		"When a character is inserted at the cursor position, the cursor advances."	editor insertCharacter: $x.	self for: ( editor characterIndex ) expect:  1.		"And, of course, the text has the new character."	self for: ( editor text string ) expect:  ('x',String cr).				"Insert another character . . ."	editor insertCharacter: $y.	self for: ( editor characterIndex ) expect:  2.	self for: ( editor text string ) expect:  ('xy',String cr).				"Delete the character at end of line."	editor deletePriorCharacter.	self for: ( editor characterIndex ) expect:  1.	self for: ( editor text string ) expect:  ('x',String cr).			! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 7/31/2012 10:56'!testE141EditorDeleteCharacterAtStartOfLine	"When we delete a character, the cursor decrements 	and the character is no longer in the text string."	| editor |	"Initial position of the cursor is line 1, column 1"	editor := HumEditor new.	self for: ( editor lineIndex ) expect:  1.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('',String cr).		"When a character is inserted at the cursor position, the cursor advances."	editor insertCharacter: $x.	self for: ( editor characterIndex ) expect:  1.		"And, of course, the text has the new character."	self for: ( editor text string ) expect:  ('x',String cr).				"Insert another character . . ."	editor insertCharacter: $y.	self for: ( editor characterIndex ) expect:  2.	self for: ( editor text string ) expect:  ('xy',String cr).				"Delete the character at end of line."	editor deletePriorCharacter.	self for: ( editor characterIndex ) expect:  1.	self for: ( editor text string ) expect:  ('x',String cr).			"Delete the character at start of line."	editor deletePriorCharacter.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('',String cr).			! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 7/31/2012 10:57'!testE142EditorIgnoresDeleteWhenCursorAtStartOfLine	"When we delete a character, the cursor decrements 	and the character is no longer in the text string."	| editor |	"Initial position of the cursor is line 1, column 1"	editor := HumEditor new.	self for: ( editor lineIndex ) expect:  1.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('',String cr).		"When a character is inserted at the cursor position, the cursor advances."	editor insertCharacter: $x.	self for: ( editor characterIndex ) expect:  1.		"And, of course, the text has the new character."	self for: ( editor text string ) expect:  ('x',String cr).				"Insert another character . . ."	editor insertCharacter: $y.	self for: ( editor characterIndex ) expect:  2.	self for: ( editor text string ) expect:  ('xy',String cr).				"Move cursor to start of line"	editor characterIndex: 0.	"Attempt delete -- should be ignored"		"Delete the character at start of line."	editor deletePriorCharacter.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('xy',String cr).			! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 7/31/2012 20:31'!testE210InterpretArrowKeys	"The arrow keys move the cursor and may change the selection.	arrowUp ==> move cursor upward	arrowDown ==> move cursor downward	arrowRight ==> move cursor to the right	arrowLeft ==> move cursor to the left	"	| editor |	editor := HumEditor new.	editor addLine: 'This is line one.'.	editor addLine: 'This is line two.'.	editor lineIndex: 2.	editor characterIndex: 0.	self for: (editor lineIndex) expect: 2.	self for: (editor characterIndex) expect: 0.	editor interpretKey: #arrowUp.	self for: ( editor lineIndex ) expect: 1.		editor interpretKey: #arrowDown.	self for: ( editor lineIndex ) expect: 2.		editor interpretKey: #arrowRight.	self for: ( editor characterIndex ) expect: 1.		editor interpretKey: #arrowLeft.	self for: ( editor characterIndex ) expect: 0.		"When we try to push beyond the current text. The cursor does not move."	editor interpretKey: #arrowLeft.	self for: ( editor characterIndex ) expect: 0.		editor interpretKey: #arrowDown.	self for: ( editor lineIndex ) expect: 2.		editor interpretKey: #arrowUp.	self for: ( editor lineIndex ) expect: 1.		editor interpretKey: #arrowUp.	self for: ( editor lineIndex ) expect: 1.							! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 7/31/2012 20:46'!testE220InterpretAltArrowKeys	"The arrow keys move the cursor and may change the selection.	altArrowUp ==> move cursor to start of first line.	altArrowDown ==> move cursor to end of last line.	altArrowRight ==> move cursor to start of current line.	altArrowLeft ==> move cursor to end of current line.	"	| editor |	editor := HumEditor new.	editor addLine: 'This is line one.'.	editor addLine: 'This is line two.'.	editor lineIndex: 2.	editor characterIndex: 0.	self for: (editor lineIndex) expect: 2.	self for: (editor characterIndex) expect: 0.	editor interpretKey: #altArrowUp.	self for: ( editor lineIndex ) expect: 1.	self for: ( editor characterIndex ) expect: 0.		editor interpretKey: #altArrowDown.	self for: ( editor lineIndex ) expect: 2.	self for: ( editor characterIndex ) expect: ('This is line two.' size).		editor characterIndex: 1.	editor interpretKey: #altArrowRight.	self for: ( editor characterIndex ) expect:  ('This is line two.' size).		editor interpretKey: #altArrowLeft.	self for: ( editor characterIndex ) expect: 0.		"When we try to push beyond the current text. The cursor does not move."	editor interpretKey: #altArrowLeft.	self for: ( editor characterIndex ) expect: 0.		editor interpretKey: #altArrowDown.	self for: ( editor lineIndex ) expect: 2.		editor interpretKey: #altArrowUp.	self for: ( editor lineIndex ) expect: 1.		editor interpretKey: #altArrowUp.	self for: ( editor lineIndex ) expect: 1.							! !!HumUserInterfaceTests methodsFor: 'HumSolid tests' stamp: 'RichardAlexanderGreen 3/30/2012 19:44'!test1010assembleAvatar	"Create example to indicate development idea/s."	| avatar head torso upperArmLeft upperArmRight hips wheelLeft wheelRight |	head := HumSolid type: #elipsoid height: 0.3 width: 0.2 depth: 0.2.	torso := HumSolid type: #box height: 1.0 width: 0.5 depth: 0.3.	upperArmLeft := HumSolid type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.		upperArmRight := HumSolid type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.	hips := HumSolid type: #box height: 0.25 width: 0.6 depth: 0.3.	wheelLeft := HumSolid type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.	wheelRight := HumSolid type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.		"Assemble."	avatar := HumSolid new.	avatar center: head onTopOf: torso.	avatar position: upperArmLeft eastOf: torso. "Assume avatar is facing us."	avatar position: upperArmRight westOf: torso. "Assume avatar is facing us."	avatar position: hips onBottomOf: torso.	avatar position: wheelLeft eastOf: hips.	avatar position: wheelRight westOf: hips.	"Assert some expectations"	self assert: ( head bottomEdge closeTo: torso topEdge ) .  "Got a funky round-off error on this, but not on others."	self assert: ( hips topEdge = torso bottomEdge ).	self assert: ( wheelLeft westEdge = hips eastEdge ).		self assert: ( wheelRight eastEdge = hips westEdge ).	self assert: ( upperArmLeft westEdge = torso eastEdge ).	self assert: ( upperArmRight eastEdge = torso westEdge ).	"Head is centered. So edges are inboard from torso."	self assert: ( head eastEdge = torso eastEdge ) not. 	self assert:  ( head westEdge = torso westEdge ) not.	"But some things were not constrained. So set those also."	upperArmLeft topEdge: ( torso topEdge ).	upperArmRight topEdge: ( torso topEdge ).	wheelLeft topEdge: ( hips topEdge ).	wheelRight topEdge: ( hips topEdge ).				! !!HumUserInterfaceTests methodsFor: 'HumSolid tests' stamp: 'RichardAlexanderGreen 3/30/2012 19:43'!test1015assembleAvatarBottomUp	"Create example to indicate development idea/s."	| avatar head torso upperArmLeft upperArmRight hips wheelLeft wheelRight |	head := HumSolid type: #elipsoid height: 0.3 width: 0.2 depth: 0.2.	torso := HumSolid type: #box height: 1.0 width: 0.5 depth: 0.3.	upperArmLeft := HumSolid type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.		upperArmRight := HumSolid type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.	hips := HumSolid type: #box height: 0.25 width: 0.6 depth: 0.3.	wheelLeft := HumSolid type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.	wheelRight := HumSolid type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.		"Assemble."	avatar := HumSolid new.	wheelLeft bottomEdge: 0.	wheelRight bottomEdge: 0.	hips topEdge: ( wheelLeft topEdge ).	avatar position: wheelLeft eastOf: hips.	avatar position: wheelRight westOf: hips.	avatar center: torso onTopOf: hips.	avatar center: head onTopOf: torso.	avatar position: upperArmLeft eastOf: torso. "Assume avatar is facing us."	avatar position: upperArmRight westOf: torso. "Assume avatar is facing us."	"Assert some expectations"	self assert: ( head bottomEdge closeTo: torso topEdge ) .  "Got a funky round-off error on this, but not on others."	self assert: ( hips topEdge = torso bottomEdge ).	self assert: ( wheelLeft westEdge = hips eastEdge ).		self assert: ( wheelRight eastEdge = hips westEdge ).	self assert: ( upperArmLeft westEdge = torso eastEdge ).	self assert: ( upperArmRight eastEdge = torso westEdge ).	"Head is centered. So edges are inboard from torso."	self assert: ( head eastEdge = torso eastEdge ) not. 	self assert:  ( head westEdge = torso westEdge ) not.	"But some things were not constrained. So set those also."	upperArmLeft topEdge: ( torso topEdge ).	upperArmRight topEdge: ( torso topEdge ).	wheelLeft topEdge: ( hips topEdge ).	wheelRight topEdge: ( hips topEdge ).				! !!HumUserInterfaceTests methodsFor: 'HumSolid tests' stamp: 'RichardAlexanderGreen 3/30/2012 16:21'!test1020colorAvatar	"Create example to indicate development idea/s."	| avatar head torso upperArmLeft upperArmRight hips wheelLeft wheelRight |	head := HumSolid type: #elipsoid height: 0.3 width: 0.2 depth: 0.2.	torso := HumSolid type: #box height: 1.0 width: 0.5 depth: 0.3.	upperArmLeft := HumSolid type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.		upperArmRight := HumSolid type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.	hips := HumSolid type: #box height: 0.25 width: 0.5 depth: 0.3.	wheelLeft := HumSolid type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.	wheelRight := HumSolid type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.		"Assemble."	avatar := HumSolid new.	avatar position: head onTopOf: torso.	avatar position: upperArmLeft eastOf: torso. "Assume avatar is facing us."	avatar position: upperArmRight westOf: torso. "Assume avatar is facing us."	avatar position: hips onBottomOf: torso.	avatar position: wheelLeft eastOf: hips.	avatar position: wheelRight westOf: hips.	"Color"	head color: ( Color paleBuff ).	torso color: ( Color green ).	upperArmLeft color: ( Color paleGreen ).		upperArmRight color: ( Color paleGreen ).	hips color: ( Color blue ).	wheelLeft color: ( Color paleBlue ).	wheelRight color: ( Color paleBlue ).	! !!HumUserInterfaceTests methodsFor: 'asserting' stamp: 'RichardAlexanderGreen 7/30/2012 17:49'!for: someExpression expect: someResult	| actual expected | 	expected := someResult.	actual := someExpression.	^ self		assert: ( expected = actual)		description: (self comparingStringBetween: expected and: actual)! !WAAbstractCanvasBrushTest subclass: #GivenWhenThen4Seaside	instanceVariableNames: 'log givenBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!GivenWhenThen4Seaside methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!assertString: stringA includesSubstring: stringB	 " stringB should be a substring in stringA "	| quote x |	quote := $' asString.	x := stringA findString: stringB.	self assert: (x > 0) description: 'Expecting ', quote, stringA, quote, ' contains ', quote, stringB, quote.! !!GivenWhenThen4Seaside methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!given: aDescriptionString code: aBlock	"Given in a given-when-then triplet 	-- use to setup test context (initial state).	The code may contain asserts to self-check.	"	self log:  ( String cr, 'Given: ', aDescriptionString ).	"Save the block so that multiple *when* can restore initial state before running."	givenBlock := aBlock.	^self.	! !!GivenWhenThen4Seaside methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!givenWhenThenComment	"The #given:code: and #when:code: and #then:code: methods are designed to be cascaded.	Note that #when:code: runs the block provided in the call to #given:code: to set-up initial condition.	That enables multiple *when-then* sequences to run even if they might interfere with each other.	However, you still need to be careful of side-effects.	"	^ 'The #given:code: and #when:code: and #then:code: methods are designed to be cascaded.	Note that #when:code: runs the block provided in the call to #given:code: to set-up initial condition.	That enables multiple *when-then* sequences to run even if they might interfere with each other.	However, you still need to be careful of side-effects.'! !!GivenWhenThen4Seaside methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!log	^ log ifNil: [ log := OrderedCollection new. ].! !!GivenWhenThen4Seaside methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!log: aString	| entry |	"Prepend a CR to make inspection more readable."	( aString beginsWith: (String cr) )		ifTrue: [ entry := aString ] ifFalse: [ entry := String cr, aString ].	( self log ) add: aString.! !!GivenWhenThen4Seaside methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!then: aDescriptionString code: aBlock	"*Then* in a given-when-then triplet 	-- Use to test post-condition after the given and then have run.	The code may contain asserts to self-check.	"	self log:  ( 'Then: ', aDescriptionString ).	"Run my assertions."	aBlock value.	^self.	! !!GivenWhenThen4Seaside methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!when: aDescriptionString code: whenBlock	"*When* in a given-when-then triplet 	-- Use to trigger events or add to state.	The code may contain asserts to self-check.	"	"Run the given block to reset to initial state.	This enables a sequence such as: Given, When, Then, When, Then.	It allows the When blocks to create contradicting states.	"	givenBlock value.	"Now run my block"	self log:  ( 'When: ', aDescriptionString, String cr ).	whenBlock value.	^self.	! !!GivenWhenThen4Seaside methodsFor: 'self test' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!test105GivenWhenThenSuccess	"Test the test utility - In this situation the test assertion is true."	| test x y z |	test := self class basicNew.	"A typical test looks like this."		test		given: 'given description' code: [ x:= 'given set'];		when: 'when description'  code: [ y := 'when set'];		then: 'then description' code: [ z := 'then set'. self assert: (true) ].	"Blocks should have executed."	self assert: ( x sameAs: 'given set' ).	self assert: ( y sameAs: 'when set' ).	self assert: ( z sameAs: 'then set' ).		! !!GivenWhenThen4Seaside methodsFor: 'self test' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!test106GivenWhenThenFail	"Test the test utility - In this situation the test assertion is true."	| test x y z |	test := self class basicNew.	"Normally, this test is not needed."	false ifFalse: [^self].	test := self class basicNew.		"A typical test looks like this."		test		given: 'given description' code: [ x:= 'given set'];		when: 'when description'  code: [ y := 'when set'];		"Following should show assertion fails."		then: 'then description' 			code: [ z := 'then set'. 							self assert: (false).							 ].		! !!GivenWhenThen4Seaside methodsFor: 'self test' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!test110BasicLog	"Test the testcase`s own log"	| test |	test := HumSeasideTests new.	test log: 'This is only a test'.	self assert: ( (test log at: 1 ) sameAs: 'This is only a test' ).! !!GivenWhenThen4Seaside methodsFor: 'self test' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!test120GivenWhenThenLogging	"Test the testcase`s own log"	| test x y z |	test := self class basicNew.	"A typical test looks like this."		test		given: 'given description' code: [ x:= 'given set'];		when: 'when description'  code: [ y := 'when set'];		then: 'then description' code: [ z := 'then set'. self assert: (true) ].	"The log should contain the descriptions."	self assertString: ( test log at: 1 ) includesSubstring: 'given description'.		self assertString: ( test log at: 2 ) includesSubstring: 'when description'.		self assertString: ( test log at: 3 ) includesSubstring: 'then description'.			! !GivenWhenThen4Seaside subclass: #HumSeasideTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumSeasideTests commentStamp: 'RichardAlexanderGreen 2/19/2013 11:21' prior: 0!This class (super class) holds the tests where Seaside is used to implement various Hum capabilities.Subclasses:- HumSeasideProgrammersAssistantTests holds tests for the Seaside implementation of the Programmers Assistant.- HumSeasideUserInterfaceTests hold tests for the Seaside implementation of the view-frame interpreter.Note that the Programmers Assistant is partially implemented in Hum, so that the PA implementation depends on the View and Dialog implementation.TODO: This class duplicates methods from GivenWhenThen. Consider using a trait or composition instead.!HumSeasideTests subclass: #HumSeasideProgrammersAssistantTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumSeasideProgrammersAssistantTests commentStamp: 'RichardAlexanderGreen 11/6/2012 15:59' prior: 0!These HumSeasideTests are adapted from HumProgrammerAssistantTests.	The Programmers Assistant provides a technology-free model of the UI.	The Hum Seaside classes provide UI components via Seaside.!!HumSeasideProgrammersAssistantTests methodsFor: 'PA200 Menu Dialogs' stamp: 'RichardAlexanderGreen 11/3/2012 11:48'!test222OpenOntologyInstance	"Test the dialog that asks the user for the file name."	| browser fileName |	"	Given: User has invokes 'Open ontology' in the browser menu.	When: User enters an existing (test) filename . . .	Then: The ontology attached to the browser matches the content of the test file.	"	browser := HumBrowser new.	browser loadOntologyInstance: 'Hum Seaside Test Ontology'.	self assert: (browser ontology isKindOf: HumOntology).	self assert: browser ontology title = 'Hum Seaside Test Ontology'.	! !!HumSeasideProgrammersAssistantTests methodsFor: 'PA100 Ontology Actions' stamp: 'RichardAlexanderGreen 11/3/2012 11:49'!aReadMe	"	These HumSeasideTests are adapted from HumProgrammerAssistantTests.	The Programmers Assistant provides a technology-free model of the UI.	The Hum Seaside classes provide a UI in Seaside.	"	^'See the class description for the intended (future) tests.'	! !!HumSeasideProgrammersAssistantTests methodsFor: 'PA100 Ontology Actions' stamp: 'RichardAlexanderGreen 11/3/2012 11:49'!test110newOntology	"Browser initializes (re-initializes) to an empty ontology."	| browser |	browser := HumBrowser new.	browser clearOntology.	self assert: (browser ontology nouns isEmpty).! !!HumSeasideProgrammersAssistantTests methodsFor: 'PA100 Ontology Actions' stamp: 'RichardAlexanderGreen 11/3/2012 11:49'!test121loadOntologyInstance	"Browser saves (writes) the ontology to a file."	| browser ontology |	browser := HumBrowser new.	browser loadOntologyInstance: 'Hum Seaside Test Ontology'.	self assert: browser ontology notNil.	browser saveOntology.	! !!HumSeasideProgrammersAssistantTests methodsFor: 'PA100 Ontology Actions' stamp: 'RichardAlexanderGreen 11/3/2012 11:49'!test130saveOntology	"Browser saves (writes) the ontology to a file."	| browser |	browser := HumBrowser new.	browser clearOntology.	browser saveOntology.	! !HumSeasideTests subclass: #HumSeasideUserInterfaceTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumSeasideUserInterfaceTests commentStamp: 'RichardAlexanderGreen 11/3/2012 11:59' prior: 0!This class holds tests of a Seaside implementation of Hum User Interface concepts.!!HumSeasideUserInterfaceTests methodsFor: 'PA300 View Code Generator' stamp: 'RichardAlexanderGreen 2/24/2013 10:01'!checkGeneratedCode	"This is a place to see if generated code will compile."! !!HumSeasideUserInterfaceTests methodsFor: 'PA300 View Code Generator' stamp: 'RichardAlexanderGreen 2/24/2013 09:53'!setUpViewFrameInOntology: aHumOntology	"Generate a view frame and dictionary entries for several tests.	---	!!!! Recipe	recipe-name: [name]	  description: [description]	  ingredients: [ingredients]	           steps: [steps]	---	Dictionary: Recipe attributes.	. Recipe attributes include recipe-line, description, ingredients, steps.	. Description is a text.	. Recipe has a set of ingredients.	. Recipe has a list of steps.	---	"	| frameEditor errors |	"Create a view frame."	frameEditor := HumFrameEditor ontology: aHumOntology viewEntity: 'recipe'.	"Add markup lines."	frameEditor addMarkUp: '!!!! Recipe'.	frameEditor addMarkUp: ' recipe-name: [name]'.	frameEditor addMarkUp: '   description: [description]'.	frameEditor addMarkUp: '   ingredients: [ingredients]'.	frameEditor addMarkUp: '         steps: [steps]'.	aHumOntology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).	errors := frameEditor saveFrameToOntology: aHumOntology.	self assert: ( errors isEmpty  ).		"TODO: Make this smarter. 	- At the very least, description, ingredients, and steps could be of type text.	- (and rendered using textarea tag).	"		"Create a dictionary frame."	frameEditor := HumFrameEditor ontology: aHumOntology dictionaryTitle: 'Recipe attributes.'.	frameEditor addDictionaryLine: 'Recipe attributes include recipe-line, description, ingredients, steps.'.	frameEditor addDictionaryLine: 'Description is a text.'.	"Should render as a text area."	frameEditor addDictionaryLine: 'Recipe has a set of ingredients.'.	"Should render as an unordered list."	frameEditor addDictionaryLine: 'Recipe has a list of steps.'.	"Should render as an ordered list."	errors := frameEditor saveFrameToOntology: aHumOntology.	self assert: ( errors isEmpty  ).	 			! !!HumSeasideUserInterfaceTests methodsFor: 'PA300 View Code Generator' stamp: 'RichardAlexanderGreen 12/18/2012 19:12'!test310ViewBecomesForm	"A Hum view frame is rendered as a Seaside Form.	TODO: Figure out how to handle read-only form later.	"	| ontology  viewFrame frameCode |	ontology := HumOntology new.		"Initialize the View Frame for this test."     self setUpViewFrameInOntology: ontology.	"There is only one frame in this ontology."	viewFrame :=  ontology fetchFrameByName: 'View: recipe.'.	self assert: viewFrame notNil. 	"Generate Seaside code for the view frame."	frameCode := viewFrame asSeasideWithOntology: ontology.	self assert: (frameCode findString: 'html form')  > 1.		self assert: ( frameCode isKindOf: String ).! !!HumSeasideUserInterfaceTests methodsFor: 'PA300 View Code Generator' stamp: 'RichardAlexanderGreen 11/3/2012 11:49'!test311ViewHasMultipleLines	"A Hum view frame is rendered as a Seaside Form.	TODO: Figure out how to handle read-only form later.	"	| ontology  viewFrame frameCode |	ontology := HumOntology new.		"Initialize the View Frame for this test."     self setUpViewFrameInOntology: ontology.	"There is only one frame in this ontology."	viewFrame :=  ontology fetchFrameByName: 'View: recipe.'.	self assert: viewFrame notNil. 	"Generate Seaside code for the view frame."	frameCode := viewFrame asSeasideWithOntology: ontology.	self assert: ( frameCode includesSubString: 'html form' ).	self assert: ( frameCode includesSubString: 'html break' ).! !!HumSeasideUserInterfaceTests methodsFor: 'PA300 View Code Generator' stamp: 'RichardAlexanderGreen 11/3/2012 11:49'!test312ViewHeader	"A Hum view frame is rendered as a Seaside Form.	TODO: Figure out how to handle read-only form later.	"	| ontology  viewFrame frameCode |	ontology := HumOntology new.		"Initialize the View Frame for this test."     self setUpViewFrameInOntology: ontology.	"There is only one frame in this ontology."	viewFrame :=  ontology fetchFrameByName: 'View: recipe.'.	self assert: viewFrame notNil. 	"Generate Seaside code for the view frame."	frameCode := viewFrame asSeasideWithOntology: ontology.	self assert: ( frameCode isKindOf: String ).	self assert: ( frameCode includesSubString: 'html form' ).	self assert: ( frameCode includesSubString: 'html break' ).	self assert: ( frameCode includesSubString: 'html heading level: 2' ).	self assert: ( frameCode includesSubString: 'Recipe').	! !!HumSeasideUserInterfaceTests methodsFor: 'PA300 View Code Generator' stamp: 'RichardAlexanderGreen 2/24/2013 10:05'!test313ViewField	"A Hum view frame is rendered as a Seaside Form.	TODO: Figure out how to handle read-only form later.	"	| ontology  viewFrame frameCode |	ontology := HumOntology new.		"Initialize the View Frame for this test."     self setUpViewFrameInOntology: ontology.	"There is only one frame in this ontology."	viewFrame :=  ontology fetchFrameByName: 'View: recipe.'.	self assert: viewFrame notNil. 	"Generate Seaside code for the view frame."	frameCode := viewFrame asSeasideWithOntology: ontology.	self assert: ( frameCode isKindOf: String ).	self assert: ( frameCode includesSubString: 'html form' ).	self assert: ( frameCode includesSubString: 'html break' ).	self assert: ( frameCode includesSubString: 'html heading level: 2' ).	self assert: ( frameCode includesSubString: 'html textInput callback: [').			self assert: ( frameCode includesSubString: 'setEntityID:').	self assert: ( frameCode includesSubString: 'toValue:').	self assert: ( frameCode includesSubString: '#name').			self assert: ( frameCode includesSubString: 'ingredients' ).		"See if the resulting code will compile in the context of a HumDialogAgent."		(Parser new) parse: ('checkRenderOn: html', String cr, frameCode) class: HumView.		Transcript show: '*** test313ViewField frameCode: ***'; cr; show: frameCode; cr.	! !!HumSeasideUserInterfaceTests methodsFor: 'PA300 View Code Generator' stamp: 'RichardAlexanderGreen 3/11/2013 07:31'!test314CheckGeneratedCode	"This is a place to see if generated code will compile and run."	| result anEntityID |		result := self builder render: [ :html | 	anEntityID := 'TestThisRecipe'.	"Following is pasted from test313ViewField Transcript show: 	TODO: Find a way to put in an actual method.	"	html form with: [ 		html break. html heading level: 2; with: ' Recipe'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #name toValue: datum ]; name: 'name'; value: 'name'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #description toValue: datum ]; name: 'description'; value: 'description'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #ingredients toValue: datum ]; name: 'ingredients'; value: 'ingredients'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #steps toValue: datum ]; name: 'steps'; value: 'steps'.		].	].	"Expect the HTML output to look like this."	"Compare strings ignoring differences in white space."	self assert: ( result like: '	<form accept-charset="utf-8" method="post" action="/">	  <br/>	  <h2>Recipe</h2>	  <br/><input name="name" value="name" type="text" class="text"/>	  <br/><input name="description" value="description" type="text" class="text"/>	  <br/><input name="ingredients" value="ingredients" type="text" class="text"/>	  <br/><input name="steps" value="steps" type="text" class="text"/>	</form>' ).	"		TODO: THIS IS JUST A CRUDE FIRST APPROXIMATION. 	It does not take data-types into account when selecting the rendering mode.	LONGER TERM: 	- Description should be a textarea with rows and columns.	- Ingredients and steps could be a table/list with some way to edit the entries.	- Ingredients (set) could be rendered as an unordered list.	- Steps (list) could be rendered as an ordered list.	 "	! !TestCase subclass: #HumOntologyTests	instanceVariableNames: ''	classVariableNames: 'Argument'	poolDictionaries: ''	category: 'Hum-Tests'!!HumOntologyTests commentStamp: 'RichardAlexanderGreen 1/2/2012 13:31' prior: 0!The ontology tests are mainly concerned with manipulating the ontolgy`s data structures.The method categories indicate the different kinds off data that are handled.!!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/9/2012 14:49'!test102addOneNoun	"Add one noun to current set."	| ontology |	ontology := HumOntology new.	ontology addNoun: 'location'.	self assert: ( (ontology nouns) includes: 'location' ).! !!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/9/2012 14:49'!test103addTwoNouns	"Add two nouns to current set."	| ontology |	ontology := HumOntology new.	"Add first noun."	ontology addNoun: 'location'.	self assert: ( (ontology nouns) includes: 'location' ).	"Add second noun."	ontology addNoun: 'place'.	self assert: ( (ontology nouns) includes: 'place' ).	"Make sure we did not overlay original"	self assert: ( (ontology nouns) includes: 'location' ).  ! !!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/9/2012 14:49'!test104addArrayOfNouns	"Add array of nouns to current set."	| ontology nounSet |	ontology := HumOntology new.	"Add one noun."	ontology addNoun: 'location'.	self assert: ( (ontology nouns) includes: 'location' ).		"Add from array."	ontology addNouns: #( 'place-1' 'place-2' 'place-3' ).	self assert: ( (ontology nouns) includes: 'place-3').	self assert: ( (ontology nouns) includes: 'location'). "Make sure we did not overlay original"	"Add from set."	nounSet := Set new.	nounSet add: 'first-location'.	nounSet add: 'second-location'.	nounSet add: 'third-location'.	ontology addNouns: nounSet.	self assert: ( (ontology nouns) includes: 'third-location').	self assert: ( (ontology nouns) includes: 'location').   "Make sure we did not overlay original"	! !!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 4/9/2012 11:45'!test110addEntityAttribute	"Add an entity-attribute relation."	| ontology  attributes |	ontology := HumOntology new.	"Add noun."	ontology addNoun: 'location'.	self assert: ( (ontology nouns) includes: 'location' ).	"Add entity-attribute relation."	ontology addEntity: 'location' attribute: 'GPS'.	"Test"	attributes := ontology immediateAttributesOfEntity: 'location'.	self assert: ( attributes include: 'GPS' ).			"Add a second entity-attribute relation."	ontology addEntity: 'location' attribute: 'location-name'.	"Test"	attributes := ontology immediateAttributesOfEntity: 'location'.	self assert: ( attributes include: 'location-name' ).	self assert: ( attributes include: 'GPS' ).		! !!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 4/10/2012 09:32'!test111getAllAttributesOfNoun	"Add an is-A relation."	| ontology allAttributes |	ontology := HumOntology new.	"Define a few relations."	ontology addEntity: 'party' attributes: #(  'name' 'alphabetized-name' 'address'  ).	ontology addEntity: 'address' attributes: #( 'street-direction' 'street-number' 'street-name' 'postal-code' ).	ontology addEntity: 'postal-code' attributes: #( 'city' 'state-province' 'nation' ).	ontology addNoun: 'person' isA: 'party'.	ontology addEntity: 'person' attributes: #( 'primary-phone-number'   ).	ontology addNoun: 'contact' isA: 'person'.	ontology addNoun: 'organization' isA: 'party'.		"The attrbutes include both the supertypes and the attributes of the supertypes."	"THINK -- Is this what we want?  What will we do with the supertypes?"	allAttributes := ontology allAttributesOfEntity: 'contact'.	self assert: ( allAttributes size ) = 11.	"	Transcript cr; show: 'test111getAllAttributesOfNoun -- Attributes of contact:'; cr; show: allAttributes; cr.	"					! !!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 3/22/2012 13:42'!test120addSubtype	"Add an is-A relation."	| ontology subtypes |	ontology := HumOntology new.	"Add noun."	ontology addNoun: 'location'.	self assert: ( (ontology nouns) includes: 'location' ).	"Add is-A relation."	ontology addNoun: 'residence' isA: 'location'.	"Test isKindOf"	self assert: ( ontology yesNoun: 'residence' isAKindOf: 'location').	"Test subtypes"	subtypes := ontology immediateSubtypesOf: 'location'.	self assert: ( subtypes isKindOf: Set).	self assert: ( ( ontology immediateSubtypesOf: 'location') includes: 'residence').! !!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 3/22/2012 13:42'!test121automaticSubtype	"Add an is-A relation."	| ontology |	ontology := HumOntology new.	"Add noun."	ontology addNoun: 'location'.	self assert: ( (ontology nouns) includes: 'location' ).	"Add an automatic subtype."	ontology addNoun: 'store-location'.	"Test isKindOf"	self assert: ( ontology yesNoun: 'store-location' isAKindOf: 'location').	"Test subtypes"	self assert: ( ( ontology immediateSubtypesOf: 'location') includes: 'store-location').! !!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 4/9/2012 11:14'!test122getAllSubtypesOfNoun	"Get all subtypes of a noun -- Use at run-time for polymorphism."	| ontology immediateSubtypes allSubtypes |	ontology := HumOntology new.	"Add a few subtype-supertype relations."	ontology addNoun: 'person' isA: 'party'.	ontology addNoun: 'organization' isA: 'party'.	ontology addNoun: 'worker' isA: 'person'.		ontology addNoun: 'employee' isA: 'worker'.	ontology addNoun: 'contractor' isA: 'worker'.	ontology addNoun: 'consultant' isA: 'worker'.		ontology addNoun: 'vendor' isA: 'organization'.	ontology addNoun: 'supplier' isA: 'vendor'.		immediateSubtypes := ontology immediateSubtypesOf: 'party'.	"Party has two subtypes (person, organization)."	self assert: ( immediateSubtypes size ) = 2.		"Party has 8 subtypes in the whole subtype tree. "	allSubtypes := ontology allSubtypesOf: 'party'.	self assert: ( allSubtypes size ) = 8.	"Transcript show: allSubtypes asSortedCollection; cr."					! !!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 5/29/2012 09:22'!test123getImmediateSupertypesOfNoun	"Get immediate super types of a noun -- Use when translating to another language ."	| ontology immediateSupertypes |	ontology := HumOntology new.	"Add a few subtype-supertype relations."	ontology addNoun: 'person' isA: 'party'.	ontology addNoun: 'organization' isA: 'party'.	ontology addNoun: 'worker' isA: 'person'.		ontology addNoun: 'employee' isA: 'worker'.	ontology addNoun: 'contractor' isA: 'worker'.		ontology addNoun: 'self-employed-consultant' isA: 'worker'.	ontology addNoun: 'self-employed-consultant' isA: 'vendor'.  "Test multiple inheritance case."		ontology addNoun: 'vendor' isA: 'organization'.	ontology addNoun: 'supplier' isA: 'vendor'.		immediateSupertypes := ontology immediateSupertypesOf:  'vendor'.	"Vendor has one immediate supertype: Vendor is an organization."	self assert: ( immediateSupertypes size ) = 1.		immediateSupertypes := ontology immediateSupertypesOf:  'supplier'.	"Supplier has one immediate supertype: Supplier is a vendor."	self assert: ( immediateSupertypes size ) = 1.		immediateSupertypes := ontology immediateSupertypesOf:  'employee'.	"Employee has one immediate supertype: Employee is a worker.."	self assert: ( immediateSupertypes size ) = 1.		immediateSupertypes := ontology immediateSupertypesOf:  'worker'.	"Worker has one immediate supertype: Worker is a party."	self assert: ( immediateSupertypes size ) = 1.		immediateSupertypes := ontology immediateSupertypesOf:  'person'.	"Party has two subtypes (person, organization)."	self assert: ( immediateSupertypes size ) = 1.		immediateSupertypes := ontology immediateSupertypesOf:  'party'.	"Party has no supertypes in this ontology."	self assert: ( immediateSupertypes size ) = 0.		immediateSupertypes := ontology immediateSupertypesOf:  'self-employed-consultant'.	"Self-employed-constulant has two immediate supertypes: 	Self-employed-consultant is a worker, and also a vendor."	self assert: ( immediateSupertypes size ) = 2.						! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 1/9/2012 14:53'!test310statementTokens	"A statement is made up of tokens."	| tokens statement |	"Make a statement and get its tokens."	statement := HumStatement from: 'Now, this is the time for all good men to come to the aid of their country.'.	tokens := statement tokens.	"Tokens are in an ordered collection (array-like)."	self assert: ( tokens at: 6 ) = 'time'.	 "Tokens are converted to lower case."	self assert: ( tokens includes: 'now' ). 	"Tokens include punctuation."	self assert: ( tokens includes: ',' ).	self assert: ( tokens includes: '.' ).		! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 5/29/2012 09:55'!test320statementEndsWithPeriodOrColon	"A statement must end with a period or a colon."	| statement |	statement := HumStatement new.		"A statement ending in a period should not raise an error."	statement source: 'This ends with a period.'.	self assert: ( statement errors ) isEmpty. 		"A statement ending in a colon should not raise an error."	statement source: 'For each token in statement tokens:'.
	self assert: ( statement errors ) isEmpty. 		"A statement not ending in a colon or period should raise an error."	statement source: 'This source statement is missing an ending period'.	self assert: ( statement errors ) isEmpty not.	"Transcript show: statement errors; cr."	! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 1/9/2012 14:53'!test330statementHasNouns	"A statement has nouns."	| statement role ontology statementNouns |	ontology := HumOntology new.	statement := HumStatement from: 'Move thing from current-location to new-location.'.	role := 'Mover'.	ontology addRole: role action: statement.		"The nouns might be defined after the statement is defined. "	ontology addNouns: #( 'thing' 'location' 'current-location' 'new-location' ).		"(Nouns are not completely bound until compile time.)"	statementNouns := ontology nounsInStatement: statement.	self assert: (statementNouns include: 'thing').	self assert: (statementNouns include: 'current-location').	self assert: (statementNouns include: 'new-location').			! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 5/29/2012 09:58'!test340statementParsing	"The parser recognizes that tokens are nouns, punctuation, keywords, or just words."	| statement role ontology statementNouns tokenTypes |	ontology := HumOntology new.	statement := HumStatement from: 'Add incoming-count to stock-count, giving updated-stock-count.'.	role := 'Calc'.	ontology addRole: role action: statement.		"The nouns might be defined after the statement is defined. "	ontology addNouns: #( 'count' 'incoming-count' 'stock-count' 'updated-stock-count' ).		"(Nouns are not completely bound until compile time.)"	statementNouns := ontology nounsInStatement: statement.	self assert: (statementNouns include: 'incoming-count').	self assert: (statementNouns include: 'stock-count').	self assert: (statementNouns include: 'updated-stock-count').		"Get tokenTypes."	tokenTypes := ontology parseStatement: statement keywords: #( 'if' 'else' 'giving' 'for' 'each' ).	"Check nouns."	self assert: ( tokenTypes include: ( 'incoming-count' -> #noun ) ).	self assert: ( tokenTypes include: ( 'stock-count' -> #noun ) ).	self assert: ( tokenTypes include: ( 'updated-stock-count' -> #noun ) ).	"Check keywords."	self assert: ( tokenTypes include: ( 'giving' -> #keyword ) ).	"Check punctuation."	self assert: ( tokenTypes include: ( ',' -> #punctuation ) ).	"Add is only another word.  -- Verbs are not special."	self assert: ( tokenTypes include: ( 'add' -> #word ) ).	"The word 'to' is only another word. -- Prepositions are not special."	self assert: ( tokenTypes include: ( 'to' -> #word ) ).			! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 9/18/2012 15:50'!test341statementParsingRemovesComments	"The parser recognizes that tokens are nouns, punctuation, keywords, or just words."	Transcript show: 'test341statementParsingRemovesComments has not been implemented yet.'; cr.	 	! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 9/18/2012 15:51'!test342statementParsingConsolidatesStrings	"The parser recognizes that tokens are nouns, punctuation, keywords, or just words."	 	Transcript show: 'test342statementParsingConsolidatesStrings has not been implemented yet.'; cr.! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 9/18/2012 15:52'!test343statementParsingSeparatesAnnotation	"The parser recognizes that tokens are nouns, punctuation, keywords, or just words."	 	Transcript show: 'test343statementParsingSeparatesAnnotation has not been implemented yet.'; cr.! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 5/29/2012 09:59'!test350statementAsHTML	"In the HTML rendering, statement nouns are enclosed in <n>...</n> to enable style sheet rendering."	| statement role ontology html |	ontology := HumOntology new.	statement := HumStatement from: 'Add incoming-count to stock-count, giving updated-stock-count.'.	role := 'Calc'.	ontology addRole: role action: statement.		"The nouns might be defined after the statement is defined. "	ontology addNouns: #( 'count' 'incoming-count' 'stock-count' 'updated-stock-count' ).		html := statement asHTML5withOntology: ontology keywords: #( 'giving' 'if' 'then' 'for' 'each' ).	self assert: ( '*Add *' matches: html ).	self assert: ( '*giving*' matches: html ).	self assert: ( '*<k>giving</k>*' matches: html ).	self assert: ( '*<n>stock-count</n>*' matches: html ).	self assert: ( '*<n>stock-count</n>,*' matches: html ).	self assert: ( '*<n>updated-stock-count</n>.*' matches: html ).! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 3/23/2012 14:19'!test360statementMatchesPatternForEach	"Test HumStatement>>onMatch: aPattern do: aBlock "	| statement pattern result |	true ifFalse: [ Transcript cr; show: 'test360statementMatchesPattern skipped'; cr.  ^self ].	"Match for each"	pattern := 'For each 1 in 2:'.	statement := HumStatement from: 'For each item in order:'.	result := 'No match'.	statement onMatch: pattern do: [ :item :order | result := 'Item=',item,' and ','order=',order ].	self assert: ( result sameAs: 'No match' ) not.	self assert: ( result sameAs: 'item=item and order=order' ).		! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 5/29/2012 10:03'!test361statementMatchesPatternForEachInThe	"Test HumStatement>>onMatch: aPattern do: aBlock "	| statement pattern result |	true ifFalse: [ Transcript cr; show: 'test361statementMatchesPatternForEachInThe skipped'; cr.  ^self ].	"Match for each"	pattern := 'For each 1 in the 2:'.	statement := HumStatement from: 'For each item in order:'.	"Preset 'No match' -- to fail fast if the pattern match does not work as expected.'"	result := 'No match'.	statement onMatch: pattern do: [ :item :order | result := 'Item=',item,' and ','order=',order ].	"Fail fast if the result was not reset."	self assert: ( result sameAs: 'No match' ) not.	"This is the result we are expecting."	self assert: ( result sameAs: 'item=item and order=order' ).		! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 5/29/2012 10:05'!test362statementMatchesPatternIsA	"Test HumStatement>>onMatch: aPattern do: aBlock "	| statement pattern result |	true ifFalse: [ Transcript cr; show: 'test362statementMatchesPatternIsA skipped'; cr.  ^self ].	"Match ___  is a ___"	pattern := 'A 1 is a 2 .' .	statement := HumStatement from: 'A menu is a bill-of-material.'.		"Preset 'No match' -- to fail fast if the pattern match does not work as expected.'"	result := 'No match'.	statement onMatch: pattern do: [ :menu :billOfMaterial | result := 'menu=',menu, ' and ', 'bill-of-material=',billOfMaterial ].	"Fail fast if the result was not reset."	self assert: ( result sameAs: 'No match' ) not.	"This is the result we are expecting."	self assert: ( result sameAs: 'menu=menu and bill-of-material=bill-of-material' ).		! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 5/29/2012 15:41'!test363statementMatchesElse	"Test HumStatement>>onMatch: aPattern do: aBlock "	| statement pattern result |	true ifFalse: [ Transcript cr; show: 'test363statementMatchesElse skipped'; cr.  ^self ].	"Match 'Else:'"	pattern := 'Else:' .	statement := HumStatement from: 'Else:'.	"Fail fast if there is no match."	result := 'No match'.	"The following will fail if the parser thinks there are nouns."	statement onMatch: pattern do: [ result := 'Else has no arguments.' ].	"Test for no match."	self assert: ( result sameAs: 'No match' ) not.	"This is the result we are expecting."	self assert: ( result sameAs: 'Else has no arguments.' ).		! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 5/29/2012 15:48'!test364statementMatchesCategories	"Test HumStatement>>onMatch: aPattern do: aBlock "	| statement pattern result |	true ifFalse: [ Transcript cr; show: 'test364statementMatchesCategories skipped'; cr.  ^self ].	". . . categories include blah, blah, blah."	pattern := '1 categories include * . ' .	statement := HumStatement from: 'Color categories include red, green, blue. '.	result := 'No match'.	statement onMatch: pattern do: [:color :list | result := 'color=', color, ' and ', 'list=', list asString. ].	self assert: ( result sameAs: 'No match' ) not.	self assert: ( result sameAs: 'color=color and list=an OrderedCollection(''red'' ''green'' ''blue'')' ).		! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 5/29/2012 15:49'!test365statementMatchesCategoriesAnd	"Test HumStatement>>onMatch: aPattern do: aBlock "	| statement pattern result |	true ifFalse: [ Transcript cr; show: 'test365statementMatchesCategoriesAnd skipped'; cr.  ^self ].	". . . categories include blah, blah, AND blah.'"	pattern := '1 categories include * . ' .	"The word 'and' should be allowed in a list without confusion."	statement := HumStatement from: 'Color categories include red, green, and blue. '.	result := 'No match'.	statement onMatch: pattern do: [:color :list | result := 'color=', color, ' and ', 'list=', list asString. ].	self assert: ( result sameAs: 'No match' ) not.	self assert: ( result sameAs: 'color=color and list=an OrderedCollection(''red'' ''green'' ''blue'')' ).		! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 5/29/2012 15:48'!test366statementMatchesAttributes	"Test HumStatement>>onMatch: aPattern do: aBlock "	| statement pattern result |	true ifFalse: [ Transcript cr; show: 'test366statementMatchesAttributes skipped'; cr.  ^self ].	". . .  attributes include blah, blah, blah."	pattern := '1 attributes include * . ' .	statement := HumStatement from: 'Party attributes include name, address, phone-number. '.	result := 'No match'.	statement onMatch: pattern do: [:party :list | result := 'party=', party, ' and ', 'list=', list asString. ].	self assert: ( result sameAs: 'No match' ) not.	self assert: ( result sameAs: 'party=party and list=an OrderedCollection(''name'' ''address'' ''phone-number'')' ).		! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 5/29/2012 15:47'!test367statementMatchesAttributesAnd	"Test HumStatement>>onMatch: aPattern do: aBlock "	| statement pattern result |	true ifFalse: [ Transcript cr; show: 'test367statementMatchesAttributesAnd skipped'; cr.  ^self ].	". . . attributes include . . . blah, blah, AND blah "	pattern := '1 attributes include * . ' .	statement := HumStatement from: 'Party attributes include name, address, and phone-number. '.	result := 'No match'.	statement onMatch: pattern do: [:party :list | result := 'party=', party, ' and ', 'list=', list asString. ].	self assert: ( result sameAs: 'No match' ) not.	self assert: ( result sameAs: 'party=party and list=an OrderedCollection(''name'' ''address'' ''phone-number'')' ).		! !!HumOntologyTests methodsFor: 'about Ontology' stamp: 'RichardAlexanderGreen 12/30/2011 13:13'!test001newOntology	"create a new Ontology"	| ontology |	ontology := HumOntology new.	self assert: ( ontology nouns) isEmpty.	self assert: ( ontology roles) isEmpty.		! !!HumOntologyTests methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 9/15/2012 10:56'!test510CreatePlanFrame	"Make one plan frame. (TDD to drive basic parts)"	| planFrame preconditions actionSet ontology |		ontology := HumOntology new.	"A plan frame has a goal. (post condition)"	planFrame := HumFrame4Plan ontology: ontology goal: 'Bake a cake per recipe.'.	self assert: (( planFrame goal ) matches: 'Bake a cake per recipe.').		"A plan frame has a set of preconditions."	preconditions := planFrame preconditions.	self assert: ( preconditions isKindOf: Set ).		planFrame addPrecondition: 'Oven is preheated per recipe.'.	self assert: ( preconditions size ) = 1.		planFrame addPrecondition: 'Batter is mixed per recipe ingredients.'.	self assert: ( preconditions size ) = 2.	planFrame addPrecondition: 'Batter is in cake-pan per recipe pan-size.'.	self assert: ( preconditions size ) = 3.	"A plan frame has a set of zero or more actions	 that move the state	 from the preconditions 	to the post condition (goal)."	actionSet := planFrame planActions.	self assert: ( actionSet isKindOf: Set ).		planFrame addActionRole: 'Baker' 	                         statement: 'Bake the cake-pan per recipe baking-time.' 	                            comment: ''.	self assert: ( actionSet size ) = 1.			! !!HumOntologyTests methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 9/15/2012 10:56'!test520CheckPlanFrame	"A plan frame must have a goal and at least two preconditions.	 -- Perhaps this rule is a 'should' rather than a 'must'.	-- The plan would still work,	     but a plan with a large number of frames with just one precondition	     seems a bit odd.	-- A better check would detect a string of such plan frames. 	-- TODO REFACTOR, TO MAKE THIS A 'SHOULD' RATHER THAN A MUST. " 	| planFrame problems  ontology |		ontology := HumOntology new.			planFrame := HumFrame4Plan new.	problems := planFrame check.	self assert: ( problems include: 'A plan frame must have a goal.' ).		"Fix that problem."	planFrame ontology: ontology; goal: 'Bake a cake per recipe'.		"A plan frame SHOULD have at least two preconditions."	"If there is only one, the business process should be stated as a procedure."	self assert: ( ( planFrame check) include:  'A plan frame should have at least two preconditions.' ).		"Half fix that problem."	planFrame addPrecondition: 'Oven is preheated per recipe.'.			self assert: (  ( planFrame check)  include:  'A plan frame should have at least two preconditions.' ).		"Fully fix that problem."	planFrame addPrecondition: 'Batter is in bake-pan per recipe.'.		self assert: (  ( planFrame check)  isEmpty ).				! !!HumOntologyTests methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 9/15/2012 10:56'!test530AddPlanFrame	"Make one plan frame. (TDD to drive basic parts)"	| planFrame ontology |		ontology := HumOntology new.	"A plan frame should have a goal and at least two preconditions."		planFrame := HumFrame4Plan  ontology: ontology goal: 'Bake a cake per recipe'.	planFrame addPrecondition: 'Oven is preheated per recipe.'.		planFrame addPrecondition: 'Batter is in bake-pan per recipe.'.	planFrame addActionRole: 'Baker' statement: 'Bake bake-pan in the oven per recipe.'.		ontology storeFrame: planFrame.		! !!HumOntologyTests methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 9/15/2012 10:56'!test540GetPlanTree	"Make several plan frames. Get the resulting plan tree."	| planFrame1 planFrame2 planFrame3 ontology planTree |		ontology := HumOntology new.	"A plan frame must have a goal and at should have at least two preconditions."		planFrame1 := HumFrame4Plan ontology: ontology goal: 'Bake a cake per recipe.'.	planFrame1 addPrecondition: 'Oven is preheated per recipe.'.		planFrame1 addPrecondition: 'Batter is in bake-pan per recipe.'.	planFrame1 addActionRole: 'Baker' statement: 'Bake bake-pan in the oven per recipe.'.	ontology storeFrame: planFrame1.			planFrame2 := HumFrame4Plan ontology: ontology goal: 'Oven is preheated per recipe.'.	planFrame2 addPrecondition: 'Oven is cleared out.'.	planFrame2 addPrecondition: 'Oven is on.'.	planFrame2 addPrecondition: 'Oven temperature is set per recipe.'.	planFrame2 addActionRole: 'Timer' statement: 'Wait 5 minutes.'.	ontology storeFrame: planFrame2.		planFrame3 := HumFrame4Plan ontology: ontology goal: 'Batter is in bake-pan per recipe.'.	planFrame3 addPrecondition: 'Batter fully mixed per recipe.'.	planFrame3 addPrecondition: 'Bake-pan is greased per recipe.'.	planFrame3 addActionRole: 'Baker' statement: 'Pour batter into bake-pan per recipe.'.	ontology storeFrame: planFrame3.		planTree := ontology buildPlanTreeForGoal:  'Bake a cake per recipe.'.	self assert: ( planTree size ) = 7.		"ontology showPlanTree: planTree."		"TODO: IS THIS CORRECT? THIS TEST DOES NOT COUNT THE GOAL AT THE ROOT AS PART OF THE PLAN TREE."	self assert: ( planTree includes: (( HumStatement source: 'Bake a cake per recipe.' ) -> (HumStatement source:  'Batter is in bake-pan per recipe.') ) ).
 	! !!HumOntologyTests methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 9/15/2012 10:56'!test550CheckPlanTree	"Check for an incomplete plan."	| planFrame1 planFrame2 planFrame3 ontology planTreeProblems |		ontology := HumOntology new.	"A plan frame must have a goal and should have at least two preconditions."		planFrame1 := HumFrame4Plan ontology: ontology goal: 'Bake a cake per recipe.'.	planFrame1 addPrecondition: 'Oven is preheated per recipe.'.		planFrame1 addPrecondition: 'Batter is in bake-pan per recipe.'.	planFrame1 addActionRole: 'Baker' statement: 'Bake bake-pan in the oven per recipe.'.	ontology storeFrame: planFrame1.			planFrame2 := HumFrame4Plan ontology: ontology goal: 'Oven is preheated per recipe.'.	planFrame2 addPrecondition: 'Oven is cleared out.'.	planFrame2 addPrecondition: 'Oven is on.'.	planFrame2 addPrecondition: 'Oven temperature is set per recipe.'.	planFrame2 addActionRole: 'Timer' statement: 'Wait 5 minutes.'.	ontology storeFrame: planFrame2.		planFrame3 := HumFrame4Plan ontology: ontology goal: 'Batter is in bake-pan per recipe.'.	planFrame3 addPrecondition: 'Batter fully mixed per recipe.'.	planFrame3 addPrecondition: 'Bake-pan is greased per recipe.'.	planFrame3 addActionRole: 'Baker' statement: 'Pour batter into bake-pan per recipe.'.	ontology storeFrame: planFrame3.		planTreeProblems := ontology checkPlanTreeForGoal:  'Bake a cake per recipe.'.	self assert: ( planTreeProblems size ) = 5.	"	Transcript cr; show: 'Plan Tree Problems:'.	planTreeProblems do: [ :problem | Transcript cr; show: problem. ].	"	! !!HumOntologyTests methodsFor: 'render Frame as HTML' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test620renderFrame4PlanAsHTML	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology html thisFrame |	ontology := HumOntology new.		"Initialize for a Plan Frame."	frameEditor := HumFrameEditor ontology: ontology goal: 'Cake is baked according to recipe..'.	frameEditor addPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameEditor addPrecondition: 'The recipe`s batter is in a prepared cake pan.'.	frameEditor addActionRole: 'Timer' statement: 'Bake the pan in the oven for the time given in the recipe.' .		thisFrame :=  ( frameEditor frame ).	ontology storeFrame: thisFrame.	html := ontology asHTML5 .	"Test:  Is the goal-statement included in the HTML ?"	self assert: ( '*according to recipe*' match: html).		"Test: Are each of the preconditions included ?"		self assert: (  '*preheated*' match: html ).	self assert: (  '*batter*'  match: html ).	"Test: Is the action instruction role and statment included ?"	self assert: (  '*Timer*'  match: html).	self assert: (  '*time given*'  match: html ).	! !!HumOntologyTests methodsFor: 'render Frame as HTML' stamp: 'RichardAlexanderGreen 10/30/2012 14:14'!test630renderFrame4ActionAsHTML	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology html |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameEditor ontology: ontology  	                                               role: 'Role' action: 'Bake the pan in the oven for the time given in the recipe.'.	frameEditor addInstructionStatement: 'Open the oven door.'.	frameEditor addInstructionStatement: 'Place the pan in the oven.'.	frameEditor addInstructionStatement: 'Close the oven door.'.	frameEditor addInstructionRole: 'Oven' statement: 'Bake for the time given.' comment: 'We have a smart oven.'.		ontology storeFrame: ( frameEditor frame ).	html := ontology asHTML5.		"Test: Title line is rendered."	self assert: ( '*time given*' matches: html ).	"First instruction is rendered."	self assert: ( '*Open the oven*' matches: html ).		"2nd instruction is rendered."	self assert: ( '*pan in the oven*' matches: html ).	"3rd instruction is rendered."	self assert: ( '*Close the oven*' matches: html ).	"4th inststruction statement is rendered"	self assert: ( '*Bake for the time*' matches: html ).	"Comment is rendered"	self assert: ( '*smart oven*' matches: html ).	"Role is rendered."	self assert: ( '*  <role>  Oven*' matches: html ).		! !!HumOntologyTests methodsFor: 'render Frame as HTML' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test640renderFrame4ViewAsHTML	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology html |	ontology := HumOntology new.		"Initialize for a View Frame."	frameEditor := HumFrameEditor ontology: ontology viewEntity: 'recipe.'.	frameEditor addMarkUp: '!!!! Recipe'.	frameEditor addMarkUp: ' recipe-name: [name]'.	frameEditor addMarkUp: '   description: [description 5]'.	frameEditor addMarkUp: '   ingredients: [ingredients]'.	frameEditor addMarkUp: '            steps: [steps]'.	self assert: ( frameEditor notNil ).		ontology storeFrame: ( frameEditor frame ).	html := ontology asHTML5.	"Test that labels are present in the rendering."	"Title line"	self assert: ('*Recipe*' matches: html).	"1st markup line"	self assert: ('*recipe-name: *' matches: html).	"2nd markup line"	self assert: ('*description: *' matches: html).	"3rd markup line"	self assert: ('*ingredients: *' matches: html).	"4th (last) marup line"	self assert: ('*steps: *' matches: html).		"Test that widgets are present in the rendering."	"1st markup line"	self assert: ('*recipe-name: <widget>*</widget>*' matches: html).	"2nd markup line"	self assert: ('*description: <widget>*</widget>*' matches: html).	"3rd markup line"	self assert: ('*ingredients: <widget>*</widget>*' matches: html).	"4th (last) marup line"	self assert: ('*steps: <widget>*</widget>*' matches: html).		"TODO: THIS DOES NOT SEEM TO BE COMPLETE."				! !!HumOntologyTests methodsFor: 'render Frame as HTML' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test650renderFrame4DictionaryAsHTML	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology html |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameEditor := HumFrameEditor ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	frameEditor addDictionaryLine: 'Recipe attributes include recipe-name, description, ingredients, steps.'.	frameEditor addDictionaryLine: 'Recipe includes a list of ingredients.'.	frameEditor addDictionaryLine: 'Recipe includes a list of steps.'.	frameEditor addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	frameEditor addDictionaryLine: 'Step attributes include step-number, step-description'.			self assert: ( frameEditor notNil ).		ontology storeFrame: ( frameEditor frame ).	html := ontology asHTML5.		""	self assert: ( '*vocabulary*' matches: html ).	""	self assert: ( '*recipe-name*' matches: html ).	""	self assert: ( '*list of ingredients*' matches: html ).	""	self assert: ( '*step-number*' matches: html ).	""	self assert: ( '*Ingredient attributes*' matches: html ).	""	self assert: ( '*Step attributes*' matches: html ).		"Transcript show: html; cr."	! !!HumOntologyTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 4/3/2012 13:21'!test370forStatementAsSmalltalk	"Translate for . . .    to Smalltalk"	|     forStatement   forSmalltalk ontology |	true ifFalse: [ Transcript cr; show: 'test370forStatementAsSmalltalk skipped'; cr. ^self.].	"---	Dictionary: Order.	An order has a list of order-items.	---	"	ontology := HumOntology new.	"Add entity-attribute relation."	ontology addEntity: 'order' attribute: 'order-items'.	"Translate the Hum 'For . . . '   statement into Smalltalk."	forStatement := HumStatement source: 'For each order-item in the order:'.	forSmalltalk := forStatement asSmalltalkWithOntology: ontology.	"Expect: 	( blackboard entity: order attribute: 'orderItems' ) do: [ :orderItem |	"	self assert: ( '*do:*' matches: forSmalltalk ).	self assert: ( '*self blackboard entity: ''order'' attribute: ''orderItem''*' matches: forSmalltalk ).	self assert: ( '*:orderItem |*' matches: forSmalltalk ).	self assert: ( '*self ( self*' matches: forSmalltalk ) not.	"	Transcript cr; show: 'from test370forStatementAsSmalltalk: '; 			     cr; show: forSmalltalk; cr.	"			! !!HumOntologyTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/24/2012 15:43'!test380ifStatementAsSmalltalk	"Translate if . . .   to  Smalltalk"	| ifStatement     ifSmalltalk     ontology |	true ifFalse: [ Transcript cr; show: 'test380ifStatementAsSmalltalk skipped'; cr. ^self.].	ifStatement := HumStatement from: 'If account balance is greater than account last-invoice-total :'.	ontology := HumOntology new.	ontology addNouns: #( 'account' 'balance' 'last-invoice-total').	ifSmalltalk := ifStatement asSmalltalkWithOntology: ontology.	self assert: ( '(  ( blackboard entity: ''account'' attribute: ''balance'' ) > ( blackboard entity: ''account'' attribute: ''lastInvoiceTotal'' ) )  ifTrue: [' matches: ifSmalltalk ).			! !!HumOntologyTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/24/2012 15:44'!test381ifStatementAsSmalltalk	"Translate if . . .   to  Smalltalk"	| ifStatement     ifSmalltalk     ontology |	true ifFalse: [ Transcript cr; show: 'test381ifStatementAsSmalltalk skipped'; cr. ^self.].	ifStatement := HumStatement from: 'If account balance > account last-invoice-total :'.	ontology := HumOntology new.	ontology addNouns: #( 'account' 'balance' 'last-invoice-total').	ifSmalltalk := ifStatement asSmalltalkWithOntology: ontology.	self assert: ( '(  ( blackboard entity: ''account'' attribute: ''balance'' ) > ( blackboard entity: ''account'' attribute: ''lastInvoiceTotal'' ) )  ifTrue: [' matches: ifSmalltalk ).			! !!HumOntologyTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/24/2012 15:47'!test382ifStatementAsSmalltalk	"Translate if . . .   to  Smalltalk"	| ifStatement     ifSmalltalk     ontology |	true ifFalse: [ Transcript cr; show: 'test381ifStatementAsSmalltalk skipped'; cr. ^self.].	ifStatement := HumStatement from: 'If account balance = account last-invoice-total :'.	ontology := HumOntology new.	ontology addNouns: #( 'account' 'balance' 'last-invoice-total').	ifSmalltalk := ifStatement asSmalltalkWithOntology: ontology.	self assert: ( '(  ( blackboard entity: ''account'' attribute: ''balance'' ) = ( blackboard entity: ''account'' attribute: ''lastInvoiceTotal'' ) )  ifTrue: [' matches: ifSmalltalk ).			! !!HumOntologyTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/24/2012 15:48'!test383ifStatementAsSmalltalk	"Translate if . . .   to  Smalltalk"	| ifStatement     ifSmalltalk     ontology |	true ifFalse: [ Transcript cr; show: 'test381ifStatementAsSmalltalk skipped'; cr. ^self.].	ifStatement := HumStatement from: 'If account balance is equal to account last-invoice-total :'.	ontology := HumOntology new.	ontology addNouns: #( 'account' 'balance' 'last-invoice-total').	ifSmalltalk := ifStatement asSmalltalkWithOntology: ontology.	self assert: ( '(  ( blackboard entity: ''account'' attribute: ''balance'' ) = ( blackboard entity: ''account'' attribute: ''lastInvoiceTotal'' ) )  ifTrue: [' matches: ifSmalltalk ).			! !!HumOntologyTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/24/2012 15:55'!test384ifStatementAsSmalltalk	"Translate if . . .   to  Smalltalk"	| ifStatement     ifSmalltalk     ontology |	true ifFalse: [ Transcript cr; show: 'test384ifStatementAsSmalltalk skipped'; cr. ^self.].	ifStatement := HumStatement from: 'If account last-invoice-total is less than  account balance :'.	ontology := HumOntology new.	ontology addNouns: #( 'account' 'balance' 'last-invoice-total').	ifSmalltalk := ifStatement asSmalltalkWithOntology: ontology.	self assert: ( '(  ( blackboard entity: ''account'' attribute: ''lastInvoiceTotal'' ) < ( blackboard entity: ''account'' attribute: ''balance'' ) )  ifTrue: [' matches: ifSmalltalk ).			! !!HumOntologyTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 3/24/2012 15:55'!test385ifStatementAsSmalltalk	"Translate if . . .   to  Smalltalk"	| ifStatement     ifSmalltalk     ontology |	true ifFalse: [ Transcript cr; show: 'test385ifStatementAsSmalltalk skipped'; cr. ^self.].	ifStatement := HumStatement from: 'If account last-invoice-total < account balance :'.	ontology := HumOntology new.	ontology addNouns: #( 'account' 'balance' 'last-invoice-total').	ifSmalltalk := ifStatement asSmalltalkWithOntology: ontology.	self assert: ( '(  ( blackboard entity: ''account'' attribute: ''lastInvoiceTotal'' ) < ( blackboard entity: ''account'' attribute: ''balance'' ) )  ifTrue: [' matches: ifSmalltalk ).			! !!HumOntologyTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 10/31/2012 09:51'!test390elseStatementAsSmalltalk	"Translate if . . .  else . . .  to Smalltalk"	| ifStatement elseStatement   ifSmalltalk elseSmalltalk  ontology |		false ifFalse: [ Transcript cr; show: '*** test390elseStatementAsSmalltalk is INCOMPLETE ***'; cr. ^self.].		ifStatement := ''.	elseStatement := ''.	ontology := HumOntology new.	ontology addNouns: #().	ifSmalltalk := ifStatement asSmalltalkWithOntology: ontology.	elseSmalltalk := elseStatement asSmalltalkWithOntology: ontology.	self shouldBeImplemented.	self assert: ( '**' matches: ifSmalltalk ).	self assert: ( '**' matches: elseSmalltalk ).			! !!HumOntologyTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test710translateFrame4ActionToSmalltalk	"Given: a Hum action frame.	When: translated to Smalltalk	Then: the resulting code is usable.	"	| frameEditor ontology code |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameEditor ontology: ontology  	                                               role: 'Cook' action: 'Bake the pan in the oven for the time given in the recipe.'.	frameEditor addInstructionStatement: 'Open the oven door.'.	frameEditor addInstructionStatement: 'Place the pan in the oven.'.	frameEditor addInstructionStatement: 'Close the oven door.'.	frameEditor addInstructionRole: 'Oven' 	                                    statement: 'Heat for the time given in the recipe.' 	                                       comment: 'We have a smart oven.'.		ontology storeFrame: ( frameEditor frame ).	ontology addNouns: #( 'pan' 'oven' 'recipe' 'time' 'door' ).	code := ontology asSmalltalk.		"Test: Title line is rendered."	self assert: ( '*bakeThePanInTheOvenForTheTimeGivenInTheRecipeQpan: aPan oven: aOven time: aTime recipe: aRecipe*' matches: code ).		"First instruction is rendered."	self assert: ( '*openTheOvenDoorQoven: aOven door: aDoor*' matches: code ).		"2nd instruction is rendered."	self assert: ( '*placeThePanInTheOvenQpan: aPan oven: aOven*' matches: code ).	"3rd instruction is rendered."	self assert: ( '*closeTheOvenDoorQoven: aOven door: aDoor*' matches: code ).	"4th (delegated) inststruction is rendered"	self assert: ( '*heatForTheTimeGivenInTheRecipeQtime: aTime recipe: aRecipe*' matches: code ).	"Comment is rendered"	self assert: ( '*smart oven*' matches: code ).	"Role is rendered."	self assert: ( '*Oven:*' matches: code ).		"Transcript cr; show: 'Generated Smalltalk:'; cr; show: code; cr."		! !!HumOntologyTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test720translateFrame4ActionToSmalltalk	"Given: a Hum action frame.	When: translated to Smalltalk	Then: the resulting code is usable.	(This test is like the last test (test710) but 'door' is not in the list of nouns, 	and we get a slightly different result.)	"	| frameEditor ontology code |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameEditor ontology: ontology  	                                               role: 'Cook' action: 'Bake the pan in the oven for the time given in the recipe.'.	frameEditor addInstructionStatement: 'Open the oven door.'.	frameEditor addInstructionStatement: 'Place the pan in the oven.'.	frameEditor addInstructionStatement: 'Close the oven door.'.	frameEditor addInstructionRole: 'Oven' 	                                    statement: 'Heat for the time given in the recipe.' 	                                       comment: 'We have a smart oven.'.		ontology storeFrame: ( frameEditor frame ).	ontology addNouns: #( 'pan' 'oven' 'recipe' 'time' ).	code := ontology asSmalltalk.	"Transcript cr; show: 'Generated Smalltalk:'; cr; show: code; cr."		"Test: Title line is rendered."	self assert: ( '*bakeThePanInTheOvenForTheTimeGivenInTheRecipeQpan: aPan oven: aOven time: aTime recipe: aRecipe*' matches: code ).		"First instruction is rendered."	self assert: ( '*openTheOvenDoorQoven: aOven*' matches: code ).		"2nd instruction is rendered."	self assert: ( '*placeThePanInTheOvenQpan: aPan oven: aOven*' matches: code ).	"3rd instruction is rendered."	self assert: ( '*closeTheOvenDoorQoven: aOven*' matches: code ).	"4th (delegated) inststruction is rendered"	self assert: ( '*aOven heatForTheTimeGivenInTheRecipeQtime: aTime recipe: aRecipe*' matches: code ).	"Comment is rendered"	self assert: ( '*smart oven*' matches: code ).	"Role is rendered."	self assert: ( '*Oven:*' matches: code ).			! !!HumOntologyTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test730translateFrame4ActionToSmalltalkExdentToBlockEnd	"Given: a Hum action frame.	When: translated to Smalltalk	Then: the resulting code reflects the block structure as indicated by indentation.	"	| frameEditor ontology code |		true ifFalse: [ Transcript cr; show: 'test730translateFrame4ActionToSmalltalkExdentToBlockEnd is turned off'; cr. ].	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameEditor ontology: ontology  	                                               role: 'Cook' action: 'Fulfill order.'.	"Enter an iteration statement."	frameEditor addInstructionStatement: '. For each order-item in the order: '.	"Enter some inside the loop. (It should be indented when rendered.)"	"THINK: Should we require indentation here."	frameEditor addInstructionStatement: '. . Pull order-item quantity from stock and place on cart.'.	"Next statement has no indent. That signals end of the iteration block."	frameEditor addInstructionStatement: '. Ship the order to the order-address.'.			ontology storeFrame: ( frameEditor frame ).	ontology addEntity: 'order' attributes: #(  'order-items' 'order-address' customer ).	ontology addEntity: 'order-item' attributes: #( 'catalog-id' 'product-label' 'quantity' 'unit-price'  ).	ontology addNoun: 'quantity' isA: 'measure'.	ontology addEntity: 'address' attributes: #( 'street-line1' 'street-line2' postal-code ).	ontology addEntity: 'postal-code' attributes: #( code-string city ).	ontology addEntity: 'city' attributes: #( city-name province state nation ).	ontology addNouns: #( 'order' 'order-item' 'order-address'  ).		code := ontology asSmalltalk.	"	Transcript cr; 		show: 'test730translateFrame4ActionToSmalltalkExdentToBlockEnd'; 		cr; show:' Generated Smalltalk:'; 		cr; show: code; cr.	"	"Test: Title line is rendered."	self assert: ( '*do:*' matches: code ).	self assert: ( '*fulfillOrderQorder: aOrder*' matches: code ).	self assert: ( '*orderItem*' matches: code).	self assert: ( '*blackboard entity: ''order'' attribute: ''orderItem''*' matches: code ).	self assert: ( '*:orderItem*' matches: code ).	"Look for opening and closing ']' on the block."	self assert: ('*[*' matches: code ).	self assert: ('*]*' matches: code ).	self assert: ( code trimBoth endsWith: ']' ) not.	self assert: ( '*self ( self*' matches: code ) not.					! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 16:38'!test900checkUsability	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template  cr code |	"Test using a dictionary statement pattern."	pattern := '1 has a list of 2'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: 'Frame has a list of frameLines. '.	"Should match"	self assert: (frameLine matchesPattern: pattern ).	"Generate some code"	"Check usability -- What if we wanted to generate Smalltalk?"	cr := String cr.	template := 'ontology addEntity: ''1'' attribute: ''2''.', cr, 'ontology addNoun: ''2'' isA: ''list''.'.	"Check usability -- What if we wanted to generate Java?  	In this situation, we need the singular form of the noun.
	So we will extend the template notation . . .	(2~ indicates the singular form of noun 2)"	template := 'private List<2~> 2;', cr, '1.attribute( 2 );'.	"Check usability -- What if we wanted to generate JavaScript?"	template := 'var 2 = [];  1["2"] = 2;'.		"Check usability -- What if we wanted to generate Erlang?	We will use an ets to represent an entity in Erlang.	(An Erlang record would probably be a better representation but it is not very dynamic.).	Anyway, this is mainly for testing 	Note: 2 must be a good-enough Erlang atom.	All of these languages will require that Hum nouns such as billing-address be translated to camelCase.	"	template := 'ets:new( 1, [ ordered_set, named_table ] ),', cr, 'ets:insert( 1, { 2, [] } ),'.		"Check usability -- What if we wanted to generate Python?	 We will represent entities using a dictionary in Python."	template := '1 = dict()', cr, '1.setdefault( "2", [ ] )'.  		"Generate arbitrary code"	code := frameLine onMatch: pattern generate: template.		! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 16:38'!test910lineMatchesPattern	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template arguments cr |	"Test using a dictionary statement pattern."	pattern := '1 has a list of 2'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: 'Frame has a list of frameLines. '.	"Should match"	self assert: (frameLine matchesPattern: pattern ).	! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 17:09'!test911lineDoesNotMatchPattern	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template arguments cr |	"Test using a dictionary statement pattern."	pattern := '1 has a list of 2'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: 'Frame has a set of frameLines. '.	"Should not match"	self assert: (frameLine matchesPattern: pattern ) not.	! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 18:04'!test912lineMatchesFloatingPattern	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template arguments cr |	"Test using a dictionary statement pattern."	pattern := '[1]'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: ' blah blah label: [attribute] blah blah '.	"Should match"	self assert: (frameLine matchesPattern: pattern ).	! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 18:23'!test913lineMatchesFloatingPattern	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template arguments cr |	"Test using a dictionary statement pattern."	pattern := '[1 2]'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: ' blah blah label: [entity attribute] blah blah '.	"Should match"	self assert: (frameLine matchesPattern: pattern ).	! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 18:24'!test914lineMatchesFloatingPattern	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template arguments cr |	"Test using a dictionary statement pattern."	pattern := '[1: 2]'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: ' blah blah label: [pane: view] blah blah '.	"Should match"	self assert: (frameLine matchesPattern: pattern ).	! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 18:25'!test915lineFailsFloatingPattern	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template arguments cr |	"Test using a dictionary statement pattern."	pattern := '(1)'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: ' blah blah label: [pane: view] blah blah '.	"Should match"	self assert: (frameLine matchesPattern: pattern ) not.	! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 19:44'!test920lineMatchesPatternParameters	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template parameters cr |	"Test using a dictionary statement pattern."	pattern := '1 has a list of 2'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: 'Frame has a list of frameLines. '.	"Should match"	self assert: (frameLine matchesPattern: pattern ).	"Get parameters"	parameters := frameLine extractPatternParameters: pattern.	self assert: ( parameters at: 1 ) = 'frame'.		self assert: ( parameters at: 2 ) = 'framelines'.	! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 19:46'!test922lineMatchesFloatingPatternParameters	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template parameters cr |	"Test using a dictionary statement pattern."	pattern := '[1]'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: ' blah blah label: [attribute] blah blah '.	"Should match"	self assert: (frameLine matchesPattern: pattern ).	"Get parameters"	parameters := frameLine extractPatternParameters: pattern.	self assert: ( parameters at: 1 ) = 'attribute'.		! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 19:47'!test923lineMatchesFloatingPatternParameters	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template parameters cr |	"Test using a dictionary statement pattern."	pattern := '[1 2]'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: ' blah blah label: [entity attribute] blah blah '.	"Should match"	self assert: (frameLine matchesPattern: pattern ).		"Get parameters"	parameters := frameLine extractPatternParameters: pattern.	self assert: ( parameters at: 1 ) = 'entity'.		self assert: ( parameters at: 2 ) = 'attribute'.	! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 20:37'!test930generateCode	"Generate some code that does not require that we find a singular noun.	"	| frameLine pattern template  cr code |	"Test using a dictionary statement pattern."	pattern := '1 has a list of 2'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: 'Frame has a list of frameLines. '.	"Should match"	self assert: (frameLine matchesPattern: pattern ).	"Generate some code"	"Check usability -- What if we wanted to generate JavaScript?"	template := 'var 2 = [];  1["2"] = 2;'.		"Generate arbitrary code"	code := frameLine onMatch: pattern generate: template.		self assert: ( code sameAs: 'var framelines = [];  frame["framelines"] = framelines;' ).		! !!HumOntologyTests methodsFor: 'about Actions' stamp: 'RichardAlexanderGreen 2/1/2012 20:18'!test410addOneAction	"An action belongs to a role."		| ontology source statement |		"Set up"	ontology := HumOntology new.		"Add role."	ontology addRole: 'Mover'.	self assert: ( ( ontology roles ) includes: 'mover' ).		"An action is identified by a statement."	source := 'Move portable-object from current-location to new-location.'.	statement := HumStatement from: source.		"Add action to the role's set of actions."	ontology addRole: 'Mover' action: statement.	self assert: ( ontology yesRole: 'Mover' hasAction: source ).	! !!HumOntologyTests methodsFor: 'about Actions' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!test420actionInstructions	"An action statement is defined by a sequence of instructions."		| ontology role action instruction1 instruction2 instructionSequence |		"Set up"	ontology := HumOntology new.		"Add action to the role's set of actions."	role := 'Cook'.	action := 'Bake a cake per recipe.'.	ontology addRole: role action:  ( HumStatement from: action ).	self assert: ( ontology yesRole: role hasAction: action ).		"Create an instruction."	" -- Instructions elements are all optional and include role, statement, comment, annotaion, translation."	instruction1 := HumInstructionLine new.	instruction1 statement: 'Preheat oven to recipe`s oven-temperature.'; role: 'Oven'.	                   	"Append instruction to sequence of instructions."	ontology appendRole: role action: action instruction: instruction1.	"test"	instructionSequence := ( ontology instructionsForRole: role action: action ).	self assert: ( instructionSequence includes: instruction1).		"Create another instruction."	instruction2 := HumInstructionLine new.	instruction2 statement: 'Mix batter per recipe.'; role: 'Mixer'; annotation: 'duration: 5 minutes'.	self assert: ( instructionSequence size) = 1.	self assert: ( instructionSequence last = instruction1).		"Append second instruction to sequence of instructions."	ontology appendRole: role action: action instruction: instruction2.	"test"	instructionSequence := ( ontology instructionsForRole: role action: action ).	self assert: ( instructionSequence size) = 2.	self assert: ( instructionSequence last = instruction2).			! !!HumOntologyTests methodsFor: 'about Actions' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!test430createInstructionsInline	"Create instructions in-line using Class methods"	| ontology role action |		"Set up"	ontology := HumOntology new.		"Add action to the role's set of actions."	role := 'Cook'.	action := 'Bake a cake per recipe.'.	ontology addRole: role action: (HumStatement from: action).		"Append first instruction to sequence of instructions."	ontology appendRole: role 	              action: action 	      instruction:  ( HumInstructionLine  statement: 'Preheat oven to recipe`s oven-temperature.' ).	"Append second instruction."	ontology appendRole: role 	              action: action 	     instruction: ( HumInstructionLine  statement: 'Mix batter per recipe.' ).	self assert: ( ( ontology instructionsForRole: role action: action) size) = 2.	self assert: ( ( ontology instructionsForRole: role action: action) includes:  'Mix batter per recipe.' ).				! !!HumOntologyTests methodsFor: 'about Actions' stamp: 'RichardAlexanderGreen 4/10/2012 11:53'!test440getRoleActionStatement	"An action belongs to a role."		| ontology source actionStatement |		"Set up"	ontology := HumOntology new.			"Add action to the role's set of actions."	source :=  'Make a cake per recipe.'.	ontology addRole: 'Mover' action:  (HumStatement from: 'Make a cake per recipe.').	self assert: ( ontology yesRole: 'Mover' hasAction: source ).		"Get back the action statement. "	actionStatement := ontology getRole: 'Mover' action: source.	self assert: ( actionStatement isKindOf: HumStatement ).		"It should, of course, match."	self assert: ( actionStatement matches:  source ).	! !!HumOntologyTests methodsFor: 'about Actions' stamp: 'RichardAlexanderGreen 9/15/2012 10:57'!test450instructionNounAntecedents	"Create instructions in-line using Class methods"	| ontology role action critique |		"Set up"	ontology := HumOntology new.		"Add action to the role's set of actions."	role := 'Cook'.	action := 'Bake a cake per recipe.'.	ontology addRole: role action: (HumStatement from: action).		"Append first instruction to sequence of instructions."	ontology appendRole: role 	              action: action 	      instruction:  ( HumInstructionLine  statement: 'Preheat oven to recipe`s oven-temperature.' ).	"Append second instruction."	ontology appendRole: role 	              action: action 	     instruction: ( HumInstructionLine  statement: 'Mix batter per recipe.' ).		self assert:  (( ontology instructionsForRole: role action: action ) size) = 2.		ontology addNouns: #( 'recipe' 'oven' 'batter' ).	"In the given instruction sequence, the nouns 'oven' and 'batter' were not seen in the action statement."		critique := ontology critiqueRole: role action: action.	self assert: ( critique size > 0 ).	self assert: ( ( critique at: 1 ) beginsWith: 'Some nouns lack antecedants').	self assert: ( ( critique at: 1 ) endsWith: 'Preheat oven to recipe`s oven-temperature.' ).	self assert: ( ( critique at: 2 ) beginsWith: 'Some nouns lack antecedants').	self assert: ( ( critique at: 2 ) endsWith: 'Mix batter per recipe.' ).						! !!HumOntologyTests methodsFor: 'about Roles' stamp: 'RichardAlexanderGreen 3/22/2012 13:40'!test220addOneRole	"Add one role to current set."	| ontology |	ontology := HumOntology new.	ontology addRole: 'Mover'.	self assert: ( (ontology roles) includes: 'mover' ).! !!HumOntologyTests methodsFor: 'about Roles' stamp: 'RichardAlexanderGreen 3/22/2012 13:40'!test230addTwoRoles	"Add two roles  to current set."	| ontology |	ontology := HumOntology new.	"Add first role."	ontology addRole: 'Mover'.	self assert: ( (ontology roles) includes: 'mover' ).	"Add second role."	ontology addRole: 'Shaker'.	self assert: ( (ontology roles) includes: 'shaker' ).	"Make sure we did not overlay original"	self assert: ( (ontology roles) includes: 'mover' ).  ! !!HumOntologyTests methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 3/30/2012 12:30'!test805translateStatementToCamelcase	| ontology statement s |	ontology := HumOntology new.	statement := HumStatement from: 'Add incoming-count to stock-count, giving updated-stock-count.'.	ontology addNouns: #( 'incoming-count' 'stock-count' 'updated-stock-count' ).	s := statement asCamelCaseWithOntology: ontology.	self assert: ( s = 'addIncomingCountToStockCountGivingUpdatedStockCount' ).! !!HumOntologyTests methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test810translateFrame4ActionToJava	"Given: a Hum action frame.	When: translated to Java	Then: the resulting code is usable.	"	| frameEditor ontology code |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameEditor ontology: ontology  	                                               role: 'Cook' action: 'Bake the pan in the oven for the time given in the recipe.'.	frameEditor addInstructionStatement: 'Open the oven door.'.	frameEditor addInstructionStatement: 'Place the pan in the oven.'.	frameEditor addInstructionStatement: 'Close the oven door.'.	frameEditor addInstructionRole: 'Oven' 	                                    statement: 'Heat for the time given in the recipe.' 	                                       comment: 'We have a smart oven.'.		ontology storeFrame: ( frameEditor frame ).	ontology addNouns: #( 'pan' 'oven' 'recipe' 'time' 'door' ).	code := ontology asJava.		Transcript cr; show: 'test810translateFrame4ActionToJava Generated Java'; cr; show: code; cr.	"TODO: The generated code will not compile because 'aDoor' is not defined."				"Test: Title line is rendered."	self assert: ( '*bakeThePanInTheOvenForTheTimeGivenInTheRecipe( Pan aPan, Oven aOven, Time aTime, Recipe aRecipe ) {*' matches: code ).		"First instruction is rendered."	self assert: ( '*this.openTheOvenDoor( aOven, aDoor );*' matches: code ).		"2nd instruction is rendered."	self assert: ( '*this.placeThePanInTheOven( aPan, aOven );*' matches: code ).	"3rd instruction is rendered."	self assert: ( '*this.closeTheOvenDoor( aOven, aDoor );*' matches: code ).	"4th (delegated) inststruction is rendered"	self assert: ( '*aOven.heatForTheTimeGivenInTheRecipe( aTime, aRecipe ); *' matches: code ).	"Comment is rendered"	self assert: ( '*smart oven*' matches: code ).	"Code ends with a bracket"	self assert: ( code endsWith: ( '} // Actor: Cook', String cr ) ).	"Code should not contain doubled semi-colon.  (Test for bug)"	self assert: ( '*;   ;*' matches: code ) not.			! !!HumOntologyTests methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 4/10/2012 12:46'!test820translateDictionaryToJava	"Add an is-A relation."	| ontology code |	ontology := HumOntology new.	"Define a few relations."	ontology addEntity: 'party' attributes: #(  'party-name' 'alphabetized-name' 'address'  ).	ontology addEntity: 'address' attributes: #( 'street-direction' 'street-number' 'street-name' 'postal-code' ).	ontology addEntity: 'postal-code' attributes: #( 'city' 'state-province' 'nation' ).	ontology addNoun: 'person' isA: 'party'.	ontology addEntity: 'person' attributes: #( 'primary-phone-number'   ).	ontology addNoun: 'contact' isA: 'person'.	ontology addNoun: 'organization' isA: 'party'.		code := ontology asJava.	Transcript cr; show: 'test820translateDictionaryToJava'; cr; show: code; cr; show: '%%%%%%%%%%'; cr.			"Expect each entity to become a class declaration."	self assert: ( '*class Party*' matches: code ).	self assert: ( '*class Address*' matches: code ).	self assert: ( '*class PostalCode*' matches: code ).	self assert: ( '*class Person*' matches: code ).		"Entities extend their Hum supertype."	self assert: ( '*Person extends Party*' matches: code ).	self assert: ( '*PostalCode extends Entity*' matches: code ).	self assert: ( '*Address extends Entity*' matches: code ).		"Attributes with no supertype are Strings by default"	self assert: ( '*public String streetDirection*' matches: code).	self assert: ( '*public String streetNumber*' matches: code).	self assert: ( '*public String stateProvince*' matches: code).	self assert: ( '*public String nation*' matches: code).	self assert: ( '*public String city*' matches: code).	self assert: ( '*public String primaryPhoneNumber*' matches: code).		"Attributes with supertypes declare accordingly"	self assert: ( '*public PostalCode postalCode*' matches: code).	self assert: ( '*public Address address*' matches: code).		"Classes have closing brace."	self assert: ( '*} // Entity: Party*' matches: code).		"WARNING: Contact and Organization are not detected as entities 	    because they have no attributes of their own.	This is an artifact of how the current Ontology implements the dictionary.	"	"This is not exactly correct, but one might ask what was intended. 	Such classes are essentially synonyms. They may also indicate unfinished work."	self assert: ( '*class Contact*' matches: code ) not. 	self assert: ( '*class Organization*' matches: code ) not.	self assert: ( '*Contact extends Person*' matches: code ) not.	self assert: ( '*Organization extends Party*' matches: code ) not.									! !!HumOntologyTests methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test830translateFrame4ActionToJavaExdentToBlockEnd	"Given: a Hum action frame.	When: translated to Java	Then: the resulting code is usable.	Then: the resulting code reflects the block structure as indicated by indentation.	"	| frameEditor ontology code tab |		true ifFalse: [ Transcript cr; show: 'test830translateFrame4ActionToJavaExdentToBlockEnd is turned off'; cr. ].	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameEditor ontology: ontology  	                                               role: 'Cook' action: 'Fulfill order.'.	"Enter an iteration statement."	frameEditor addInstructionStatement: '. For each order-item in the order: '.	"Enter some inside the loop. (It should be indented when rendered.)"	"THINK: Should we require indentation here."	frameEditor addInstructionStatement: '. . Pull order-item quantity from stock and place on cart.'.	"Next statement has no indent. That signals end of the iteration block."	frameEditor addInstructionStatement: '. Ship the order to the order-address.'.			ontology storeFrame: ( frameEditor frame ).	ontology addEntity: 'order' attributes: #(  'order-items' 'order-address' customer ).	ontology addEntity: 'order-item' attributes: #( 'catalog-id' 'product-label' 'quantity' 'unit-price'  ).	ontology addNoun: 'quantity' isA: 'measure'.	ontology addEntity: 'address' attributes: #( 'street-line1' 'street-line2' postal-code ).	ontology addEntity: 'postal-code' attributes: #( code-string city ).	ontology addEntity: 'city' attributes: #( city-name province state nation ).	ontology addNouns: #( 'order' 'order-item' 'order-address'  ).		code := ontology asJava.		Transcript cr; 		show: 'test830translateFrame4ActionToJavaExdentToBlockEnd'; 		cr; show:' Generated Java:'; 		cr; show: code; cr.		"Test: Title line is rendered."	self assert: ( '*for (*:*)*' matches: code ).	self assert: ( '*fulfillOrder( Order aOrder ) {*' matches: code ).	self assert: ( '*orderItem*' matches: code).	self assert: ( '*for ( OrderItem orderItem : order.orderItems )*' matches: code ).	self assert: ( '*OrderItem orderItem*' matches: code ).	                          		"Look for opening and closing '} // for' on the block."	self assert: ('*{*' matches: code ).	tab := String tab.	self assert: ('*',tab,'}*' matches: code ).							! !!HumOntologyTests methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 9/15/2012 11:09'!test830translateRoleToJavaClass	"Given: a Hum action frame.	When: translated to Java	Then: the resulting code is usable.	"	| frameEditor ontology code |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameEditor ontology: ontology  	                                               role: 'Cook' action: 'Bake the pan in the oven for the time given in the recipe.'.	frameEditor addInstructionStatement: 'Open the oven door.'.	frameEditor addInstructionStatement: 'Place the pan in the oven.'.	frameEditor addInstructionStatement: 'Close the oven door.'.	frameEditor addInstructionRole: 'Oven' 	                                    statement: 'Heat for the time given in the recipe.' 	                                       comment: 'We have a smart oven.'.		ontology storeFrame: ( frameEditor frame ).	ontology addNouns: #( 'pan' 'oven' 'recipe' 'time' 'door' ).	code := ontology asJava.		Transcript cr; show: 'test830translateRoleToJavaClass Generated Java'; cr; show: code; cr.	"TODO: The generated code will not compile because 'aDoor' is not defined."				"Test: Title line is rendered."	self assert: ( '*bakeThePanInTheOvenForTheTimeGivenInTheRecipe( Pan aPan, Oven aOven, Time aTime, Recipe aRecipe ) {*' matches: code ).		"First instruction is rendered."	self assert: ( '*this.openTheOvenDoor( aOven, aDoor );*' matches: code ).		"2nd instruction is rendered."	self assert: ( '*this.placeThePanInTheOven( aPan, aOven );*' matches: code ).	"3rd instruction is rendered."	self assert: ( '*this.closeTheOvenDoor( aOven, aDoor );*' matches: code ).	"4th (delegated) inststruction is rendered"	self assert: ( '*aOven.heatForTheTimeGivenInTheRecipe( aTime, aRecipe ); *' matches: code ).	"Comment is rendered"	self assert: ( '*smart oven*' matches: code ).	"Code ends with a bracket"	self assert: ( code endsWith: ('} // Actor: Cook', String cr ) ).	"Code should not contain doubled semi-colon.  (Test for bug)"	self assert: ( '*;   ;*' matches: code ) not.			! !Object subclass: #Hum000TestPlanOverview	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!Hum000TestPlanOverview commentStamp: 'RichardAlexanderGreen 1/2/2012 12:48' prior: 0!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%BIG TEST PLAN%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890         1         2         3         4         5         6         7         8         9        10 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%USER INTERFACE TEST PLANAssemble user interface from components   =======================================A. Scribe interprets keyboard, mouse, and menu gestures.   1. Keyboard has control or command or option pressed.      a) Conventional commands            (copy, cut, paste, un-do, save, open, print, close window, quit application).      b) Commands defined by the user, menu, or application default preferences.   2. Mouse actions      a) Mouse over. (May cause display.)      b) Mouse button pressed.       c) Mouse moved.      d) Mouse button released. (Buttons invoke commands.)   3. User selects action from menu.      a) Create menu | submenu | toolbar.      b) Respond to user navigation.      c) Send (user-selected) command.B. Painter creates 2-D objects in the user’s viewport.   1. Create billboard in anchored location   2. Create floating billboard in front of camera. (or near mouse cursor).   3. Create window (viewport).   4. Move billboard’s text-cursor (left, right, up, down, jump to).   5. Move billboard to a new anchored location.   6. Draw text on billboard at cursor.           (Side-effect: Cursor moves to end of text).   7. Draw lines and shapes on billboard.           (A diagram may direct the painter.) C. Sculptor creates 3-D objects in the user’s viewport.   1. Create 3-D shapes via      a) rotations.       b) extrusion.      c) cut.      d) fill with material.      e) cover with texture.   2. Common tasks (scripts / macros / routines)      a) Create deck, wall, door, window.      b) Create light.      c) Create room.      d) Place billboard on wall.   3. Create, move, animate avatar.      a) Create avatar.      b) Move avatar.      c) Animate avatar.D. Viewport actions affect a window (viewport).   1. Slide, pan, and zoom viewport.      a) Slice actions are like document-centric scrolling.      b) Pan actions are like rotating a camera up-down, left-right.      c) Zoom actions are like a zoom lens widening or narrowing the field of view             (as if the camera moved, but the camera does not move).   2. Move viewport to a new place in virtual world.      a) Rotate camera (same as pan actions).      b) Step forward | backward.      c) Side-step left | right.      d) Step-Turn left | right.      e) Step up (rise) | down (descend).      f) Move viewport to floor location under cursor.      g) Move viewport to face wall under cursor.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%II. Programmer Assistant (PA) User-Dialogs%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%A. Ontology Actions   1. New ontology.   2. Save ontology on file. (Save As on new file)   3. Load ontology from file   4. Merge ontology from (TBD: file or another PA).   5. Test run ontology.   6. Deploy ontology?  (??? What does ‘deploy’ portend ???)B. Frame Editor Actions   1. Usual text edit actions:      a) commands: (copy, cut, paste, un-do, save, open, print, close window)      b) cursor moves: (up, down, left, right, top, bottom, . . .)   2. PA-specific actions:      a) [Line updated] event causes the logical-line and frame to be checked.         (1) The logical-line is rendered.              Keywords and nouns are emphasized. Nouns have links.          (2) If the logical-line is not understood (no definition in ontology or DSL),              the line is flagged (with a question-mark).         (3) If a noun lacks an antecedent in the frame, the noun is flagged (color code).      b) [Insert/Append Instruction] - Instructions are indented.         (1) In an action frame,                the automatic indent matches the preceding statement’s indent                unless it was a control statement (ending with a colon).                   And then, the indentation is increased by one.         (2) In plan and dialog frames,                instructions have only one level of indent                because control statements are not allowed in those contexts.         (3) In dialog frames,                the user indicates an instruction by starting the line with dot [tab].      c) [Submit frame] command causes the ontology to be          (1) updated.         (2) versioned.         (3) re-evaluated. (problems flagged)         (4) re-displayed. (all views rebuilt)      d) [Test Dialog] - in dialog run-time with mock agents. %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%III. Run-Time Test Cases%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%A. Messenger   1. The actors (agents) communicate via the Messenger.   2. Messenger is addressed via a URI.   3. Messenger records each message in a log file.   4. In test mode,          the messenger can replay the messages          that were sent to an actor during some period of time.          (This capability enables simulations.)   5. In test mode,          messages can only be communicated          between actors that are also in test mode.B. Resource Manager (RM) - assigns tasks to actors.   1. Actor checks-in (announces availability to perform specific roles).   2. Assign task (action-statement) to actor.      a) Job-ticket contains action-statement, noun-values,             request context (requesting actor, and instruction-pointer).      b) The RM assigns an available actor.      c) The RM sends the job-ticket to the assigned actor.              (via Messenger)   3. Actor has completed task.      a) The resources consumed (actor’s time, etc) are recorded on the job ticket.      b) Any computed results are added to the job-ticket.             (Convention: Actions with results have a ‘giving’ clause.)      c) RM sends resource consumption data to Bookkeeper.      d) Task complete notice (with job-ticket) is sent to requester.             (The requester resumes execution of the plan.)C. Bookkeeper - tracks resource consumption   1. Job-ticket resource consumption is recorded.   2. Resource dimensions include job, resource,          provider (actor, role), consumer (actor, role), and date-time.   3. Actors may decrement, increment inventories.   4. Actors may set inventory level (initialization, audit). D. Supervisor - controls execution of plans and dialogs.   1. Delegate task.          (The current actor has delegated a task to another role.)      a) Send delegated task to Resource Manager. (RM)          (The RM will assign the task to an available actor.)    2. Resume suspended action.          (When a task is delegated to another role,             the current task execution is suspended.)!!Hum000TestPlanOverview methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/13/2012 15:23'!aReadMe	"See the class description for the intended (future) tests."	^'See the class description for the intended (future) tests.'	! !!Hum000TestPlanOverview methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/17/2012 10:58'!givenWhenThenInHTML	"HTML GivenWhenThen frames."^'<html><head>	<title>Hum PA Given-When-Then</title>	<style type="text/css">		pre.Reqt {font-size: Larger}		pre.Design {font-size: Smaller}	</style></head><body>	<h1>	<center>		Web 		<br/>Programmers Assistant		<br/>Given When Then	</center></h1><h2>	<center>		The Programmers Assistant 		<br/>User Interface behavior 		<br/>is defined 		<br/>via Given-When-Then story cards.	</center></h2><table border=1 cellpadding=6><tr> <th>GIVEN WHEN THEN</th> <th>ARCHITECTURE CONSEQUENCE</th> </tr></pre><!!-- =============== --></td></tr><tr><td><pre class="Reqt"><b>Given:</b> User is editing a frame.<b>When:</b> Text cursor moves off current line        (key return, up, down, mouse click).<b>Then:</b> Current line is pretty-printed.<b>Then:</b> (also)  Current frame is critiqued.<td><pre class="Design">Either use (CodeMirrror.js)   or stick with making one line at a time   using &lt;input&gt; text or test-area.Comment: CodeMirror is probably the ideal solution. However, it may require a lot of work to get CodeMirror   to signal the Web-PA properly   and for the WebPA to interact with the code mirror.</pre></td></pre><!!-- =============== --></td></tr><tr><td><pre class="Reqt"><b>Given:</b> User has navigated to a frame opening dialog.<b>When:</b> User is entering the frame title statement.<b>Then:</b>  Auto-completion is offered for title statements.<b>When:</b> User has completed entering the frame title statement.<b>Then:</b>  The code text is appropriately initialized      (and made visible), depending on the type of frame.    -- Empty frame may be a template.    -- Code frame is pretty-printed.    -- The first line is given focus (and/or highlighted).<td><pre class="Design">Use JQuery auto-completion facility.Looks easy enough.Open a new tab-pane with the code text.</pre></td></pre><!!-- =============== --></td></tr><tr><td><pre class="Reqt"><b>Given:</b> User is entering an instruction.<b>When:</b> User enters a delegated instruction.<b>Then:</b>  Auto-Completion is offered for the given role name`s public actions.(A role`s public actions are those preceded with the label "Action:")<td><pre class="Design">Use JQuery auto-completion.PA (model of PA) should implement the query as a method.</pre></td></pre><!!-- =============== --></td></tr><tr><td><pre class="Reqt"><b>Given:</b> User is inserting a delegated instruction into some frame.<b>When:</b> The statement is a not one of that role`s current public actions.<b>Then:</b>  Action (empty frame) is added     -- after user confirms intent to add a new action.<b>When:</b> The statement currently references a private (To:) procedure.<b>Then:</b> The procedure is converted to a public"Action:" procedure    -- after user confirms intent to convert.<td><pre class="Design">Use Seaside dialog to confirm user intent.PA modifies underlying code.If a converted "To:" statement is currently displayed or diagrammed,some means is needed to signal that it has changed from "To:" to "Action:".(Brute force, we could simply tell every display to update from the model.)</pre></td></pre><!!-- =============== --></td></tr><tr><td><pre class="Reqt"><b>Given:</b> User is editing a frame`s code.<b>When:</b> User moves text cursor to a new line . . .<b>Then:</b> New line is highlighted.<b>Then:</b> (also)  Old line is not.<td><pre class="Design">This assumes we are <u>not</u> using CodeMirror.js.It is a work-around.</pre></td></pre><!!-- =============== --></td></tr><tr><td><pre class="Reqt"><b>Given:</b> User is editing a frame`s code.<b>When:</b> User presses something other than a line-selector key [up/down] . . .<b>Then:</b> The line under the text cursor is put into edit mode.<b>When:</b> User presses enter or return.<b>Then:</b>  An empty line is inserted with appropriate indentation.<td><pre class="Design">This assumes we are <u>not</u> using CodeMirror.js.Otherwise CodeMirror`s normal behavior should be adequate.</pre></td></pre><!!-- =============== --></td></tr><tr><td><pre class="Reqt"><b>Given:</b> User is editing a plan frame.<b>When:</b> User enters a precondition statement.<b>Then:</b> Auto-completion is offered  (sourced from known conditions.)<td><pre class="Design">Use JQuery auto-completion. PA will provide a suitable collection (of strings) via a method.</pre></td></pre><!!-- =============== --></td></tr><tr><td><pre class="Reqt"><b>Given:</b> User is editing a plan frame.<b>When:</b>  User enters new precondition       (one that does not match a known condition)<b>Then:</b> Condition is added to conditions collection    unless the annotation says "[assumed]."<b>When:</b> Condition is added . . .<b>Then:</b> an empty frame is inserted into frames.    -- (This empty frame simplifies some things.)<td><pre class="Design">Q: What happens when/if the user deletes the only reference later?A: Will think about it.  (TBD)The UI simply tells PA>>addLine: aPlanFrameLine.The PA then performs the rest.</pre></td></pre><!!-- =============== --></td></tr><tr><td><pre class="Reqt"><b>Given:</b> Statement is in a displayed view.<b>When:</b> Statement has no known nouns.    -- because it is entered before nouns are defined.    -- because (last) noun became undefined.<b>Then:</b> Statement is highlighted with an"error" color.    -- background / foreground is TBD<b>Then:</b> Critique says ". . . no known nouns"<td><pre class="Design">Since the set of diagrams displays all of the statements,  at least implicitly,   it appears that PA needs to scan all statements in the ontology   and update the known nouns attribute.The WebPA may then update each display   that is affected by statement qualities.This looks like a job for "Announcements" (Pharo publish/subscribe).</pre></td></pre><!!-- =============== --></td></tr><table>'.! !!Hum000TestPlanOverview methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/17/2012 12:30'!progress	^ ' 	01-Jan-2012:  33 test  65 implementation methods completed.	02-Jan-2012:  37 test  76 implementation methods completed.	03-Jan-2012:  38 test  91 implementation methods completed. -- 1079+788+188 = 2055 Lines in ST (file-out) files.	04-Jan-2012:  39 test 111 implementation methods completed -- 1088+825+152 = 2065 Lines ( after refactoring ).	---- Start counting assert: as indicator of number of tests instead. ---	06-Jan-2012:   90 asserts 155 implementation methods completed -- 1189+1034+158  = 2381 Lines 	09-Jan-2012: 101 asserts 146 implementation methods completed -- 1224+1114+162 =  2500 Lines (at 3:20 pm)	12-Jan-2012: 164 asserts 169 implementation methods completed -- 1617+1364+169+54 = 3204 Lines (at 3:30 pm)	15-Jan-2012: 211 asserts 186 implementation methods completed -- 1850+1518+208+54 = 3630 Lines (at 9:15 pm)	18-Jan-2012: 247 asserts 208 implementation methods completed -- 2113+1709+230+54 = 4106 Lines (at 1:50 pm)	--- Started work on UI ----	20-Jan-2012: 305 asserts 259 implementation methods completed -- 2314+1722+230+54+430 = 4750 Lines (at 5:05 pm) 	06-Feb-2012: 363 asserts 345 implementation methods completed -- 2742+1919+253+596+547 = 6057 Lines ==> ~ 5274 LoC	28-Mar-2012: 534 asserts 402 implementation methods completed -- 254+2388+804+3892+804 = 8142 Lines ==> ~ 6500 LoC	10-Apr-2012: 615 asserts 419 implementation methods completed -- 254+2700+804+4406+870 = 9034 Lines ==> ~ 7200 LoC 	29-May-2012: Basically got lost trying to find ways to do 3D modeling and also surveying free design tools.	24-July-2012: Got distracted learning Python and using Visual Python (VPython) and using it to model trailer and to visualize Game Of Life in 3D.	28-September-2012: Got around to learning Seaside and starting to implement the IDE.					I have a site initiated at Seaside hosting.					Took a look at Magritte -- Decided to not use it in the browser. (too many layers and dependencies, not enough comments in the code).					I also toyed with Pier (a content management system based on Seaside and Magritte) -- I has still another wiki-mark-up.					Pier might be worth adopting later as a wiki and book generator. 					I am not convinced yet, but (notably) some of the Pharo/Seaside/Pier books seem to be produced via Pier.	28-September-2012: Made sure that all of my classes have comments. (Pet peeve about others code -- must comply myself.)	28-September-2012: 795 asserts 533 implementation methods completed -- 268+3048+1059+773+6138+1306 = 12592 ==> ~ 10,000 LoC.	17-October-2012:      658 asserts -- I removed a large number of redundant tests that had been cut and pasted into HumSeasideTests.	17-October-2012:      658 asserts, 553 implementation methods completed-- 269+3047+1090+1150+5311+1306 = 12173 ==> still roughly 10,000 LoC.	'! !