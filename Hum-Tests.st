TestCase subclass: #HumTestCase	instanceVariableNames: 'ensureBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumTestCase commentStamp: 'RichardAlexanderGreen 3/26/2015 13:01' prior: 0!HumTestCase provides some syntax "sugar" on TestCase.!!HumTestCase methodsFor: 'testing' stamp: 'RichardAlexanderGreen 3/26/2015 13:15'!assert: stringA sameAs: stringB 	self assert: (stringA sameAs: stringB)	     description: ( 'Expecting: ', stringA ,' sameAs: ', stringB ).! !!HumTestCase methodsFor: 'testing' stamp: 'RichardAlexanderGreen 3/26/2015 13:01'!expect: expectedValue actual: actualValue description: aDescription 	self assert: (expectedValue = actualValue)	     description: ( 'Expected: ', expectedValue asString,' actual: ', actualValue asString, ' - ', aDescription ).	! !!HumTestCase methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/15/2015 13:20'!signal	self ensure.	super signal.! !!HumTestCase methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/15/2015 13:21'!ensure	ensureBlock ifNotNil: [ ensureBlock value ].! !!HumTestCase methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/15/2015 13:21'!ensureBlock: aBlock	ensureBlock := aBlock.! !!HumTestCase methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/18/2015 20:52'!pattern: stringPattern matches: string 	self assert: ( string matches: stringPattern) 		description: ( 'Result should match pattern: {',stringPattern,'}').		! !!HumTestCase methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 3/26/2015 13:01'!expect: expectedValue actual: actualValue 	self assert: (expectedValue = actualValue)	     description: ( 'Expected: ', expectedValue asString,' actual: ', actualValue asString ).! !HumTestCase subclass: #HumOntologyTranslatorTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumOntologyTranslatorTests methodsFor: 'utility' stamp: 'RichardAlexanderGreen 10/25/2013 12:38'!assertExpectedTokensIn: expected matchesTokensIn: actual	"Compare the two strings as a stream of tokens.	If they are the same, 	. return self.	If they are not the same, 	. signal failure and show where match fails.	This is patterned after TestCase>>assert:equals:	"	| whitespace specials delimiters expectedTokens actualTokens |	self assert: ( expected isKindOf: String ).	self assert: ( actual isKindOf: String ).	whitespace := String space, String tab, String crlf.	specials := '~!!@#$%^&*()_+`-={}|[]\:";''<>?,./'.	delimiters := whitespace, specials.	expectedTokens := ( expected withBlanksCondensed ) findTokens: delimiters keep: specials.	actualTokens   := (   actual withBlanksCondensed ) findTokens: delimiters keep: specials.		( 1 to: expectedTokens size )		do: [ :i |			| expectedToken actualToken |			expectedToken := expectedTokens at: i.			actualToken := actualTokens at: i.			self assert: ( expectedToken = actualToken ) description: 'expected: "',expectedToken,'" at: ',i asString,' actual: "', actualToken,'"'.			"Note failing this assert will halt the loop."			].	^ self		assert: ( expectedTokens = actualTokens )		description: 'tokens do not match '.! !!HumOntologyTranslatorTests methodsFor: 'utility' stamp: 'RichardAlexanderGreen 10/25/2013 12:56'!test010AssertExpectedTokensInAMatchesTokensInB	"Test the utility with the cases that matter to me."	| failcase |		"Two cases that differ only in white space will match"	self assertExpectedTokensIn: '  (  { } )' matchesTokensIn: '({})'.	"Two cases that differ in substance will fail"	failcase := [self assertExpectedTokensIn: '( { } )' matchesTokensIn: '( { somethingdifferent } )'].	self should: failcase raise: TestFailure.! !!HumOntologyTranslatorTests methodsFor: 'Generic Translation Strategy' stamp: 'RichardAlexanderGreen 10/8/2013 08:38'!test110AttachMethodToClass	"Attach a method to a class."	| translator aMethodName aClassName aSource |	translator := HumOntologyTranslator new.	"Example in Java syntax with Hum accounting"	aSource := '			/** Move portable-object to location. */		public Expense movePortableObjectToLocation( PortableObject portableObject, Location location ) {			// TBD - The body of the method goes here.			Timer timer = new Timer.start();			timer.tick( self.randomDuration() );  // Fuzzy number for simulation.			return new Expense( self.class(), self.id(), timer.stop() );		}						'.	aMethodName := 'Move portable-object to location.'.	aClassName := 'MaterialTransporter'.	translator attachAction: aMethodName toActorClass: aClassName fromSource: aSource.		"TODO: Need some asserts."	self assert: ( translator methodsForClasses isEmpty) not.! !!HumOntologyTranslatorTests methodsFor: 'Generic Translation Strategy' stamp: 'RichardAlexanderGreen 3/15/2013 17:04'!test111GetMethodsForClass	"Attach a method and get it back."	| translator aMethodName aClassName aSource methods source |	translator := HumOntologyTranslator new.	"Example in Java syntax with Hum accounting"	aSource := '			/** Move portable-object to location. */		public Expense movePortableObjectToLocation( Entity portableObject, Entity location ) {			// TBD - The body of the method goes here.			Timer timer = new Timer.start();			timer.tick( self.averageDuration() );  // Use average duration for fairness.			return new Expense( self.class(), self.id(), timer.stop() );		}						'.	aMethodName := 'Move portable-object to location.'.	aClassName  := 'MaterialTransporter'.	translator attachAction: aMethodName toActorClass: aClassName fromSource: aSource.		"Now get it back."	methods := translator getMethodsForClass: aClassName.	self assert: ( methods size = 1 ).	source := methods at: aMethodName.	self assert: aSource equals: source.	! !!HumOntologyTranslatorTests methodsFor: 'Generic Translation Strategy' stamp: 'RichardAlexanderGreen 6/5/2014 09:43'!test120AttachClassPrologue	"Attach prologue source lines to an actor class.	Language-specific translators will generate prologue code.	The prologue will contain boiler-plate and infrastructure.	"	| translator  aClassName aSource |	translator := HumOntologyTranslator new.	aClassName := 'MaterialTransporter'.		"Example in Java syntax with Hum accounting.	Eventually, the Ontology Translator will generate the prologue."	aSource := '// Hum Actor: ', aClassName,'.// Actor supertype implements BlackBoard and Messenger interfaces.include hum.actor.Actor;  // On receipt of a message, the supertype copies data into local blackBoard and jobTicket variables.include hum.actor.BlackBoard;include hum.actor.JobTicket;// Many nouns are of these datatypes: include hum.datatypes.Measure;include hum.datatypes.TimeStamp;		public class ',aClassName,' extends Actor {	private BlackBoard blackBoard;	private JobTicket jobTicket;'.	translator attachPrologToActorClass: aClassName fromSource: aSource.		self assert: ( translator prologues isEmpty ) not.	"An Actor`s implementation in Java or Erlang must reside in a file of the same name.	We can adopt the same convention for JavaScript and Smalltalk implementations.	"	! !!HumOntologyTranslatorTests methodsFor: 'translate to Erlang' stamp: 'RichardAlexanderGreen 4/20/2015 08:22'!testE230translateInstructionToErlang	"Translate Hum instruction (invoke) to Erlang do()."	| translator ontology humSource actionStatement erlangSource expectedMessage expectedSource |	actionStatement := 'Move portable-object from this-location to that-location.'.	humSource := '. ', actionStatement.	"Our strategy involves a generic calling pattern that sends the message."	"Given: ontology knows which words are nouns."	"TODO: In the actual instruction the nouns may be replaced by subtypes.	 TODO: Some process is needed to match the instruction instance to the appropriate action header.	 TODO: Could that process be outside the pure 'translate to Erlang' ?	 TODO: This is also where polymorphism comes into the picture.	"	translator := HumOntologyTranslator new.	ontology := HumOntology new.	ontology addNouns: #('portable-object' 'this-location' 'that-location').	"When: Action call is translated to Erlang call"	erlangSource := translator translateSelfCallToErlang: humSource.	"Then: The message passed to self looks like { roleAtom, ActionStatement, NounValues }."	expectedMessage := '{self,"', actionStatement, '",NounValues}'.	"Note: The role is translated to an Erlang atom."	self assert: (( '*', expectedMessage, '*' ) match: erlangSource ).	"Then: The call looks like 'do( { Role, Action, NounValues} ).'"	"Note: The actor simply calls itself via do(...). 	 Note: We do not distinguish public interface from internal."	expectedSource := 'do(', expectedMessage,')'.	self assert: (( '*', expectedSource, '*' ) match: erlangSource ).	! !!HumOntologyTranslatorTests methodsFor: 'translate to Erlang' stamp: 'RichardAlexanderGreen 9/14/2014 14:16'!testE310translatePlanFramesToErlang	"TODO: Decide how to do this.	Alternative-A:	1. The plan is data. 	   It can be represented as a dictionary/table in ETS.	2. The plan`s run-time state includes 	   conditions that have been asserted,	   actions currently in-progress,	   current job-ticket charges,	   and the plan`s blackboard.	3. The Coordinator has actions/methods:	   - Assert condition. (Update state and trigger actions.)	   - What is current state? (Return run-time state. See #2 above.)	   - Cancel goal. (Send cancels to Dispatcher.)	---	Alternative-B:	1. Each plan-frame is a finite-state-machine (FSM).	   The state includes a list of unsatisfied preconditions	   which is set via init()	   A private performActions method sends {action, Role, Statement, Nouns } to Dispatcher.	   The performActions method code (containing those sends) is generated. 	2. When a condition is satisfed, an event is broadcast to the set of FSM. 	   Each frame FSM removes matched preconditions from the list of unsatisfied preconditions.	   If there are no more unsatisfied preconditions, the FSM calls its own private performActions method.	Alternative-C:	- Same as B, but there is a single frame module that is data-driven with no frame-specific code.	  It is given the list of preconditions and list of action messages via the initialization process	  by a higher level process translated from the whole plan.	Discussion:	- I like C best because 	(1) It places the entire plan in a single, reasonably readable place.	(2) Debug should be easier.	(3) There is less code (at most one module) to generate.	    In fact, the plan-level module can be data-driven. 	    We only need to generate a data packet in Erlang format.	"	"*** TODO: Write the HumCoordinator agent in Erlang. *** (Confirm that Alternative-C is workable.)"	"*** See: HumCoordinator>>runPlanFrameForCondition: aGoalString ***"	! !!HumOntologyTranslatorTests methodsFor: 'translate to Erlang' stamp: 'RichardAlexanderGreen 4/20/2015 08:22'!testE210translateActionHeaderToErlang	"Translate Hum action header to Erlang do pattern.	An actor (role) is implemented as an Erlang process. (?)	When the Dispatcher assigns a task,	  it will send a message of the form { role, ActionStatement, NounValues }	  to the assigned actor (process).	The actor will implement a mailbox dispatcher 	  that invokes 'do( {ActionStatement, NounValues} )'	and a do() method that matches the specific action statement.	"	| translator ontology humSource actionStatement erlangSource expectedSource |	actionStatement := 'Move portable-object from this-location to that-location.'.	humSource := 'Action: ', actionStatement.	"Our strategy involves a generic do( ... ) pattern that receives the message."	"Given: ontology knows which words are nouns"	translator := HumOntologyTranslator new.	ontology := HumOntology new.	ontology addNouns: #('portable-object' 'this-location' 'that-location').	"When: Action header is translated to Erlang do header"	erlangSource := translator translateActionHeaderToErlang: humSource.	"Then: The do header looks like 'do( { action-statement, noun-values } )' "	expectedSource := 'do( { "',actionStatement,'", NounValues } ) ->'.	self assert: (( '*', expectedSource, '*' ) match: erlangSource ).		"TODO: The Erlang boiler plate must assure that the do() will be invoked 	 for the message { ActionStatement, NounValues}"	! !!HumOntologyTranslatorTests methodsFor: 'translate to Erlang' stamp: 'RichardAlexanderGreen 4/20/2015 08:22'!testE311tranlatePreconditionsToErlangList	"Translate a plan-frame`s preconditions to an Erlang list.	A Hum coordinator instance (an Erlang FSM?) will match notifications of conditions asserted	against its list of preconditions	and when all of the precondiditions have been asserted will run the action statement.	When the action completes, the coordinator asserts its goal and terminates itself.	"	| erlangList expected preconditionA preconditionB planFrame  ontology |		ontology := HumOntology new.	"A plan frame should have a goal and at least two preconditions."		planFrame := HumFrame4Plan  ontology: ontology goal: 'Bake a cake per recipe'.	preconditionA := 'Oven is preheated per recipe.'.	planFrame appendPrecondition: preconditionA.	preconditionB := 'Batter is in bake-pan per recipe.'.	planFrame appendPrecondition: preconditionB.	planFrame appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.		ontology storeFrame: planFrame.	expected := '[',preconditionA quoted,',',preconditionB quoted,']'. 	erlangList := expected. "STUB"	"TODO: This translation has not been fully implemented yet."	self assert: ( ('*',preconditionA,'*') match: erlangList ).	self assert: ( ('*',preconditionB,'*') match: erlangList ).	! !!HumOntologyTranslatorTests methodsFor: 'translate to Erlang' stamp: 'RichardAlexanderGreen 4/20/2015 08:22'!testE220translateActionCallToErlang	"Translate a Hum action call to an Erlang call."	| translator ontology humSource actionStatement erlangSource expectedMessage expectedSource |	actionStatement := 'Move portable-object from this-location to that-location.'.	humSource := 'Mover: ', actionStatement.	"Our strategy involves a generic calling pattern that sends the message."	"Given: The ontology knows which words are nouns"	translator := HumOntologyTranslator new.	ontology := HumOntology new.	ontology addNouns: #('portable-object' 'this-location' 'that-location').	"When: Action call is translated to Erlang call"	erlangSource := translator translateActionCallToErlang: humSource.	"Then: The message passed to the Dispatcher looks like { roleAtom, ActionStatement, NounValues }."	expectedMessage := '{mover,"', actionStatement, '",NounValues}'.	"Note: The role is translated to an Erlang atom."	"self assert: (( '*', expectedMessage, '*' ) match: erlangSource )."	"Then: The call looks like '?CALL({Role,Action,NounValues}).'"	"?CALL is an Erlang macro that will probably become 'gen_supervisor:call( dispatcher, ' 	 -- which invokes an OTP gen_supervisor method"	expectedSource := '?CALL(', expectedMessage,')'.	"Transcript cr; show: 'in test220translateActionCallToErlang';	           cr; show: 'expected: ',expectedSource;	           cr; show: ' getting: ',erlangSource; cr."	self assert: (( '*', expectedSource, '*' ) match: erlangSource ).! !!HumOntologyTranslatorTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 4/20/2015 08:22'!test720translateFrame4ActionToSmalltalk	"Given: a Hum action frame.	When: translated to Smalltalk	Then: the resulting code is usable.	(This test is like the last test (test710) but 'door' is not in the list of nouns, 	and we get a slightly different result.)	"	| frameEditor ontology code |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameUpdater ontology: ontology  	                                               role: 'Cook' action: 'Bake the pan in the oven for the time given in the recipe.'.	frameEditor appendInstructionStatement: 'Open the oven door.'.	frameEditor appendInstructionStatement: 'Place the pan in the oven.'.	frameEditor appendInstructionStatement: 'Close the oven door.'.	frameEditor appendInstructionRole: 'Oven' 	                                    statement: 'Heat for the time given in the recipe.' 	                                       comment: 'We have a smart oven.'.		ontology storeFrame: ( frameEditor frame ).	ontology addNouns: #( 'pan' 'oven' 'recipe' 'time' ).	code := ontology codeGenerator generateSmalltalk.	"Transcript cr; show: 'Generated Smalltalk:'; cr; show: code; cr."		"Test: Title line is rendered."	self assert: ( '*bakePanInOvenForTimeGivenInRecipeQpan: aPan oven: aOven time: aTime recipe: aRecipe*' match: code ).		"First instruction is rendered."	self assert: ( '*openOvenDoorQoven: aOven*' match: code ).		"2nd instruction is rendered."	self assert: ( '*placePanInOvenQpan: aPan oven: aOven*' match: code ).	"3rd instruction is rendered."	self assert: ( '*closeOvenDoorQoven: aOven*' match: code ).	"4th (delegated) inststruction is rendered"	self assert: ( '*aOven heatForTimeGivenInRecipeQtime: aTime recipe: aRecipe*' match: code ).	"Comment is rendered"	self assert: ( '*smart oven*' match: code ).	"Role is rendered."	self assert: ( '*Oven:*' match: code ).			! !!HumOntologyTranslatorTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 4/20/2015 08:55'!test383ifStatementAsSmalltalk	"Translate if . . .   to  Smalltalk"	| ifStatement     ifSmalltalk     ontology |	true ifFalse: [ Transcript cr; show: 'test381ifStatementAsSmalltalk skipped'; cr. ^self.].	ifStatement := HumStatement from: 'If account balance is equal to account last-invoice-total :'.	ontology := HumOntology new.	ontology addNouns: #( 'account' 'balance' 'last-invoice-total').	ifSmalltalk := ontology codeGenerator generateSmalltalkIfFor: ifStatement.	self expect: '(  ( blackboard entity: ''account'' attribute: ''balance'' ) = ( blackboard entity: ''account'' attribute: ''lastInvoiceTotal'' ) )  ifTrue: [' actual: ifSmalltalk.			! !!HumOntologyTranslatorTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 1/23/2015 14:47'!test380ifStatementAsSmalltalk	"Translate if . . .   to  Smalltalk"	| ifStatement     ifSmalltalk     ontology |	true ifFalse: [ Transcript cr; show: 'test380ifStatementAsSmalltalk skipped'; cr. ^self.].	ifStatement := HumStatement from: 'If account balance is greater than account last-invoice-total :'.	ontology := HumOntology new.	ontology addNouns: #( 'account' 'balance' 'last-invoice-total').	ifSmalltalk := ontology codeGenerator generateSmalltalkForStatement: ifStatement.	self expect:  '(  ( blackboard entity: ''account'' attribute: ''balance'' ) > ( blackboard entity: ''account'' attribute: ''lastInvoiceTotal'' ) )  ifTrue: [' actual: ifSmalltalk .			! !!HumOntologyTranslatorTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 4/20/2015 08:22'!test730translateFrame4ActionToSmalltalkExdentToBlockEnd	"Given: a Hum action frame.	When: translated to Smalltalk	Then: the resulting code reflects the block structure as indicated by indentation.	"	| frameEditor ontology code |		true ifFalse: [ Transcript cr; show: 'test730translateFrame4ActionToSmalltalkExdentToBlockEnd is turned off'; cr. ].	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameUpdater ontology: ontology  	                                               role: 'Cook' action: 'Fulfill order.'.	"Enter an iteration statement."	frameEditor appendInstructionStatement: '. For each order-item in the order: '.	"Enter some inside the loop. (It should be indented when rendered.)"	"THINK: Should we require indentation here."	frameEditor appendInstructionStatement: '. . Pull order-item from stock and place on cart.'.	"Next statement has no indent. That signals end of the iteration block."	frameEditor appendInstructionStatement: '. Ship the order to the order-address.'.			ontology storeFrame: ( frameEditor frame ).	ontology addEntity: 'order' attributes: #(  'order-items' 'order-address' customer ).	ontology addEntity: 'order-item' attributes: #( 'catalog-id' 'product-label' 'quantity' 'unit-price'  ).	ontology addNoun: 'quantity' isA: 'measure'.	ontology addEntity: 'address' attributes: #( 'street-line1' 'street-line2' postal-code ).	ontology addEntity: 'postal-code' attributes: #( code-string city ).	ontology addEntity: 'city' attributes: #( city-name province state nation ).	ontology addNouns: #( 'order' 'order-item' 'order-address'  ).		code := ontology codeGenerator generateSmalltalk.	"	Transcript cr; 		show: 'test730translateFrame4ActionToSmalltalkExdentToBlockEnd'; 		cr; show:' Generated Smalltalk:'; 		cr; show: code; cr.	"	"Test: Title line is rendered."	self assert: ( '*fulfillOrderQorder: aOrder*' match: code ).	"For is implemented by do:"	self assert: ( '*do:*' match: code ).	self assert: ( '*:orderItem*' match: code ).	self assert: ( '*aOrderItem := orderItem*' match: code).	self assert: ( '*Item: aOrderItem*' match: code).	self assert: ( '*blackboard entity: ''order'' attribute: ''orderItem''*' match: code ).	"Look for opening and closing ']' on the block."	self assert: ('*[*' match: code ).	"Watch for proper close on the do: []. "	self assert: ('*].*' match: code ).	"Watch for proper position for closing ']'"	self assert: ( code trimBoth endsWith: ']' ) not.	self assert: ( code trimBoth endsWith: '].' ) not.	self assert: ( '*self ( self*' match: code ) not.		"code inspect."					! !!HumOntologyTranslatorTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 4/20/2015 08:54'!test381ifStatementAsSmalltalk	"Translate if . . .   to  Smalltalk"	| ifStatement     ifSmalltalk     ontology |	true ifFalse: [ Transcript cr; show: 'test381ifStatementAsSmalltalk skipped'; cr. ^self.].	ifStatement := HumStatement from: 'If account balance > account last-invoice-total :'.	ontology := HumOntology new.	ontology addNouns: #( 'account' 'balance' 'last-invoice-total').	ifSmalltalk := ontology codeGenerator generateSmalltalkIfFor: ifStatement.	self expect: '(  ( blackboard entity: ''account'' attribute: ''balance'' ) > ( blackboard entity: ''account'' attribute: ''lastInvoiceTotal'' ) )  ifTrue: [' actual: ifSmalltalk .			! !!HumOntologyTranslatorTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 4/20/2015 08:13'!test370forStatementAsSmalltalk	"Translate for . . .    to Smalltalk"	|     forStatement   forSmalltalk ontology |	true ifFalse: [ Transcript cr; show: 'test370forStatementAsSmalltalk skipped'; cr. ^self.].	"---	Dictionary: Order.	An order has a list of order-items.	---	"	ontology := HumOntology new.	"Add entity-attribute relation."	ontology addEntity: 'order' attribute: 'order-items'.	"Translate the Hum 'For . . . '   statement into Smalltalk."	forStatement := HumStatement source: 'For each order-item in the order:'.	"forSmalltalk := forStatement asSmalltalkWithOntology: ontology."  forSmalltalk := ontology codeGenerator generateSmalltalkForStatement: forStatement.	"Expect: 	( blackboard entity: order attribute: 'orderItems' ) do: [ :orderItem |	"	self assert: ( '*do:*' match: forSmalltalk ).	self assert: ( '*self blackboard entity: ''order'' attribute: ''orderItem''*' match: forSmalltalk ).	self assert: ( '*:orderItem |*' match: forSmalltalk ).	self assert: ( '*self ( self*' match: forSmalltalk ) not.	"	Transcript cr; show: 'from test370forStatementAsSmalltalk: '; 			     cr; show: forSmalltalk; cr.	"			! !!HumOntologyTranslatorTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 4/20/2015 08:21'!test385ifStatementAsSmalltalk	"Translate if . . .   to  Smalltalk"	| ifStatement     ifSmalltalk     ontology |	true ifFalse: [ Transcript cr; show: 'test385ifStatementAsSmalltalk skipped'; cr. ^self.].	ifStatement := HumStatement from: 'If account last-invoice-total < account balance :'.	ontology := HumOntology new.	ontology addNouns: #( 'account' 'balance' 'last-invoice-total').	ifSmalltalk := ontology codeGenerator generateSmalltalkIfFor: ifStatement.	self expect:  '(  ( blackboard entity: ''account'' attribute: ''lastInvoiceTotal'' ) < ( blackboard entity: ''account'' attribute: ''balance'' ) )  ifTrue: [' actual: ifSmalltalk.			! !!HumOntologyTranslatorTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 4/20/2015 08:21'!test710translateFrame4ActionToSmalltalk	"Given: a Hum action frame.	When: translated to Smalltalk	Then: the resulting code is usable.	"	| frameEditor ontology code |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameUpdater ontology: ontology  	                                  role: 'Cook' 	                                action: 'Bake the pan in the oven for the time given in the recipe.'.	frameEditor appendInstructionStatement: 'Open the oven door.'.	frameEditor appendInstructionStatement: 'Place the pan in the oven.'.	frameEditor appendInstructionStatement: 'Close the oven door.'.	frameEditor appendInstructionRole: 'Oven' 	                     statement: 'Heat for the time given in the recipe.' 	                       comment: 'We have a smart oven.'.		ontology storeFrame: ( frameEditor frame ).	ontology addNouns: #( 'pan' 'oven' 'recipe' 'time' 'door' ).	code := ontology codeGenerator generateSmalltalk.		"Test: Title line is rendered."	self assert: ( '*bakePanInOvenForTimeGivenInRecipeQpan: aPan oven: aOven time: aTime recipe: aRecipe*' match: code ).		"First instruction is rendered."	self assert: ( '*openOvenDoorQoven: aOven door: aDoor*' match: code ).		"2nd instruction is rendered."	self assert: ( '*placePanInOvenQpan: aPan oven: aOven*' match: code ).	"3rd instruction is rendered."	self assert: ( '*closeOvenDoorQoven: aOven door: aDoor*' match: code ).	"4th (delegated) inststruction is rendered"	self assert: ( '*heatForTimeGivenInRecipeQtime: aTime recipe: aRecipe*' match: code ).	"Comment is rendered"	self assert: ( '*smart oven*' match: code ).	"Role is rendered."	self assert: ( '*Oven:*' match: code ).		"Transcript cr; show: 'Generated Smalltalk:'; cr; show: code; cr."		"TODO: Review the translation methods to assure consistency in how nouns are handled.	Question: Is the blackboard used in a consistent way? 	*** blackboard is not used above, but is seen in Java translation. ***	"	"code inspect."	! !!HumOntologyTranslatorTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 4/20/2015 08:55'!test382ifStatementAsSmalltalk	"Translate if . . .   to  Smalltalk"	| ifStatement     ifSmalltalk     ontology |	true ifFalse: [ Transcript cr; show: 'test382ifStatementAsSmalltalk skipped'; cr. ^self.].	ifStatement := HumStatement from: 'If account balance = account last-invoice-total :'.	ontology := HumOntology new.	ontology addNouns: #( 'account' 'balance' 'last-invoice-total').	ifSmalltalk := ontology codeGenerator generateSmalltalkIfFor: ifStatement.	self expect: '(  ( blackboard entity: ''account'' attribute: ''balance'' ) = ( blackboard entity: ''account'' attribute: ''lastInvoiceTotal'' ) )  ifTrue: [' actual: ifSmalltalk.			! !!HumOntologyTranslatorTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 4/20/2015 08:15'!test384ifStatementAsSmalltalk	"Translate if . . .   to  Smalltalk"	| ifStatement     ifSmalltalk     ontology |	true ifFalse: [ Transcript cr; show: 'test384ifStatementAsSmalltalk skipped'; cr. ^self.].	ifStatement := HumStatement from: 'If account last-invoice-total is less than  account balance :'.	ontology := HumOntology new.	ontology addNouns: #( 'account' 'balance' 'last-invoice-total').	ifSmalltalk := ontology codeGenerator generateSmalltalkIfFor: ifStatement.	self expect:  '(  ( blackboard entity: ''account'' attribute: ''lastInvoiceTotal'' ) < ( blackboard entity: ''account'' attribute: ''balance'' ) )  ifTrue: [' actual: ifSmalltalk .			! !!HumOntologyTranslatorTests methodsFor: 'translate to Smalltalk' stamp: 'RichardAlexanderGreen 4/20/2015 08:21'!test390elseStatementAsSmalltalk	"Translate if . . .  else . . .  to Smalltalk"	| ifStatement elseStatement   ifSmalltalk elseSmalltalk  ontology |		false ifFalse: [ Transcript cr; show: '*** test390elseStatementAsSmalltalk is INCOMPLETE ***'; cr. ^self.].		ifStatement := ''.	elseStatement := ''.	ontology := HumOntology new.	ontology addNouns: #().	ifSmalltalk := ifStatement asSmalltalkWithOntology: ontology.	elseSmalltalk := elseStatement asSmalltalkWithOntology: ontology.	"TODO: Figure out how to translate 'Else:' from Hum to Smalltalk."	self shouldBeImplemented.	self assert: ( '**' match: ifSmalltalk ).	self assert: ( '**' match: elseSmalltalk ).			! !!HumOntologyTranslatorTests methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 1/21/2014 11:55'!testJ805translateStatementToCamelcase	| ontology statement s |	ontology := HumOntology new.	statement := HumStatement from: 'Add incoming-count to stock-count, giving updated-stock-count.'.	ontology addNouns: #( 'incoming-count' 'stock-count' 'updated-stock-count' ).	s := statement asCamelCaseWithOntology: ontology.	self assert: ( s = 'addIncomingCountToStockCountGivingUpdatedStockCount' ).! !!HumOntologyTranslatorTests methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 4/20/2015 08:27'!testJ811translateFrame4ActionToJava	"Given: a Hum action frame with a hyphenated noun.	When: translated to Java	Then: the resulting code is usable.	"	| frameEditor ontology code |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameUpdater ontology: ontology  	                                  role: 'Cook' 								action: 'Bake the cake-pan in the oven for the time given in the recipe.'.	frameEditor appendInstructionStatement: 'Open the oven door.'.	frameEditor appendInstructionStatement: 'Place the cake-pan in the oven.'.	frameEditor appendInstructionStatement: 'Close the oven door.'.	frameEditor appendInstructionRole: 'Oven' 	                                 statement: 'Heat for the time given in the recipe.' 	                                   comment: 'We have a smart oven.'.		ontology storeFrame: ( frameEditor frame ).	ontology addNouns: #( 'cake-pan' 'oven' 'recipe' 'time' 'door' ).	code := ontology codeGenerator asJava.		"Transcript cr; show: 'testJ811translateFrame4ActionToJava Generated Java'; cr; show: code; cr."			"Test: Title line is rendered."	self assert: ( '*bakeCakePanInOvenForTimeGivenInRecipe( CakePan aCakePan, Oven aOven, Time aTime, Recipe aRecipe ) {*' match: code ).		"TODO: The generated Java code (see below) will not compile because 'aDoor' is not defined."		"First instruction is rendered."	self assert: ( '*this.openOvenDoor( aOven, aDoor );*' match: code ).		"2nd instruction is rendered."	self assert: ( '*this.placeCakePanInOven( aCakePan, aOven );*' match: code ).	"3rd instruction is rendered."	self assert: ( '*this.closeOvenDoor( aOven, aDoor );*' match: code ).	"4th (delegated) inststruction is rendered"	self assert: ( '*aOven.heatForTimeGivenInRecipe( aTime, aRecipe ); *' match: code ).	"Comment is rendered"	self assert: ( '*smart oven*' match: code ).	"Code ends with a bracket"	self assert: ( code endsWith: ( '} // Actor: Cook', String cr ) ).	"Code should not contain doubled semi-colon.  (Test for bug)"	self assert: ( '*;   ;*' match: code ) not.		"TODO: Test for case where noun is a hyphenated term."	"code inspect."			! !!HumOntologyTranslatorTests methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 4/20/2015 08:27'!testJ810translateFrame4ActionToJava	"Given: a Hum action frame.	When: translated to Java	Then: the resulting code is usable.	"	| frameEditor ontology code |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameUpdater ontology: ontology  	                                  role: 'Cook' 								action: 'Bake the pan in the oven for the time given in the recipe.'.	frameEditor appendInstructionStatement: 'Open the oven door.'.	frameEditor appendInstructionStatement: 'Place the pan in the oven.'.	frameEditor appendInstructionStatement: 'Close the oven door.'.	frameEditor appendInstructionRole: 'Oven' 	                     statement: 'Heat for the time given in the recipe.' 	                       comment: 'We have a smart oven.'.		ontology storeFrame: ( frameEditor frame ).	ontology addNouns: #( 'pan' 'oven' 'recipe' 'time' 'door' ).	ontology compileAllFrames.	code := ontology codeGenerator asJava.		"Transcript cr; show: 'test810translateFrame4ActionToJava Generated Java'; cr; show: code; cr."			"Test: Title line is rendered."	self assert: ( '*bakePanInOvenForTimeGivenInRecipe( Pan aPan, Oven aOven, Time aTime, Recipe aRecipe ) {*' match: code ).		"TODO: The generated Java code (see below) will not compile because 'aDoor' is not defined."	"QUESTION: Is 'aDoor' a noise-word in this context? Do we really need it?"	"QUESTION: Should we/Could we fix the problem by adding a local variable declaration where needed?"		"First instruction is rendered."	self assert: ( '*this.openOvenDoor( aOven, aDoor );*' match: code ).		"2nd instruction is rendered."	self assert: ( '*this.placePanInOven( aPan, aOven );*' match: code ).	"3rd instruction is rendered."	self assert: ( '*this.closeOvenDoor( aOven, aDoor );*' match: code ).	"4th (delegated) inststruction is rendered"	self assert: ( '*aOven.heatForTimeGivenInRecipe( aTime, aRecipe ); *' match: code ).	"Comment is rendered"	self assert: ( '*smart oven*' match: code ).	"Code ends with a bracket"	self assert: ( code endsWith: ( '} // Actor: Cook', String cr ) ).	"Code should not contain doubled semi-colon.  (Test for bug)"	self assert: ( '*;   ;*' match: code ) not.		"code inspect."				! !!HumOntologyTranslatorTests methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 4/20/2015 08:27'!testJ820translateDictionaryToJava	"Add an is-A relation."	| ontology code |	ontology := HumOntology new.	"Define a few relations."	ontology addEntity: 'party' attributes: #(  'party-name' 'alphabetized-name' 'address'  ).	ontology addEntity: 'address' attributes: #( 'street-direction' 'street-number' 'street-name' 'postal-code' ).	ontology addEntity: 'postal-code' attributes: #( 'city' 'state-province' 'nation' ).	ontology addNoun: 'person' isA: 'party'.	ontology addEntity: 'person' attributes: #( 'primary-phone-number'   ).	ontology addNoun: 'contact' isA: 'person'.	ontology addNoun: 'organization' isA: 'party'.		code := ontology codeGenerator asJava.	"Transcript cr; show: 'test820translateDictionaryToJava'; cr; show: code; cr; show: '%%%%%%%%%%'; cr."			"Expect each entity to become a class declaration."	self assert: ( '*class Party*' match: code ).	self assert: ( '*class Address*' match: code ).	self assert: ( '*class PostalCode*' match: code ).	self assert: ( '*class Person*' match: code ).		"Entities extend their Hum supertype."	self assert: ( '*Person extends Party*' match: code ).	self assert: ( '*PostalCode extends Entity*' match: code ).	self assert: ( '*Address extends Entity*' match: code ).		"Attributes with no supertype are Strings by default"	self assert: ( '*public String streetDirection*' match: code).	self assert: ( '*public String streetNumber*' match: code).	self assert: ( '*public String stateProvince*' match: code).	self assert: ( '*public String nation*' match: code).	self assert: ( '*public String city*' match: code).	self assert: ( '*public String primaryPhoneNumber*' match: code).		"Attributes with supertypes declare accordingly"	self assert: ( '*public PostalCode postalCode*' match: code).	self assert: ( '*public Address address*' match: code).		"Classes have closing brace."	self assert: ( '*} // Entity: Party*' match: code).		"WARNING: Contact and Organization are not detected as entities 	    because they have no attributes of their own.	This is an artifact of how the current Ontology implements the dictionary.	"	"This is not exactly correct, but one might ask what was intended. 	Such classes are essentially synonyms. They may also indicate unfinished work."	"TODO: Add code-critic warning when supertypes/subtypes have no attributes of their own."	self assert: ( '*class Contact*' match: code ) not. 	self assert: ( '*class Organization*' match: code ) not.	self assert: ( '*Contact extends Person*' match: code ) not.	self assert: ( '*Organization extends Party*' match: code ) not.		"code inspect."									! !!HumOntologyTranslatorTests methodsFor: 'translate to Java' stamp: 'RichardAlexanderGreen 4/20/2015 08:27'!testJ830translateFrame4ActionToJavaExdentToBlockEnd	"Given: a Hum action frame.	When: translated to Java	Then: the resulting code is usable.	Then: the resulting code reflects the block structure as indicated by indentation.	"	| frameEditor ontology code tab |		true ifFalse: [ Transcript cr; show: 'test830translateFrame4ActionToJavaExdentToBlockEnd is turned off'; cr. ].	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameUpdater ontology: ontology role: 'Cook' action: 'Fulfill order.'.	"Enter an iteration statement."	frameEditor appendInstructionStatement: '. For each order-item in the order: '.	"Enter some inside the loop. (It should be indented when rendered.)"	"THINK: Should we require indentation here."	frameEditor appendInstructionStatement: '. . Pull order-item quantity from stock and place on cart.'.	"Next statement has no indent. That signals end of the iteration block."	frameEditor appendInstructionStatement: '. Ship the order to the order-address.'.			ontology storeFrame: ( frameEditor frame ).	ontology addEntity: 'order' attributes: #(  'order-items' 'order-address' customer ).	ontology addEntity: 'order-item' attributes: #( 'catalog-id' 'product-label' 'quantity' 'unit-price'  ).	ontology addNoun: 'quantity' isA: 'measure'.	ontology addEntity: 'address' attributes: #( 'street-line1' 'street-line2' postal-code ).	ontology addEntity: 'code' attributes: #( key value ).	ontology addEntity: 'postal-code' attributes: #( city ).	ontology addEntity: 'city' attributes: #( name province state nation ).	ontology addNouns: #( 'order' 'order-item' 'order-address'  ).		code := ontology codeGenerator asJava.	"	Transcript cr; 		show: 'test830translateFrame4ActionToJavaExdentToBlockEnd'; 		cr; show:' Generated Java:'; 		cr; show: code; cr."		"Test: Title line is rendered."	self assert: ( '*fulfillOrder( Order aOrder ) {*' match: code ).		"Test: 'For each order-item in the order:' "	self assert: ( '*for (*:*)*' match: code ).	self assert: ( '*aOrderItem*' match: code).	self assert: ( '*OrderItem orderItem*' match: code ).	self assert: ( '*for ( OrderItem orderItem : order.orderItems )*' match: code ).	                          		"Look for opening and closing '} // for' on the block."	self assert: ('*{*' match: code ).	tab := String tab.	self assert: ('*',tab,'}*' match: code ).		"code inspect."							! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 5/20/2014 09:23'!testH215tranlateButtonWidgetAtLineEnd	"Translate [[label]] into HTML button element -- Test for bug when widget is at end of line."	| ontology aBlackBoard aMarkupString result code |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard new.	aMarkupString := 'some preceeding content and then [[Preview]]'. 	result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.	self expect: '' actual: result.	code := ontology codeGenerator html contents.	self expect: 'some preceeding content and then <button name="Preview" type="button">Preview</button>'      actual: code.! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 4/20/2015 08:23'!testH330tranlateHeading	"Translate !!!!!! into HTML heading"	| ontology aBlackBoard aMarkupString code  viewFrame |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard new.	viewFrame := HumFrame4View new.	aMarkupString := '!!!!!! Heading Level 3'. 	viewFrame addMarkUp: aMarkupString.	code := ontology codeGenerator generateHTMLforMarkupLines: viewFrame frameLines blackboard: aBlackBoard.	self deny: ('*!!*' match: code).	self assert: ('*<h3>*Heading*</h3>*' match: code).	self expect: '<h3> Heading Level 3</h3>' trimBoth      actual: code trimBoth.! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 4/20/2015 08:26'!testH360tranlateListItemWithEmphasis	"Translate !!!!!! into HTML heading"	| ontology aBlackBoard aMarkupString code  viewFrame |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard new.	viewFrame := HumFrame4View new.	aMarkupString := '--- Item at indent level _3_.'. 	viewFrame addMarkUp: aMarkupString.	code := ontology codeGenerator generateHTMLforMarkupLines: viewFrame frameLines blackboard: aBlackBoard.	self deny: ('*!!*' match: code).	self assert: ('*<item3>*Item*<u>3</u>*</item3>*' match: code).	self expect: '<item3> &bull;  Item at indent level <u>3</u>.</item3>'       actual: code.! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 4/20/2015 08:26'!testH350tranlateListItem	"Translate !!!!!! into HTML heading"	| ontology aBlackBoard aMarkupString code  viewFrame |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard new.	viewFrame := HumFrame4View new.	aMarkupString := '--- Item at indent level 3'. 	viewFrame addMarkUp: aMarkupString.	code := ontology codeGenerator generateHTMLforMarkupLines: viewFrame frameLines blackboard: aBlackBoard.	self deny: ('*!!*' match: code).	self assert: ('*<item3>*Item*</item3>*' match: code).	self expect: '<item3> &bull;  Item at indent level 3</item3>'      actual: code.! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 4/20/2015 08:26'!testH420tranlateTextAreaWidget	"Translate [attribute 9] into textarea tag."	| ontology aBlackBoard aMarkupString code  result |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard worldbase: 'none'.	aBlackBoard businessEvent: 'testH420tranlateTextAreaWidget'.	aMarkupString := ' description: [description 5]'. 	ontology addEntity: 'user' attribute: 'description'.	aBlackBoard setEntityName: 'user' attribute: 'description' toValue: 'This text	has more than one line.	It could go on for many lines.	But five lines should be enough most of the time.	'.	ontology codeGenerator contextEntity: 'user'.	result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.	code := ontology codeGenerator html contents.	self assert: ( '*description:*<textarea*rows="5"*' match: code ).	self expect: ' description: <textarea type="text" name="description" rows="5">This text	has more than one line.	It could go on for many lines.	But five lines should be enough most of the time.	</textarea>'      actual: code.! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 5/20/2014 09:23'!testH125tranlatePageWidgetAtEnd	"Translate [page:text] into HTML anchor element - test for bug when widget is at line end."	| ontology aBlackBoard aMarkupString result code |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard new.	aMarkupString := '[page: menu item ]'.	result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.	self expect: '' actual: result.	code := ontology codeGenerator html contents.	self expect: '<a href="MenuItem.html"> menu item </a>'      actual: code.! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 5/30/2014 17:58'!testH140tranlateImageWidget	"Translate [link: text | URL ] into HTML anchor element"	| ontology aBlackBoard aMarkupString result code |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard new.	aMarkupString := 'Here is a pretty picture: [image: Pretty Picture | images/PrettyPicture.bmp ].'.	result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.	self expect: '' actual: result.	code := ontology codeGenerator html contents.	self expect: 'Here is a pretty picture: <img src="images/PrettyPicture.bmp" alt="Pretty Picture"/>.'      actual: code.! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 4/20/2015 08:23'!testH310tranlateTableRow	"Translate | ... | ... | into table elements."	| ontology aBlackBoard aMarkupString  code  viewFrame |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard new.	viewFrame := HumFrame4View new.	aMarkupString := '| column one | column two |'. 	viewFrame addMarkUp: aMarkupString.	code := ontology codeGenerator generateHTMLforMarkupLines: viewFrame frameLines blackboard: aBlackBoard.	self deny: ('*|*' match: code).	self expect: '<tr><td> column one </td><td> column two </td></tr>'      actual: code.! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 4/20/2015 08:26'!testH430tranlateEntityAttributeWidget	"Translate [entity`s attribute] into input tag."	| ontology aBlackBoard aMarkupString code  result |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard worldbase: 'none'.	aBlackBoard businessEvent: 'testH430tranlateEntityAttributeWidget'.	aMarkupString := ' name: [user`s name]'. 	ontology addEntity: 'user' attribute: 'name'.	aBlackBoard setEntityName: 'user' attribute: 'name' toValue: 'Billy Buyer'.	ontology codeGenerator contextEntity: 'user'.	result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.	code := ontology codeGenerator html contents.	self assert: ( '*name:*<input*' match: code ).	self expect: ' name: <input type="text" name="user:name" value="Billy Buyer"/>'      actual: code.! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 4/20/2015 08:26'!testH410tranlateAttributeWidget	"Translate [attribute] into input tag."	| ontology aBlackBoard aMarkupString code  result |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard worldbase: 'none'.	aBlackBoard businessEvent: 'testH410tranlateAttributeWidget'.	aMarkupString := ' name: [user-name]'. 	ontology addEntity: 'user' attribute: 'user-name'.	aBlackBoard setEntityName: 'user' attribute: 'user-name' toValue: 'Billy Buyer'.	ontology codeGenerator contextEntity: 'user'.	result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.	code := ontology codeGenerator html contents.	self assert: ( '*name:*<input*' match: code ).	self expect: ' name: <input type="text" name="user:user-name" value="Billy Buyer"/>'      actual: code.! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 5/20/2014 09:23'!testH120tranlatePageWidget	"Translate [page:text] into HTML anchor element"	| ontology aBlackBoard aMarkupString result code |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard new.	aMarkupString := 'To learn more, go to [page:This is only a test].'.	result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.	self expect: '' actual: result.	code := ontology codeGenerator html contents.	self expect: 'To learn more, go to <a href="ThisIsOnlyATest.html">This is only a test</a>.'       actual: code.! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 5/20/2014 09:23'!testH210tranlateButtonWidget	"Translate [[label]] into HTML button element"	| ontology aBlackBoard aMarkupString result code |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard new.	aMarkupString := '[[Submit]] [[Reset]] [[Preview]] '. "<<<< space at end allows defect to proceed"	result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.	self expect: '' actual: result.	code := ontology codeGenerator html contents.	self expect: '<button name="Submit" type="submit">Submit</button> <button name="Reset" type="reset">Reset</button> <button name="Preview" type="button">Preview</button> '      actual: code.! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 4/20/2015 08:23'!testH320tranlateTableRowWithEmphasis	"Translate | ... | ... | into table elements."	| ontology aBlackBoard aMarkupString code  viewFrame |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard new.	viewFrame := HumFrame4View new.	aMarkupString := '| *Product* | *Description* |'. 	viewFrame addMarkUp: aMarkupString.	code := ontology codeGenerator generateHTMLforMarkupLines: viewFrame frameLines blackboard: aBlackBoard.	self deny: ('*|*' match: code).	self expect: '<tr><td> <b>Product</b> </td><td> <b>Description</b> </td></tr>'      actual: code.! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 5/30/2014 17:58'!testH130tranlateLinkWidget	"Translate [link: text | URL ] into HTML anchor element"	| ontology aBlackBoard aMarkupString result code |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard new.	aMarkupString := 'To learn more, go to [link: Test Driven Development | http://c2.com/cgi/wiki?TestDrivenDevelopment].'.	result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.	self expect: '' actual: result.	code := ontology codeGenerator html contents.	self expect: 'To learn more, go to <a href="http://c2.com/cgi/wiki?TestDrivenDevelopment">Test Driven Development</a>.'      actual: code.! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 4/20/2015 08:26'!testH340tranlateHeadingWithEmphasis	"Translate !!!!!! into HTML heading"	| ontology aBlackBoard aMarkupString code  viewFrame |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard new.	viewFrame := HumFrame4View new.	aMarkupString := '!!!!!! Heading Level _3_'. 	viewFrame addMarkUp: aMarkupString.	code := ontology codeGenerator generateHTMLforMarkupLines: viewFrame frameLines blackboard: aBlackBoard.	self deny: ('*!!*' match: code).	self assert: ('*<h3>*Heading*<u>3</u>*</h3>*' match: code).	self expect: '<h3> Heading Level <u>3</u></h3>' trimBoth      actual: code trimBoth.! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 4/20/2015 08:23'!testH230tranlateRadioButtons	"Translate (a) into HTML radio-button element."	| ontology aBlackBoard aMarkupString result code |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard new.	aMarkupString := 'Are you a member?  (y) Yes.  (n) No.  (d) Not sure.'. 	result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.	self expect: '' actual: result.	code := ontology codeGenerator html contents.	self deny: ('*(*)*' match: code).	self expect: 'Are you a member?  <input name="y" type="radio"/> Yes.  <input name="n" type="radio"/> No.  <input name="d" type="radio"/> Not sure.'      actual: code."TODO: FIGURE OUT HOW TO GROUP RADIO BUTTONS."! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 4/20/2015 08:23'!testH216tranlateButtonWidgetAtLineEnd	"Translate [[label]] into HTML button element -- Test for bug when widget is at end of line."	| ontology aBlackBoard aMarkupString result code |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard new.	aMarkupString := 'some [[Middle Button]] and then [[Edge Button]]'. 	result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.	self expect: '' actual: result.	code := ontology codeGenerator html contents.	self deny: ('*[[*]]*' match: code).	self expect: 'some <button name="Middle Button" type="button">Middle Button</button> and then <button name="Edge Button" type="button">Edge Button</button>'      actual: code.! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 5/20/2014 09:23'!testH110tranlateEmphasis	"*text* becomes bold, ~text~ becomes italic, _text_ becomes underline, ^text^ becomes superscript"	| ontology aBlackBoard aMarkupString result code |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard new.	aMarkupString := 'This text is *bold*. This is ~italic~. This will be _underlined_. And this will be ^superscript^. '.	result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.	self expect: '' actual: result.	code := ontology codeGenerator html contents.	self expect: 'This text is <b>bold</b>. This is <i>italic</i>. This will be <u>underlined</u>. And this will be <sup>superscript</sup>. '       actual: code.! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 4/20/2015 08:23'!testH220tranlateCheckBox	"Translate [z] into HTML checkbox element."	| ontology aBlackBoard aMarkupString result code |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard new.	aMarkupString := '[a] Yes, I am lonely. Send me spam.'. 	result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.	self expect: '' actual: result.	code := ontology codeGenerator html contents.	self deny: ('*[*]*' match: code).	self expect: '<input type="checkbox" name="a"/> Yes, I am lonely. Send me spam.'      actual: code.! !!HumOntologyTranslatorTests methodsFor: 'translate markup to HTML' stamp: 'RichardAlexanderGreen 5/20/2014 09:23'!testH115tranlateEmphasisAtEnd	"*text* becomes bold, ~text~ becomes italic, _text_ becomes underline, ^text^ becomes superscript"	| ontology aBlackBoard aMarkupString result code |	ontology := HumOntology new.	aBlackBoard := HumBlackBoard new.	aMarkupString := '*To boldly go all the way to the end of line.*'.	result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.	self expect: '' actual: result.	code := ontology codeGenerator html contents.	self expect: '<b>To boldly go all the way to the end of line.</b>'       actual: code.! !!HumOntologyTranslatorTests methodsFor: 'z generated Smalltalk' stamp: 'RichardAlexanderGreen 2/26/2014 16:35'!fulfillOrderQorder: aOrder 	"For each order-item in the order: "	( self blackboard entity: 'order' attribute: 'orderItem' ) do: [ :orderItem |      | aOrderItem |     aOrderItem := orderItem.		"Pull order-item from stock and place on cart. "		 self pullOrderItemFromStockAndPlaceOnCartQorderItem: aOrderItem . 		].	"Ship the order to the order-address. "	 self shipTheOrderToTheOrderAddressQorder: aOrder . ! !!HumOntologyTranslatorTests methodsFor: 'z generated Smalltalk' stamp: 'RichardAlexanderGreen 2/26/2014 15:56'!bakeThePanInTheOvenForTheTimeGivenInTheRecipeQpan: aPan oven: aOven time: aTime recipe: aRecipe 	 | aDoor |	"Open the oven door. "	self openTheOvenDoorQoven: aOven door: aDoor . 	"Place the pan in the oven. "	 self placeThePanInTheOvenQpan: aPan oven: aOven . 	"Close the oven door. "	 self closeTheOvenDoorQoven: aOven door: aDoor . 	"Oven: Heat for the time given in the recipe.We have a smart oven."	 aOven heatForTheTimeGivenInTheRecipeQtime: aTime recipe: aRecipe . "We have a smart oven."! !HumTestCase subclass: #HumSimulatorTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumSimulatorTests methodsFor: 'Simulator tests' stamp: 'RichardAlexanderGreen 3/2/2015 10:27'!testX142RunClubMech	"A vignette may trigger a goal."	| ontology simulator messenger playback fileName pa dialogAgent stepLog scribe request worldbase request2 blackboard setup |	"set up"	fileName := 'ClubMechV02.txt'.	pa := HumProgrammersAssistant new.	pa loadOntologyFromTextFileNamed: fileName.	ontology := pa ontology.	ontology compileAllFrames.	simulator := HumSimulator new.	simulator ontology: (ontology).	setup := self setUpBasicConfigurationOn: simulator.	messenger := simulator messenger.	worldbase := messenger getActorInstanceFromID: (simulator worldbaseID).	worldbase clock: (simulator).	self assert: ( worldbase isKindOf: HumWorldBase ).	self expect: ( setup at: 'worldbase') actual: worldbase.		"Speech acts are interpreted by dialog vignettes in an ontology."	simulator after: ( 1 second ) sendSpeech: 'My name is Testy Tester.' from: 'client A'.	simulator after: (10 seconds) sendSpeech: 'Enter a topic.' from: 'client A'.	simulator step.	simulator stepUntilDone.		"Verify that expected messages were sent."	playback := messenger playbackLog.	self expect: 3 actual: (playback size) description: 'Check-in client-A bookkeeper worldbase ???'.	dialogAgent := simulator getDialogAgentNamed: 'client A'. 	blackboard := dialogAgent blackboard.	self expect: 'Testy Tester' actual: (blackboard getEntityName: 'user' attribute: 'name').	stepLog := dialogAgent stepLog.	self expect: 8 actual: (stepLog size) description: '???'.	self expect: #(		'client A: My name is Testy Tester.' 		'S:  Hello Testy Tester.' 		'S:    Please select an activity.' 		'DialogAgent: {client A} is doing: {Push context "Select an activity.".}' 		'client A: Enter a topic.' 		'S:  Please enter a description of the talk you are offering.' 		'DialogAgent: {client A} is doing: {Clear topic.}' 		'DialogAgent: {client A} is doing: {Ask topic.}'		)			actual: stepLog asArray.	"WHEN: Client enters data (speaker, title, description) and presses [Go!!] button ... "	"THEN: WorldBase should have a topic entity with attribute values for speaker, title, description. "	scribe := dialogAgent scribeProxy.	request := HumHttpRequest new.	request 		atField: 'topic:speaker' put: 'I.M. Speaker';		atField: 'topic:title' put: 'This is only a test.';		atField: 'topic:description' put: 'This is line one.',String cr,'This is line two'.	scribe handleHttpPostRequest: request.	"WorldBase should contain user`s name, topic`s speaker, title, description"	self expect: (setup at: 'worldbase') actual: worldbase.	self expect: 4 actual: ( worldbase quads size ). 	self expect: 0 actual: ( worldbase history size ).	"Enter a second topic. Result should be a second topic instance, not an updated version of first topic."	simulator after: (20 seconds) sendSpeech: 'Enter another topic.' from: 'client A'.	simulator step.	simulator stepUntilDone.	"At this point, 'Clear topic' instruction should have cleared topic entries from blackboard."	self expect: 2 actual: (blackboard entityIdentifiers size) description: 'topic ID established'.	self expect: 1 actual: (blackboard quads size) description: 'topic data not seen yet'.	"TODO: We need better way to indicate which topic instance (or a new instance) is to be updated."		request2 := HumHttpRequest new.	request2 		atField: 'topic:speaker' put: 'I.M. Speaker Too';		atField: 'topic:title' put: 'This is a second topic.';		atField: 'topic:description' put: 'This is line one of the second topic.',String cr,'This is line two of it.'.	scribe handleHttpPostRequest: request2.	self expect: 0 actual: ( worldbase history size ) description: 'Topic is added not updated.'. 	self expect: 7 actual: ( worldbase quads size ) description: 'We expect two topic instances'.	! !!HumSimulatorTests methodsFor: 'Simulator tests' stamp: 'RichardAlexanderGreen 1/2/2015 20:40'!testX124StepUntilDone	"A simulation loads client speech-acts into a queue with a specified delay.	. Each speech-act is sent to the dialog-agent that is attached to the simulator. 	. The timestamp on each event indicates its order, 	. . but does not determine the real-time duration of the simulation.	. The speech-act is sent when the simulation clock reaches the time indicated by the given delay.	"	| simulator ontology dialogAgent stepLog |	"Given: set up"	ontology := self setUpHotelOntology.	simulator := HumSimulator new.	simulator ontology: (ontology).	self setUpBasicConfigurationOn: simulator.	"Speech acts are interpreted by dialog vignettes in an ontology."	simulator after: (10 seconds) sendSpeech: 'Hello there.' from: 'client A'.	simulator after: (20 seconds) sendSpeech: 'I would like to check in.' from: 'client A'.	simulator after: (30 seconds) sendSpeech: 'When is check-out?' from: 'client A'.	simulator stepUntilDone.	self assert: ( simulator queue size = 0 ).	"simulator log4Dialog inspect."	"Examine logs for expected event and values."	dialogAgent := simulator getDialogAgentNamed: 'client A'. 	stepLog := dialogAgent stepLog.	self expect: #(		'client A: Hello there.' 		'S: Welcome to the Hotel California.' 		'client A: I would like to check in.' 		'S: Everyone has a reservation here. Please check-in.' 		'DialogAgent: {client A} is doing: {Ask Guest.}'  		'client A: When is check-out?' 		'S: You can check-out anytime. But you can never leave.') actual: stepLog asArray.! !!HumSimulatorTests methodsFor: 'Simulator tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:42'!testX100SimulatorReadMe	"The Simulator provides the means for 'regression testing'.	Hum dialogs / protocols may be exercised by sending a series of messages to one or more Dialog Agents.	Hum plans are initiated via such dialogs.	Evidence of execution may be found via the Bookkeeper, Messenger logs, and Agent logs.	"	"Simulations 'load' the system under test by starting dialog sequences 	. at random intervals as seen by the simulated clock.	==> We need a way to represent dialog sequences.	==> We need a way to represent random intervals.	==> We need a way to identify the number of dialogs to be run simultaneously.	==> Ideally, we will run the dialogs in independent threads.	"	"The simulator (Scribe?) emulates a human response rate 	. of approximating 1 keystroke (or button press) per second of simulated clock time.	. It is not necessary to simulate the sensor, just the time between vignette inputs.	"	"A simulation loads 'events' into a time-sorted queue and sends the events asynchronously.	. Agent/Actors respond to events by adding events of their own to the queue. 	. The timestamp on each event indicates its order, 	. . but does not determine the real-time duration of the simulation.	. There is no need to create real-time wait-times during the simulation.	"	! !!HumSimulatorTests methodsFor: 'Simulator tests' stamp: 'RichardAlexanderGreen 9/7/2014 11:51'!testX110AddEventToQueue	"A simulation loads client speech-acts into a queue with a specified delay.	. Each speech-act is sent to the dialog-agent that is attached to the simulator. 	. The timestamp on each event indicates its order, 	. . but does not determine the real-time duration of the simulation.	. The speech-act is sent when the simulation clock reaches the time indicated by the given delay.	"	| simulator anActor statement |	simulator := HumSimulator new.	"Speech acts are interpreted by dialog vignettes in an ontology."	simulator ontology: (self setUpHotelOntology).	simulator after: (30 seconds) sendSpeech: 'Hello.' from: 'client A'.	self assert: ( simulator queue size = 1 ).	self assert: ( ( simulator queue at: 1 ) isKindOf: Array).	self expect: { Duration seconds: 30.  #speech. 'client A'. 'Hello.'.} actual: ( simulator queue at: 1 ).	! !!HumSimulatorTests methodsFor: 'Simulator tests' stamp: 'RichardAlexanderGreen 12/27/2014 19:51'!testX130DialogUsesScribe	"There should be a Scribe in the chain.	A Dialog Agent does not connect directly to a UI framework.	A Dialog Agent uses a Scribe as an intermediary.	Simulator ==> Dialog Agent ==> Scribe.	Q: Where/When/How is the connection between Dialog Agent and Scribe instantiated ?	"	| simulator ontology dialogAgent stepLog scribe stepLog2 |	"setup"	ontology := self setUpHotelOntology.	simulator := HumSimulator new.	simulator ontology: (ontology).	self setUpBasicConfigurationOn: simulator.	"Speech acts are interpreted by dialog vignettes in an ontology."	simulator after: (30 seconds) sendSpeech: 'Hello.' from: 'client A'.	self assert: ( simulator queue size = 1 ).	self assert: ( ( simulator queue at: 1 ) isKindOf: Array).	self expect: { Duration seconds: 30.  #speech. 'client A'. 'Hello.'.} actual: ( simulator queue at: 1 ).	simulator step.	self assert: ( simulator queue size = 0 ).		"Examine log for expected event and values."	dialogAgent := simulator getDialogAgentNamed: 'client A'. 	stepLog := dialogAgent stepLog.	self expect: #('client A: Hello.' 'S: Welcome to the Hotel California.') actual: stepLog asArray.		"Verify that a Scribe is involved."	scribe := dialogAgent scribeProxy.	stepLog2 := scribe stepLog.	self expect: #('System: Welcome to the Hotel California.') actual: stepLog2 asArray.	! !!HumSimulatorTests methodsFor: 'Simulator tests' stamp: 'RichardAlexanderGreen 9/7/2014 11:51'!testX112AddTwoEventsToQueue	"A simulation loads client speech-acts into a queue with a specified delay.	. Each speech-act is sent to the dialog-agent that is attached to the simulator. 	. The timestamp on each event indicates its order, 	. . but does not determine the real-time duration of the simulation.	. The speech-act is sent when the simulation clock reaches the time indicated by the given delay.	"	| simulator anActor statement |	simulator := HumSimulator new.	"Speech acts are interpreted by dialog vignettes in an ontology."	simulator ontology: (self setUpHotelOntology).	simulator after: (10 seconds) sendSpeech: 'Hello there.' from: 'client A'.	simulator after: (20 seconds) sendSpeech: 'Hi there.' from: 'client B'.	self assert: ( simulator queue size = 2 ).	self expect: { Duration seconds: 10.  #speech. 'client A'. 'Hello there.'.} actual: ( simulator queue at: 1 ).	self expect: { Duration seconds: 20.  #speech. 'client B'. 'Hi there.'.} actual: ( simulator queue at: 2 ).	! !!HumSimulatorTests methodsFor: 'Simulator tests' stamp: 'RichardAlexanderGreen 12/27/2014 19:19'!testX140VignetteTriggersGoal	"A vignette may trigger a goal."	| ontology simulator messenger playback |	"setup"	ontology := self setUpDogAndPonyOntology.	simulator := HumSimulator new.	simulator ontology: (ontology).	self setUpDogAndPonyConfigurationOn: simulator.	"Speech acts are interpreted by dialog vignettes in an ontology."	simulator after: (10 seconds) sendSpeech: 'Eh?.' from: 'client A'.	simulator step.	simulator stepUntilDone.	( 1 to: 3 ) do: [:i | (Delay forMilliseconds: 1) wait.].  "Give forked processes some time to run."	"Verify that expected messages were sent."	messenger := simulator messenger.	playback := messenger playbackLog.	self assert: (playback size > 0).	"Expect logs for coordinator dispatcher bookkeeper worldbase dog pony band."	self expect: 7 actual: (playback size) 	     description: 'Expect logs for dispatcher bookkeeper worldbase coordinator dog pony band'. 	self expect: 9 actual: ( messenger playbackLogToURI: 'dispatcherURI' ) size		   description: 'Expect 6 check-ins and 3 assignments.'.	self expect: 1 actual: ( messenger playbackLogToURI: 'dogURI' ) size   description: 'dispatcher assigns to dog'.	self expect: 1 actual: ( messenger playbackLogToURI: 'ponyURI' ) size  description: 'dispatcher assigns to pony'.	self expect: 1 actual: ( messenger playbackLogToURI: 'bandURI' ) size  description: 'dispatcher assigns to band'.	! !!HumSimulatorTests methodsFor: 'Simulator tests' stamp: 'RichardAlexanderGreen 3/25/2015 10:52'!testX150RunParallel	"A vignette may trigger a goal."	| ontology simulator messenger playback myActors myBookkeeper |	ontology := self setUpDogAndPonyOntology.	simulator := HumSimulator new.	"Speech acts are interpreted by dialog vignettes in an ontology."	myActors := self setUpDogAndPonyConfigurationOn: simulator.	simulator ontology: (ontology).	simulator after: (10 seconds) sendSpeech: 'Eh?.' from: 'client A'.	simulator after: (20 seconds) sendSpeech: 'Eh?.' from: 'client B'.	simulator after: (30 seconds) sendSpeech: 'Eh?.' from: 'client C'.		simulator step.	simulator stepUntilDone.	( 1 to: 7 ) do: [:i | (Delay forMilliseconds: 1) wait.]. "Give forked processes some time to run."	"Verify that expected messages were sent."	messenger := simulator messenger.	playback := messenger playbackLog.	self assert: (playback size > 0) description: 'Messenger play-back-log should not be empty.'.	"Verify that expected messages were sent."	"Expect logs for coordinator dispatcher bookkeeper worldbase dog pony band."	self expect: 9 actual: (playback size) 		description: 'Expect logs for dispatcher bookkeeper worldbase dog pony band client-A client-B client-C'. 	self expect: 17  	     actual: ( messenger playbackLogToURI: 'dispatcherURI' ) size		description: 'Expect 8 check-ins and 9 assignments.'.	self expect: 3 actual: ( messenger playbackLogToURI: 'dogURI'  ) size  description: 'dispatcher assigns to dog'.	self expect: 3 actual: ( messenger playbackLogToURI: 'ponyURI' ) size  description: 'dispatcher assigns to pony'.	self expect: 3 actual: ( messenger playbackLogToURI: 'bandURI' ) size  description: 'dispatcher assigns to band'.			myBookkeeper := myActors at: 'bookkeeper'.	self expect: (HumMeasure quantity: 27 units: #step) 	     actual: (myBookkeeper chargesByRole at: 'Band:step'). 		! !!HumSimulatorTests methodsFor: 'Simulator tests' stamp: 'RichardAlexanderGreen 12/27/2014 20:19'!testX120Step	"A simulation loads client speech-acts into a queue with a specified delay.	. Each speech-act is sent to the dialog-agent that is attached to the simulator. 	. The timestamp on each event indicates its order, 	. . but does not determine the real-time duration of the simulation.	. The speech-act is sent when the simulation clock reaches the time indicated by the given delay.	"	| simulator ontology  dialogAgent stepLog |	"set up"	ontology := self setUpHotelOntology.	simulator := HumSimulator new.	simulator ontology: (ontology).	self setUpBasicConfigurationOn: simulator.		"Speech acts are interpreted by dialog vignettes in an ontology."	simulator after: (30 seconds) sendSpeech: 'Hello.' from: 'client A'.	self assert: ( simulator queue size = 1 ).	self assert: ( ( simulator queue at: 1 ) isKindOf: Array).	self expect: { Duration seconds: 30.  #speech. 'client A'. 'Hello.'.} actual: ( simulator queue at: 1 ).	simulator step.	self assert: ( simulator queue size = 0 ).		"Examine log for expected event and values."	dialogAgent := simulator getDialogAgentNamed: 'client A'. 	stepLog := dialogAgent stepLog.	self expect: 2 actual: stepLog size.	self expect: #('client A: Hello.' 'S: Welcome to the Hotel California.') actual: stepLog asArray.	! !!HumSimulatorTests methodsFor: 'Simulator tests' stamp: 'RichardAlexanderGreen 8/29/2014 11:39'!aDesignNoteEventQueue	"The Simulator provides the means for 'regression testing'.	Hum dialogs / protocols may be exercised by sending a series of messages to one or more Dialog Agents.	Hum plans are initiated via such dialogs.	Evidence of successful execution may be found via the Bookkeeper.	The Simulator simulates steps a simulated clock.	Simulations 'load' the system under test by sending dialog sequences 	. at random intervals as seen by the simulated clock.	The simulator emulates a human response rate 	. of approximating 1 keystroke (or button press) per second of simulated clock time.	. Since Hum is not currently intended for embedded systems, 	. . faster sensor rates are not needed at this time.	The simulated clock runs at some convenient multiple of real-time. 
  . This multiple is a configuration option. 	. 'Convenience' may be a combination of 	. . what the run-time can produce, and 	. . what the user wishes to monitor.	"	"Design Analysis:	Typically, one of two mechanisms are used to simulate clock-time:	a. The simulation loads 'events' into a time-sorted queue and sends the events asynchronously.	. . . Agent/Actors respond to events by adding events of their own to the queue.	b. The simulation 'steps' a simulated clock 	. . . and sends 'step' messages with a simulated clock timestamp to all actors simultaneously.	. . . Actor/Agents respond make some 'move' when each 'step' message arrives.	. . . The 'move' may be 'do nothing' if the agent is simulating an idle state, wait time, or task duration.	"	"When events are sparse, or the actual system response time is highly variable, method 'a' is preferred.	However, a human monitor may perceive the simulation as 'jerky'. 	But where simulation results are primarily examined after the 'run', the 'jerks' are not irrelevant.	Method 'a' can also be used when agents are scripted to perform certain actions at certain times of day.	The dialog stimulus may be a time-of-day notice in that case. 	"	"Method 'b' is typically more convenient for animations where the concept of frame-rate applies.	Note that method 'a' can also be applied to real-time animation 	  by sending a 'frame' event triggered by the real-time clock.	A recorded animation where the rendering work-flow time is relatively long, can also be driven by method 'a'.	"	"On the whole, method 'a' appears to be more flexible. So that is what we will implement.	Consequence: This requires that the timestamps in the Messenger may be over-ridden by simulated timestamps.	"! !!HumSimulatorTests methodsFor: 'Simulator tests' stamp: 'RichardAlexanderGreen 4/20/2015 08:29'!testX122StepStep	"A simulation loads client speech-acts into a queue with a specified delay.	. Each speech-act is sent to the dialog-agent that is attached to the simulator. 	. The timestamp on each event indicates its order, 	. . but does not determine the real-time duration of the simulation.	. The speech-act is sent when the simulation clock reaches the time indicated by the given delay.	"	| simulator ontology dialogAgent stepLog scribe scribeLog |	"set up"	ontology := self setUpHotelOntology.	simulator := HumSimulator new.	simulator ontology: (ontology).	self setUpBasicConfigurationOn: simulator.	"Speech acts are interpreted by dialog vignettes in an ontology."	simulator after: (10 seconds) sendSpeech: 'Hello there.' from: 'client A'.	simulator after: (20 seconds) sendSpeech: 'I would like to check in.' from: 'client A'.	self assert: ( simulator queue size = 2 ).	self expect: { Duration seconds: 10.  #speech. 'client A'. 'Hello there.'.} actual: ( simulator queue at: 1 ).	self expect: { Duration seconds: 20.  #speech. 'client A'. 'I would like to check in.'.} actual: ( simulator queue at: 2 ).	simulator step.	self assert: ( simulator queue size = 1 ).	self expect: { Duration seconds: 20.  #speech. 'client A'. 'I would like to check in.'.} actual: ( simulator queue at: 1 ).	simulator step.	self assert: ( simulator queue size = 0 ).	"Examine logs for expected event and values."	dialogAgent := simulator getDialogAgentNamed: 'client A'. 
  scribe := dialogAgent scribeProxy.	scribeLog := scribe log.	self assert: ( '*<input type="text" name="Guest:name" value=""/>*' match: (scribeLog at: 1)).	stepLog := dialogAgent stepLog.	self expect: #(		'client A: Hello there.' 		'S: Welcome to the Hotel California.' 		'client A: I would like to check in.' 		'S: Everyone has a reservation here. Please check-in.' 		'DialogAgent: {client A} is doing: {Ask Guest.}'		)	 	actual: stepLog asArray.! !!HumSimulatorTests methodsFor: 'Simulator tests' stamp: 'RichardAlexanderGreen 4/20/2015 08:29'!testX143RunBarista	"A vignette may trigger a goal."	| ontology simulator messenger playback fileName pa dialogAgent stepLog worker |	"set up"	fileName := 'Barista.txt'.	pa := HumProgrammersAssistant new.	pa loadOntologyFromTextFileNamed: fileName.	ontology := pa ontology.	ontology compileAllFrames.	simulator := HumSimulator new.	simulator ontology: (ontology).	self setUpBasicConfigurationOn: simulator.		worker := HumActor workerID: 'Bobbi' uri: 'URI:Bobbi' roles: #('barista' 'server') configuration: simulator.	worker checkIn.		"Speech acts are interpreted by dialog vignettes in an ontology."	simulator after: ( 1 second ) sendSpeech: 'Authenticated 1234567890.' from: 'client A'.
  "2015-01-22: Data is not being passed from order to worker. "	"TODO: Simulate form fill-in."  "2015-01-22: Fails because polymorphism is not implemented."	"TODO: Implement polymorphism."	simulator step.	simulator stepUntilDone.	( 1 to: 3 ) do: [ :i | (Delay forMilliseconds: 9) wait.].  "Give forked processes some time to run."		"Verify that expected messages were sent."	messenger := simulator messenger.	playback := messenger playbackLog.	self expect: 5 actual: (playback size) description: 'Check-in client-A bookkeeper worldbase ???'.	dialogAgent := simulator getDialogAgentNamed: 'client A'. 	stepLog := dialogAgent stepLog.	self assert: ( ('*Sorry*' match: (stepLog at: 2)) not ) 		description: 'Sorry -- {', (stepLog at:2),'}'.	self expect: #(		'client A: Authenticated 1234567890.' 		'S:  Welcome *** Unknown ***.' 		'S:    Please enter your order.' 		'DialogAgent: {client A} is doing: {Ask order.}'		)			actual: stepLog asArray.! !!HumSimulatorTests methodsFor: 'Simulator tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:42'!testX103RepresentNumberOfDialogs	"Simulations 'load' the system under test by starting dialog sequences 	. at random intervals as seen by the simulated clock.	==> We need a way to identify the number of dialogs to be run simultaneously.	"	| simulator |	simulator := HumSimulator new.	simulator numberOfDialogs: 3.! !!HumSimulatorTests methodsFor: 'Simulator tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:42'!testX102RepresentRandomIntervals	"Simulations 'load' the system under test by starting dialog sequences 	. at random intervals as seen by the simulated clock.	==> We need a way to represent random intervals.	"	| simulator distribution |	"Express the distribution as an S-curve in seconds."	distribution := Dictionary new.	distribution		at: 0.0 put: 100.0;		at: 50.0 put: 1000.0;		at: 100.0 put: 8000.0.	simulator := HumSimulator new.	simulator randomStartingIntervals: distribution.! !!HumSimulatorTests methodsFor: 'Simulator tests' stamp: 'RichardAlexanderGreen 7/15/2014 10:07'!testX101RepresentDialogSequence	"Simulations 'load' the system under test by starting dialog sequences 	. at random intervals as seen by the simulated clock.	==> We need a way to represent dialog sequences."	| simulator |	simulator := HumSimulator ontology: (HumOntology new).	simulator dialogSequence: #( 'Hello.' 'Goodbye.').! !!HumSimulatorTests methodsFor: 'Simulator tests' stamp: 'RichardAlexanderGreen 4/20/2015 08:29'!testX144RunDonutShop	"A vignette may trigger a goal."	| ontology simulator messenger playback fileName pa dialogAgent stepLog |	false ifFalse: [Transcript cr; show: 'testX144RunDonutShop turned off.'. ^self].	"set up"	fileName := 'DonutShopV05.txt'.	pa := HumProgrammersAssistant new.	pa loadOntologyFromTextFileNamed: fileName.	ontology := pa ontology.	ontology compileAllFrames.	simulator := HumSimulator new.	simulator ontology: (ontology).	self setUpBasicConfigurationOn: simulator.		"Speech acts are interpreted by dialog vignettes in an ontology."	simulator after: ( 1 second ) sendSpeech: 'Customer presents order.' from: 'client A'.	simulator step.	simulator stepUntilDone.	( 1 to: 3 ) do: [ :i | (Delay forMilliseconds: 9) wait.].  "Give forked processes some time to run."		"Verify that expected messages were sent."	messenger := simulator messenger.	playback := messenger playbackLog.	self expect: 3 actual: (playback size) description: 'Check-in client-A bookkeeper worldbase ???'.	dialogAgent := simulator getDialogAgentNamed: 'client A'. 	stepLog := dialogAgent stepLog.	self assert: ( ('*Sorry*' match: (stepLog at: 2)) not ) 		description: 'Sorry -- {', (stepLog at:2),'}'.	self expect: #(		)			actual: stepLog asArray.! !!HumSimulatorTests methodsFor: 'setup' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!setUpDogAndPonyOntology	"When this ontology runs,	 the vignette triggers the goal, and	 the plan should guides the sequence."	| testOntology frame4Plan planFrame2 planFrame3 actionFrame1 actionFrame2 actionFrame3 vignette1 |	testOntology := HumOntology new.	""	vignette1 := HumFrame4Vignette ontology: testOntology vignetteContext: 'Start.' pattern: 'Hello *.'.	vignette1 addVignettePattern: '* Hi*.'.	vignette1 addVignettePattern: '* Eh? *.'.		vignette1 addVignetteResponse: 'For your entertainment!! Doggy Dog and Prancing Pony!!'. 	vignette1 addVignetteInstruction: 'Goal: Run dog and pony show.'.	testOntology addVignette: vignette1 toContext: (vignette1 vignetteContext). 	"Root of plan"	frame4Plan := HumFrame4Plan ontology: testOntology goal: 'Run dog and pony show.'.	frame4Plan appendPrecondition: 'Dog is on pony`s back.'.	frame4Plan appendPrecondition: 'Pony is running in circle.'.	frame4Plan appendRole: 'Band' action: 'Play show music.'.	""	planFrame2 := HumFrame4Plan ontology: testOntology goal: 'Dog is on pony`s back.'.	planFrame2 appendPrecondition: 'Pony is running in circle.'.	planFrame2 appendRole: 'Dog' action: 'Jump on pony`s back.'.	""	planFrame3 := HumFrame4Plan ontology: testOntology goal: 'Pony is running in circle.'.	"planFrame3 addPrecondition: 'Pony is in the ring.' annotation: 'assumed'."	planFrame3 appendRole: 'Pony' action: 'Run in circle.'.	""	actionFrame1 := HumFrame4Action ontology: testOntology role: 'Band' action: 'Play show music.'.	actionFrame1			appendInstructionStatement: 'For each note in music:';			appendInstructionStatement: '	Read note.';	 		appendInstructionStatement: '	Play note.'.	""	actionFrame2 := HumFrame4Action ontology: testOntology role: 'Dog' action: 'Jump on pony`s back.'.	actionFrame2 			appendInstructionStatement: 'Bark twice. (to warn the pony)';			appendInstructionStatement: 'Jump and balance on pony`s back.'.	""	actionFrame3 := HumFrame4Action ontology: testOntology role: 'Pony' action: 'Run in circle.'.	actionFrame3			appendInstructionStatement: 'Enter ring.';			appendInstructionStatement: 'Run in circles until dog jumps off.'.	{ frame4Plan. planFrame2. planFrame3. actionFrame1. actionFrame2. actionFrame3.} 			do: [:frame | frame compileToOntology: testOntology.].	testOntology compileAllFrames.	"testOntology inspect.	self halt."	^testOntology.			! !!HumSimulatorTests methodsFor: 'setup' stamp: 'RichardAlexanderGreen 3/2/2015 09:26'!setUpBasicConfigurationOn: aHumSimulator 	| configuration actors dispatcher messenger bookkeeper worldBase setup  |	configuration := aHumSimulator.	messenger := (HumMessenger uri: 'messengerURI').	configuration messenger: messenger.	configuration messengerID: 'messengerID' dispatcherID: 'dispatcherID' bookkeeperID: 'bookkeeperID' worldbaseID: 'worldbaseID'. 	dispatcher := HumActor dispatcherID: 'dispatcherID' uri: 'dispatcherURI' configuration: configuration.	bookkeeper := HumActor bookkeeperID: 'bookkeeperID' uri: 'bookkeeperURI' configuration: configuration.	worldBase := HumWorldBase openWorldBase: 'worldbase for HumSimulatorTests'.	worldBase id: 'worldbaseID'; uri: 'worldbaseURI'; configuration: configuration; clock: aHumSimulator.	actors := { dispatcher. bookkeeper. worldBase. }.	actors do: [ :actor | actor checkIn. ].	setup := Dictionary new.	setup		at: 'worldbase' put: worldBase;		at: 'bookkeeper' put: bookkeeper;		at: 'dispatcher' put: dispatcher;		at: 'messenger' put: messenger.	^setup. "Return dictionary of actors to simplify test and debug."		! !!HumSimulatorTests methodsFor: 'setup' stamp: 'RichardAlexanderGreen 9/7/2014 20:15'!setUpKnockKnockOnOntology: anOntology	| viewFrame dictionaryFrame |	"Provide a view frame."	viewFrame := HumFrame4View ontology: anOntology viewEntity: 'Knock'.	viewFrame addMarkUp: '!!!!Knock, knock, who`s there?'.	viewFrame addMarkUp: '  Please enter first name: [first-name]'.	"Provide a dictionary frame."	dictionaryFrame := HumFrame4Dictionary ontology: anOntology title: 'Knock attributes'.	dictionaryFrame addDictionaryLine: 'Knock attributes include first-name.'.		dictionaryFrame compileToOntology: anOntology .	viewFrame       compileToOntology: anOntology.! !!HumSimulatorTests methodsFor: 'setup' stamp: 'RichardAlexanderGreen 1/2/2015 20:18'!setUpHotelOntology	| testOntology vignette1 vignette2 vignette3 view1 |	"Provide a set of vignettes."	testOntology := HumOntology baseOntology.	vignette1 := HumFrame4Vignette ontology: testOntology vignetteContext: 'Start.' pattern: 'Hello *.'.	vignette1 addVignettePattern: '* Hi *.'.	vignette1 addVignetteResponse: 'Welcome to the Hotel California.'. 	testOntology addVignette: vignette1 toContext: (vignette1 vignetteContext). 	vignette2 := HumFrame4Vignette ontology: testOntology vignetteContext: 'Start.' pattern: '* reservation *.'.	vignette2 addVignettePattern: '* check in *.'.	vignette2 addVignetteResponse: 'Everyone has a reservation here. Please check-in.'.	vignette2 addVignetteInstruction: 'Ask Guest.' . 	testOntology addVignette: vignette2 toContext: (vignette2 vignetteContext). 	vignette3 := HumFrame4Vignette ontology: testOntology vignetteContext: 'Start.' pattern: '* check-out *.'.	vignette3 addVignettePattern: '* check out *.'.	vignette3 addVignettePattern: '* check-out *.'.	vignette3 addVignettePattern: '* checkout *.'.	vignette3 addVignetteResponse: 'You can check-out anytime. But you can never leave.'.	testOntology addVignette: vignette3 toContext: (vignette3 vignetteContext). 		view1 := HumFrame4View ontology: testOntology viewEntity: 'Guest'.	view1 addMarkUp: '!! Guest Registry'.	view1 addMarkUp: ' name: [name]'.	testOntology addViewFrame: view1.		testOntology addNoun: 'guest' isA: 'person'.		^testOntology.   ! !!HumSimulatorTests methodsFor: 'setup' stamp: 'RichardAlexanderGreen 2/24/2015 10:33'!setUpDogAndPonyConfigurationOn: aHumSimulator 	| configuration actors dispatcher messenger bookkeeper worldBase dog pony band myActors |	"Attach the configuration to the Simulator. "	configuration := aHumSimulator.	"Instantiate the infrastructure agents."	messenger := (HumMessenger uri: 'messengerURI').	messenger clock: aHumSimulator.  "Use the simulated clock in place of the system clock."	configuration messenger: messenger.	configuration messengerID: 'messengerID' dispatcherID: 'dispatcherID' bookkeeperID: 'bookkeeperID' worldbaseID: 'worldbaseID'. 	dispatcher := HumActor dispatcherID: 'dispatcherID' uri: 'dispatcherURI' configuration: configuration.	bookkeeper := HumActor bookkeeperID: 'bookkeeperID' uri: 'bookkeeperURI' configuration: configuration.	worldBase := HumWorldBase openWorldBase: 'HumRunTimeTests:setUpDogAndPonyConfigurationOn'.	worldBase 		id: 'worldbaseID'; 		uri: 'worldbaseURI';		configuration: configuration;		clock: aHumSimulator.	"Instantiate the worker agents."	dog  := HumActor workerID: 'dogID' uri: 'dogURI' roles: #('dog') configuration: configuration.	pony := HumActor workerID: 'ponyID' uri: 'ponyURI' roles: #('pony') configuration: configuration.	band := HumActor workerID: 'bandID' uri: 'bandURI' roles: #('band') configuration: configuration.		actors := { dispatcher. bookkeeper. worldBase. dog. pony. band. }.	actors do: [ :actor | actor checkIn. ].		"Return a dictionary of actors for test convenience."	myActors := Dictionary new.	myActors		at: 'bookkeeper' put: bookkeeper;		at: 'dog' put: dog;		at: 'pony' put: pony;		at: 'band' put: band.	^myActors.	! !HumTestCase subclass: #HumUserInterfaceTests	instanceVariableNames: 'lastChange'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumUserInterfaceTests commentStamp: 'RichardAlexanderGreen 1/22/2012 08:35' prior: 0!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%USER INTERFACE TEST PLAN%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Assemble user interface from components   =======================================A. Scribe interprets keyboard, mouse, and menu gestures.   1. Keyboard has control or command or option pressed.      a) Conventional commands            (copy, cut, paste, un-do, save, open, print, close window, quit application).      b) Commands defined by the user, menu, or application default preferences.   2. Mouse actions      a) Mouse over. (May cause display.)      b) Mouse button pressed.       c) Mouse moved.      d) Mouse button released. (Buttons invoke commands.)   3. User selects action from menu.      a) Define menu | submenu | toolbar.      b) Respond to user navigation.      c) Send (user-selected) command.B. Painter renders 2-D objects in the users viewport.   1. Define billboard in anchored location   2. Define floating billboard in front of camera. (or near mouse cursor).   3. Define window (viewport).   4. Move billboards text-cursor (left, right, up, down, jump to).   5. Move billboard to a new anchored location.   6. Draw text on billboard at cursor.           (Side-effect: Cursor moves to end of text).   7. Draw lines and shapes on billboard.           (A diagram may direct the painter.) C. Sculptor renders 3-D objects in the users viewport.   1. Define 3-D shapes via      a) rotations.       b) extrusion.      c) cut.      d) fill with material.      e) cover with texture.   2. Common tasks (scripts / macros / routines)      a) Define deck, wall, door, window.      b) Define light.      c) Define room.      d) Place billboard on wall.   3. Create, move, animate avatar.      a) Create avatar.      b) Move avatar.      c) Animate avatar.D. Viewport actions affect a window (viewport).   1. Slide, pan, and zoom viewport.      a) Slice actions are like document-centric scrolling.      b) Pan actions are like rotating a camera up-down, left-right.      c) Zoom actions are like a zoom lens widening or narrowing the field of view             (as if the camera moved, but the camera does not move).   2. Move viewport to a new place in virtual world.      a) Rotate camera (same as pan actions).      b) Step forward | backward.      c) Side-step left | right.      d) Step-Turn left | right.      e) Step up (rise) | down (descend).      f) Move viewport to floor location under cursor.      g) Move viewport to face wall under cursor.!!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 3/12/2013 14:16'!testE142EditorIgnoresDeleteWhenCursorAtStartOfLine	"When we delete a character, the cursor decrements 	and the character is no longer in the text string."	| editor |	"Initial position of the cursor is line 1, column 1"	editor := HumEditor new.	self for: ( editor lineIndex ) expect:  1.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('',String cr).		"When a character is inserted at the cursor position, the cursor advances."	editor insertCharacter: $x.	self for: ( editor characterIndex ) expect:  1.		"And, of course, the text has the new character."	self for: ( editor text string ) expect:  ('x',String cr).				"Insert another character . . ."	editor insertCharacter: $y.	self for: ( editor characterIndex ) expect:  2.	self for: ( editor text string ) expect:  ('xy',String cr).				"Move cursor to start of line"	editor characterIndex: 0.	"Attempt delete -- should be ignored"	"Delete the character at start of line."	editor deletePriorCharacter.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('xy',String cr).			! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 10/9/2014 10:57'!testE140EditorDeleteCharacterAtEndOfLine	"When we delete a character, the cursor decrements 	and the character is no longer in the text string."	| editor |	"Initial position of the cursor is line 1, column 1"	editor := HumEditor new.	self for: ( editor lineIndex ) expect:  1.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('',String cr).		"When a character is inserted at the cursor position, the cursor advances."	editor insertCharacter: $x.	self for: ( editor characterIndex ) expect:  1.		"And, of course, the text has the new character."	self for: ( editor text string ) expect:  ('x',String cr).				"Insert another character . . ."	editor insertCharacter: $y.	self for: ( editor characterIndex ) expect:  2.	self for: ( editor text string ) expect:  ('xy',String cr).				"Delete the character at end of line."	editor text addDependent: self.	editor deletePriorCharacter.	self for: ( editor characterIndex ) expect:  1.	self for: ( editor text string ) expect:  ('x',String cr).		self assert: (self lastChange == editor text ).		! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 3/12/2013 14:11'!testE121EditorInsertCharacterAtFrontOfLine	"When we insert a character, the cursor advances and the character is in the text string."	| editor |	"Initial position of the cursor is line 1, column 1"	editor := HumEditor new.	self for: ( editor lineIndex ) expect:  1.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('',String cr).		"When a character is inserted at the cursor position, the cursor advances."	editor insertCharacter: $x.	self for: ( editor characterIndex ) expect:  1.		"And, of course, the text has the new character."	self for: ( editor text string ) expect:  ('x',String cr).				"Insert another character, but at the front of the line."	editor characterIndex: 0.	editor insertCharacter: $y.	self for: ( editor characterIndex ) expect:  1.	self for: ( editor text string ) expect:  ('yx',String cr).		! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 10/9/2014 10:52'!testE130EditorInsertLine	"When we insert a line, the cursor advances to the beginning of the new line."	| editor |	"Initial position of the cursor is line 1, column 1"	editor := HumEditor new.	self for: ( editor lineIndex ) expect:  1.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('',String cr).		"When a character is inserted at the cursor position, the cursor advances."	editor insertCharacter: $x.	self for: ( editor characterIndex ) expect:  1.		"And, of course, the text has the new character."	self for: ( editor text string ) expect:  ('x',String cr).				"Insert another character . . ."	editor insertCharacter: $y.	self for: ( editor characterIndex ) expect:  2.	self for: ( editor text string ) expect:  ('xy',String cr).				"Insert an empty line."	editor insertLine.	self for: ( editor lineIndex ) expect:  2.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('xy',String cr, String cr).		"We should see event"	editor text addDependent: self.	editor insertLine.	self assert: ( self lastChange == editor text ).		! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 7/31/2012 10:56'!testE141EditorDeleteCharacterAtStartOfLine	"When we delete a character, the cursor decrements 	and the character is no longer in the text string."	| editor |	"Initial position of the cursor is line 1, column 1"	editor := HumEditor new.	self for: ( editor lineIndex ) expect:  1.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('',String cr).		"When a character is inserted at the cursor position, the cursor advances."	editor insertCharacter: $x.	self for: ( editor characterIndex ) expect:  1.		"And, of course, the text has the new character."	self for: ( editor text string ) expect:  ('x',String cr).				"Insert another character . . ."	editor insertCharacter: $y.	self for: ( editor characterIndex ) expect:  2.	self for: ( editor text string ) expect:  ('xy',String cr).				"Delete the character at end of line."	editor deletePriorCharacter.	self for: ( editor characterIndex ) expect:  1.	self for: ( editor text string ) expect:  ('x',String cr).			"Delete the character at start of line."	editor deletePriorCharacter.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('',String cr).			! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 10/8/2014 12:05'!testE220InterpretAltArrowKeys	"The arrow keys move the cursor and forget the selection.	altArrowUp ==> move cursor to start of first line.	altArrowDown ==> move cursor to end of last line.	altArrowRight ==> move cursor to start of current line.	altArrowLeft ==> move cursor to end of current line.	"	| editor |	editor := HumEditor new.	editor addLine: 'This is line one.'.	editor addLine: 'This is line two.'.	editor lineIndex: 2.	editor characterIndex: 0.	self for: (editor lineIndex) expect: 2.	self for: (editor characterIndex) expect: 0.	editor interpretKey: #altArrowUp.	self for: ( editor lineIndex ) expect: 1.	self for: ( editor characterIndex ) expect: 0.		editor interpretKey: #altArrowDown.	self for: ( editor lineIndex ) expect: 2.	self for: ( editor characterIndex ) expect: ('This is line two.' size).		editor characterIndex: 1.	editor interpretKey: #altArrowRight.	self for: ( editor characterIndex ) expect:  ('This is line two.' size).		editor interpretKey: #altArrowLeft.	self for: ( editor characterIndex ) expect: 0.		"When we try to push beyond the current text. The cursor does not move."	editor interpretKey: #altArrowLeft.	self for: ( editor characterIndex ) expect: 0.		editor interpretKey: #altArrowDown.	self for: ( editor lineIndex ) expect: 2.		editor interpretKey: #altArrowUp.	self for: ( editor lineIndex ) expect: 1.		editor interpretKey: #altArrowUp.	self for: ( editor lineIndex ) expect: 1.							! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 10/9/2014 10:24'!testE230InterpretShiftArrowKeys	"The shift arrow keys move the cursor and update the selection.	shiftArrowUp ==> Move cursor upward. Update selection.	shiftArrowDown ==> Move cursor downward. Update selection. 	shiftArrowRight ==> Move cursor to the right. Update selection.	shiftArrowLeft ==> Move cursor to the left. Update selection.	Selection is updated so that either the start or the end includes the cursor.	Note: Selection is modal and history dependent.	"	| editor cr |	cr := String cr.	editor := HumEditor new.	editor addLine: 'ABCD'.	editor addLine: 'abcd'.	editor lineIndex: 2.	editor characterIndex: 0.	self for: (editor lineIndex) expect: 2.	self for: (editor characterIndex) expect: 0.	editor 		characterIndex: 2;		lineIndex: 1;		interpretKey: #arrowLeft.	self for: ( editor characterIndex ) expect: 1.	editor interpretKey: #shiftArrowRight.	self for: ( editor selectedText ) expect: 'B'.	editor interpretKey: #shiftArrowRight.	self for: ( editor selectedText ) expect: 'BC'.	editor interpretKey: #shiftArrowRight.	self for: ( editor selectedText ) expect: 'BCD'.	editor interpretKey: #shiftArrowRight.	self for: ( editor selectedText ) expect: 'BCD'. "does not wrap"	editor interpretKey: #shiftArrowLeft.	self for: ( editor selectedText ) expect: 'BC'.	editor interpretKey: #shiftArrowLeft.	self for: ( editor selectedText ) expect: 'B'.	editor interpretKey: #shiftArrowDown.	self for: ( editor selectedText ) expect: 'BCD',cr,'ab'.	editor interpretKey: #shiftArrowLeft.	self for: ( editor selectedText ) expect: 'BCD',cr,'a'.	editor interpretKey: #shiftArrowLeft.	self for: (editor characterIndex ) expect: 0.	self for: ( editor selectedText ) expect: 'BCD',cr.		"Go the other way."	editor		lineIndex: 2;		characterIndex: 2;		interpretKey: #arrowRight.	self for: ( editor characterIndex ) expect: 3.	editor		interpretKey: #shiftArrowUp.	self for: ( editor characterIndex ) expect: 3.	self for: ( editor lineIndex ) expect: 1.		self for: ( editor selectedText ) expect: 'D',cr,'abc'.		! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 10/14/2014 12:37'!testE315EditorSupportsUnDoAtBottom	"Editor supports multiple levels of undo - tolerates too many pops."		| editor text1 text2 text3 text4 |	"Initial position of the cursor is line 1, column 1"	editor := HumEditor new.	self for: (editor lineIndex) expect: 1.	self for: (editor characterIndex) expect: 0.	text1 := editor text copy.	self for: ( text1 lines size ) expect: 1.	self for: ( text1 string ) expect:  ('',String cr).		"When a character is inserted at the cursor position, the cursor advances."	editor insertCharacter: $x.	text2 := editor text copy.	self for: ( text2 string ) expect:  ('x',String cr).				"Insert another character . . ."	editor insertCharacter: $y.	text3 := editor text copy.	self for: ( text3 string ) expect:  ('xy',String cr).				"Insert an empty line."	editor insertLine.	text4 := editor text copy.	self for: ( text4 string ) expect:  ('xy', String cr, String cr).		self for: ( text1 string ) expect:  ('',String cr).	self for: ( text2 string ) expect:  ('x',String cr).		self for: ( text3 string ) expect:  ('xy',String cr).		self for: ( text4 string ) expect:  ('xy', String cr, String cr).		"Test undo"	editor undo.	self assert: ( editor text = text4 ) not.	self for: ( editor text  ) expect:  text3 .		"Multiple levels of undo"	editor undo.	self for: ( editor text  ) expect:  text2 .	editor undo.	self for: ( editor text  ) expect:  text1 .	"Too many undo should not raise exception or produce unexpected side effect."	editor undo.	self for: ( editor text  ) expect:  text1 .			! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 10/14/2014 12:52'!testE320EditorSupportsReDo	"Editor supports multiple levels of undo and redo."		| editor text1 text2 text3 text4 |	"Initial position of the cursor is line 1, column 1"	editor := HumEditor new.	self for: (editor lineIndex) expect: 1.	self for: (editor characterIndex) expect: 0.	text1 := editor text copy.	self for: ( text1 lines size ) expect: 1.	self for: ( text1 string ) expect:  ('',String cr).		"When a character is inserted at the cursor position, the cursor advances."	editor insertCharacter: $x.	text2 := editor text copy.	self for: ( text2 string ) expect:  ('x',String cr).				"Insert another character . . ."	editor insertCharacter: $y.	text3 := editor text copy.	self for: ( text3 string ) expect:  ('xy',String cr).				"Insert an empty line."	editor insertLine.	text4 := editor text copy.	self for: ( text4 string ) expect:  ('xy', String cr, String cr).		self for: ( text1 string ) expect:  ('',String cr).	self for: ( text2 string ) expect:  ('x',String cr).		self for: ( text3 string ) expect:  ('xy',String cr).		self for: ( text4 string ) expect:  ('xy', String cr, String cr).		"Test undo"	editor undo.	self assert: ( editor text = text4 ) not.	self for: ( editor text  ) expect:  text3 .		"Multiple levels of undo"	editor undo.	self for: ( editor text  ) expect:  text2 .	editor undo.	self for: ( editor text  ) expect:  text1 .		"Multiple levels of redo"	editor redo.	self for: ( editor text  ) expect:  text2 .	editor redo.	self for: ( editor text  ) expect:  text3 .	editor redo.	self for: ( editor text  ) expect:  text4 .			! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 10/9/2014 10:46'!testE120EditorInsertCharacterAtEndOfLine	"When we insert a character, the cursor advances and the character is in the text string."	| editor |	"Initial position of the cursor is line 1, column 1"	editor := HumEditor new.	self for: ( editor lineIndex ) expect:  1.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('',String cr).		"When a character is inserted at the cursor position, the cursor advances."	editor insertCharacter: $x.	self for: ( editor characterIndex ) expect:  1.		"And, of course, the text has the new character."	self for: ( editor text string ) expect:  ('x',String cr).				"Insert another character . . ."	editor insertCharacter: $y.	self for: ( editor characterIndex ) expect:  2.	self for: ( editor text string ) expect:  ('xy',String cr).				"Editor is a controller. Text is a model. When text is changed, it issues a change notice."	editor text addDependent: self. "This TestCase instance will receive #update: call."	editor insertCharacter: $z.	self assert: (self lastChange = editor text ).	! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 3/12/2013 14:20'!testE143EditorDeleteCharactersWillNotBackOverBeginningOfLine	"When we delete a character, the cursor decrements 	and the character is no longer in the text string.	When the cursor is at the start of the line (position zero),	it will back no further (and will not delete the prior line-end).	TODO: Decide if this is the correct behavior.	"	| editor |	"Initial position of the cursor is line 1, column 1"	editor := HumEditor new.	self for: ( editor lineIndex ) expect:  1.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('',String cr).		"When a character is inserted at the cursor position, the cursor advances."	editor insertCharacter: $x.	self for: ( editor characterIndex ) expect:  1.		"And, of course, the text has the new character."	self for: ( editor text string ) expect:  ('x',String cr).				"Insert another character . . ."	editor insertCharacter: $y.	self for: ( editor characterIndex ) expect:  2.	self for: ( editor text string ) expect:  ('xy',String cr).				"Delete the character at end of line."	editor deletePriorCharacter.	self for: ( editor characterIndex ) expect:  1.	self for: ( editor text string ) expect:  ('x',String cr).			"Delete the character at start of line."	editor deletePriorCharacter.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('',String cr).			"Attempt one more delete."	editor deletePriorCharacter.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('',String cr).			! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 3/12/2013 14:14'!testE131EditorInsertTwoLines	"When we insert a line, the cursor advances to the beginning of the new line."	| editor |	"Initial position of the cursor is line 1, column 1"	editor := HumEditor new.	self for: ( editor lineIndex ) expect:  1.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('',String cr).		"When a character is inserted at the cursor position, the cursor advances."	editor insertCharacter: $x.	self for: ( editor characterIndex ) expect:  1.		"And, of course, the text has the new character."	self for: ( editor text string ) expect:  ('x',String cr).				"Insert another character . . ."	editor insertCharacter: $y.	self for: ( editor characterIndex ) expect:  2.	self for: ( editor text string ) expect:  ('xy',String cr).				"Insert an empty line."	editor insertLine.	editor insertLine.	self for: ( editor lineIndex ) expect:  3.	self for: ( editor characterIndex ) expect:  0.	self for: ( editor text string ) expect:  ('xy', String cr, String cr, String cr).		! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 10/9/2014 10:31'!testE110EditorPosition	"The editor owns a (cursor) position."	| editor |	editor := HumEditor new.	"Initial position is at front of first line."	self assert: editor lineIndex equals: 1.	self assert: editor characterIndex equals: 0.	! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 10/8/2014 12:05'!testE210InterpretArrowKeys	"The arrow keys move the cursor and forget the selection.	arrowUp ==> move cursor upward	arrowDown ==> move cursor downward	arrowRight ==> move cursor to the right	arrowLeft ==> move cursor to the left	"	| editor |	editor := HumEditor new.	editor addLine: 'This is line one.'.	editor addLine: 'This is line two.'.	editor lineIndex: 2.	editor characterIndex: 0.	self for: (editor lineIndex) expect: 2.	self for: (editor characterIndex) expect: 0.	editor interpretKey: #arrowUp.	self for: ( editor lineIndex ) expect: 1.		editor interpretKey: #arrowDown.	self for: ( editor lineIndex ) expect: 2.		editor interpretKey: #arrowRight.	self for: ( editor characterIndex ) expect: 1.		editor interpretKey: #arrowLeft.	self for: ( editor characterIndex ) expect: 0.		"When we try to push beyond the current text. The cursor does not move."	editor interpretKey: #arrowLeft.	self for: ( editor characterIndex ) expect: 0.		editor interpretKey: #arrowDown.	self for: ( editor lineIndex ) expect: 2.		editor interpretKey: #arrowUp.	self for: ( editor lineIndex ) expect: 1.		editor interpretKey: #arrowUp.	self for: ( editor lineIndex ) expect: 1.							! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 10/14/2014 11:42'!testE310EditorSupportsUnDo	"Editor supports multiple levels of undo."		| editor text1 text2 text3 text4 |	"Initial position of the cursor is line 1, column 1"	editor := HumEditor new.	self for: (editor lineIndex) expect: 1.	self for: (editor characterIndex) expect: 0.	text1 := editor text copy.	self for: ( text1 lines size ) expect: 1.	self for: ( text1 string ) expect:  ('',String cr).		"When a character is inserted at the cursor position, the cursor advances."	editor insertCharacter: $x.	text2 := editor text copy.	self for: ( text2 string ) expect:  ('x',String cr).				"Insert another character . . ."	editor insertCharacter: $y.	text3 := editor text copy.	self for: ( text3 string ) expect:  ('xy',String cr).				"Insert an empty line."	editor insertLine.	text4 := editor text copy.	self for: ( text4 string ) expect:  ('xy', String cr, String cr).		self for: ( text1 string ) expect:  ('',String cr).	self for: ( text2 string ) expect:  ('x',String cr).		self for: ( text3 string ) expect:  ('xy',String cr).		self for: ( text4 string ) expect:  ('xy', String cr, String cr).		"Test undo"	editor undo.	self assert: ( editor text = text4 ) not.	self for: ( editor text  ) expect:  text3 .		"Multiple levels of undo"	editor undo.	self for: ( editor text  ) expect:  text2 .	editor undo.	self for: ( editor text  ) expect:  text1 .		! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 10/14/2014 12:55'!testE325EditorSupportsReDoToBottom	"Editor supports multiple levels of undo and redo."		| editor text1 text2 text3 text4 |	"Initial position of the cursor is line 1, column 1"	editor := HumEditor new.	self for: (editor lineIndex) expect: 1.	self for: (editor characterIndex) expect: 0.	text1 := editor text copy.	self for: ( text1 lines size ) expect: 1.	self for: ( text1 string ) expect:  ('',String cr).		"When a character is inserted at the cursor position, the cursor advances."	editor insertCharacter: $x.	text2 := editor text copy.	self for: ( text2 string ) expect:  ('x',String cr).				"Insert another character . . ."	editor insertCharacter: $y.	text3 := editor text copy.	self for: ( text3 string ) expect:  ('xy',String cr).				"Insert an empty line."	editor insertLine.	text4 := editor text copy.	self for: ( text4 string ) expect:  ('xy', String cr, String cr).		self for: ( text1 string ) expect:  ('',String cr).	self for: ( text2 string ) expect:  ('x',String cr).		self for: ( text3 string ) expect:  ('xy',String cr).		self for: ( text4 string ) expect:  ('xy', String cr, String cr).		"Test undo"	editor undo.	self assert: ( editor text = text4 ) not.	self for: ( editor text  ) expect:  text3 .		"Multiple levels of undo"	editor undo.	self for: ( editor text  ) expect:  text2 .	editor undo.	self for: ( editor text  ) expect:  text1 .		"Multiple levels of redo"	editor redo.	self for: ( editor text  ) expect:  text2 .	editor redo.	self for: ( editor text  ) expect:  text3 .	editor redo.	self for: ( editor text  ) expect:  text4 .		"Tolerate one too many."	editor redo.	self for: ( editor text  ) expect:  text4 .			! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 10/9/2014 10:47'!lastChange	^ lastChange ! !!HumUserInterfaceTests methodsFor: 'HumEditor Tests' stamp: 'RichardAlexanderGreen 10/9/2014 10:50'!update: someObject	"Record fact that someObject was updated by a test.	We must call 'someObject addDependent: self' prior to causing update.	"	lastChange := someObject! !!HumUserInterfaceTests methodsFor: 'HumAssembly tests' stamp: 'RichardAlexanderGreen 1/1/2014 09:27'!testS550sceneAsThreeJSinHTML	"Render a box as a ThreeJS cube"	| scene js expect html |	scene := self buildTrailerScene.	scene id: 'theScene'.		js := scene asThreeJS.
	html := scene asThreeJSinHTML.		"write it to a file as see if it compiles and renders"	HumCalculator writeString: html toFileNamed: ((scene asCamelCase),'.html').! !!HumUserInterfaceTests methodsFor: 'HumAssembly tests' stamp: 'RichardAlexanderGreen 1/3/2014 11:15'!buildTrailerNoseCurve	"Return curve of #(x y) where x = 0 is front-most point, y is offset from centerline"	| yOffset xOffset f curve|	yOffset := -1.0.	xOffset := -2.0.	f := 1.0 / (xOffset * xOffset).	curve := OrderedCollection new.	"Transcript cr; show: '========='."	(0.0 to: 1.0 by: 0.05 )  		do: [ :p |	    |x y x2 y2|			x := p * 2.			x2 := (p*2) + xOffset.			y2 := ( f * (x2*x2) ).			y := (y2 + yOffset) negated.			"Transcript cr; show: (x printShowingDecimalPlaces:2),'==>',(y printShowingDecimalPlaces:2)."			curve add: ( x@y ).			].	^curve ! !!HumUserInterfaceTests methodsFor: 'HumAssembly tests' stamp: 'RichardAlexanderGreen 4/20/2015 08:29'!testS625VPythonTrailer	| trailer pythonCode scene file |	trailer := self buildTrailerAssembly.	scene := HumScene new.	scene addPart: trailer.	pythonCode := scene asVPython.	"Generated code should contain BoxThing() instances."	self assert: ( '*BoxThing(*' match: pythonCode ).	"TODO: Generated code should contain positioning statements."		"Write code out to a file for easier inspection and possible compilation."	file := StandardFileStream fileNamed: 'testS625VPythonTrailer.py'.	file nextPutAll: pythonCode.	file close.	! !!HumUserInterfaceTests methodsFor: 'HumAssembly tests' stamp: 'RichardAlexanderGreen 11/1/2014 14:51'!testS425trailerExample2	"Test DSL usability -- change #depth to #length -- No code is generated."	| trailer deckLayer wallLayer interiorLayer	   interiorLength interiorWidth interiorHeight 	   deck  deckThickness	  wallThickness wallHeight eastWall westWall northWall southWall 	  bed bedClearance bedWalkSpace 	  centerAisle eastCloset westCloset closetDepth 	  bulkheadWidth bulkheadThickness topSpace	  toilet handSink shower	  galleyBulkhead shoulderWidth galleyLength galley galleyTable	|	trailer := (HumAssembly new) id: 'trailer'.	deckLayer := (HumLayer new) id: 'deck layer'.	wallLayer := (HumLayer new) id: 'wall layer'.	interiorLayer := (HumLayer new) id: 'interior layer'.		"deck"	deckThickness   := 0.20 meters.	interiorLength  := 6.00 meters.	interiorWidth   := 2.00 meters.	interiorHeight  := 2.00 meters.		deck :=  HumSolid id: 'deck' type: #box height: deckThickness width: interiorWidth length: interiorLength.	deckLayer addPart: deck.  "walls"	wallThickness := 0.10 meters.	wallHeight    := 1.00 meters.	northWall := HumSolid id: 'northWall' type: #box height: wallHeight width: interiorWidth length: wallThickness.	southWall := HumSolid id: 'southWall' type: #box height: wallHeight width: interiorWidth length: wallThickness.	eastWall := HumSolid id: 'eastWall' type: #box height: wallHeight width: wallThickness length: interiorLength.	westWall := HumSolid id: 'westWall' type: #box height: wallHeight width: wallThickness length: interiorLength.	"Assembly deck and walls"	trailer position: northWall northOf: deck.	trailer position: southWall southOf: deck.	trailer position: eastWall eastOf: deck.	trailer position: westWall westOf: deck.	wallLayer addParts: { northWall. southWall. eastWall. westWall. }.	"======= bed room ========"	bed := HumSolid id: 'bed' type: #box height: (0.5 meters) width: (1.2 meters) length: (2.0 meters).	trailer position: bed southOf: northWall.	trailer position: bed onTopOf: deck.	bedClearance := 0.50 meters.	bedWalkSpace := HumSpace id: 'bedWalkSpace' height: interiorHeight width: interiorWidth length: bedClearance .	"closets"	closetDepth   := 0.50 meters.	bulkheadWidth := 0.70 meters.  eastCloset := HumSolid	id: 'eastCloset' type: #box height: interiorHeight width: bulkheadWidth length: closetDepth.	westCloset := HumSolid	id: 'westCloset' type: #box height: interiorHeight width: bulkheadWidth length: closetDepth.	centerAisle := HumSpace id: 'centerAisle' height: interiorHeight width: (interiorWidth - (bulkheadWidth*2.0)) length: interiorLength.	trailer center: centerAisle onTopOf: deck.  trailer position: bedWalkSpace southOf: bed.	trailer position: eastCloset eastOf: centerAisle.	trailer position: eastCloset southOf: bedWalkSpace.	trailer position: westCloset westOf: centerAisle.	trailer position: westCloset southOf: bedWalkSpace.	interiorLayer addParts: { bed. bedWalkSpace. eastCloset. westCloset. centerAisle. }. "bed room parts"	"======= bath room ==========="	toilet := HumSolid id: 'toilet' type: #box height: (0.40 meters) width: (0.20 meters) length: (0.80 meters).	trailer position: toilet onTopOf: deck.	trailer position: toilet southOf: westCloset.	trailer position: toilet eastOf: westWall.	"Postion hand sink above toilet but below topSpace - top will be ~ 1 meter ~ 40 inches above floor"	handSink := HumSolid id: 'hand sink' type: #box height: (0.20 meters) width: (0.20 meters) length: (0.80 meters).	topSpace := HumSpace id: 'top space' height: (interiorHeight / 2.0) width: interiorWidth length: interiorLength.	trailer center: topSpace over: deck.	trailer position: topSpace over: westWall.	trailer center: handSink above: toilet.	trailer position: handSink below: topSpace.	"Position shower by East wall (east of center aisle in bath roos)"	shower := HumSpace id: 'shower'  height: interiorHeight width: bulkheadWidth length: (0.80 meters). 	trailer position: shower onTopOf: deck.	trailer position: shower westOf: eastWall.	trailer position: shower southOf: eastCloset.	interiorLayer addParts: { toilet. handSink. shower. }.		"======== galley =========="	bulkheadThickness := (0.04 meter).	galleyBulkhead := HumSolid id: 'galleyBulkhead' type: #box 	                           height: interiorHeight width: bulkheadWidth length: bulkheadThickness.	galleyLength := (0.50 meters) "space for 3-burner stove"	              + (1.20 meters) "space for kichen sink and food prep".	"Assure shoulder room at table" 	shoulderWidth := (0.80 meters).	( galleyLength < ( shoulderWidth * 2.0)  ) ifTrue: [ galleyLength := ( shoulderWidth * 2.0) ].   galleyTable := HumSolid id: 'galleyTable' type: #box                           height: (0.02 meters) width: (0.6 meter) length: galleyLength.	galley := HumSolid id: 'galley' type: #box 	                        height: (1 meter) width: (0.4 meters) length: galleyLength.	trailer position: galleyBulkhead above: deck.	trailer position: galleyBulkhead southOf: shower.	trailer position: galley above: deck.	trailer position: galley southOf: galleyBulkhead.	trailer position: galleyTable southOf: galleyBulkhead.	trailer position: galleyTable below: topSpace.		interiorLayer addParts: { galleyBulkhead. galley. galleyTable. }.		"Reset interior length"	interiorLength := bed length + bedWalkSpace length + eastCloset length 	                + shower length 	                + galleyBulkhead length + galley length.	"Transcript cr; show: 'testS425trailerExample'; cr; show: 'corrected interior length = ', interiorLength asString; cr."	self assert: (interiorLength >= (2.0 + 0.5 + 0.5 + 0.8 + (2*0.8) ) meters ).	"Correct south wall position"	trailer position: southWall southOf: deck.			! !!HumUserInterfaceTests methodsFor: 'HumAssembly tests' stamp: 'RichardAlexanderGreen 10/29/2014 22:25'!testS410x3dAssembly	"render the objects in HumAssembly"	| avatar head torso "upperArmLeft upperArmRight hips wheelLeft wheelRight" x3d file |	head := HumSolid id: #head type: #elipsoid height: 0.3 width: 0.2 depth: 0.2.	torso := HumSolid id: #torso type: #box height: 1.0 width: 0.5 depth: 0.3.	"upperArmLeft := HumSolid id: #upperArmLeft type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.		upperArmRight := HumSolid id: #upperArmRight type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.	hips := HumSolid id: #hips type: #box height: 0.25 width: 0.5 depth: 0.3.	wheelLeft := HumSolid id: #wheelLeft type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.	wheelRight := HumSolid id: wheelRight type: #elipsoid height: 0.5 width: 0.1 depth: 0.5."		"Assemble."	avatar := HumAssembly new.	avatar id: #avatar.	avatar position: head onTopOf: torso.	"Assume avatar is facing us."	"avatar position: upperArmLeft eastOf: torso.	avatar position: upperArmRight westOf: torso. 	avatar position: hips onBottomOf: torso.	avatar position: wheelLeft eastOf: hips.	avatar position: wheelRight westOf: hips."	"Color"	head color: ( Color paleBuff ).	torso color: ( Color green )."	upperArmLeft color: ( Color paleGreen ).		upperArmRight color: ( Color paleGreen ).	hips color: ( Color blue ).	wheelLeft color: ( Color paleBlue ).	wheelRight color: ( Color paleBlue )."	"render"	x3d := avatar asX3D.	"Transcript cr; show: 'testS410x3dAssembly'; cr; show: x3d; cr."		"Write code out to a file for easier inspection and possible compilation."	file := StandardFileStream fileNamed: 'testS410x3dAssembly.x3d'.	file nextPutAll: x3d.	file close.! !!HumUserInterfaceTests methodsFor: 'HumAssembly tests' stamp: 'RichardAlexanderGreen 10/22/2014 13:34'!buildTrailerAssembly	"Build trailer - to be used in other tests."	| trailer deckLayer wallLayer interiorLayer	   interiorLength interiorWidth interiorHeight 	   deck  deckThickness	  wallThickness wallHeight eastWall westWall northWall southWall 	  bed bedClearance bedWalkSpace 	  centerAisle eastCloset westCloset closetDepth 	  bulkheadWidth bulkheadThickness topSpace	  toilet handSink bathLength shower	  galleyBulkhead shoulderWidth galleyLength galley galleyTable	|	trailer := (HumAssembly new) id: 'trailer'.	deckLayer := (HumLayer new) id: 'deck layer'.	wallLayer := (HumLayer new) id: 'wall layer'.	interiorLayer := (HumLayer new) id: 'interior layer'.		"deck"	deckThickness   := 0.20 meters.	interiorLength  := 6.00 meters.	interiorWidth   := 2.00 meters.	interiorHeight  := 2.00 meters.		deck :=  HumSolid id: 'deck' type: #box height: deckThickness width: interiorWidth length: interiorLength.	deckLayer addPart: deck.  "walls"	wallThickness := 0.10 meters.	wallHeight    := 1.00 meters.	northWall := HumSolid id: 'northWall' type: #box height: wallHeight width: interiorWidth length: wallThickness.	southWall := HumSolid id: 'southWall' type: #box height: wallHeight width: interiorWidth length: wallThickness.	eastWall := HumSolid id: 'eastWall' type: #box height: wallHeight width: wallThickness length: interiorLength.	westWall := HumSolid id: 'westWall' type: #box height: wallHeight width: wallThickness length: interiorLength.	"Assembly deck and walls"	trailer position: northWall northOf: deck.	trailer position: southWall southOf: deck.	trailer position: eastWall eastOf: deck.	trailer position: westWall westOf: deck.	wallLayer addParts: { northWall. southWall. eastWall. westWall. }.	"======= bed room ========"	bed := HumSolid id: 'bed' type: #box height: (0.5 meters) width: (1.2 meters) length: (2.0 meters).	trailer position: bed northOf: southWall.	trailer position: bed onTopOf: deck.	bedClearance := 0.50 meters.	bedWalkSpace := HumSpace id: 'bedWalkSpace' height: interiorHeight width: interiorWidth length: bedClearance .	"closets"	closetDepth   := 0.50 meters.	bulkheadWidth := 0.70 meters.  eastCloset := HumSolid	id: 'eastCloset' type: #box height: interiorHeight width: bulkheadWidth length: closetDepth.	westCloset := HumSolid	id: 'westCloset' type: #box height: interiorHeight width: bulkheadWidth length: closetDepth.	centerAisle := HumSpace id: 'centerAisle' height: interiorHeight width: (interiorWidth - (bulkheadWidth*2.0)) length: interiorLength.	trailer center: centerAisle onTopOf: deck.  trailer position: bedWalkSpace northOf: bed.	trailer position: eastCloset eastOf: centerAisle.	trailer position: eastCloset northOf: bedWalkSpace.	trailer position: westCloset westOf: centerAisle.	trailer position: westCloset northOf: bedWalkSpace.	interiorLayer addParts: { bed. bedWalkSpace. eastCloset. westCloset. centerAisle. }. "bed room parts"	"======= bath room ==========="	bathLength := 1.0 meter.	toilet := HumSolid id: 'toilet' type: #box height: (0.40 meters) width: (0.20 meters) length: bathLength.	trailer position: toilet onTopOf: deck.	trailer position: toilet northOf: westCloset.	trailer position: toilet eastOf: westWall.	"Postion hand sink above toilet but below topSpace - top will be ~ 1 meter ~ 40 inches above floor"	handSink := HumSolid id: 'hand sink' type: #box height: (0.20 meters) width: (0.20 meters) length: bathLength.	topSpace := HumSpace id: 'top space' height: (interiorHeight / 2.0) width: interiorWidth length: interiorLength.	trailer center: topSpace over: deck.	trailer position: topSpace over: westWall.	trailer center: handSink above: toilet.	trailer position: handSink below: topSpace.	"Position shower by East wall (east of center aisle in bath roos)"	shower := HumSpace id: 'shower'  height: interiorHeight width: bulkheadWidth length: bathLength. 	trailer position: shower onTopOf: deck.	trailer position: shower westOf: eastWall.	trailer position: shower northOf: eastCloset.	interiorLayer addParts: { toilet. handSink. shower. }.		"======== galley =========="	bulkheadThickness := (0.04 meter).	galleyBulkhead := HumSolid id: 'galleyBulkhead' type: #box 	                           height: interiorHeight width: bulkheadWidth length: bulkheadThickness.	galleyLength := (0.50 meters) "space for 3-burner stove"	              + (1.20 meters) "space for kichen sink and food prep".	"Assure shoulder room at table" 	shoulderWidth := (0.80 meters).	( galleyLength < ( shoulderWidth * 2.0)  ) ifTrue: [ galleyLength := ( shoulderWidth * 2.0) ].   galleyTable := HumSolid id: 'galleyTable' type: #box                           height: (0.02 meters) width: (0.6 meter) length: galleyLength.	galley := HumSolid id: 'galley' type: #box 	                        height: (1 meter) width: (0.4 meters) length: galleyLength.	trailer position: galleyBulkhead above: deck.	trailer position: galleyBulkhead northOf: shower.	trailer position: galley above: deck.	trailer position: galley northOf: galleyBulkhead.	trailer position: galleyTable northOf: galleyBulkhead.	trailer position: galleyTable below: topSpace.		interiorLayer addParts: { galleyBulkhead. galley. galleyTable. }.		"Reset interior length"	interiorLength := bed length + bedWalkSpace length + eastCloset length 	                + shower length 	                + galleyBulkhead length + galley length.	"Transcript cr; show: 'buildTrailer'; cr; show: 'corrected interior length = ', interiorLength asString; cr."	self assert: (interiorLength >= (2.0 + 0.5 + 0.5 + 0.8 + (2*0.8) ) meters ).	"Correct south wall position"	deck length: interiorLength.	eastWall length: interiorLength.	westWall length: interiorLength.	trailer position: northWall northOf: deck.	
	^trailer.			! !!HumUserInterfaceTests methodsFor: 'HumAssembly tests' stamp: 'RichardAlexanderGreen 11/1/2014 14:51'!testS420trailerExample	"Test DSL usability - No code is generated by this test."	| trailer deckLayer wallLayer interiorLayer	   interiorLength interiorWidth interiorHeight 	   deck  deckThickness	  wallThickness wallHeight eastWall westWall northWall southWall 	  bed bedClearance bedWalkSpace 	  centerAisle eastCloset westCloset closetDepth 	  bulkheadWidth bulkheadThickness topSpace	  toilet handSink shower	  galleyBulkhead shoulderWidth galleyLength galley galleyTable	|	trailer := (HumAssembly new) id: 'trailer'.	deckLayer := (HumLayer new) id: 'deck layer'.	wallLayer := (HumLayer new) id: 'wall layer'.	interiorLayer := (HumLayer new) id: 'interior layer'.		"deck"	deckThickness   := 0.20 meters.	interiorLength  := 6.00 meters.	interiorWidth   := 2.00 meters.	interiorHeight  := 2.00 meters.		deck :=  HumSolid id: 'deck' type: #box height: deckThickness width: interiorWidth depth: interiorLength.	deckLayer addPart: deck.  "walls"	wallThickness := 0.10 meters.	wallHeight    := 1.00 meters.	northWall := HumSolid id: 'northWall' type: #box height: wallHeight width: interiorWidth depth: wallThickness.	southWall := HumSolid id: 'southWall' type: #box height: wallHeight width: interiorWidth depth: wallThickness.	eastWall := HumSolid id: 'eastWall' type: #box height: wallHeight width: wallThickness depth: interiorLength.	westWall := HumSolid id: 'westWall' type: #box height: wallHeight width: wallThickness depth: interiorLength.	"Assembly deck and walls"	trailer position: northWall northOf: deck.	trailer position: southWall southOf: deck.	trailer position: eastWall eastOf: deck.	trailer position: westWall westOf: deck.	wallLayer addParts: { northWall. southWall. eastWall. westWall. }.	"======= bed room ========"	bed := HumSolid id: 'bed' type: #box height: (0.5 meters) width: (1.2 meters) depth: (2.0 meters).	trailer position: bed southOf: northWall.	trailer position: bed onTopOf: deck.	bedClearance := 0.50 meters.	bedWalkSpace := HumSpace id: 'bedWalkSpace' height: interiorHeight width: interiorWidth depth: bedClearance .	"closets"	closetDepth   := 0.50 meters.	bulkheadWidth := 0.70 meters.  eastCloset := HumSolid	id: 'eastCloset' type: #box height: interiorHeight width: bulkheadWidth depth: closetDepth.	westCloset := HumSolid	id: 'westCloset' type: #box height: interiorHeight width: bulkheadWidth depth: closetDepth.	centerAisle := HumSpace id: 'centerAisle' height: interiorHeight width: (interiorWidth - (bulkheadWidth*2.0)) depth: interiorLength.	trailer center: centerAisle onTopOf: deck.  trailer position: bedWalkSpace southOf: bed.	trailer position: eastCloset eastOf: centerAisle.	trailer position: eastCloset southOf: bedWalkSpace.	trailer position: westCloset westOf: centerAisle.	trailer position: westCloset southOf: bedWalkSpace.	interiorLayer addParts: { bed. bedWalkSpace. eastCloset. westCloset. centerAisle. }. "bed room parts"	"======= bath room ==========="	toilet := HumSolid id: 'toilet' type: #box height: (0.40 meters) width: (0.20 meters) depth: (0.80 meters).	trailer position: toilet onTopOf: deck.	trailer position: toilet southOf: westCloset.	trailer position: toilet eastOf: westWall.	"Postion hand sink above toilet but below topSpace - top will be ~ 1 meter ~ 40 inches above floor"	handSink := HumSolid id: 'hand sink' type: #box height: (0.20 meters) width: (0.20 meters) depth: (0.80 meters).	topSpace := HumSpace id: 'top space' height: (interiorHeight / 2.0) width: interiorWidth depth: interiorLength.	trailer center: topSpace over: deck.	trailer position: topSpace over: westWall.	trailer center: handSink above: toilet.	trailer position: handSink below: topSpace.	"Position shower by East wall (east of center aisle in bath roos)"	shower := HumSpace id: 'shower'  height: interiorHeight width: bulkheadWidth depth: (0.80 meters). 	trailer position: shower onTopOf: deck.	trailer position: shower westOf: eastWall.	trailer position: shower southOf: eastCloset.	interiorLayer addParts: { toilet. handSink. shower. }.		"======== galley =========="	bulkheadThickness := (0.04 meter).	galleyBulkhead := HumSolid id: 'galleyBulkhead' type: #box 	                           height: interiorHeight width: bulkheadWidth depth: bulkheadThickness.	galleyLength := (0.50 meters) "space for 3-burner stove"	              + (1.20 meters) "space for kichen sink and food prep".	"Assure shoulder room at table" 	shoulderWidth := (0.80 meters).	( galleyLength < ( shoulderWidth * 2.0)  ) ifTrue: [ galleyLength := ( shoulderWidth * 2.0) ].   galleyTable := HumSolid id: 'galleyTable' type: #box                           height: (0.02 meters) width: (0.6 meter) depth: galleyLength.	galley := HumSolid id: 'galley' type: #box 	                        height: (1 meter) width: (0.4 meters) depth: galleyLength.	trailer position: galleyBulkhead above: deck.	trailer position: galleyBulkhead southOf: shower.	trailer position: galley above: deck.	trailer position: galley southOf: galleyBulkhead.	trailer position: galleyTable southOf: galleyBulkhead.	trailer position: galleyTable below: topSpace.		interiorLayer addParts: { galleyBulkhead. galley. galleyTable. }.		"Reset interior length"	interiorLength := bed depth + bedWalkSpace depth + eastCloset depth 	                + shower depth 	                + galleyBulkhead depth + galley depth.	"Transcript cr; show: 'testS420trailerExample'; cr; show: 'corrected interior length = ', interiorLength asString; cr."	self assert: (interiorLength >= (2.0 + 0.5 + 0.5 + 0.8 + (2*0.8) ) meters ).	"Correct south wall position"	trailer position: southWall southOf: deck.			! !!HumUserInterfaceTests methodsFor: 'HumAssembly tests' stamp: 'RichardAlexanderGreen 10/13/2014 11:55'!testS525solidAsThreeJS	"Render a box as a ThreeJS cube"	| solid js expect |	solid := HumSolid id: 'front wall' height: (3 meters) width: (0.1 meters) length: (4 meters).	solid color: (Color red).		js := solid asThreeJS.	expect := '			var frontWall = new THREE.Mesh( ( new THREE.CubeGeometry( 0.100, 4.000, 3.000 )  )			                            , ( new THREE.MeshBasicMaterial( { color: 0xff0000 } )  )			                            );			frontWall.position.set( 0.050, 2.000, 1.500 );	'.	self assert: expect equals: js.! !!HumUserInterfaceTests methodsFor: 'HumAssembly tests' stamp: 'RichardAlexanderGreen 12/24/2013 12:34'!testS540sceneAsThreeJS	"Render a box as a ThreeJS cube"	| scene js expect |	scene := self buildTrailerScene.	scene id: 'theScene'.		js := scene asThreeJS.
	"Expect this scene prolog"	expect := 'scene = new THREE.Scene();'.	self assert: ( ('*',expect,'*') match: js ).		"Expect this layer prolog. One of several like this."		expect := 'var wallLayer = new THREE.Geometry();'.	self assert: ( ('*',expect,'*') match: js ).	  "Expect this code fragment -- one of many like this."	expect := 'var southWall = new THREE.Mesh( ( new THREE.CubeGeometry( 2.000, 0.100, 1.000 )  )			                            , ( new THREE.MeshBasicMaterial( { color: 0x7f7f7f } )  )			                            );			southWall.position.set( 1.000, -0.050, 0.500 );				THREE.GeometryUtils.merge( wallLayer, southWall );'.	self assert: ( ('*',expect,'*') match: js ).	! !!HumUserInterfaceTests methodsFor: 'HumAssembly tests' stamp: 'RichardAlexanderGreen 12/24/2013 12:17'!testS510boxAsThreeJS	"Render a box as a ThreeJS cube"	| box js expect |	box := HumBox id: 'big box' height: (10 meters) width: (20 meters) length: (30 meters).	js := box asThreeJS.	expect := '			var bigBox = new THREE.Mesh( ( new THREE.CubeGeometry( 20.000, 30.000, 10.000   )  )			                            , ( new THREE.MeshBasicMaterial( { transparent: true } )  )			                            );			bigBox.position.set( 10.000, 15.000, 5.000 );'.	self assert: expect equals: js.! !!HumUserInterfaceTests methodsFor: 'HumAssembly tests' stamp: 'RichardAlexanderGreen 10/22/2014 13:34'!buildTrailerScene	"Build trailer scene - to be used in other tests."	|  trailer deckLayer wallLayer interiorLayer scene	   interiorLength interiorWidth interiorHeight 	   deck  deckThickness	  wallThickness wallHeight eastWall westWall northWall southWall 	  bed bedClearance bedWalkSpace 	  centerAisle eastCloset westCloset closetDepth 	  bulkheadWidth bulkheadThickness topSpace	  toilet handSink bathLength shower	  galleyBulkhead shoulderWidth galleyLength galley galleyTable	|	trailer := (HumAssembly new) id: 'trailer'.	deckLayer := (HumLayer new) id: 'deck layer'.	wallLayer := (HumLayer new) id: 'wall layer'.	interiorLayer := (HumLayer new) id: 'interior layer'.		"deck"	deckThickness   := 0.20 meters.	interiorLength  := 6.00 meters.	interiorWidth   := 2.00 meters.	interiorHeight  := 2.00 meters.		deck :=  HumSolid id: 'deck' type: #box height: deckThickness width: interiorWidth length: interiorLength.	deckLayer addPart: deck.  "walls"	wallThickness := 0.10 meters.	wallHeight    := 1.00 meters.	northWall := HumSolid id: 'northWall' type: #box height: wallHeight width: interiorWidth length: wallThickness.	southWall := HumSolid id: 'southWall' type: #box height: wallHeight width: interiorWidth length: wallThickness.	eastWall := HumSolid id: 'eastWall' type: #box height: wallHeight width: wallThickness length: interiorLength.	westWall := HumSolid id: 'westWall' type: #box height: wallHeight width: wallThickness length: interiorLength.	"Assembly deck and walls"	trailer position: northWall northOf: deck.	trailer position: southWall southOf: deck.	trailer position: eastWall eastOf: deck.	trailer position: westWall westOf: deck.	wallLayer addParts: { northWall. southWall. eastWall. westWall. }.	"======= bed room ========"	bed := HumSolid id: 'bed' type: #box height: (0.5 meters) width: (1.2 meters) length: (2.0 meters).	trailer position: bed northOf: southWall.	trailer position: bed onTopOf: deck.	bedClearance := 0.50 meters.	bedWalkSpace := HumSpace id: 'bedWalkSpace' height: interiorHeight width: interiorWidth length: bedClearance .	"closets"	closetDepth   := 0.50 meters.	bulkheadWidth := 0.70 meters.  eastCloset := HumSolid	id: 'eastCloset' type: #box height: interiorHeight width: bulkheadWidth length: closetDepth.	westCloset := HumSolid	id: 'westCloset' type: #box height: interiorHeight width: bulkheadWidth length: closetDepth.	centerAisle := HumSpace id: 'centerAisle' height: interiorHeight width: (interiorWidth - (bulkheadWidth*2.0)) length: interiorLength.	trailer center: centerAisle onTopOf: deck.  trailer position: bedWalkSpace northOf: bed.	trailer position: eastCloset eastOf: centerAisle.	trailer position: eastCloset northOf: bedWalkSpace.	trailer position: westCloset westOf: centerAisle.	trailer position: westCloset northOf: bedWalkSpace.	interiorLayer addParts: { bed. bedWalkSpace. eastCloset. westCloset. centerAisle. }. "bed room parts"	"======= bath room ==========="	bathLength := 1.0 meter.	toilet := HumSolid id: 'toilet' type: #box height: (0.40 meters) width: (0.20 meters) length: bathLength.	trailer position: toilet onTopOf: deck.	trailer position: toilet northOf: westCloset.	trailer position: toilet eastOf: westWall.	"Postion hand sink above toilet but below topSpace - top will be ~ 1 meter ~ 40 inches above floor"	handSink := HumSolid id: 'hand sink' type: #box height: (0.20 meters) width: (0.20 meters) length: bathLength.	topSpace := HumSpace id: 'top space' height: (interiorHeight / 2.0) width: interiorWidth length: interiorLength.	trailer center: topSpace over: deck.	trailer position: topSpace over: westWall.	trailer center: handSink above: toilet.	trailer position: handSink below: topSpace.	"Position shower by East wall (east of center aisle in bath roos)"	shower := HumSpace id: 'shower'  height: interiorHeight width: bulkheadWidth length: bathLength. 	trailer position: shower onTopOf: deck.	trailer position: shower westOf: eastWall.	trailer position: shower northOf: eastCloset.	interiorLayer addParts: { toilet. handSink. shower. }.		"======== galley =========="	bulkheadThickness := (0.04 meter).	galleyBulkhead := HumSolid id: 'galleyBulkhead' type: #box 	                           height: interiorHeight width: bulkheadWidth length: bulkheadThickness.	galleyLength := (0.50 meters) "space for 3-burner stove"	              + (1.20 meters) "space for kichen sink and food prep".	"Assure shoulder room at table" 	shoulderWidth := (0.80 meters).	( galleyLength < ( shoulderWidth * 2.0)  ) ifTrue: [ galleyLength := ( shoulderWidth * 2.0) ].   galleyTable := HumSolid id: 'galleyTable' type: #box                           height: (0.02 meters) width: (0.6 meter) length: galleyLength.	galley := HumSolid id: 'galley' type: #box 	                        height: (1 meter) width: (0.4 meters) length: galleyLength.	trailer position: galleyBulkhead above: deck.	trailer position: galleyBulkhead northOf: shower.	trailer position: galley above: deck.	trailer position: galley northOf: galleyBulkhead.	trailer position: galleyTable northOf: galleyBulkhead.	trailer position: galleyTable below: topSpace.		interiorLayer addParts: { galleyBulkhead. galley. galleyTable. }.		"Reset interior length"	interiorLength := bed length + bedWalkSpace length + eastCloset length 	                + shower length 	                + galleyBulkhead length + galley length.	"Transcript cr; show: 'buildTrailer'; cr; show: 'corrected interior length = ', interiorLength asString; cr."	self assert: (interiorLength >= (2.0 + 0.5 + 0.5 + 0.8 + (2*0.8) ) meters ).	"Correct south wall position"	deck length: interiorLength.	eastWall length: interiorLength.	westWall length: interiorLength.	trailer position: northWall northOf: deck.		scene := HumScene new.	scene addParts: { deckLayer. wallLayer. interiorLayer. }.
	^scene.			! !!HumUserInterfaceTests methodsFor: 'HumAssembly tests' stamp: 'RichardAlexanderGreen 11/1/2014 14:52'!testS430showTrailerLayoutTable	"Display a table of the trailer parts edges.	... Testing HumSolid layout positioning.	"	| trailer |		false ifFalse: [ Transcript cr; show: 'testS430showTrailerLayoutTable is turned off';cr. ^self.].	trailer := self buildTrailerAssembly.	"table heading"	Transcript cr; show: ''; cr.	Transcript show: ('id' padded: #left to: 16 with: $.), ' north-south'; cr.	"table rows"	(trailer parts)		do: [ :part | "for each part:"			Transcript show: ((part id) padded: #left to: 16 with: $.  )			               , String tab, (part mm: #southEdge)			               , String tab, (part mm: #northEdge); 			             cr.			].! !!HumUserInterfaceTests methodsFor: 'HumAssembly tests' stamp: 'RichardAlexanderGreen 12/24/2013 11:47'!testS530assemblyAsThreeJS	"Render a box as a ThreeJS cube"	| assembly js expect |	assembly := self buildTrailerAssembly.		js := assembly asThreeJS.		"Expect this prolog."		expect := 'var trailer = new THREE.Geometry();'.	self assert: ( ('*',expect,'*') match: js ).	  "Expect this code fragment -- one of many like this."	expect := 'var southWall = new THREE.Mesh( ( new THREE.CubeGeometry( 2.000, 0.100, 1.000 )  )			                            , ( new THREE.MeshBasicMaterial( { color: 0x7f7f7f } )  )			                            );			southWall.position.set( 1.000, -0.050, 0.500 );				THREE.GeometryUtils.merge( trailer, southWall );'.	self assert: ( ('*',expect,'*') match: js ).	! !!HumUserInterfaceTests methodsFor: 'HumText tests' stamp: 'RichardAlexanderGreen 10/13/2014 12:00'!testT110initialTextHasOneEmptyLine	"When it is initialized, there is one empty line.	"	| text |		"Initial position of the cursor is line 1, column 1"	text := HumText new.	self for: ( text lines size ) expect: 1.	self for: ( text string ) expect:  ('',String cr).! !!HumUserInterfaceTests methodsFor: 'HumText tests' stamp: 'RichardAlexanderGreen 10/13/2014 12:01'!testT115initialTextCopyHasOneEmptyLine	"When it is initialized, there is one empty line.	"	| text textCopy |	"Initial position of the cursor is line 1, column 1"	text := HumText new.	textCopy := text copy.	self for: ( textCopy lines size ) expect: 1.	self for: ( textCopy string ) expect:  ('',String cr).! !!HumUserInterfaceTests methodsFor: 'HumDiagramTests' stamp: 'RichardAlexanderGreen 6/23/2014 13:53'!testD220LayoutDiagram	"Create a diagram with four nodes and three connections."	| diagram nodeA nodeB nodeC nodeD |	diagram := HumDiagram new.	nodeA := HumEntity title: 'A'.	nodeB := HumEntity title: 'B'.	nodeC := HumEntity title: 'C'.	nodeD := HumEntity title: 'D'.		diagram 		addNode: nodeA;		addNode: nodeB;		addNode: nodeC.			self assert: ( diagram nodes size = 3 ).		diagram		addConnection: ( nodeA -> nodeB );		addConnection: ( nodeB -> nodeC );		addConnection: ( nodeB -> nodeD ).  "Fan-out downstream from B"		  self assert: ( diagram connections size = 3 ).  "Layout the diagram."	diagram layoutDiagramWithNodeExtent: (16@8) nodeSpacing: (4@4).	self assert: ( diagram mapNodePosition size = 4 ).	self assert: ( diagram mapPositionNode size = 4 ).				! !!HumUserInterfaceTests methodsFor: 'HumDiagramTests' stamp: 'RichardAlexanderGreen 4/17/2013 09:58'!assert: x equals: a or: b	self assert: (( x = a ) or: [x = b]).! !!HumUserInterfaceTests methodsFor: 'HumDiagramTests' stamp: 'RichardAlexanderGreen 4/18/2013 10:41'!testD321EnergyBetweenNodes	"Calculate the (layout) force between two nodes."	| diagram nodeA nodeB nodeC forceA forceB |	diagram := HumDiagram new.	nodeA := HumEntity title: 'A'.	nodeB := HumEntity title: 'B'.	nodeC := HumEntity title: 'C'.		diagram 		addNode: nodeA;		addNode: nodeB;		addNode: nodeC.			self assert: ( diagram nodes size = 3 ).		diagram		addConnection: ( nodeA -> nodeB ).		";		addConnection: ( nodeB -> nodeC );		addConnection: ( nodeA -> nodeC ).		"  self assert: ( diagram connections size = 1 ).	"Force the layout to make this test easier"	diagram setNode: nodeA position: (0@0).	diagram setNode: nodeB position: (2@0).		forceA := diagram layoutEnergyOnNode: nodeA fromNode: nodeB.	forceB := diagram layoutEnergyOnNode: nodeB fromNode: nodeA.		self assert: ( forceA = forceB ).	self assert: ( forceA >= 0 ).								! !!HumUserInterfaceTests methodsFor: 'HumDiagramTests' stamp: 'RichardAlexanderGreen 4/13/2013 08:54'!testD110CreateDiagram	"Create a diagram with three nodes and two connections."	| diagram nodeA nodeB nodeC |	diagram := HumDiagram new.	nodeA := HumEntity title: 'A'.	nodeB := HumEntity title: 'B'.	nodeC := HumEntity title: 'C'.		diagram 		addNode: nodeA;		addNode: nodeB;		addNode: nodeC.			self assert: ( diagram nodes size = 3 ).		diagram		addConnection: ( nodeA -> nodeB );		addConnection: ( nodeB -> nodeC ).		  self assert: ( diagram connections size = 2 ).				! !!HumUserInterfaceTests methodsFor: 'HumDiagramTests' stamp: 'RichardAlexanderGreen 6/23/2014 13:53'!testD210LayoutDiagram	"Create a diagram with three nodes and two connections."	| diagram nodeA nodeB nodeC |	diagram := HumDiagram new.	nodeA := HumEntity title: 'A'.	nodeB := HumEntity title: 'B'.	nodeC := HumEntity title: 'C'.		diagram 		addNode: nodeA;		addNode: nodeB;		addNode: nodeC.			self assert: ( diagram nodes size = 3 ).		diagram		addConnection: ( nodeA -> nodeB );		addConnection: ( nodeB -> nodeC ).		  self assert: ( diagram connections size = 2 ).  "Layout the diagram."	diagram layoutDiagramWithNodeExtent: (16@8) nodeSpacing: (4@4).	self assert: ( diagram mapNodePosition size = 3 ).	self assert: ( diagram mapPositionNode size = 3 ).				! !!HumUserInterfaceTests methodsFor: 'HumDiagramTests' stamp: 'RichardAlexanderGreen 6/23/2014 13:53'!testD230LayoutDiagram	"Create a diagram with five nodes and four connections."	| diagram nodeA1 nodeA2 nodeB nodeC nodeD |	diagram := HumDiagram new.	nodeA1 := HumEntity title: 'A1'.	nodeA2 := HumEntity title: 'A2'.	nodeB := HumEntity title: 'B'.	nodeC := HumEntity title: 'C'.	nodeD := HumEntity title: 'D'.		diagram 		addNode: nodeA1;		addNode: nodeA2;		addNode: nodeB;		addNode: nodeC;		addNode: nodeD.			self assert: ( diagram nodes size = 5 ).		diagram		addConnection: ( nodeA1 -> nodeB );		addConnection: ( nodeA2 -> nodeB ); "Fan-in upstream from B"		addConnection: ( nodeB -> nodeC );		addConnection: ( nodeB -> nodeD ).  "Fan-out downstream from B"		  self assert: ( diagram connections size = 4 ).  "Layout the diagram."	diagram layoutDiagramWithNodeExtent: (16@8) nodeSpacing: (4@4).	self assert: ( diagram mapNodePosition size = 5 ).	self assert: ( diagram mapPositionNode size = 5 ).		self assert: (( diagram mapNodePosition ) at: nodeB) equals: ( 0@0 ).						"Note nodeC and nodeD will be assigned 12@0 or 12@8. But the choice may be random."			self assert: (( diagram mapNodePosition ) at: nodeC) equals: (12@0) or: (12@8).	self assert: (( diagram mapNodePosition ) at: nodeD) equals: (12@0) or: (12@8).	self assert: (( diagram mapNodePosition ) at: nodeC) ~= (( diagram mapNodePosition ) at: nodeD).		"Note nodeC and nodeD will be assigned -12@0 or -12@8. But the choice may be random."			self assert: (( diagram mapNodePosition ) at: nodeA1) equals: (-12@0) or: (-12@8).	self assert: (( diagram mapNodePosition ) at: nodeA2) equals: (-12@0) or: (-12@8).	self assert: (( diagram mapNodePosition ) at: nodeA1) ~= (( diagram mapNodePosition ) at: nodeA2).					"diagram inspect."		! !!HumUserInterfaceTests methodsFor: 'HumDiagramTests' stamp: 'RichardAlexanderGreen 4/17/2013 11:00'!testD310DistanceBetweenNodes	"Calculate the (layout) distance between two nodes."	| diagram nodeA nodeB nodeC distance |	diagram := HumDiagram new.	nodeA := HumEntity title: 'A'.	nodeB := HumEntity title: 'B'.	nodeC := HumEntity title: 'C'.		diagram 		addNode: nodeA;		addNode: nodeB;		addNode: nodeC.			self assert: ( diagram nodes size = 3 ).		diagram		addConnection: ( nodeA -> nodeB );		addConnection: ( nodeB -> nodeC );		addConnection: ( nodeA -> nodeC ).		  self assert: ( diagram connections size = 3 ).	"Force the layout 3-4-5 triangle to make this test easier"	diagram setNode: nodeA position: (0@0).	diagram setNode: nodeB position: (40@0).	diagram setNode: nodeC position: (40@30).		"The distance from nodeA to nodeC should be 50."	distance := diagram layoutDistanceFromNode: nodeA toNode: nodeC.	self assert: distance equals: 50.					! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 12/12/2013 16:08'!test340spaceLayout	"HumAssembly may position its parts relative to itself and each other."	| container spaceA spaceB |		""	container := HumAssembly new.	container length: 100 meter; width: 100 meter; height: 100 meter.		spaceA :=( HumSpace new ) length: 10 meter; width: 10 meter; height: 10 meter.	spaceB :=( HumSpace new ) length: 10 meter; width: 10 meter; height: 10 meter.		container center: spaceA at: { 20 meter. 30 meter. 50 meter. }.	self assert: ( spaceA eastEdge = 25 meter).	self assert: ( spaceA northEdge = 35 meter ).	self assert: ( spaceA bottomEdge = 45 meter ).		self assert: ( spaceA westEdge = 15 meter ).	self assert: ( spaceA southEdge = 25 meter ).	self assert: ( spaceA topEdge = 55 meter ).		"Place B on top of A."	container position: spaceB onTopOf: spaceA.	self assert: ( spaceB bottomEdge ) = ( spaceA topEdge ).		"Place B under A."	container position: spaceB onBottomOf: spaceA.	self assert: ( spaceB topEdge ) = ( spaceA bottomEdge ).		"Place B on East side of A."	container position: spaceB eastOf: spaceA.	self assert: ( spaceB westEdge ) = ( spaceA eastEdge ).		"Place B on West side of A."	container position: spaceB westOf: spaceA.	self assert: ( spaceB eastEdge ) = ( spaceA westEdge ).		"Place B on North side of A."	container position: spaceB northOf: spaceA.	self assert: ( spaceB southEdge ) = ( spaceA northEdge ).		"Place B on South side  of A."	container position: spaceB southOf: spaceA.	self assert: ( spaceB northEdge ) = ( spaceA southEdge ).		! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 8/18/2013 21:16'!test220boxSizeIsDurable	"A box is initialized with a origin object which is zero-sized and at 0,0."	| box |	box := HumBox new.	box width: 1 meter; height: 1 meter; length: 1 meter.	"Bump box over to the the East by pushing on the West edge."	box westEdge: 1 meter.	self assert: ( box eastEdge = 2 meter ).	"Bump box up."	box topEdge: 3 meter. 	self assert: ( box bottomEdge = 2 meter ).	"Bump box from bottom."	box bottomEdge: 3 meter.	self assert: ( box topEdge = 4 meter).	"Pull box via the East edge."	box eastEdge: 5 meter.	self assert: ( box westEdge = 4 meter ).	"Bump box to the South by pushing on the North edge."	box northEdge: 7 meter.	self assert: ( box southEdge = 6 meter ).	"Pull box to the South by pulling on the South edge."	box southEdge: -2 meter.	self assert: ( box northEdge = -1 meter ).! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 8/18/2013 21:22'!test320spaceSizeIsDurable	"A space is initialized with a origin object which is zero-sized and at 0,0."	| space |	space := HumSpace new.	space width: 1 meter; height: 1 meter; length: 1 meter.	"Bump space over to the the East by pushing on the West edge."	space westEdge: 1 meter.	self assert: ( space eastEdge = 2 meter ).	"Bump space up."	space topEdge: 3 meter.	self assert: ( space bottomEdge = 2 meter ).	"Bump space from bottom."	space bottomEdge: 3 meter.	self assert: ( space topEdge = 4 meter ).	"Pull space via the East edge."	space eastEdge: 5 meter.	self assert: ( space westEdge = 4 meter ).	"Bump space to the South by pushing on the North edge."	space northEdge: 7 meter.	self assert: ( space southEdge = 6 meter ).	"Pull space to the South by pulling on the South edge."	space southEdge: -2 meter.	self assert: ( space northEdge = -1 meter ).! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 12/12/2013 16:06'!test330spaceContainer	"HumAssembly may contain other spaces."	| container box  |		""	container := HumAssembly new.	container length: 100 meter; width: 100 meter; height: 100 meter.	container bottomEdge: 1000 meter; westEdge: 2000 meter; southEdge: 3000 meter.		box :=( HumBox new ) length: 10 meter; width: 10 meter; height: 10 meter.		container center: box at: { 20 meter. 30 meter. 50 meter. }.	"Note: These box positions are relative to the container`s edges."	self assert: ( box eastEdge = 25 meter ).	self assert: ( box northEdge = 35 meter ).	self assert: ( box bottomEdge = 45 meter ).! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 8/18/2013 21:21'!test310spaceHasOrigin	"A space is initialized with a origin object which is zero-sized and at 0,0."	| space zero |	zero := 0 meter.	space := HumSpace new.	self assert: ( space origin height = zero ).	self assert: ( space origin width = zero ).	self assert: ( space origin length = zero ).		self assert: ( space origin westEdge = zero ).	self assert: ( space origin eastEdge = zero ).		self assert: ( space origin northEdge = zero ).		self assert: ( space origin southEdge = zero ).		self assert: ( space origin topEdge = zero ).		self assert: ( space origin bottomEdge = zero ).! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 12/5/2013 08:15'!test250boxCentering	"Spaces may contain other spaces. Spaces are container-like."	| container boxA boxB |		"Default unit of measure is meter."	container := HumAssembly new.	container length: 100; width: 100; height: 100.		boxA :=( HumBox new ) length: 20; width: 20; height: 20.	boxB :=( HumBox new ) length: 10; width: 10; height: 10.		"Center B on top of A."	container center: boxB onTopOf: boxA.	self assert: ( boxB center at: 1) = ( boxA center at: 1 ).	self assert: ( boxB center at: 2 ) = (  boxA center at: 2 ).	self assert: ( boxB bottomEdge ) = (  boxA topEdge ).! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 12/5/2013 08:15'!test240boxLayout	"Spaces may contain other spaces. Spaces are container-like."	| container boxA boxB |		""	container := HumAssembly new.	container length: 100 meter; width: 100 meter; height: 100 meter.		boxA :=( HumBox new ) length: 10 meter; width: 10 meter; height: 10 meter.	boxB :=( HumBox new ) length: 10 meter; width: 10 meter; height: 10 meter.		container center: boxA at: { 20 meter. 30 meter. 50 meter. }.	self assert: ( boxA eastEdge = 25 meter ).	self assert: ( boxA northEdge = 35 meter ).	self assert: ( boxA bottomEdge = 45 meter ).		self assert: ( boxA westEdge = 15 meter ).	self assert: ( boxA southEdge = 25 meter ).	self assert: ( boxA topEdge = 55 meter ).		"Place B on top of A."	container position: boxB onTopOf: boxA.	self assert: ( boxB bottomEdge ) = ( boxA topEdge ).		"Place B under A."	container position: boxB onBottomOf: boxA.	self assert: ( boxB topEdge ) = ( boxA bottomEdge ).		"Place B on East side of A."	container position: boxB eastOf: boxA.	self assert: ( boxB westEdge ) = ( boxA eastEdge ).		"Place B on West side of A."	container position: boxB westOf: boxA.	self assert: ( boxB eastEdge ) = ( boxA westEdge ).		"Place B on North side of A."	container position: boxB northOf: boxA.	self assert: ( boxB southEdge ) = ( boxA northEdge ).		"Place B on South side  of A."	container position: boxB southOf: boxA.	self assert: ( boxB northEdge ) = ( boxA southEdge ).		! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 12/10/2013 13:59'!test230boxIsAContainer	"Spaces may contain other spaces. Spaces are container-like."	| container box  |		""	container := HumAssembly new.	container length: 100 meter; width: 100 meter; height: 100 meter.		box :=( HumAssembly new ) length: 10 meter; width: 10 meter; height: 10 meter.		container center: box at: { 20 meter. 30 meter. 50 meter. }.		self assert: (container parts includes: box).	self assert: ( box eastEdge = 25 meter ).	self assert: ( box northEdge = 35 meter ).	self assert: ( box bottomEdge = 45 meter ).! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 8/18/2013 21:14'!test210boxHasOrigin	"A box is initialized with a origin object which is zero-sized and at 0,0."	| box zero |	zero := 0 meter.	box := HumBox new.	self assert: ( box origin height = zero ).	self assert: ( box origin width = zero ).	self assert: ( box origin length = zero ).		self assert: ( box origin westEdge = zero ).	self assert: ( box origin eastEdge = zero ).		self assert: ( box origin northEdge = zero ).		self assert: ( box origin southEdge = zero ).		self assert: ( box origin topEdge = zero ).		self assert: ( box origin bottomEdge = zero ).! !!HumUserInterfaceTests methodsFor: 'HumSpace tests' stamp: 'RichardAlexanderGreen 12/12/2013 16:35'!test350assemblyDimensions	"A HumAssembly dimensions enclose whatever is inside the assembly"	| container spaceA spaceB |		""	container := HumAssembly new.	container length: 100 meter; width: 100 meter; height: 100 meter.		spaceA :=( HumSpace new ) length: 10 meter; width: 10 meter; height: 10 meter.	spaceB :=( HumSpace new ) length: 10 meter; width: 10 meter; height: 10 meter.		"Note: These positions are relative to the container`s origin."	container center: spaceA at: { 20 meter. 30 meter. 50 meter. }.	self assert: ( spaceA eastEdge = 25 meter).	self assert: ( spaceA northEdge = 35 meter ).	self assert: ( spaceA bottomEdge = 45 meter ).		self assert: ( spaceA westEdge = 15 meter ).	self assert: ( spaceA southEdge = 25 meter ).	self assert: ( spaceA topEdge = 55 meter ).		"Place B on top of A."	container position: spaceB onTopOf: spaceA.	self assert: ( spaceB bottomEdge ) = ( spaceA topEdge ).	self assert: ( container bottomEdge ) < ( spaceA bottomEdge ).	self assert: ( container topEdge ) > ( spaceB topEdge ).		"Place B under A."	container position: spaceB onBottomOf: spaceA.	self assert: ( spaceB topEdge ) = ( spaceA bottomEdge ).		"Place B on East side of A."	container position: spaceB eastOf: spaceA.	self assert: ( spaceB westEdge ) = ( spaceA eastEdge ).		"Place B on West side of A."	container position: spaceB westOf: spaceA.	self assert: ( spaceB eastEdge ) = ( spaceA westEdge ).		"Place B on North side of A."	container position: spaceB northOf: spaceA.	self assert: ( spaceB southEdge ) = ( spaceA northEdge ).		"Place B on South side  of A."	container position: spaceB southOf: spaceA.	self assert: ( spaceB northEdge ) = ( spaceA southEdge ).		! !!HumUserInterfaceTests methodsFor: 'HumSolid tests' stamp: 'RichardAlexanderGreen 12/12/2013 15:46'!testS220x3dExtent	"Produce a x3d box extent from my length width height"	| box result |	box := HumBox new.	box length: 10.0; width: 20.0; height: 30.0.	result := box x3dExtent.		self assert: '20.000 10.000 30.000' equals: result.! !!HumUserInterfaceTests methodsFor: 'HumSolid tests' stamp: 'RichardAlexanderGreen 12/12/2013 15:42'!testS110assembleAvatar	"Create example to indicate development idea/s."	| avatar head torso upperArmLeft upperArmRight hips wheelLeft wheelRight |	head := HumSolid id: '' type: #elipsoid height: 0.3 width: 0.2 depth: 0.2.	torso := HumSolid id: '' type: #box height: 1.0 width: 0.5 depth: 0.3.	upperArmLeft := HumSolid id: '' type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.		upperArmRight := HumSolid id: 'upperArmRight'type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.	hips := HumSolid id: '' type: #box height: 0.25 width: 0.6 depth: 0.3.	wheelLeft := HumSolid id: '' type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.	wheelRight := HumSolid id: '' type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.		"Assemble."	avatar := HumAssembly new.	avatar center: head onTopOf: torso.	avatar position: upperArmLeft eastOf: torso. "Assume avatar is facing us."	avatar position: upperArmRight westOf: torso. "Assume avatar is facing us."	avatar position: hips onBottomOf: torso.	avatar position: wheelLeft eastOf: hips.	avatar position: wheelRight westOf: hips.	"Assert some expectations"	self assert: ( head bottomEdge closeTo: torso topEdge ) .  "Got a funky round-off error on this, but not on others."	self assert: ( hips topEdge = torso bottomEdge ).	self assert: ( wheelLeft westEdge = hips eastEdge ).		self assert: ( wheelRight eastEdge = hips westEdge ).	self assert: ( upperArmLeft westEdge = torso eastEdge ).	self assert: ( upperArmRight eastEdge = torso westEdge ).	"Head is centered. So edges are inboard from torso."	self assert: ( head eastEdge = torso eastEdge ) not. 	self assert:  ( head westEdge = torso westEdge ) not.	"But some things were not constrained. So set those also."	upperArmLeft  topEdge: ( torso topEdge ).	upperArmRight topEdge: ( torso topEdge ).	wheelLeft  topEdge: ( hips topEdge ).	wheelRight topEdge: ( hips topEdge ).	"TODO: Check that constraints are effective."				! !!HumUserInterfaceTests methodsFor: 'HumSolid tests' stamp: 'RichardAlexanderGreen 4/20/2015 09:47'!testS320x3dShape	"Produce a x3d box extent from my length width height"	| box result expect |	box := HumSolid new.	box id: 'BOX1'; length: 10.0; width: 20.0; height: 30.0; color: (Color red).	result := box x3dShape.	expect := '	 <Transform translation="10.0 5.0 15.0">			<Shape>				<Appearance>					<Material diffuseColor="1.00 0.00 0.00" specularColor="0.5 0.5 0.5"/>				</Appearance>				<Box DEF="NONE" id="BOX1" size="20.000 10.000 30.000"/>			</Shape>		</Transform>				'.	self assert: (HumCalculator string: expect isLike: result).! !!HumUserInterfaceTests methodsFor: 'HumSolid tests' stamp: 'RichardAlexanderGreen 4/20/2015 09:47'!testS520ThreeJSBox	"Produce a Three.js cube with my length width height and position"	| box result expect |	box := HumSolid new.	box id: 'box102030'; length: 10.0; width: 20.0; height: 30.0; color: (Color green).	result := box asThreeJS.	expect := '			var box102030 = new THREE.Mesh( ( new THREE.CubeGeometry( 20.000, 10.000, 30.000   )  )			                            , ( new THREE.MeshBasicMaterial( { color: 0x00ff00 } )  )			                            );			box102030.position.set( 10.000, 5.000, 15.000 );	'.	self assert: ( HumCalculator string:  expect isLike: result ).! !!HumUserInterfaceTests methodsFor: 'HumSolid tests' stamp: 'RichardAlexanderGreen 12/12/2013 15:39'!testS120colorAvatar	"Create example to indicate development idea/s."	| avatar head torso upperArmLeft upperArmRight hips wheelLeft wheelRight |	head := HumSolid id: '' type: #elipsoid height: 0.3 width: 0.2 depth: 0.2.	torso := HumSolid id: '' type: #box height: 1.0 width: 0.5 depth: 0.3.	upperArmLeft := HumSolid id: '' type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.		upperArmRight := HumSolid id: '' type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.	hips := HumSolid id: '' type: #box height: 0.25 width: 0.5 depth: 0.3.	wheelLeft := HumSolid id: '' type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.	wheelRight := HumSolid id: '' type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.		"Assemble."	avatar := HumAssembly new.	avatar position: head onTopOf: torso.	avatar position: upperArmLeft eastOf: torso. "Assume avatar is facing us."	avatar position: upperArmRight westOf: torso. "Assume avatar is facing us."	avatar position: hips onBottomOf: torso.	avatar position: wheelLeft eastOf: hips.	avatar position: wheelRight westOf: hips.	"Color"	head color: ( Color paleBuff ).	torso color: ( Color green ).	upperArmLeft color: ( Color paleGreen ).		upperArmRight color: ( Color paleGreen ).	hips color: ( Color blue ).	wheelLeft color: ( Color paleBlue ).	wheelRight color: ( Color paleBlue ).	"This is a usability test. Does it pass?"	! !!HumUserInterfaceTests methodsFor: 'HumSolid tests' stamp: 'RichardAlexanderGreen 10/29/2014 17:10'!testS200x3dReadMe	"X3D is a direct superset of VRML (It supercedes VRML97 as a standard.).	X3D is relatively well supported.	X3D can run in a browser as part of a DOM.	TODO: X3D is my preferred target language for 3D visualization.		TODO: Add X3D web page preamble feature to HumScene.	"! !!HumUserInterfaceTests methodsFor: 'HumSolid tests' stamp: 'RichardAlexanderGreen 10/22/2014 13:22'!testS620VPythonPreamble	"Produce a general purpose VPython scene preamble "	| scene result expected |	scene := HumScene new.	self assert: (scene isKindOf: HumScene).	result := scene asVPythonPreamble.	expected := 'from visual import *import Thingfrom Thing import BoxThingfrom Thing import PipeThing# Set window attributesscene.width=800scene.height=800scene.title="Scene Title"scene.background = ( 0.7, 0.7, 0.7 )# Set camera/viewport attributesscene.autoscale = Truescene.center = ( 4*12, 13*12, 4*12 )scene.up = ( 0, 0, 1 )'.	self expect: expected actual: result.	! !!HumUserInterfaceTests methodsFor: 'HumSolid tests' stamp: 'RichardAlexanderGreen 1/19/2015 09:44'!testS615VPythonSpace	"Produce a VPython Thing.py box with my length width height and position, but not visible"	| box result expected |	box := HumSpace new.	box id: 'space102030'; length: 10.0; width: 20.0; height: 30.0.	result := box asVPythonThing.	expected := 'space102030 = BoxThing( label = "space102030", length = 10.000, width = 20.000, height = 30.000, visible = false )'.	self expect: expected actual: result.! !!HumUserInterfaceTests methodsFor: 'HumSolid tests' stamp: 'RichardAlexanderGreen 12/12/2013 15:40'!testS115assembleAvatarBottomUp	"Create example to indicate development idea/s."	| avatar head torso upperArmLeft upperArmRight hips wheelLeft wheelRight |	head := HumSolid id: '' type: #elipsoid height: 0.3 width: 0.2 depth: 0.2.	torso := HumSolid id: '' type: #box height: 1.0 width: 0.5 depth: 0.3.	upperArmLeft := HumSolid id: '' type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.		upperArmRight := HumSolid id: '' type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.	hips := HumSolid id: '' type: #box height: 0.25 width: 0.6 depth: 0.3.	wheelLeft := HumSolid id: '' type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.	wheelRight := HumSolid id: '' type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.		"Position and assemble the avatar."	avatar := HumAssembly new.	wheelLeft bottomEdge: 0.	wheelRight bottomEdge: 0.	hips topEdge: ( wheelLeft topEdge ).	"HumAssembly #position: . . . methods also add mentioned objects to the container/assembly."	avatar position: wheelLeft eastOf: hips.	avatar position: wheelRight westOf: hips.	avatar center: torso onTopOf: hips.	avatar center: head onTopOf: torso.	avatar position: upperArmLeft eastOf: torso. "Assume avatar is facing us."	avatar position: upperArmRight westOf: torso. "Assume avatar is facing us."	"Assert some expectations"	self assert: ( head bottomEdge closeTo: torso topEdge ) .  "Got a funky round-off error on this, but not on others."	self assert: ( hips topEdge = torso bottomEdge ).	self assert: ( wheelLeft westEdge = hips eastEdge ).		self assert: ( wheelRight eastEdge = hips westEdge ).	self assert: ( upperArmLeft westEdge = torso eastEdge ).	self assert: ( upperArmRight eastEdge = torso westEdge ).	"Head is centered. So edges are inboard from torso."	self assert: ( head eastEdge = torso eastEdge ) not. 	self assert:  ( head westEdge = torso westEdge ) not.	"But some things were not constrained. So set those also."	upperArmLeft topEdge: ( torso topEdge ).	upperArmRight topEdge: ( torso topEdge ).	wheelLeft topEdge: ( hips topEdge ).	wheelRight topEdge: ( hips topEdge ).	"This is a usability test. Does it pass?"				! !!HumUserInterfaceTests methodsFor: 'HumSolid tests' stamp: 'RichardAlexanderGreen 10/29/2014 12:04'!test600VPythonReadMe	"I started this when my VPython environment started working again.	However, it immediately stopped working after downloading something else Python related.	I've given up on VPython as a target language!!		The X3D (markup language) has better support, is a standard of sorts, VRML descendent.	I will refocus my 3D efforts on X3D.	"! !!HumUserInterfaceTests methodsFor: 'HumSolid tests' stamp: 'RichardAlexanderGreen 12/5/2013 11:23'!testS230x3dCenter		"Produce a x3d box position from my length width height (and default position)"	| box result |	box := HumBox new.	box length: 10.0; width: 20.0; height: 30.0.	result := box x3dCenter.		self assert: '10.0 5.0 15.0' equals: result.! !!HumUserInterfaceTests methodsFor: 'HumSolid tests' stamp: 'RichardAlexanderGreen 12/10/2013 12:53'!testS210x3dColor	"HumSolid x3dColor should produce a X3D color string"	| solid colorString |	solid := HumSolid new.	solid color: Color red.	colorString := solid x3dColor.	self assert: (colorString = '1.00 0.00 0.00').! !!HumUserInterfaceTests methodsFor: 'HumSolid tests' stamp: 'RichardAlexanderGreen 1/19/2015 09:39'!testS610VPythonThing	"Produce a VPython Thing.py box with my length width height and position"	| box result expected |	box := HumSolid new.	box id: 'box102030'; length: 10.0; width: 20.0; height: 30.0; color: (Color green).	result := box asVPythonThing.	expected := 'box102030 = BoxThing( label = "box102030", length = 10.000, width = 20.000, height = 30.000, aColor = color.green )'.	self expect: expected actual: result.! !!HumUserInterfaceTests methodsFor: 'HumSolid tests' stamp: 'RichardAlexanderGreen 4/20/2015 09:46'!testS310x3dMaterial	"HumSolid x3dMaterial should produce a X3D xml string"	| solid colorString expect result |	solid := HumSolid new.	solid color: Color red.	colorString := solid x3dColor.	self assert: (colorString = '1.00 0.00 0.00').	expect := '<material color="1.00 0.00 0.00 1.00" />	'.  result := solid x3dMaterial.  self assert: (HumCalculator string: result isLike: expect).! !!HumUserInterfaceTests methodsFor: 'HumSolid tests' stamp: 'RichardAlexanderGreen 10/13/2014 11:53'!testS505ThreeJSColor	"HumSolid three.js needs HTML color string"	| solid colorString |	solid := HumSolid new.	solid color: Color green.	colorString := solid color printHtmlString.	self assert: (colorString = '00FF00').! !!HumUserInterfaceTests methodsFor: 'asserting' stamp: 'RichardAlexanderGreen 3/14/2012 20:53'!expect: actualValue is: expectedValue 	""	^ self		assert: ( actualValue = expectedValue)		description: ( self comparingStringBetween: expectedValue and: actualValue ).! !!HumUserInterfaceTests methodsFor: 'asserting' stamp: 'RichardAlexanderGreen 10/8/2014 19:06'!for: someExpression expect: someResult	|   | 	^self expect: someResult actual: someExpression! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 5/4/2013 22:05'!test570surfaceAssemblyAsHumScript	"Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."	| window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram script diagramMenu |	"This feature is deferred until javascript code is written to enable it."	true ifFalse: [Transcript cr; show: 'test570surfaceAssemblyAsHumScript turned off px'; cr. ^self ].	"NOTE: Dimensions used here are percentages of the container !!!!!!"		"Create the main divisions."	window := HumSurface new initialize: 'px'; width: 1300 px; height: 800 px; id: 'window'.	menuStack := HumSurface new initialize: 'px'; width: 1300 px; height: 25 px; top: 0 px; left: 0 px; id: 'menu stack'.	editStack := HumSurface new initialize: 'px'; width: 800 px; height: 75 px; left: 0 px; id: 'edit stack'.	diagramStack := HumSurface new initialize: 'px'; width: 500 px; height: 75 px; id: 'diagram stack'.	"Assemble them."	window place:  editStack below: menuStack.	window place: diagramStack below: menuStack.	window place: diagramStack rightOf: editStack.		"Create editStack divisions and assemble them."	editMenu := HumSurface new initialize: 'px'; width: 800 px; height: 25 px; top: 0 px; left: 0 px; id: 'edit menu'.	codeView := HumSurface new initialize: 'px'; width: 800 px; height: 700 px; id: 'code view'.	critiqueView := HumSurface new initialize: 'px'; width: 800 px; height: 25 px; id: 'critique view'.		editStack place: codeView below: editMenu.	editStack place: critiqueView below: codeView.		"Create diagramStack divisions."	diagramMenu := HumSurface new initialize: 'px'; width: 500 px; height: 25 px; left: 0 px; top: 0 px; id: 'diagram menu'.	planTreeDiagram := HumSurface new initialize: 'px'; width: 500 px; height: 200 px; left: 0 px; top: 0 px; id: 'plan tree'.	roleRelationsDiagram := HumSurface new initialize: 'px'; width: 500 px; height: 200 px; id: 'role relations'.	wordRelationsDiagram := HumSurface new initialize: 'px'; width: 500 px; height: 200 px; id: 'word relations'.	vignetteDiagram := HumSurface new initialize: 'px'; width: 500 px; height: 200 px; id: 'vignette relations'.  		diagramStack place: planTreeDiagram below: diagramMenu.	diagramStack place: roleRelationsDiagram below:  planTreeDiagram.	diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.	diagramStack place: vignetteDiagram below: wordRelationsDiagram.		"Get the SVG string for this assembly."	script := window asHumScript .		self assert: ( script beginsWith: '. Painter: ' ).	self assert: ( script includesSubString: 'surface' ).	self assert: ( script includesSubString: ' id ''window'' ' ).	self assert: ( script includesSubString: ' id ''edit stack'' ' ).	self assert: ( script includesSubString: ' id ''diagram stack'' ' ).	self assert: ( script includesSubString: ' id ''critique view'' ' ).	"	Transcript cr; show: 'from test570surfaceAssemblyAsHumScript px'; cr; show: script; cr.	"	 		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 5/4/2013 20:32'!test130surfaceLayers	"A surface is initialized with a origin object which is zero-sized and at 0,0."	| surface rectangleA rectangleB |	"Note: Dimensions used here are meaningless - They are just for testing convenience."	surface := HumSurface new.	rectangleA := ( HumSurface new ) width: 20 px; height: 10 px.	rectangleB := ( HumSurface new ) width: 30 px; height: 40 px.		"Put rectangle A on the surface."	surface place: rectangleA at: {5 px. 5 px. 0}.	self assert: ( rectangleA left = 5 px ).	self assert: ( rectangleA top = 5 px ).	self assert: ( rectangleA layer = 0 ).		"Put rectange B on top of rectangle A"	surface overlay: rectangleB onTopOf: rectangleA.	"By convention, the top and left edges will align."	self assert: ( rectangleB left = 5 px ).	self assert: ( rectangleB top = 5 px ).	"By convention, the layer is greater for the thing on top."	self assert: ( rectangleB layer ) > ( rectangleA layer ).			! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 6/9/2014 09:12'!test260surfaceAssemblyAsSvgPercent	"Test for usability -- Consider a layout like the PA."	| window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram svgString |	true ifFalse: [Transcript cr; show: 'test260surfaceAssemblyAsSvgPercent turned off'; cr. ^self ].	"NOTE: Dimensions used here are percentages of the container !!!!!!"		"Create the main divisions."	window := HumSurface new initialize: #percent; width: 100 percent; height: 100 percent; id: 'window'.	menuStack := HumSurface new initialize: #percent; width: 100 percent; height: 10 percent; top: 0 percent; left: 0 percent.	editStack := HumSurface new initialize: #percent; width: 75 percent; height: 90 percent; left: 0 percent; id: 'edit stack'.	diagramStack := HumSurface new initialize: #percent; width: 25 percent; height: 90 percent; id: 'diagram stack'.	"Assemble them."	window place: editStack below: menuStack.	window place: diagramStack below: menuStack.	window place: diagramStack rightOf: editStack.		"Create editStack divisions and assemble them."	editMenu := HumSurface new initialize: #percent; width: 100 percent; height: 10 percent; top: 0 percent; left: 0 percent.	codeView := HumSurface new initialize: #percent; width: 100 percent; height: 80 percent.	critiqueView := HumSurface new initialize: #percent; width: 100 percent; height: 10 percent; id: 'critique view'.		editStack place: codeView below: editMenu.	editStack place: critiqueView below: codeView.		"Create diagramStack divisions."	planTreeDiagram := HumSurface new initialize: #percent; width: 100 percent; height: 25 percent; left: 0 percent; top: 0 percent.	roleRelationsDiagram := HumSurface new initialize: #percent; width: 100 percent; height: 25 percent.	wordRelationsDiagram := HumSurface new initialize: #percent; width: 100 percent; height: 25 percent.	vignetteDiagram := HumSurface new initialize: #percent; width: 100 percent; height: 25 percent.		diagramStack place: roleRelationsDiagram below: planTreeDiagram.	diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.	diagramStack place: vignetteDiagram below: wordRelationsDiagram.		"Get the SVG string for this assembly."	svgString := window asSVG.		self assert: ( svgString trimBoth beginsWith: '<svg ' ).	self assert: ( svgString includesSubString: '<rect ' ).	self assert: ( svgString includesSubString: 'ID="window" ' ).	self assert: ( svgString includesSubString: 'ID="edit stack" ' ).	self assert: ( svgString includesSubString: 'ID="diagram stack" ' ).	self assert: ( svgString includesSubString: 'ID="critique view" ' ).		"Transcript cr; show: 'from test260surfaceAssemblyAsSvgPercent: ; cr; show: svgString; cr."		 		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 6/9/2014 09:15'!test255surfaceAssemblyAsSVG	"Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."	| window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram svgString diagramMenu |	true ifFalse: [Transcript cr; show: 'test255surfaceAssemblyAsSVG turned off'; cr. ^self ].	"NOTE: Dimensions used here are percentages of the container !!!!!!"		"Create the main divisions."	window := HumSurface new width: 13.0; height: 8.0; id: 'window'.	menuStack := HumSurface new width: 12.0; height: 0.25; top: 0; left: 0; id: 'menu stack'.	editStack := HumSurface new width: 8.0; height: 7.5; left: 0; id: 'edit stack'.	diagramStack := HumSurface new width: 5.0; height: 7.5; id: 'diagram stack'.	"Assemble them."	window place:  editStack below: menuStack.	window place: diagramStack below: menuStack.	window place: diagramStack rightOf: editStack.		"Create editStack divisions and assemble them."	editMenu := HumSurface new width: 8.0; height: 0.25; top: 0; left: 0; id: 'edit menu'.	codeView := HumSurface new width: 8.0; height: 7.0; id: 'code view'.	critiqueView := HumSurface new width: 8.0; height: 0.25; id: 'critique view'.		editStack place: codeView below: editMenu.	editStack place: critiqueView below: codeView.		"Create diagramStack divisions."	diagramMenu := HumSurface new width: 5.0; height: 0.25; left: 0; top: 0; id: 'diagram menu'.	planTreeDiagram := HumSurface new width: 5.0; height: 2.0; left: 0; top: 0; id: 'plan tree'.	roleRelationsDiagram := HumSurface new width: 5.0; height: 2.0; id: 'role relations'.	wordRelationsDiagram := HumSurface new width: 5.0; height: 2.0; id: 'word relations'.	vignetteDiagram := HumSurface new width: 5.0; height: 2.0; id: 'vignette relations'.  		diagramStack place: planTreeDiagram below: diagramMenu.	diagramStack place: roleRelationsDiagram below:  planTreeDiagram.	diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.	diagramStack place: vignetteDiagram below: wordRelationsDiagram.		"Get the SVG string for this assembly."	svgString := window asSvgViewBox .		self assert: ( svgString beginsWith: '<svg ' ).	self assert: ( svgString includesSubString: '<rect ' ).	self assert: ( svgString includesSubString: ' ID="window" ' ).	self assert: ( svgString includesSubString: ' ID="edit stack" ' ).	self assert: ( svgString includesSubString: ' ID="diagram stack" ' ).	self assert: ( svgString includesSubString: ' ID="critique view" ' ).		"Transcript cr; show: 'test255surfaceAssemblyAsSVG'; cr; show: svgString; cr."! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 12/9/2013 10:58'!test220surfaceAsSvgViewBox	"Test for usability -- Consider a layout like the PA."	| window svgString |		true ifFalse: [Transcript cr; show: 'test220surfaceAsSvgViewBox turned off'; cr.  ^self ].		window := HumSurface new initialize: #pixel; width: 1600 px; height: 900 px; id: 'window'.	"Get the SVG string for this assembly."	svgString := window asSvgViewBox.		self assert: ( svgString beginsWith: '<svg ' ).	self assert: ( svgString includesSubString: '<rect ' ).	self assert: ( svgString includesSubString: ' ID="window" ' ).	self assert: ( svgString includesSubString: ' width="1600 px" ' ).	self assert: ( svgString includesSubString: ' height="900 px" ' ).	self assert: ( svgString includesSubString: ' viewBox="0 0 1600 900" ').			 		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 5/4/2013 20:36'!test140surfaceLayout	"A surface is initialized with a origin object which is zero-sized and at 0,0."	| surface rectangleA rectangleB |		"Note: Dimensions used here are meaningless - They are just for testing convenience."	surface := HumSurface new.	rectangleA := ( HumSurface new ) width: 20 px; height: 10 px.	rectangleB := ( HumSurface new ) width: 30 px; height: 40 px.		"Put rectangle A on the surface."	surface place: rectangleA at: { 5 px. 5px. 1. }.	self assert: ( rectangleA left = 5 px ).	self assert: ( rectangleA top = 5 px ).	self assert: ( rectangleA layer = 1 ).		"Put B below A."	surface place: rectangleB below: rectangleA.	self assert: ( rectangleB top ) = ( rectangleA bottom ).	"By convention B is in same layer as A. (They are side by side in the same layer. )"	self assert: ( rectangleB layer ) = ( rectangleA layer ).		"Now put B above A. "	rectangleA layer: 3.	surface place: rectangleB above: rectangleA.	self assert: ( rectangleB bottom ) = ( rectangleA top ).	self assert: ( rectangleB layer ) = ( rectangleA layer ).		"Now put B left of A."	rectangleA layer: 4.	surface place: rectangleB leftOf: rectangleA.	self assert: ( rectangleB left ) = ( rectangleA right ).	self assert: ( rectangleB layer ) = ( rectangleA layer ).		"Now put B right of A."	rectangleA layer: 5.	surface place: rectangleB rightOf: rectangleA.	self assert: ( rectangleB left ) = ( rectangleA right ).	self assert: ( rectangleB layer ) = ( rectangleA layer ).		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 5/28/2014 10:53'!test320surfaceAssemblyAsXML	"Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."	| window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram xmlString diagramMenu |	true ifFalse: [Transcript cr; show: 'test320surfaceAssemblyAsXML turned off'; cr. ^self ].	"NOTE: Dimensions used here are percentages of the container !!!!!!"		"Create the main divisions."	window := HumSurface new    initialize: 'px'; width: 1300 px; height: 800 px; id: 'window'.	menuStack := HumSurface new initialize: 'px'; width: 1300 px; height: 25 px; top: 0 px; left: 0 px; id: 'menu stack'.	editStack := HumSurface new initialize: 'px'; width: 800 px; height: 75 px; left: 0 px; id: 'edit stack'.	diagramStack := HumSurface new initialize: 'px'; width: 500 px; height: 75 px; id: 'diagram stack'.	"Assemble them."	window place:  editStack below: menuStack.	window place: diagramStack below: menuStack.	window place: diagramStack rightOf: editStack.		"Create editStack divisions and assemble them."	editMenu := HumSurface new initialize: 'px'; width: 800 px; height: 25 px; top: 0 px; left: 0 px; id: 'edit menu'.	codeView := HumSurface new initialize: 'px'; width: 800 px; height: 700 px; id: 'code view'.	critiqueView := HumSurface new initialize: 'px'; width: 800 px; height: 25 px; id: 'critique view'.		editStack place: codeView below: editMenu.	editStack place: critiqueView below: codeView.		"Create diagramStack divisions."	diagramMenu := HumSurface new initialize: 'px'; width: 500 px; height: 25 px; left: 0 px; top: 0 px; id: 'diagram menu'.	planTreeDiagram := HumSurface new initialize: 'px'; width: 500 px; height: 200 px; left: 0 px; top: 0 px; id: 'plan tree'.	roleRelationsDiagram := HumSurface new initialize: 'px'; width: 500 px; height: 200 px; id: 'role relations'.	wordRelationsDiagram := HumSurface new initialize: 'px'; width: 500 px; height: 200 px; id: 'word relations'.	vignetteDiagram := HumSurface new initialize: 'px'; width: 500 px; height: 200 px; id: 'vignette relations'.  		diagramStack place: planTreeDiagram below: diagramMenu.	diagramStack place: roleRelationsDiagram below:  planTreeDiagram.	diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.	diagramStack place: vignetteDiagram below: wordRelationsDiagram.		"Get the SVG string for this assembly."	xmlString := window asXML .		self assert: ( xmlString trimBoth beginsWith: '<script' ).	self assert: ( xmlString includesSubString: '<hum:surface ' ).	self assert: ( xmlString includesSubString: '<hum:surface ID="window" ' ).	self assert: ( xmlString includesSubString: '<hum:surface ID="edit stack" ' ).	self assert: ( xmlString includesSubString: '<hum:surface ID="diagram stack" ' ).	self assert: ( xmlString includesSubString: '<hum:surface ID="critique view" ' ).		"Transcript cr; show: 'from test320surfaceAssemblyAsXML'; cr; show: xmlString; cr."		 		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 10/31/2012 09:53'!test470surfaceAssemblyAsHTML	"Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."	| window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram htmlString diagramMenu |	"This feature is deferred until javascript code is written to enable it."	false ifFalse: [Transcript cr; show: '*** test470surfaceAssemblyAsHTML TURNED OFF until javascript code is written to enable it'; cr. ^self ].	"NOTE: Dimensions used here are percentages of the container !!!!!!"		"Create the main divisions."	window := HumSurface new width: '1300' ; height: '800'; id: 'window'.	menuStack := HumSurface new width: '1300'; height: '25'; top: 0; left: 0; id: 'menu stack'.	editStack := HumSurface new width: '800'; height: '75'; left: 0; id: 'edit stack'.	diagramStack := HumSurface new width: '500'; height: '75'; id: 'diagram stack'.	"Assemble them."	window place:  editStack below: menuStack.	window place: diagramStack below: menuStack.	window place: diagramStack rightOf: editStack.		"Create editStack divisions and assemble them."	editMenu := HumSurface new width: '800'; height: '25'; top: 0; left: 0; id: 'edit menu'.	codeView := HumSurface new width: '800'; height: '700'; id: 'code view'.	critiqueView := HumSurface new width: '800'; height: '25'; id: 'critique view'.		editStack place: codeView below: editMenu.	editStack place: critiqueView below: codeView.		"Create diagramStack divisions."	diagramMenu := HumSurface new width: '500'; height: '25'; left: 0; top: 0; id: 'diagram menu'.	planTreeDiagram := HumSurface new width: '500'; height: '200'; left: 0; top: 0; id: 'plan tree'.	roleRelationsDiagram := HumSurface new width: '500'; height: '200'; id: 'role relations'.	wordRelationsDiagram := HumSurface new width: '500'; height: '200'; id: 'word relations'.	vignetteDiagram := HumSurface new width: '500'; height: '200'; id: 'vignette relations'.  		diagramStack place: planTreeDiagram below: diagramMenu.	diagramStack place: roleRelationsDiagram below:  planTreeDiagram.	diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.	diagramStack place: vignetteDiagram below: wordRelationsDiagram.		"Get the SVG string for this assembly."	htmlString := window asHTML .		self assert: ( htmlString beginsWith: '<html' ).	self assert: ( htmlString includesSubString: '<canvas ' ).	self assert: ( htmlString includesSubString: ' id="window" ' ).	self assert: ( htmlString includesSubString: ' id="edit stack" ' ).	self assert: ( htmlString includesSubString: ' id="diagram stack" ' ).	self assert: ( htmlString includesSubString: ' id="critique view" ' ).		Transcript cr; show: 'from test470surfaceAssemblyAsHTML'; cr; show: htmlString; cr.		 		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 5/4/2013 20:30'!test120surfaceSizeIsDurable	"A surface is initialized with a origin object which is zero-sized and at 0,0."	| surface |	"Note: Dimensions used here are meaningless - They are just for testing convenience."		surface := HumSurface new.	surface width: 1 px; height: 1 px.	"Bump surface over the the right."	surface left: 1 px.	self assert: ( surface right = 2 px ).	"Bump surface up."	surface top: 3 px.	self assert: ( surface bottom = 2 px ).	"Bump surface from bottom."	surface bottom: 3 px.	self assert: ( surface top = 4 px ).	"Pull surface via the right edge."	surface right: 5 px.	self assert: ( surface left = 4 px).! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 5/28/2014 10:53'!test310surfaceAsXML	"First principle: Express a hum surface as XML.	The recipient of the XML may interpret it using some local framework.	For example: The Hum RunTime may provide a JavaScript interpreter.	"	| window xmlString |		true ifFalse: [Transcript cr; show: 'test310surfaceAsXML turned off'; cr.  ^self ].		window := HumSurface new initialize: 'px'; width: 800 px; height: 450 px; id: 'window'.	"Get the SVG string for this assembly."	xmlString := window asXML.		self assert: ( xmlString trimBoth beginsWith: '<script ' ).	self assert: ( xmlString includesSubString: '<hum:surface ' ).	self assert: ( xmlString includesSubString: ' ID="window" ' ).	self assert: ( xmlString includesSubString: ' width="800 px" ' ).	self assert: ( xmlString includesSubString: ' height="450 px" ' ).		 	"Transcript cr; show: 'from test310surfaceAsXML : '; cr; show: xmlString; cr."	! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 5/28/2014 10:52'!test210surfaceAsSVG	"Test for usability -- Consider a layout like the PA."	| window svgString |		true ifFalse: [Transcript cr; show: 'test210surfaceAsSVG turned off'; cr.  ^self ].		window := HumSurface new initialize: 'px'; width: 1600 px; height: 900 px; id: 'window'.	"Get the SVG string for this assembly."	svgString := window asSVG.		self assert: ( svgString trimBoth beginsWith: '<svg ' ).	self assert: ( svgString includesSubString: '<rect ' ).	self assert: ( svgString includesSubString: ' ID="window" ' ).	self assert: ( svgString includesSubString: ' width="1600 px" ' ).	self assert: ( svgString includesSubString: ' height="900 px" ' ).		 		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 5/4/2013 20:28'!test110surfaceHasOrigin	"A surface is initialized with a origin object which is zerosized and at 0,0."	| surface zero|	surface := HumSurface new.	zero := 0 px.	self assert: ( surface origin left = zero).	self assert: ( surface origin right = zero ).		self assert: ( surface origin top = zero ).		self assert: ( surface origin bottom = zero ).	self assert: ( surface origin height = zero ).	self assert: ( surface origin width = zero ).	self assert: ( surface origin layer = zero ).! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 2/26/2014 17:01'!test510surfaceAsHumScript	"Test first principle: Produce a hum action call.	The hum script may be translated into some target language.	The target language could be a series of openGL calls, or PyQt, JavaScript canvas, et cetera.	"	| window script |		"This #asHTML  feature is deferred until javascript code is written to enable it."	true ifFalse: [Transcript cr; show: 'test510surfaceAsHumScript turned off'; cr.  ^self ].		window := HumSurface new initialize: 'px'; width: 800 px; height: 450 px; id: 'window'.	"Get the SVG string for this assembly."	script := window asHumScript.		"Expect something like '. Painter: Paint surface with id 'window' width '800 px' height '450 px'.   "	self assert: ( script beginsWith: '. Painter:' ).	self assert: ( script includesSubString: 'Paint surface ' ).	self assert: ( script includesSubString: ' id ''window''' ).	self assert: ( script includesSubString: ' width ''800 px''' ).	self assert: ( script includesSubString: ' height ''450 px''' ).	self assert: ( script includesSubString: ' left ''0 px''' ).	self assert: ( script includesSubString: ' top ''0 px''' ).	self assert: ( script endsWith: '.' ).		 	"Transcript cr; show: 'from test510surfaceAsHumScript '; cr; show: script; cr."	! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 12/9/2013 11:00'!test270surfaceAssemblyAsSvgInch	"Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."	| window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram svgString diagramMenu |	true ifFalse: [Transcript cr; show: 'test270surfaceAssemblyAsSvgInch turned off'; cr. ^self ].	"NOTE: Dimensions used here are percentages of the container !!!!!!"		"Create the main divisions."	window := HumSurface new initialize: 'inch'; width: 13.0 inch; height: 8.0 inch; id: 'window'.	menuStack := HumSurface new initialize: 'inch'; width: 13.0 inch; height: 0.25 inch; top: 0 inch; left: 0 inch; id: 'menu stack'.	editStack := HumSurface new initialize: 'inch'; width: 8.0 inch; height: 7.5 inch; left: 0 inch; id: 'edit stack'.	diagramStack := HumSurface new initialize: 'inch'; width: 5.0 inch; height: 7.5 inch; id: 'diagram stack'.	"Assemble them."	window place:  editStack below: menuStack.	window place: diagramStack below: menuStack.	window place: diagramStack rightOf: editStack.		"Create editStack divisions and assemble them."	editMenu := HumSurface new initialize: 'inch'; width: 8.0 inch; height: 0.25 inch; top: 0 inch; left: 0 inch; id: 'edit menu'.	codeView := HumSurface new initialize: 'inch'; width: 8.0 inch; height: 7.0 inch; id: 'code view'.	critiqueView := HumSurface new initialize: 'inch'; width: 8.0 inch; height: 0.25 inch; id: 'critique view'.		editStack place: codeView below: editMenu.	editStack place: critiqueView below: codeView.		"Create diagramStack divisions."	diagramMenu := HumSurface new initialize: 'inch'; width: 5.0 inch; height: 0.25 inch; left: 0 inch; top: 0 inch; id: 'diagram menu'.	planTreeDiagram := HumSurface new initialize: 'inch'; width: 5.0 inch; height: 2.0 inch; left: 0 inch; top: 0 inch; id: 'plan tree'.	roleRelationsDiagram := HumSurface new initialize: 'inch'; width: 5.0 inch; height: 2.0 inch; id: 'role relations'.	wordRelationsDiagram := HumSurface new initialize: 'inch'; width: 5.0 inch; height: 2.0 inch; id: 'word relations'.	vignetteDiagram := HumSurface new initialize: 'inch'; width: 5.0 inch; height: 2.0 inch; id: 'vignette relations'.  		diagramStack place: planTreeDiagram below: diagramMenu.	diagramStack place: roleRelationsDiagram below:  planTreeDiagram.	diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.	diagramStack place: vignetteDiagram below: wordRelationsDiagram.		"Get the SVG string for this assembly."	svgString := window asSvgViewBox .		self assert: ( svgString beginsWith: '<svg ' ).	self assert: ( svgString includesSubString: '<rect ' ).	self assert: ( svgString includesSubString: ' ID="window" ' ).	self assert: ( svgString includesSubString: ' ID="edit stack" ' ).	self assert: ( svgString includesSubString: ' ID="diagram stack" ' ).	self assert: ( svgString includesSubString: ' ID="critique view" ' ).		"Transcript cr; show: svgString; cr."		 		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 5/4/2013 20:50'!test150surfaceLayoutForPA	"Test for usability -- Consider a layout like the PA."	| window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram |	"NOTE: Dimensions used here are percentages of the container !!!!!!"		"Create the main divisions."	window := HumSurface new initialize: 'percent'; width: 100 percent; height: 100 percent.	menuStack := HumSurface new initialize: 'percent'; width: 100 percent; height: 10 percent; top: 0 percent; left: 0 percent.	editStack := HumSurface new initialize: 'percent'; width: 75 percent; height: 90 percent; left: 0 percent.	diagramStack := HumSurface new initialize: 'percent'; width: 25 percent; height: 90 percent.	"Assemble them."	window place:  editStack below: menuStack.	self expect: editStack bottom is: -100 percent .	window place: diagramStack below: menuStack.	self expect: diagramStack bottom is: -100 percent.	window place: diagramStack rightOf: editStack.	self expect:  diagramStack right is: 100 percent.		"Create editStack divisions and assemble them."	editMenu := HumSurface new initialize: 'percent'; width: 100 percent; height: 10 percent; top: 0 percent; left: 0 percent.	codeView := HumSurface new initialize: 'percent'; width: 100 percent; height: 80 percent.	critiqueView := HumSurface new initialize: 'percent'; width: 100 percent; height: 10 percent.		editStack place: codeView below: editMenu.	editStack place: critiqueView below: codeView.	self expect:  critiqueView bottom is: -100 percent.		"Create diagramStack divisions."	planTreeDiagram := HumSurface new initialize: 'percent'; width: 100 percent; height: 25 percent; left: 0 percent; top: 0 percent.	roleRelationsDiagram := HumSurface new initialize: 'percent'; width: 100 percent; height: 25 percent.	wordRelationsDiagram := HumSurface new initialize: 'percent'; width: 100 percent; height: 25 percent.	vignetteDiagram := HumSurface new initialize: 'percent'; width: 100 percent; height: 25 percent.		diagramStack place: roleRelationsDiagram below:  planTreeDiagram.	diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.	diagramStack place: vignetteDiagram below: wordRelationsDiagram.	self expect: vignetteDiagram bottom is: -100 percent.	self expect: vignetteDiagram top is: -75 percent.	self expect: vignetteDiagram left is: 0 percent.	self expect: vignetteDiagram right is: 100 percent.	 		! !!HumUserInterfaceTests methodsFor: 'HumSurface tests' stamp: 'RichardAlexanderGreen 10/31/2012 09:54'!test410surfaceAsHTML	"Test for usability -- Consider a layout like the PA."	| window htmlString |		"This #asHTML  feature is deferred until javascript code is written to enable it."	false ifFalse: [Transcript cr; show: '*** test410surfaceAsHTML TURNED OFF until javascript code is written to enable it '; cr.  ^self ].		window := HumSurface new width: '800 px'; height: '450 px'; id: 'window'.	"Get the SVG string for this assembly."	htmlString := window asHTML.		self assert: ( htmlString beginsWith: '<html' ).	self assert: ( htmlString includesSubString: '<canvas ' ).	self assert: ( htmlString includesSubString: ' id="window" ' ).	self assert: ( htmlString includesSubString: ' width="800 px" ' ).	self assert: ( htmlString includesSubString: ' height="450 px" ' ).		 	Transcript cr; show: 'from test410surfaceAsHTML '; cr; show: htmlString; cr.	! !!HumUserInterfaceTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 11/1/2014 14:50'!testS500ThreeJSReadMe	"The advantage of ThreeJS is that it runs WebGL in a relatively straight-forward manner.	The disadvantage of ThreeJS is that the API is relativelyl low-level.	"! !!HumUserInterfaceTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/13/2012 15:24'!aReadMe	"See the class description for the intended (future) tests."	^'See the class description for the intended (future) tests.'	! !Object subclass: #Hum000TestPlanOverview	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!Hum000TestPlanOverview commentStamp: 'RichardAlexanderGreen 1/30/2014 12:28' prior: 0!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%BIG TEST PLAN%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890         1         2         3         4         5         6         7         8         9        10 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%USER INTERFACE TEST PLAN    (plan is WBS agenda, not a sequence)Assemble user interface from components   =======================================A. Scribe interprets keyboard, mouse, and menu gestures.   1. Keyboard has control or command or option pressed.      a) Conventional commands            (copy, cut, paste, un-do, save, open, print, close window, quit application).      b) Commands defined by the user, menu, or application default preferences.   2. Mouse actions      a) Mouse over. (May cause display.)      b) Mouse button pressed.       c) Mouse moved.      d) Mouse button released. (Buttons invoke commands.)   3. User selects action from menu.      a) Create menu | submenu | toolbar.      b) Respond to user navigation.      c) Send (user-selected) command.B. Painter creates 2-D objects in the users viewport.   1. Create billboard in anchored location   2. Create floating billboard in front of camera. (or near mouse cursor).   3. Create window (viewport).   4. Move billboards text-cursor (left, right, up, down, jump to).   5. Move billboard to a new anchored location.   6. Draw text on billboard at cursor.           (Side-effect: Cursor moves to end of text).   7. Draw lines and shapes on billboard.           (A diagram may direct the painter.) C. Sculptor creates 3-D objects in the users viewport.   1. Create 3-D shapes via      a) rotations.       b) extrusion.      c) cut.      d) fill with material.      e) cover with texture.   2. Common tasks (scripts / macros / routines)      a) Create deck, wall, door, window.      b) Create light.      c) Create room.      d) Place billboard on wall.   3. Create, move, animate avatar.      a) Create avatar.      b) Move avatar.      c) Animate avatar.D. Viewport actions affect a window (viewport).   1. Slide, pan, and zoom viewport.      a) Slice actions are like document-centric scrolling.      b) Pan actions are like rotating a camera up-down, left-right.      c) Zoom actions are like a zoom lens widening or narrowing the field of view             (as if the camera moved, but the camera does not move).   2. Move viewport to a new place in virtual world.      a) Rotate camera (same as pan actions).      b) Step forward | backward.      c) Side-step left | right.      d) Step-Turn left | right.      e) Step up (rise) | down (descend).      f) Move viewport to floor location under cursor.      g) Move viewport to face wall under cursor.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%II. Programmer Assistant (PA) User-Dialogs%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%A. Ontology Actions   1. New ontology.   2. Save ontology on file. (Save As on new file)   3. Load ontology from file   4. Merge ontology from (TBD: file or another PA).   5. Test run ontology.   6. Deploy ontology?  (??? What does deploy portend ???)B. Frame Editor Actions   1. Usual text edit actions:      a) commands: (copy, cut, paste, un-do, save, open, print, close window)      b) cursor moves: (up, down, left, right, top, bottom, . . .)   2. PA-specific actions:      a) [Line updated] event causes the logical-line and frame to be checked.         (1) The logical-line is rendered.              Keywords and nouns are emphasized. Nouns have links.          (2) If the logical-line is not understood (no definition in ontology or DSL),              the line is flagged (with a question-mark).         (3) If a noun lacks an antecedent in the frame, the noun is flagged (color code).      b) [Insert/Append Instruction] - Instructions are indented.         (1) In an action frame,                the automatic indent matches the preceding statements indent                unless it was a control statement (ending with a colon).                   And then, the indentation is increased by one.         (2) In plan and dialog frames,                instructions have only one level of indent                because control statements are not allowed in those contexts.         (3) In dialog frames,                the user indicates an instruction by starting the line with dot [tab].      c) [Submit frame] command causes the ontology to be          (1) updated.         (2) versioned.         (3) re-evaluated. (problems flagged)         (4) re-displayed. (all views rebuilt)      d) [Test Dialog] - in dialog run-time with mock agents. %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%III. Run-Time Test Cases%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%A. Messenger   1. The actors (agents) communicate via the Messenger.   2. Messenger is addressed via a URI.   3. Messenger records each message in a log file.   4. In test mode,          the messenger can replay the messages          that were sent to an actor during some period of time.          (This capability enables simulations.)   5. In test mode,          messages can only be communicated          between actors that are also in test mode.B. Resource Manager (RM) - assigns tasks to actors.   1. Actor checks-in (announces availability to perform specific roles).   2. Assign task (action-statement) to actor.      a) Job-ticket contains action-statement, noun-values,             request context (requesting actor, and instruction-pointer).      b) The RM assigns an available actor.      c) The RM sends the job-ticket to the assigned actor.             (via Messenger)   3. Actor has completed task.      a) The resources consumed (actors time, etc) are recorded on the job ticket.      b) Any computed results are added to the job-ticket.            (Convention: Actions results have a giving clause.)      c) RM sends resource consumption data to Bookkeeper.      d) Task complete notice (with job-ticket) is sent to requester.            (The requester resumes execution of the plan.)C. Bookkeeper - tracks resource consumption   1. Job-ticket resource consumption is recorded.   2. Resource dimensions include job, resource,          provider (actor, role), consumer (actor, role), and date-time.   3. Actors may decrement, increment inventories.   4. Actors may set inventory level (initialization, audit).D. Supervisor - controls execution of plans and dialogs.   1. Delegate task.         (The current actor has delegated a task to another role.)      a) Send delegated task to Resource Manager. (RM)         (The RM will assign the task to an available actor.)    2. Resume suspended action.         (When a task is delegated to another role,             the current task execution is suspended.)!!Hum000TestPlanOverview methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/17/2012 10:58'!givenWhenThenInHTML	"HTML GivenWhenThen frames."^'<html><head>	<title>Hum PA Given-When-Then</title>	<style type="text/css">		pre.Reqt {font-size: Larger}		pre.Design {font-size: Smaller}	</style></head><body>	<h1>	<center>		Web 		<br/>Programmers Assistant		<br/>Given When Then	</center></h1><h2>	<center>		The Programmers Assistant 		<br/>User Interface behavior 		<br/>is defined 		<br/>via Given-When-Then story cards.	</center></h2><table border=1 cellpadding=6><tr> <th>GIVEN WHEN THEN</th> <th>ARCHITECTURE CONSEQUENCE</th> </tr></pre><!!-- =============== --></td></tr><tr><td><pre class="Reqt"><b>Given:</b> User is editing a frame.<b>When:</b> Text cursor moves off current line        (key return, up, down, mouse click).<b>Then:</b> Current line is pretty-printed.<b>Then:</b> (also)  Current frame is critiqued.<td><pre class="Design">Either use (CodeMirrror.js)   or stick with making one line at a time   using &lt;input&gt; text or test-area.Comment: CodeMirror is probably the ideal solution. However, it may require a lot of work to get CodeMirror   to signal the Web-PA properly   and for the WebPA to interact with the code mirror.</pre></td></pre><!!-- =============== --></td></tr><tr><td><pre class="Reqt"><b>Given:</b> User has navigated to a frame opening dialog.<b>When:</b> User is entering the frame title statement.<b>Then:</b>  Auto-completion is offered for title statements.<b>When:</b> User has completed entering the frame title statement.<b>Then:</b>  The code text is appropriately initialized      (and made visible), depending on the type of frame.    -- Empty frame may be a template.    -- Code frame is pretty-printed.    -- The first line is given focus (and/or highlighted).<td><pre class="Design">Use JQuery auto-completion facility.Looks easy enough.Open a new tab-pane with the code text.</pre></td></pre><!!-- =============== --></td></tr><tr><td><pre class="Reqt"><b>Given:</b> User is entering an instruction.<b>When:</b> User enters a delegated instruction.<b>Then:</b>  Auto-Completion is offered for the given role name`s public actions.(A role`s public actions are those preceded with the label "Action:")<td><pre class="Design">Use JQuery auto-completion.PA (model of PA) should implement the query as a method.</pre></td></pre><!!-- =============== --></td></tr><tr><td><pre class="Reqt"><b>Given:</b> User is inserting a delegated instruction into some frame.<b>When:</b> The statement is a not one of that role`s current public actions.<b>Then:</b>  Action (empty frame) is added     -- after user confirms intent to add a new action.<b>When:</b> The statement currently references a private (To:) procedure.<b>Then:</b> The procedure is converted to a public"Action:" procedure    -- after user confirms intent to convert.<td><pre class="Design">Use Seaside dialog to confirm user intent.PA modifies underlying code.If a converted "To:" statement is currently displayed or diagrammed,some means is needed to signal that it has changed from "To:" to "Action:".(Brute force, we could simply tell every display to update from the model.)</pre></td></pre><!!-- =============== --></td></tr><tr><td><pre class="Reqt"><b>Given:</b> User is editing a frame`s code.<b>When:</b> User moves text cursor to a new line . . .<b>Then:</b> New line is highlighted.<b>Then:</b> (also)  Old line is not.<td><pre class="Design">This assumes we are <u>not</u> using CodeMirror.js.It is a work-around.</pre></td></pre><!!-- =============== --></td></tr><tr><td><pre class="Reqt"><b>Given:</b> User is editing a frame`s code.<b>When:</b> User presses something other than a line-selector key [up/down] . . .<b>Then:</b> The line under the text cursor is put into edit mode.<b>When:</b> User presses enter or return.<b>Then:</b>  An empty line is inserted with appropriate indentation.<td><pre class="Design">This assumes we are <u>not</u> using CodeMirror.js.Otherwise CodeMirror`s normal behavior should be adequate.</pre></td></pre><!!-- =============== --></td></tr><tr><td><pre class="Reqt"><b>Given:</b> User is editing a plan frame.<b>When:</b> User enters a precondition statement.<b>Then:</b> Auto-completion is offered  (sourced from known conditions.)<td><pre class="Design">Use JQuery auto-completion. PA will provide a suitable collection (of strings) via a method.</pre></td></pre><!!-- =============== --></td></tr><tr><td><pre class="Reqt"><b>Given:</b> User is editing a plan frame.<b>When:</b>  User enters new precondition       (one that does not match a known condition)<b>Then:</b> Condition is added to conditions collection    unless the annotation says "[assumed]."<b>When:</b> Condition is added . . .<b>Then:</b> an empty frame is inserted into frames.    -- (This empty frame simplifies some things.)<td><pre class="Design">Q: What happens when/if the user deletes the only reference later?A: Will think about it.  (TBD)The UI simply tells PA>>addLine: aPlanFrameLine.The PA then performs the rest.</pre></td></pre><!!-- =============== --></td></tr><tr><td><pre class="Reqt"><b>Given:</b> Statement is in a displayed view.<b>When:</b> Statement has no known nouns.    -- because it is entered before nouns are defined.    -- because (last) noun became undefined.<b>Then:</b> Statement is highlighted with an"error" color.    -- background / foreground is TBD<b>Then:</b> Critique says ". . . no known nouns"<td><pre class="Design">Since the set of diagrams displays all of the statements,  at least implicitly,   it appears that PA needs to scan all statements in the ontology   and update the known nouns attribute.The WebPA may then update each display   that is affected by statement qualities.This looks like a job for "Announcements" (Pharo publish/subscribe).</pre></td></pre><!!-- =============== --></td></tr><table>'.! !!Hum000TestPlanOverview methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 9/10/2014 15:43'!progress	^ ' 	01-Jan-2012:  33 test  65 implementation methods completed.	02-Jan-2012:  37 test  76 implementation methods completed.	03-Jan-2012:  38 test  91 implementation methods completed. -- 1079+788+188 = 2055 Lines in ST (file-out) files.	04-Jan-2012:  39 test 111 implementation methods completed -- 1088+825+152 = 2065 Lines ( after refactoring ).	---- Start counting assert: as indicator of number of tests instead. ---	06-Jan-2012:   90 asserts 155 implementation methods completed -- 1189+1034+158  = 2381 Lines 	09-Jan-2012: 101 asserts 146 implementation methods completed -- 1224+1114+162 =  2500 Lines (at 3:20 pm)	12-Jan-2012: 164 asserts 169 implementation methods completed -- 1617+1364+169+54 = 3204 Lines (at 3:30 pm)	15-Jan-2012: 211 asserts 186 implementation methods completed -- 1850+1518+208+54 = 3630 Lines (at 9:15 pm)	18-Jan-2012: 247 asserts 208 implementation methods completed -- 2113+1709+230+54 = 4106 Lines (at 1:50 pm)	--- Started work on UI ----	20-Jan-2012: 305 asserts 259 implementation methods completed -- 2314+1722+230+54+430 = 4750 Lines (at 5:05 pm) 	06-Feb-2012: 363 asserts 345 implementation methods completed -- 2742+1919+253+596+547 = 6057 Lines ==> ~ 5274 LoC	28-Mar-2012: 534 asserts 402 implementation methods completed -- 254+2388+804+3892+804 = 8142 Lines ==> ~ 6500 LoC	10-Apr-2012: 615 asserts 419 implementation methods completed -- 254+2700+804+4406+870 = 9034 Lines ==> ~ 7200 LoC 	29-May-2012: Basically got lost trying to find ways to do 3D modeling and also surveying free design tools.	24-July-2012: Got distracted learning Python and using Visual Python (VPython) and using it to model trailer and to visualize Game Of Life in 3D.	28-September-2012: Got around to learning Seaside and starting to implement the IDE.					I have a site initiated at Seaside hosting.					Took a look at Magritte -- Decided to not use it in the browser. 					   (too many layers and dependencies, not enough comments in the code).					I also toyed with Pier (a content management system based on Seaside and Magritte) 					-- It has still another wiki-mark-up.					Pier might be worth adopting later as a wiki and book generator. 					I am not convinced yet, 					  but (notably) some of the Pharo/Seaside/Pier books seem to be produced via Pier.	28-September-2012: Made sure that all of my classes have comments. 	                  (Pet peeve about others code -- must comply myself.)	28-September-2012: 795 asserts 533 implementation methods completed -- 12592 ==> ~ 10,000 LoC.	17-October-2012:   658 asserts -- I removed a large number of redundant tests that had been cut and pasted into HumSeasideTests.	17-October-2012:   658 asserts, 553 implementation methods completed-- 12173 ==> still roughly 10,000 LoC.	*** ~5 months without a report -- Mostly working on HumSeaside but distracted with Python/Javascript. ***	11-March-2013:     704 asserts, 584 implementation methods completed -- 13,716 * (10/12) ==> 11,430 LoC.	*** Implementing HumDiagram, HumFuzzy, HumMeasure.	25-April-2013:     785 asserts, 630 implementation methods completed -- 16,824 * (10/12) ==> 14,020 LoC.	*** Miscelaneous refactoring and tinkering ***	05-February-2014: 1033 asserts 1030 implementation methods completed -- 19,888 * (10/12) ==> 16,573 LoC.	10-September-2014: 1181 asserts, 1163 implementation methods completed -- 28,142 * (10/12) ==> 23,451 LoC	'! !!Hum000TestPlanOverview methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/13/2012 15:23'!aReadMe	"See the class description for the intended (future) tests."	^'See the class description for the intended (future) tests.'	! !HumTestCase subclass: #HumFuzzyTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumFuzzyTests methodsFor: 'Fuzzy Arithmetic Tests' stamp: 'RichardAlexanderGreen 7/2/2014 18:02'!testF210PlusOrMinus	"A measure stated as plus-or-minus 	 is assumed to exclude cases outside the limits."	| measure sampleMean sampleMedian |	measure := HumFuzzy quantity: 100 plusOrMinus: 1.	"Use Float #closeto: "	sampleMean := measure mean.	sampleMedian := measure median.	"Note: Following will fail occasionally."	self assert: ( sampleMean closeTo: 100.0 ) description: 'This sampleMean value will deviate now and then'. 	self assert: ( sampleMedian closeTo: 100.0 ) description: 'This sampleMedian value will deviate now and then'.		! !!HumFuzzyTests methodsFor: 'Fuzzy Arithmetic Tests' stamp: 'RichardAlexanderGreen 7/2/2014 18:02'!testF310Mode	"Estimate the mode of a distribution by calculating expected value."	| mode distribution fuzzy sum mean expected |	distribution := Dictionary new.	distribution		at: 0.00 put: 0;		at: 0.20 put: 50;		at: 0.50 put: 100;		at: 0.80 put: 200;		at: 1.00 put: 400.	fuzzy := HumFuzzy distribution: distribution.	sum := 0.	fuzzy distributionDo: [:p :v | sum := sum + (p*v)].	mode := sum.	expected := ((20*50)+(50*100)+(80*200)+(100*400))/100. 	self expect: expected actual: mode.	! !!HumFuzzyTests methodsFor: 'Fuzzy Arithmetic Tests' stamp: 'RichardAlexanderGreen 7/2/2014 18:02'!testF410Plot	"Estimate the mode of a distribution by calculating expected value."	| distribution fuzzy   canvas scaleX scaleY extent magnifyBy scalePt priorPt vMax |	distribution := Dictionary new.	distribution		at: 0.00 put: 0;		at: 0.20 put: 50;		at: 0.50 put: 100;		at: 0.80 put: 200;		at: 1.00 put: 400.	fuzzy := HumFuzzy distribution: distribution.	false ifTrue: [ fuzzy asCrudeMorph ].	! !!HumFuzzyTests methodsFor: 'Fuzzy Arithmetic Tests' stamp: 'RichardAlexanderGreen 7/2/2014 18:02'!ztestF410LearnToPlot	"Estimate the mode of a distribution by calculating expected value."	| distribution fuzzy   canvas scaleX scaleY extent magnifyBy scalePt priorPt vMax |	distribution := Dictionary new.	distribution		at: 0.00 put: 0;		at: 0.20 put: 50;		at: 0.50 put: 100;		at: 0.80 put: 200;		at: 1.00 put: 400.	fuzzy := HumFuzzy distribution: distribution.		magnifyBy := 2.	scaleX := [:v | v*magnifyBy].	scaleY := [:p | (100 - (100*p))*magnifyBy ]. "Flip Y. Screen coordinates have Y pointing down."	scalePt := [:pt | (scaleX value: (pt x))@(scaleY value: (pt y)) ].	vMax := distribution at: 1.0.	extent := ( scalePt value: (vMax@0.0) )* 1.1.		priorPt := scalePt value: 0.0@0.0.	canvas := FormCanvas extent: extent depth: 32 origin: (10@10) clipRect: (Rectangle origin: 0@0 extent: extent).	  canvas fillColor: Color blue muchLighter.		"verticle grid"		(0.0 to: vMax by: 100.0)			do: [:v | canvas line: (scalePt value: v@0.0) to: (scalePt value: v@1.0) width: 1 color: Color green].	  "horizontal grid"		(0.0 to: 1.0 by: 0.1)			do:[:p | canvas line: (scalePt value: 0.0@p) to: (scalePt value: vMax@p) width: 1 color: Color green].		(0.0 to: 1.0 by: 0.5)			do:[:p | canvas line: (scalePt value: 0.0@p) to: (scalePt value: vMax@p) width: 2 color: Color green].		fuzzy distributionDo: 		[:p :v | 		| xy | 		xy := scalePt value: v@p.		canvas line: priorPt to: xy width: 4 color: Color red.		priorPt := xy.		].	"Should we display the canvas?"	false ifTrue: [| morph | 		morph := canvas form asMorph openInWorld. 		"You can delete morph by double-clicking it."		morph on: #doubleClick send: #delete to: morph. 		].	! !!HumFuzzyTests methodsFor: 'Fuzzy Arithmetic Tests' stamp: 'RichardAlexanderGreen 7/2/2014 18:02'!testF160Division	"Divide fuzzy distributions."	| distributionA distributionB median fuzzyA fuzzyB fuzzyC resultMedian expectedMedian diff   diffMedian actualMean expectedMean diffMean |	"A distribution is a Dictionary of p->f points	where p is the probability that observations will be less than or equal to f.	When the distribution is plotted 	 by mapping p->f to (f,p) = (x,y),	 you get an S-Curve."	distributionA := Dictionary new.	distributionB := Dictionary new.	distributionA		at: 0.50 put: 200;  "Estimate 200 hours"		at: 0.00 put: 0;    "Cannot be less than zero"  		at: 0.10 put: 100;   "Will come at less than half the estimate no more than 10% of time."		at: 0.90 put: 400;  "Will come at upto double the estimate no more than 90% of time."		at: 1.00 put: 800.  "At worst, the actual will be 4 times the estimate."	distributionB		at: 0.50 put: 100;  "Estimate 100 hours"		at: 0.00 put: 0;    "Cannot be less than zero"  		at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."		at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."		at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."	fuzzyA := HumFuzzy distribution: distributionA.	fuzzyB := HumFuzzy distribution: distributionB.	fuzzyC := fuzzyA / fuzzyB.		resultMedian := fuzzyC median.	" Niave median is just . . . "	expectedMedian := (( fuzzyA median) / (fuzzyB median) ). 	" But, because there is a long tail . . . "	diffMedian := ( resultMedian - expectedMedian ) abs.	"NOTE: Following will fail occasionally."	self assert: ( diffMedian closeTo: 0.0 ) not.			"Examine expectedMean"	actualMean := fuzzyC mean.	expectedMean := ( fuzzyA mean ) / ( fuzzyB mean ).	diffMean := ( expectedMean - actualMean ) abs.	"The difference will typically be on the order of 5-15%"	"It could be close to zero, but that will be a rare event."	self assert: ( diffMean closeTo: 0.0 ) not. ! !!HumFuzzyTests methodsFor: 'Fuzzy Arithmetic Tests' stamp: 'RichardAlexanderGreen 7/2/2014 18:02'!testF431PlotPlus	"Add fuzzy distributions.	NOTE: The test assertions will fail occasionally. "	| distributionA distributionB median fuzzyA fuzzyB fuzzyC resultMedian expectedMedian  expectedMean actualMean diffMean diffMedian |	"A distribution is a Dictionary of p->f points	where p is the probability that observations will be less than or equal to f.	When the distribution is plotted 	 by mapping p->f to (f,p) = (x,y),	 you get an S-Curve."	distributionA := Dictionary new.	distributionA		at: 0.50 put: 100;  "Estimate 100 hours"		at: 0.00 put: 0;    "Cannot be less than zero"  		at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."		at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."		at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."	distributionB := distributionA.	fuzzyA := HumFuzzy distribution: distributionA.	fuzzyB := HumFuzzy distribution: distributionB.	fuzzyC := fuzzyA + fuzzyB.	false ifTrue: [ fuzzyC asCrudeMorphInRectangle: (Rectangle origin: 111@222 extent: 500@500) ]					! !!HumFuzzyTests methodsFor: 'Fuzzy Arithmetic Tests' stamp: 'RichardAlexanderGreen 7/2/2014 18:02'!testF112CheckEdgeCases	"Create a fuzzy quantity from a given distribution."	| distribution median fuzzy |	"A distribution is a Dictionary of f->p points	where p is the probability that observations will be less than or equal to f.	When the distribution is plotted mapping (f,p) to (x,y) you get an S-Curve."	distribution := Dictionary new.	distribution		at: 0.00 put: 0;		at: 0.50 put: 100;		at: 0.20 put: 50;		at: 0.80 put: 200;		at: 1.00 put: 400.	fuzzy := HumFuzzy distribution: distribution.		self assert: 100 equals: ( fuzzy median ).	self assert: 0 equals: ( fuzzy atP: 0.0 ).	self assert: 400 equals: ( fuzzy atP: 1.00 ).! !!HumFuzzyTests methodsFor: 'Fuzzy Arithmetic Tests' stamp: 'RichardAlexanderGreen 7/2/2014 18:02'!testF150MinusOp	"Subtract fuzzy distributions."	| distributionA distributionB median fuzzyA fuzzyB fuzzyC resultMedian expectedMedian diff  minus |	"A distribution is a Dictionary of p->f points	where p is the probability that observations will be less than or equal to f.	When the distribution is plotted 	 by mapping p->f to (f,p) = (x,y),	 you get an S-Curve."	distributionA := Dictionary new.	distributionB := Dictionary new.	distributionA		at: 0.50 put: 200;  "Estimate 200 hours"		at: 0.00 put: 0;    "Cannot be less than zero"  		at: 0.10 put: 100;   "Will come at less than half the estimate no more than 10% of time."		at: 0.90 put: 400;  "Will come at upto double the estimate no more than 90% of time."		at: 1.00 put: 800.  "At worst, the actual will be 4 times the estimate."	distributionB		at: 0.50 put: 100;  "Estimate 100 hours"		at: 0.00 put: 0;    "Cannot be less than zero"  		at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."		at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."		at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."	fuzzyA := HumFuzzy distribution: distributionA.	fuzzyB := HumFuzzy distribution: distributionB.	minus := #-.	fuzzyC := fuzzyA op: minus with: fuzzyB.		resultMedian := fuzzyC median.	" Niave median is just . . . "	expectedMedian := (( fuzzyB median) - fuzzyA median). 	" But, because there is a long tail . . . "	self assert: ( resultMedian > expectedMedian ).	diff := ( resultMedian - expectedMedian ) abs.	self assert:( diff > ((expectedMedian) * 0.10) ).	! !!HumFuzzyTests methodsFor: 'Fuzzy Arithmetic Tests' stamp: 'RichardAlexanderGreen 7/2/2014 18:02'!testF430PlotPlus	"Add fuzzy distributions.	NOTE: The test assertions will fail occasionally. "	| distributionA distributionB median fuzzyA fuzzyB fuzzyC resultMedian expectedMedian  expectedMean actualMean diffMean diffMedian |	"A distribution is a Dictionary of p->f points	where p is the probability that observations will be less than or equal to f.	When the distribution is plotted 	 by mapping p->f to (f,p) = (x,y),	 you get an S-Curve."	distributionA := Dictionary new.	distributionA		at: 0.50 put: 100;  "Estimate 100 hours"		at: 0.00 put: 0;    "Cannot be less than zero"  		at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."		at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."		at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."	distributionB := distributionA.	fuzzyA := HumFuzzy distribution: distributionA.	fuzzyB := HumFuzzy distribution: distributionB.	fuzzyC := fuzzyA + fuzzyB.	false ifTrue: [ fuzzyC asCrudeMorph2 ]					! !!HumFuzzyTests methodsFor: 'Fuzzy Arithmetic Tests' stamp: 'RichardAlexanderGreen 7/2/2014 18:02'!testF110CreateFuzzyWithDistribution	"Create a fuzzy quantity from a given distribution."	| distribution median fuzzy |	"A distribution is a Dictionary of f->p points	where p is the probability that observations will be less than or equal to f.	When the distribution is plotted mapping (f,p) to (x,y) you get an S-Curve."	distribution := Dictionary new.	distribution		at: 0.00 put: 0;		at: 0.20 put: 50;		at: 0.50 put: 100;		at: 0.80 put: 200;		at: 1.00 put: 400.	fuzzy := HumFuzzy distribution: distribution.		self assert: 100 equals: ( fuzzy median ).! !!HumFuzzyTests methodsFor: 'Fuzzy Arithmetic Tests' stamp: 'RichardAlexanderGreen 7/2/2014 18:02'!testF230Plus	"Add fuzzy distributions."	|   median fuzzyA fuzzyB fuzzyC resultMedian expectedMedian  expectedMean actualMean diffMean diffMedian |	"A distribution is a Dictionary of p->f points	where p is the probability that observations will be less than or equal to f.	When the distribution is plotted 	 by mapping p->f to (f,p) = (x,y),	 you get an S-Curve."	fuzzyA := HumFuzzy quantity: 100.0 plusOrMinus: 1.0.	fuzzyB := HumFuzzy quantity: 100.0 plusOrMinus: 1.0.	fuzzyC := fuzzyA + fuzzyB.		resultMedian := fuzzyC median.	" Niave median is just . . . "	expectedMedian := (( fuzzyA median) + fuzzyB median). 	" In this case, the tail is not long. "	diffMedian := 1.00 - ( resultMedian / expectedMedian ) abs.	self assert:( diffMedian < 0.01 ).		"Examine expectedMean"	actualMean := fuzzyC mean.	expectedMean := ( fuzzyA mean ) + ( fuzzyB mean ).	diffMean := 1.00 - (( expectedMean / actualMean ) abs).	"The difference is typically less than 1% "	self assert: ( diffMean <  0.01 ).	"Transcript cr; show: 'testF230Plus diffMean = ', ( diffMean asString)."			! !!HumFuzzyTests methodsFor: 'Fuzzy Arithmetic Tests' stamp: 'RichardAlexanderGreen 7/2/2014 18:02'!testF125Mean	"Create a fuzzy quantity from a given distribution."	| distribution median fuzzy average |	"A distribution is a Dictionary of p->f points	where p is the probability that observations will be less than or equal to f.	When the distribution is plotted 	 by mapping p->f to (f,p) = (x,y),	 you get an S-Curve."	distribution := Dictionary new.	distribution		at: 0.50 put: 100;  "Estimate 100 hours"		at: 0.00 put: 0;    "Cannot be less than zero"  		at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."		at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."		at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."	fuzzy := HumFuzzy distribution: distribution.		self assert: 100 equals: ( fuzzy median ).	"Calculate mean"	average := fuzzy mean.	"the mean will be higher than the median because of long tail"	self assert: ( average > ( fuzzy median ) ).			! !!HumFuzzyTests methodsFor: 'Fuzzy Arithmetic Tests' stamp: 'RichardAlexanderGreen 7/2/2014 18:02'!testF170Product	"Multiply fuzzy distributions."	| distributionA distributionB median fuzzyA fuzzyB fuzzyC resultMedian expectedMedian diff   diffMedian actualMean expectedMean diffMean |	"A distribution is a Dictionary of p->f points	where p is the probability that observations will be less than or equal to f.	When the distribution is plotted 	 by mapping p->f to (f,p) = (x,y),	 you get an S-Curve."	distributionA := Dictionary new.	distributionB := Dictionary new.	distributionA		at: 0.50 put: 200;  "Estimate 200 hours"		at: 0.00 put: 0;    "Cannot be less than zero"  		at: 0.10 put: 100;   "Will come at less than half the estimate no more than 10% of time."		at: 0.90 put: 400;  "Will come at upto double the estimate no more than 90% of time."		at: 1.00 put: 800.  "At worst, the actual will be 4 times the estimate."	distributionB		at: 0.50 put: 100;  "Estimate 100 hours"		at: 0.00 put: 0;    "Cannot be less than zero"  		at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."		at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."		at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."	fuzzyA := HumFuzzy distribution: distributionA.	fuzzyB := HumFuzzy distribution: distributionB.	fuzzyC := fuzzyA * fuzzyB.			resultMedian := fuzzyC median.	" Niave median is just . . . "	expectedMedian := (( fuzzyA median) * (fuzzyB median) ). 	" But, because there is a long tail . . . "	diffMedian := ( resultMedian - expectedMedian ) abs.	"NOTE: Following will fail occasionally."	self assert: ( diffMedian closeTo: 0.0 ) not.			"Examine expectedMean"	actualMean := fuzzyC mean.	expectedMean := ( fuzzyA mean ) * ( fuzzyB mean ).	diffMean := 1.00 - (( expectedMean - actualMean ) abs).	"The difference will typically be less than 3%"	"It could be close to zero, but that will be a rare event."	self assert: ( diffMean closeTo: 0.0 ) not. 	self assert: ( diffMean < 0.03 ).	! !!HumFuzzyTests methodsFor: 'Fuzzy Arithmetic Tests' stamp: 'RichardAlexanderGreen 7/2/2014 18:02'!testF120Interpolation	"Create a fuzzy quantity from a given distribution."	| distribution median fuzzy |	"A distribution is a Dictionary of p->f points	where p is the probability that observations will be less than or equal to f.	When the distribution is plotted 	 by mapping p->f to (f,p) = (x,y),	 you get an S-Curve."	distribution := Dictionary new.	distribution		at: 0.50 put: 100;  "Estimate 100 hours"		at: 0.00 put: 0;    "Cannot be less than zero"  		at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."		at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."		at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."	fuzzy := HumFuzzy distribution: distribution.		self assert: 100 equals: ( fuzzy median ).	"Should be able to return given point value."	self assert: 100 equals: ( fuzzy atP: 0.50 ).  	"Force interpolation"	self assert: ( ( fuzzy atP: 0.70 ) closeTo: 150.0 ).	self assert: ( ( fuzzy atP: 0.05 ) closeTo:  25.0 ).	self assert: ( ( fuzzy atP: 0.95 ) closeTo: 300.0 ).		! !!HumFuzzyTests methodsFor: 'Fuzzy Arithmetic Tests' stamp: 'RichardAlexanderGreen 7/2/2014 18:02'!testF155Minus	"Subtract fuzzy distributions."	| distributionA distributionB median fuzzyA fuzzyB fuzzyC resultMedian expectedMedian diffMedian  minus actualMean expectedMean diffMean |	"A distribution is a Dictionary of p->f points	where p is the probability that observations will be less than or equal to f.	When the distribution is plotted 	 by mapping p->f to (f,p) = (x,y),	 you get an S-Curve."	distributionA := Dictionary new.	distributionB := Dictionary new.	distributionA		at: 0.50 put: 200;  "Estimate 200 hours"		at: 0.00 put: 0;    "Cannot be less than zero"  		at: 0.10 put: 100;   "Will come at less than half the estimate no more than 10% of time."		at: 0.90 put: 400;  "Will come at upto double the estimate no more than 90% of time."		at: 1.00 put: 800.  "At worst, the actual will be 4 times the estimate."	distributionB		at: 0.50 put: 100;  "Estimate 100 hours"		at: 0.00 put: 0;    "Cannot be less than zero"  		at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."		at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."		at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."	fuzzyA := HumFuzzy distribution: distributionA.	fuzzyB := HumFuzzy distribution: distributionB.	minus := #-.	fuzzyC := fuzzyA - fuzzyB.		resultMedian := fuzzyC median.	" Niave median is just . . . "	expectedMedian := (( fuzzyA median) - (fuzzyB median) ). 	" But, because there is a long tail . . . "	diffMedian := ( resultMedian - expectedMedian ) abs.	"NOTE: Following will fail occasionally."	self assert: ( diffMedian closeTo: 0.0 ) not.			"Examine expectedMean"	actualMean := fuzzyC mean.	expectedMean := ( fuzzyA mean ) - ( fuzzyB mean ).	diffMean := ( expectedMean - actualMean ) abs.	"The difference will typically be on the order of 5-15%"	"It could be close to zero, but that will be a rare event."	self assert: ( diffMean closeTo: 0.0 ) not. 		! !!HumFuzzyTests methodsFor: 'Fuzzy Arithmetic Tests' stamp: 'RichardAlexanderGreen 7/2/2014 18:02'!testF130Plus	"Add fuzzy distributions.	NOTE: The test assertions will fail occasionally. "	| distributionA distributionB median fuzzyA fuzzyB fuzzyC resultMedian expectedMedian  expectedMean actualMean diffMean diffMedian |	"A distribution is a Dictionary of p->f points	where p is the probability that observations will be less than or equal to f.	When the distribution is plotted 	 by mapping p->f to (f,p) = (x,y),	 you get an S-Curve."	distributionA := Dictionary new.	distributionA		at: 0.50 put: 100;  "Estimate 100 hours"		at: 0.00 put: 0;    "Cannot be less than zero"  		at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."		at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."		at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."	distributionB := distributionA.	fuzzyA := HumFuzzy distribution: distributionA.	fuzzyB := HumFuzzy distribution: distributionB.	fuzzyC := fuzzyA + fuzzyB.		resultMedian := fuzzyC median.	" Niave median is just . . . "	expectedMedian := (( fuzzyA median) + fuzzyB median). 	" But, because there is a long tail . . . "	self assert: ( resultMedian > expectedMedian ).	diffMedian := ( resultMedian - expectedMedian ) abs.	self assert:( diffMedian > ((expectedMedian) * 0.10) ).		"Examine expectedMean"	actualMean := fuzzyC mean.	expectedMean := ( fuzzyA mean ) + ( fuzzyB mean ).	diffMean := 1.00 - (( expectedMean / actualMean ) abs).	"Expect some difference due to long tail."	self assert: ( diffMean closeTo: 0.0 ) not. 	"The difference is typically about 3 to 4%; but is occasionally greater than 5%."	self assert: ( diffMean <  0.05 ).	"Transcript cr; show: 'testF130Plus diffMean = ', ( diffMean asString)."			! !!HumFuzzyTests methodsFor: 'Fuzzy Arithmetic Tests' stamp: 'RichardAlexanderGreen 7/2/2014 18:02'!testF100FuzzyArithmeticReadMe	"	Spurious precision is a form of disinformation because it hides the uncertainty in the result.	Hum`s fuzzy arithmetic feature provides facilities to calculate and present the uncertainty 	 that is inherent in all real-world situations.		Real-world numbers represent observations.	An observation is a measurement taken at a point in time using a specific method and set of calibrated sensors.	Measurements always have limited precision and accuracy.	That means that each measurement is associated with a distribution curve. (Typically a 'bell' curve of some kind.)		The goal of Hum`s fuzzy arithmetic is to correctly represent the uncertainty involved	  so that results may be stated with appropriate confidence intervals or probability curves (S-curves).	Use Cases:	. Software effort estimates tend to have distributions with long tails.	. Many measurements cannot be negative, and therefore, do not have symetric distributions.	. Simulations involve many estimates for inputs and process parameters.	. . Thus any 'result' can only be a probability distribution. 	. . . Otherwise, spurious precision is a form of disinformation.	. Engineering calculations are estimates that involve many sources of uncertainty and approximation.	. . Fuzzy arithmetic provides a way of representing those spreads in the results.	. . In effect, the fuzzy arithmetic automatically provides a sensitivity analysis.	"! !!HumFuzzyTests methodsFor: 'Fuzzy Arithmetic Tests' stamp: 'RichardAlexanderGreen 7/2/2014 18:02'!testF140Op	"Test op:with:"	| distributionA distributionB median fuzzyA fuzzyB fuzzyC resultMedian expectedMedian diff plus |	"A distribution is a Dictionary of p->f points	where p is the probability that observations will be less than or equal to f.	When the distribution is plotted 	 by mapping p->f to (f,p) = (x,y),	 you get an S-Curve."	distributionA := Dictionary new.	distributionA		at: 0.50 put: 100;  "Estimate 100 hours"		at: 0.00 put: 0;    "Cannot be less than zero"  		at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."		at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."		at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."	distributionB := distributionA.	fuzzyA := HumFuzzy distribution: distributionA.	fuzzyB := HumFuzzy distribution: distributionB.	plus := #+.	fuzzyC := fuzzyA op: plus with: fuzzyB.		resultMedian := fuzzyC median.	" Niave median is just . . . "	expectedMedian := (( fuzzyA median) + fuzzyB median). 	" But, because there is a long tail . . . "	self assert: ( resultMedian > expectedMedian ).	diff := ( resultMedian - expectedMedian ) abs.	self assert:( diff > ((expectedMedian) * 0.10) ).	! !HumTestCase subclass: #HumProgrammersAssistantTests	instanceVariableNames: 'eh'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumProgrammersAssistantTests commentStamp: 'RichardAlexanderGreen 1/2/2012 14:42' prior: 0!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Programmer Assistant (PA) User-Dialogs%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%A. Ontology Actions   1. New ontology.   2. Save ontology on file. (Save As on new file)   3. Load ontology from file(futures:)   4. Merge ontology from (TBD: file or another PA).   5. Test run ontology.   6. Deploy ontology?  (??? What does deploy portend ???)B. Frame Editor Actions   1. Usual text edit actions:      a) commands: (copy, cut, paste, un-do, save, open, print?, close window)      b) cursor moves: (up, down, left, right, top, bottom, . . .)   2. PA-specific actions:      a) [Line updated] event causes the logical-line and frame to be checked.         (1) The logical-line is rendered. 	           Keywords and nouns are emphasized. Nouns have links.          (2) If the logical-line is not understood (no definition in ontology or DSL),                the line is flagged (with a question-mark).         (3) If a noun lacks an antecedent in the frame, the noun is flagged (color code).      b) [Insert/Append Instruction] - Instructions are indented.         (1) In an action frame,                the automatic indent matches the preceding statements indent                unless it was a control statement (ending with a colon).                   And then, the indentation is increased by one.         (2) In plan and dialog frames,                instructions have only one level of indent                because control statements are not allowed in those contexts.         (3) In dialog frames,                the user indicates an instruction by starting the line with dot [tab].      c) [Submit frame] command causes the ontology to be          (1) updated.         (2) versioned.         (3) re-evaluated. (problems flagged)         (4) re-displayed. (all views rebuilt)      d) [Test Dialog] - in dialog run-time with mock agents.!!HumProgrammersAssistantTests methodsFor: 'pa900LoadParseCompileView' stamp: 'RichardAlexanderGreen 6/13/2014 20:29'!test920LoadFromTextFileAndRenderAsHTML	"Load from pizza-ontology.txt"	| fileName pa |	fileName := 'Pizza-Ontology.txt'.	pa := HumProgrammersAssistant new.	pa loadOntologyFromTextFileNamed: fileName.	pa ontology compileAllFrames.	pa ontology view renderAsHTMLonFileNamed: 'Pizza-Ontology.html'.	! !!HumProgrammersAssistantTests methodsFor: 'pa900LoadParseCompileView' stamp: 'RichardAlexanderGreen 12/1/2014 18:12'!test924LoadClubMechAndRenderAsHTML	"Load from pizza-ontology.txt"	| fileName pa html |	fileName := 'ClubMechV02.txt'.	pa := HumProgrammersAssistant new.	pa loadOntologyFromTextFileNamed: fileName.	pa ontology compileAllFrames.	self assert: ( pa ontology frames anySatisfy: [:frame | frame title beginsWith: 'Context:']).
	html := pa ontology view renderAsHTMLonFileNamed: 'ClubMechV02.html'.	self assert: ('*Context:*' match: html).	! !!HumProgrammersAssistantTests methodsFor: 'pa900LoadParseCompileView' stamp: 'RichardAlexanderGreen 1/16/2015 17:34'!test923LoadBaristaAndRenderAsHTML	"Load from pizza-ontology.txt"	| fileName pa |	fileName := 'Barista.txt'.	pa := HumProgrammersAssistant new.	pa loadOntologyFromTextFileNamed: fileName.	pa ontology compileAllFrames.	pa ontology view renderAsHTMLonFileNamed: 'Barista.html'.	! !!HumProgrammersAssistantTests methodsFor: 'pa900LoadParseCompileView' stamp: 'RichardAlexanderGreen 1/22/2015 18:03'!test930LoadActionFrame	"Load, parse, and render a slightly tricky action frame."	| stream pa frames html ideal |	stream := ReadWriteStream on: ''.	stream basicNextPutAll:'Role: Order-Checker. Action: Give carriers to the customer. . Match carrier to order. . Move matched carrier to scale. . (This catches most errors with carrier sequencing.) . If scale weight matches order`s expected weight: . . Release carriers to customer.[ native] . Else : . . (Most likely error is that carrier is out of sequence.)  . . Check for carrier-sequence-error. . . (Now what?)'.	pa := HumProgrammersAssistant new.	pa loadOntologyFromTextStream: stream.	frames := pa ontology frames asOrderedCollection.	self expect: 1 actual: (frames count: [:frame | frame isKindOf: HumFrame4Action ]).	"actionFrame := frames at: 1."	html := pa ontology view renderAsHTMLonFileNamed: 'test930LoadActionFrame.html'.	self assert: ('*Role:*' match: html).	self assert: ('*Action:*' match: html).	self assert: ('*class="indent2"*class="indent1"*class="indent2"*' match: html) 			description: 'Should see indent pattern.'.	self assert: ('*<k>*</k>*<k>*</k>*' match: html) description: 'Should see 2 keyword markers.'.	ideal := '<html>  <head>    <title>      (untitled) -- No title yet.    </title>    <style>        body {font-family: MONOSPACE;}        heading {font-size: X-LARGE; }              title1, title2, title3, title4, title5 {font-weight: BOLD;}        title1 {font-size: 200%;}        title2 {font-size: 150%;}        title3 {font-size: 125%;}        title4 {font-size: 100%;}        frameTitle {color: BLUE; font-size: LARGER; font-weight: BOLD;}                n, noun {color: PURPLE;}        k, keyword {font-weight: BOLD;}        r, role {font-style: ITALIC;font-weight: BOLD;}                statement {color: BLUE;}        c, comment {color: GREEN;}        annotation {}                pattern {}        markup {font-family: MONOSPACE;}        widget {color: RED;}                        HumFrame {}        frameLine, CommentLine, DictionaryLine, PreconditionLine  {margin-left: 1em;}        InstructionLine {margin-left: 1em; color: BLUE;}          InstructionLine.indent1 {margin-left: 1em;}            InstructionLine.indent2 {margin-left: 2em;}            InstructionLine.indent3 {margin-left: 3em;}            InstructionLine.indent4 {margin-left: 4em;}                      textarea {vertical-align: top;}          form {border-style: outset; padding: 1em;}        table {}        th {background: CYAN;}        td {background: LIGHTGREY;}    </style>  </head>  <body>    <heading>      Ontology: (untitled) -- No title yet.    </heading>    <hr/>    <HumFrame>      <frameTitle>        Order-Checker: Give carriers to the customer.      </frameTitle>      <br/><b>Role: </b>      <role>        Order-Checker.      </role>      <br/><b>Action: </b>      <action>        Give carriers to the customer.      </action>      <br/>      <InstructionLine class="indent1" >        <statement>          Match carrier to order.        </statement>      </InstructionLine>      <br/>      <InstructionLine class="indent1" >        <statement>          Move matched carrier to scale.        </statement>      </InstructionLine>      <br/>      <InstructionLine class="indent1" >        <comment>          (This catches most errors with carrier sequencing.)        </comment>      </InstructionLine>      <br/>      <InstructionLine class="indent1" >        <statement>          <k>If</k> scale weight          <k>matches</k> order` s expected weight:        </statement>      </InstructionLine>      <br/>      <InstructionLine class="indent2" >        <statement>          Release carriers to customer.[ native]        </statement>      </InstructionLine>      <br/>      <InstructionLine class="indent1" >        <statement>          <k>Else</k>:        </statement>      </InstructionLine>      <br/>      <InstructionLine class="indent2" >        <comment>          (Most likely error is that carrier is out of sequence.)        </comment>      </InstructionLine>      <br/>      <InstructionLine class="indent2" >        <statement>          Check for carrier-sequence-error.        </statement>      </InstructionLine>      <br/>      <InstructionLine class="indent2" >        <comment>          (Now what?)        </comment>      </InstructionLine>    </HumFrame>    <hr/>  </body></html>'.	HumCalculator writeString: ideal toFileNamed: 'test930LoadActionFrameIdeal.html'.	"q := HumCalculator string: html isLike: ideal.	self assert: q."	HumCalculator diffCandidate: html againstIdeal: ideal showing: 3.				! !!HumProgrammersAssistantTests methodsFor: 'pa900LoadParseCompileView' stamp: 'RichardAlexanderGreen 1/6/2015 08:37'!test912LoadDonutShop	"Load from pizza-ontology.txt"	|  pa fileName frames |	fileName := 'DonutShopV05.txt'.	pa := HumProgrammersAssistant new.	pa loadOntologyFromTextFileNamed: fileName.	frames := pa ontology frames.	self expect: 81 actual: ( frames size ).	self assert: ( frames anySatisfy: [:frame | frame isKindOf: HumFrame4Vignette ]).	! !!HumProgrammersAssistantTests methodsFor: 'pa900LoadParseCompileView' stamp: 'RichardAlexanderGreen 6/17/2014 19:07'!test910LoadFromTextFile	"Load from pizza-ontology.txt"	|  pa fileName |	fileName := 'pizza-ontology.txt'.	pa := HumProgrammersAssistant new.	pa loadOntologyFromTextFileNamed: fileName.	self assert: ( pa ontology frames size = 25 ).	self assert: ( pa ontology frames anySatisfy: [:frame | frame isKindOf: HumFrame4Vignette ]).	! !!HumProgrammersAssistantTests methodsFor: 'pa900LoadParseCompileView' stamp: 'RichardAlexanderGreen 1/22/2015 14:51'!test913LoadBarista	"Load from pizza-ontology.txt"	|  pa fileName frames |	fileName := 'Barista.txt'.	pa := HumProgrammersAssistant new.	pa loadOntologyFromTextFileNamed: fileName.	frames := pa ontology frames.	self expect: 13 actual: ( frames size ).	"We want at least one of each type of frame."	self assert: ( frames anySatisfy: [:frame | frame isKindOf: HumFrame4Dictionary ]).	self assert: ( frames anySatisfy: [:frame | frame isKindOf: HumFrame4Vignette ]).	self assert: ( frames anySatisfy: [:frame | frame isKindOf: HumFrame4Comment ]).	self assert: ( frames anySatisfy: [:frame | frame isKindOf: HumFrame4Action ]).	self assert: ( frames anySatisfy: [:frame | frame isKindOf: HumFrame4View ]).	self assert: ( frames anySatisfy: [:frame | frame isKindOf: HumFrame4Plan ]).	! !!HumProgrammersAssistantTests methodsFor: 'pa900LoadParseCompileView' stamp: 'RichardAlexanderGreen 1/2/2015 21:06'!test914LoadClubMech	"Load from pizza-ontology.txt"	|  pa fileName frames |	"Transcript cr; show: 'test914LoadClubMech begins'."	fileName := 'ClubMechV02.txt'.	pa := HumProgrammersAssistant new.	pa loadOntologyFromTextFileNamed: fileName.	frames := pa ontology frames.	self assert: (pa ontology contextVignettes size > 0).	"Transcript cr; show: 'test914LoadClubMech ends'."	self expect: 20 actual: ( frames size ).	self assert: ( frames anySatisfy: [:frame | frame isKindOf: HumFrame4Vignette ]).	! !!HumProgrammersAssistantTests methodsFor: 'pa900LoadParseCompileView' stamp: 'RichardAlexanderGreen 1/5/2015 09:52'!test922LoadDonutShopAndRenderAsHTML	"Load from pizza-ontology.txt"	| fileName pa |	fileName := 'DonutShopV05.txt'.	pa := HumProgrammersAssistant new.	pa loadOntologyFromTextFileNamed: fileName.	pa ontology compileAllFrames.	pa ontology view renderAsHTMLonFileNamed: 'DonutShopV05.html'.	! !!HumProgrammersAssistantTests methodsFor: 'pa710parseFrameLineSource' stamp: 'RichardAlexanderGreen 1/23/2015 11:11'!test700parseSourceLine	"An instruction looks like: <role> : <statement> . (comment) [annotation]"	"The role prefix is optional - It only appears when one role is delegating to another."	"Comments and annotation are optional."! !!HumProgrammersAssistantTests methodsFor: 'pa710parseFrameLineSource' stamp: 'RichardAlexanderGreen 1/23/2015 11:13'!test741getOneWidget	"The frame editor instance knows what kind of frame it is editing.	"	|  markupLine widgets |	markupLine :=  HumMarkupLine source: 'This string contains a widget between brackets: [widget-content]'.	widgets := markupLine widgets.		self assert: ( widgets includes: '[widget-content]')		! !!HumProgrammersAssistantTests methodsFor: 'pa710parseFrameLineSource' stamp: 'RichardAlexanderGreen 10/8/2014 10:12'!test730getAnnotation	"Some framelines have annotations. Some don't."	| pa source annotation remainder |	pa := HumProgrammersAssistant new.	source := 'Equipment is washed and ready. [Assumed.]'.	annotation := pa getAnnotationFromSource: source.	self expect: '[Assumed.]' actual: annotation.	remainder := pa removeAnnotationFromSource: source.	self expect: 'Equipment is washed and ready.' actual: remainder.! !!HumProgrammersAssistantTests methodsFor: 'pa710parseFrameLineSource' stamp: 'RichardAlexanderGreen 1/30/2014 11:09'!test720getComment	"Some framelines have comments. Some don't."	| pa source comment remainder |	pa := HumProgrammersAssistant new.	source := 'Action: Bake a cake per recipe. (Recipe is a noun.)'.	comment := pa getCommentFromSource: source.	self assert: '(Recipe is a noun.)' equals: comment.	remainder := pa removeCommentFromSource: source.	self assert: 'Action: Bake a cake per recipe.' equals: remainder.! !!HumProgrammersAssistantTests methodsFor: 'pa710parseFrameLineSource' stamp: 'RichardAlexanderGreen 1/23/2015 11:13'!test742getTwoWidgets""	| markupLine widgets |	markupLine :=  HumMarkupLine 						source: 'This string contains two widgets: [widget-content-1] and also [widget-content-2]'.	widgets := markupLine widgets.		self assert: ( widgets includes: '[widget-content-1]').	self assert: ( widgets includes: '[widget-content-2]').	! !!HumProgrammersAssistantTests methodsFor: 'pa710parseFrameLineSource' stamp: 'RichardAlexanderGreen 1/23/2015 11:13'!test743getTwoWidgetsAndButton""	| markupLine widgets |	markupLine :=  HumMarkupLine 						source: 'This string contains two widgets: [widget-content-1] and also [widget-content-2] and [[button]]'.	widgets := markupLine widgets.		self assert: ( widgets includes: '[widget-content-1]').	self assert: ( widgets includes: '[widget-content-2]').	self assert: ( widgets includes: '[[button]]').	! !!HumProgrammersAssistantTests methodsFor: 'pa710parseFrameLineSource' stamp: 'RichardAlexanderGreen 1/30/2014 10:56'!test710getLabel	"Some framelines have labels. Some don't."	| pa source label remainder |	pa := HumProgrammersAssistant new.	source := 'Action: Bake a cake per recipe.'.	label := pa getLabelFromSource: source.	self assert: 'Action' equals: label.	remainder := pa removeLabelFromSource: source.	self assert: 'Bake a cake per recipe.' equals: remainder.! !!HumProgrammersAssistantTests methodsFor: 'pa710parseFrameLineSource' stamp: 'RichardAlexanderGreen 10/8/2014 10:25'!test725getComment	"Some framelines have comments. Some don't."	| pa source comment remainder |	pa := HumProgrammersAssistant new.	source := 'Action: Bake a cake per recipe. '.	comment := pa getCommentFromSource: source.	self expect: nil actual: comment.	remainder := pa removeCommentFromSource: source.	self expect: source trimBoth actual: remainder.! !!HumProgrammersAssistantTests methodsFor: 'pa710parseFrameLineSource' stamp: 'RichardAlexanderGreen 10/8/2014 10:21'!test735getAnnotation	"Some framelines have annotations. Some don't."	| pa source annotation remainder |	pa := HumProgrammersAssistant new.	source := 'Equipment is washed and ready. (There is no annotation here.)'.	annotation := pa getAnnotationFromSource: source.	self expect: nil actual: annotation.	remainder := pa removeAnnotationFromSource: source.	self expect: source actual: remainder.! !!HumProgrammersAssistantTests methodsFor: 'pa610Store In Ontology' stamp: 'RichardAlexanderGreen 1/23/2014 14:55'!test660storeFrame4Vignette	"Store a dictionary frame.	"	| frameUpdater ontology |	ontology := HumOntology new.				ontology := HumOntology new.			"Initialize for a Dialog Frame."	frameUpdater := HumFrameUpdater ontology: ontology vignetteContext: 'Expecting Hello.' pattern: 'Knock, knock.'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Vignette ).		"Add response lines."	"There are two kinds of resonse, verbal responses and actions."	frameUpdater addVignetteResponse: 'Who is there?'.	frameUpdater addVignetteInstruction: 'Next context "Expecting who.".'.	"Run store and fetch test routine"	self storeInOntology: ontology fromFrameUpdater: frameUpdater.	! !!HumProgrammersAssistantTests methodsFor: 'pa610Store In Ontology' stamp: 'RichardAlexanderGreen 1/23/2014 14:54'!test650storeFrame4Dictionary	"Store a dictionary frame.	"	| frameUpdater ontology |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameUpdater := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	"Add dictionary lines."	"attributes"	frameUpdater addDictionaryLine: 'Recipe attributes include recipe-name, description, ingrediants steps.'.	"set collection"	frameUpdater addDictionaryLine: 'Recipe includes a set of ingrediants.'.	"list collection"	frameUpdater addDictionaryLine: 'Recipe includes a list of steps.'.	"Attribute used in  set above is an entity with its own attributes. Entities are members of set."	frameUpdater addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	"Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"	frameUpdater addDictionaryLine: 'Step attributes include step-number, step-description'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Dictionary ).				"Run store and fetch test routine"	self storeInOntology: ontology fromFrameUpdater: frameUpdater.	! !!HumProgrammersAssistantTests methodsFor: 'pa610Store In Ontology' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!test620storeFrame4Plan	"Store plan frame.	"	| frameUpdater ontology |	ontology := HumOntology new.		"Initialize for a Plan Frame."	frameUpdater := HumFrameUpdater ontology: ontology goal: 'Cake is baked according to recipe..'.	"Append precondition lines."	frameUpdater appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameUpdater appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.	"Finish with action statement."	frameUpdater appendRole: 'Oven' action: 'Bake the pan in the oven for the time given in the recipe.' .		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Plan ).		self assert: (frameUpdater frame frameLines size = 3 ).		"Run store and fetch test routine"	self storeInOntology: ontology fromFrameUpdater: frameUpdater.	! !!HumProgrammersAssistantTests methodsFor: 'pa610Store In Ontology' stamp: 'RichardAlexanderGreen 3/17/2015 12:06'!test630storeFrame4Action	"Store an action frame.	"	| frameUpdater ontology |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameUpdater := HumFrameUpdater ontology: ontology  	                                               role: 'Role' action: 'Bake the pan in the oven for the time given in the recipe.'.	"Append instruction lines."	frameUpdater appendInstructionStatement: 'Open the oven door.'.	frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.	frameUpdater appendInstructionStatement: 'Close the oven door.'.	"Append an instruction that is delegated"	frameUpdater appendInstructionRole: 'Oven' statement: 'Bake for the time given.'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Action ).			self assert: ( frameUpdater frame frameLines size = 4 ).		"Run store and fetch test routine"	self storeInOntology: ontology fromFrameUpdater: frameUpdater.		! !!HumProgrammersAssistantTests methodsFor: 'pa610Store In Ontology' stamp: 'RichardAlexanderGreen 1/23/2014 14:54'!test640storeFrame4View	"Store a view frame.	"	| frameUpdater ontology |	ontology := HumOntology new.		"Initialize for a View Frame."	frameUpdater := HumFrameUpdater ontology: ontology viewEntity: 'recipe.'.	"Add markup lines."	frameUpdater addMarkUp: '!!!! Recipe'.	frameUpdater addMarkUp: ' recipe-name: [name]'.	frameUpdater addMarkUp: '   description: [description 5]'.	frameUpdater addMarkUp: '   ingredients: [ingredients]'.	frameUpdater addMarkUp: '            steps: [steps]'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4View ).			"Run store and fetch test routine"	self storeInOntology: ontology fromFrameUpdater: frameUpdater.	! !!HumProgrammersAssistantTests methodsFor: 'pa610Store In Ontology' stamp: 'RichardAlexanderGreen 4/20/2015 09:33'!storeInOntology: aHumOntology fromFrameUpdater: frameUpdater1	| frame1 identifier frameUpdater2 frame2 frameUpdater3 frame3 |	"The frame editor receives the command to store the frame from the user interface (Scribe)."	frameUpdater1 storeFrameInOntology.		"The frame will now have a uniqueIdentifier."	frame1 := frameUpdater1 frame.	self assert: ( frame1 isKindOf: HumFrame ).	identifier := frame1 uniqueIdentifier.	self assert: ( identifier isKindOf: HumIdentifier ).		"We can use the identifier to fetch the frame into another frameUpdater."	frameUpdater2 := HumFrameUpdater ontology: aHumOntology loadFrameByIdentifier: identifier.	self assert: (frameUpdater2 isKindOf: HumFrameUpdater ).		"Check the content."	frame2 := frameUpdater2 frame.	self assert: ( frame2 isKindOf:  (frame1 class) ).	self assert: ( frame1 titleLine = frame2 titleLine ).	self assert: ( frame1 titleLine sameAs: frame2 titleLine ).	self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).	self assert: ( frame1 frameLines at: 1) = ( frame2 frameLines at: 1 ).	self assert: (( frame1 frameLines at: 1) sameAs: ( frame2 frameLines at: 1 )).		frameUpdater3 := HumFrameUpdater ontology: aHumOntology loadFrameByName: (frame1 frameName).	self assert: (frameUpdater2 isKindOf: HumFrameUpdater ).		"Check the content."	frame3 := frameUpdater3 frame.	self assert: ( frame3 isKindOf:  (frame1 class) ).	self assert: ( frame1 titleLine = frame3 titleLine ).	self assert: ( frame1 titleLine sameAs: frame3 titleLine ).	self assert: ( frame1 frameLines size ) = ( frame3 frameLines size ).	self assert: ( frame1 frameLines at: 1) = ( frame3 frameLines at: 1 ).	self assert: (( frame1 frameLines at: 1) sameAs: ( frame3 frameLines at: 1 )).	! !!HumProgrammersAssistantTests methodsFor: 'pa410 Compile frame' stamp: 'RichardAlexanderGreen 4/20/2015 08:33'!test431compileFrame4Action	"In this case, 'compile' means adding the frame to the ontology,	  and the syntax checks for problems that would prevent the frame from executing. 	"	| actionSourceString frameUpdater ontology errors instructionSequence |	ontology := HumOntology new.		"Initialize for an Action Frame."	actionSourceString :=  'Bake the pan in the oven for the time given in the recipe.'.	frameUpdater := HumFrameUpdater ontology: ontology role: 'Baker' action:  actionSourceString.	"Append instruction lines."	frameUpdater appendInstructionStatement: 'Open the oven door.'.	frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.	frameUpdater appendInstructionStatement: 'Close the oven door.'.	frameUpdater appendInstructionStatement: 'Set the oven-temperature per recipe.'.		"Append an instruction that is delegated"	frameUpdater appendInstructionRole: 'Oven' statement: 'Bake for the baking-time given in the recipe.'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Action ).	self expect: 5 actual: ( frameUpdater frame frameLines size ) description: '5 lines expected'.		ontology addNouns: #( 'recipe' 'oven' 'pan' 'baking-time' 'oven-temperature' ).		errors := frameUpdater checkFrameSyntax.	self assert: ( errors count: [ :error | '*no known nouns*' match: error ] ) = 0.		errors := frameUpdater compileToOntology: ontology.	self expect: 5 actual: ( frameUpdater frame frameLines size ) description: 'should still be 5 lines'.		self assert: (errors size) = 7.		"Now we can get the action from the ontology"	self assert: ( ( ontology getRole: 'Baker'  action:  actionSourceString ) isKindOf: HumStatement ).			"Now we can also get the instruction sequence "	instructionSequence := ( ontology instructionsForRole: 'Baker' action: actionSourceString ).	self assert: ( instructionSequence isKindOf: OrderedCollection ).	self expect: 5 actual: ( instructionSequence size ).	self assert:( ( instructionSequence at: 1) isKindOf: HumInstructionLine ).		"And the role`s actions includes "	self assert: (( ontology actionsOf: 'Baker' ) include: actionSourceString ).		! !!HumProgrammersAssistantTests methodsFor: 'pa410 Compile frame' stamp: 'RichardAlexanderGreen 1/21/2015 20:21'!test450compileFrame4Dictionary	"In this context, 	'compile' means that the ontology will be updated with nouns and their supertypes.	"	| frameUpdater ontology errors nounSubtypes |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameUpdater := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	"Add dictionary lines."	"supertype"	frameUpdater addDictionaryLine: 'Description is a text.'.	"attributes"	frameUpdater addDictionaryLine: 'Recipe attributes include recipe-name, recipe-description, ingredients, steps.'.	"set collection"	frameUpdater addDictionaryLine: 'Recipe includes a set of ingredients.'.	"list collection"	frameUpdater addDictionaryLine: 'Recipe includes a list of steps.'.	"Attribute used in  set above is an entity with its own attributes. Entities are members of set."	frameUpdater addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, substitute.'.	"Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"	frameUpdater addDictionaryLine: 'Step attributes include step-number, step-description'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Dictionary ).		errors := frameUpdater compileToOntology: ontology.		"There are no syntax errors."	self assert: ( errors isEmpty ).		"Check that ontology has all that stuff."	self assert: ( ontology nouns includesAllOf: #( 'recipe' 'recipe-name' 'description' 'ingredient' 'step' 'ingredient-name' 'quantity' 'substitute' 'step-number' 'step-description' )).		"Check that the supertypes are recorded also."	nounSubtypes := ontology nounSubtypes.	self expect: {('text'->'description'). ('set'->'ingredients'). ('list'->'steps')} 	     actual: nounSubtypes asArray.		! !!HumProgrammersAssistantTests methodsFor: 'pa410 Compile frame' stamp: 'RichardAlexanderGreen 6/9/2014 08:53'!test446compileFrame4View	"Compile a view frame.	"	| frameUpdater ontology errors testMe |		testMe := true.	testMe ifFalse: [ Transcript cr; show: 'test446compileFrame4View is turned off.'; cr. ^self].		ontology := HumOntology new.		"Initialize for a View Frame."	frameUpdater := HumFrameUpdater ontology: ontology viewEntity: 'recipe.'.	"Add markup lines."	frameUpdater addMarkUp: '!!!! Recipe'.	frameUpdater addMarkUp: ' recipe-name: [name]'.	frameUpdater addMarkUp: '   description: [description 5]'.	frameUpdater addMarkUp: '   ingredients: [ingredients]'.	frameUpdater addMarkUp: '            steps: [steps]'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4View ).		ontology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).			"Expect no complaints about no nouns."	errors := frameUpdater compileToOntology: ontology.	self assert: ( errors isEmpty  ).		! !!HumProgrammersAssistantTests methodsFor: 'pa410 Compile frame' stamp: 'RichardAlexanderGreen 4/20/2015 08:28'!test421compileFrame4Plan	"In this context, 'compile' means that the plan frame is inserted into the ontology,	  and the frame is checked for problems that would prevent the plan from executing.	"	| frameUpdater ontology errors goalSourceString frameIn frameOut  |	ontology := HumOntology new.	"Initialize for a Plan Frame."	goalSourceString := 'Cake is baked according to recipe.'.	frameUpdater := HumFrameUpdater ontology: ontology goal: goalSourceString.	"Append precondition lines."	frameUpdater appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameUpdater appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.	"Finish with action statement."	frameUpdater appendRole: 'Oven' action: 'Bake the pan in the oven for the time given in the recipe.' .		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Plan ).		"Every line has recipe as a noun."	ontology addNouns: #( 'recipe' ).		"Expect no complaints about no nouns. "	errors := frameUpdater checkFrameSyntax.	self assert: ( errors count: [ :error | '*no nouns*' match: error ]  ) = 0.		errors := frameUpdater compileToOntology: ontology.		self assert: ( errors size = 6 ).		"Now we should see frame in the ontology."	frameIn := frameUpdater frame.	frameOut := ontology getPlanFrameForGoal: goalSourceString. 	self assert: ( frameOut = frameIn ).	! !!HumProgrammersAssistantTests methodsFor: 'pa410 Compile frame' stamp: 'RichardAlexanderGreen 1/23/2014 14:41'!test461compileFrame4Vignette	"Compile a dialog vignette.	"	| frameUpdater1 frameUpdater2 frameUpdater3 ontology frame1 frame2 frame3 |	ontology := HumOntology new.			"Initialize a Vignette Frame."	frameUpdater1 := HumFrameUpdater ontology: ontology 												vignetteContext: 'Expecting Hello.' 																pattern: 'Knock, knock.'.	frameUpdater1 addVignetteResponse: 'Who is there?'.	frameUpdater1 nextVignetteContext: 'Expecting first name'.	frameUpdater1 compileToOntology: ontology.	 	frameUpdater2 := HumFrameUpdater ontology: ontology 													vignetteContext: 'Expecting first name.' 																	pattern: '[first-name]'.	frameUpdater2 addVignetteResponse: '[first-name] who?'.	frameUpdater2 nextVignetteContext: 'Expecting whole-name'.	frameUpdater2 compileToOntology: ontology.		frameUpdater3 :=  HumFrameUpdater ontology: ontology 													vignetteContext: 'Expecting whole-name.' 																	pattern: '[first-name] [last-name]'.	frameUpdater3 addVignetteResponse: 'Hello [first-name] [last-name]. What do you want to do?'.	frameUpdater3 addVignetteInstruction: 'Ask menu.'.	frameUpdater3 compileToOntology: ontology.		"The ontology should have these frames."	frame1 := frameUpdater1 frame.	frame2 := frameUpdater2 frame.	frame3 := frameUpdater3 frame.	self assert: ( frame1 uniqueIdentifier < frame2 uniqueIdentifier).	self assert: ( frame2 uniqueIdentifier < frame3 uniqueIdentifier ).	self assert: ( ( ontology fetchFrameByIdentifier: ( frame1 uniqueIdentifier  )) = frame1 ).	self assert: ( ( ontology fetchFrameByIdentifier: ( frame2 uniqueIdentifier  )) = frame2 ).	self assert: ( ( ontology fetchFrameByIdentifier: ( frame3 uniqueIdentifier  )) = frame3 ).		""							! !!HumProgrammersAssistantTests methodsFor: 'pa210 Create frame' stamp: 'RichardAlexanderGreen 1/23/2014 14:39'!test250createFrame4Dictionary	"The frame editor instance knows what kind of frame it is editing.	"	| frameUpdater ontology |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameUpdater := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.		"Add dictionary lines."	"attributes"	frameUpdater addDictionaryLine: 'Recipe attributes include recipe-name, description, ingrediants steps.'.	"set collection"	frameUpdater addDictionaryLine: 'Recipe includes a set of ingrediants.'.	"list collection"	frameUpdater addDictionaryLine: 'Recipe includes a list of steps.'.	"Attribute used in  set above is an entity with its own attributes. Entities are members of set."	frameUpdater addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	"Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"	frameUpdater addDictionaryLine: 'Step attributes include step-number, step-description'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Dictionary ).	! !!HumProgrammersAssistantTests methodsFor: 'pa210 Create frame' stamp: 'RichardAlexanderGreen 1/23/2014 14:38'!test240createFrame4View	"The frame editor instance knows what kind of frame it is editing.	"	| frameUpdater ontology |	ontology := HumOntology new.		"Initialize for a View Frame."	frameUpdater := HumFrameUpdater ontology: ontology viewEntity: 'recipe.'.		"Add markup lines."	frameUpdater addMarkUp: '!!!! Recipe'.	frameUpdater addMarkUp: ' recipe-name: [name]'.	frameUpdater addMarkUp: '   description: [description 5]'.	frameUpdater addMarkUp: '   ingredients: [ingredients]'.	frameUpdater addMarkUp: '            steps: [steps]'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4View ).	! !!HumProgrammersAssistantTests methodsFor: 'pa210 Create frame' stamp: 'RichardAlexanderGreen 6/12/2014 16:14'!test261updateFrame4Vignette	"Create a dialog vignette.	"	| frameUpdater ontology |	ontology := HumOntology new.			"Initialize for a Dialog Frame."	frameUpdater := HumFrameUpdater ontology: ontology vignetteContext: 'Expecting Hello.' pattern: 'Knock, knock.'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Vignette ).		"Add response lines."	"There are two kinds of resonse, verbal responses and actions."	frameUpdater addVignetteResponse: 'Who is there?'.	frameUpdater addVignetteInstruction: 'Next context "Expecting who.".'.		self assert: ( ( frameUpdater frame frameLines at: 1 ) 									sameAs:  ( HumVignetteResponseLine source: 'S: Who is there?' ) ).	self assert: ( ( frameUpdater frame frameLines at: 2 ) 									sameAs:  ( HumInstructionLine statement: 'Next context "Expecting who.".' ) ).	self assert: ( ( frameUpdater frame responseLines at: 1 ) 									sameAs:  ( HumMarkupLine source: 'Who is there?' ) ).	self assert: ( ( frameUpdater frame instructionLines at: 1 ) 									sameAs:  ( HumInstructionLine statement: 'Next context "Expecting who.".' ) ).							! !!HumProgrammersAssistantTests methodsFor: 'pa210 Create frame' stamp: 'RichardAlexanderGreen 1/23/2014 14:39'!test260createFrame4Vignette	"Create a dialog vignette..	"	| frameUpdater ontology |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameUpdater := HumFrameUpdater ontology: ontology vignetteContext: 'hello' pattern: 'Knock, knock.'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Vignette ).	! !!HumProgrammersAssistantTests methodsFor: 'pa210 Create frame' stamp: 'RichardAlexanderGreen 4/20/2015 09:48'!test231formatFrame4Action  "The frame editor instance knows what kind of frame it is editing.  "  | frameUpdater ontology prettyPrint q ideal |  ontology := HumOntology new.    "Initialize for an Action Frame."  frameUpdater := HumFrameUpdater ontology: ontology                                      role: 'Baker'                                 action: 'Bake the pan in the oven for the time given in the recipe.'.  "Append instruction lines."  frameUpdater appendInstructionStatement: 'Open the oven door.'.  frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.  frameUpdater appendInstructionStatement: 'Close the oven door.'.    "Append an instruction that is delegated"  frameUpdater appendInstructionRole: 'Oven' statement: 'Bake for the time given.'.    self assert: ( frameUpdater notNil ).  self assert: ( frameUpdater frame isMemberOf: HumFrame4Action ).    self assert: ( frameUpdater frame frameLines size = 4 ).    prettyPrint := frameUpdater prettyPrint.  ideal := '<HumFrame>  <frameTitle>    Baker: Bake the pan in the oven for the time given in the recipe.  </frameTitle><br/><b>Role: </b>  <role> Baker.</role><br/><b>Action: </b>  <action> Bake the pan in the oven for the time given in the recipe. </action><br/>	<InstructionLine class="indent1" >		<statement>	 		Open the oven door.		</statement>	</InstructionLine><br/>  <InstructionLine class="indent1" >    <statement>       Place the pan in the oven.    </statement>  </InstructionLine><br/>  <InstructionLine class="indent1" >    <statement>      Close the oven door.    </statement>  </InstructionLine><br/>  <InstructionLine class="indent1" >    <role>Oven</role>:  <statement> Bake for the time given. </statement>  </InstructionLine></HumFrame>'.  q := HumCalculator string: prettyPrint isLike: ideal.  self assert: q description: 'Expecting prettyPrint to match ideal'    ! !!HumProgrammersAssistantTests methodsFor: 'pa210 Create frame' stamp: 'RichardAlexanderGreen 3/17/2015 12:06'!test230createFrame4Action	"The frame editor instance knows what kind of frame it is editing.	"	| frameUpdater ontology |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameUpdater := HumFrameUpdater ontology: ontology  	                                  role: 'Role' 																action: 'Bake the pan in the oven for the time given in the recipe.'.	"Append instruction lines."	frameUpdater appendInstructionStatement: 'Open the oven door.'.	frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.	frameUpdater appendInstructionStatement: 'Close the oven door.'.		"Append an instruction that is delegated"	frameUpdater appendInstructionRole: 'Oven' statement: 'Bake for the time given.'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Action ).		self assert: ( frameUpdater frame frameLines size = 4 ).		! !!HumProgrammersAssistantTests methodsFor: 'pa210 Create frame' stamp: 'RichardAlexanderGreen 1/23/2015 11:08'!test200createFrame	"There are seven types of frame: (See HumFrame hierarchy)	. plan frame	. action frame	. dictionary frame	. view frame	. vignette frame	. comment frame	. data frame	Each type of frame should have suitable constructors.	"! !!HumProgrammersAssistantTests methodsFor: 'pa210 Create frame' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!test220createFrame4Plan	"Test a plan frame (goal frame).	---	Goal: Cake is baked according to recipe.	Preconditions:	. Oven is preheated to the temperature given in the recipe.	. The recipe`s batter is in a prepared cake pan.	Action:	. Oven: Bake the pan in the oven for the time given in the recipe.	---	"	| frameUpdater ontology |	ontology := HumOntology new.		"Initialize for a Plan Frame."	frameUpdater := HumFrameUpdater ontology: ontology goal: 'Cake is baked according to recipe.'.		"Append precondition lines."	frameUpdater appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameUpdater appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.	"Finish with action statement."	frameUpdater appendRole: 'Oven' action: 'Bake the pan in the oven for the time given in the recipe.' .		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Plan ).	self assert: ( frameUpdater frame frameLines size = 3 ).	! !!HumProgrammersAssistantTests methodsFor: 'pa100 Ontology Actions' stamp: 'RichardAlexanderGreen 4/20/2015 09:53'!test130loadOntology	"PA loads (reads) the ontology fram a file where it was saved previously."	| zPA |	false ifFalse: [ Transcript cr; show: 'test130loadOntology turned off - No way to save an ontology!!'. ^self ].	zPA := HumProgrammersAssistant new.	zPA clearOntology.	zPA saveOntologyOnFileNamed: 'HumPA-test.ontology'.	zPA loadOntologyFromFileNamed: 'HumPA-test.ontology'.	! !!HumProgrammersAssistantTests methodsFor: 'pa100 Ontology Actions' stamp: 'RichardAlexanderGreen 12/8/2012 11:03'!test110newOntology	"PA initializes (re-initializes) to an empty ontology."	| zPA |	zPA := HumProgrammersAssistant new.	zPA clearOntology.	self assert: (zPA ontology nouns isEmpty).! !!HumProgrammersAssistantTests methodsFor: 'pa100 Ontology Actions' stamp: 'RichardAlexanderGreen 4/20/2015 09:53'!test120saveOntology	"PA saves (writes) the ontology to a file."	| zPA |	false ifFalse: [ Transcript cr; show: 'test120saveOntology turned off - No way to save an ontology!!'. ^self ].	zPA  := HumProgrammersAssistant new.	zPA clearOntology.	zPA saveOntologyOnFileNamed: 'HumPA-test.ontology'.	! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 1/23/2014 14:40'!test351critiqueFrame4Dictionary	"Critique a dictionary frame.	After a dictionary frame is 'compiled', the nouns are recognized.	"	| frameUpdater ontology errors |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameUpdater := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	"Add dictionary lines."	"attributes"	frameUpdater addDictionaryLine: 'Recipe attributes include recipe-name, description, ingredients, steps.'.	"set collection"	frameUpdater addDictionaryLine: 'Recipe includes a set of ingrediants.'.	"list collection"	frameUpdater addDictionaryLine: 'Recipe includes a list of steps.'.	"Attribute used in  set above is an entity with its own attributes. Entities are members of set."	frameUpdater addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	"Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"	frameUpdater addDictionaryLine: 'Step attributes include step-number, step-description'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Dictionary ).		"ontology addNouns: #( 'recipe' 'name' 'description' 'ingredient' 'step' )."	frameUpdater compileToOntology: ontology. "Nouns are now added to ontology."				"Expect no complaints about no nouns."	errors := frameUpdater checkFrameSyntax.	self assert: ( errors isEmpty  ).	self assert: ( errors size = 0 ).		"Transcript  cr; show: 'test351critiqueFrame4Dictionary'; cr; show: errors; cr."	! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 1/16/2015 16:33'!test361critiqueFrame4Vignette	"Critique a dialog vignette.	"	| frameUpdater1 frameUpdater2 frameUpdater3 ontology errors1 errors2 errors3 |	ontology := HumOntology new.			"Initialize for a Dialog Frame."	frameUpdater1 := HumFrameUpdater ontology: ontology 													vignetteContext: 'Expecting Hello.' 																	pattern: 'Knock, knock.'.	frameUpdater1 addVignetteResponse: 'Who is there?'.	frameUpdater1 nextVignetteContext: 'Expecting first name.'.	errors1 := frameUpdater1 checkFrameSyntax.	self assert: (errors1 isEmpty ) not.	 	frameUpdater2 := HumFrameUpdater ontology: ontology 													vignetteContext: 'Expecting first name.' 																	pattern: '[first-name]'.	frameUpdater2 addVignetteResponse: '[first-name] who?'.	frameUpdater2 nextVignetteContext: 'Expecting whole-name.'.	errors2 := frameUpdater2 checkFrameSyntax.	self assert: (errors2 isEmpty ) not.			frameUpdater3 :=  HumFrameUpdater ontology: ontology 													vignetteContext: 'Expecting whole-name.' 																	pattern: '[first-name] [last-name]'.	frameUpdater3 addVignetteResponse: 'Hello [first-name] [last-name]. What do you want to do?'.	frameUpdater3 addVignetteInstruction: 'Ask menu.'.	errors3 := frameUpdater3 checkFrameSyntax.	self assert: (errors3 isEmpty ) not.		ontology addNouns: #( 'name' 'first-name' 'last-name' 'menu' ).		frameUpdater1 compileToOntology: ontology.	frameUpdater2 compileToOntology: ontology.	frameUpdater3 compileToOntology: ontology.		errors1 := frameUpdater1 checkFrameSyntax.	self assert: ( errors1 isEmpty ).		errors2 := frameUpdater2 checkFrameSyntax.	self assert: ( errors2 isEmpty ).		errors3 := frameUpdater3 checkFrameSyntax.	"{Ask menu.} is not defined in this ontology."	self assert: ( errors3 at: 1 ) = 'Action: {Ask menu.} has not been defined.'.												! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 4/20/2015 08:27'!test320critiqueFrame4Plan	"Check plan frame - no known nouns - no plans	"	| frameUpdater ontology errors |	ontology := HumOntology new.	"Initialize for a Plan Frame."	frameUpdater := HumFrameUpdater ontology: ontology goal: 'Cake is baked according to recipe..'.		"Append precondition lines."	frameUpdater appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameUpdater appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.		"Finish with action statement."	frameUpdater appendRole: 'Oven' action: 'Bake the pan in the oven for the time given in the recipe.' .		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Plan ).		"Expect complaints about no nouns."	errors := frameUpdater checkFrameSyntax.	self assert: ( errors isEmpty not ).	self assert: ( errors anySatisfy: [ :error | '*no known nouns*' match: error ] ).		"Expect complaints about preconditions with no plans."	self assert: ( errors anySatisfy: [ :error | '*no plan*' match: error ] ).		"Transcript cr; show: 'test320critiqueFrame4Plan Errors: ', errors asString; cr."	! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 4/20/2015 08:27'!test321critiqueFrame4Plan	"Detect: Every precondition has a noun that traces back to the goal statement.	"	| frameUpdater ontology errors |	ontology := HumOntology new.	"Initialize for a Plan Frame."	frameUpdater := HumFrameUpdater ontology: ontology goal: 'Cake is baked according to recipe..'.		"Append precondition lines."	frameUpdater appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameUpdater appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.		"Finish with action statement."	frameUpdater appendRole: 'Oven' action: 'Bake the pan in the oven for the time given in the recipe.' .		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Plan ).		"Every line has recipe as a noun."	ontology addNouns: #( 'recipe' ).		"Expect no complaints about no nouns. "	errors := frameUpdater checkFrameSyntax.	self assert: ( errors count: [ :error | '*no nouns*' match: error ]  ) = 0.	! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 4/20/2015 08:28'!test350critiqueFrame4Dictionary	"Critique a dictionary frame.	Before the frame is compiled, the nouns are not recognized.	This might not be what we want, but it is consistent with other frames.	Consequences: Nouns will not be rendered (color/underline) 	              until the frame is compiled (submitted).	"	| frameUpdater ontology errors |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameUpdater := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	"Add dictionary lines."	"attributes"	frameUpdater addDictionaryLine: 'Recipe attributes include recipe-name, description, ingrediants steps.'.	"set collection"	frameUpdater addDictionaryLine: 'Recipe includes a set of ingrediants.'.	"list collection"	frameUpdater addDictionaryLine: 'Recipe includes a list of steps.'.	"Attribute used in  set above is an entity with its own attributes. Entities are members of set."	frameUpdater addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	"Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"	frameUpdater addDictionaryLine: 'Step attributes include step-number, step-description'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Dictionary ).	"Until the frame is compiled, the nouns are not recognized.	TODO: IS THIS WHAT WE WANT?	"	errors := frameUpdater checkFrameSyntax.	self assert: ( errors isEmpty not ).	self assert: ( errors size = 5 ).		"Transcript  cr; show: 'test350critiqueFrame4Dictionary'; cr; show: errors; cr."  errors do: [:error | '*has no known nouns*' match: error. ]	! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 1/23/2015 10:54'!test346critiqueFrame4View	"When the nouns are defined, there are no complaints. s	"	| frameUpdater ontology errors testMe |		testMe := true.	testMe ifFalse: [ Transcript cr; show: 'test345critiqueFrame4View is turned off.'; cr. ^self].		ontology := HumOntology new.		"Initialize for a View Frame."	frameUpdater := HumFrameUpdater ontology: ontology viewEntity: 'recipe.'.	"Add markup lines."	frameUpdater addMarkUp: '!!!! Recipe'.	frameUpdater addMarkUp: ' recipe-name: [name]'.	frameUpdater addMarkUp: '   description: [description 5]'.	frameUpdater addMarkUp: '   ingredients: [ingredients]'.	frameUpdater addMarkUp: '            steps: [steps]'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4View ).		ontology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).			"Expect no complaints about no nouns."	errors := frameUpdater checkFrameSyntax.	self assert: ( errors isEmpty  ).		"Transcript show: 'test346critiqueFrame4View errors:'; cr; show: errors; cr."	! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 4/20/2015 08:27'!test322critiqueFrame4PlanMissingAntecedant	"Detect: One or more preconditions have a noun with no antecedant in the goal statement.	"	| frameUpdater ontology errors |	ontology := HumOntology new.	"Initialize for a Plan Frame."	frameUpdater := HumFrameUpdater ontology: ontology goal: 'Cake is baked according to recipe..'.		"Append precondition lines."	frameUpdater appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameUpdater appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.		"Finish with action statement."	frameUpdater appendRole: 'Oven' action: 'Bake the pan in the oven for the time given in the recipe.' .		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Plan ).		"Every line has recipe as a noun."	ontology addNouns: #( 'recipe' 'pan' ).		"Expect 'no antecedant' complaints "	errors := frameUpdater checkFrameSyntax.	self assert: ( errors count: [ :error | '*no antecedant*' match: error ]  ) > 0.	! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 4/20/2015 08:28'!test331critiqueFrame4Action	"Detect: Some nouns, but still not enough.	"	| frameUpdater ontology errors |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameUpdater := HumFrameUpdater ontology: ontology  	                                  role: 'Role' 																action: 'Bake the pan in the oven for the time given in the recipe.'.	"Append instruction lines."	frameUpdater appendInstructionStatement: 'Open the oven door.'.	frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.	frameUpdater appendInstructionStatement: 'Close the oven door.'.		"Append an instruction that is delegated"	frameUpdater appendInstructionRole: 'Oven' statement: 'Bake for the time given.'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Action ).		ontology addNouns: #( 'recipe' 'oven').		"Still expect one complaints about no nouns on the last line."	errors := frameUpdater checkFrameSyntax.	self assert: ( errors count: [ :error | '*no known nouns*' match: error ] ) = 1.! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 4/20/2015 08:28'!test330critiqueFrame4Action	"Detect: No known nouns.	"	| frameUpdater ontology errors |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameUpdater := HumFrameUpdater ontology: ontology  	                                  role: 'Role' 																action: 'Bake the pan in the oven for the time given in the recipe.'.	"Append instruction lines."	frameUpdater appendInstructionStatement: 'Open the oven door.'.	frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.	frameUpdater appendInstructionStatement: 'Close the oven door.'.		"Append an instruction that is delegated"	frameUpdater appendInstructionRole: 'Oven' statement: 'Bake for the time given in the recipe.'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Action ).		self assert: ( frameUpdater frame frameLines size = 4 ).			"Expect  complaints about no nouns on every line because the ontology has not been informed."	errors := frameUpdater checkFrameSyntax.		"Check the simple instructions."	self assert: (errors includes: 'Statement: {Open the oven door.} has no known nouns!!' ).	self assert: (errors includes: 'Statement: {Place the pan in the oven.} has no known nouns!!').	self assert: (errors includes: 'Statement: {Close the oven door.} has no known nouns!!' ).		"Check the last one - It is delegated."	self assert: (errors includes: 'Statement: {Bake for the time given in the recipe.} has no known nouns!!' ).		"The action line should have nouns too."	self assert: (errors includes: 'Action statement {Bake the pan in the oven for the time given in the recipe.} has no known nouns!!' ).			self assert: ( errors count: [ :error | '*no known nouns*' match: error] ) = 5.		! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 1/23/2014 14:40'!test345critiqueFrame4View	"Detect: No nouns in a view frame.	"	| frameUpdater ontology errors testMe |		"Turn this on/off for now."	testMe := true.	testMe ifFalse: [ Transcript cr; show: 'test345critiqueFrame4View is turned off.'; cr. ^self].		ontology := HumOntology new.		"Initialize for a View Frame."	frameUpdater := HumFrameUpdater ontology: ontology viewEntity: 'recipe.'.	"Add markup lines.	These widgets should reference nouns.	"	frameUpdater addMarkUp: '!!!! Recipe'.	frameUpdater addMarkUp: ' recipe-name: [name]'.	frameUpdater addMarkUp: '   description: [description 5]'.	frameUpdater addMarkUp: '   ingredients: [ingredients]'.	frameUpdater addMarkUp: '            steps: [steps]'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4View ).			"Expect complaints about no nouns."	errors := frameUpdater checkFrameSyntax.	self assert: ( errors isEmpty not ).		self assert: (errors size = 4 ).		"Transcript show: errors; cr."	! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 1/23/2015 11:03'!test300codeCriticFeatures	"The code critic generates errors and warnings for each type of frame."		"General syntax in most frames:	. Error: Statement should end with a period. (Instruction/Precondition/Action/Dictionary)	. Error: Statement should end with a colon.  (If/Else/For)	. Error: Response should end with period or question-mark. (vignette response)	. Error: Parenthesis is not closed. 	. Error: Bracket is not closed.	. Error: Unknown frame-type. (Expecting Comment/Goal/Role/View/Context/Dictionary/Data)	"	"For statements in any frame:	. Warning: Statement has no known nouns.	. Warning: Noun '___' has no antecedent.	. Warning: Statement is currently undefined. 	. Warning: Role '____' is undefined.	"	"For plan frames:	. Warning: Precondition is currently undefined. 	. . (It is not marked [Assumed] and there is no goal-frame defining it.)	. Warning: This goal is not invoked anywhere yet.	. . (No vignette or precondition invokes it.)	. Warning: This action is currently undefined.	. Error: Action statements must have role prefix.	. Error: There is a loop in the plan tree.	"	"For dictionary frames:	. Error: Statement is not recognized. 	. . (It does not match the Hum Dictionary DSL.)	. Error: Entity '____' cannot be its own attribute. 	. . (There is a cycle in the noun graph from this entity back to itself.)	. Warning: Noun '____' has no known source.	. . (The noun is not seen in any vignette-pattern, view, or giving-statement.) 	"	"For vignette frames:	. Warning: Context '____' has no content yet.	. Warning: Goal '____' is currently undefined.	. Warning: View '____' is currently undefined.	"	"For widgets:	. Error: Widget '[___]' is not recognized. 	. . (The widget content does not match the Hum Widget DSL.)	. Warning: Noun '____' is not defined.	. . (The noun named in a widget does not appear in any dictionary statement.)	"	"For text markup in view and vignette:	. Error: Bolding started with '*' is not closed.	. Error: Italics started with '~' is not closed.	. Error: Underline started with '_' is not closed.	"		! !!HumProgrammersAssistantTests methodsFor: 'pa310 Critique frame' stamp: 'RichardAlexanderGreen 4/20/2015 08:28'!test332critiqueFrame4ActionForAntecedants	"Detect: 'No known noun' and/or  'no antecedant'	"	| frameUpdater ontology errors |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameUpdater := HumFrameUpdater ontology: ontology  	                                  role: 'Role' 																action: 'Bake the pan in the oven for the time given in the recipe.'.	"Append instruction lines."	frameUpdater appendInstructionStatement: 'Open the oven door.'.	frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.	frameUpdater appendInstructionStatement: 'Close the oven door.'.		"Append an instruction that is delegated"	frameUpdater appendInstructionRole: 'Oven' statement: 'Bake for the time given.'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Action ).		ontology addNouns: #( 'recipe' 'oven' ).		"Still expect one complaints about no nouns on the last line."	errors := frameUpdater checkFrameSyntax.	self assert: ( errors count: [ :error | '*no known nouns*' match: error ] ) = 1.		"Check for antecedants - Happy path: 'door' is not a noun and needs no antecedant."	self assert: ( errors count: [: error | '*no antecedant*' match: error ] ) = 0.		"But if we make door a noun, it will now lack an antecedant."	ontology addNoun: 'door'.	errors := frameUpdater checkFrameSyntax.	self assert: ( errors count: [: error | '*no antecedant*' match: error ] ) = 2.			! !!HumProgrammersAssistantTests methodsFor: 'pa800LoadFromTextStream' stamp: 'RichardAlexanderGreen 6/12/2014 14:50'!test814StreamHasViewAndDictionaryFrames	"Load two frames: a view frame and a dictionary frame."	| stream pa |	stream := ReadWriteStream on: ''.	"Load two frames."	stream basicNextPutAll: '========= First Line ============View: Standard Footer.	Copyright 2014 RichardAlexanderGreen.===Dictionary: User/Client Attributes.	User attributes include name, email, passwordHash.==='.		pa := HumProgrammersAssistant new.	pa loadOntologyFromTextStream: stream.	self assert: ( pa ontology frames size = 2 ).	self assert: ( pa ontology frames anySatisfy: [:frame | frame isKindOf: HumFrame4Dictionary ] ).	! !!HumProgrammersAssistantTests methodsFor: 'pa800LoadFromTextStream' stamp: 'RichardAlexanderGreen 12/11/2014 13:39'!test815StreamHasViewDictionaryAndPlanFrame	"Load three frames: a view, a dictionary, and a plan frame."	| stream pa frames planFrames planLines |	stream := ReadWriteStream on: ''.	"Load three frames."	stream basicNextPutAll: '========= This is only a test ===============View: Standard Footer.	Copyright 2014 RichardAlexanderGreen.===Dictionary: User/Client Attributes.	User attributes include name, email, password-hash.===Goal: Bake a cake per recipe.Preconditions:	Oven is preheated per recipe`s oven-temperature.	Batter is prepared per recipe.	Batter is in cake-pan prepared per recipe.Action:	Arm: Place cake-pan in oven.	Timer: Wait for recipe`s bake-time.==='.		pa := HumProgrammersAssistant new.	pa loadOntologyFromTextStream: stream.	frames := pa ontology frames.	self expect: 3 actual: (frames size).	self expect: 1 actual: ( frames count: [:frame | frame isKindOf: HumFrame4Plan ] ).	self expect: 1 actual: ( frames count: [:frame | frame isKindOf: HumFrame4View ] ).	self expect: 1 actual: ( frames count: [:frame | frame isKindOf: HumFrame4Dictionary ] ).		"Test for correct number of plan lines. (Remove defect where block labels are of wrong type.)"	planFrames := ( frames select: [:frame | frame isKindOf: HumFrame4Plan ] ) asOrderedCollection.	planLines := ( planFrames at: 1 ) frameLines.	self expect: 3 actual: ( planLines count: [:frameLine | frameLine isKindOf: HumConditionLine ] ).	self expect: 2 actual: ( planLines count: [:frameLine | frameLine isKindOf: HumInstructionLine ] ).	! !!HumProgrammersAssistantTests methodsFor: 'pa800LoadFromTextStream' stamp: 'RichardAlexanderGreen 6/12/2014 12:10'!test810FramesAreSeparatedByFrameDelimiter	"Frames are separated by lines beginning with ===.	Comment: Additional content may follow a leading === - but that content will be ignored.	Authors may delimit frames by =============================== if they like.	Authors may delimit groups of frames with banners.	==================================	===== Views Collected Below ======	==================================	"	| stream pa |	stream := ReadWriteStream on: ''.	stream basicNextPutAll: 'View: Standard Footer.	Copyright 2014 RichardAlexanderGreen.==='.		pa := HumProgrammersAssistant new.	pa loadOntologyFromTextStream: stream.	self assert: ( pa ontology frames size = 1 ).	self assert: ( pa ontology frames allSatisfy: [:frame | frame isKindOf: HumFrame4View ]).	! !!HumProgrammersAssistantTests methodsFor: 'pa800LoadFromTextStream' stamp: 'RichardAlexanderGreen 6/12/2014 14:46'!test811StreamStartsWithFrameDelimiter	"Test where file starts with a frame-delimiter."	| stream pa |	stream := ReadWriteStream on: ''.	"Test where file starts with a frame-delimiter."	stream basicNextPutAll: '========= First Line ============View: Standard Footer.	Copyright 2014 RichardAlexanderGreen.==='.		pa := HumProgrammersAssistant new.	pa loadOntologyFromTextStream: stream.	self assert: (pa ontology frames size = 1 ).	! !!HumProgrammersAssistantTests methodsFor: 'pa800LoadFromTextStream' stamp: 'RichardAlexanderGreen 12/11/2014 12:14'!test820StreamHasVignettes	"Test that vignettes are properly parsed, loaded, and indexed."	| stream pa frames |		stream := ReadWriteStream on: ''.	"Load these frames."	stream basicNextPutAll:'===Context: Start.U: Enter.S: Club Mech is a test bed for Hum dialogs.U: My name is [user-name].U: Authenticated as [user-name].S: Hello [user-name].   Please select an activity.. Push context "Select an activity.".U: I am a member.S: What is your name?U: *.S: Welcome to Club Mech.   Are you a member? ===Context: Select an activity.U: Propose a topic.U: Suggest a topic.U: Recommend a topic.U: Introduce a topic.U: Enter a topic.S: Please enter a description of the talk you are offering.. Ask topic.U: Vote *.S: Here is the current ballot.. Ask voter-ballot.. (Assumes a ballot is available / usable.)U: * scoreboard.S: Here is the scoreboard for the current ballot.. Show scoreboard.. (Also assumes a ballot is available / usable.)==='.	pa := HumProgrammersAssistant new.	pa loadOntologyFromTextStream: stream.	frames := pa ontology frames.	self expect: 7 actual: frames size description: 'Expecting one frame per vignette.'.	self assert: ( frames allSatisfy: [:frame | frame isKindOf: HumFrame4Vignette ] ).	self assert: (pa ontology contextVignettes size > 0).	! !!HumProgrammersAssistantTests methodsFor: 'pa800LoadFromTextStream' stamp: 'RichardAlexanderGreen 6/12/2014 14:49'!test813StreamStartsWithFrameDelimiterEndsWithEOF	"Test where file starts with a frame-delimiter and ends on end-of-file."	| stream pa |	stream := ReadWriteStream on: ''.	"Test where file starts with a frame-delimiter and ends on end-of-file."	stream basicNextPutAll: '========= First Line ============View: Standard Footer.	Copyright 2014 RichardAlexanderGreen.'.		pa := HumProgrammersAssistant new.	pa loadOntologyFromTextStream: stream.	self assert: (pa ontology frames size = 1 ).	! !!HumProgrammersAssistantTests methodsFor: 'pa800LoadFromTextStream' stamp: 'RichardAlexanderGreen 6/12/2014 14:49'!test812StreamEndsWithEndOfFile	"Test where frame ends on end-of-file"	| stream pa |	stream := ReadWriteStream on: ''.	"Test where frame ends on end-of-file"	stream basicNextPutAll: 'View: Standard Footer.	Copyright 2014 RichardAlexanderGreen.'.		pa := HumProgrammersAssistant new.	pa loadOntologyFromTextStream: stream.	self assert: (pa ontology frames size = 1 ).	! !!HumProgrammersAssistantTests methodsFor: 'pa800LoadFromTextStream' stamp: 'RichardAlexanderGreen 12/11/2014 13:03'!test817StreamHasViewDictionaryPlanAndActionFrames	"Load four frames: a view, a dictionary, a plan, and an action frame."	| stream pa frames |	stream := ReadWriteStream on: ''.	"Load four frames."	stream basicNextPutAll: '========= This is only a test ===============View: Standard Footer.	Copyright 2014 RichardAlexanderGreen.===Dictionary: User/Client Attributes.	User attributes include name, email, password-hash.===Goal: Bake a cake per recipe.Preconditions:	Oven is preheated per recipe`s oven-temperature.	Batter is prepared per recipe.	Batter is in cake-pan prepared per recipe.Action:	Arm: Place cake-pan in oven.	Timer: Wait for recipe`s bake-time.===Role: Arm.Action: Place cake-pan in oven.	Open oven door.	Pick-up cake-pan.	Place cake-pan inside oven.To: Open oven door.	Position carriage in front of oven.	Grab door handle.	Pull door handle to open position.==='.		pa := HumProgrammersAssistant new.	pa loadOntologyFromTextStream: stream.	frames := pa ontology frames.	self expect: 5 actual: frames size.	self expect: 2 actual: ( frames count: [:frame | frame isKindOf: HumFrame4Action ] ).	self expect: 1 actual: ( frames count: [:frame | frame isKindOf: HumFrame4Plan ] ).	self expect: 1 actual: ( frames count: [:frame | frame isKindOf: HumFrame4Dictionary ] ).	self expect: 1 actual: ( frames count: [:frame | frame isKindOf: HumFrame4View ] ).	! !!HumProgrammersAssistantTests methodsFor: 'pa800LoadFromTextStream' stamp: 'RichardAlexanderGreen 6/12/2014 12:12'!test800LoadFileReadMe	"The Programmers Assistant may load and parse a text file.	1. The framing-convention is that frames are separated by ===.	The older versions of Hum/Simple English used --- as a frame-delimiter.	But this version also uses lines beginning with '---' in the mark-up notation.	2. All frames should begin with a title line 	   so that the type of frame can be quickly recognized by humans and the PA-Loader.	3. For convenience, empty frames should be tolerated (but not stored).	4. For convenience, the file may begin with a frame-delimiter (===).	5. For convenience, the file may end with an end-of-file (missing frame-delimiter).	"		"Frames are separated by lines beginning with ===.	Comment: Additional content may follow a leading === - but that content will be ignored.	Authors may delimit frames by =============================== if they like.	Authors may delimit groups of frames with banners.	==================================	===== Views Collected Below ======	==================================	"! !!HumProgrammersAssistantTests methodsFor: 'pa800LoadFromTextStream' stamp: 'RichardAlexanderGreen 6/12/2014 14:50'!test816StreamHasViewDictionaryPlanAndCommentFrames	"Load four frames: a view, a dictionary, a plan, and a comment frame."	| stream pa |	stream := ReadWriteStream on: ''.	"Load four frames."	stream basicNextPutAll: '========= This is only a test ===============View: Standard Footer.	Copyright 2014 RichardAlexanderGreen.===Dictionary: User/Client Attributes.	User attributes include name, email, password-hash.===Goal: Bake a cake per recipe.Preconditions:	Oven is preheated per recipe`s oven-temperature.	Batter is prepared per recipe.	Batter is in cake-pan prepared per recipe.Action:	Arm: Place cake-pan in oven.	Timer: Wait for recipe`s bake-time.===Comment: Some nouns may not need to be identified.	It may or may not be necessary to identify some nouns in the domain.	Nouns like oven and cake-pan (above) might not have variable values at run-time.==='.		pa := HumProgrammersAssistant new.	pa loadOntologyFromTextStream: stream.	self assert: ( pa ontology frames size = 4 ).	self assert: ( pa ontology frames anySatisfy: [:frame | frame isKindOf: HumFrame4Comment ] ).	! !!HumProgrammersAssistantTests methodsFor: 'pa510 Store and fetch frame' stamp: 'RichardAlexanderGreen 6/12/2014 16:15'!test571fetchFrame4VignetteByTitle	"TODO: Think about how vignettes would be identified to users.	The current design treats vignettes as modules.	It might make more sense to treat contexts as modules	because the rule is that the vignettes in a context are tried in the order given.	If that were the case, 	  the modules would tend to have too many lines of code, 	  but they would be easily named.	Idea: Name the vignette by context plus the first pattern.	Problem: That does not deal with the ordering of vignettes within a context.	Question: Is the ordering of vignettes really necessary?	          In other words, should we demand greater specificity from users?	Decision: Discard the idea that vignettes are tried in some order and see what happens.	"	| frameUpdater1 frameUpdater2 ontology name frame1 frame2 |	"Given: A context is active."	"When: Scribe delivers a pattern and run-time looks it up."	"Then: If the pattern matches one of the vignette`s in the active context, 	       . Ontology returns that vignette.	       Otherwise:	       . Ontology returns nil. (Perhaps we should return a default 'do not understand' vignette.)"		"Create a dialog vignette.	"	ontology := HumOntology new.			"Initialize for a Dialog Frame."	frameUpdater1 := HumFrameUpdater ontology: ontology vignetteContext: 'Expecting Hello.' pattern: 'Knock, knock.'.		self assert: ( frameUpdater1 notNil ).	self assert: ( frameUpdater1 frame isMemberOf: HumFrame4Vignette ).		"Add response lines."	"There are two kinds of resonse, verbal responses and actions."	frameUpdater1 addVignetteResponse: 'Who is there?'.	frameUpdater1 addVignetteInstruction: 'Next context "Expecting who.".'.		self assert: ( ( frameUpdater1 frame frameLines at: 1 ) 									sameAs:  ( HumVignetteResponseLine source: 'S: Who is there?' ) ).	self assert: ( ( frameUpdater1 frame frameLines at: 2 ) 									sameAs:  ( HumInstructionLine statement: 'Next context "Expecting who.".' ) ).	self assert: ( ( frameUpdater1 frame responseLines at: 1 ) 									sameAs:  ( HumMarkupLine source: 'Who is there?' ) ).	self assert: ( ( frameUpdater1 frame instructionLines at: 1 ) 									sameAs:  ( HumInstructionLine statement: 'Next context "Expecting who.".' ) ).			frame1 := frameUpdater1 frame.	self assert: ( frame1 isKindOf: HumFrame4Vignette ).	name := frame1 frameName.	self assert: ( name isKindOf: String ).	"We can use the identifier to fetch the frame into another frameUpdater."	frameUpdater1 storeFrameInOntology.	frameUpdater2 := HumFrameUpdater ontology: ontology fetchFrameByName: name.	self assert: (frameUpdater2 isKindOf: HumFrameUpdater ).	"Check the content."	frame2 := frameUpdater2 frame.	self assert: ( frame2 isKindOf: HumFrame4Vignette ).	self assert: ( frame1 titleLine = frame2 titleLine ).	self assert: ( frame1 titleLine sameAs: frame2 titleLine ).	self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).	self assert: ( frame1 frameLines at: 1) = ( frame2 frameLines at: 1 ).	self assert: (( frame1 frameLines at: 1) sameAs: ( frame2 frameLines at: 1 )).						! !!HumProgrammersAssistantTests methodsFor: 'pa510 Store and fetch frame' stamp: 'RichardAlexanderGreen 1/23/2014 14:41'!test510storeFrame	"Store the frame in the given ontology.	The frame may be stored even if it has errors.	"	| frameUpdater ontology |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameUpdater := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	"Add dictionary lines."	"supertype"	frameUpdater addDictionaryLine: 'Description is a text.'.	"attributes"	frameUpdater addDictionaryLine: 'Recipe attributes include recipe-name, recipe-description, ingredients, steps.'.	"set collection"	frameUpdater addDictionaryLine: 'Recipe includes a set of ingredients.'.	"list collection"	frameUpdater addDictionaryLine: 'Recipe includes a list of steps.'.	"Attribute used in  set above is an entity with its own attributes. Entities are members of set."	frameUpdater addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	"Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"	frameUpdater addDictionaryLine: 'Step attributes include step-number, step-description'.		self assert: ( frameUpdater notNil ).	self assert: ( frameUpdater frame isMemberOf: HumFrame4Dictionary ).		"The frame editor receives the command to store the frame from the user interface (Scribe)."	frameUpdater storeFrameInOntology.		! !!HumProgrammersAssistantTests methodsFor: 'pa510 Store and fetch frame' stamp: 'RichardAlexanderGreen 3/17/2015 12:06'!test551fetchFrame4ActionByTitle	"The title of an action includes the role and the statement."		| frameUpdater1 frameUpdater2 ontology frame1 frame2 name |	"Given: Ontology contains several action frames."	"When: Caller (PA) requests the action frame with role and statement-string."	"Then: Ontology returns the matching action frame.	       Otherwise: The PA may ask the ontology for a ranked list of nearest matches. (test552 ?)"	ontology := HumOntology new.		"Initialize for an Action Frame."	frameUpdater1 := HumFrameUpdater ontology: ontology  	                                  role: 'Role' 																action: 'Bake the pan in the oven for the time given in the recipe.'.	"Append instruction lines."	frameUpdater1 appendInstructionStatement: 'Open the oven door.'.	frameUpdater1 appendInstructionStatement: 'Place the pan in the oven.'.	frameUpdater1 appendInstructionStatement: 'Close the oven door.'.		"Append an instruction that is delegated"	frameUpdater1 appendInstructionRole: 'Oven' statement: 'Bake for the time given.'.		self assert: ( frameUpdater1 notNil ).	self assert: ( frameUpdater1 frame isMemberOf: HumFrame4Action ).		self assert: ( frameUpdater1 frame frameLines size = 4 ).		frame1 := frameUpdater1 frame.	self assert: ( frame1 isKindOf: HumFrame4Action ).	name := frame1 frameName.	self assert: ( name isKindOf: String ).	"We can use the identifier to fetch the frame into another frameUpdater."	frameUpdater1 storeFrameInOntology.	frameUpdater2 := HumFrameUpdater ontology: ontology fetchFrameByName: name.	self assert: (frameUpdater2 isKindOf: HumFrameUpdater ).	"Check the content."	frame2 := frameUpdater2 frame.	self assert: ( frame2 isKindOf: HumFrame4Action ).	self assert: ( frame1 titleLine = frame2 titleLine ).	self assert: ( frame1 titleLine sameAs: frame2 titleLine ).	self expect: ( frame1 frameLines size ) actual: ( frame2 frameLines size ).	self expect: ( frame1 frameLines at: 1)  actual: ( frame2 frameLines at: 1 ).	self expect: ( frame1 frameLines at: 1) actual: ( frame2 frameLines at: 1 ).		! !!HumProgrammersAssistantTests methodsFor: 'pa510 Store and fetch frame' stamp: 'RichardAlexanderGreen 4/20/2015 08:28'!test532fetchFrame4PlanByTitle	"Create a plan frame in editor; store it; get it back via its title.	"	| frameUpdater1 frameUpdater2 frameUpdater3 frameUpdater4 ontology errors frame1 frame2  frame4 name |	ontology := HumOntology new.	"Initialize for a Plan Frame."	frameUpdater1 := HumFrameUpdater ontology: ontology goal: 'Cake is baked according to recipe.'.	"Append precondition lines."	frameUpdater1 appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameUpdater1 appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.	"Finish with action statement."	frameUpdater1 appendRole: 'Oven' action: 'Bake the pan in the oven for the time given in the recipe.' .		self assert: ( frameUpdater1 notNil ).	self assert: ( frameUpdater1 frame isMemberOf: HumFrame4Plan ).		"Every line has recipe as a noun."	ontology addNouns: #( 'recipe' ).		"Expect no complaints about no nouns. "	errors := frameUpdater1 checkFrameSyntax.	self assert: ( errors count: [ :error | '*no known nouns*' match: error] ) = 0.		self assert: ( frameUpdater1 notNil ).	self assert: ( frameUpdater1 frame isMemberOf: HumFrame4Plan ).		"The frame editor receives the command to store the frame from the user interface (Scribe)."	frameUpdater1 storeFrameInOntology.	"The frame will now have a uniqueIdentifier."	frame1 := frameUpdater1 frame.	self assert: ( frame1 isKindOf: HumFrame4Plan ).	name := frame1 frameName.	self assert: ( name isKindOf: String ).	"We can use the identifier to fetch the frame into another frameUpdater."	frameUpdater2 := HumFrameUpdater ontology: ontology fetchFrameByName: name.	self assert: ( frameUpdater2 isKindOf: HumFrameUpdater ).	"Check the content."	frame2 := frameUpdater2 frame.	self assert: ( frame2 isKindOf: HumFrame4Plan ).	self assert: ( frame1 titleLine = frame2 titleLine ).	self assert: ( frame1 titleLine sameAs: frame2 titleLine ).	self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).	self assert: ( frame1 frameLines at: 1 ) = ( frame2 frameLines at: 1 ).	self assert: (( frame1 frameLines at: 1 ) sameAs: ( frame2 frameLines at: 1 )).		"Make sure it still works when there is more than one plan frame."		frameUpdater3 := HumFrameUpdater ontology: ontology 	                                    goal: 'Oven is preheated to the temperature given in the recipe.'.	frameUpdater3 storeFrameInOntology.	frameUpdater4 := HumFrameUpdater ontology: ontology fetchFrameByName: name.	self assert: ( frameUpdater2 isKindOf: HumFrameUpdater ).	"Check the content."	frame4 := frameUpdater2 frame.	self assert: ( frame4 isKindOf: HumFrame4Plan ).	self assert: ( frame1 titleLine = frame2 titleLine ).	self assert: ( frame1 titleLine sameAs: frame4 titleLine ).	self assert: ( frame1 frameLines size ) = ( frame4 frameLines size ).	self assert: ( frame1 frameLines at: 1 ) = ( frame4 frameLines at: 1 ).	self assert: (( frame1 frameLines at: 1 ) sameAs: ( frame4 frameLines at: 1 )).! !!HumProgrammersAssistantTests methodsFor: 'pa510 Store and fetch frame' stamp: 'RichardAlexanderGreen 4/20/2015 09:32'!test531fetchFrame4PlanByID	"Create a plan frame in editor; store it; get it back via its ID.	"	| frameUpdater1 frameUpdater2 ontology errors frame1 frame2 identifier |	ontology := HumOntology new.	"Initialize for a Plan Frame."	frameUpdater1 := HumFrameUpdater ontology: ontology goal: 'Cake is baked according to recipe..'.	"Append precondition lines."	frameUpdater1 appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameUpdater1 appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.	"Finish with action statement."	frameUpdater1 appendRole: 'Oven' action: 'Bake the pan in the oven for the time given in the recipe.' .		self assert: ( frameUpdater1 notNil ).	self assert: ( frameUpdater1 frame isMemberOf: HumFrame4Plan ).		"Every line has recipe as a noun."	ontology addNouns: #( 'recipe' ).		"Expect no complaints about no nouns. "	errors := frameUpdater1 checkFrameSyntax.	self assert: ( errors count: [ :error | '*no known nouns*' match: error]  ) = 0.				self assert: ( frameUpdater1 notNil ).	self assert: ( frameUpdater1 frame isMemberOf: HumFrame4Plan ).		"The frame editor receives the command to store the frame from the user interface (Scribe)."	frameUpdater1 storeFrameInOntology.	"The frame will now have a uniqueIdentifier."	frame1 := frameUpdater1 frame.	self assert: ( frame1 isKindOf: HumFrame4Plan ).	identifier := frame1 uniqueIdentifier.	self assert: ( identifier isKindOf: HumIdentifier ).	"We can use the identifier to fetch the frame into another frameUpdater."	frameUpdater2 := HumFrameUpdater ontology: ontology loadFrameByIdentifier: identifier.	self assert: (frameUpdater2 isKindOf: HumFrameUpdater ).	"Check the content."	frame2 := frameUpdater2 frame.	self assert: ( frame2 isKindOf: HumFrame4Plan ).	self assert: ( frame1 titleLine = frame2 titleLine ).	self assert: ( frame1 titleLine sameAs: frame2 titleLine ).	self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).	self assert: ( frame1 frameLines at: 1) = ( frame2 frameLines at: 1 ).	self assert: (( frame1 frameLines at: 1) sameAs: ( frame2 frameLines at: 1 )).			! !!HumProgrammersAssistantTests methodsFor: 'pa510 Store and fetch frame' stamp: 'RichardAlexanderGreen 1/23/2014 14:42'!test541fetchFrame4DictionaryByTitle	"Ontology will fetch a dictionary frame given its title."	| frameUpdater1 frameUpdater2 ontology name frame1 frame2 |		"Given: Ontology has several dictionary frames."	"When: Caller (PA) requests a dictionary frame by its title."	"Then: Ontology returns the matching frame."	"--- Otherwise ---"	"The caller may request a ranked list of nearest matches. (test542 ?)"	"Initialize for a Dictionary Frame."	ontology := HumOntology new.	frameUpdater1 := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.		"Add dictionary lines."	"attributes"	frameUpdater1 addDictionaryLine: 'Recipe attributes include recipe-name, description, ingrediants steps.'.	"set collection"	frameUpdater1 addDictionaryLine: 'Recipe includes a set of ingrediants.'.	"list collection"	frameUpdater1 addDictionaryLine: 'Recipe includes a list of steps.'.	"Attribute used in  set above is an entity with its own attributes. Entities are members of set."	frameUpdater1 addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	"Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"	frameUpdater1 addDictionaryLine: 'Step attributes include step-number, step-description'.		self assert: ( frameUpdater1 notNil ).	self assert: ( frameUpdater1 frame isMemberOf: HumFrame4Dictionary ).			"The frame editor receives the command to store the frame from the user interface (Scribe)."	frameUpdater1 storeFrameInOntology.	"The frame will now have a uniqueIdentifier."	frame1 := frameUpdater1 frame.	self assert: ( frame1 isKindOf: HumFrame4Dictionary ).	name := frame1 frameName.	self assert: ( name isKindOf: String ).	"We can use the identifier to fetch the frame into another frameUpdater."	frameUpdater2 := HumFrameUpdater ontology: ontology fetchFrameByName: name.	self assert: (frameUpdater2 isKindOf: HumFrameUpdater ).	"Check the content."	frame2 := frameUpdater2 frame.	self assert: ( frame2 isKindOf: HumFrame4Dictionary ).	self assert: ( frame1 titleLine = frame2 titleLine ).	self assert: ( frame1 titleLine sameAs: frame2 titleLine ).	self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).	self assert: ( frame1 frameLines at: 1) = ( frame2 frameLines at: 1 ).	self assert: (( frame1 frameLines at: 1) sameAs: ( frame2 frameLines at: 1 )).		! !!HumProgrammersAssistantTests methodsFor: 'pa510 Store and fetch frame' stamp: 'RichardAlexanderGreen 1/23/2014 14:42'!test561fetchFrame4ViewByTitle	"This should be easy."	| frameUpdater1 frameUpdater2 ontology name frame1 frame2 |	"Given: PA or run-time has ontology open with several view frames."	"When: PA or run-time correctly requests a view by name."	"Then: Ontology returns the frame containing that view."	"--- Following can go into another test: ---"	"When: The name does not match any view,"	"Then: The PA can ask the ontology for a ranked list of view names. (best match)"		ontology := HumOntology new.		"Initialize for a View Frame."	frameUpdater1 := HumFrameUpdater ontology: ontology viewEntity: 'recipe.'.		"Add markup lines."	frameUpdater1 addMarkUp: '!!!! Recipe'.	frameUpdater1 addMarkUp: ' recipe-name: [name]'.	frameUpdater1 addMarkUp: '   description: [description 5]'.	frameUpdater1 addMarkUp: '   ingredients: [ingredients]'.	frameUpdater1 addMarkUp: '            steps: [steps]'.		self assert: ( frameUpdater1 notNil ).	self assert: ( frameUpdater1 frame isMemberOf: HumFrame4View ).		frame1 := frameUpdater1 frame.	self assert: ( frame1 isKindOf: HumFrame4View ).	name := frame1 frameName.	self assert: ( name isKindOf: String ).	"We can use the identifier to fetch the frame into another frameUpdater."	frameUpdater1 storeFrameInOntology.	frameUpdater2 := HumFrameUpdater ontology: ontology fetchFrameByName: name.	self assert: (frameUpdater2 isKindOf: HumFrameUpdater ).	"Check the content."	frame2 := frameUpdater2 frame.	self assert: ( frame2 isKindOf: HumFrame4View ).	self assert: ( frame1 titleLine = frame2 titleLine ).	self assert: ( frame1 titleLine sameAs: frame2 titleLine ).	self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).	self assert: ( frame1 frameLines at: 1) = ( frame2 frameLines at: 1 ).	self assert: (( frame1 frameLines at: 1) sameAs: ( frame2 frameLines at: 1 )).! !!HumProgrammersAssistantTests methodsFor: 'pa510 Store and fetch frame' stamp: 'RichardAlexanderGreen 4/20/2015 09:31'!test520fetchFrameByID	"Store a dictionary frame and then get it back using its uniqueIdentifier.	"	| frameUpdater1 ontology identifier frameUpdater2 frame1 frame2 |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameUpdater1 := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	"Add dictionary lines."	"supertype"	frameUpdater1 addDictionaryLine: 'Description is a text.'.	"attributes"	frameUpdater1 addDictionaryLine: 'Recipe attributes include recipe-name, recipe-description, ingredients, steps.'.	"set collection"	frameUpdater1 addDictionaryLine: 'Recipe includes a set of ingredients.'.	"list collection"	frameUpdater1 addDictionaryLine: 'Recipe includes a list of steps.'.	"Attribute used in  set above is an entity with its own attributes. Entities are members of set."	frameUpdater1 addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	"Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"	frameUpdater1 addDictionaryLine: 'Step attributes include step-number, step-description'.		self assert: ( frameUpdater1 notNil ).	self assert: ( frameUpdater1 frame isMemberOf: HumFrame4Dictionary ).		"The frame editor receives the command to store the frame from the user interface (Scribe)."	frameUpdater1 storeFrameInOntology.	"The frame will now have a uniqueIdentifier."	frame1 := frameUpdater1 frame.	self assert: ( frame1 isKindOf: HumFrame4Dictionary ).	identifier := frame1 uniqueIdentifier.	self assert: ( identifier isKindOf: HumIdentifier ).	"We can use the identifier to fetch the frame into another frameUpdater."	frameUpdater2 := HumFrameUpdater ontology: ontology loadFrameByIdentifier: identifier.	self assert: (frameUpdater2 isKindOf: HumFrameUpdater ).	"Check the content."	frame2 := frameUpdater2 frame.	self assert: ( frame2 isKindOf: HumFrame4Dictionary ).	self assert: ( frame1 titleLine = frame2 titleLine ).	self assert: ( frame1 titleLine sameAs: frame2 titleLine ).	self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).	self assert: ( frame1 frameLines at: 1) = ( frame2 frameLines at: 1 ).	self assert: (( frame1 frameLines at: 1) sameAs: ( frame2 frameLines at: 1 )).		! !!HumProgrammersAssistantTests methodsFor: 'pa510 Store and fetch frame' stamp: 'RichardAlexanderGreen 4/20/2015 09:32'!test540fetchFrame4DictionaryByID	| frameUpdater1 frameUpdater2 ontology identifier frame1 frame2 |		"Initialize for a Dictionary Frame."	ontology := HumOntology new.	frameUpdater1 := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.		"Add dictionary lines."	"attributes"	frameUpdater1 addDictionaryLine: 'Recipe attributes include recipe-name, description, ingrediants steps.'.	"set collection"	frameUpdater1 addDictionaryLine: 'Recipe includes a set of ingrediants.'.	"list collection"	frameUpdater1 addDictionaryLine: 'Recipe includes a list of steps.'.	"Attribute used in  set above is an entity with its own attributes. Entities are members of set."	frameUpdater1 addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	"Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"	frameUpdater1 addDictionaryLine: 'Step attributes include step-number, step-description'.		self assert: ( frameUpdater1 notNil ).	self assert: ( frameUpdater1 frame isMemberOf: HumFrame4Dictionary ).			"The frame editor receives the command to store the frame from the user interface (Scribe)."	frameUpdater1 storeFrameInOntology.	"The frame will now have a uniqueIdentifier."	frame1 := frameUpdater1 frame.	self assert: ( frame1 isKindOf: HumFrame4Dictionary ).	identifier := frame1 uniqueIdentifier.	self assert: ( identifier isKindOf: HumIdentifier ).	"We can use the identifier to fetch the frame into another frameUpdater1."	frameUpdater2 := HumFrameUpdater ontology: ontology loadFrameByIdentifier: identifier.	self assert: (frameUpdater2 isKindOf: HumFrameUpdater ).	"Check the content."	frame2 := frameUpdater2 frame.	self assert: ( frame2 isKindOf: HumFrame4Dictionary ).	self assert: ( frame1 titleLine = frame2 titleLine ).	self assert: ( frame1 titleLine sameAs: frame2 titleLine ).	self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).	self assert: ( frame1 frameLines at: 1) = ( frame2 frameLines at: 1 ).	self assert: (( frame1 frameLines at: 1) sameAs: ( frame2 frameLines at: 1 )).		! !!HumProgrammersAssistantTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/13/2012 15:24'!aReadMe	"See the class description for the intended (future) tests."	^'See the class description for the intended (future) tests.'	! !HumTestCase subclass: #HumRunTimeTests	instanceVariableNames: 'setupMessenger setupDispatcher setupBookkeeper setupWorker setupEnvironment setupConfiguration'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumRunTimeTests commentStamp: 'RichardAlexanderGreen 6/10/2013 08:57' prior: 0!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Run-Time Test Cases--- See also: HumCalculatorTests%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%A. Messenger   1. The actors (agents) communicate via the Messenger.   2. Messenger is addressed via a URI.   3. Messenger records each message in a log file.   4. In test mode,          the messenger can replay the messages          that were sent to an actor during some period of time.          (This capability enables simulations.)   5. In test mode,          messages can only be communicated          between actors that are also in test mode.B. Resource Manager (RM) - assigns tasks to actors.   1. Actor checks-in (announces availability to perform specific roles).   2. Assign task (action-statement) to actor.      a) Job-ticket contains action-statement, noun-values,             request context (requesting actor, and instruction-pointer).      b) The RM assigns an available actor.      c) The RM sends the job-ticket to the assigned actor.             (via Messenger)   3. Actor has completed task.      a) The resources consumed (actors time, etc) are recorded on the job ticket.      b) Any computed results are added to the job-ticket.            (Convention: Actions with results have a "giving" clause.)      c) RM sends resource consumption data to Bookkeeper.      d) Task complete notice (with job-ticket) is sent to requester.            (The requester resumes execution of the plan.)C. Bookkeeper - tracks resource consumption   1. Job-ticket resource consumption is recorded.   2. Resource dimensions include job, resource,          provider (actor, role), consumer (actor, role), and date-time.   3. Actors may decrement, increment inventories.   4. Actors may set inventory level (initialization, audit).D. Supervisor - controls execution of plans and dialogs.   1. Delegate task.         (The current actor has delegated a task to another role.)      a) Send delegated task to Resource Manager. (RM)         (The RM will assign the task to an available actor.)    2. Resume suspended action.         (When a task is delegated to another role,             the current task execution is suspended.)   3. E. Blackboard + WorldBase   1. Blackboard sends new values to attached WorldBase with event-stamp.   2. WorldBase stores and returns value!!HumRunTimeTests methodsFor: 'Blackboard Tests' stamp: 'RichardAlexanderGreen 9/14/2014 13:34'!test700BlackBoardReadMe	"	Each active actor records its state on a BlackBoard instance.	The BlackBoard instance may persist its data on a WorldBase singleton.	"	"	Hum BlackBoard client situations (use cases):	A Coordinator is operating a plan. The plan has context and state.	A Dispatcher tracks a number of Actors, their Roles, and their execution state.	A Dialog Agent may have a long-running Dialog with associated data.	A Messenger must remember the URI (network addresses) associated with actor IDs.	When an actor delegates an instruction to another actor, (like RMI)	  the 'caller' must persist its state until the delegation 'returns' 	  so that the caller can resume execution with saved state and instruction-pointer.	  Note: The saved state may be 'updated/amended' if the delegation has a 'giving' clause.	"! !!HumRunTimeTests methodsFor: 'Blackboard Tests' stamp: 'RichardAlexanderGreen 2/28/2015 10:04'!test710setAndGet	"set entity-attribute value"	| blackboard entity value |	blackboard := HumBlackBoard new.	blackboard worldbase: ( HumWorldBase new ).	blackboard businessEvent: 'test710setAndGet'.	entity := HumEntity title: 'Entity for test710setAndGet'.	"Set entity-attribute value."	blackboard setEntityID: (entity id) attribute: #description toValue: 'This is only a test.'.	value := blackboard getEntityID: (entity id) attribute: #description.	self assert: ( value == 'This is only a test.').! !!HumRunTimeTests methodsFor: 'Blackboard Tests' stamp: 'RichardAlexanderGreen 2/28/2015 10:04'!test720setGetReplace	"Update entity-attribute value"	| blackboard entity value |	blackboard := HumBlackBoard new.	blackboard worldbase: ( HumWorldBase new ).	blackboard businessEvent: 'test720setGetReplace'.	entity := HumEntity title: 'Entity for test720setGetReplace'.	blackboard setEntityID: (entity id) attribute: #description toValue: 'This is only a test.'.	value := blackboard getEntityID: (entity id) attribute: #description.	self assert: ( value == 'This is only a test.').		blackboard setEntityID: (entity id) attribute: #description toValue: 'This WAS only a test.'.	value := blackboard getEntityID: (entity id) attribute: #description.	self assert: ( value == 'This is only a test.') not.	self assert: ( value == 'This WAS only a test.').! !!HumRunTimeTests methodsFor: 'Blackboard Tests' stamp: 'RichardAlexanderGreen 3/2/2015 09:11'!test730clearEntity	"Update entity-attribute value"	| blackboard value worldbase |	blackboard := HumBlackBoard new.	worldbase := HumWorldBase openWorldBase: 'worldbase for test730clearEntity'.	blackboard worldbase: worldbase.	blackboard businessEvent: 'test730clearEntity'.		blackboard setEntityName: 'Tester' attribute: #description toValue: 'This is only a test.'.	value := blackboard getEntityName: 'Tester' attribute: #description.	self assert: ( value == 'This is only a test.').	blackboard clearEntity: 'Tester'.		self expect: 0 actual: (blackboard entityIdentifiers size).	self expect: 0 actual: (blackboard quads size).	self expect: 1 actual: (worldbase quads size).	self expect: 0 actual: (worldbase history size).		blackboard setEntityName: 'Tester' attribute: #description toValue: 'This WAS only a test.'.	self expect: 1 actual: (blackboard entityIdentifiers size).	self expect: 1 actual: (blackboard quads size).	self expect: 2 actual: (worldbase quads size).	self expect: 0 actual: (worldbase history size).		value := blackboard getEntityName: 'Tester' attribute: #description.	self assert: ( value == 'This is only a test.') not.	self assert: ( value == 'This WAS only a test.').! !!HumRunTimeTests methodsFor: 'Scribe Tests' stamp: 'RichardAlexanderGreen 2/23/2015 09:10'!testS110SetupScribe	"A scribe is attached to a dialogAgent Agent.	The dialogAgent Agent is configured with a Blackboard.	"	| dialogAgent configuration scribe |	configuration := HumConfiguration messengerID: 'IDMessenger' 	                                 dispatcherID: 'IDDispatcher' 	                                 bookkeeperID: 'IDBookkeeper' 	                                  worldbaseID: 'IDWorldbase'. 	configuration messenger: HumMessenger new.	configuration openWorldBase.	dialogAgent := HumDialogAgent dialogID: 'dialogID' uri: 'dialogURI' client: 'clientURI' configuration: configuration.	scribe := HumScribe dialogAgent: dialogAgent. ! !!HumRunTimeTests methodsFor: 'Scribe Tests' stamp: 'RichardAlexanderGreen 11/8/2014 09:15'!testS100ScribeReadMe	"These Scribe tests generally involve a Scribe that is independent of Seaside.	If the client is running in HTML context, the HTML scribe will be invoked.	If the client is running in a VR context, the appropriate VR scribe will be invoked.	"	| |	"	When a dialog session is initiated, a Scribe is already present.	The Scribe mediates between the Dialog Agent and the user interface.	The Scribe translates user gestures into dialog vignette 'speech' inputs.	The user/client interface may be one of many technologies including:	 HTML forms,	 HTTP / AJAX / XMPP, 	 software embedded with hardware sensors,	 voice recognition,	 hand-gesture / body-language interpreters,	 virtual reality sensors,	 an automated agent message framework,	 or an internal unit-test user-simulator.	The first UI-connected Scribe will be built around HTML forms	 as that is a popular technology at this time (June 2014)."		"A Scribe is a HumActor that interprets user gestures seen by some set of sensors."	"In this set of tests, the Scribe interprets HTTP requests."		"General dataflow / workflow:	User authenticates via web application.	Web Application: ( Inform scribe that user connected.)	****	==> Scribe: ( Identify on-going dialog, if any. Set context. Operate vignette. )	****	==> Vignette: (Ask viewName) 	==> Dialog Agent: ( Delegate view operation to Scribe.)	==> Scribe: ( Translate view to HTML page. ) 	==> Scribe: ( Send HTML page to web browser.)	==> Browser: ( User fills in blanks and presses [[Submi`t Button]].)	==> Scribe: ( Captures data from Http Response and returns data to Dialog Agent in task-completion message. )	==> Dialog Agent: ( Registers data on blackboard and completes current vignette.)	"	"TODO: How does the Dispatcher know what kind of Scribe to delegate 'Ask viewName.' ???"	"Thinking Out Loud:	. Scribe is wrapper around a suite of sensors.	. That means it is determined by the user`s UI context. 	. . HTML: If Scribe is resident on Browser, it can be associated directly with HTML user/client.	. . HTML: If Scribe is server-side, it is associated with a session, and thus with an HTML client.	. . XMPP: If client is communicating via XMPP, Scribe can be an XMPP receiver.	. . Virtual World: Scribe must reside in the virtual world ??	. The Scribe and the user/client are indistinguishable from the PoV of other actors.	* Therefore: 	* . *** The Scribe must start the session and configure the Dialog Agent.***	* . The Dialog Agent must override or finess the Dispatcher to assign the correct Scribe instance.	* . Alternate: Add suitable 'back-door' methods to the Dispatcher. (JobTicket not relevant to Scribe.)	* . Alternate: The Dialog Agent by-passes the Dispatcher and delegates to Scribe actor directly.  * . . 	'( self messenger ) sendStatement: aMessageObject toID: recipientID fromID: myID.'	* . Alternate: Scribe instance role-name is unique. (Works if Dispatcher does not check against Ontology.)	"		"Summary - Restatement:	- When a session is instantiated BUT client is UNKNOWN,	. . a Scribe and a Dialog Agent MAY be instantiated, 	. . BUT the Dialog  will have no history and a temporary context stack.	- When a session is instantiated AND the client is identified,	. . a Scribe and a Dialog Agent will be instantiated, 	. . AND the Dialog will have history and context stack fetched from ??? WorldBase ???.	- Assuming the Dialog Agent is server-side,	. . we will instatiate it on the same server as the Dispatcher.	. . (In Erlang OTP, it will be ??? )	. . (In Java web server, it will be attached to the session.) 	. . (In Seaside web server, session (WASession subtype) will delegate to Dialog Agent.)	. . (In Smalltalk without Seaside, a response handler (HTTP/XMPP) will delegate to Dialog Agent.)	"! !!HumRunTimeTests methodsFor: 'Scribe Tests' stamp: 'RichardAlexanderGreen 2/26/2015 15:30'!testS131ScribeHandlesHttpPostRequest	"Scribe: Captures data from Http Response and returns data to Dialog Agent in task-completion message. "	"TODO: REFACTOR this test -- It is very confused."	| scribe request dialogAgent ontology |	"Setup the Dialog actor and the Scribe actor."	ontology := setupConfiguration ontology.	self setUpKnockKnockOnOntology: ontology.		dialogAgent := HumDialogAgent				dialogID: 'dialogID'				uri: 'dialogURI'				client: 'clientURI'				configuration: setupConfiguration.	dialogAgent blackboard businessEvent: 'testS131ScribeHandlesHttpPostRequest'.		"scribe := HumScribe scribeID: 'scribeID' 	                      dialog: 'dialogURI' 	                         uri: 'scribeURI' 	                      client: 'clientURI' 	               configuration: setupConfiguration. " "See >>setUp."	scribe := HumScribe dialogAgent: dialogAgent.	"scribe checkIn."		"Create this HTTP request. 	 HumHttpRequest is a wrapper around ??? (Seaside / Zinc / Comanche / MOCK) "	request := HumHttpRequest new.	"Set Http Request form to include this input - name:value pair."	request atField: 'entityName:attributeName' put: 'test value'.		"Ask Scribe to handle the request."	scribe handleHttpPostRequest: request.		"We should see data in Scribe`s Blackboard and a change in scribe state."	self expected: 'test value' 	       actual: ( scribe blackboard getEntityName: 'entityName' attribute: 'attributeName').		"We should also see data in the Dialog Agent`s blackboard"	self expected: 'test value' 	       actual: ( dialogAgent blackboard getEntityName: 'entityName' attribute: 'attributeName').	! !!HumRunTimeTests methodsFor: 'Scribe Tests' stamp: 'RichardAlexanderGreen 2/26/2015 15:30'!testS133ScribeMocksViewDataEntry	"Scribe: Captures data from Http Response and returns data to Dialog Agent in task-completion message. "	| baseOntology dialogAgent scribe viewFrame userEntries blackboard |	"TODO: REFACTOR this test -- It is very confused."	"Scenario:	1. Dialog matches vignette.	2. Vignette response contains 'Ask viewname.'	3. Dialog gets ViewFrame from Ontology.	4. Dialog delegates 'Ask' to Scribe.	5. HTML-Scribe generates HTML page/frame with needed HTML form elements.	6. HTML-Scribe sends HTML page/frame via a Session?	7. HTML-Scribe receives HTML-response from Session.	8. HTML-Scribe parses HTML-response and populates Dialog blackboard.	9. *** Form return is a Dialog Pattern???? ***"	true ifFalse: [Transcript cr; show: 'testS132ScribeHandlesViewReturn is turned off.'. ^self].		"Dialog delegates 'Ask' to Scribe"	baseOntology := HumOntology baseOntology.	self setUpKnockKnockOnOntology: baseOntology.	dialogAgent := HumDialogAgent dialogID: 'dialogID' 	                                   uri: 'dialogURI' 	                                client: 'clientURI' 	                         configuration: setupConfiguration.  dialogAgent blackboard businessEvent: 'testS133ScribeMocksViewDataEntry'.	scribe := HumScribe dialogAgent: dialogAgent.	viewFrame := baseOntology getViewFrame: 'Knock'.	scribe askView: viewFrame withBlackBoard: (dialogAgent blackboard). 		self expect: 'sendView: {	<form action="View: Knock." class="Ask" enctype="application/x-www-form-urlencoded" id="View: Knock." method="POST" >	<h2>Knock, knock, who`s there?</h2>  Please enter first name: <input type="text" name="Knock:first-name" value=""/> <input type="submit" value="Go!!"   style="color:WHITE; background:GREEN"/> <input type="submit" value="NoGo!!" style="color:WHITE; background:RED"/>	</form>}'			actual: (scribe log at: 1 ifAbsent: ['']).	"Mock data entry."	userEntries := Dictionary new.	userEntries		at: 'knock:first-name' put: 'Testy'.	scribe mockDataEntry: userEntries.	"The blackboard should now match data entered."	blackboard := dialogAgent blackboard.	self expect: 'Testy' actual: (blackboard getEntityName: 'knock' attribute: 'first-name').	"And the worldbase has also been updated"	self expect: 1 actual: (blackboard worldbase quads size).		! !!HumRunTimeTests methodsFor: 'Scribe Tests' stamp: 'RichardAlexanderGreen 2/26/2015 17:27'!testS132ScribeHandlesViewReturn	"Scribe: Captures data from Http Response and returns data to Dialog Agent in task-completion message. "	| baseOntology dialogAgent scribe viewFrame |	"TODO: REFACTOR this test -- It is very confused."	"Scenario:	1. Dialog matches vignette.	2. Vignette response contains 'Ask viewname.'	3. Dialog gets ViewFrame from Ontology.	4. Dialog delegates 'Ask' to Scribe.	5. HTML-Scribe generates HTML page/frame with needed HTML form elements.	6. HTML-Scribe sends HTML page/frame via a Session?	7. HTML-Scribe receives HTML-response from Session.	8. HTML-Scribe parses HTML-response and populates Dialog blackboard.	9. *** Form return is a Dialog Pattern???? ***"	true ifFalse: [Transcript cr; show: 'testS132ScribeHandlesViewReturn is turned off.'. ^self].		"Dialog delegates 'Ask' to Scribe"	baseOntology := HumOntology baseOntology.	self setUpKnockKnockOnOntology: baseOntology.	dialogAgent := HumDialogAgent dialogID: 'dialogID' 	                                   uri: 'dialogURI' 	                                client: 'clientURI' 	                         configuration: setupConfiguration.	scribe := HumScribe dialogAgent: dialogAgent.	viewFrame := baseOntology getViewFrame: 'Knock'.	dialogAgent blackboard businessEvent: 'Ask Knock'.	scribe askView: viewFrame withBlackBoard: (dialogAgent blackboard). 		self expect: 'sendView: {	<form action="View: Knock." class="Ask" enctype="application/x-www-form-urlencoded" id="View: Knock." method="POST" >	<h2>Knock, knock, who`s there?</h2>  Please enter first name: <input type="text" name="Knock:first-name" value=""/> <input type="submit" value="Go!!"   style="color:WHITE; background:GREEN"/> <input type="submit" value="NoGo!!" style="color:WHITE; background:RED"/>	</form>}'			actual: (scribe log at: 1 ifAbsent: ['']).	"htmlSent := scribe log at: 2.	 htmlSent inspect."		! !!HumRunTimeTests methodsFor: 'Configuration Tests' stamp: 'RichardAlexanderGreen 9/22/2014 14:47'!test005ApplicationConfigurationSetup	"This setup is used by several tests. "	"Define a Hum configuration."	| |	"#setUp creates a shared configuration."	self assert: ( setupMessenger uri  sameAs: 'mock messenger URI' ).	self assert: ( setupConfiguration messenger == setupMessenger ).	self assert: ( setupDispatcher isKindOf: HumDispatcher ).	self assert: ( setupDispatcher id sameAs: 'mock Dispatcher ID' ).	self assert: ( setupDispatcher uri sameAs: 'mock Dispatcher URI'  ).	self assert: ( setupBookkeeper isKindOf: HumBookkeeper ).	self assert: ( setupBookkeeper id sameAs: 'mock bookkeeper ID' ).	self assert: ( setupBookkeeper uri sameAs: 'mock bookkeeper URI'  ). 	self assert: ( setupWorker isKindOf: HumActor ).	self assert: ( setupWorker uri sameAs:  'mock worker URI'  ).	self assert: ( setupWorker id  sameAs: 'test workerID').	self assert: ( setupWorker roles = ( #('serf' 'cook' 'singer' 'composer')  )   ).	self assert: ( setupMessenger isKindOf: HumMessenger ).	self assert: ( setupMessenger ping: 'mock Dispatcher URI' ) == setupDispatcher id.	self assert: ( setupMessenger ping: 'mock bookkeeper URI' ) == setupBookkeeper id.	self assert: ( setupMessenger ping: 'mock worker URI' ) == setupWorker id.! !!HumRunTimeTests methodsFor: 'Configuration Tests' stamp: 'RichardAlexanderGreen 10/14/2014 13:05'!test000ApplicationConfigurationReadMe	"An application has a run-time configuration."	| |	"System	/Application Configuration:	A typical system will include these 'singleton' components: 	. Messenger: Assure messages are received and logged.	. Dispatcher: Assign actions to actors. (Tracks current system work-in-progress at actor level. )	. Bookkeeper: Record resource utilization as tasks complete.	. WorldBase: Record events, maintain entity state data. 	An active user / client session will also include session-bound instances of a:	. Dialog Agent: Conduct dialog with user / client actor. 	. Scribe: Mediate between Dialog and User Interface technology. 	. Ontology: A Dialog Agent interprets dialog vignettes found in a specific ontology.	Each running plan will also include an instance of a:	. Coordinator: Coordinate plan execution. (Tracks work-in-progress at plan level.)	. Ontology: An ontology must be present at the time the plan is built.Actor Configuration:	An Actor`s (minimal) configuration includes a Messenger and a Dispatcher.		During execution, most Actors have a BlackBoard where run-time data is persisted.	The BlackBoard may require the services of a WorldBase when the Actor`s actions affect the World. (typical)	"! !!HumRunTimeTests methodsFor: 'Coordinator Tests' stamp: 'RichardAlexanderGreen 3/25/2015 10:49'!test330twoPlanFrames	"Test with two plan frames.	"	| coordinator ontology  planFrameA planFrameB dictionaryFrame actionFrameA actionFrameB charges |	ontology := HumOntology new.	"Root frame has one prereq and one action"	planFrameA := HumFrame4Plan ontology: ontology goal: 'Complete the whole plan.'.	planFrameA 			appendPrecondition: 'Have song with title.';	 		appendRole: 'Singer' action: 'Sing song with title.'; 	   	 		compileToOntology: ontology.	"Create the corresponding action frame."	actionFrameA := HumFrame4Action ontology: ontology role: 'Singer' action: 'Sing song with title.'.	actionFrameA 			appendInstructionStatement: ' Open music book to given song title.';			appendInstructionStatement: ' Read song melody-notes and lyrics.';			appendInstructionStatement: ' Sing song melody-notes and lyrics.';			compileToOntology: ontology.		"Second level frame with no prereq and one action"		planFrameB := HumFrame4Plan ontology: ontology goal: 'Have song with title.'.	planFrameB 			appendRole: 'Composer' action: 'Compose song with title.';		 	compileToOntology: ontology.		"Create the corresponding action frame."	actionFrameB := HumFrame4Action ontology: ontology role: 'Composer' action: 'Compose song with title.'.	actionFrameB 			appendInstructionStatement: ' Publish music book with given song title.';			compileToOntology: ontology.		"We need at least one noun."	dictionaryFrame := HumFrame4Dictionary ontology: ontology title: 'Song has title, composer, et cetera'.	dictionaryFrame 			addDictionaryLine: 'Song attributes include title, composer, melody.';	 		compileToOntology: ontology.			setupConfiguration ontology: ontology.	coordinator := HumCoordinator coordinatorID: 'coordinator ID' 																		uri: 'myURI' 																		goal: 'Complete the whole plan.' 																		dialog: (HumDialogAgent new) 																		configuration: setupConfiguration. 																		coordinator checkIn.	coordinator runPlan.		self assert: (coordinator jobTicket notNil ).	charges := coordinator jobTicket charges.	self expect: 4 actual: ( charges size )description: 'Expecting N charges.'.! !!HumRunTimeTests methodsFor: 'Coordinator Tests' stamp: 'RichardAlexanderGreen 3/25/2015 10:48'!test320coordinatorInvokesAction	"Goal: Plan has one frame with no preconditions.	 Action:	 . Cook: Sing song called title.	"	| ontology planFrame dictionaryFrame  actionFrame coordinator dialogAgent charges |	true ifFalse: [ Transcript cr; show: 'test320coordinatorInvokesAction turned off'; cr. ^self].	ontology := HumOntology new.		"Define a few nouns."	dictionaryFrame := HumFrame4Dictionary ontology: ontology title: 'Song vocabulary'.	dictionaryFrame addDictionaryLine: 'Song attributes include title, lyrics, melody-notes.'.	"Compile it"	dictionaryFrame compileToOntology: ontology.	"Define a simple plan."	setupConfiguration ontology: ontology.	planFrame := HumFrame4Plan ontology: ontology goal: 'Plan has one frame with no preconditions.'.	planFrame appendRole: 'cook' action: 'Sing song called title.'.		"Create the corresponding action frame."	actionFrame := HumFrame4Action ontology: ontology role: 'cook' action: 'Sing song called title.'.	actionFrame 			appendInstructionStatement: ' Open music book to given song title.';			appendInstructionStatement: ' Read song melody-notes and lyrics.';			appendInstructionStatement: ' Sing song melody-notes and lyrics.'.	"Store it in the ontology."	ontology storeFrame: planFrame.	ontology storeFrame: actionFrame.		"Compile it."	planFrame compileToOntology: ontology.	actionFrame compileToOntology: ontology.	""	dialogAgent := HumActor dialogID: 'test dialog ID' 	                           uri: 'test dialog URL' 	                        client: 'client ID' 	                 configuration: setupConfiguration.	"Create a running instance of the plan and a coordinator to run it."	setupConfiguration ontology: ontology.	coordinator := HumActor coordinatorID: 'test coordinator ID' 	                              uri: 'test coordinator URL' 	                             goal: 'Plan has one frame with no preconditions.'								            dialog: dialogAgent	                    configuration: setupConfiguration.	self assert: (coordinator isKindOf: HumCoordinator ).				coordinator checkIn.			"Run the plan."	coordinator runPlan.			"After that plan has run. The goal will be fulfilled."	 self assert: ( coordinator remainingConditions isEmpty ).	"Now there should be at least one change on the job ticket."	charges := coordinator jobTicket charges.	self expect: 3 actual: ( charges size ) description: 'Expecting 3 charges.'		 	! !!HumRunTimeTests methodsFor: 'Coordinator Tests' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!test310coordinatorRunsPlan	"Dialog:	 . Coordinator to Dispatcher: Run action A for job J.	 . Dispatcher to Coordinator: Action A completed on job J.	"	| ontology planFrame dictionaryFrame  actionFrame coordinator dialogAgent |			true ifFalse: [ Transcript cr; show: 'test310coordinatorRunsPlan turned off'; cr. ^self].	"Create an ontology."	ontology := setupConfiguration ontology.	"Define a few nouns."	dictionaryFrame := HumFrame4Dictionary ontology: ontology title: 'Song vocabulary'.	dictionaryFrame addDictionaryLine: 'Song attributes include title, lyrics, melody-notes.'.	"Compile it"	dictionaryFrame compileToOntology: ontology.	"Define a simple plan."	setupConfiguration ontology: ontology.	planFrame := HumFrame4Plan ontology: ontology goal: 'Plan has one frame with no preconditions.'.	planFrame appendRole: 'cook' action: 'Sing song called title.'.		"Create the corresponding action frame."	actionFrame := HumFrame4Action ontology: ontology role: 'cook' action: 'Sing song called title.'.	actionFrame 			appendInstructionStatement: ' Open music book to given song title.';			appendInstructionStatement: ' Read song melody-notes and lyrics.';			appendInstructionStatement: ' Sing song melody-notes and lyrics.'.				"Store it in the ontology."	ontology storeFrame: planFrame.	ontology storeFrame: actionFrame.		"Compile it."	planFrame compileToOntology: ontology.	actionFrame compileToOntology: ontology.	""	dialogAgent := HumActor dialogID: 'test dialog ID' 	                           uri: 'test dialog URL' 	                        client: 'client ID' 	                 configuration: setupConfiguration.	dialogAgent checkIn.		"Create a running instance of the plan and a coordinator to run it."	coordinator := HumActor coordinatorID: 'test coordinator ID' 	                              uri: 'test coordinator URL' 	                             goal: 'Plan has one frame with no preconditions.'								            dialog: dialogAgent	                    configuration: setupConfiguration.	self assert: (coordinator isKindOf: HumCoordinator ).				coordinator checkIn.			"Run the plan."	coordinator runPlan.			"After that plan has run. The goal will be fulfilled."	 self assert: ( coordinator remainingConditions isEmpty ).	"Now there should be at least one change on the job ticket."	self assert: ( coordinator jobTicket charges notEmpty ) description: 'Job Ticket should not be empty'.	 ! !!HumRunTimeTests methodsFor: 'Coordinator Tests' stamp: 'RichardAlexanderGreen 3/25/2015 10:11'!test340planTreeBranches	"Test a plan tree with several levels and significant branching.	"	| coordinator ontology  planFrameA planFrameB1 planFrameB2 planFrameB3 planFrameC dictionaryFrame baker mixer oven actionFrameA actionFrameB1 actionFrameB2 actionFrameB3 actionFrameC |	ontology := HumOntology new.	"The root frame of this plan tree has several preconditions."	planFrameA := HumFrame4Plan ontology: ontology goal: 'Cake is baked per recipe.'.	planFrameA 		appendPrecondition: 'Oven is preheated per recipe.';	 	appendPrecondition: 'Cake batter is mixed per recipe.';	 	appendPrecondition: 'Cake-pan is greased.';	 	appendRole: 'baker' action: 'Bake cake batter in cake pan for recipe time.';	 	compileToOntology: ontology.	"Corresponding action frame:"	actionFrameA := HumFrame4Action ontology: ontology role: 'baker' action: 'Bake cake batter in cake pan for recipe time.'.	actionFrameA 		appendInstructionStatement: 'Dummy statement.'; 		compileToOntology: ontology.	"Second level frame -- This frame has a precondition, therefore a third level will be needed."	planFrameB1 := HumFrame4Plan ontology: ontology goal: 'Cake batter is mixed per recipe.'.	planFrameB1 appendPrecondition: 'Cake ingredients, per recipe, are assembled on mixing counter.'.	planFrameB1 appendRole: 'mixer' action: 'Mix ingredients per recipe.'.		planFrameB1 compileToOntology: ontology.	"Corresponding action frame:"	actionFrameB1 := HumFrame4Action ontology: ontology role: 'mixer' action: 'Mix ingredients per recipe.'.	actionFrameB1 		appendInstructionStatement: 'Dummy statement.'; 		compileToOntology: ontology.		"Another second level frame - has no precondtions at this time."	planFrameB2 := HumFrame4Plan ontology: ontology goal: 'Oven is preheated per recipe.'.	planFrameB2 appendRole: 'oven' action: 'Preheat to temperature given by recipe.'.	planFrameB2 compileToOntology: ontology.	"Corresponding action frame:"	actionFrameB2 := HumFrame4Action ontology: ontology role: 'oven' action: 'Preheat to temperature given by recipe.'.	actionFrameB2 		appendInstructionStatement: 'Dummy statement.'; 		compileToOntology: ontology.		"Still another second level frame - has no preconditions at this time."	planFrameB3 := HumFrame4Plan ontology: ontology goal: 'Cake-pan is greased.'.	planFrameB3 appendRole: 'mixer' action: 'Grease a cake-pan.'.	planFrameB3 compileToOntology: ontology.	"Corresponding action frame:"	actionFrameB3 := HumFrame4Action ontology: ontology role: 'mixer' action: 'Grease a cake-pan.'.	actionFrameB3 		appendInstructionStatement: 'Dummy statement.'; 		compileToOntology: ontology.		"Third level frame - has no preconditions at this time."	planFrameC := HumFrame4Plan ontology: ontology 	                                goal: 'Cake ingredients, per recipe, are assembled on mixing counter.'.	planFrameC appendRole: 'mixer' action: 'Assemble cake ingredients per recipe on mixing counter.'.	planFrameC compileToOntology: ontology.	"Corresponding action frame:"	actionFrameC := HumFrame4Action ontology: ontology role: 'mixer' action: 'Assemble cake ingredients per recipe on mixing counter.'.	actionFrameC 		appendInstructionStatement: 'Dummy statement.'; 		compileToOntology: ontology.		"We need at least one noun."	dictionaryFrame := HumFrame4Dictionary ontology: ontology title: 'Cake recipe vocabulary'.	dictionaryFrame addDictionaryLine: 'Recipe attributes include title, ingredients, steps.'.	dictionaryFrame addDictionaryLine: 'Cake-Recipe attributes include oven-temperature, oven-time.'.	dictionaryFrame addDictionaryLine: 'A pan is a container.'.	dictionaryFrame addDictionaryLine: 'A bowl is a container.'.	dictionaryFrame addDictionaryLine: 'A cake-pan is a baking-pan.'.	dictionaryFrame compileToOntology: ontology.			setupConfiguration ontology: ontology.	coordinator := HumCoordinator coordinatorID: 'coordinator ID' 																		uri: 'myURI' 																		goal: 'Cake is baked per recipe.' 																		dialog: (HumDialogAgent new) 																		configuration: setupConfiguration.	coordinator checkIn.		baker := HumActor workerID: 'bakerID' uri: 'bakerURI' roles: #('baker') configuration: setupConfiguration.	baker checkIn.	mixer := HumActor workerID: 'mixerID' uri: 'mixerURI' roles: #('mixer') configuration: setupConfiguration.	mixer checkIn.	oven := HumActor workerID: 'ovenID' uri: 'ovenURI' roles: #('oven') configuration: setupConfiguration.	oven checkIn.		coordinator runPlan.		self assert: (coordinator jobTicket notNil ).	self assert: (coordinator jobTicket charges notEmpty ) description: 'Job ticket should show charges.'.	self assert: (coordinator jobTicket charges size = 5 ).	"	Transcript cr; show: 'test340planTreeBranches'.	coordinator getActionSequence do: [:action | Transcript cr; show: action ].	Transcript cr.	"! !!HumRunTimeTests methodsFor: 'Coordinator Tests' stamp: 'RichardAlexanderGreen 11/3/2014 09:22'!test300CoordinatorReadMe"Coordinator - controls execution of plans and dialogs.   1. Execute Plans.			a) When a plan is evaluated, 			   the coordinator scans plan frames to find those whose actions are executable.			b) When a plan frame is executable, its action instructions are executed. (Sent to Dispatcher)			c) After the last plan action is executed, the plan frame`s post condition is asserted.			d) If an post-condition is the plan`s goal, we are done.			e) Iterate.				2. Provide a viewable model showing the execution state of each (every) plan frame in a running plan.			The State of plan frame may be pending / executing / suspended / fulfilled.			. Pending: The pre-conditions have not been satisfied.			. Executing: The plan actions statement/s are executing.			. Suspended: The execution of the action statements has been extended (Some business exception occurred.).			. Fulfilled: The post-condition has been asserted.								"! !!HumRunTimeTests methodsFor: 'setup and helpers' stamp: 'RichardAlexanderGreen 3/8/2012 20:27'!expect: actualValue is: expectedValue 	""	^ self		assert: (expectedValue = actualValue)		description: ( self comparingStringBetween: expectedValue and: actualValue ).! !!HumRunTimeTests methodsFor: 'setup and helpers' stamp: 'RichardAlexanderGreen 2/1/2015 10:00'!setUpKnockKnockOnOntology: anOntology	| viewFrame dictionaryFrame |	self assert: (anOntology isKindOf: HumOntology ).	"Provide a view frame."	viewFrame := HumFrame4View ontology: anOntology viewEntity: 'Knock'.	viewFrame addMarkUp: '!!!!Knock, knock, who`s there?'.	viewFrame addMarkUp: '  Please enter first name: [first-name]'.	"Provide a dictionary frame."	dictionaryFrame := HumFrame4Dictionary ontology: anOntology title: 'Knock attributes'.	dictionaryFrame addDictionaryLine: 'Knock attributes include first-name.'.		dictionaryFrame compileToOntology: anOntology .	viewFrame       compileToOntology: anOntology.! !!HumRunTimeTests methodsFor: 'setup and helpers' stamp: 'RichardAlexanderGreen 1/13/2012 15:23'!aReadMe	"See the class description for the intended (future) tests."	^'See the class description for the intended (future) tests.'	! !!HumRunTimeTests methodsFor: 'setup and helpers' stamp: 'RichardAlexanderGreen 4/1/2014 15:48'!expected:  expectedValue actual: actualValue 	""	^ self		assert: (expectedValue = actualValue)		description: ( self comparingStringBetween: expectedValue and: actualValue ).! !!HumRunTimeTests methodsFor: 'setup and helpers' stamp: 'RichardAlexanderGreen 8/14/2013 20:57'!tearDown	"Transcript cr; show: 'completed: ', (testSelector asString)."! !!HumRunTimeTests methodsFor: 'setup and helpers' stamp: 'RichardAlexanderGreen 2/22/2015 11:10'!setUp	"This setup is used by many run-time tests. 	It initializes: setupConfiguration setupMessenger setupDispatcher setupBookkeeper setupWorker "	| |	"Set the ID"	"Define a Hum configuration."	setupConfiguration := HumConfiguration messengerID: 'mock messenger ID' 	                                         dispatcherID: 'mock Dispatcher ID' 	                                      bookkeeperID: 'mock bookkeeper ID'                                         worldbaseID: 'mock worldbase ID'. "Mentioned but not instantiated?"	"Attach local messenger (Mock)".	setupMessenger := HumMessenger new.	setupMessenger id: 'mock messenger ID';								uri: 'mock messenger URI'.		setupConfiguration messenger: setupMessenger.	"Create worldbase instance and check-in."	setupConfiguration openWorldBase.	"A resource Dispatcher must know a messenger and a bookkeeper."	setupDispatcher := HumActor dispatcherID: 'mock Dispatcher ID'  	                                     uri: 'mock Dispatcher URI'  	                           configuration: setupConfiguration.							"A bookkeeper must know a messenger and a world base."						setupBookkeeper := HumActor bookkeeperID: 'mock bookkeeper ID' 	                                   uri: 'mock bookkeeper URI'  	                         configuration: setupConfiguration.		"A worker must know a messenger and a Dispatcher and some roles"	setupWorker := HumActor workerID: 'test workerID'  	                           uri: 'mock worker URI' 	                         roles: #( 'serf' 'cook' 'singer' 'composer')   	                 configuration: setupConfiguration.		"Messenger needs to know bookkeeper and Dispatcher"	setupMessenger registerActor: setupBookkeeper atURI: setupBookkeeper uri. 	setupMessenger registerActor: setupDispatcher atURI: setupDispatcher uri.	"Check in."	setupWorker checkIn.! !!HumRunTimeTests methodsFor: 'Messenger Tests' stamp: 'RichardAlexanderGreen 3/26/2015 13:19'!testM010MessengerRemembersActors	| messenger cook server |	"Create an actor -- The actor automatically registers itself with the messenger in its configuration."	cook := HumActor workerID: 'cook ID' uri: 'mock cook URI' roles: #('cook')  configuration: setupConfiguration.	cook checkIn.	messenger := setupConfiguration messenger.	self assert: ( messenger ping: 'mock cook URI' ) equals: cook id.	"One more should make no problem."	server := HumActor workerID: 'server ID' uri: 'server URI' roles: #('server') configuration: setupConfiguration.	server checkIn.	self assert: ( messenger ping: 'server URI' )= server id.	self assert: ( messenger ping: 'mock cook URI' ) == cook id.	! !!HumRunTimeTests methodsFor: 'Messenger Tests' stamp: 'RichardAlexanderGreen 7/10/2014 21:11'!testM110MessengerRemembersActors	| messenger cook server |	"Create an actor -- The actor automatically registers itself with the messenger in its configuration."	cook := HumActor workerID: 'cook ID' uri: 'mock cook URI' roles: #('cook')  configuration: setupConfiguration.	cook checkIn.	messenger := setupConfiguration messenger.	self assert: ( messenger ping: 'mock cook URI' ) equals: cook id.	"One more should make no problem."	server := HumActor workerID: 'server ID' uri: 'server URI' roles: #('server') configuration: setupConfiguration.	server checkIn.	self assert: ( messenger ping: 'server URI' )= server id.	self assert: ( messenger ping: 'mock cook URI' ) == cook id.	! !!HumRunTimeTests methodsFor: 'Messenger Tests' stamp: 'RichardAlexanderGreen 2/28/2015 10:25'!testM120MessageAttributes	"The components of a message include sender, receiver, when sent, statement, and noun-values. "	| message |	message := HumMessage title: 'message in testM120MessageAttributes'.	message sender: 'sender ID';	        receiver: 'receiver ID';	        whenSent: (Duration seconds: 120);	        statement: (HumStatement source: 'Bake a cake per recipe.');	        nounValues: #( 'recipe'->'Recipe 120' ).! !!HumRunTimeTests methodsFor: 'WorldBase Tests' stamp: 'RichardAlexanderGreen 2/28/2015 10:02'!test620setAndGet	"set entity-attribute value"	| worldBase entity value |	worldBase := HumWorldBase openWorldBase: 'WorldBase for test620setAndGet'.	self assert: worldBase notNil.	self assert: ( worldBase title = 'WorldBase for test620setAndGet' ).		entity := HumEntity title: 'Entity for test620setAndGet'.	worldBase setEntityID: (entity id) attribute: #description toValue: 'This is only a test.'.	value := worldBase getEntityID: (entity id) attribute: #description.	self assert: ( value == 'This is only a test.').! !!HumRunTimeTests methodsFor: 'WorldBase Tests' stamp: 'RichardAlexanderGreen 2/26/2015 17:16'!test615CreateUniqueIdentifier	"Create an instance of a Hum World Base (a database to be shared by multiple actors)."	|  id |	id := HumIdentifier createUniqueIdentifierForEntityName: 'test615' inContext: 'test615CreateUniqueIdentifier'.	self assert: (id isKindOf: HumIdentifier).		! !!HumRunTimeTests methodsFor: 'WorldBase Tests' stamp: 'RichardAlexanderGreen 9/22/2014 14:47'!test610CreateWorldBaseInstance	"Create an instance of a Hum World Base (a database to be shared by multiple actors)."	| worldBase |	worldBase := HumWorldBase openWorldBase: 'test610CreateWorldBaseInstance'.	self assert: worldBase notNil.	self assert: ( worldBase title = 'test610CreateWorldBaseInstance' ).! !!HumRunTimeTests methodsFor: 'WorldBase Tests' stamp: 'RichardAlexanderGreen 6/22/2014 10:08'!test600WorldBaseReadMe	"	A WorldBase implements the 'corporate memory' of an enterprise.	It is a kind of temporal database 	 which means each record is related to a business (world) event.		BlackBoards provide fast-memory persistence for Actors.	The WorldBase provides fail-back memory for BlackBoards.	The WorldBase implements an Entity-Attribute model of the world.	Entities have Attributes. Attributes have values which are time-stamped.	The time-stamps are associated with world events. (as observed by Hum Actors)		The basic persistence strategy is 'Remember everything short-term, forget some things later.'	(Short-form: 'Persist now, purge later.')		Retention rules are defined in terms of how-long (minutes, days, years) old attribute values are retained.	Many corporate legal departments prefer that old data be 'purged' to reduce 'discovery' costs and risks.	To be 'purged' means the data is erased from main repositories and archives.	The implementation of retention rules is currently low-priority. (We have to remember before we can forget.)	"! !!HumRunTimeTests methodsFor: 'WorldBase Tests' stamp: 'RichardAlexanderGreen 2/28/2015 10:03'!test630setGetReplace	"set entity-attribute value"	| worldBase entity value |	worldBase := HumWorldBase openWorldBase: 'test630setGetReplace'.	self assert: worldBase notNil.	self assert: ( worldBase title = 'test630setGetReplace' ).		entity := HumEntity title: 'Entity for test630setGetReplace'.	worldBase setEntityID: (entity id) attribute: #description toValue: 'This is only a test.'.	value := worldBase getEntityID: (entity id) attribute: #description.	self assert: ( value == 'This is only a test.').		worldBase setEntityID: (entity id) attribute: #description toValue: 'This WAS only a test.'.	value := worldBase getEntityID: (entity id) attribute: #description.	self assert: ( value == 'This is only a test.') not.	self assert: ( value == 'This WAS only a test.').		! !!HumRunTimeTests methodsFor: 'WorldBase Tests' stamp: 'RichardAlexanderGreen 2/26/2015 17:19'!test616CreateUniqueIdentifierDoesNotBreak	"Create an instance of a Hum World Base (a database to be shared by multiple actors)."	|  id newerID nTrial |	id := HumIdentifier createUniqueIdentifierForEntityName: 'test616CreateUniqueIdentifierDoesNotBreak' inContext: 'test616CreateUniqueIdentifierDoesNotBreak'.	self assert: (id isKindOf: HumIdentifier).		"Make sure it can handle high rate."	nTrial := 1000.	newerID := Array new: nTrial.	( 1 to: nTrial ) 		do: [:i | newerID at: i put: ( HumIdentifier createUniqueIdentifierForEntityName: ('try:',(nTrial asString) ) inContext: ('try:',(nTrial asString) ) ).].		self assert: (( id = (newerID at: nTrial) ) not).! !!HumRunTimeTests methodsFor: 'WorldBase Tests' stamp: 'RichardAlexanderGreen 3/6/2015 09:52'!test640FindWhere	"set entity-attribute value"	| worldBase entityA entityB entitySet |	worldBase := HumWorldBase openWorldBase: 'test640FindWhere'.	self assert: worldBase notNil.	self assert: ( worldBase title = 'test640FindWhere' ).		"Insert two entity instances with attribute vlaues."	entityA := HumIdentifier createUniqueIdentifierForEntityName: 'Person:A' inContext: 'test640FindWhere'.	worldBase setEntityID: entityA attribute: 'first-name' toValue: 'Tessie'.		worldBase setEntityID: entityA attribute: 'last-name'  toValue: 'Tester'.			entityB := HumIdentifier createUniqueIdentifierForEntityName: 'Person:B' inContext: 'test640FindWhere'.	worldBase setEntityID: entityB attribute: 'first-name' toValue: 'Terry'.		worldBase setEntityID: entityB attribute: 'last-name'  toValue: 'Terrence'.			"Return a set of entity identifiers satisfying my criteria."	entitySet := worldBase whereAttribute: 'first-name' satisfies: [:name | name beginsWith: 'T'].	self expect: 2 actual: (entitySet size).		"entitySet sorted asArray inspect."		"TODO: Decide: EntityType is innate. EntityType is an attribute."		! !!HumRunTimeTests methodsFor: 'Dialog Tests' stamp: 'RichardAlexanderGreen 1/16/2015 16:34'!test830dialogAgentMatchesInputToVignette	"Pattern 'Hello *.' matches 'Hello.'.	 Given: a set of vignettes (in an ontology)	 When: Scribe sends a user statement - clientSays: 'Hello.'	 Then: Dialog Agent matches user statement to available vignette patterns.	"	| vignetteFrame ontology pattern response dialogAgent  match |	ontology := HumOntology new.	setupConfiguration ontology: ontology.	pattern := 'Hello *.'.	vignetteFrame := HumFrame4Vignette 											ontology: ontology 											vignetteContext: 'Start.' 											pattern: pattern. 	response := 'Hello yourself.'.	vignetteFrame addVignetteResponse: response.	vignetteFrame compileToOntology: ontology.		dialogAgent := HumDialogAgent 										dialogID: 'Dialog Agent ID' 										uri: 'Dialog Agent URI' 										client: 'clientURI' 										configuration: setupConfiguration.	"Simulate call from Scribe."	match := dialogAgent clientSays: 'Hello.'.	self assert: ( match isKindOf: HumFrame4Vignette ).	self assert: ( match responseLines notEmpty ).	self assert: (( match responseLines at: 1 ) sameAs: 'Hello yourself.').! !!HumRunTimeTests methodsFor: 'Dialog Tests' stamp: 'RichardAlexanderGreen 7/2/2014 10:41'!test820createDialogAgent	"Create a dialog agent."	| dialogAgent |	dialogAgent := HumDialogAgent 										dialogID: 'Dialog Agent ID' 										uri: 'Dialog Agent URI' 										client: 'clientURI' 										configuration: setupConfiguration.! !!HumRunTimeTests methodsFor: 'Dialog Tests' stamp: 'RichardAlexanderGreen 4/20/2015 08:29'!test860dialogAgentMatchesInputWithNounSlot	"Pattern ('My name is [full-name].') matches 'My name is Tessie Tester.'.	 Given: a set of vignettes (in an ontology)	 When: Scribe sends a user statement	 Then: Dialog Agent matches user statement to available vignette patterns.	"	| vignetteFrame ontology pattern response dialogAgent  match responseLines stepLog |	ontology := HumOntology new.	ontology addEntity: 'user' attribute: 'name'.  	setupConfiguration ontology: ontology.	pattern := 'My name is [user name].'.	vignetteFrame := HumFrame4Vignette 											ontology: ontology 											vignetteContext: 'Start.' 											pattern: pattern. 												response := 'Welcome [user name].'.	vignetteFrame addVignetteResponse: response.	vignetteFrame compileToOntology: ontology.		dialogAgent := HumDialogAgent 										dialogID: 'Dialog Agent ID' 										uri: 'Dialog Agent URI' 										client: 'clientURI' 										configuration: setupConfiguration.	"Simulate call from Scribe."	match := dialogAgent clientSays: 'My name is Tessie Tester.'.	self assert: ( match isKindOf: HumFrame4Vignette ).	responseLines := match responseLines. 	self expect: 1 actual: ( responseLines size ).	self assert: ('*Sorry*' match: ( responseLines at: 1 ) source) not description: 'Don`t be sorry.'.	self expect: 'Welcome [user name].' actual: (( responseLines at: 1 ) source ).	"Was slot filled-in?"	stepLog := dialogAgent stepLog.	self expect: 'S: Welcome Tessie Tester.' actual: (stepLog at: 2).! !!HumRunTimeTests methodsFor: 'Dialog Tests' stamp: 'RichardAlexanderGreen 1/16/2015 16:34'!test840dialogAgentSorry	"Stimulus 'Help' returns 'Sorry ...'	 Given: a set of vignettes (in an ontology)	 When: Scribe sends a user statement	   Then: Dialog Agent attempts to match user statement to available vignette patterns.	 When: There is no match	   Then: The agent returns a 'sorry . . .' response	"	| vignetteFrame ontology pattern response dialogAgent  match |	ontology := HumOntology new.	setupConfiguration ontology: ontology.	pattern := 'Hello *.'.	vignetteFrame := HumFrame4Vignette 											ontology: ontology 											vignetteContext: 'Start.' 											pattern: pattern. 	response := 'Hello yourself.'.	vignetteFrame addVignetteResponse: response.	vignetteFrame compileToOntology: ontology.		dialogAgent := HumDialogAgent 										dialogID: 'Dialog Agent ID' 										uri: 'Dialog Agent URI' 										client: 'clientURI' 										configuration: setupConfiguration.	"Simulate call from Scribe."	match := dialogAgent clientSays: 'Help.'.	self assert: ( match isKindOf: HumFrame4Vignette ).	self assert: ( match responseLines notEmpty ).	self assert: (( match responseLines at: 1 ) sameAs: 'Hello yourself.') not.	self assert: (( match responseLines at: 1 ) source beginsWith: 'Sorry').	self assert: (( match responseLines at: 1 ) source sameAs: 'Sorry, { Help.} is not understood.').	! !!HumRunTimeTests methodsFor: 'Dialog Tests' stamp: 'RichardAlexanderGreen 1/16/2015 16:31'!test850dialogAgentMatchesInputWithAlternatePunctuations	"Pattern ('Hello *.' 'Hi *.') matches 'Hi!!'.	 Given: a set of vignettes (in an ontology)	 When: Scribe sends a user statement	 Then: Dialog Agent matches user statement to available vignette patterns.	"	| vignetteFrame ontology pattern response dialogAgent  match responseLines |	ontology := HumOntology new.	setupConfiguration ontology: ontology.	pattern := 'Hello *.'.	vignetteFrame := HumFrame4Vignette 											ontology: ontology 											vignetteContext: 'Start.' 											pattern: pattern. 	vignetteFrame addPattern: 'Hi *.'.												response := 'Welcome.'.	vignetteFrame addVignetteResponse: response.	vignetteFrame compileToOntology: ontology.		dialogAgent := HumDialogAgent 										dialogID: 'Dialog Agent ID' 										uri: 'Dialog Agent URI' 										client: 'clientURI' 										configuration: setupConfiguration.	"Simulate call from Scribe."	match := dialogAgent clientSays: 'Hi!!'.	self assert: ( match isKindOf: HumFrame4Vignette ).	responseLines := match responseLines. 	self expect: 1 actual: ( responseLines size ).	self expect: response actual: (( responseLines at: 1 ) source ).! !!HumRunTimeTests methodsFor: 'Dialog Tests' stamp: 'RichardAlexanderGreen 1/16/2015 16:34'!test833dialogAgentMatchesInputToVignette3	"Pattern ('Hello *.' 'Hi *.') matches 'Hi there.'.	 Given: a set of vignettes (in an ontology)	 When: Scribe sends a user statement	 Then: Dialog Agent matches user statement to available vignette patterns.	"	| vignetteFrame ontology pattern response dialogAgent  match |	ontology := HumOntology new.	setupConfiguration ontology: ontology.	pattern := 'Hello *.'.	vignetteFrame := HumFrame4Vignette 											ontology: ontology 											vignetteContext: 'Start.' 											pattern: pattern. 	vignetteFrame addPattern: 'Hi *.'.											response := 'Welcome.'.	vignetteFrame addVignetteResponse: response.	vignetteFrame compileToOntology: ontology.		dialogAgent := HumDialogAgent 										dialogID: 'Dialog Agent ID' 										uri: 'Dialog Agent URI' 										client: 'clientURI' 										configuration: setupConfiguration.	"Simulate call from Scribe."	match := dialogAgent clientSays: 'Hi there.'.	self assert: ( match isKindOf: HumFrame4Vignette ).	self assert: ( match responseLines notEmpty ).	self assert: (( match responseLines at: 1 ) source) equals: response.! !!HumRunTimeTests methodsFor: 'Dialog Tests' stamp: 'RichardAlexanderGreen 1/16/2015 16:34'!test834dialogAgentMatchesInputWithAlternatePunctuations	"Pattern ('Hello *.' 'Hi *.' 'Hi *!!' 'Hello * ?') matches 'Hi there.'.	 Given: a set of vignettes (in an ontology)	 When: Scribe sends a user statement	 Then: Dialog Agent matches user statement to available vignette patterns.	"	| vignetteFrame ontology pattern response dialogAgent  match |	ontology := HumOntology new.	setupConfiguration ontology: ontology.	pattern := 'Hello *.'.	vignetteFrame := HumFrame4Vignette 											ontology: ontology 											vignetteContext: 'Start.' 											pattern: pattern. 	vignetteFrame addPattern: 'Hi *.'.	vignetteFrame addPattern: 'Hi *!!'.	vignetteFrame addPattern: 'Hello * ?'.													response := 'Welcome.'.	vignetteFrame addVignetteResponse: response.	vignetteFrame compileToOntology: ontology.		dialogAgent := HumDialogAgent 										dialogID: 'Dialog Agent ID' 										uri: 'Dialog Agent URI' 										client: 'clientURI' 										configuration: setupConfiguration.	"Simulate call from Scribe."	match := dialogAgent clientSays: 'Hi there.'.	self assert: ( match isKindOf: HumFrame4Vignette ).	self assert: ( match responseLines notEmpty ).	self assert: (( match responseLines at: 1 ) source) equals: response.! !!HumRunTimeTests methodsFor: 'Dialog Tests' stamp: 'RichardAlexanderGreen 1/16/2015 16:33'!test810createSimpleVignette	"Create a vignette frame."	| vignetteFrame ontology pattern response |	ontology := HumOntology new.	setupConfiguration ontology: ontology.	pattern := 'Hello *.'.	vignetteFrame := HumFrame4Vignette 											ontology: ontology 											vignetteContext: 'Start.' 											pattern: pattern. 	response := 'Hello yourself.'.	vignetteFrame addVignetteResponse: response.	vignetteFrame compileToOntology: ontology. ! !!HumRunTimeTests methodsFor: 'Dialog Tests' stamp: 'RichardAlexanderGreen 6/4/2014 10:16'!test800DialogAgentReadMe	"Dialogs:	A Dialog Agent instance is associated with each active dialog.
  Active dialogs are long-running; 	so the state of the dialog must be persisted indefinitely.Session:	A session is defined by a connection to some client/user interface (UI) technology.	Between sessions, the state of the dialog is persisted.	When a new session begins, 	 the state is restored to assure continuity in the conversation.	(The user should feel that we remember them and what was said in the prior session.)Scribes:	When a dialog session is initiated, a Scribe is already present.	The Scribe mediates between the Dialog (Dialog Agent) and the user interface.	The Scribe translates user gestures into dialog vignette 'speech' inputs.	See: The Scribe ReadMe for more detail about the scribe.Clients:	It is generally assumed that the client actor will be human user.	However, dialogs may also be written for automated actors.	"! !!HumRunTimeTests methodsFor: 'Dialog Tests' stamp: 'RichardAlexanderGreen 1/16/2015 16:34'!test832dialogAgentMatchesInputToVignette2	"Pattern 'Hello *.' matches 'Hello Ms. Robot.'	 Given: a set of vignettes (in an ontology)	 When: Scribe sends a user statement -- clientSays: 'Hello Ms. Robot.'.	 Then: Dialog Agent matches user statement to vignette with wildcard. -- pattern := 'Hello *.'.	"	| vignetteFrame ontology pattern response dialogAgent  match responseLines |	ontology := HumOntology new.	setupConfiguration ontology: ontology.	pattern := 'Hello *.'.	vignetteFrame := HumFrame4Vignette 											ontology: ontology 											vignetteContext: 'Start.' 											pattern: pattern. 	response := 'Hello yourself.'.	vignetteFrame addVignetteResponse: response.	vignetteFrame compileToOntology: ontology.		dialogAgent := HumDialogAgent 										dialogID: 'Dialog Agent ID' 										uri: 'Dialog Agent URI' 										client: 'clientURI' 										configuration: setupConfiguration.	"Simulate call from Scribe."	match := dialogAgent clientSays: 'Hello Ms. Robot.'.	self assert: ( match isKindOf: HumFrame4Vignette ).	responseLines := match responseLines.	self expect: 1 actual: ( responseLines size ).	self expect: 'Hello yourself.' actual: ( responseLines at: 1 ) source.! !!HumRunTimeTests methodsFor: 'Dialog Tests' stamp: 'RichardAlexanderGreen 12/29/2014 06:54'!test825DialogAgentHasScribe	"When a dialog agent is activated, a Scribe is already present."	| dialogAgent |	"How is the scribe`s presence evidenced?	This constructor assumes that a Scribe mediates the URI.	We can assume that the Scribe is calling the constructor?General dataflow / workflow:	User authenticates via web application.	Web Application: ( Inform scribe that user connected.)	==> Scribe: ( Identify on-going dialog, if any. Set context. Operate vignette. )Thinking out loud:	Using a URI to identify the client makes several assumptions about the environment.	Q: Should this be a client ID instead? That would be more consistent with other constructors.	"	dialogAgent := HumDialogAgent 										dialogID: 'Dialog Agent ID' 										uri: 'Dialog Agent URI' 										client: 'clientURI' 										configuration: setupConfiguration.	self assert: (dialogAgent scribeProxy isKindOf: HumScribe ).! !!HumRunTimeTests methodsFor: 'Actor Tests' stamp: 'RichardAlexanderGreen 9/14/2014 13:33'!test120workerCheckInMessage	"Worker checks-in, announcing roles."	"The check-in protocol has the worker-side and the resource dispatcher side."	"Worker says:	. dispatcher: Check-in worker W with roles R.	The dispatcher adds the worker to its (role -> worker) knowledge."	|  worker dispatcher message |		"Get the worker from the setup."	worker := setupWorker.	self assert: ( worker isKindOf: HumActor ).	self assert: ( worker roles include: 'serf' ).		"Get the resource dispatcher from the setup."	dispatcher := setupDispatcher.	self assert: ( dispatcher isKindOf: HumDispatcher ).	"Use a Smalltalk coded message to tell dispatcher."	"To: Execute the check-in directly, we would say:"	"dispatcher checkInActor: worker name at: 'worker uri' withRoles: worker roles."		message := 'self checkInActor: ', ('worker id') quoted, ' at: ', ('worker uri') quoted, ' withRoles: #(', ('cook') quoted, ').'.	Compiler evaluate: message for: dispatcher logged: false.		"dispatcher now includes worker in set of those who know that role."	self assert: ( dispatcher roleActor includes: ( 'cook' -> 'worker id' ) ).	! !!HumRunTimeTests methodsFor: 'Actor Tests' stamp: 'RichardAlexanderGreen 3/26/2015 13:16'!test105actorConfiguration	"A Hum Actor is configured with the address of a messenger node.	Actors communicate by sending predefined message types via the messenger.	"	|   messenger worker dispatcher   bookkeeper |	true ifFalse: [ Transcript cr; show: 'test105actorConfiguration is TURNED OFF'; cr. ^self].	"Create the (mock) messenger service"	messenger := HumMessenger uri: 'mock messenger URI'.	self assert: ( messenger uri  sameAs: 'mock messenger URI' ).		"A resource dispatcher must know a messenger and a bookkeeper."	dispatcher := HumActor dispatcherID: 'test dispatcher'  	                        uri: 'mock dispatcher URI' 	              configuration: setupConfiguration.	self assert: ( dispatcher isKindOf: HumDispatcher ).	self assert:  dispatcher uri sameAs: 'mock dispatcher URI'.		"A bookkeeper must know a messenger and a world base."						bookkeeper := HumActor bookkeeperID: 'test bookkeeper'  	                              uri: 'mock bookkeeper URI' 	                    configuration: setupConfiguration.	self assert: bookkeeper uri sameAs: 'mock bookkeeper URI'.									"A worker must know a messenger and a dispatcher and some roles"	worker := HumActor workerID: 'test cook ID' uri: 'test cook URI' roles: #( 'cook' 'bottle-washer' 'bar-tender' 'psych' ) configuration: setupConfiguration. 	self assert: worker uri sameAs:  'test cook URI'.				! !!HumRunTimeTests methodsFor: 'Actor Tests' stamp: 'RichardAlexanderGreen 9/14/2014 13:33'!test130workerChecksInViaMessenger	"Worker checks-in, announcing roles."	"The check-in protocol has the worker-side and the resource dispatcher side."	"Worker says:	. dispatcher: Check-in worker W with roles R.	The dispatcher adds the worker to its (role -> worker) knowledge."	|  worker dispatcher |		"Get the worker from the setup."	worker := setupWorker.		"Get the resource dispatcher from the setup."	dispatcher := setupDispatcher.	self assert: ( dispatcher isKindOf: HumDispatcher ).	"Tell the worker to check-in."	worker checkIn.		"dispatcher now includes worker in set of those who know that role."	self assert: ( dispatcher roleActor includes: ( 'serf' -> worker id ) ).	! !!HumRunTimeTests methodsFor: 'Actor Tests' stamp: 'RichardAlexanderGreen 11/3/2014 09:03'!test135workerChecksOutViaMessenger	"Worker checks-in, announcing roles."	"The check-in protocol has the worker-side and the resource dispatcher side."	"Worker says:	. dispatcher: Check-in worker W with roles R.	The dispatcher adds the worker to its (role -> worker) knowledge."	|  worker dispatcher |		"Get the worker from the setup."	worker := setupWorker.		"Get the resource dispatcher from the setup."	dispatcher := setupDispatcher.	self assert: ( dispatcher isKindOf: HumDispatcher ).	"Tell the worker to check-in."	worker checkIn.		"dispatcher now includes worker in set of those who know that role."	self assert: ( dispatcher roleActor includes: ( 'serf' -> worker id ) ).		"Tell the worker to check-out."	worker checkOut.	self assert: ( dispatcher roleActor includes: ( 'serf' -> worker id ) ) not.	! !!HumRunTimeTests methodsFor: 'Actor Tests' stamp: 'RichardAlexanderGreen 9/14/2014 13:42'!test100ActorReadMe	"Jobs and Tasks:		An Hum Actor executes action statements assigned by the Resource Dispatcher.	Action assignments include a JobTicket to which resources are added as used, including the actor`s time.	A JobTicket is started when a Plan is started. It is associated with the plan goal (instance).Messenger:	Actors communicate via the Messenger which provides a wrapper around some communication technology.	The Messenger also logs messages for diagnosis and replay purposes. 
  (The actor need not bother with that level of logging.)Roles:		Action Statements procedures are defined in Ontology Action Frames that are collected under a Role.	When an Actor 'checks-in' with its Resource Dispatcher, it claims to 'know' one or more Roles.	The Resource Dispatcher may then assign an Action to an Actor that knows the associated Role.	Delegation:	An Actor may delegate an instruction`s action to another Role.	While the other role is executing, the current execution is suspended. 	When the other role 'returns', 	. the message-receiver interface restores state (via BlackBoard) 	. and resumes execution.	Actor Configuration:	The Actor`s (minimal) configuration includes a Messenger and a Resource Dispatcher.		During execution, most Actors have a BlackBoard where run-time data is persisted.	The BlackBoard typically requires the services of a WorldBase:	. when Actor delegates an instruction (action) to another role (because current state must be peristed)	. when the Actor`s actions affect the World. 	. . (WorldBase retention rules define what is remembered, what is forgotten.)	System	/Application Configuration:	A typical system will include these 'singleton' components: 	. Messenger: Assure messages are received and logged.	. Resource Dispatcher: Assign actions to actors. (Tracks current system work-in-progress at actor level. )	. Bookkeeper: Record resource utilization as tasks complete.	. WorldBase: Record events, maintain entity state data. 	An active user / client session will also include session-bound instances of a:	. Dialog Agent: Conduct dialog with user / client actor. 	. Scribe: Mediate between Dialog and User Interface technology. 	. Ontology: A Dialog Agent interprets dialog vignettes found in a specific ontology.	Each running plan will also include an instance of a:	. Coordinator: Coordinate plan execution. (Tracks work-in-progress at plan level.)	. Ontolog: An ontology must be present at the time the plan is built.	"! !!HumRunTimeTests methodsFor: 'Actor Tests' stamp: 'RichardAlexanderGreen 9/14/2014 13:33'!test110workerChecksIn	"Worker checks-in, announcing roles."	"The check-in protocol has the worker-side and the resource dispatcher side."	"Worker says:	. dispatcher: Check-in worker W with roles R.	The dispatcher adds the worker to its (role -> worker) knowledge."	|  worker dispatcher |		"Get the worker from the setup."	worker := setupWorker.	self assert: ( worker isKindOf: HumActor ).	self assert: ( worker roles include: 'serf' ).		"Get the resource dispatcher from the setup."	dispatcher := setupDispatcher.	self assert: ( dispatcher isKindOf: HumDispatcher ).		"Execute the check-in directly."	dispatcher checkInActor: 'worker id' at: 'worker uri' withRoles: worker roles.		"dispatcher now includes worker in set of those who know that role."	self assert: ( dispatcher roleActor includes: ( 'serf' -> 'worker id' ) ).			! !!HumRunTimeTests methodsFor: 'Dispatcher Tests' stamp: 'RichardAlexanderGreen 3/17/2015 12:06'!test210DispatcherAssignsAction	"Some actor delegates a task to a role.	The Dispatcher assigns the task to an actor that advertises that role	and sends the task (work order) to the assigned actor.	"	| baker  bookkeeper oven ontology frameEditor jobTicket actionInstruction dispatcher frameEditor2 |	true ifFalse: [ Transcript cr; show: 'test210DispatcherAssignsAction turned off'; cr. ^self].		"Get the Dispatcher from the setup."	dispatcher := setupDispatcher.	self assert: ( dispatcher isKindOf: HumDispatcher ).	"Create a baker worker"	baker := HumActor workerID: 'bakerId' uri: 'bakerURI' roles: #('baker') configuration: setupConfiguration.	self assert: (baker uri sameAs: 'bakerURI').	"Create another actor to be oven. " 	oven := HumActor workerID: 'ovenID' uri: 'ovenURI' roles: #( 'oven' ) configuration: setupConfiguration.	self assert: (oven uri sameAs:  'ovenURI' ).	"Tell the actors to check-in."	baker checkIn.	oven checkIn.		"======= Set up the action frame  =========="	ontology := setupConfiguration ontology.		"Initialize for an Action Frame."	frameEditor := HumFrameUpdater ontology: ontology  	                                   role: 'Baker' 	                                 action: 'Bake the pan in the oven for the time given in the recipe.'.	"Append an instruction that is delegated"	frameEditor 			appendInstructionRole: 'Oven' statement: 'Bake for the time given in recipe.';	 		storeFrameInOntology .	"We need at least one noun."	ontology addNoun: 'recipe'.		frameEditor2 := HumFrameUpdater ontology: ontology	 																	role: 'Oven'																		action: 'Bake for the time given in recipe.'.	frameEditor2			appendInstructionStatement: ' Set oven timer to the time given in recipe.';			appendInstructionStatement: ' Set oven temperature to the temperature given in recipe.';			appendInstructionStatement: ' Start.';			storeFrameInOntology.				"============== ================="	"We will pretend to be Coordinator running a plan.	There will be a Job Ticket for the plan.	The Coordinator will ask the Dispatcher to assign an actor to run the action.	"	jobTicket := HumJobTicket title: 'Ttest210DispatcherAssignsAction'.	self assert: ( jobTicket isKindOf: HumEntity ).	actionInstruction := HumInstructionLine role: 'Baker' statement: 'Bake the pan in the oven for the time given in the recipe.'.  actionInstruction statement noun: 'recipe' value: 'white cake'.	actionInstruction jobTicket: jobTicket.	dispatcher assignRole: 'Baker' action: actionInstruction.	"After the task is done, a resource usage entry will be sent to the bookkeeper."	bookkeeper := setupBookkeeper.	self assert: ( bookkeeper isKindOf: HumBookkeeper ).	self assert: ( bookkeeper jobTickets size > 0 ).	"See also: Bookkeeper tests."	! !!HumRunTimeTests methodsFor: 'Dispatcher Tests' stamp: 'RichardAlexanderGreen 9/14/2014 14:13'!test200DispatcherReadMe"The Dispatcher (RM) - assigns tasks to actors.   1. Actor checks-in (announces availability to perform specific roles).   2. Assign task (action-statement) to actor.      a) Job-ticket contains action-statement, noun-values,             request context (requesting actor, and instruction-pointer).      b) The RM assigns an available actor.      c) The RM sends the job-ticket to the assigned actor.             (via Messenger)   3. Actor has completed task.      a) The resources consumed (actors time, etc) are recorded on the job ticket.      b) Any computed results are added to the job-ticket.            (Convention: Actions with results have a 'giving' clause.)      c) RM sends resource consumption data to Bookkeeper.      d) Task complete notice (with job-ticket) is sent to requester.            (The requester resumes execution of the plan.)   4. Delegate task.         (The current actor has delegated a task to another role.)      a) Send delegated task to Dispatcher. (RM)         (The RM will assign the task to an available actor.)       b) If an actor delegates to a role which it also knows,            the delegated action is assigned to the same actor.      c) Persist actor state during a delegation         (Since delegations may be long-running,           we need a way to persist actor state during a delegation.)					Q: Where is the push-down stack in this context? Does the RM maintain it? (A: Basically, yes.)					Q: Does the actor persist its own state while suspended or does the RM maintain it? (A: Actor via BB)					Solution-1: If the target framework (e.g. Erlang OTP) maintains state, we do not need to.					Solution-2: Perhaps, the RM should maintain caller`s state during a delegation. 					Solution-2.1: This has the advantage of being able to survey the complete application state in one place.					Solution-2.2: But we could also do that by querying the WorldBase or active actors. (See solution-3 next.)					Solution-3: The Hum persistence framework (BlackBoard plus WorldBase) persists the actor`s state.    <<<					Solution-3.1: State is in the actor`s BlackBoard (BB), and the BB implements a 'resume' capability.  <<<					Solution-3.2: This implies: RM sees delegate return ==> sends resume to actor ==> BB is persistent.  <<<					Solution-3.3: BB saves/fetches (snapshots) to/from WorldBase (WB). ==> Lots of eggs in WB !!!!!!!!					solution-3.4: The actor supertype message-receive interface will activate the BB, et cetera.   5. Resume suspended action.         When a instruction is delegated to another role, the current task execution is suspended.         When the delegation (call) completes, the requestor resumes execution.   6. Maintain model of all the known actors` assignment-state. 			Actors may be idle, engaged, suspended. 			(Note: Actor instances are 'single-threaded' but may delegate instructions to self.)			. Idle: No action assigned. (Actor is available for suitable assignments.)			. Engaged: An action is assigned but not yet completed. (Action is in-progress)			. Suspended: An action instruction has been delegated to another actor. (This actor is waiting for other actor.)			"! !!HumRunTimeTests methodsFor: 'Network Tests' stamp: 'RichardAlexanderGreen 3/26/2015 13:46'!test100ReadMe	"Network is a wrapper on whatever technology is used to communicate between Actors.""Features:"	"The Network component provides serialization and de-serialization of Message instances (see HumMessage)."	"Design Note: The serialization strategy assumes 'payload' is not sensitive to communication stack."	"The Network sends/receives messages (wrapping the communication technology)."! !!HumRunTimeTests methodsFor: 'Bookkeeper Tests' stamp: 'RichardAlexanderGreen 9/22/2014 13:54'!test410BookkeeperRecordsJobTickets	"If we ask the bookkeeper to 'run' a jobTicket, it stores it in its jobTickets collection.'"	| ticket bookie |	ticket := HumJobTicket title: 'test410BookkeeperRecordsJobTickets'.	bookie := setupBookkeeper.	bookie recordJobTicket: ticket.	self assert: ( bookie jobTickets includes: ticket ) .! !!HumRunTimeTests methodsFor: 'Bookkeeper Tests' stamp: 'RichardAlexanderGreen 11/3/2014 09:16'!test420BookkeeperSums	"The bookkeeper tracks utilization of an actor by action, actor, role, job.	"	| ticket bookie action  aJobID |		ticket := HumJobTicket title: 'test420BookkeeperSums'.	action := 'This is only a test of the bookkeeper.'.	aJobID := UUID new.		"Measures are tracked by action, role, actor, and job."	#( 1 3 5 ) 		do: [ :q | 			| m anID aRoleName |			m := HumMeasure quantity: q units: #step.			anID := 'test actor ID', q asString.			aRoleName := 'tester', q asString.			ticket appendCharge: m forAction: action byActor: anID inRole: aRoleName onJob: aJobID . 			m := HumMeasure quantity: q*10 units: #kilometer.			ticket appendCharge: m forAction: action byActor: anID inRole: aRoleName onJob: aJobID . 			].    "Send to bookkeeper."	bookie := setupBookkeeper.	bookie recordJobTicket: ticket.	self assert: ( bookie jobTickets includes: ticket ) .		"Bookkeeper tracks utilization by Action."	self assert: ( bookie chargesByAction size = 2).	"Bookkeeper tracks utilization by Actor."	self assert: ( bookie chargesByActor size = 6).	"Bookkeeper tracks utilization by Role."	self assert: ( bookie chargesByRole size = 6).	"Bookkeeper tracks utilization by Job."	self assert: ( bookie chargesByJob size = 2).	"Sum by metric (calls, steps, gross counts)"	self assert: ( bookie chargesByMetric size = 2).	self assert: ( bookie chargesByMetric at: 'total:step') = (HumMeasure quantity: 9 units: #step).	self assert: ( bookie chargesByMetric at: 'total:kilometer') = (HumMeasure quantity: 90 units: #kilometer).		false ifTrue: [ "Inspect result"		| sums |		sums := bookie chargesByRole.		sums inspect.		].	! !!HumRunTimeTests methodsFor: 'Bookkeeper Tests' stamp: 'RichardAlexanderGreen 11/3/2014 09:15'!test400BookkeeperReadMe	"A Bookkeeper tracks resource utilization.	It maintains resource utilization accounts, but at a fundamental level, 	those accounts are denominated in resource measures, not monetary measures.	This enables detailed cost accounting. 	However, most industries and companies have their own unique monetization rules;	so, we do not attempt to build those into the Bookkeeper.	But the Bookkeeper can be extended to include monetization rules. 	TODO: Experiment with a subtype that prices the resource utilization.	"! !Object subclass: #GivenWhenThen4Seaside	instanceVariableNames: 'log givenBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!GivenWhenThen4Seaside commentStamp: 'RichardAlexanderGreen 3/17/2014 14:36' prior: 0!see: WACanvasBrushTest for examples of how this test framework is used.Note: the base methods are copied from Hum-Tests GivenWhenThenInstance Variables:	log	<OrderedCollection>	givenBlock	<Object>!!GivenWhenThen4Seaside methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/26/2015 13:09'!expect: expectedValue actual: actualValue 	self assert: (expectedValue = actualValue)	     description: ( 'Expected: ', expectedValue asString,' actual: ', actualValue asString ).! !!GivenWhenThen4Seaside methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!when: aDescriptionString code: whenBlock	"*When* in a given-when-then triplet 	-- Use to trigger events or add to state.	The code may contain asserts to self-check.	"	"Run the given block to reset to initial state.	This enables a sequence such as: Given, When, Then, When, Then.	It allows the When blocks to create contradicting states.	"	givenBlock value.	"Now run my block"	self log:  ( 'When: ', aDescriptionString, String cr ).	whenBlock value.	^self.	! !!GivenWhenThen4Seaside methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!assertString: stringA includesSubstring: stringB	 " stringB should be a substring in stringA "	| quote x |	quote := $' asString.	x := stringA findString: stringB.	self assert: (x > 0) description: 'Expecting ', quote, stringA, quote, ' contains ', quote, stringB, quote.! !!GivenWhenThen4Seaside methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!then: aDescriptionString code: aBlock	"*Then* in a given-when-then triplet 	-- Use to test post-condition after the given and then have run.	The code may contain asserts to self-check.	"	self log:  ( 'Then: ', aDescriptionString ).	"Run my assertions."	aBlock value.	^self.	! !!GivenWhenThen4Seaside methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!log	^ log ifNil: [ log := OrderedCollection new. ].! !!GivenWhenThen4Seaside methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!givenWhenThenComment	"The #given:code: and #when:code: and #then:code: methods are designed to be cascaded.	Note that #when:code: runs the block provided in the call to #given:code: to set-up initial condition.	That enables multiple *when-then* sequences to run even if they might interfere with each other.	However, you still need to be careful of side-effects.	"	^ 'The #given:code: and #when:code: and #then:code: methods are designed to be cascaded.	Note that #when:code: runs the block provided in the call to #given:code: to set-up initial condition.	That enables multiple *when-then* sequences to run even if they might interfere with each other.	However, you still need to be careful of side-effects.'! !!GivenWhenThen4Seaside methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!log: aString	| entry |	"Prepend a CR to make inspection more readable."	( aString beginsWith: (String cr) )		ifTrue: [ entry := aString ] ifFalse: [ entry := String cr, aString ].	( self log ) add: aString.! !!GivenWhenThen4Seaside methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!given: aDescriptionString code: aBlock	"Given in a given-when-then triplet 	-- use to setup test context (initial state).	The code may contain asserts to self-check.	"	self log:  ( String cr, 'Given: ', aDescriptionString ).	"Save the block so that multiple *when* can restore initial state before running."	givenBlock := aBlock.	^self.	! !!GivenWhenThen4Seaside methodsFor: 'self test' stamp: 'RichardAlexanderGreen 12/13/2013 11:09'!test106GivenWhenThenFail	"Test the test utility - In this situation the test assertion is true."	| test x y z |	test := self class basicNew.	"Normally, this test is not needed."	false ifFalse: [^self].	test := self class basicNew.		"A typical test looks like this."		test		given: 'given description' code: [ x:= 'given set'];		when: 'when description'  code: [ y := 'when set'];		"Following should show assertion fails."		then: 'then description' 			code: [ z := 'then set'. 							self assert: (false).							 ].	self should: [test then: 'should fail' code: [ self assert: false ] ] raise: AssertionFailure.		! !!GivenWhenThen4Seaside methodsFor: 'self test' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!test120GivenWhenThenLogging	"Test the testcase`s own log"	| test x y z |	test := self class basicNew.	"A typical test looks like this."		test		given: 'given description' code: [ x:= 'given set'];		when: 'when description'  code: [ y := 'when set'];		then: 'then description' code: [ z := 'then set'. self assert: (true) ].	"The log should contain the descriptions."	self assertString: ( test log at: 1 ) includesSubstring: 'given description'.		self assertString: ( test log at: 2 ) includesSubstring: 'when description'.		self assertString: ( test log at: 3 ) includesSubstring: 'then description'.			! !!GivenWhenThen4Seaside methodsFor: 'self test' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!test105GivenWhenThenSuccess	"Test the test utility - In this situation the test assertion is true."	| test x y z |	test := self class basicNew.	"A typical test looks like this."		test		given: 'given description' code: [ x:= 'given set'];		when: 'when description'  code: [ y := 'when set'];		then: 'then description' code: [ z := 'then set'. self assert: (true) ].	"Blocks should have executed."	self assert: ( x sameAs: 'given set' ).	self assert: ( y sameAs: 'when set' ).	self assert: ( z sameAs: 'then set' ).		! !!GivenWhenThen4Seaside methodsFor: 'self test' stamp: 'RichardAlexanderGreen 2/19/2013 11:23'!test110BasicLog	"Test the testcase`s own log"	| test |	test := HumSeasideTests new.	test log: 'This is only a test'.	self assert: ( (test log at: 1 ) sameAs: 'This is only a test' ).! !!GivenWhenThen4Seaside methodsFor: 'testing' stamp: 'RichardAlexanderGreen 3/25/2014 09:29'!assert: aBlock matches: aPatternString 	"This is a utility function to improve readability."	| html |	html := self builder render: aBlock.	self		assert: ( aPatternString matches: html )		description:	'Expected: ', ( aPatternString printString ), ', Actual: ', ( html printString )		resumable: true.		! !!GivenWhenThen4Seaside methodsFor: 'testing' stamp: 'RichardAlexanderGreen 4/20/2015 08:32'!assert: aBlock match: aPatternString 	"This is a utility function to improve readability."	| html |	html := self builder render: aBlock.	self		assert: ( aPatternString match: html )		description:	'Expected: ', ( aPatternString printString ), ', Actual: ', ( html printString )		resumable: true.		! !GivenWhenThen4Seaside subclass: #HumSeasideTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumSeasideTests commentStamp: 'RichardAlexanderGreen 2/19/2013 11:21' prior: 0!This class (super class) holds the tests where Seaside is used to implement various Hum capabilities.Subclasses:- HumSeasideProgrammersAssistantTests holds tests for the Seaside implementation of the Programmers Assistant.- HumSeasideUserInterfaceTests hold tests for the Seaside implementation of the view-frame interpreter.Note that the Programmers Assistant is partially implemented in Hum, so that the PA implementation depends on the View and Dialog implementation.TODO: This class duplicates methods from GivenWhenThen. Consider using a trait or composition instead.!HumSeasideTests subclass: #HumSeasideProgrammersAssistantTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumSeasideProgrammersAssistantTests commentStamp: 'RichardAlexanderGreen 11/6/2012 15:59' prior: 0!These HumSeasideTests are adapted from HumProgrammerAssistantTests.	The Programmers Assistant provides a technology-free model of the UI.	The Hum Seaside classes provide UI components via Seaside.!!HumSeasideProgrammersAssistantTests methodsFor: 'PA200 Menu Dialogs' stamp: 'RichardAlexanderGreen 11/3/2012 11:48'!test222OpenOntologyInstance	"Test the dialog that asks the user for the file name."	| browser fileName |	"	Given: User has invokes 'Open ontology' in the browser menu.	When: User enters an existing (test) filename . . .	Then: The ontology attached to the browser matches the content of the test file.	"	browser := HumBrowser new.	browser loadOntologyInstance: 'Hum Seaside Test Ontology'.	self assert: (browser ontology isKindOf: HumOntology).	self assert: browser ontology title = 'Hum Seaside Test Ontology'.	! !!HumSeasideProgrammersAssistantTests methodsFor: 'PA100 Ontology Actions' stamp: 'RichardAlexanderGreen 11/3/2012 11:49'!test130saveOntology	"Browser saves (writes) the ontology to a file."	| browser |	browser := HumBrowser new.	browser clearOntology.	browser saveOntology.	! !!HumSeasideProgrammersAssistantTests methodsFor: 'PA100 Ontology Actions' stamp: 'RichardAlexanderGreen 11/3/2012 11:49'!aReadMe	"	These HumSeasideTests are adapted from HumProgrammerAssistantTests.	The Programmers Assistant provides a technology-free model of the UI.	The Hum Seaside classes provide a UI in Seaside.	"	^'See the class description for the intended (future) tests.'	! !!HumSeasideProgrammersAssistantTests methodsFor: 'PA100 Ontology Actions' stamp: 'RichardAlexanderGreen 11/3/2012 11:49'!test110newOntology	"Browser initializes (re-initializes) to an empty ontology."	| browser |	browser := HumBrowser new.	browser clearOntology.	self assert: (browser ontology nouns isEmpty).! !!HumSeasideProgrammersAssistantTests methodsFor: 'PA100 Ontology Actions' stamp: 'RichardAlexanderGreen 11/3/2012 11:49'!test121loadOntologyInstance	"Browser saves (writes) the ontology to a file."	| browser ontology |	browser := HumBrowser new.	browser loadOntologyInstance: 'Hum Seaside Test Ontology'.	self assert: browser ontology notNil.	browser saveOntology.	! !HumSeasideTests subclass: #HumSeasideUserInterfaceTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumSeasideUserInterfaceTests commentStamp: 'RichardAlexanderGreen 11/3/2012 11:59' prior: 0!This class holds tests of a Seaside implementation of Hum User Interface concepts.!!HumSeasideUserInterfaceTests methodsFor: 'PA300 View Code Generator' stamp: 'RichardAlexanderGreen 5/20/2014 09:23'!test312ViewHeader	"A Hum view frame is rendered as a Seaside Form.	TODO: Figure out how to handle read-only form later.	"	| ontology  viewFrame frameCode |	ontology := HumOntology new.		"Initialize the View Frame for this test."     self setUpViewFrameInOntology: ontology.	"There is only one frame in this ontology."	viewFrame :=  ontology fetchFrameByName: 'View: recipe.'.	self assert: viewFrame notNil. 	"Generate Seaside code for the view frame."	frameCode := ontology codeGenerator generateSeasideForView: viewFrame..	self assert: ( frameCode isKindOf: String ).	self assert: ( frameCode includesSubString: 'html form' ).	self assert: ( frameCode includesSubString: 'html break' ).	self assert: ( frameCode includesSubString: 'html heading level: 2' ).	self assert: ( frameCode includesSubString: 'Recipe').	! !!HumSeasideUserInterfaceTests methodsFor: 'PA300 View Code Generator' stamp: 'RichardAlexanderGreen 5/20/2014 09:23'!test310ViewBecomesForm	"A Hum view frame is rendered as a Seaside Form.	TODO: Figure out how to handle read-only form later.	"	| ontology  viewFrame frameCode |	ontology := HumOntology new.		"Initialize the View Frame for this test."     self setUpViewFrameInOntology: ontology.	"There is only one frame in this ontology."	viewFrame :=  ontology fetchFrameByName: 'View: recipe.'.	self assert: viewFrame notNil. 	"Generate Seaside code for the view frame."	frameCode := ontology codeGenerator generateSeasideForView: viewFrame.		self assert: ( frameCode isKindOf: String ).	self assert: ( frameCode findString: 'html form')  > 1.! !!HumSeasideUserInterfaceTests methodsFor: 'PA300 View Code Generator' stamp: 'RichardAlexanderGreen 2/24/2013 10:01'!checkGeneratedCode	"This is a place to see if generated code will compile."! !!HumSeasideUserInterfaceTests methodsFor: 'PA300 View Code Generator' stamp: 'RichardAlexanderGreen 8/22/2013 15:25'!setUpViewFrameInOntology: aHumOntology	"Generate a view frame and dictionary entries for several tests.	---	!!!! Recipe	recipe-name: [name]	  description: [description]	  ingredients: [ingredients]	        steps: [steps]	---	Dictionary: Recipe attributes.	. Recipe attributes include recipe-line, description, ingredients, steps.	. Description is a text.	. Recipe has a set of ingredients.	. Recipe has a list of steps.	---	"	| frameEditor errors |	"Create a view frame."	frameEditor := HumFrameUpdater ontology: aHumOntology viewEntity: 'recipe'.	"Add markup lines."	frameEditor addMarkUp: '!!!! Recipe'.	frameEditor addMarkUp: ' recipe-name: [name]'.	frameEditor addMarkUp: '   description: [description]'.	frameEditor addMarkUp: '   ingredients: [ingredients]'.	frameEditor addMarkUp: '         steps: [steps]'.	aHumOntology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).	errors := frameEditor compileToOntology: aHumOntology.	self assert: ( errors isEmpty  ).		"TODO: Make this smarter. 	- At the very least, description, ingredients, and steps could be of type text.	- (and rendered using textarea tag).	"		"Create a dictionary frame."	frameEditor := HumFrameUpdater ontology: aHumOntology dictionaryTitle: 'Recipe attributes.'.	frameEditor addDictionaryLine: 'Recipe attributes include recipe-line, description, ingredients, steps.'.	frameEditor addDictionaryLine: 'Description is a text.'.	"TODO: Should render description as a text area."	frameEditor addDictionaryLine: 'Recipe has a set of ingredients.'.	"TODO: Should render ingredients as an unordered list."	frameEditor addDictionaryLine: 'Recipe has a list of steps.'.	"TODO: Should render steps as an ordered list."	errors := frameEditor compileToOntology: aHumOntology.	self assert: ( errors isEmpty  ).	 			! !!HumSeasideUserInterfaceTests methodsFor: 'PA300 View Code Generator' stamp: 'RichardAlexanderGreen 5/20/2014 09:23'!test311ViewHasMultipleLines	"A Hum view frame is rendered as a Seaside Form.	TODO: Figure out how to handle read-only form later.	"	| ontology  viewFrame frameCode |	ontology := HumOntology new.		"Initialize the View Frame for this test."     self setUpViewFrameInOntology: ontology.	"There is only one frame in this ontology."	viewFrame :=  ontology fetchFrameByName: 'View: recipe.'.	self assert: viewFrame notNil. 	"Generate Seaside code for the view frame."	frameCode := ontology codeGenerator generateSeasideForView: viewFrame.	self assert: ( frameCode includesSubString: 'html form' ).	self assert: ( frameCode includesSubString: 'html break' ).! !!HumSeasideUserInterfaceTests methodsFor: 'PA300 View Code Generator' stamp: 'RichardAlexanderGreen 5/20/2014 10:47'!test313ViewField	"A Hum view frame is rendered as a Seaside Form.	TODO: Figure out how to handle read-only form later.	"	| ontology  viewFrame frameCode |	ontology := HumOntology new.		"Initialize the View Frame for this test."     self setUpViewFrameInOntology: ontology.	"There is only one frame in this ontology."	viewFrame :=  ontology fetchFrameByName: 'View: recipe.'.	self assert: viewFrame notNil. 	"Generate Seaside code for the view frame."	frameCode := ontology codeGenerator generateSeasideForView: viewFrame..	self assert: ( frameCode isKindOf: String ).	self assert: ( frameCode includesSubString: 'html form' ).	self assert: ( frameCode includesSubString: 'html break' ).	self assert: ( frameCode includesSubString: 'html heading level: 2' ).	self assert: ( frameCode includesSubString: 'html textInput callback: [').			self assert: ( frameCode includesSubString: 'setEntityID:').	self assert: ( frameCode includesSubString: 'toValue:').	self assert: ( frameCode includesSubString: '#name').			self assert: ( frameCode includesSubString: 'ingredients' ).		"See if the resulting code will compile in the context of a HumDialogAgent."		(Parser new) parse: ('checkRenderOn: html', String cr, frameCode) class: HumView.		"Transcript show: '*** test313ViewField frameCode: ***'; cr; show: frameCode; cr."	! !!HumSeasideUserInterfaceTests methodsFor: 'PA300 View Code Generator' stamp: 'RichardAlexanderGreen 4/20/2015 09:46'!test314CheckGeneratedCode	"This is a place to see if generated code will compile and run."	| result anEntityID |		result := self builder render: [ :html | 	anEntityID := 'TestThisRecipe'.	"Following is pasted from test313ViewField Transcript show: 	TODO: Find a way to put in an actual method.	"	html form with: [ 		html break. html heading level: 2; with: ' Recipe'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #name toValue: datum ]; name: 'name'; value: 'name'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #description toValue: datum ]; name: 'description'; value: 'description'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #ingredients toValue: datum ]; name: 'ingredients'; value: 'ingredients'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #steps toValue: datum ]; name: 'steps'; value: 'steps'.		].	].	"Expect the HTML output to look like this."	"Compare strings ignoring differences in white space."	self assert: ( HumCalculator string: result isLike: '	<form accept-charset="utf-8" method="post" action="/">	  <br/>	  <h2>Recipe</h2>	  <br/><input name="name" value="name" type="text" class="text"/>	  <br/><input name="description" value="description" type="text" class="text"/>	  <br/><input name="ingredients" value="ingredients" type="text" class="text"/>	  <br/><input name="steps" value="steps" type="text" class="text"/>	</form>' ).	"		TODO: THIS IS JUST A CRUDE FIRST APPROXIMATION. 	It does not take data-types into account when selecting the rendering mode.	LONGER TERM: 	- Description should be a textarea with rows and columns.	- Ingredients and steps could be a table/list with some way to edit the entries.	- Ingredients (set) could be rendered as an unordered list.	- Steps (list) could be rendered as an ordered list.	 "	! !HumTestCase subclass: #HumCalculatorTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumCalculatorTests commentStamp: 'RichardAlexanderGreen 1/13/2012 15:25' prior: 0!The Calculator role (agent) provides - base level arithmetic (using measures)- string utilities used to parse Hum source code.!!HumCalculatorTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:38'!test550CasualMeasures	"Work with non-KMS measures. Develop HumMeasure2"	| milesPerHour feetPerMile feetPerHour secondsPerHour feetPerSecond|	milesPerHour := HumMeasure quantity: 60 units: 'mile' per: 'hour'.	self assert: ((milesPerHour dimensions) at: 'mile') = 1.	self assert: ((milesPerHour dimensions) at: 'hour') = -1.		feetPerMile := HumMeasure quantity: 5280 units: 'foot' per: 'mile'.	self assert: ((feetPerMile dimensions) at: 'foot') = 1.	self assert: ((feetPerMile dimensions) at: 'mile') = -1.			feetPerHour := milesPerHour * feetPerMile.	self assert: ((feetPerHour dimensions) at: 'foot') = 1.	self assert: ((feetPerHour dimensions) at: 'hour') = -1.		secondsPerHour := HumMeasure quantity: 3600 units: 'second' per: 'hour'.	self assert: ((secondsPerHour dimensions) at: 'second') = 1.	self assert: ((secondsPerHour dimensions) at: 'hour') = -1.		feetPerSecond := feetPerHour / secondsPerHour.	self assert: ((feetPerSecond dimensions) at: 'foot') = 1.	self assert: ((feetPerSecond dimensions) at: 'second') = -1.	self assert: (60*5280/3600) equals: (feetPerSecond quantity).		! !!HumCalculatorTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:38'!test556CasualMeasuresSquares	"Test asString"	| squareFeet squareYard squareFeetPerSquareYard |		squareFeet := HumMeasure quantity: 900 units: 'square feet'.	squareFeetPerSquareYard := HumMeasure quantity: 9 units: 'square feet' per: 'square yard'.	squareYard := squareFeet / squareFeetPerSquareYard.	self assert: '100 square yard' equals: ( squareYard asString ).	! !!HumCalculatorTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:38'!test552CasualMeasuresAdd	"Work with non-KMS measures. Develop HumMeasure2"	| pretax taxRate tax total |	pretax := HumMeasure quantity: 100.0 units: 'dollar'.	taxRate := HumMeasure quantity: 0.06 units: 'dollar' per: 'dollar'.	tax := pretax * taxRate.	total := pretax + tax.		self assert: (total quantity) = 106.00.! !!HumCalculatorTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 8/12/2014 09:58'!test510measurePlusSameUnits	"Measures may be added if same units."	| m1 m2 m3 |	m1 := HumMeasure quantity: 10 units: #meter.	m2 := HumMeasure quantity: 20 units: #meter.	m3 := m1 + m2.	self expect: m3 quantity actual: 30.	self expect: m3 units actual: #meter.	! !!HumCalculatorTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:38'!test540CommonUnits	| v d t a |	"Test that these do not crash"	v := 10 kps.                 "kilometers per second = approximate escape velocity (10.735 going East at equator)"	self assert: (10*1000) equals: (v quantity). 		a := 20 mps / (1 second).    "meters per second per second = approximately 2 G acceleration"	self assert: (20) equals: (a quantity).	self assert: ( Dictionary newFrom: { 'meter'->1. 'second'->(-2). } ) equals: (a dimensions).	self assert: 'meter per square second' equals: ( a units ).		t := v / a.                  "How many seconds to reach escape velocity?"	self assert: (10*1000/20) equals: (t quantity).	self assert: ( Dictionary newFrom: { 'second'->1. } ) equals: ( t dimensions ).	self assert: 'second' equals: ( t units ).		d := ( a / 2 ) * ( t * t ) . "How much distance covered in that amount of time?"	self assert: ((20/2)* (10*1000/20) * (10*1000/20)) equals: ( d quantity ).	"Transcript cr; show: 'test540CommonUnits d = '; show: d asString."		! !!HumCalculatorTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:38'!test553CasualMeasuresSubtract	"Work with non-KMS measures. Develop HumMeasure2"	| prediscount discountRate discount total |	prediscount := HumMeasure quantity: 100.0 units: 'dollar'.	discountRate := HumMeasure quantity: 0.05 units: 'dollar' per: 'dollar'.	discount := prediscount * discountRate.	total := prediscount - discount.		self assert: (total quantity) = 95.00.! !!HumCalculatorTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:38'!test560coefficientOfExpansion	"Sometimes the exponents are all negative."	| coefficient |	"coefficient of expansion for aluminum	See: http://www.engineeringtoolbox.com/linear-expansion-coefficients-d_95.html"	coefficient := HumMeasure quantity: 22.2e-6 per: #degreeKelvin.	self assert: ( Dictionary newFrom: { 'degreeKelvin' -> (-1). } ) equals: ( coefficient dimensions ).	! !!HumCalculatorTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 11/24/2014 13:56'!test581megaWattToAcceleration	"What kind of acceleration does a megaWatt per tonne give?"	| power mass vSquared energy deltaVqty deltaV acceleration |	power := 1 megaWatt.	mass := 1 tonne.	energy := power * (1 second) .		"kinetic energy KE = mass * v * v / 2. 	==> v := sqrt{ 2 * KE / mass }	"	vSquared := (( energy / mass ) * 2.0).	deltaVqty := (vSquared quantity ) sqrt.	deltaV := deltaVqty meterPerSecond.	self expect: '44.721 meterPerSecond' actual: (deltaV as: #meterPerSecond).	acceleration := deltaV / (1 second).	self expect: '4.560 gravity' actual: ( acceleration as: #gravity ).	! !!HumCalculatorTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:38'!test555CasualMeasuresAsString	"Test asString"	| force distance work time power length width area height volume|	force := HumMeasure quantity: 550 units: 'pound'.	self assert: (force asString) = '550 pound'.	distance := HumMeasure quantity: 1 units: 'foot'.	self assert: (distance asString) = '1 foot'.	work := force * distance.	self assert: '550 foot pound' equals: (work asString).	time := HumMeasure quantity: 1 units: 'second'.	"check ' per '"	power := work / time.	self assert: '550 foot pound per second' equals: (power asString).	"Check square"	length := HumMeasure quantity: 10 units: 'feet'.	width  := HumMeasure quantity: 20 units: 'feet'.	area := length * width.	self assert: ('200 square foot') equals: (area asString).	"Check cubic"	height := HumMeasure quantity: 8 units: 'feet'.	volume := area * height.	self assert: ('1600 cubic foot') equals: (volume asString).			! !!HumCalculatorTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 8/12/2014 09:59'!test520measureMinusSameUnits	"Measures may be added if same units."	| m1 m2 m3 |	m1 := HumMeasure quantity: 10 units: #meter.	m2 := HumMeasure quantity: 25 units: #meter.	m3 :=  m2 - m1.	self expect: m3 quantity actual: 15.	self expect: m3 units actual: #meter.! !!HumCalculatorTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:38'!test557CasualMeasuresCubics	"Test asString"	| cubicFeet cubicYard cubicFeetPercubicYard |		cubicFeet := HumMeasure quantity: 2700 units: 'cubic feet'.	cubicFeetPercubicYard := HumMeasure quantity: 27 units: 'cubic feet' per: 'cubic yard'.	cubicYard := cubicFeet / cubicFeetPercubicYard.	self assert: '100 cubic yard' equals: ( cubicYard asString ).	! !!HumCalculatorTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:38'!ztest530measureTimesPercent	"Percent times percent produces percent"	| m1 m2 m3 |	m1 := HumMeasure percent: 10.	m2 := HumMeasure percent: 25.	m3 :=  m2 * m1.	self expect: m3 quantity is: (0.10 * 0.25 * 100).	self expect: m3 units is: #percent. 	! !!HumCalculatorTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:38'!test542UnitsShouldCancel	| v d t a m kineticEnergy |	"Test that these do not crash"	v := 10 kps.	self assert: ( Dictionary newFrom: { 'meter'->1. 'second'->(-1). } ) equals: ( v dimensions ).		a := 2 gravity.	self assert: ( Dictionary newFrom: { 'meter'->1. 'second'->(-2). } ) equals: ( a dimensions ).		t := v / a.	self assert: ( Dictionary newFrom: { 'second'->(1). } ) equals: ( t dimensions ).		d := a * t * t / 2.	self assert: ( Dictionary newFrom: { 'meter'->1. } ) equals: ( d dimensions ).		m := 1 tonne. "metric ton"	self assert: ( Dictionary newFrom: { 'kilogram'->1. } ) equals: ( m dimensions ).	kineticEnergy := m * v * v / 2.	self assert: ( Dictionary newFrom: { 'kilogram'->1. 'meter'->2. 'second'->(-2). } ) equals: ( kineticEnergy dimensions ).		! !!HumCalculatorTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:38'!test570CreateMeasureFromString	"Create a measure from a sting of the form: -999 units"	| string expect result |	string := '-123 meter'.	result := HumMeasure fromString: string.	expect := HumMeasure quantity: -123 units: #meter.	self assert: expect equals: result.	! !!HumCalculatorTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 4/18/2015 09:01'!test546ConvertVolumeMeasures	| s a volume cubicInch displacement asLitre |	s := 1 inch.	a := s * s.	volume := a * s. 	cubicInch := volume.	displacement := cubicInch * 400. 	self expect: ( HumMeasure quantity: 0.0065548256 units: 'cubic meter') actual: (displacement).		asLitre := displacement as: #litre. 	self expect: '6.555 litre' actual: asLitre.! !!HumCalculatorTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 4/20/2015 09:50'!test545Conversions	| v vDisplay d dDisplay t a aDisplay |	"Test that these do not crash"	v := 10 kps.                 "kilometers per second = approximate escape velocity (10.735 going East at equator)"	self expect: (10*1000) actual: (v quantity). 	vDisplay := v as: #mph.	self assert: '22369.419 mph' equals: vDisplay.		a := 20 mps / (1 second).    "meters per second per second = approximately 2 G acceleration"	self expect: (20) actual: (a quantity).	self expect: ( Dictionary newFrom: { 'meter'->1. 'second'->(-2). } ) actual: (a dimensions).	self expect: 'meter per square second' actual: ( a units ).	aDisplay := a as: #gravity.	self pattern: '2.*gravity' matches: aDisplay .		t := v / a.                  "How many seconds to reach escape velocity?"	self expect: (10*1000/20) actual: (t quantity).	self expect: ( Dictionary newFrom: { 'second'->(1). } ) actual: ( t dimensions ).	self expect: 'second' actual: ( t units ).		d := ( a / 2 ) * ( t * t ) . "How much distance covered in that amount of time?"	self expect: ((20/2) * (10*1000/20) * (10*1000/20)) actual: ( d quantity ).	dDisplay := d as: #miles.	self assert: ( '1553.432 miles' = dDisplay ).	"	Transcript cr; show: 'test545Conversions'.	Transcript show: ' v =  ', v asString.	Transcript show: ' a =  ', a asString.	Transcript show: ' t =  ', t asString.	Transcript show: ' d =  ', d asString.	Transcript cr.	"		! !!HumCalculatorTests methodsFor: 'Measure Tests' stamp: 'RichardAlexanderGreen 4/18/2015 09:26'!test580exampleBussardRamJet	| pi area speed z beta gamma volume density energy energyPerHydrogen ePerSecond |	pi := Float pi.	area :=  (1 km) * (1 km) * pi. "Assume the ram scoop is a circle."	speed := 0.1 lightSpeed.		"Is relatvity relevant at this speed?"	z := 0.1 * 0.1.      "v squared over c squared"	beta := (1 - z) sqrt.	gamma := 1.0 / beta. 	self assert: (gamma < 1.06 )."~ 1.05 :: Ignored because smaller than other engineering uncertainties. "		"The interstellar medium within the Local Bubble has a density of about 0.07 atoms/cm3"	density := (HumMeasure quantity: 0.07 units: #HydrogenAtom)/(1 cubicCentimeter).	energy := (26.7 mev)/ 4. "CNO fusion energy per hydrogen atom"	energyPerHydrogen := energy / (HumMeasure quantity: 1 units: #HydrogenAtom).		"How much power does the CNO fusion provide?"	volume := area * speed. "volume per second"	ePerSecond := volume * density * energyPerHydrogen.	self expect: (HumMeasure quantity: 7.05e6 units: #joule per: #second) actual: ePerSecond.	"Seems way too small to power, let alone move, a structure 1 km in radius." 		! !!HumCalculatorTests methodsFor: 'HumVector Tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:38'!testV115VectorCrossProduct	"Check the vector cross product"	| u v s |	u := HumVector newFrom: #( 5.0 0.0 0.0 ).	v := HumVector newFrom: #( 0.0 5.0 0.0 ).		s := u cross: v.	self assert: ( s at: 1 ) = 0.0.	self assert: ( s at: 2 ) = 0.0.	self assert: ( s at: 3 ) = 25.0.		! !!HumCalculatorTests methodsFor: 'HumVector Tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:38'!testV113VectorCrossProduct	"Check the vector cross product"	| u v s |	u := HumVector newFrom: #( 0.0 1.0 0.0 ).	v := HumVector newFrom: #( 1.0 0.0 0.0 ).		s := u cross: v.	self assert: ( s at: 1 ) =  0.0.	self assert: ( s at: 2 ) =  0.0.	self assert: ( s at: 3 ) = -1.0.		! !!HumCalculatorTests methodsFor: 'HumVector Tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:38'!testV111VectorCrossProduct	"Check the vector cross product"	| u v s |	u := HumVector newFrom: #( 0.0 0.0 1.0 ).	v := HumVector newFrom: #( 0.0 1.0 0.0 ).		s := u cross: v.	self assert: ( s at: 1 ) = -1.0.	self assert: ( s at: 2 ) =  0.0.	self assert: ( s at: 3 ) =  0.0.		! !!HumCalculatorTests methodsFor: 'HumVector Tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:38'!testV110VectorCrossProduct	"Check the vector cross product"	| u v s |	u := HumVector newFrom: #( 1.0 0.0 0.0 ).	v := HumVector newFrom: #( 0.0 1.0 0.0 ).		s := u cross: v.	self assert: ( s at: 1 ) = 0.0.	self assert: ( s at: 2 ) = 0.0.	self assert: ( s at: 3 ) = 1.0.		! !!HumCalculatorTests methodsFor: 'HumVector Tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:38'!testV210IdentityVector	"Creat a identity vector I * V = V.	u * v = v.	"	| i  v |	i := HumVector ones: 3.	v := HumVector newFrom: #( 1.0 2.0 3.0 ).	self assert: ( i * v ) = v.	self assert: ( i dot: i ) = 3.0.	self assert: ( i dot: v ) = 6.0.	self assert: ( i cross: i ) = ( HumVector zero: 3 ).					! !!HumCalculatorTests methodsFor: 'HumVector Tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:38'!testV117VectorCrossProduct	"Check the vector cross product"	| u v s |	u := HumVector newFrom: #( 5.0 2.0 0.0 ).	v := HumVector newFrom: #( 2.0 5.0 0.0 ).		s := u cross: v.	self assert: ( s at: 1 ) = 0.0.	self assert: ( s at: 2 ) = 0.0.	self assert: ( s at: 3 ) = 21.0.		! !!HumCalculatorTests methodsFor: 'HumVector Tests' stamp: 'RichardAlexanderGreen 7/14/2014 09:38'!testV112VectorCrossProduct	"Check the vector cross product"	| u v s |	u := HumVector newFrom: #( 0.0 1.0 0.0 ).	v := HumVector newFrom: #( 0.0 0.0 1.0 ).		s := u cross: v.	self assert: ( s at: 1 ) =  1.0.	self assert: ( s at: 2 ) =  0.0.	self assert: ( s at: 3 ) =  0.0.		! !!HumCalculatorTests methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 6/13/2014 08:50'!test120substringBetween	"Test helper method that finds a substring between two given substrings."	| stringIn stringOut calc |	stringIn := 'This is just the begining. We are expecting the stuff between [ and ].'.	stringOut := HumCalculator given: stringIn extractBetween: '[' and: ']'.	self assert: ( stringOut sameAs: ' and ' ).		stringIn := 'This is just the begining. We are expecting the stuff between [[button]].'.	stringOut := HumCalculator given: stringIn extractBetween: '[[' and: ']]'.	self assert: ( stringOut sameAs: 'button' ).		calc := HumCalculator new.	self assert: (calc given: 'lunch snacks dinner' extractBetween: 'lunch' and: 'dinner') = ' snacks '.! !!HumCalculatorTests methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 10/7/2014 13:17'!test310parse	"calc parse: s - recognizes quoted strings as single tokens."	| string calc tokens n |	string := 'This is a "quoted text"?'.	calc := HumCalculator new.	tokens := calc parse: string.	n := tokens size.	self expect: 8 actual: n.	self expect: {'This'. #word. 1. 4. } actual: (tokens at: 1).	self expect: {' '. #whitespace. 5. 5. } actual: ( tokens at: 2).	self expect: {'?'. #separator. 24. 24. } actual: (tokens at: n).	self expect: {'"quoted text"'. #string. 11. 23. } actual: (tokens at: (n-1)).	self expect: {' '. #whitespace. 10. 10. } actual: (tokens at: (n-2)).	! !!HumCalculatorTests methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 10/8/2014 09:41'!test314parse	"Test parse with quote within string."	| string calc tokens quote |	quote := $" asString.	string := 'Parse a ''internal quote (',quote,')'''.	calc := HumCalculator new.	tokens := calc parse: string.	self expect: 5 actual: (tokens size).	self expect: { '''internal quote (',quote,')'''. #string. 9. 28.} actual: tokens last.	"TODO: Think about following convention where doubled quote within a string is treated as embedded quote."	"TODO: Think about following convention where special characters are preceded with back-slash (\)."! !!HumCalculatorTests methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 10/7/2014 13:18'!test311parse	"What if string ends with quoted text?"	| string calc tokens n |	string := 'This is a "quoted text"'.	calc := HumCalculator new.	tokens := calc parse: string.	n := tokens size.	self expect: 7 actual: n.	self expect: {'This'. #word. 1. 4. } actual: (tokens at: 1).	self expect: {' '. #whitespace. 5. 5. } actual: ( tokens at: 2).	self expect: {'"quoted text"'. #string. 11. 23. } actual: (tokens at: (n)).	self expect: {' '. #whitespace. 10. 10. } actual: (tokens at: (n-1)).	! !!HumCalculatorTests methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 6/13/2014 08:44'!test110substringAfter	"Test helper method that finds a substring between two given substrings."	| stringIn stringOut calc|	stringIn := 'This is just the begining. We are expecting content after this colon: And this is it.'.	stringOut := HumCalculator given: stringIn extractAfter: ':'.	self assert: ( stringOut sameAs: ' And this is it.' ).		stringIn := 'This is just the begining. We are expecting content after this operator := Right hand side.'.	stringOut := HumCalculator given: stringIn extractAfter: ':='.	self assert: ( stringOut sameAs: ' Right hand side.' ).	! !!HumCalculatorTests methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 12/5/2013 09:57'!test210templateFill	| template parameters expect result calc|	template := '	  <div id="@id" class="@class">	     @body	  </div>	  '.	parameters := Dictionary new.	parameters 	  at: 'id' put: 'identifier';	  at: 'class' put: 'HighClass';	  at: 'body' put: 'Torso'.	calc := HumCalculator new.	result := calc fillTemplate: template fromDictionary: parameters.	expect := '	  <div id="identifier" class="HighClass">	     Torso	  </div>	  '.	self assert: expect equals: result.	! !!HumCalculatorTests methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 6/13/2014 08:46'!test115substringBefore	"Test helper method that finds a substring between two given substrings."	| stringIn stringOut |	stringIn := 'We are expecting content before this colon: And this is it.'.	stringOut := HumCalculator given: stringIn extractUpto: ':'.	self assert: ( stringOut sameAs: 'We are expecting content before this colon' ). ! !!HumCalculatorTests methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 10/8/2014 09:37'!test305parse	"Test the simple parser."	| string calc tokens n |	string := 'Example: This is a sentence. This is a question?'.	calc := HumCalculator new.	tokens := calc parse: string.	n := tokens size.	self expect: 20 actual: n.	"Parse produces a collection of tuples: { token. type. start. stop. }"	self expect: {'Example'. #word. 1. 7. } actual: (tokens at: 1).	self expect: {':'. #separator. 8. 8. } actual: (tokens at: 2).	self expect: {' '. #whitespace. 9. 9. } actual: ( tokens at: 3).	self expect: 48 actual: (string size).	self expect: {'?'. #separator. 48. 48. } actual: (tokens at: n).	! !!HumCalculatorTests methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 6/13/2014 08:48'!test130substringBetweenBrackets	"Test helper method that finds a substring between a pair of brackets or similar pairs."	| stringIn stringOut |	stringIn := 'We are expecting the stuff between [[ and ]], including the brackets, but nothing else.'.	stringOut := HumCalculator given: stringIn extractIncludingMatching: '[]'.	self assert: ( stringOut sameAs: '[[ and ]]' ).		stringOut := HumCalculator given: 'Sometimes (parends (may be nested)).' extractIncludingMatching: '()'.	self assert: (stringOut = '(parends (may be nested))').			stringOut := HumCalculator given: 'Note (parends (may be (deeply) nested)).' extractIncludingMatching: '()'.	self assert: (stringOut = '(parends (may be (deeply) nested))').! !!HumCalculatorTests methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 10/7/2014 13:27'!test312parse	"Test parse with quote within string."	| string calc tokens quote |	quote := $' asString.	string := 'Parse a "internal quote (',quote,')"'.	calc := HumCalculator new.	tokens := calc parse: string.	self expect: 5 actual: (tokens size).	self expect: { '"internal quote (',quote,')"'. #string. 9. 28.} actual: tokens last.! !!HumCalculatorTests methodsFor: 'string utilities' stamp: 'RichardAlexanderGreen 10/8/2014 09:28'!test313parse	"calc parse: s - recognizes quoted strings as single tokens."	| string calc tokens n quote |	quote := $' asString.	string := 'This is a ',quote,'quoted text',quote,'?'.	calc := HumCalculator new.	tokens := calc parse: string.	n := tokens size.	self expect: 8 actual: n.	self expect: {'This'. #word. 1. 4. } actual: (tokens at: 1).	self expect: {' '. #whitespace. 5. 5. } actual: ( tokens at: 2).	self expect: {'?'. #separator. 24. 24. } actual: (tokens at: n).	self expect: {'''quoted text'''. #string. 11. 23. } actual: (tokens at: (n-1)).	self expect: {' '. #whitespace. 10. 10. } actual: (tokens at: (n-2)).	! !HumTestCase subclass: #GivenWhenThen	instanceVariableNames: 'log givenBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!GivenWhenThen commentStamp: 'RichardAlexanderGreen 2/19/2013 10:53' prior: 0!This is an implementation of Given-When-Then (behavior driven development) style of testing.Note: Methods are duplicated under HumSeasideTests because I did not want to deal with Pharo "traits" and Smalltalk does not support multiple inheritance.!!GivenWhenThen methodsFor: 'self test' stamp: 'RichardAlexanderGreen 2/19/2013 10:58'!test106GivenWhenThenFail	"Test the test utility - In this situation the test assertion is true."	| test x y z |	test := self class basicNew.	"Normally, this test is not needed."	false ifFalse: [^self].	test := self class basicNew.		"A typical test looks like this."		test		given: 'given description' code: [ x:= 'given set'];		when: 'when description'  code: [ y := 'when set'];		"Following should show assertion fails."		then: 'then description' 			code: [ z := 'then set'. 							self assert: (false).							 ].		! !!GivenWhenThen methodsFor: 'self test' stamp: 'RichardAlexanderGreen 2/19/2013 10:59'!test120GivenWhenThenLogging	"Test the testcase`s own log"	| test x y z |	test := self class basicNew.	"A typical test looks like this."		test		given: 'given description' code: [ x:= 'given set'];		when: 'when description'  code: [ y := 'when set'];		then: 'then description' code: [ z := 'then set'. self assert: (true) ].	"The log should contain the descriptions."	self assertString: ( test log at: 1 ) includesSubstring: 'given description'.		self assertString: ( test log at: 2 ) includesSubstring: 'when description'.		self assertString: ( test log at: 3 ) includesSubstring: 'then description'.			! !!GivenWhenThen methodsFor: 'self test' stamp: 'RichardAlexanderGreen 2/19/2013 10:58'!test105GivenWhenThenSuccess	"Test the test utility - In this situation the test assertion is true."	| test x y z |	test := self class basicNew.	"A typical test looks like this."		test		given: 'given description' code: [ x:= 'given set'];		when: 'when description'  code: [ y := 'when set'];		then: 'then description' code: [ z := 'then set'. self assert: (true) ].	"Blocks should have executed."	self assert: ( x sameAs: 'given set' ).	self assert: ( y sameAs: 'when set' ).	self assert: ( z sameAs: 'then set' ).		! !!GivenWhenThen methodsFor: 'self test' stamp: 'RichardAlexanderGreen 2/19/2013 10:48'!test110BasicLog	"Test the testcase`s own log"	| test |	test := HumSeasideTests new.	test log: 'This is only a test'.	self assert: ( (test log at: 1 ) sameAs: 'This is only a test' ).! !!GivenWhenThen methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 11:02'!when: aDescriptionString code: whenBlock	"*When* in a given-when-then triplet 	-- Use to trigger events or add to state.	The code may contain asserts to self-check.	"	"Run the given block to reset to initial state.	This enables a sequence such as: Given, When, Then, When, Then.	It allows the When blocks to create contradicting states.	"	givenBlock value.	"Now run my block"	self log:  ( 'When: ', aDescriptionString, String cr ).	whenBlock value.	^self.	! !!GivenWhenThen methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 11:06'!assertString: stringA includesSubstring: stringB	 " stringB should be a substring in stringA "	| quote x |	quote := $' asString.	x := stringA findString: stringB.	self assert: (x > 0) description: 'Expecting ', quote, stringA, quote, ' contains ', quote, stringB, quote.! !!GivenWhenThen methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 10:48'!then: aDescriptionString code: aBlock	"*Then* in a given-when-then triplet 	-- Use to test post-condition after the given and then have run.	The code may contain asserts to self-check.	"	self log:  ( 'Then: ', aDescriptionString ).	"Run my assertions."	aBlock value.	^self.	! !!GivenWhenThen methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 10:46'!log	^ log ifNil: [ log := OrderedCollection new. ].! !!GivenWhenThen methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 10:46'!givenWhenThenComment	"The #given:code: and #when:code: and #then:code: methods are designed to be cascaded.	Note that #when:code: runs the block provided in the call to #given:code: to set-up initial condition.	That enables multiple *when-then* sequences to run even if they might interfere with each other.	However, you still need to be careful of side-effects.	"	^ 'The #given:code: and #when:code: and #then:code: methods are designed to be cascaded.	Note that #when:code: runs the block provided in the call to #given:code: to set-up initial condition.	That enables multiple *when-then* sequences to run even if they might interfere with each other.	However, you still need to be careful of side-effects.'! !!GivenWhenThen methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 10:47'!log: aString	| entry |	"Prepend a CR to make inspection more readable."	( aString beginsWith: (String cr) )		ifTrue: [ entry := aString ] ifFalse: [ entry := String cr, aString ].	( self log ) add: aString.! !!GivenWhenThen methodsFor: 'API' stamp: 'RichardAlexanderGreen 2/19/2013 10:50'!given: aDescriptionString code: aBlock	"Given in a given-when-then triplet 	-- use to setup test context (initial state).	The code may contain asserts to self-check.	"	self log:  ( String cr, 'Given: ', aDescriptionString ).	"Save the block so that multiple *when* can restore initial state before running."	givenBlock := aBlock.	^self.	! !HumTestCase subclass: #HumBaseTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumBaseTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/10/2015 09:49'!test130putGetEvent	"put get event"	| wb eventID |	wb := HumBase new.	eventID := wb eventWho: 'who' what: 'what' where: 'where' why: 'why not'.	self assert: (eventID isKindOf: LargePositiveInteger ).! !!HumBaseTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/2/2015 11:58'!test120updateGetValue	"Save entity-attribute-value and fetch."	|  id type event value wb n |	n := 9.	wb := HumBase new.	"Set initial value"	( 1 to: n )		do: [ :i |			id := i.			type := #entityType.			event := i * 11.			value := i * 111.			wb entityID: id entityType: type attribute: #attributeType value: value event: event.			].	"Update value"	( 1 to: n )		do: [ :i |			id := i.			type := #entityType.			event := i * 111.			value := i * 1111.			wb entityID: id entityType: type attribute: #attributeType value: value event: event.			].		self expect: n actual: (wb entitiesOfType at: type) size.	self expect: 0 actual: (wb entitiesOfType at: #noneSuch ifAbsent: [Set new]) size.	self expect: n actual: ( wb findEntitiesOfType: type ) size.	self expect: 0 actual: ( wb findEntitiesOfType: #noneSuch ) size.		( 1 to: n )		do: [ :j |			self expect: 0 actual: ( wb entitiesWithValue at: { #attributeType. j*111. } ) size.			self expect: { j*1111. j*111. } actual: ( wb entityAttributeValue at: { j. #attributeType. } ) top.			].		( 1 to: n )		do: [ :k |			self expect: k*1111 actual: ( wb getEntityID: k attribute: #attributeType ).			self expect: { k. } 			     actual: ( wb findEntitiesWhereAttribute: #attributeType satisfies: [:x | x = ( k * 1111)] ) asArray.			].	! !!HumBaseTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/10/2015 10:58'!test110putGetValue	"Save entity-attribute-value and fetch."	|  id type event value wb n |	n := 9.	wb := HumBase new.	( 1 to: n )		do: [ :i |			id := i.			type := #entityType.			event := i * 11.			value := i * 111.			wb entityID: id entityType: type attribute: #attributeType value: value event: event.			].		self expect: n actual: (wb entitiesOfType at: type) size.	self expect: 0 actual: (wb entitiesOfType at: #noneSuch ifAbsent: [Set new]) size.		( 1 to: n )		do: [ :j |			self expect: 1 actual: ( wb entitiesWithValue at: { #attributeType. j*111. } ) size.			self expect: {{ j*111. j*11. } } actual: ( wb entityAttributeValue at: { j. #attributeType. } ) asArray.			].		( 1 to: n )		do: [ :k |			self expect: k*111 actual: ( wb getEntityID: k attribute: #attributeType ).			self expect: { k. } actual: ( wb findEntitiesWhereAttribute: #attributeType satisfies: [:x | x = (k * 111)]) asArray.			].	! !HumTestCase subclass: #HumOntologyTests	instanceVariableNames: ''	classVariableNames: 'Argument'	poolDictionaries: ''	category: 'Hum-Tests'!!HumOntologyTests commentStamp: 'RichardAlexanderGreen 1/30/2014 13:59' prior: 0!The ontology tests are mainly concerned with manipulating the ontology`s data structures.The method categories indicate the different kinds off data that are handled.!!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/26/2015 08:22'!test100nounTypes	"An entity noun will have attributes."	"A category noun will have categories."	"An entity noun may have supertypes and/or subtypes."	"A plural noun indicates a list or set or bag collection. By default, it indicates a set."	"A noun may have a synonym. "! !!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/9/2012 14:49'!test102addOneNoun	"Add one noun to current set."	| ontology |	ontology := HumOntology new.	ontology addNoun: 'location'.	self assert: ( (ontology nouns) includes: 'location' ).! !!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 2/12/2014 11:20'!test124getAllSupertypesOfNoun	"Get immediate super types of a noun -- Use when translating to another language ."	| ontology immediateSupertypes allSupertypes |	ontology := HumOntology new.	"Add a few subtype-supertype relations."	ontology addNoun: 'person' isA: 'party'.	ontology addNoun: 'organization' isA: 'party'.	ontology addNoun: 'worker' isA: 'person'.		ontology addNoun: 'employee' isA: 'worker'.	ontology addNoun: 'contractor' isA: 'worker'.		ontology addNoun: 'self-employed-consultant' isA: 'worker'.	ontology addNoun: 'self-employed-consultant' isA: 'vendor'.  "Test multiple inheritance case."		ontology addNoun: 'vendor' isA: 'organization'.	ontology addNoun: 'supplier' isA: 'vendor'.		immediateSupertypes := ontology immediateSupertypesOf:  'vendor'.	"Vendor has one immediate supertype: Vendor is an organization."	self assert: ( immediateSupertypes size ) = 1.		immediateSupertypes := ontology immediateSupertypesOf:  'supplier'.	"Supplier has one immediate supertype: Supplier is a vendor."	self assert: ( immediateSupertypes size ) = 1.		immediateSupertypes := ontology immediateSupertypesOf:  'employee'.	"Employee has one immediate supertype: Employee is a worker.."	self assert: ( immediateSupertypes size ) = 1.		immediateSupertypes := ontology immediateSupertypesOf:  'worker'.	"Worker has one immediate supertype: Worker is a party."	self assert: ( immediateSupertypes size ) = 1.		immediateSupertypes := ontology immediateSupertypesOf:  'person'.	"Party has two subtypes (person, organization)."	self assert: ( immediateSupertypes size ) = 1.		immediateSupertypes := ontology immediateSupertypesOf:  'party'.	"Party has no supertypes in this ontology."	self assert: ( immediateSupertypes size ) = 0.		immediateSupertypes := ontology immediateSupertypesOf:  'self-employed-consultant'.	"Self-employed-constulant has two immediate supertypes: 	Self-employed-consultant is a worker, and also a vendor."	self assert: ( immediateSupertypes size ) = 2.		allSupertypes := ontology allSupertypesOf: 'self-employed-consultant'.	"consultant > worker > person > party; also: consultant > vendor > organization > party"	self assert: ( allSupertypes size ) equals: 5.						! !!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/21/2015 09:32'!test121automaticSubtype	"Add an is-A relation."	| ontology |	ontology := HumOntology new.	"Add noun."	ontology addEntity: 'location' attributes: #('latitude' 'longitude').	self assert: ( (ontology nouns) includes: 'location' ).	"Add an automatic subtype."	ontology addNoun: 'store-location'.	"Test isKindOf"	self assert: ( ontology yesNoun: 'store-location' isAKindOf: 'location').	"Test subtypes"	self assert: ( ( ontology immediateSubtypesOf: 'location') includes: 'store-location').! !!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/9/2012 14:49'!test104addArrayOfNouns	"Add array of nouns to current set."	| ontology nounSet |	ontology := HumOntology new.	"Add one noun."	ontology addNoun: 'location'.	self assert: ( (ontology nouns) includes: 'location' ).		"Add from array."	ontology addNouns: #( 'place-1' 'place-2' 'place-3' ).	self assert: ( (ontology nouns) includes: 'place-3').	self assert: ( (ontology nouns) includes: 'location'). "Make sure we did not overlay original"	"Add from set."	nounSet := Set new.	nounSet add: 'first-location'.	nounSet add: 'second-location'.	nounSet add: 'third-location'.	ontology addNouns: nounSet.	self assert: ( (ontology nouns) includes: 'third-location').	self assert: ( (ontology nouns) includes: 'location').   "Make sure we did not overlay original"	! !!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 4/9/2012 11:14'!test122getAllSubtypesOfNoun	"Get all subtypes of a noun -- Use at run-time for polymorphism."	| ontology immediateSubtypes allSubtypes |	ontology := HumOntology new.	"Add a few subtype-supertype relations."	ontology addNoun: 'person' isA: 'party'.	ontology addNoun: 'organization' isA: 'party'.	ontology addNoun: 'worker' isA: 'person'.		ontology addNoun: 'employee' isA: 'worker'.	ontology addNoun: 'contractor' isA: 'worker'.	ontology addNoun: 'consultant' isA: 'worker'.		ontology addNoun: 'vendor' isA: 'organization'.	ontology addNoun: 'supplier' isA: 'vendor'.		immediateSubtypes := ontology immediateSubtypesOf: 'party'.	"Party has two subtypes (person, organization)."	self assert: ( immediateSubtypes size ) = 2.		"Party has 8 subtypes in the whole subtype tree. "	allSubtypes := ontology allSubtypesOf: 'party'.	self assert: ( allSubtypes size ) = 8.	"Transcript show: allSubtypes asSortedCollection; cr."					! !!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 3/22/2012 13:42'!test120addSubtype	"Add an is-A relation."	| ontology subtypes |	ontology := HumOntology new.	"Add noun."	ontology addNoun: 'location'.	self assert: ( (ontology nouns) includes: 'location' ).	"Add is-A relation."	ontology addNoun: 'residence' isA: 'location'.	"Test isKindOf"	self assert: ( ontology yesNoun: 'residence' isAKindOf: 'location').	"Test subtypes"	subtypes := ontology immediateSubtypesOf: 'location'.	self assert: ( subtypes isKindOf: Set).	self assert: ( ( ontology immediateSubtypesOf: 'location') includes: 'residence').! !!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 4/10/2012 09:32'!test111getAllAttributesOfNoun	"Add an is-A relation."	| ontology allAttributes |	ontology := HumOntology new.	"Define a few relations."	ontology addEntity: 'party' attributes: #(  'name' 'alphabetized-name' 'address'  ).	ontology addEntity: 'address' attributes: #( 'street-direction' 'street-number' 'street-name' 'postal-code' ).	ontology addEntity: 'postal-code' attributes: #( 'city' 'state-province' 'nation' ).	ontology addNoun: 'person' isA: 'party'.	ontology addEntity: 'person' attributes: #( 'primary-phone-number'   ).	ontology addNoun: 'contact' isA: 'person'.	ontology addNoun: 'organization' isA: 'party'.		"The attrbutes include both the supertypes and the attributes of the supertypes."	"THINK -- Is this what we want?  What will we do with the supertypes?"	allAttributes := ontology allAttributesOfEntity: 'contact'.	self assert: ( allAttributes size ) = 11.	"	Transcript cr; show: 'test111getAllAttributesOfNoun -- Attributes of contact:'; cr; show: allAttributes; cr.	"					! !!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 7/26/2013 09:10'!test110addEntityAttribute	"Add an entity-attribute relation."	| ontology  attributes |	ontology := HumOntology new.	"Add noun."	ontology addNoun: 'location'.	self assert: ( (ontology nouns) includes: 'location' ).	"Add entity-attribute relation."	ontology addEntity: 'location' attribute: 'GPS'.	"Test"	attributes := ontology immediateAttributesOfEntity: 'location'.	self assert: ( attributes include: 'GPS' asLowercase ).			"Add a second entity-attribute relation."	ontology addEntity: 'location' attribute: 'location-name'.	"Test"	attributes := ontology immediateAttributesOfEntity: 'location'.	self assert: ( attributes include: 'location-name' ).	self assert: ( attributes include: 'GPS' asLowercase ).		! !!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 1/9/2012 14:49'!test103addTwoNouns	"Add two nouns to current set."	| ontology |	ontology := HumOntology new.	"Add first noun."	ontology addNoun: 'location'.	self assert: ( (ontology nouns) includes: 'location' ).	"Add second noun."	ontology addNoun: 'place'.	self assert: ( (ontology nouns) includes: 'place' ).	"Make sure we did not overlay original"	self assert: ( (ontology nouns) includes: 'location' ).  ! !!HumOntologyTests methodsFor: 'about Nouns' stamp: 'RichardAlexanderGreen 5/29/2012 09:22'!test123getImmediateSupertypesOfNoun	"Get immediate super types of a noun -- Use when translating to another language ."	| ontology immediateSupertypes |	ontology := HumOntology new.	"Add a few subtype-supertype relations."	ontology addNoun: 'person' isA: 'party'.	ontology addNoun: 'organization' isA: 'party'.	ontology addNoun: 'worker' isA: 'person'.		ontology addNoun: 'employee' isA: 'worker'.	ontology addNoun: 'contractor' isA: 'worker'.		ontology addNoun: 'self-employed-consultant' isA: 'worker'.	ontology addNoun: 'self-employed-consultant' isA: 'vendor'.  "Test multiple inheritance case."		ontology addNoun: 'vendor' isA: 'organization'.	ontology addNoun: 'supplier' isA: 'vendor'.		immediateSupertypes := ontology immediateSupertypesOf:  'vendor'.	"Vendor has one immediate supertype: Vendor is an organization."	self assert: ( immediateSupertypes size ) = 1.		immediateSupertypes := ontology immediateSupertypesOf:  'supplier'.	"Supplier has one immediate supertype: Supplier is a vendor."	self assert: ( immediateSupertypes size ) = 1.		immediateSupertypes := ontology immediateSupertypesOf:  'employee'.	"Employee has one immediate supertype: Employee is a worker.."	self assert: ( immediateSupertypes size ) = 1.		immediateSupertypes := ontology immediateSupertypesOf:  'worker'.	"Worker has one immediate supertype: Worker is a party."	self assert: ( immediateSupertypes size ) = 1.		immediateSupertypes := ontology immediateSupertypesOf:  'person'.	"Party has two subtypes (person, organization)."	self assert: ( immediateSupertypes size ) = 1.		immediateSupertypes := ontology immediateSupertypesOf:  'party'.	"Party has no supertypes in this ontology."	self assert: ( immediateSupertypes size ) = 0.		immediateSupertypes := ontology immediateSupertypesOf:  'self-employed-consultant'.	"Self-employed-constulant has two immediate supertypes: 	Self-employed-consultant is a worker, and also a vendor."	self assert: ( immediateSupertypes size ) = 2.						! !!HumOntologyTests methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!test520CheckPlanFrame	"A plan frame SHOULD have a goal and at least two preconditions.	 -- Perhaps this rule is a 'should' rather than a 'must'.	-- The plan would still work,	     but a plan with a large number of frames with just one precondition	     seems a bit odd.	-- A better check would detect a string of such plan frames. 	" 	| planFrame problems  ontology |		ontology := HumOntology new.			planFrame := HumFrame4Plan new.	problems := planFrame check.	self assert: ( problems include: 'A plan frame must have a goal.' ).		"Fix that problem."	planFrame ontology: ontology; goal: 'Bake a cake per recipe'.		"A plan frame SHOULD have at least two preconditions."	"If there is only one, the business process should be stated as a procedure."	self assert: ( ( planFrame check) include:  'A plan frame should have at least two preconditions.' ).		"Half fix that problem."	planFrame appendPrecondition: 'Oven is preheated per recipe.'.			self assert: (  ( planFrame check)  include:  'A plan frame should have at least two preconditions.' ).		"Fully fix that problem."	planFrame appendPrecondition: 'Batter is in bake-pan per recipe.'.		self assert: (  ( planFrame check)  isEmpty ).				! !!HumOntologyTests methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!test545DrawPlanTree	"Make several plan frames. Get the resulting plan tree."	| planFrame1 planFrame2 planFrame3 ontology planTreeView |		ontology := HumOntology new.	"A plan frame must have a goal and at should have at least two preconditions."		planFrame1 := HumFrame4Plan ontology: ontology goal: 'Bake a cake per recipe.'.	planFrame1 appendPrecondition: 'Oven is preheated per recipe.'.		planFrame1 appendPrecondition: 'Batter is in bake-pan per recipe.'.	planFrame1 appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.	ontology storeFrame: planFrame1.			planFrame2 := HumFrame4Plan ontology: ontology goal: 'Oven is preheated per recipe.'.	planFrame2 appendPrecondition: 'Oven is cleared out.'.	planFrame2 appendPrecondition: 'Oven is on.'.	planFrame2 appendPrecondition: 'Oven temperature is set per recipe.'.	planFrame2 appendRole: 'Timer' action: 'Wait 5 minutes.'.	ontology storeFrame: planFrame2.		planFrame3 := HumFrame4Plan ontology: ontology goal: 'Batter is in bake-pan per recipe.'.	planFrame3 appendPrecondition: 'Batter fully mixed per recipe.'.	planFrame3 appendPrecondition: 'Bake-pan is greased per recipe.'.	planFrame3 appendRole: 'Baker' action: 'Pour batter into bake-pan per recipe.'.	ontology storeFrame: planFrame3.		"TODO: The plan tree is incomplete at this point 	       and the following call to {buildPlanTreeForGoal:} should fail."	planTreeView := ontology view showPlanTreeForGoal: 'Bake a cake per recipe.'.		"Transcript cr; show: 'test545DrawPlanTree'; show: planTreeView; cr."
 	! !!HumOntologyTests methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!test540GetPlanTree	"Make several plan frames. Get the resulting plan tree."	| planFrame1 planFrame2 planFrame3 ontology planTree |		ontology := HumOntology new.	"A plan frame must have a goal and at should have at least two preconditions."		planFrame1 := HumFrame4Plan ontology: ontology goal: 'Bake a cake per recipe.'.	planFrame1 appendPrecondition: 'Oven is preheated per recipe.'.		planFrame1 appendPrecondition: 'Batter is in bake-pan per recipe.'.	planFrame1 appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.	ontology storeFrame: planFrame1.			planFrame2 := HumFrame4Plan ontology: ontology goal: 'Oven is preheated per recipe.'.	planFrame2 appendPrecondition: 'Oven is cleared out.'.	planFrame2 appendPrecondition: 'Oven is on.'.	planFrame2 appendPrecondition: 'Oven temperature is set per recipe.'.	planFrame2 appendRole: 'Timer' action: 'Wait 5 minutes.'.	ontology storeFrame: planFrame2.		planFrame3 := HumFrame4Plan ontology: ontology goal: 'Batter is in bake-pan per recipe.'.	planFrame3 appendPrecondition: 'Batter fully mixed per recipe.'.	planFrame3 appendPrecondition: 'Bake-pan is greased per recipe.'.	planFrame3 appendRole: 'Baker' action: 'Pour batter into bake-pan per recipe.'.	ontology storeFrame: planFrame3.		"TODO: The plan tree is incomplete at this point 	       and the following call to {buildPlanTreeForGoal:} should fail."	planTree := ontology buildPlanTreeForGoal:  'Bake a cake per recipe.' indent: 0.	self assert: ( planTree size ) = 7.		"ontology showPlanTree: planTree."		"TODO: IS THIS CORRECT? THIS TEST DOES NOT COUNT THE GOAL AT THE ROOT AS PART OF THE PLAN TREE."	self assert: ( planTree anySatisfy: [:assoc |		 ((assoc value) at: 2) = (HumStatement source: 'Batter is in bake-pan per recipe.')		 ]).	 
 	! !!HumOntologyTests methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!test510CreatePlanFrame	"Make one plan frame. (TDD to drive basic parts)"	| planFrame preconditions actionSet ontology |		ontology := HumOntology new.	"A plan frame has a goal. (post condition)"	planFrame := HumFrame4Plan ontology: ontology goal: 'Bake a cake per recipe.'.	self assert: (( planFrame goal ) matchesCandidateStatement: 'Bake a cake per recipe.' inOntology: ontology).		"A plan frame has a collection of preconditions."	preconditions := planFrame preconditions.	self assert: ( preconditions isKindOf: Collection ).		planFrame appendPrecondition: 'Oven is preheated per recipe.'.	self assert: ( preconditions size ) = 1.		planFrame appendPrecondition: 'Batter is mixed per recipe ingredients.'.	self assert: ( preconditions size ) = 2.	planFrame appendPrecondition: 'Batter is in cake-pan per recipe pan-size.'.	self assert: ( preconditions size ) = 3.	"A plan frame has a set of zero or more actions	 that move the state	 from the preconditions 	to the post condition (goal)."	actionSet := planFrame planActions.	self assert: ( actionSet isKindOf: Collection ).		planFrame appendRole: 'Baker' action: 'Bake the cake-pan per recipe baking-time.' comment: ''.	self assert: ( actionSet size ) = 1.			! !!HumOntologyTests methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!test550CheckPlanTree	"Check for an incomplete plan."	| planFrame1 planFrame2 planFrame3 ontology planTreeProblems |		ontology := HumOntology new.	"A plan frame must have a goal and should have at least two preconditions."		planFrame1 := HumFrame4Plan ontology: ontology goal: 'Bake a cake per recipe.'.	planFrame1 appendPrecondition: 'Oven is preheated per recipe.'.		planFrame1 appendPrecondition: 'Batter is in bake-pan per recipe.'.	planFrame1 appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.	ontology storeFrame: planFrame1.			planFrame2 := HumFrame4Plan ontology: ontology goal: 'Oven is preheated per recipe.'.	planFrame2 appendPrecondition: 'Oven is cleared out.'.	planFrame2 appendPrecondition: 'Oven is on.'.	planFrame2 appendPrecondition: 'Oven temperature is set per recipe.'.	planFrame2 appendRole: 'Timer' action: 'Wait 5 minutes.'.	ontology storeFrame: planFrame2.		planFrame3 := HumFrame4Plan ontology: ontology goal: 'Batter is in bake-pan per recipe.'.	planFrame3 appendPrecondition: 'Batter fully mixed per recipe.'.	planFrame3 appendPrecondition: 'Bake-pan is greased per recipe.'.	planFrame3 appendRole: 'Baker' action: 'Pour batter into bake-pan per recipe.'.	ontology storeFrame: planFrame3.		planTreeProblems := ontology checkPlanTreeForGoal:  'Bake a cake per recipe.'.	self assert: ( planTreeProblems size ) = 5.	"	Transcript cr; show: 'Plan Tree Problems:'.	planTreeProblems do: [ :problem | Transcript cr; show: problem. ].	"	! !!HumOntologyTests methodsFor: 'about Plans and Conditions' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!test530AddPlanFrame	"Make one plan frame. (TDD to drive basic parts)"	| planFrame ontology |		ontology := HumOntology new.	"A plan frame should have a goal and at least two preconditions."		planFrame := HumFrame4Plan  ontology: ontology goal: 'Bake a cake per recipe'.	planFrame appendPrecondition: 'Oven is preheated per recipe.'.		planFrame appendPrecondition: 'Batter is in bake-pan per recipe.'.	planFrame appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.		ontology storeFrame: planFrame.		"===	Goal: Bake a cake per recipe.	Preconditions:	. Oven is preheated per recipe.	. Batter is in bake-pan per recipe.	Action:	. Baker: Bake bake-pan in the oven per recipe.	===	"		! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 3/23/2012 14:19'!test360statementMatchesPatternForEach	"Test HumStatement>>onMatch: aPattern do: aBlock "	| statement pattern result |	true ifFalse: [ Transcript cr; show: 'test360statementMatchesPattern skipped'; cr.  ^self ].	"Match for each"	pattern := 'For each 1 in 2:'.	statement := HumStatement from: 'For each item in order:'.	result := 'No match'.	statement onMatch: pattern do: [ :item :order | result := 'Item=',item,' and ','order=',order ].	self assert: ( result sameAs: 'No match' ) not.	self assert: ( result sameAs: 'item=item and order=order' ).		! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 5/29/2012 10:05'!test362statementMatchesPatternIsA	"Test HumStatement>>onMatch: aPattern do: aBlock "	| statement pattern result |	true ifFalse: [ Transcript cr; show: 'test362statementMatchesPatternIsA skipped'; cr.  ^self ].	"Match ___  is a ___"	pattern := 'A 1 is a 2 .' .	statement := HumStatement from: 'A menu is a bill-of-material.'.		"Preset 'No match' -- to fail fast if the pattern match does not work as expected.'"	result := 'No match'.	statement onMatch: pattern do: [ :menu :billOfMaterial | result := 'menu=',menu, ' and ', 'bill-of-material=',billOfMaterial ].	"Fail fast if the result was not reset."	self assert: ( result sameAs: 'No match' ) not.	"This is the result we are expecting."	self assert: ( result sameAs: 'menu=menu and bill-of-material=bill-of-material' ).		! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 5/29/2012 15:41'!test363statementMatchesElse	"Test HumStatement>>onMatch: aPattern do: aBlock "	| statement pattern result |	true ifFalse: [ Transcript cr; show: 'test363statementMatchesElse skipped'; cr.  ^self ].	"Match 'Else:'"	pattern := 'Else:' .	statement := HumStatement from: 'Else:'.	"Fail fast if there is no match."	result := 'No match'.	"The following will fail if the parser thinks there are nouns."	statement onMatch: pattern do: [ result := 'Else has no arguments.' ].	"Test for no match."	self assert: ( result sameAs: 'No match' ) not.	"This is the result we are expecting."	self assert: ( result sameAs: 'Else has no arguments.' ).		! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 9/28/2014 11:11'!test342statementParsingConsolidatesStrings	"A string is delimited by double quotes."	|   | 	Transcript show: 'TODO: test342statementParsingConsolidatesStrings has not been implemented yet.'; cr.! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 3/17/2015 12:12'!test340statementParsing	"The parser recognizes that tokens are nouns, punctuation, keywords, or just words."	| statement role ontology statementNouns tokenTypes |	ontology := HumOntology new.	statement := HumStatement from: 'Add incoming-count to stock-count, giving updated-stock-count.'.	role := 'Calc'.	ontology indexRole: role action: statement.		"The nouns might be defined after the statement is defined. "	ontology addNouns: #( 'count' 'incoming-count' 'stock-count' 'updated-stock-count' ).		"(Nouns are not completely bound until compile time.)"	statementNouns := ontology nounsInStatement: statement.	self assert: (statementNouns include: 'incoming-count').	self assert: (statementNouns include: 'stock-count').	self assert: (statementNouns include: 'updated-stock-count').		"Get tokenTypes."	tokenTypes := ontology parseStatement: statement triggerWords: #( 'if' 'else' 'giving' 'for-each' ) keywords: #( 'each' 'giving' ).	"Check nouns."	self assert: ( tokenTypes include: ( 'incoming-count' -> #noun ) ).	self assert: ( tokenTypes include: ( 'stock-count' -> #noun ) ).	self assert: ( tokenTypes include: ( 'updated-stock-count' -> #noun ) ).	"Check keywords."	self assert: ( tokenTypes include: ( 'giving' -> #keyword ) ).	"Check punctuation."	self assert: ( tokenTypes include: ( ',' -> #punctuation ) ).	"Add is only another word.  -- Verbs are not special."	self assert: ( tokenTypes include: ( 'Add' -> #word ) ).	"The word 'to' is only another word. -- Prepositions are not special."	self assert: ( tokenTypes include: ( 'to' -> #word ) ).			! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 5/29/2012 10:03'!test361statementMatchesPatternForEachInThe	"Test HumStatement>>onMatch: aPattern do: aBlock "	| statement pattern result |	true ifFalse: [ Transcript cr; show: 'test361statementMatchesPatternForEachInThe skipped'; cr.  ^self ].	"Match for each"	pattern := 'For each 1 in the 2:'.	statement := HumStatement from: 'For each item in order:'.	"Preset 'No match' -- to fail fast if the pattern match does not work as expected.'"	result := 'No match'.	statement onMatch: pattern do: [ :item :order | result := 'Item=',item,' and ','order=',order ].	"Fail fast if the result was not reset."	self assert: ( result sameAs: 'No match' ) not.	"This is the result we are expecting."	self assert: ( result sameAs: 'item=item and order=order' ).		! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 5/29/2012 15:49'!test365statementMatchesCategoriesAnd	"Test HumStatement>>onMatch: aPattern do: aBlock "	| statement pattern result |	true ifFalse: [ Transcript cr; show: 'test365statementMatchesCategoriesAnd skipped'; cr.  ^self ].	". . . categories include blah, blah, AND blah.'"	pattern := '1 categories include * . ' .	"The word 'and' should be allowed in a list without confusion."	statement := HumStatement from: 'Color categories include red, green, and blue. '.	result := 'No match'.	statement onMatch: pattern do: [:color :list | result := 'color=', color, ' and ', 'list=', list asString. ].	self assert: ( result sameAs: 'No match' ) not.	self assert: ( result sameAs: 'color=color and list=an OrderedCollection(''red'' ''green'' ''blue'')' ).		! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 5/29/2012 15:48'!test366statementMatchesAttributes	"Test HumStatement>>onMatch: aPattern do: aBlock "	| statement pattern result |	true ifFalse: [ Transcript cr; show: 'test366statementMatchesAttributes skipped'; cr.  ^self ].	". . .  attributes include blah, blah, blah."	pattern := '1 attributes include * . ' .	statement := HumStatement from: 'Party attributes include name, address, phone-number. '.	result := 'No match'.	statement onMatch: pattern do: [:party :list | result := 'party=', party, ' and ', 'list=', list asString. ].	self assert: ( result sameAs: 'No match' ) not.	self assert: ( result sameAs: 'party=party and list=an OrderedCollection(''name'' ''address'' ''phone-number'')' ).		! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 5/29/2012 15:47'!test367statementMatchesAttributesAnd	"Test HumStatement>>onMatch: aPattern do: aBlock "	| statement pattern result |	true ifFalse: [ Transcript cr; show: 'test367statementMatchesAttributesAnd skipped'; cr.  ^self ].	". . . attributes include . . . blah, blah, AND blah "	pattern := '1 attributes include * . ' .	statement := HumStatement from: 'Party attributes include name, address, and phone-number. '.	result := 'No match'.	statement onMatch: pattern do: [:party :list | result := 'party=', party, ' and ', 'list=', list asString. ].	self assert: ( result sameAs: 'No match' ) not.	self assert: ( result sameAs: 'party=party and list=an OrderedCollection(''name'' ''address'' ''phone-number'')' ).		! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 5/29/2012 09:55'!test320statementEndsWithPeriodOrColon	"A statement must end with a period or a colon."	| statement |	statement := HumStatement new.		"A statement ending in a period should not raise an error."	statement source: 'This ends with a period.'.	self assert: ( statement errors ) isEmpty. 		"A statement ending in a colon should not raise an error."	statement source: 'For each token in statement tokens:'.
	self assert: ( statement errors ) isEmpty. 		"A statement not ending in a colon or period should raise an error."	statement source: 'This source statement is missing an ending period'.	self assert: ( statement errors ) isEmpty not.	"Transcript show: statement errors; cr."	! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 1/9/2012 14:53'!test310statementTokens	"A statement is made up of tokens."	| tokens statement |	"Make a statement and get its tokens."	statement := HumStatement from: 'Now, this is the time for all good men to come to the aid of their country.'.	tokens := statement tokens.	"Tokens are in an ordered collection (array-like)."	self assert: ( tokens at: 6 ) = 'time'.	 "Tokens are converted to lower case."	self assert: ( tokens includes: 'now' ). 	"Tokens include punctuation."	self assert: ( tokens includes: ',' ).	self assert: ( tokens includes: '.' ).		! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 3/17/2015 12:12'!test330statementHasNouns	"A statement has nouns."	| statement role ontology statementNouns |	ontology := HumOntology new.	statement := HumStatement from: 'Move thing from current-location to new-location.'.	role := 'Mover'.	ontology indexRole: role action: statement.		"The nouns might be defined after the statement is defined. "	ontology addNouns: #( 'thing' 'location' 'current-location' 'new-location' ).		"(Nouns are not completely bound until compile time.)"	statementNouns := ontology nounsInStatement: statement.	self assert: (statementNouns include: 'thing').	self assert: (statementNouns include: 'current-location').	self assert: (statementNouns include: 'new-location').	self expect: 3 actual: (statementNouns size).			! !!HumOntologyTests methodsFor: 'about Statements' stamp: 'RichardAlexanderGreen 5/29/2012 15:48'!test364statementMatchesCategories	"Test HumStatement>>onMatch: aPattern do: aBlock "	| statement pattern result |	true ifFalse: [ Transcript cr; show: 'test364statementMatchesCategories skipped'; cr.  ^self ].	". . . categories include blah, blah, blah."	pattern := '1 categories include * . ' .	statement := HumStatement from: 'Color categories include red, green, blue. '.	result := 'No match'.	statement onMatch: pattern do: [:color :list | result := 'color=', color, ' and ', 'list=', list asString. ].	self assert: ( result sameAs: 'No match' ) not.	self assert: ( result sameAs: 'color=color and list=an OrderedCollection(''red'' ''green'' ''blue'')' ).		! !!HumOntologyTests methodsFor: 'about FrameLines' stamp: 'RichardAlexanderGreen 10/29/2013 07:38'!test351frameLineParsingRemovesComments	"The parser recognizes that tokens are nouns, punctuation, keywords, or just words."	|   |	Transcript show: 'TODO: test351frameLineParsingRemovesComments has not been implemented yet.'; cr.	 	! !!HumOntologyTests methodsFor: 'about FrameLines' stamp: 'RichardAlexanderGreen 10/29/2013 07:38'!test353frameLineParsingSeparatesAnnotation	"The parser recognizes that tokens are nouns, punctuation, keywords, or just words."	|  |	Transcript show: 'TODO: test353frameLineParsingSeparatesAnnotation has not been implemented yet.'; cr.! !!HumOntologyTests methodsFor: 'about FrameLines' stamp: 'RichardAlexanderGreen 1/23/2014 15:25'!test350frameLineSeparateLabelStatementCommentAnnotation	"Generic frameline = ( indent ) ( label : ) ( statement '.' ) ( '(' comment ')' ) ( '[' annotation ']' )	where label = word ':'	"! !!HumOntologyTests methodsFor: 'about Ontology' stamp: 'RichardAlexanderGreen 12/30/2011 13:13'!test001newOntology	"create a new Ontology"	| ontology |	ontology := HumOntology new.	self assert: ( ontology nouns) isEmpty.	self assert: ( ontology roles) isEmpty.		! !!HumOntologyTests methodsFor: 'render as HTML' stamp: 'RichardAlexanderGreen 1/21/2015 09:46'!test626renderNounTreeAsHTML	"Define a dictionary with more than one level. Render as a noun tree."	| ontology nounTreeView frameEditor |		ontology := HumOntology new.		"Create a Dictionary Frame."	frameEditor := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	frameEditor addDictionaryLine: 'Recipe attributes include recipe-name, description, ingredients, steps.'.	frameEditor addDictionaryLine: 'Recipe includes a list of ingredients.'.	frameEditor addDictionaryLine: 'Recipe includes a list of steps.'.	frameEditor addDictionaryLine: 'Measure attributes include quantity, units.'.	frameEditor addDictionaryLine: 'Ingredient attributes include ingredient-name, ingredient-measure, substitute.'.	frameEditor addDictionaryLine: 'Step attributes include step-number, step-description'.	frameEditor addDictionaryLine: 'Bakery attributes include oven, mixer, counter.'.	frameEditor addDictionaryLine: 'Recipe attributes include bake-time, bake-temperature.'.	ontology storeFrame: ( frameEditor frame ).	ontology compileAllFrames.		nounTreeView := ontology view renderNounTreeForNoun: 'recipe'.		self expect: 'Noun Tree:   recipe    |-> bake-temperature    |-> bake-time    |-> description    |-> ingredients         |-> ingredient-measure              |=> measure                   |-> quantity                   |-> units         |-> ingredient-name         |-> substitute    |-> recipe-name    |-> steps         |-> step-description         |-> step-number'		actual: nounTreeView.
 	! !!HumOntologyTests methodsFor: 'render as HTML' stamp: 'RichardAlexanderGreen 4/18/2015 09:46'!test611renderInstructionLines	"Create instructions in-line using Class methods"	| ontology role action preheatInstruction mixInstruction frameEditor html |		"Set up"	ontology := HumOntology new.		"Add action to the role's set of actions."	role := 'Cook'.	action := 'Bake a cake per recipe.'.	ontology indexRole: role action: (HumStatement from: action).		"Append first instruction to sequence of instructions."	preheatInstruction := HumInstructionLine  statement: 'Preheat oven to recipe`s oven-temperature.'.	ontology appendInstruction: preheatInstruction toRole: role action: action.		"Append second instruction."	mixInstruction := HumInstructionLine  statement: 'Mix batter per recipe.'.	ontology appendInstruction: mixInstruction toRole: role action: action.		"Initialize for a Dictionary Frame."	frameEditor := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	frameEditor addDictionaryLine: 'Recipe attributes include product-name, oven-temperature.'.  ontology storeFrame: ( frameEditor frame ).	"Frames must be compiled before rendering if nouns are to be flagged."	ontology compileAllFrames.	html := ontology view renderStatement: preheatInstruction.	self assert: ( '*Preheat oven*' match: html ).	self assert: ( '*oven-temperature*' match: html ).	self assert: ( '*<n>*</n>*' match: html ).	self assert: ( '*<n>oven-temperature</n>*' match: html ).	! !!HumOntologyTests methodsFor: 'render as HTML' stamp: 'RichardAlexanderGreen 4/18/2015 20:55'!test620renderFrame4PlanAsHTML	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology html thisFrame |	ontology := HumOntology new.		"Initialize for a Plan Frame."	frameEditor := HumFrameUpdater ontology: ontology goal: 'Cake is baked according to recipe..'.	frameEditor appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameEditor appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.	frameEditor appendRole: 'Timer' action: 'Bake the pan in the oven for the time given in the recipe.' .		thisFrame :=  ( frameEditor frame ).	ontology storeFrame: thisFrame.		"Frames must be compiled before rendering if nouns are to be flagged."	ontology addNouns: #( 'recipe' ).	ontology compileAllFrames.	html := ontology view asHTML5 .	"Test:  Is the goal-statement included in the HTML ?"	self pattern:  '*according to *' matches: html.		"Test: Are each of the preconditions included ?"		self pattern:  '*preheated*' matches: html .	self pattern:  '*batter*'  matches: html .	"Test: Is the action instruction role and statment included ?"	self pattern:  '*Timer*'  matches: html.	self pattern:  '*time given*'  matches: html.		"HTML should include a 'Preconditions' subheading."	self pattern:  '*Preconditions*' matches: html.		"HTML should include a 'Actions' subheading."	self pattern: '*Actions*' matches: html.		"HTML should include nouns flags"	self pattern: '*<n>*</n>*' matches: html.	self pattern:  '*<n>recipe</n>*' matches: html.	"Preconditions should have nouns marked"	self pattern:  '*temperature given in the <n>recipe</n>*' matches: html.	"Actions should have nouns marked."	self pattern:  '*time given in the <n>recipe</n>*' matches: html.	"Goal should have nouns marked."	self pattern:  '*according to <n>recipe</n>*' matches: html.! !!HumOntologyTests methodsFor: 'render as HTML' stamp: 'RichardAlexanderGreen 4/18/2015 20:58'!test630renderFrame4ActionAsHTML	"Given: The frame editor contains a role-action frame.	 When: Rendering a role-action frame as HTML.	 Then: The HTML identifies the nouns. (see test610renderStatementAsHTML)	 Then: The HTML indents instructions.	 Then: The HTML includes the heading.	 Then: The HTML includes each comment.	 Note: CSS boiler-plate (generated elsewhere) will handle the color-coding.	"	| frameEditor ontology html |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameEditor := HumFrameUpdater ontology: ontology  	                                   role: 'Baker' 	                                 action: 'Bake the pan in the oven for the time given in the recipe.'.	frameEditor appendInstructionStatement: 'Open the oven door.'.	frameEditor appendInstructionStatement: 'Place the pan in the oven.'.	frameEditor appendInstructionStatement: 'Close the oven door.'.	frameEditor appendInstructionRole: 'Oven' statement: 'Bake for the baking-time given in the recipe.' comment: 'We have a smart oven.'.		ontology storeFrame: ( frameEditor frame ).		"Frames must be compiled if nouns are to be flagged"	ontology addNouns: #( 'recipe' 'oven' 'baking-time').	ontology compileAllFrames.	html := ontology view asHTML5.		"Test: Title line is rendered."	self pattern:  '*time given*' matches: html.	"First instruction is rendered."	self pattern:  '*Open the*' matches: html.		"2nd instruction is rendered."	self pattern:  '*pan in the*' matches: html.	"3rd instruction is rendered."	self pattern:  '*Close the*' matches: html.	"4th inststruction statement is rendered"	self pattern:  '*Bake for the*' matches: html.	"Comment is rendered"	self pattern:  '*smart oven*' matches: html.	"Role is rendered."	self pattern:  '*<role>*Oven*' matches: html.	"HTML should include 'Action:' label."	self pattern:  '*Action:*' matches: html.	"Avoid double-space bug"	self assert:(  '*<br/><br/><InstructionLine>*' match: html ) not.			"html inspect."		! !!HumOntologyTests methodsFor: 'render as HTML' stamp: 'RichardAlexanderGreen 4/20/2015 08:40'!test642renderCheckBoxAsHTML	"Given: The frame editor instance knows what kind of frame it is editing.	 When: The frame is a view and we render it as HTML for viewing the ontology source.	 Then: The rendering shows a reasonable facsimile of the corresponding HTML form, 	       but with source navigation.	"	| frameEditor ontology html |	ontology := HumOntology new.		"Initialize for a View Frame."	frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'pizza-order.'.	frameEditor addMarkUp: '!!!! Pizza Order'.	frameEditor addMarkUp: '!!!!!! Toppings'.	frameEditor addMarkUp: ' [P] Pepperoni  [S] Sausage  [H] Ham'.	self assert: ( frameEditor notNil ).		ontology storeFrame: ( frameEditor frame ).	ontology compileAllFrames.	html := ontology view asHTML5.	"Test that labels are present in the rendering."	"Title lines"	self pattern: '*Pizza Order*' matches: html.	self pattern: '*Toppings*' matches: html.	"Are widgets rendered?"	self assert: ('*[*]*' match: html ) not description: 'Hum widgets should be replaced by HTML element.'.	"Expect radio button"	self assert: ('*checkbox*' match: html) description: 'Expecting a checkbox.'.	"Watch for bug"	self pattern: '*<input name="H" type="checkbox"/> Ham*' matches: html.	self pattern: '*<input name="S" type="checkbox"/> Sausage*' matches: html.	self pattern: '*<input name="P" type="checkbox"/> Pepperoni*' matches: html.	"Inspect -- paste result into HTML tool/file."	"html inspect."			! !!HumOntologyTests methodsFor: 'render as HTML' stamp: 'RichardAlexanderGreen 4/20/2015 08:42'!test643renderTextAsHTML	"Given: The frame editor instance knows what kind of frame it is editing.	 When: The frame is a view and we render it as HTML for viewing the ontology source.	 Then: The rendering shows a reasonable facsimile of the corresponding HTML form, 	       but with source navigation.	"	| frameEditor ontology html |	ontology := HumOntology new.		"Initialize for a View Frame."	frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'Who'.	frameEditor addMarkUp: '!!!! Who Are You?'.	frameEditor addMarkUp: 'Please describe yourself for our members.'.	frameEditor addMarkUp: 'Description: [whoami 8]'.	self assert: ( frameEditor notNil ).		ontology storeFrame: ( frameEditor frame ).		ontology compileAllFrames.	html := ontology view asHTML5.	"Test that labels are present in the rendering."	"Title lines"	self pattern: '*Who Are You?*' matches: html.	"Are widgets rendered?"	self assert: ('*[*]*' match: html ) not 	     description: 'Hum widget should be replaced by HTML element.'.	"Check textarea tag attributes."  self assert: ('*<textarea*' match: html) description: 'Expecting a textarea tag.'.	self pattern: '*rows=8*' matches: html.	self pattern: '*name="whoami"*' matches: html.	"Inspect -- paste result into HTML tool/file."	"html inspect."			! !!HumOntologyTests methodsFor: 'render as HTML' stamp: 'RichardAlexanderGreen 4/20/2015 08:45'!test650renderFrame4DictionaryAsHTML	"The frame editor instance knows what kind of frame it is editing.	"	| frameEditor ontology html |	ontology := HumOntology new.			"Initialize for a Dictionary Frame."	frameEditor := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	frameEditor addDictionaryLine: 'Recipe attributes include recipe-name, description, ingredients, steps.'.	frameEditor addDictionaryLine: 'Recipe includes a list of ingredients.'.	frameEditor addDictionaryLine: 'Recipe includes a list of steps.'.	frameEditor addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	frameEditor addDictionaryLine: 'Step attributes include step-number, step-description'.			self assert: ( frameEditor notNil ).		ontology storeFrame: ( frameEditor frame ).	html := ontology view asHTML5.		self pattern:  '*vocabulary*' matches: html.	self pattern: '*recipe-name*' matches: html.	self pattern: '*<k>list</k> of ingredients*' matches: html.	self pattern: '*step-number*' matches: html.	self pattern: '*Ingredient <k>attributes</k>*' matches: html.	self pattern: '*Step <k>attributes</k>*' matches: html.		"Note: String>>match: is not case sensitive.	So following checks that capitalization is maintained."	self assert: ( (html findString: 'Step <k>attributes</k>') > 0 ).		! !!HumOntologyTests methodsFor: 'render as HTML' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!test625renderPlanTreeAsHTML	"Make several plan frames. Get the resulting plan tree."	| planFrame1 planFrame2 planFrame3 ontology planTreeView frameEditor |		ontology := HumOntology new.	"A plan frame must have a goal and at should have at least two preconditions."		planFrame1 := HumFrame4Plan ontology: ontology goal: 'Bake a cake per recipe.'.	planFrame1 appendPrecondition: 'Oven is preheated per recipe.'.		planFrame1 appendPrecondition: 'Batter is in bake-pan per recipe.'.	planFrame1 appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.	ontology storeFrame: planFrame1.			planFrame2 := HumFrame4Plan ontology: ontology goal: 'Oven is preheated per recipe.'.	planFrame2 appendPrecondition: 'Oven is cleared out.'.	planFrame2 appendPrecondition: 'Oven is on.'.	planFrame2 appendPrecondition: 'Oven temperature is set per recipe.'.	planFrame2 appendRole: 'Timer' action: 'Wait 5 minutes.'.	ontology storeFrame: planFrame2.		planFrame3 := HumFrame4Plan ontology: ontology goal: 'Batter is in bake-pan per recipe.'.	planFrame3 appendPrecondition: 'Batter fully mixed per recipe.'.	planFrame3 appendPrecondition: 'Bake-pan is greased per recipe.'.	planFrame3 appendRole: 'Baker' action: 'Pour batter into bake-pan per recipe.'.	ontology storeFrame: planFrame3.			"Create a Dictionary Frame."	frameEditor := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	frameEditor addDictionaryLine: 'Recipe attributes include recipe-name, description, ingredients, steps.'.	frameEditor addDictionaryLine: 'Recipe includes a list of ingredients.'.	frameEditor addDictionaryLine: 'Recipe includes a list of steps.'.	frameEditor addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	frameEditor addDictionaryLine: 'Step attributes include step-number, step-description'.	frameEditor addDictionaryLine: 'Bakery attributes include oven, mixer, counter.'.	frameEditor addDictionaryLine: 'Recipe attributes include baking-time.'.	ontology storeFrame: ( frameEditor frame ).	ontology compileAllFrames.		planTreeView := ontology view renderPlanTreeForGoal: 'Bake a cake per recipe.'.		self expect: 'Plan Tree:   Bake a cake per <n>recipe</n>.   |->  <n>Oven</n> <k>is</k> preheated per <n>recipe</n>.        |->  <n>Oven</n> <k>is</k> cleared out.        |->  <n>Oven</n> <k>is</k> on.        |->  <n>Oven</n> temperature <k>is</k> <k>set</k> per <n>recipe</n>.   |->  Batter <k>is</k> in bake-pan per <n>recipe</n>.        |->  Batter fully mixed per <n>recipe</n>.        |->  Bake-pan <k>is</k> greased per <n>recipe</n>.'		actual: planTreeView.
 	! !!HumOntologyTests methodsFor: 'render as HTML' stamp: 'RichardAlexanderGreen 4/20/2015 08:47'!test680renderOntologyAsHTML	"Render an ontology object in HTML and store on given filename."	| ontology frameEditor html |		ontology := HumOntology new.		"Create a Plan Frame."	frameEditor := HumFrameUpdater ontology: ontology goal: 'Cake is baked according to recipe..'.	frameEditor appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.	frameEditor appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.	frameEditor appendRole: 'Timer' action: 'Bake the pan in the oven for the time given in the recipe.' .	ontology storeFrame: ( frameEditor frame ).		"Create an Action Frame."	frameEditor := HumFrameUpdater ontology: ontology  	                                   role: 'baker' 																	action: 'Bake the pan in the oven for the time given in the recipe.'.	frameEditor appendInstructionStatement: 'Open the oven door.'.	frameEditor appendInstructionStatement: 'Place the pan in the oven.'.	frameEditor appendInstructionStatement: 'Close the oven door.'.	frameEditor appendInstructionRole: 'Oven' statement: 'Bake for the time given.' comment: 'We have a smart oven.'.		ontology storeFrame: ( frameEditor frame ).		"Create a Dictionary Frame."	frameEditor := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	frameEditor addDictionaryLine: 'Recipe attributes include recipe-name, description, ingredients, steps.'.	frameEditor addDictionaryLine: 'Recipe includes a list of ingredients.'.	frameEditor addDictionaryLine: 'Recipe includes a list of steps.'.	frameEditor addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	frameEditor addDictionaryLine: 'Step attributes include step-number, step-description'.	frameEditor addDictionaryLine: 'Bakery attributes include oven, mixer, counter.'.	frameEditor addDictionaryLine: 'Recipe attributes include baking-time.'.	ontology storeFrame: ( frameEditor frame ).	"Create a View Frame."	frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe.'.	frameEditor addMarkUp: '!!!! Recipe'.	frameEditor addMarkUp: ' recipe-name: [name]'.	frameEditor addMarkUp: '   description: [description 5]'.	frameEditor addMarkUp: '   ingredients: [ingredients]'.	frameEditor addMarkUp: '            steps: [steps]'.	ontology storeFrame: ( frameEditor frame ).		"Frames must be compiled if nouns are to be marked."	ontology compileAllFrames.	html := ontology view asHTML5.	self assert: ( html size > 1000 ).		"Frames should be have horizontal lines between."	self pattern:  '*<hr/>*<HumFrame>*' matches: html.		"Should see some nouns flagged."	self pattern:  '*<n>*</n>*' matches: html.	self pattern:  '*<n>oven</n>*' matches: html.	self pattern:  '*<n>recipe</n>*' matches: html.							! !!HumOntologyTests methodsFor: 'render as HTML' stamp: 'RichardAlexanderGreen 4/20/2015 08:51'!test640renderFrame4ViewAsHTML	"Given: The frame editor instance knows what kind of frame it is editing.	 When: The frame is a view and we render it as HTML for viewing the ontology source.	 Then: The rendering shows a reasonable facsimile of the corresponding HTML form, 	       but with source navigation.	"	| frameEditor ontology html |	ontology := HumOntology new.		"Initialize for a View Frame."	frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe.'.	frameEditor addMarkUp: '!!!! Recipe'.	frameEditor addMarkUp: ' recipe-name: [name]'.	frameEditor addMarkUp: '   description: [description 5]'.	frameEditor addMarkUp: '   ingredients: [ingredients]'.	frameEditor addMarkUp: '           steps: [steps]'.	self assert: ( frameEditor notNil ).		ontology storeFrame: ( frameEditor frame ).	ontology compileAllFrames.	html := ontology view asHTML5.	"Test that labels are present in the rendering."	"Title line"	self pattern: '*Recipe*' matches: html.	"1st markup line"	self pattern: '*recipe-name: *' matches: html.	"2nd markup line"	self pattern: '*description: *' matches: html.	"3rd markup line"	self pattern: '*ingredients: *' matches: html.	"4th (last) marup line"	self pattern: '*steps: *' matches: html.		"Test that widgets are present in the rendering."	"1st markup line"	self assert: ( ( html match:  '*[name]*'  ) not )	      description: 'Hum widget should be replaced by HTML element'.	self pattern: '*recipe-name: <input name="*"*/>*' matches: html.	"2nd markup line -- TODO: Should be multi-line box."	self assert: ( ( '*[description 5]*' match: html ) not )	      description: 'Hum widget should be replaced by HTML element'.	self pattern: '*description: <textarea name="*"*/>*' matches: html.	"3rd markup line -- TODO: Should be input-table.  (HOW?) "	self pattern: '*ingredients: <table name="*"*/>*' matches: html.	"4th markup line -- TODO: Should be input-table.  (HOW?) "	self pattern: '*steps: <table name="*"*/>*' matches: html.		"TODO: WIDGETS NEED TO BE ARTICULATED BY TYPE."	"Inspect -- paste result into HTML tool/file."	"html inspect."! !!HumOntologyTests methodsFor: 'render as HTML' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!test690renderOntologyAsHTMLonFile	"Render an ontology object in HTML and store on given filename."	| ontology frameEditor html planFrame1 planFrame2 planFrame3 |		ontology := HumOntology new.	ontology title: 'test690renderOntologyAsHTMLonFile'.			planFrame1 := HumFrame4Plan ontology: ontology goal: 'Bake a cake per recipe.'.	planFrame1 appendPrecondition: 'Oven is preheated per recipe.'.		planFrame1 appendPrecondition: 'Batter is in bake-pan per recipe.'.	planFrame1 appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.	ontology storeFrame: planFrame1.			planFrame2 := HumFrame4Plan ontology: ontology goal: 'Oven is preheated per recipe.'.	planFrame2 appendPrecondition: 'Oven is cleared out.'.	planFrame2 appendPrecondition: 'Oven is on.'.	planFrame2 appendPrecondition: 'Oven temperature is set per recipe.'.	planFrame2 appendRole: 'Timer' action: 'Wait 5 minutes.'.	ontology storeFrame: planFrame2.		planFrame3 := HumFrame4Plan ontology: ontology goal: 'Batter is in bake-pan per recipe.'.	planFrame3 appendPrecondition: 'Batter fully mixed per recipe.'.	planFrame3 appendPrecondition: 'Bake-pan is greased per recipe.'.	planFrame3 appendRole: 'Baker' action: 'Pour batter into bake-pan per recipe.'.	ontology storeFrame: planFrame3.		"Create an Action Frame."	frameEditor := HumFrameUpdater ontology: ontology  	                                   role: 'baker' 																	action: 'Bake the pan in the oven for the time given in the recipe.'.	frameEditor appendInstructionStatement: 'Open the oven door.'.	frameEditor appendInstructionStatement: 'Place the pan in the oven.'.	frameEditor appendInstructionStatement: 'Close the oven door.'.	frameEditor appendInstructionRole: 'Oven' statement: 'Bake for the baking-time given in the recipe.' comment: 'We have a smart oven.'.		ontology storeFrame: ( frameEditor frame ).		"Create a Dictionary Frame."	frameEditor := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	frameEditor addDictionaryLine: 'Recipe attributes include recipe-name, description, ingredients, steps.'.	frameEditor addDictionaryLine: 'Recipe includes a list of ingredients.'.	frameEditor addDictionaryLine: 'Recipe includes a list of steps.'.	frameEditor addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	frameEditor addDictionaryLine: 'Step attributes include step-number, step-description'.	frameEditor addDictionaryLine: 'Bakery attributes include oven, mixer, counter.'.	frameEditor addDictionaryLine: 'Recipe attributes include baking-time.'.	ontology storeFrame: ( frameEditor frame ).	"Create a View Frame."	frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.	frameEditor addMarkUp: '!!!! Recipe'.	frameEditor addMarkUp: ' recipe-name: [name]'.	frameEditor addMarkUp: '   description: [description 5]'.	frameEditor addMarkUp: '   ingredients: [ingredients]'.	frameEditor addMarkUp: '            steps: [steps]'.	ontology storeFrame: ( frameEditor frame ).		"Frames must be compiled if nouns are to be marked."	ontology compileAllFrames.	html := ontology view asHTML5.	self assert: ( html size > 1000 ).		"Write on a file."	ontology view renderAsHTMLonFileNamed: 'test690renderOntologyAsHTMLonFile.html'.			! !!HumOntologyTests methodsFor: 'render as HTML' stamp: 'RichardAlexanderGreen 4/18/2015 09:45'!test610renderStatementAsHTML	"In the HTML rendering, statement nouns are enclosed in <n>...</n> to enable style sheet rendering."	| statement role ontology html |	ontology := HumOntology new.	statement := HumStatement from: 'Add incoming-count to stock-count, giving updated-stock-count.'.	role := 'Calc'.	ontology indexRole: role action: statement.		"The nouns might be defined after the statement is defined. "	ontology addNouns: #( 'count' 'incoming-count' 'stock-count' 'updated-stock-count' ).		html := ontology view renderStatement: statement triggerWords: #('if' 'else' 'for-each') keywords: #( 'giving' 'if' 'then' 'each' ).	self assert: ( '*Add *' match: html ).	self assert: ( '*giving*' match: html ).	self assert: ( '*<k>giving</k>*' match: html ).	self assert: ( '*<n>stock-count</n>*' match: html ).	self assert: ( '*<n>stock-count</n>,*' match: html ).	self assert: ( '*<n>updated-stock-count</n>.*' match: html ).! !!HumOntologyTests methodsFor: 'render as HTML' stamp: 'RichardAlexanderGreen 4/20/2015 08:38'!test641renderRadioButtonAsHTML	"Given: The frame editor instance knows what kind of frame it is editing.	 When: The frame is a view and we render it as HTML for viewing the ontology source.	 Then: The rendering shows a reasonable facsimile of the corresponding HTML form, 	       but with source navigation.	"	| frameEditor ontology html |	ontology := HumOntology new.		"Initialize for a View Frame."	frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'pizza-order.'.	frameEditor addMarkUp: '!!!! Pizza Order'.	frameEditor addMarkUp: '!!!!!! Size'.	frameEditor addMarkUp: '  (S) Small  (M) Medium  (L) Large'.	self assert: ( frameEditor notNil ).		ontology storeFrame: ( frameEditor frame ).	ontology compileAllFrames.	html := ontology view asHTML5.	"Test that labels are present in the rendering."	"Title lines"	self pattern: '*Pizza Order*' matches: html.	self assert: ('*Size*' match: html).	"Are radio widgets rendered?"	self assert: ('*(#)*' match: html ) not description: 'Hum widget should be replaced by HTML element'.	"Expect radio button"	self assert: ('*radio*' match: html) description: 'Expecting a radio button.'.	"Inspect -- paste result into HTML tool/file."	"html inspect."			! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 18:04'!test912lineMatchesFloatingPattern	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template arguments cr |	"Test using a dictionary statement pattern."	pattern := '[1]'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: ' blah blah label: [attribute] blah blah '.	"Should match"	self assert: (frameLine matchesPattern: pattern ).	! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 16:38'!test910lineMatchesPattern	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template arguments cr |	"Test using a dictionary statement pattern."	pattern := '1 has a list of 2'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: 'Frame has a list of frameLines. '.	"Should match"	self assert: (frameLine matchesPattern: pattern ).	! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 19:46'!test922lineMatchesFloatingPatternParameters	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template parameters cr |	"Test using a dictionary statement pattern."	pattern := '[1]'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: ' blah blah label: [attribute] blah blah '.	"Should match"	self assert: (frameLine matchesPattern: pattern ).	"Get parameters"	parameters := frameLine extractPatternParameters: pattern.	self assert: ( parameters at: 1 ) = 'attribute'.		! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 16:38'!test900checkUsability	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template  cr code |	"Test using a dictionary statement pattern."	pattern := '1 has a list of 2'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: 'Frame has a list of frameLines. '.	"Should match"	self assert: (frameLine matchesPattern: pattern ).	"Generate some code"	"Check usability -- What if we wanted to generate Smalltalk?"	cr := String cr.	template := 'ontology addEntity: ''1'' attribute: ''2''.', cr, 'ontology addNoun: ''2'' isA: ''list''.'.	"Check usability -- What if we wanted to generate Java?  	In this situation, we need the singular form of the noun.
	So we will extend the template notation . . .	(2~ indicates the singular form of noun 2)"	template := 'private List<2~> 2;', cr, '1.attribute( 2 );'.	"Check usability -- What if we wanted to generate JavaScript?"	template := 'var 2 = [];  1["2"] = 2;'.		"Check usability -- What if we wanted to generate Erlang?	We will use an ets to represent an entity in Erlang.	(An Erlang record would probably be a better representation but it is not very dynamic.).	Anyway, this is mainly for testing 	Note: 2 must be a good-enough Erlang atom.	All of these languages will require that Hum nouns such as billing-address be translated to camelCase.	"	template := 'ets:new( 1, [ ordered_set, named_table ] ),', cr, 'ets:insert( 1, { 2, [] } ),'.		"Check usability -- What if we wanted to generate Python?	 We will represent entities using a dictionary in Python."	template := '1 = dict()', cr, '1.setdefault( "2", [ ] )'.  		"Generate arbitrary code"	code := frameLine onMatch: pattern generate: template.		! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 19:47'!test923lineMatchesFloatingPatternParameters	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template parameters cr |	"Test using a dictionary statement pattern."	pattern := '[1 2]'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: ' blah blah label: [entity attribute] blah blah '.	"Should match"	self assert: (frameLine matchesPattern: pattern ).		"Get parameters"	parameters := frameLine extractPatternParameters: pattern.	self assert: ( parameters at: 1 ) = 'entity'.		self assert: ( parameters at: 2 ) = 'attribute'.	! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 20:37'!test930generateCode	"Generate some code that does not require that we find a singular noun.	"	| frameLine pattern template  cr code |	"Test using a dictionary statement pattern."	pattern := '1 has a list of 2'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: 'Frame has a list of frameLines. '.	"Should match"	self assert: (frameLine matchesPattern: pattern ).	"Generate some code"	"Check usability -- What if we wanted to generate JavaScript?"	template := 'var 2 = [];  1["2"] = 2;'.		"Generate arbitrary code"	code := frameLine onMatch: pattern generate: template.		self assert: ( code sameAs: 'var framelines = [];  frame["framelines"] = framelines;' ).		! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 17:09'!test911lineDoesNotMatchPattern	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template arguments cr |	"Test using a dictionary statement pattern."	pattern := '1 has a list of 2'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: 'Frame has a set of frameLines. '.	"Should not match"	self assert: (frameLine matchesPattern: pattern ) not.	! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 18:24'!test914lineMatchesFloatingPattern	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template arguments cr |	"Test using a dictionary statement pattern."	pattern := '[1: 2]'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: ' blah blah label: [pane: view] blah blah '.	"Should match"	self assert: (frameLine matchesPattern: pattern ).	! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 19:44'!test920lineMatchesPatternParameters	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template parameters cr |	"Test using a dictionary statement pattern."	pattern := '1 has a list of 2'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: 'Frame has a list of frameLines. '.	"Should match"	self assert: (frameLine matchesPattern: pattern ).	"Get parameters"	parameters := frameLine extractPatternParameters: pattern.	self assert: ( parameters at: 1 ) = 'frame'.		self assert: ( parameters at: 2 ) = 'framelines'.	! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 18:25'!test915lineFailsFloatingPattern	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template arguments cr |	"Test using a dictionary statement pattern."	pattern := '(1)'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: ' blah blah label: [pane: view] blah blah '.	"Should match"	self assert: (frameLine matchesPattern: pattern ) not.	! !!HumOntologyTests methodsFor: 'pattern matching' stamp: 'RichardAlexanderGreen 10/27/2012 18:23'!test913lineMatchesFloatingPattern	"Test the pattern matching.	When the current line contains the pattern, 	Then the match is true.	"	| frameLine pattern template arguments cr |	"Test using a dictionary statement pattern."	pattern := '[1 2]'.	"Create a frame line that will match the pattern."	frameLine := HumFrameLine new.	frameLine source: ' blah blah label: [entity attribute] blah blah '.	"Should match"	self assert: (frameLine matchesPattern: pattern ).	! !!HumOntologyTests methodsFor: 'about Actions' stamp: 'RichardAlexanderGreen 3/17/2015 12:31'!test450instructionNounAntecedents	"Nouns in instructions should have antecedants in the action statement.	(Test the code critic)"	| ontology role action critique |		"Set up"	ontology := HumOntology new.		"Add action to the role's set of actions."	role := 'Cook'.	action := 'Bake a cake per recipe.'.	ontology indexRole: role action: (HumStatement from: action).		"Append first instruction to sequence of instructions."	ontology appendInstruction: 'Preheat oven to recipe`s oven-temperature.' toRole: role action: action.	"Append second instruction."	ontology appendInstruction: 'Mix batter per recipe.' toRole: role action: action.		self assert:  (( ontology instructionsForRole: role action: action ) size) = 2.		ontology addNouns: #( 'recipe' 'oven' 'batter' ).	"In the given instruction sequence, the nouns 'oven' and 'batter' were not seen in the action statement."		critique := ontology critiqueRole: role action: action.	self assert: ( critique size > 0 ).	self assert: ( ( critique at: 1 ) beginsWith: 'Some nouns lack antecedants').	self assert: ( ( critique at: 1 ) endsWith: 'Preheat oven to recipe`s oven-temperature.' ).	self assert: ( ( critique at: 2 ) beginsWith: 'Some nouns lack antecedants').	self assert: ( ( critique at: 2 ) endsWith: 'Mix batter per recipe.' ).	! !!HumOntologyTests methodsFor: 'about Actions' stamp: 'RichardAlexanderGreen 3/17/2015 12:15'!test410addOneAction	"An action belongs to a role."		| ontology source statement |		"Set up"	ontology := HumOntology new.		"Add role."	ontology addRole: 'Mover'.	self assert: ( ( ontology roles ) includes: 'Mover' ).		"An action is identified by a statement."	source := 'Move portable-object from current-location to new-location.'.	statement := HumStatement from: source.		"Add action to the role's set of actions."	ontology indexRole: 'Mover' action: statement.	self assert: ( ontology yesRole: 'Mover' hasAction: source ).	! !!HumOntologyTests methodsFor: 'about Actions' stamp: 'RichardAlexanderGreen 3/17/2015 12:18'!test442matchActionStatementPolymorphic	"Retrieve appropriate statement with supertype 	 when invoking sentence has a subtype."		| ontology source actionStatement candidate|		"Set up"	ontology := HumOntology new.	"Define subtypes"	ontology addNoun: 'cake' isA: 'bake-product'.	ontology addNoun: 'pie' isA: 'bake-product'.			"Add action to the role's set of actions."	source := 'Bake a bake-product per recipe.'.	ontology indexRole: 'Baker' action:  (HumStatement from: source ).	candidate :=  'Bake a bake-product per recipe.'.	"Check that String>>sameAs: means what we expect."	self assert: ( candidate sameAs: source ).	self assert: ( source sameAs: candidate ).	"Should be able to retrieve with string that matches our source."	self assert: ( ontology yesRole: 'Baker' hasAction: candidate ).		"Get back the action statement. "	actionStatement := ontology getRole: 'Baker' action: candidate.	self assert: ( actionStatement isKindOf: HumStatement ).		"Candidate should match when it is word for word the same."	self assert: ( actionStatement matchesCandidateStatement: candidate inOntology: ontology).	"Candidate should also match if the articles are dropped or different."	candidate :=  'Bake the bake-product per the recipe.'.	self assert: ( actionStatement matchesCandidateStatement: candidate inOntology: ontology).	candidate :=  'Bake bake-product per recipe.'.	self assert: ( actionStatement matchesCandidateStatement: candidate inOntology: ontology).		"Now prove polymorphism works."	candidate :=  'Bake a cake per recipe.'.	self assert: ( actionStatement matchesCandidateStatement: candidate inOntology: ontology).	candidate :=  'Bake a pie per recipe.'.	self assert: ( actionStatement matchesCandidateStatement: candidate inOntology: ontology).	"But cookie-batch is not defined as a subtype in this ontology.	(Check for false positive.)"	candidate :=  'Bake a cookie-batch per recipe.'.	self assert: ( actionStatement matchesCandidateStatement: candidate inOntology: ontology) not.					! !!HumOntologyTests methodsFor: 'about Actions' stamp: 'RichardAlexanderGreen 3/17/2015 12:26'!test420actionInstructions	"An action statement is defined by a sequence of instructions."		| ontology role action instruction1 instruction2 instructionSequence |		"Set up"	ontology := HumOntology new.		"Add action to the role's set of actions."	role := 'Cook'.	action := 'Bake a cake per recipe.'.	ontology indexRole: role action:  ( HumStatement from: action ).	self assert: ( ontology yesRole: role hasAction: action ).		"Create an instruction."	" -- Instructions elements are all optional and include role, statement, comment, annotaion, translation."	instruction1 := HumInstructionLine new.	instruction1 statement: 'Preheat oven to recipe`s oven-temperature.'; role: 'Oven'.	                   	"Append instruction to sequence of instructions."	ontology appendInstruction: instruction1 toRole: role action: action.	"test"	instructionSequence := ( ontology instructionsForRole: role action: action ).	self assert: ( instructionSequence includes: instruction1).		"Create another instruction."	instruction2 := HumInstructionLine new.	instruction2 statement: 'Mix batter per recipe.'; role: 'Mixer'; annotation: 'duration: 5 minutes'.	self assert: ( instructionSequence size) = 1.	self assert: ( instructionSequence last = instruction1).		"Append second instruction to sequence of instructions."	ontology appendInstruction: instruction2 toRole: role action: action.	"test"	instructionSequence := ( ontology instructionsForRole: role action: action ).	self assert: ( instructionSequence size) = 2.	self assert: ( instructionSequence last = instruction2).	! !!HumOntologyTests methodsFor: 'about Actions' stamp: 'RichardAlexanderGreen 3/17/2015 12:36'!test461Frame4ActionCrossReferences	"Given: An action instruction delegates to another role (or same role).	When: The action frame is compiled.	Then: The ontology tracks where (which role-action frame) the action statement is invoked.	"	| frameUpdater frameUpdater2 ontology actionTitle1 actionTitle2  relations |	ontology := HumOntology new.		"Initialize for an Action Frame."	frameUpdater := HumFrameUpdater ontology: ontology  	                                   role: 'Baker' 	                                 action: 'Bake the pan in the oven for the time given in the recipe.'.	frameUpdater appendInstructionStatement: 'Open the oven door.'.	frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.	frameUpdater appendInstructionStatement: 'Close the oven door.'.	frameUpdater appendInstructionRole: 'Oven' 	                     statement: 'Bake for the baking-time given in the recipe.' 	                       comment: 'We have a smart oven.'.		ontology storeFrame: ( frameUpdater frame ).	actionTitle1 := frameUpdater frame title.		frameUpdater2 := HumFrameUpdater ontology: ontology																	  role: 'Oven'																	action: 'Bake for the baking-time given in the recipe.'.	ontology storeFrame: ( frameUpdater2 frame ).	actionTitle2 := frameUpdater2 frame title.		"Frames must be compiled if nouns are to be flagged"	ontology addNouns: #( 'recipe' 'oven' 'baking-time').	  "When: The action frame is compiled."	ontology compileAllFrames.	"Then: The ontology tracks where (which role-action frame) the action statement is invoked."	relations := ontology frameRelations.	self assert: (relations size > 0).	self assert: ( relations includes: { actionTitle1. #invokesAction. actionTitle2 asLowercase. }  ).		! !!HumOntologyTests methodsFor: 'about Actions' stamp: 'RichardAlexanderGreen 3/17/2015 12:17'!test440getRoleActionStatement	"An action belongs to a role."		| ontology source actionStatement |		"Set up"	ontology := HumOntology new.			"Add action to the role's set of actions."	source :=  'Bake a cake per recipe.'.	ontology indexRole: 'Baker' action:  (HumStatement from: source ).	self assert: ( ontology yesRole: 'Baker' hasAction: source ).		"Get back the action statement. "	actionStatement := ontology getRole: 'Baker' action: source.	self assert: ( actionStatement isKindOf: HumStatement ).		"It should, of course, match."	self assert: ( actionStatement matchesCandidateStatement: source inOntology: ontology).	! !!HumOntologyTests methodsFor: 'about Actions' stamp: 'RichardAlexanderGreen 3/17/2015 12:29'!test430createInstructionsInline	"Create instructions in-line using Class methods"	| ontology role action |		"Set up"	ontology := HumOntology new.		"Add action to the role's set of actions."	role := 'Cook'.	action := 'Bake a cake per recipe.'.	ontology indexRole: role action: (HumStatement from: action).		"Append first instruction to sequence of instructions."	ontology appendInstruction: 'Preheat oven to recipe`s oven-temperature.' toRole: role action: action.	"Append second instruction."	ontology appendInstruction: 'Mix batter per recipe.' toRole: role action: action.	self assert: ( ( ontology instructionsForRole: role action: action) size) = 2.	self assert: ( ( ontology instructionsForRole: role action: action) includes:  'Mix batter per recipe.' ).				! !!HumOntologyTests methodsFor: 'about Actions' stamp: 'RichardAlexanderGreen 3/17/2015 12:17'!test441matchActionStatementAgainstCandidate	"Retrieve statement object from ontology when given a similar string."		| ontology source actionStatement candidate|		"Set up"	ontology := HumOntology new.			"Add action to the role's set of actions."	source := 'Bake a cake per recipe.'.	ontology indexRole: 'Baker' action:  (HumStatement from: source ).	candidate :=  'Bake a cake per recipe.'.	"Check that String>>sameAs: means what we expect."	self assert: ( candidate sameAs: source ).	self assert: ( source sameAs: candidate ).	"Should be able to retrieve with string that matches our source."	self assert: ( ontology yesRole: 'Baker' hasAction: candidate ).		"Get back the action statement. "	actionStatement := ontology getRole: 'Baker' action: candidate.	self assert: ( actionStatement isKindOf: HumStatement ).		"Candidate should match when it is word for word the same."	self assert: ( actionStatement matchesCandidateStatement: candidate inOntology: ontology).	"Candidate should also match if the articles are dropped or different."	candidate :=  'Bake the cake per the recipe.'.	self assert: ( actionStatement matchesCandidateStatement: candidate inOntology: ontology).	candidate :=  'Bake cake per recipe.'.	self assert: ( actionStatement matchesCandidateStatement: candidate inOntology: ontology).		! !!HumOntologyTests methodsFor: 'about Roles' stamp: 'RichardAlexanderGreen 9/17/2014 11:39'!test220addOneRole	"Add one role to current set."	| ontology |	ontology := HumOntology new.	ontology addRole: 'Mover'.	self assert: ( (ontology roles) includes: 'Mover' ).! !!HumOntologyTests methodsFor: 'about Roles' stamp: 'RichardAlexanderGreen 9/17/2014 11:40'!test230addTwoRoles	"Add two roles  to current set."	| ontology |	ontology := HumOntology new.	"Add first role."	ontology addRole: 'Mover'.	self assert: ( (ontology roles) includes: 'Mover' ).	"Add second role."	ontology addRole: 'Shaker'.	self assert: ( (ontology roles) includes: 'Shaker' ).	"Make sure we did not overlay original"	self assert: ( (ontology roles) includes: 'Mover' ).  ! !HumSeasideTests subclass: #HumSeasideWidgetTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumSeasideWidgetTests commentStamp: 'RichardAlexanderGreen 3/17/2014 14:35' prior: 0!Test the HumWidget subclasses as Seaside components.!!HumSeasideWidgetTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/26/2015 17:34'!test135ViewUptoWidget	"A Hum view frame is rendered as a Seaside Form ...	Render '[attribute name]' ...	"	| ontology frameEditor errors  humView |	ontology := HumOntology new.		"Initialize the View Frame for this test."	frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.	"Add markup lines."	"frameEditor addMarkUp: '!!!! Recipe'."	frameEditor addMarkUp: ' recipe-name: [name]'.	"	frameEditor addMarkUp: '   description: [description 5]'.	frameEditor addMarkUp: '   ingredients: [ingredients]'.	frameEditor addMarkUp: '         steps: [steps]'.	"	ontology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).	errors := frameEditor compileToOntology: ontology.	self assert: ( errors isEmpty  ).	"Create HumView as interface between Ontology and Seaside"	humView := HumView new.	humView		ontology: ontology;		view: 'recipe';		blackboard: (HumBlackBoard new).	humView blackboard businessEvent: 'test135'.		"Generate Seaside code for the view frame."		"Expect input within the form."	self assert: [ :html | humView asWidget renderOn: html ] matches: '*recipe-name*<input*'.			! !!HumSeasideWidgetTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/26/2015 15:30'!test107BindWidgetToCategory	"A widget may be bound to blackboard"	|  widget blackboard value entityName attributeName |	"wire it up"	blackboard := HumBlackBoard worldbase: 'none'.	blackboard businessEvent: 'test107BindWidgetToCategory'.	entityName := 'test107'.	attributeName := 'some-attribute'.	widget := HumCategoryWidget onEntity: entityName attribute: attributeName blackboard: blackboard.	widget categories: #( 'red' 'green' 'blue' 'yellow' 'orange' 'purple' ).	"Test flow: widget ==> blackboard ==> world base"	value := 'red'. 	widget store: value.	self expect: value actual: widget attributeValue.	self expect: value actual: (blackboard getEntityName: entityName attribute: attributeName).						! !!HumSeasideWidgetTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/27/2014 22:24'!test132ViewHasHeadingLine	"A Hum view frame is rendered as a Seaside Form ...	Render Hum Heading Markup as HTML heading.	"	| ontology frameEditor errors  humView |	ontology := HumOntology new.		"Initialize the View Frame for this test."	frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.	"Add markup lines."	frameEditor addMarkUp: '!!!! Recipe'.	errors := frameEditor compileToOntology: ontology.	self assert: ( errors isEmpty  ).	"Create HumView as interface between Ontology and Seaside"	humView := HumView new.	humView		ontology: ontology;		view: 'recipe';		blackboard: (HumBlackBoard new).			"Generate Seaside code for the view frame."		"Expect heading within the form."	self assert: [ :html | humView asWidget renderOn: html ] matches: '*<h2>*</h2>*'.	self assert: [ :html | humView asWidget renderOn: html ] matches: '*<form*<br/>*<h2>*</h2>*</form>*'.			! !!HumSeasideWidgetTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/25/2014 10:18'!test100BasicWiring	"A Hum view frame is rendered as a Seaside Form."	| ontology    humView |	ontology := HumOntology new.		"Initialize the View Frame for this test."   self setUpViewFrameInOntology: ontology.	"Create HumView as interface between Ontology and Seaside"	humView := HumView new.	humView		ontology: ontology;		view: 'recipe';		blackboard: (HumBlackBoard new).			"Generate Seaside code for the view frame."			self assert: humView gives: 'a HumView'.		! !!HumSeasideWidgetTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/25/2014 10:40'!test120ViewHasFormTag	"A Hum view frame is rendered as a Seaside Form.	"	| ontology    humView frameEditor errors |	ontology := HumOntology new.		"Initialize the View Frame for this test."	frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.	"Add markup lines."	frameEditor addMarkUp: '!!!! Recipe'.	errors := frameEditor compileToOntology: ontology.	self assert: ( errors isEmpty  ).	"Create HumView as interface between Ontology and Seaside"	humView := HumView new.	humView		ontology: ontology;		view: 'recipe';		blackboard: (HumBlackBoard new).			"Generate Seaside code for the view frame."			self assert: [ :html | humView asWidget renderOn: html ] matches: '*<form *id="recipe"*>*</form>*'.		! !!HumSeasideWidgetTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/20/2014 14:41'!setUpViewFrameInOntology: aHumOntology	"Generate a view frame and dictionary entries for several tests.	---	!!!! Recipe	recipe-name: [name]	  description: [description]	  ingredients: [ingredients]	        steps: [steps]	---	Dictionary: Recipe attributes.	. Recipe attributes include recipe-line, description, ingredients, steps.	. Description is a text.	. Recipe has a set of ingredients.	. Recipe has a list of steps.	---	"	| frameEditor errors |	"Create a view frame."	frameEditor := HumFrameUpdater ontology: aHumOntology viewEntity: 'recipe'.	"Add markup lines."	frameEditor addMarkUp: '!!!! Recipe'.	frameEditor addMarkUp: ' recipe-name: [name]'.	frameEditor addMarkUp: '   description: [description]'.	frameEditor addMarkUp: '   ingredients: [ingredients]'.	frameEditor addMarkUp: '         steps: [steps]'.	aHumOntology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).	errors := frameEditor compileToOntology: aHumOntology.	self assert: ( errors isEmpty  ).		"TODO: Make this smarter. 	- At the very least, description, ingredients, and steps could be of type text.	- (and rendered using textarea tag).	"		"Create a dictionary frame."	frameEditor := HumFrameUpdater ontology: aHumOntology dictionaryTitle: 'Recipe attributes.'.	frameEditor addDictionaryLine: 'Recipe attributes include recipe-line, description, ingredients, steps.'.	frameEditor addDictionaryLine: 'Description is a text.'.	"TODO: Should render description as a text area."	frameEditor addDictionaryLine: 'Recipe has a set of ingredients.'.	"TODO: Should render ingredients as an unordered list."	frameEditor addDictionaryLine: 'Recipe has a list of steps.'.	"TODO: Should render steps as an ordered list."	errors := frameEditor compileToOntology: aHumOntology.	self assert: ( errors isEmpty  ).	 			! !!HumSeasideWidgetTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/26/2014 15:32'!test102BasicWiring2	"A Hum view frame is rendered as a Seaside Form."	| ontology    humView frameEditor errors |	ontology := HumOntology new.		"Initialize the View Frame for this test."	frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.	"Add markup lines."	frameEditor addMarkUp: '!!!! Recipe'.	errors := frameEditor compileToOntology: ontology.	self assert: ( errors isEmpty  ).	"Create HumView as interface between Ontology and Seaside"	humView := HumView new.	humView		ontology: ontology;		view: 'recipe';		blackboard: (HumBlackBoard new).			"Generate Seaside code for the view frame."			self assert: (humView asWidget) matches: '<view id="recipe">*</view>'.		! !!HumSeasideWidgetTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/26/2015 15:30'!test105BindWidgetToBlackboard	"A widget may be bound to blackboard"	|  widget blackboard value entityName attributeName |	"wire it up"	blackboard := HumBlackBoard worldbase: 'none'.	blackboard businessEvent: 'test105BindWidgetToBlackboard'.	"Refactor Test: Test binding of blackboard to worldbase elsewhere."	"worldbase := HumWorldBase new. 	blackboard worldbase: worldbase."	entityName := 'test105'.	attributeName := 'some-attribute'.	widget := HumWidget onEntity: entityName attribute: attributeName blackboard: blackboard.	"Test flow: widget ==> blackboard ==> world base"	value := 'aValue'. 	widget store: value.	self expect: value  actual: widget attributeValue.	self expect: value  actual: (blackboard getEntityName: entityName attribute: attributeName).						! !!HumSeasideWidgetTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/26/2015 17:35'!test138ViewHasDateWidget	"A Hum view frame is rendered as a Seaside Form ...	Render '[attribute name]' ...	"	| ontology frameEditor errors  humView |	ontology := HumOntology new.		"Initialize the View Frame for this test."	frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'reservation'.	"Add markup lines."	frameEditor addMarkUp: '   arrival date: [arrival-date]'.	ontology addNoun: 'arrival-date' isA: 'date'.	errors := frameEditor compileToOntology: ontology.	self assert: ( errors isEmpty  ).	"Create HumView as interface between Ontology and Seaside"	humView := HumView new.	humView		ontology: ontology;		view: 'reservation';		blackboard: (HumBlackBoard new).	humView blackboard businessEvent: 'test138'.		"Generate Seaside code for the view frame."		"Expect date input within the form."	self assert: [ :html | humView asWidget renderOn: html ] matches: '*<input*type="date"*'.			! !!HumSeasideWidgetTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/26/2014 15:01'!test011GivenWhenThenFail	"Dry test the test frame"	self given: '' code: [].	self when: '' code: [].	self then: '' code: [ self assert: true "false".].	! !!HumSeasideWidgetTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/26/2015 17:35'!test140ViewHasMeasureWidget	"A Hum view frame is rendered as a Seaside Form ...	Render '[category-name]' ...	"	| ontology frameEditor errors  humView |	ontology := HumOntology new.		"Initialize the View Frame for this test."	frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'reservation'.	"Add markup lines."	frameEditor addMarkUp: '   number of adults: [adult-count]'.	ontology addNoun: 'adult-count' isA: 'Measure'.	errors := frameEditor compileToOntology: ontology.	self assert: ( errors isEmpty  ).	"Create HumView as interface between Ontology and Seaside"	humView := HumView new.	humView		ontology: ontology;		view: 'reservation';		blackboard: (HumBlackBoard new).	humView blackboard businessEvent: 'test140'.		"Generate Seaside code for the view frame."		"Expect date input within the form."	self assert: [ :html | humView asWidget renderOn: html ] matches: '*<input*type="number"*'.			! !!HumSeasideWidgetTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/26/2015 17:36'!test150ViewLineHasSeveralWidgets	"A Hum view frame is rendered as a Seaside Form ...	Render '[category-name]' ...	"	| ontology frameEditor errors  humView |	ontology := HumOntology new.		"Initialize the View Frame for this test."	frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'who'.	"Add markup lines."	frameEditor addMarkUp: '   prefix: [prefix] first: [first-name] middle: [middle-name] last: [last-name] suffix: [suffix]'.	ontology addNouns: #( 'prefix' 'first-name' 'middle-name' 'last-name' 'suffix' ).	errors := frameEditor compileToOntology: ontology.	self assert: ( errors isEmpty  ).	"Create HumView as interface between Ontology and Seaside"	humView := HumView new.	humView		ontology: ontology;		view: 'who';		blackboard: (HumBlackBoard new).	humView blackboard businessEvent: 'test150'.		"Generate Seaside code for the view frame."		"Expect date input within the form."	self assert: [ :html | humView asWidget renderOn: html ] matches: '*prefix:*id="prefix"*'.	self assert: [ :html | humView asWidget renderOn: html ] matches: '*suffix:*id="suffix"*'.			! !!HumSeasideWidgetTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/26/2015 17:35'!test136ViewHasTextWidget	"A Hum view frame is rendered as a Seaside Form ...	Render '[attribute name]' ...	"	| ontology frameEditor errors  humView |	ontology := HumOntology new.		"Initialize the View Frame for this test."	frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.	"Add markup lines."	"frameEditor addMarkUp: '!!!! Recipe'.	frameEditor addMarkUp: ' recipe-name: [name]'.	"	frameEditor addMarkUp: '   description: [description 5]'.	"	frameEditor addMarkUp: '   ingredients: [ingredients]'.	frameEditor addMarkUp: '         steps: [steps]'.	"	ontology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).	errors := frameEditor compileToOntology: ontology.	self assert: ( errors isEmpty  ).	"Create HumView as interface between Ontology and Seaside"	humView := HumView new.	humView		ontology: ontology;		view: 'recipe';		blackboard: (HumBlackBoard new).	humView blackboard businessEvent: 'test136'.		"Generate Seaside code for the view frame."		"Expect test area within the form."	self assert: [ :html | humView asWidget renderOn: html ] matches: '*<textarea*'.	self assert: [ :html | humView asWidget renderOn: html ] matches: '*rows="5"*'.			! !!HumSeasideWidgetTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/26/2015 17:35'!test139ViewHasCategoryWidget	"A Hum view frame is rendered as a Seaside Form ...	Render '[category-name]' ...	"	| ontology frameEditor errors  humView |	ontology := HumOntology new.		"Initialize the View Frame for this test."	frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'reservation'.	"Add markup lines."	frameEditor addMarkUp: '   class of room: [room-class]'.	ontology categoriesOf: 'room-class' include: #( 'King' 'Double Queen' 'Suite' ) .	errors := frameEditor compileToOntology: ontology.	self assert: ( errors isEmpty  ).	"Create HumView as interface between Ontology and Seaside"	humView := HumView new.	humView		ontology: ontology;		view: 'reservation';		blackboard: (HumBlackBoard new).	humView blackboard businessEvent: 'test139'.		"Generate Seaside code for the view frame."		"Expect date input within the form."	self assert: [ :html | humView asWidget renderOn: html ] matches: '*<select*<option*Suite*'.			! !!HumSeasideWidgetTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/20/2014 14:01'!test010GivenWhenThen	"Test the test frame"	self given: '' code: [].	self when: '' code: [].	self then: '' code: [ self assert: true.]! !!HumSeasideWidgetTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/25/2014 10:54'!test130ViewHasMarkupLines	"A Hum view frame is rendered as a Seaside Form ...	Expect multiple lines within the form	"	| ontology    humView frameEditor errors |	ontology := HumOntology new.		"Initialize the View Frame for this test."	frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.	"Add markup lines."	frameEditor addMarkUp: '!!!! Recipe'.	"	frameEditor addMarkUp: ' recipe-name: [name]'.	frameEditor addMarkUp: '   description: [description]'.	frameEditor addMarkUp: '   ingredients: [ingredients]'.	frameEditor addMarkUp: '         steps: [steps]'.	"	ontology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).	errors := frameEditor compileToOntology: ontology.	self assert: ( errors isEmpty  ).	"Create HumView as interface between Ontology and Seaside"	humView := HumView new.	humView		ontology: ontology;		view: 'recipe';		blackboard: (HumBlackBoard new).			"Generate Seaside code for the view frame."		"Expect break within the form."	self assert: [ :html | humView asWidget renderOn: html ] matches: '*<form*<br/>*</form>*'.			! !!HumSeasideWidgetTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/25/2014 10:39'!test110ViewHasViewTag	"A Hum view frame is rendered as a Seaside Form.	"	| ontology    humView frameEditor errors |	ontology := HumOntology new.		"Initialize the View Frame for this test."	frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.	"Add markup lines."	frameEditor addMarkUp: '!!!! Recipe'.	errors := frameEditor compileToOntology: ontology.	self assert: ( errors isEmpty  ).		"Create HumView as interface between Ontology and Seaside"	humView := HumView new.	humView		ontology: ontology;		view: 'recipe';		blackboard: (HumBlackBoard new).			"Generate Seaside code for the view frame."			self assert: [ :html | humView asWidget renderOn: html ] matches: '<view id="recipe">*</view>'.		! !!HumSeasideWidgetTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/26/2015 17:31'!test134ViewHasStringWidget	"A Hum view frame is rendered as a Seaside Form ...	Render '[attribute name]' ...	"	| ontology frameEditor errors  humView |	ontology := HumOntology new.		"Initialize the View Frame for this test."	frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.	"Add markup lines."	"frameEditor addMarkUp: '!!!! Recipe'."	frameEditor addMarkUp: ' recipe-name: [name]'.	"	frameEditor addMarkUp: '   description: [description 5]'.	frameEditor addMarkUp: '   ingredients: [ingredients]'.	frameEditor addMarkUp: '         steps: [steps]'.	"	ontology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).	errors := frameEditor compileToOntology: ontology.	self assert: ( errors isEmpty  ).	"Create HumView as interface between Ontology and Seaside"	humView := HumView new.	humView		ontology: ontology;		view: 'recipe';		blackboard: (HumBlackBoard new).	humView blackboard businessEvent: 'test134ViewHasStringWidget'.	"Generate Seaside code for the view frame."		"Expect input within the form."	self assert: [ :html | humView asWidget renderOn: html ] matches: '*<input*'.			! !HumTestCase subclass: #Hum000RefactoringTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!Hum000RefactoringTests commentStamp: 'RichardAlexanderGreen 1/31/2014 11:06' prior: 0!Collaborative Roles and ResponsibilitiesTop-Level Roles===============Role: Ontology.	Goal: Maintain and access frames.		Action: Add frame.		Action: Get frame where title = string.		Action: Add frame-line.	Goal: Maintain and access noun relationships.		Action: Add noun attributes.		Action: Note noun supertype.		Action: Get all supertypes for noun.		Action: Get all subtypes for noun.	Role: Ontology Translator	Goal: Translate ontology into other languages.		Action: Pretty-point ontology via HTML markup.		Action: Translate ontology role to Erlang process.		Action: Translate ontology role to Java interface and class files.		Action: Render Hum view as JavaScript interactive.Role: Programmers Assistant. (subtype Ontology or Dialog ???)	Goal: Display and update ontology frames and diagrams.		Action: Layout IDE view frames.		Action: Notify user-interface listeners.		Action: Respond to user-interface (scribe) events.Role: Run-Time.	Goal: Operate plans, views, and dialogs.Role: Run-Time User-Interface.	Goal: Translate to/from user-interface framework (e.g. HTML browser)		Action: Translate Hum view to HTML.		Action: Capture and forward view update event data. (to Scribe / Blackboard ???)		* Dialog: Operate Hum dialog.		* Dialog: Operate Hum view.		* Dialog: Ask client for data needed to operate plan.		Action: Track 2-D surface coordinates.		Action: Track 3-D solid coordinates.		Action: Draw diagram from graph-data.		* Painter: Render surfaces as SVG.		* Painter: Render diagram as SVG.		* Sculptor: Render 3-D solid assembly as SVG/JavaScript. (Use WebGL wrapper)Role: Run-Time Calculator.	Goal: VM provides data processing services, operates on datatype primitives.	   Measure Operations:		Action: Add/Subtract/Multiply/Divide measure-A with measure-B giving measure-C.		Action: Add/Subtract/Multiply/Divide distribution-A and distribution-B giving distribution-C.	   Distribution Operations:		Action: From distribution select value at Z. (Z between 0.0 and 1.0. Interpolating to give value.)		Action: From collection analyze attribute frequency giving distribution.	   String Operations:		Action: Extract substring from string-A . . . giving string-B.		Action: Insert  substring into string-A . . . giving string-B.		Action: Format xml with . . . giving xml-string.		Action: Fill in template from dictionary.		Action: Match pattern to string giving dictionary.	   Date  Operations:		Action: Compare date-A with date-B giving duration.		Action: Add duration to date-A giving date-B.	   Collection Operations:		Action: In collection-A return entities where <boolean expression> giving collection-B.		Action: From collection return size (count).	   Persistence Operations:		Action: Save/Restore actor`s state {blackboard, IP, job-ticket}. (On call to another actor)		Action: Notify World-Base when blackboard changes.		Action: Populate blackboard from action-call {requester, action, noun-values, job-ticket}.		Action: Forward action-call to Messenger.. . . Run-Time Work-Flow Roles . . .- - - - - - - - - - - - - - - - - - -Role: Supervisor.	Goal: Operate plans.		Action: Populate plan with data from blackboard.		Action: Evaluate preconditions and invoke actions that are ready.		Action: Assert precondition. (when action completes)		Action: Notify client and bookkeeper when plan is complete.		* Dialog: Ask for data needed to operate plan.Role: Resource Manager.	Goal: Manage actors.		* Dispatcher: Assign actor to perform role action on job.		* Bookkeeper: Tally resource usage for job.		* DangerMan: Handle problem reported by actor performing action for job.Role: Bookkeeper.	Goal: Track resource utilization.		Action: Record resources used by actor performing action on job.		Action: Sum resource utilized by actor/job/client/action/resource-type/inventory.		Action: Select . . .Role: Messenger.	Goal: Deliver messages. Provide log, audit-trail, replay, security services. 		Action: Deliver message from sender to receiver.		Action: Remember actor is at address.		Action: Replay messages to/from actor since date-time.		Action: Record each action-type in audit-trail.		Action: Remember/Forget that action-type requires privilege-type.	!!Hum000RefactoringTests methodsFor: '000 Class Responsibiltiy Collaboration' stamp: 'RichardAlexanderGreen 9/14/2014 13:49'!humClassResponsiblityCollaboration^'Collaborative Roles and ResponsibilitiesTODO: Does this "Purpose:" hierarchy has a place in Hum Action Frames?Top-Level Roles===============Role: Ontology.	Purpose: Maintain and access frames.  		Action: Add frame.        (Other tests will also cover.)		Action: Add frame-line.   (Depends on the kind of frame. Other tests will cover as by-product.)		Action: Get frame where . . .  (tests12x ... 13x )		Action: . . . where goal is planned.		Action: . . . where action is defined.		Action: . . . where view is defined.		Action: Get frames where . . .		Action: . . . where precondition is used. (A goal-frame has a set of preconditions.)		Action: . . . where action is invoked.    (Actions may be invoked in goal, action, and vignette frames.)		Action: . . . where view is invoked.      (A view may be invoked in view and vignette frames.)		Action: . . . where context is defined. 	(Each context vignette is a frame.)		Action: . . . where context is invoked.  	(Scan the vignette instructions at compile time?)	Purpose: Maintain and access noun relationships. (These are covered in old HumOntologyTests)		Action: Add noun attributes.		Action: Note noun supertype.		Action: Get all supertypes for noun.		Action: Get all subtypes for noun.		Action: Get frame-lines where noun is used.  (Skipped -- 12 Feb 2014)	Role: Ontology Viewer. (subtype Ontology   *** REFACTORING ***)	Purpose: Provide visualizations of the ontology.		Action: Pretty-print ontology via HTML markup.		Action: Translate ontology relationships to graph. (UI may render graph as SVG).		Action: . . . goal dependencies . . .		Action: . . . noun dependencies . . .		Action: . . . role dependencies . . .		Action: . . . dialog context paths . . .		Action: . . . view hierarchy . . .		Role: Ontology Translator (subtype Ontology  *** REFACTORING ***)	Purpose: Translate ontology into other programming languages.		Action: Translate ontology role to Erlang process.		Action: Translate ontology goal-frame to Erlang FSM.		Action: Translate ontology role to Java interface and class files.		Action: Translate Hum view to Smalltalk Seaside (+ Hum Run-Time).	   Futures?		Action: Translate ontology role to Python class.		Action: Translate ontology role to Javascript class. (prototype)		Role: Programmers Assistant. (subtype Dialog)	Purpose: Display and update ontology frames and diagrams.		Action: Respond to user gestures by invoking ontology and user-interface actions.		Action: Layout IDE view frames.		Action: Parse frame-line source code.	Purpose: Identify potential problems, missing code. (Code Critic)		Action: Statement has no known nouns.  (Implies that the only parameter is the job.)		Action: Noun lacks antecedent.         (There is no way to populate it at run-time.)		Action: Spellcheck frame-line.         (Words should be in natural dictionary or local jargon.)		Action: Identify undefined preconditions as pending.		Action: Identify undefined actions as pending. 		Action: Identify noun-graph cycles as warning.		Action: Identify precondition-graph cycles as error.		Action: Identify action-graph cycles as warning.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Run-Time Layer==============Role: Run-Time.	Purpose: Operate plans, views, and dialogs.   (Ontology is active on the run-time layer.)		* Coordinator: Operate plans.		* User-Interface: Operate views.		* Dialog-Agent: Operate dialogs.		* Messenger: Provide agent-to-agent communication infrastructure.		* Resource-Manager: Assign agents to tasks. (actions on jobs)		* Bookkeeper: Record resource utilization.		* Calculator: Implement traditional data-processing operations.		* World-Base: Implement temporal database.Role: Run-Time User-Interface. (Hum-UI package)	Purpose: Translate to/from user-interface framework (e.g. HTML browser)		Action: Capture and forward view update event data. (to Scribe / Blackboard ???)		* Dialog: Operate Hum dialog.		* Dialog: Operate Hum view.		* Dialog: Ask client for data needed to operate plan.		Action: Track 2-D surface coordinates.		* Painter: Render surfaces as SVG.		Action: Draw diagram from graph-data.		* Painter: Render diagram as SVG. 		 (TODO: Should HumGraph or Painter position the nodes in virtual space?)		 (TODO: Use an external product for dynamic interactive positioning.)		Action: Track 3-D solid coordinates.		* Sculptor: Render 3-D solid assembly as SVG/JavaScript. (Use WebGL wrapper)Role: Run-Time Calculator.  (HumCalculator class)	Purpose: VM provides data processing services, operates on datatype primitives.	   (Measure Operations)		Action: Add/Subtract/Multiply/Divide measure-A with measure-B giving measure-C.		Action: Add/Subtract/Multiply/Divide distribution-A and distribution-B giving distribution-C.	   (Distribution Operations)		Action: From distribution select value at Z. (Z between 0.0 and 1.0. Interpolating to give value.)		Action: From collection analyze attribute frequency giving distribution.	   (String Operations)		Action: Extract substring from string-A . . . giving string-B.		Action: Insert  substring into string-A . . . giving string-B.		Action: Format xml with . . . giving xml-string.		Action: Fill in template from dictionary.		Action: Match pattern to string giving dictionary.	   (Date  Operations)		Action: Compare date-A with date-B giving duration.		Action: Add duration to date-A giving date-B.	   (Collection Operations)		Action: In collection-A return entities where <boolean expression> giving collection-B.		Action: From collection return size (count).	   (Persistence Operations)		Action: Save/Restore actor`s state {blackboard, IP, job-ticket}. (On call to another actor)		Action: Notify World-Base when blackboard changes.		Action: Populate blackboard from action-call {requester, action, noun-values, job-ticket}.		Action: Forward action-call to Messenger.		 (String, Date, Collection, Persistence support bootstrap and user extensions.)- - - - - - - - - - - - - - - - - - -. . . Run-Time Work-Flow Roles . . .- - - - - - - - - - - - - - - - - - -Role: Coordinator.	Purpose: Operate plans.		Action: Populate plan with data from blackboard.		* Dialog: Ask for data needed to operate plan.		Action: Evaluate preconditions and invoke actions that are ready.		Action: Assert precondition. (when action completes)		Action: Notify client and bookkeeper when plan is complete.		* Role: Dispatcher.	Purpose: Manage actors.		* Dispatcher: Assign actor to perform role action on job.		* Bookkeeper: Tally resource usage for job.		* Intervener: Handle problem reported by actor performing action for job.		* Monitor: Identify over-long action-duration.Role: Bookkeeper.	Purpose: Track resource utilization.   (Bookkeeper does not monetize utilization or inventory. See Accounting role for that.)		Action: Record resource-utilized by actor performing action on job.		Action: Sum/Select resource-utilized by actor/job/client/action/resource-type/inventory.   (12 slightly different actions)Role: Messenger.	Purpose: Deliver messages. Provide log, audit-trail, replay, security services. 		Action: Deliver message from sender to receiver.		Action: Remember actor is at address.		Action: Replay messages to/from actor since date-time.		Action: Record each action-type in audit-trail.		Action: Remember/Forget that action-type requires privilege-type.Role: World-Base.	Purpose: Remember what happened and why.	(Corporate long-term memory.)		Action: Record event. (Event <==> Timestamp.)		Action: Record entity attribute-values due to event.		Action: Fetch current state.		Action: Fetch entity event-history.		Action: Fetch state at time-T.	Purpose: Forget what happened and why. 	(Reduce short-term memory burden.)		Action: Purge data in category-C prior to time-T.		Action: . . . event records . . .		Action: . . . entity values . . .%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Shown to clarify separation of responsibility)======================Role: Accountant.   	Purpose: Maintain monetary accounts.   		(Traditional accounting functions go here.)		* Costing: Assign costs to resources.		* Pricing: Assign prices to products.		* Ledger: Categorize expenses, revenues, assets, liabilities, cash-flows.		* Accounts: Track counter-party obligations.		* Receivables: Track customer obligations.	(Send invoices and statements to customers.)		* Purchasing: Purchase resources as needed.		* Payables: Track supplier obligations.	(Pay suppliers for resources delivered.)		* Taxables: Track tax authority obligations.		* Banking: Track actual receipts, payments, balances.Role: Relations. 	Purpose: Track who-we-know and why. 		Action: Track counter-party roles. 	(customers, suppliers, workers, governments)		Action: Track knowledge/capability.	(knowledge management ???)		Action: Track contracts.   				(promises, pricing, future dates)		Action: Follow-up intent/obligation/claim.		(campaign, promise, agenda, order, claim)		Action: Notify counter-party of relevant events. 		* Coordinator: Operate order-fulfillment plans.		* Dialog: Initiate order-fulfillment plans from sales-orders.		* Dialog: Operate automated correspondence. 	(via post, e-mail, Messenger, . . .)		* Archive: Record correspondence.Role: Archive. (These functions may use the WorldBase but are not implemented there.)	Purpose: Manage enterprise documents / files.		Action: Record correspondence.  		(Correspondence is also Dialog and World-Base Event)		Action: Archive product brochures, catalogs, manuals.  (Products and Documents are World-Base entities)		Action: Manage engineering documents.  	(Versions, reviews, approvals, releases are also World-Base Events)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Run-Time Implementations:	Erlang:		Advantages:			Erlang OTP is a robust and mature actor framework.			==> Hum translates nicely to OTP distributed actors.			==> Hum world-base translates nicely to Erlang databases. (e.g. Riak)			May Enable a large audience for Erlang OTP. 	<<< Open OTP to enterprise audience? <<<		Disadvantages:			Some host limitations.			Different Paradigm ==> Smaller audience.  (But it might be a thought-leader audience.)	JVM ==> Java/Scala/Groovy:		Advantages:			Runs almost everywhere.			Large audience.		Disadvantages:			Immature actor framework. (But I am told Scala OTP is okay.)	ECMAscript / JavaScript:		Advantages:			Runs in web browsers.			Large audience.			Enables a large web-oriented constituency.  	<<< This could be a GAME-CHANGER. <<<<			Includes strong 3D support via webGL.		Disadvantages:			NO MATURE ACTOR FRAMEWORK.			JavaScript frameworks are very diverse and not well documented.			WebGL wrappers are immature. (But that might not be a problem by the time I get to doing 3D.)	'.! !!Hum000RefactoringTests methodsFor: '000 Class Responsibiltiy Collaboration' stamp: 'RichardAlexanderGreen 3/26/2014 14:45'!strategyForSeaside^'TBD -- Currently considering subtyping HumWidgets as WAComponentsSee: WAInputElementContainer for some code examples.See: WAInputGetFunctionalTestSee: WAModelFunctionalTestsee: WAHtml5InputTestsee: '! !!Hum000RefactoringTests methodsFor: '100 Maintain and access frames' stamp: 'RichardAlexanderGreen 2/9/2014 17:20'!test133getFramesInvokingView	"Get views frames and vignettes that invoke a view."	| ontology  viewFrame  vignette resultSet |		"Create an ontology"	ontology := HumOntology new.		"Create a view that invokes another view."	viewFrame := HumFrame4View ontology: ontology viewEntity: 'Party'. 	viewFrame addMarkUp: '!!!! Party'.	viewFrame addMarkUp: ' name: [name]'.	viewFrame addMarkUp: ' address: [pane: Address]'.	ontology storeFrame: viewFrame.		"Create a vignette that invokes a view."	vignette := HumFrame4Vignette ontology: ontology vignetteContext: 'Order Entry' pattern: '* delivered *'.	vignette addVignetteResponse: 'Where do you want it delivered?'.	vignette addVignetteInstruction: 'Ask Address.'.	ontology storeFrame: vignette.		ontology compileAllFrames. "Create indexes."		resultSet := ontology getFramesThatInvokeView: 'Address'.		self assert: ( resultSet size ) equals: 2.	! !!Hum000RefactoringTests methodsFor: '100 Maintain and access frames' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!test132getFramesInvokingAction	"Get the frames that invoke a given action."	| frames ontology goalFrame actionFrame vignetteFrame instruction |	ontology := HumOntology new.	"Actions may be invoked in goal-frames, action-frames, and vignettes."		"Create a goal frame. "	goalFrame := HumFrame4Plan ontology: ontology goal: 'Dishes are clean and dry.'.	goalFrame appendRole: 'Dishwasher' action: 'Clean and dry the dishes.'.	ontology storeFrame: goalFrame.		"Create an action frame."	actionFrame := HumFrame4Action ontology: ontology role: 'Chef' action: 'Boss KP.'.	actionFrame appendInstructionRole: 'Dishwasher' statement: 'Clean and dry the dishes.'.	ontology storeFrame: actionFrame.		"Create a vignette."	vignetteFrame := HumFrame4Vignette ontology: ontology vignetteContext: 'KP' pattern: '* allowance *'.	vignetteFrame addVignetteResponse: 'Okay. I will load the dishwasher.'.	instruction := (HumInstructionLine role: 'Dishwasher' statement: 'Clean and dry the dishes.').	vignetteFrame addVignetteInstruction: instruction.	ontology storeFrame: vignetteFrame.		ontology compileAllFrames. "Compile creates index as a by-product."		frames := ontology getFramesThatInvokeAction: 'Dishwasher: Clean and dry the dishes.'.		self expect: 3 actual: (frames size) description: 'Goal frame, action frame, and vignette all invoke instruction.'.! !!Hum000RefactoringTests methodsFor: '100 Maintain and access frames' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!test121getFrameForGoal	"Get the plan frame that defines a goal."	| planFrame ontology result |		ontology := HumOntology new.	"A plan frame should have a goal and at least two preconditions."		planFrame := HumFrame4Plan  ontology: ontology goal: 'Bake a cake per recipe.'.	planFrame appendPrecondition: 'Oven is preheated per recipe.'.		planFrame appendPrecondition: 'Batter is in bake-pan per recipe.'.	planFrame appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.		ontology storeFrame: planFrame.		result := ontology getPlanFrameForGoal: 'Bake a cake per recipe.'.		self assert: planFrame equals: result.! !!Hum000RefactoringTests methodsFor: '100 Maintain and access frames' stamp: 'RichardAlexanderGreen 2/12/2014 11:12'!test135getFramesInvokingContext	"Get vignettes that define a context."	| ontology  vignetteA vignetteB resultSet |		"Create an ontology"	ontology := HumOntology new.			"Create a vignette that defines part of a context."	vignetteA := HumFrame4Vignette ontology: ontology vignetteContext: 'Order-Entry' pattern: '* delivered *'.	vignetteA addVignetteResponse: 'Where do you want it delivered?'.	vignetteA addVignetteInstruction: 'Ask Address.'.	ontology storeFrame: vignetteA.		"Create another vignette in the same context."	vignetteB := HumFrame4Vignette ontology: ontology vignetteContext: 'Order-Entry' pattern: '* pick up *'.	vignetteB addVignetteResponse: 'When do you expect to pick up?'.	vignetteB addVignetteInstruction: 'Push context pick-up-time.'.	ontology storeFrame: vignetteB.		ontology compileAllFrames. "Create indexes."	"Test: Make this not case-sensitive."	resultSet := ontology getFramesThatInvokeContext: 'pick-up-time'.		self assert: ( resultSet size ) equals: 1.	! !!Hum000RefactoringTests methodsFor: '100 Maintain and access frames' stamp: 'RichardAlexanderGreen 2/12/2014 10:15'!test134getFramesDefiningContext	"Get vignettes that define a context."	| ontology  vignetteA vignetteB resultSet |		"Create an ontology"	ontology := HumOntology new.			"Create a vignette that defines part of a context."	vignetteA := HumFrame4Vignette ontology: ontology vignetteContext: 'Order-Entry' pattern: '* delivered *'.	vignetteA addVignetteResponse: 'Where do you want it delivered?'.	vignetteA addVignetteInstruction: 'Ask Address.'.	ontology storeFrame: vignetteA.		"Create another vignette in the same context."	vignetteB := HumFrame4Vignette ontology: ontology vignetteContext: 'Order-Entry' pattern: '* pick up *'.	vignetteB addVignetteResponse: 'When do you expect to pick up?'.	vignetteB addVignetteInstruction: 'Push context pick-up-time.'.	ontology storeFrame: vignetteB.		ontology compileAllFrames. "Create indexes."	"Test: Make this not case-sensitive."	resultSet := ontology getFramesThatDefineContext: 'order-entry'.		self assert: ( resultSet size ) equals: 2.	! !!Hum000RefactoringTests methodsFor: '100 Maintain and access frames' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!test131getFramesInvokingPrecondition	"Get the goal frames that invoke a given precondition."	| frames ontology planFrameA planFrameB |	ontology := HumOntology new.		planFrameA := HumFrame4Plan  ontology: ontology goal: 'Bake a cake per recipe.'.	planFrameA appendPrecondition: 'Oven is preheated per recipe.'.		planFrameA appendPrecondition: 'Batter is prepared per recipe.'.   "Redundant. See below."	planFrameA appendPrecondition: 'Batter is in bake-pan per recipe.'.	planFrameA appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.	ontology storeFrame: planFrameA.		planFrameB := HumFrame4Plan ontology: ontology goal: 'Batter is in bake-pan per recipe.'.	planFrameB appendPrecondition: 'Batter is prepared per recipe.'.	planFrameB appendPrecondition: 'Cake-pan is prepared per recipe.'.   "Is it greased?"	planFrameB appendRole: 'Mixer' action: 'Pour batter into cake-pan.'.	ontology storeFrame: planFrameB.		ontology compileAllFrames. "Compile creates index as a by-product."		frames := ontology getFramesThatInvokePrecondition: 'Batter is prepared per recipe.'.			self assert: (frames size) equals: 2.! !!Hum000RefactoringTests methodsFor: '100 Maintain and access frames' stamp: 'RichardAlexanderGreen 2/5/2014 15:57'!test123getFrameForView	"Get frame where view is defined."	| frame result ontology |	ontology := HumOntology new.	frame := HumFrame4View ontology: ontology viewEntity: 'Street-Address'.	self assert: (frame isKindOf: HumFrame4View ).		frame addMarkUp: '!! This is a 1sd level title.'.	frame addMarkUp: '!!!! This is a 2nd level title.'.	frame addMarkUp: '!!!!!! This is a 3rd level title.'.		ontology storeFrame: frame.		result := ontology getViewFrame: 'Street-Address'.		self assert: frame equals: result.	! !!Hum000RefactoringTests methodsFor: '100 Maintain and access frames' stamp: 'RichardAlexanderGreen 3/17/2015 12:07'!test122getFrameForAction	"Get frame where action statement is defined."	| ontology frameUpdater result |		ontology := HumOntology new.		"Initialize for an Action Frame."	frameUpdater := HumFrameUpdater ontology: ontology  	                                   role: 'Baker' 	                                 action: 'Bake the pan in the oven for the time given in the recipe.'.	frameUpdater appendInstructionStatement: 'Open the oven door.'.	frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.	frameUpdater appendInstructionStatement: 'Close the oven door.'.	frameUpdater appendInstructionRole: 'Oven' 	                     statement: 'Bake for the baking-time given in the recipe.' 	                       comment: 'We have a smart oven.'.		ontology storeFrame: ( frameUpdater frame ).		result := ontology getFrameForRole: 'Baker' action: 'Bake the pan in the oven for the time given in the recipe.'.		self expect: ( frameUpdater frame ) actual: result.! !!Hum000RefactoringTests methodsFor: '100 Maintain and access frames' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!test110addFrame	"Add frame to ontology"	| planFrame ontology |		ontology := HumOntology new.	"A plan frame should have a goal and at least two preconditions."		planFrame := HumFrame4Plan  ontology: ontology goal: 'Bake a cake per recipe'.	planFrame appendPrecondition: 'Oven is preheated per recipe.'.		planFrame appendPrecondition: 'Batter is in bake-pan per recipe.'.	planFrame appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.		ontology storeFrame: planFrame.		self assert: (ontology frames size) = 1.		self assert: (ontology framesByIdentifier size) = 1.		self assert: (ontology framesByName size) = 1.! !!Hum000RefactoringTests methodsFor: '200 View Ontology' stamp: 'RichardAlexanderGreen 2/28/2014 11:06'!test211prettyPrintOntologyAsHTMLonFile	"Pretty print the given ontology on an HTML file."	| html ontology |	ontology := self givenOntology.	"Call via a OntologyViewer instance."	html := ontology view renderAsHTMLonFileNamed: 'test211.html'.	! !!Hum000RefactoringTests methodsFor: '200 View Ontology' stamp: 'RichardAlexanderGreen 4/20/2015 08:19'!test230renderEmphasisAsHTML	"Render emphasis in the markup as underscore, italic, bold. 	  'Do _not_ forget to ~preheat~ the *oven*.''	"	| html ontology frameUpdater |	ontology := HumOntology new.		"Create a View Frame."	frameUpdater := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.	frameUpdater addMarkUp: '!!!! Heading 2'.	frameUpdater addMarkUp: '- List1'.	frameUpdater addMarkUp: '-- List2'.	frameUpdater addMarkUp: '  Do _not_ forget to ~preheat~ the *oven*.'.  "Test emphasis."	ontology storeFrame: ( frameUpdater frame ).		"Frames must be compiled if nouns are to be marked."	ontology compileAllFrames.	"Call via a OntologyViewer instance."	html := ontology view renderAsHTMLonFileNamed: 'test230.html'.	"Expect _not_ to become <u>not</u> "	self assert: ('*<u>not</u>*' match: html).	"Expect ~preheat~ to become <i>preheat</i> "	self assert: ('*<i>preheat</i>*' match: html).	"Expect *oven* to become <b>oven</b> "	"Note: Might also see noun <n> tags."	self assert: ('*<b>*oven*</b>*' match: html).		! !!Hum000RefactoringTests methodsFor: '200 View Ontology' stamp: 'RichardAlexanderGreen 3/17/2015 13:00'!givenOntology	| ontology planFrame1 planFrame2 planFrame3 frameUpdater |		ontology := HumOntology new.	ontology title: 'givenOntology'.			planFrame1 := HumFrame4Plan ontology: ontology goal: 'Bake a cake per recipe.'.	planFrame1 appendPrecondition: 'Oven is preheated per recipe.'.		planFrame1 appendPrecondition: 'Batter is in bake-pan per recipe.'.	planFrame1 appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.	ontology storeFrame: planFrame1.			planFrame2 := HumFrame4Plan ontology: ontology goal: 'Oven is preheated per recipe.'.	planFrame2 appendPrecondition: 'Oven is cleared out.'.	planFrame2 appendPrecondition: 'Oven is on.'.	planFrame2 appendPrecondition: 'Oven temperature is set per recipe.'.	planFrame2 appendRole: 'Timer' action: 'Wait 5 minutes.'.	ontology storeFrame: planFrame2.		planFrame3 := HumFrame4Plan ontology: ontology goal: 'Batter is in bake-pan per recipe.'.	planFrame3 appendPrecondition: 'Batter fully mixed per recipe.'.	planFrame3 appendPrecondition: 'Bake-pan is greased per recipe.'.	planFrame3 appendRole: 'Baker' action: 'Pour batter into bake-pan per recipe.'.	ontology storeFrame: planFrame3.		"Create an Action Frame."	frameUpdater := HumFrameUpdater ontology: ontology  	                                   role: 'baker' 																	action: 'Bake the pan in the oven for the time given in the recipe.'.	frameUpdater appendInstructionStatement: 'Open the oven door.'.	frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.	frameUpdater appendInstructionStatement: 'Close the oven door.'.	frameUpdater appendInstructionRole: 'Oven' statement: 'Bake for the baking-time given in the recipe.' comment: 'We have a smart oven.'.		ontology storeFrame: ( frameUpdater frame ).		"Create a Dictionary Frame."	frameUpdater := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.	frameUpdater addDictionaryLine: 'Recipe attributes include recipe-name, description, ingredients, steps.'.	frameUpdater addDictionaryLine: 'Recipe includes a list of ingredients.'.	frameUpdater addDictionaryLine: 'Recipe includes a list of steps.'.	frameUpdater addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.	frameUpdater addDictionaryLine: 'Step attributes include step-number, step-description'.	frameUpdater addDictionaryLine: 'Bakery attributes include oven, mixer, counter.'.	frameUpdater addDictionaryLine: 'Recipe attributes include baking-time.'.	ontology storeFrame: ( frameUpdater frame ).	"Create a View Frame."	frameUpdater := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.	frameUpdater addMarkUp: '!!!! Recipe'.	frameUpdater addMarkUp: ' recipe-name: [name]'.	frameUpdater addMarkUp: '   description: [description 5]'.	frameUpdater addMarkUp: '   ingredients: [ingredients]'.	frameUpdater addMarkUp: '  Do _not_ forget to ~preheat~ the *oven*.'.  "Test emphasis."	frameUpdater addMarkUp: '            steps: [steps]'.	ontology storeFrame: ( frameUpdater frame ).		"Frames must be compiled if nouns are to be marked."	ontology compileAllFrames.		^ontology! !!Hum000RefactoringTests methodsFor: '200 View Ontology' stamp: 'RichardAlexanderGreen 4/20/2015 08:19'!test220renderCollectionAsHtmlTable	"A plural noun indicates a collection.	When a view contains a plural attribute: '[ingredients]' ... '[steps]',	it should be rendered as a table of ingredients.	"	| html ontology |	ontology := self givenOntology.	"Call via a OntologyViewer instance."	html := ontology view asHTML5.	"Should see two tables"	self assert: ( '*<table*</table>*<table*</table>*' match: html ).	"Should see attributes of steps."	self assert: ( '*<th>*step-*</th>*' match: html ).	"Should see attributes of ingredients."	self assert: ( '*<th>*ingredient-name*</th>*' match: html ).	"html inspect."	! !!Hum000RefactoringTests methodsFor: '200 View Ontology' stamp: 'RichardAlexanderGreen 4/20/2015 08:12'!test221renderCollectionAsHtmlTableOnFile	"A plural noun indicates a collection.	When a view contains a plural attribute: '[ingredients]' ... '[steps]',	it should be rendered as a table of ingredients.	"	| html ontology |	ontology := self givenOntology.	"Call via a OntologyViewer instance."	html := ontology view renderAsHTMLonFileNamed: 'test221.html'.	"Should see two tables"	self assert: ( '*<table*</table>*<table*</table>*' match: html ).	"Should see attributes of steps."	self assert: ( '*<th>*step-*</th>*' match: html ).	"Should see attributes of ingredients."	self assert: ( '*<th>*ingredient-name*</th>*' match: html ).		! !!Hum000RefactoringTests methodsFor: '200 View Ontology' stamp: 'RichardAlexanderGreen 2/12/2014 12:01'!test210prettyPrintOntologyAsHTML	"Refactor so that this function is view OntologyViewer"	| html ontology |	ontology := self givenOntology.	"Call via a OntologyViewer instance."	html := ontology view asHTML5.	! !HumTestCase subclass: #HumByteCodeTests	instanceVariableNames: 'humVM'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-Tests'!!HumByteCodeTests commentStamp: 'RichardAlexanderGreen 7/26/2012 12:02' prior: 0!After a bit of experimentation with these tests, I have decided that the HumVM is not a worthwhile feature.Basically, the code and effort required to load the slots will overwhelm any savings in code space by compressing to byte code.I had also thought that byte code would simplify translation to multiple languages, but I don't see that working out either.'!!HumByteCodeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 9/20/2012 07:37'!test110EachInstructionHasTwoBytes	"A Hum byte code instruction has two bytes -- one for operation and one for operand."	| instruction |	instruction := HumVMInstruction new.	instruction operation: 255.	instruction operand: 254.	self assert: 255 equals: ( instruction operation).	self assert: 254 equals: ( instruction operand).	! !!HumByteCodeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 9/20/2012 07:37'!test130Operand000IsNone	"An operand index of zero is treated as None.	(For some operators, this will be nonsence and should not compile.)"	| instruction |	instruction := HumVMInstruction opCode: 000 value: 000.	self assert: 'None' equals: instruction slotName. ! !!HumByteCodeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 6/20/2013 09:40'!test220MeasureAdd	"Add measure into measure-arithmetic register."	| instruction measureA measureB measureC |		"First load a measure into the register."	measureA := HumMeasure quantity: 220 units: 'meter'.	humVM setSlot: 001 to: measureA.	instruction := HumVMInstruction opCode: 001 value: 001.	humVM runInstruction: instruction.	self assert: ( humVM measureRegister ) equals: measureA.		"Add another measure into the register."	measureB := HumMeasure quantity: 330 units: 'meter'.	humVM setSlot: 002 to: measureB.	instruction := HumVMInstruction opCode: 002 value: 002.	humVM runInstruction: instruction.		measureC := HumMeasure quantity: 550 units: 'meter'.	self assert: ( humVM measureRegister ) equals: measureC.	! !!HumByteCodeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 9/20/2012 07:37'!test120OpCode000IsHalt	"An opCode of 000 is a halt instruction. (operand is ignored)"	| instruction |	instruction := HumVMInstruction opCode: 000 value: 000.	self assert: 'Halt' equals: ( instruction opCodeName ).! !!HumByteCodeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 6/20/2013 09:40'!test230MeasureMinus	"Add measure into measure-arithmetic register."	| instructionA instructionB measureA measureB measureC |		"First load a measure into the register."	measureA := HumMeasure quantity: 330 units: 'meter'.	humVM setSlot: 001 to: measureA.	instructionA := HumVMInstruction opCode: 001 value: 001.	humVM runInstruction: instructionA.	self assert: ( humVM measureRegister ) equals: measureA.		"Subtract another measure from the register."	measureB := HumMeasure quantity: 220 units: 'meter'.	humVM setSlot: 002 to: measureB.	instructionB := HumVMInstruction opCode: 003 value: 002.	humVM runInstruction: instructionB.		measureC := HumMeasure quantity: 110 units: 'meter'.	self assert: ( humVM measureRegister ) equals: measureC.	! !!HumByteCodeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 6/20/2013 09:39'!test210MeasureLoad	"Load measure into measure-arithmetic register."	| instruction measure |	measure := (HumMeasure quantity: 210 units: 'meter').	humVM setSlot: 001 to: measure.	instruction := HumVMInstruction opCode: 001 value: 001.	humVM runInstruction: instruction.	self assert: ( humVM measureRegister ) equals: measure.! !!HumByteCodeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 7/26/2012 10:07'!setUp	"For convenience, create a Hum VM instance for all of the tests to use."		humVM := HumVM new.! !