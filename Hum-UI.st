Object subclass: #HumText	instanceVariableNames: 'string lines'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumText commentStamp: 'RichardAlexanderGreen 9/28/2012 13:54' prior: 0!HumText models a text.Text is multi-line and potentially enhanced with color, emphasis, fonts, and font weights.( Also known as "Attributed String" )The immediate intent is to support a code editor and rich text without going "over-board".See: HumTextPrettyToken.*** Note: The current implementation is far from complete. ***Instance Variables:	string	< String >	lines	< OrderedCollection of HumTextLine >!!HumText methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/7/2012 19:46'!addLine: aString 	| newLine tempLines |	self assert: ( aString isKindOf: String ).	newLine := HumTextLine new.	newLine string: aString.	tempLines := self lines.	((tempLines size = 1) and: [( tempLines at: 1) string isEmpty])		ifTrue: [tempLines := OrderedCollection new. ].	tempLines add: newLine.	self lines: tempLines.! !!HumText methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 18:33'!insertEmptyLineAfter: lineIndex 	| currentLines tempLines |	currentLines := self lines.	tempLines := currentLines copyFrom: 1 to: lineIndex.	tempLines add: ( HumTextLine new).	tempLines addAll: ( currentLines copyFrom: ( lineIndex + 1 ) to:  currentLines size ).	lines := tempLines.! !!HumText methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 20:00'!lines	"Return the HumText list of  lines"	lines 		ifNil: [ "initialize the list"			lines := OrderedCollection new. 			lines add: ( HumTextLine new ).			].	^lines. ! !!HumText methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 20:28'!lines: anOrderedCollection 	( anOrderedCollection isKindOf:  OrderedCollection )		ifFalse: [ Error signal: 'Bad value sent to HumText>>lines: _']		ifTrue: [ |firstElement| firstElement := anOrderedCollection at: 1.			(firstElement isKindOf: HumTextLine) 			ifFalse: [ Error signal: 'First line should be a HumTextLine'] 			].	lines := anOrderedCollection! !!HumText methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 17:50'!string	| result |	result := String empty.	( self lines )		do: [ :line |			result := result, line string, String cr.			].	^result.! !Object subclass: #HumTextLine	instanceVariableNames: 'string indentLevel'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumTextLine commentStamp: 'RichardAlexanderGreen 9/28/2012 13:52' prior: 0!A text is assumed have a collection of text-lines.Each text line is assumed to be a collection of tokens.Each token may have attributes that affect how it is rendered.For example, rendering attributes may include emphasis, color, highlight, link, editable.  (ToDo)Emphasis in turn might include isBold, isItalic, isUnderlined, relative height. (ToDo)Note -- Lines might be re-flowed during the rendering if the context permits / requires it.But the source lines in the text remain the same regardless of the rendering.We don't want to surprise the author by changing the source.(There is some conceptual conflict here that I have to resolve.)Instance Variables:	string	<String>	indentLevel	<Integer>!!HumTextLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 20:54'!indentLevel	"The indent level indicates the level of indentation,	  but not the rendering of the indentation."	^ indentLevel ifNil: [ indentLevel := 0 ].! !!HumTextLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 20:53'!indentLevel: aSmallInteger	indentLevel := aSmallInteger.! !!HumTextLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 17:51'!string	string ifNil: [ string := String new. ].	^string.! !!HumTextLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 18:21'!string: aByteString 	string := aByteString! !Object subclass: #HumTextPrettyPrinter	instanceVariableNames: 'startCommentToEndOfLine'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumTextPrettyPrinter commentStamp: 'RichardAlexanderGreen 8/7/2012 19:28' prior: 0!HumTextPrettyPrinter is designed to pretty print a text based upon parameters provided.Parameters include:- string that begins a multi-line comment -- example: '/*' in several notations derived from the C langauge.- string that ends a multi-line comment. -- example: '*/' in several notations.- string that begins a whole-line comment -- example: '#' in several notations.- string that begins a remainder-of-line comment -- example '//' in several notations.- string that begins a compiler directive -- example '@' in Java and other languages.- string of special characters that may be included in names -- example '_' in many languages, '_-' in COBOL.- tokens that represent "keywords" -- exampe 'if', 'else', 'begin', 'end', 'for', 'def', 'class', 'public', 'private'.- balanced pairs -- For example: '(...)', '[...]', '{...}'- string delimiters -- For example: "..." and '...' - string for indentation -- For example: tab or '. '- treatment for keywords -- example: bold, foreground blue- treatment for whole-line comment -- example: italic, background dark green, foreground yellow.- treatment for remainder-of-line comments -- example: italic, foreground green- treatment for multi-line comments -- example: italic, foreground green- treatment for strings -- example: normal, forground cyan- treatment for special characters -- example: bold, forground red- treatment for whole-line comment -- example: italic, background dark green, foreground yellow.!!HumTextPrettyPrinter methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/7/2012 19:54'!addCommentToEndOfLineStartsWith: aString 	| |	self assert: (aString isKindOf:  String).	startCommentToEndOfLine := aString.! !!HumTextPrettyPrinter methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 8/7/2012 20:06'!parse: aHumTextLine 	|  tokens ppTokens |	"delimiters := (' ', startCommentToEndOfLine )."	tokens := ( aHumTextLine string ) substrings. 	ppTokens := OrderedCollection new.	tokens do: [ :token | 		| ppToken |		ppToken := HumTextPrettyToken new.		ppToken string: token.		ppTokens add: ppToken.		].	^ ppTokens.	! !Object subclass: #HumSurface	instanceVariableNames: 'top bottom left right origin width height layer objects id'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumSurface commentStamp: 'RichardAlexanderGreen 1/22/2012 09:51' prior: 0!HumSurface is like a movable canvas.It is also a container which collects other 2D objects which are also HumSurface instances.It has a set of layout methods.Instance Variables:	top	      <Number>	bottom	<Number>	left	      <Number>	right	<Number>	width	<Number>	height	<Number>	layer	<Number>	origin	<HumSurface>	objects	<Set>!!HumSurface methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/14/2012 21:31'!initialize	| zero |	zero := HumMeasure quantity: 0 units: ''.	width := zero.	left := zero.	right := zero.		height := zero.	top := zero.	bottom := zero.		layer := zero.! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:36'!bottom	^ bottom ifNil: [ bottom := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:56'!bottom: aNumber	"Reset the bottom edge."	bottom := self asMeasure: aNumber.	"Force top edge to be bottom + height"	top := bottom + (self height).! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:36'!height	^ height ifNil: [ height := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:56'!height: aNumber.	"Reset the distance between top and bottom edges."	height := self asMeasure: aNumber.	"Force the bottom to be the top minus the height."	bottom := (self top) - height.! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/16/2012 12:31'!id	self assert: ( id isKindOf: String ).	self assert: ( id notEmpty ).	^ id! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2012 13:02'!id: aString 	id := aString.! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:40'!layer	^ layer ifNil: [ layer := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:33'!layer: aNumber	layer := aNumber! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:35'!left	^ left ifNil: [ left := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:57'!left: aNumber	| measure |	measure := self asMeasure: aNumber.	"Rest the left edge."	left := measure.	"Force the right edge to keep width constant."	right := left + (self width).! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 14:26'!objects	"I remember the 2d objects placed on me."	^ objects ifNil: [ objects := Set new. ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:45'!origin	"origin is a zero-size object positioned at (0 0 0 )"		^ origin ifNil: [ origin := HumSurface new.  ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:35'!right	^ right ifNil: [ right := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:57'!right: aNumber		"Reset the right edge."	right := self asMeasure: aNumber.	"Force the left edge to keep the width constant."	left := right - (self width).! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:36'!top	^ top ifNil: [ top := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:58'!top: aNumber	"Reset the top edge."	top := self asMeasure: aNumber.	"Force the bottom edge to keep the height constant."	bottom := top - (self height).! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:32'!width	^ width! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:58'!width: aNumber	"Reset the width."	width := self asMeasure: aNumber.	"Force the right edge to be consistent."	right := (self left) + width.! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 1/20/2012 14:36'!overlay: aHumSurfaceB onTopOf: aHumSurfaceA 	"Both objects are assumed (forced) to be present in my collection."	( self objects ) add: aHumSurfaceA.	( self objects ) add: aHumSurfaceB.	"By convention, surface B will be aligned with A's top and left edges."	aHumSurfaceB top: (aHumSurfaceA top).		aHumSurfaceB left: (aHumSurfaceA left).	"By convention, surface B will be placed in a higher numbered layer."	"Note: If there already was already another object on top and in same layer, 	   there is no attempt to place this one in-between."	aHumSurfaceB layer: (aHumSurfaceA layer) + 1.	! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 1/20/2012 14:53'!place: aHumSurfaceB above: aHumSurfaceA 	"Place B above A on the surface. (Not to be confused with putting B on a different layer.)"		"Assure that A and B are in my collection."	(self objects) add: aHumSurfaceA.	(self objects) add: aHumSurfaceB.		"By convention, set B's bottom will be equal to A's top."	aHumSurfaceB bottom: ( aHumSurfaceA top ).		"By convention, B is now in the same layer as A."	aHumSurfaceB layer: ( aHumSurfaceA layer ).		! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 1/20/2012 14:23'!place: aHumSurface at: anArray 	| x y z |	x := anArray at: 1.	y := anArray at: 2.	z := anArray at: 3.		( self objects ) add: aHumSurface.	aHumSurface top: y; left: x; layer: z.! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 1/20/2012 14:53'!place: aHumSurfaceB below: aHumSurfaceA 	"Place B below A on the surface. (Not to be confused with putting B on a different  layer.)"		"Assure that A and B are in my collection."	(self objects) add: aHumSurfaceA.	(self objects) add: aHumSurfaceB.		"By convention, set B's top to be equal to A's bottom."	aHumSurfaceB top: ( aHumSurfaceA bottom ).		"By convention, B is now in the same layer as A."	aHumSurfaceB layer: ( aHumSurfaceA layer ).		! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 1/20/2012 14:55'!place: aHumSurfaceB leftOf: aHumSurfaceA 	"Place B left of A on the surface. "		"Assure that A and B are in my collection."	(self objects) add: aHumSurfaceA.	(self objects) add: aHumSurfaceB.		"By convention, set B's left to be equal to A's right."	aHumSurfaceB left: ( aHumSurfaceA right ).		"By convention, B is now in the same layer as A."	aHumSurfaceB layer: ( aHumSurfaceA layer ).		! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 3/7/2012 21:15'!place: aHumSurfaceB rightOf: aHumSurfaceA 	"Place B right of A on the surface. "		"Assure that A and B are in my collection."	(self objects) add: aHumSurfaceA.	(self objects) add: aHumSurfaceB.		"By convention, set B's right to be equal to A's left."	aHumSurfaceB left: ( aHumSurfaceA right ).		"By convention, B is now in the same layer as A."	aHumSurfaceB layer: ( aHumSurfaceA layer ).		! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/30/2012 14:04'!asHTML	" Render surface as HTML"	| myBlock html calc |	calc := HumCalculator new.		myBlock := [ self asHtmlCanvasOffsetX: (self left) y: (self top) ].	html := calc xml: 'html' 				with: [ (calc xml: 'head' 					            with: [ calc xml: 'title' 						                         with: ['Surface as HTML' ]						                ]),					      (calc xml: 'body'					              with: [ myBlock value ])					    ].					^html.! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/30/2012 13:48'!asHtmlCanvasOffsetX: offsetX y: offsetY	"Return a HTML <rect . . . /> element for this surface."	| xml canvasAttributes nextLayer viewX viewY calc |	xml := String new.	canvasAttributes := OrderedCollection new.	( id notNil ) ifTrue: [ canvasAttributes add: 'id' -> id ].		"Don't scale dimensions in this version"	canvasAttributes add: 'width' -> width asString.	canvasAttributes add: 'height' -> height asString.	viewX := left + offsetX.	viewY := top + offsetY.		canvasAttributes add: 'x' -> viewX asString.	canvasAttributes add: 'y' -> viewY negated asString.  "Flip our Y value because HTML has Y pointing down."		canvasAttributes add: 'style' -> 'border:3px solid black;'.	calc := HumCalculator new.	xml := '  ', ( calc xml: 'canvas' attributes: canvasAttributes ), String cr  .		nextLayer := ''.	(self objects )		do: [ :object | 			nextLayer := nextLayer, (object asHtmlCanvasOffsetX: viewX y: viewY).			].	xml := xml, nextLayer.	^xml. 		! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 3/16/2012 12:52'!asHumScript	| script space period |	space := ' '.	period := '.'.	script := '. Painter: '.	script := script, 'Paint surface with '.	script := script, space, 'id', space, (self id) quoted.	script := script, space, 'width', space, (self width) asString quoted.	script := script, space, 'height', space, (self height) asString quoted.	script := script, space, 'left', space, (self left) asString quoted.	script := script, space, 'top', space, (self top) asString quoted.		script := script, period.		( self objects )		do: [ :each | script := script, String cr, (each asHumScript ) ].		^script.! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 3/14/2012 21:29'!asMeasure: anObject	| measure |	( anObject isKindOf: HumMeasure )		ifTrue: [ measure := anObject ].	( anObject isKindOf: String ) 		ifTrue: [ measure := HumMeasure fromString: anObject ].	( anObject isKindOf: Number )		ifTrue: [ measure := HumMeasure quantity: anObject units: '' ].	self assert: ( measure isKindOf: HumMeasure ).	^measure! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/30/2012 13:50'!asSVG	| myBlock svg calc |		myBlock := [ self asSvgRectOffsetX: (self left) y: (self top) ].	calc := HumCalculator new.	svg := calc xml: 'svg' attributes: ( HumSurface svgAttributes ) with: myBlock.		^svg.! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/30/2012 13:48'!asSvgRect	"Return a SVG <rect . . . /> element for this surface."	| xml rectAttributes nextLayer calc |	self deprecated.	xml := String new.	rectAttributes := OrderedCollection new.	( id notNil ) ifTrue: [ rectAttributes add: 'id' -> id ].		"TODO: determine what scale and transpose should be applied to this surface's rectangle."	rectAttributes add: 'width' -> width asString.	rectAttributes add: 'height' -> height asString.	calc := HumCalculator new.	xml := calc xml: 'rect' attributes: rectAttributes .		nextLayer := ''.	(self objects )		do: [ :object | 			nextLayer := nextLayer, object asSvgRect.			].	xml := xml, nextLayer.	^xml. 		! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/30/2012 13:49'!asSvgRectOffsetX: offsetX y: offsetY	"Return a SVG <rect . . . /> element for this surface."	| xml rectAttributes nextLayer viewX viewY calc |	xml := String new.	rectAttributes := OrderedCollection new.	( id notNil ) ifTrue: [ rectAttributes add: 'id' -> id ].		"Don't scale dimensions in this version"	rectAttributes add: 'width' -> width asString.	rectAttributes add: 'height' -> height asString.	viewX := left + offsetX.	viewY := top + offsetY.		rectAttributes add: 'x' -> viewX asString.	rectAttributes add: 'y' -> viewY negated asString.  "Flip our Y value because SVG has Y pointing down."	calc := HumCalculator new.	xml := calc xml: 'rect' attributes: rectAttributes .		nextLayer := ''.	(self objects )		do: [ :object | 			nextLayer := nextLayer, (object asSvgRectOffsetX: viewX y: viewY).			].	xml := xml, nextLayer.	^xml. 		! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/31/2012 09:40'!asSvgViewBox	| attributes viewBoxAttribute space myBlock svg calc |	"Set up standard attributes for the svg prolog."	calc := HumCalculator new.	space := $   asString.	attributes := OrderedCollection new.	attributes add: 'xmlns' -> 'http://www.w3.org/2000/svg'.	attributes add: 'xmlns:xlink' -> 'http://www.w3.org/1999/xlink'.	attributes add: 'width' -> '100%'.	attributes add: 'height' -> '100%'.		viewBoxAttribute := self left quantity asString, space, self top quantity asString, space, self width quantity asString, space, self height quantity asString.	attributes add: 'viewBox' -> viewBoxAttribute.		myBlock := [ self asSvgRectOffsetX: 0 y: 0.  ].		svg := calc xmlOpen: 'svg' attributes: attributes.	svg := svg, '<g stroke="#001122" stroke-width="0.03" fill="ffeedd" >'.	svg := svg, ( myBlock value).	svg := svg, '</g>'.	svg := svg, '</svg>'.	^svg.! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/30/2012 13:50'!asXML	| myBlock xml calc |		myBlock := [ self asXMLRectOffsetX: (self left) y: (self top) ].	calc := HumCalculator new.	xml := calc xml: 'script' attributes: ( HumSurface humSurfaceAttributes ) with: myBlock.		^xml.! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/30/2012 13:49'!asXMLRectOffsetX: offsetX y: offsetY 	"Return a hum <surface . . . /> element for this surface."	| xml rectAttributes nextLayer viewX viewY calc |	xml := String new.	rectAttributes := OrderedCollection new.	( id notNil ) ifTrue: [ rectAttributes add: 'id' -> id ].		rectAttributes add: 'width' -> width asString.	rectAttributes add: 'height' -> height asString.	viewX := left + offsetX.	viewY := top + offsetY.		rectAttributes add: 'x' -> viewX asString.	rectAttributes add: 'y' -> viewY asString.  	calc := HumCalculator new.	xml := calc xml: 'hum:surface' attributes: rectAttributes .		nextLayer := ''.	(self objects )		do: [ :object | 			nextLayer := nextLayer, (object asXMLRectOffsetX: viewX y: viewY).			].	xml := xml, nextLayer.	^xml. 		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumSurface class	instanceVariableNames: ''!!HumSurface class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/16/2012 11:40'!humAttributes	"Set up standard attributes for the hum UI prolog."	| dict |	dict := OrderedCollection new.	dict add: 'src' -> 'scripts/hum.js'.	dict add: 'defer' -> 'defer'.	^dict.! !!HumSurface class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/16/2012 11:41'!humSurfaceAttributes	"Set up standard attributes for the hum UI prolog."	| dict |	dict := OrderedCollection new.	dict add: 'src' -> 'scripts/humSurface.js'.	dict add: 'defer' -> 'defer'.	^dict.! !!HumSurface class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 11/7/2012 12:44'!svgAttributes	"Will generate default attributes as follows:	<svg 	xmlns='http://www.w3.org/2000/svg' 			xmlns:xlink='http://www.w3.org/1999/xlink' 			width='100%'			height='100%'			>	Note: 100% width and height assumes that the actual size constraint 	will be defined in an enclosing <div . . .> tag.			"	| dict |	"Return default attributes for the svg prolog as a list of associations."	dict := OrderedCollection new.	dict add: 'xmlns' -> 'http://www.w3.org/2000/svg'.	dict add: 'xmlns:xlink' -> 'http://www.w3.org/1999/xlink'.	dict add: 'width' -> '100%'.	dict add: 'height' -> '100%'.	^dict.	! !Object subclass: #HumEditor	instanceVariableNames: 'lineIndex characterIndex text keyboardActions'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumEditor commentStamp: 'RichardAlexanderGreen 8/7/2012 19:38' prior: 0!A HumEditor is attached to HumText.The editor provides the means to modify the text.The editor has a cursortPosition which defines where a cursor might be rendered and where character inserts and deletes may occur.The editor has a 'selection' which defines a part of the text that might be highlighted and processed.---Editor Actions   1. Usual text edit actions:      a) commands: (copy, cut, paste, un-do, save, open, print?, close window)      b) cursor moves: (up, down, left, right, top, bottom, . . .)   2. PA-specific actions:      a) [Line updated] event causes the logical-line and frame to be checked.         (1) The logical-line is rendered. 	           Keywords and nouns are emphasized. Nouns have links.          (2) If the logical-line is not understood (no definition in ontology or DSL),                the line is flagged (with a question-mark).         (3) If a noun lacks an antecedent in the frame, the noun is flagged (color code).      b) [Insert/Append Instruction] - Instructions are indented.         (1) In an action frame,                the automatic indent matches the preceding statement’s indent                unless it was a control statement (ending with a colon).                   And then, the indentation is increased by one.         (2) In plan and dialog frames,                instructions have only one level of indent                because control statements are not allowed in those contexts.         (3) In dialog frames,                the user indicates an instruction by starting the line with dot [tab].---!!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 18:37'!addLine: aString 	"Delegate to HumText instance."	(self text) addLine: aString! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 10:46'!characterIndex	"Character index is equal to the number of charactes to the left of the cursor."	^ characterIndex ifNil: [ characterIndex := 0 ].! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 19:48'!characterIndex: aSmallInteger 	characterIndex := aSmallInteger.	(characterIndex < 0 ) ifTrue: [ characterIndex := 0 ].! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 20:51'!currentLine	| result |	result := ( self lines ) at: ( self lineIndex ).	^result.! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 10:55'!deletePriorCharacter	"Insert a character into the text at the current (cursor) position"	| humTextLine currentLine stringUpto stringAfter newLine currentIndex  |	"If cursor is at the front of the line, delete is a no op."	currentIndex := (self characterIndex).	( currentIndex = 0 ) ifTrue: [ Beeper beep. ^self ].	"Otherwise . . ."	humTextLine := (self lines) at: (self lineIndex).	currentLine := humTextLine string.	( currentIndex >= currentLine size )		ifFalse: [	stringUpto := currentLine copyFrom: 1 to: (currentIndex - 1).					stringAfter := currentLine copyFrom: (currentIndex+1) to: (currentLine size).					]		ifTrue: [ 	stringUpto := currentLine copyFrom: 1 to: (currentLine size - 1).			       	stringAfter := ''. 					].		newLine := stringUpto,  stringAfter.	humTextLine string: newLine.	"(self lines) at: (self lineIndex) put: humTextLine."	"Advance the cursor."	self characterIndex: currentIndex - 1.	! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 10:49'!insertCharacter: aCharacter 	"Insert a character into the text at the current (cursor) position"	| humTextLine currentLine currentIndex stringUpto stringAfter newLine |	humTextLine := (self lines) at: (self lineIndex).	currentLine := humTextLine string.	currentIndex := self characterIndex.	( currentIndex >= currentLine size )		ifFalse: [	stringUpto := currentLine copyFrom: 1 to: currentIndex.					stringAfter := currentLine copyFrom: ( currentIndex +1 ) to: (currentLine size).					]		ifTrue: [ 	stringUpto := currentLine copy.			       	stringAfter := ''. 					].		newLine := stringUpto, (aCharacter asString), stringAfter.	humTextLine string: newLine.	"(self lines) at: (self lineIndex) put: humTextLine."	"Advance the cursor."	self characterIndex: (self characterIndex + 1).	! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 10:51'!insertLine	"Delegate to our HumText instance"	self text insertEmptyLineAfter: (self lineIndex).	"Adjust the cursor to point to the beginning of the new line."	lineIndex := lineIndex + 1.	characterIndex := 0.			! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 10:08'!lineIndex	^ lineIndex ifNil: [ lineIndex := 1 ].! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 20:32'!lineIndex: aSmallInteger 	| maxLine |	lineIndex := aSmallInteger.	maxLine := ((self text ) lines size).	( lineIndex >  maxLine ) ifTrue: [ lineIndex := maxLine].	( lineIndex < 1 ) ifTrue: [ lineIndex := 1 ].! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 10:36'!lines	^ self text lines.! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 17:42'!text	^ text ifNil: [ text := HumText new ].! !!HumEditor methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 7/31/2012 20:48'!interpretKey: aSymbol 	"Interpret various keyboard gestures."	| action |	keyboardActions ifNil: ["initialize"		keyboardActions := Dictionary  new.		keyboardActions			"Simple arrow keys"			at: #arrowUp put: [ self lineIndex: ( (self lineIndex) - 1) ];			at: #arrowDown put: [ self lineIndex: ( (self lineIndex) + 1 ) ];			at: #arrowLeft put: [ self characterIndex: ( (self characterIndex ) - 1) ];			at: #arrowRight put: [ self characterIndex: ( (self characterIndex ) + 1) ];						"Alt-Arrow keys"			at: #altArrowUp put: [ self lineIndex: 1];			at: #altArrowDown put: [ self lineIndex: ( self lines size ). 				                                   self characterIndex:  (self currentLine string size) ];			at: #altArrowLeft put: [ self characterIndex: 0 ];			at: #altArrowRight put: [ self characterIndex: (self currentLine string size) ];						"Escape key is a no-op at this time."			at: #escape put: [ Beeper beep ].		 ].	"Interpret the symbol (keyboard action name) given"	action := keyboardActions at: aSymbol 						ifAbsent: [ Error signal: 'No action for: ', (aSymbol asString)].	action value.	! !HumSurface subclass: #HumView	instanceVariableNames: 'entityID aHumBlackboard blackboard'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumView methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/24/2013 10:14'!blackboard	^ blackboard ifNil: [ Error signal: 'HumView blackboard accessed but no blackboard has been assigned.'].! !!HumView methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/24/2013 10:12'!blackboard: aHumBlackBoard	self assert: ( aHumBlackboard isKindOf: HumBlackBoard ).	blackboard := aHumBlackBoard.! !!HumView methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/24/2013 10:04'!checkRenderOn: html	html form with: [ 		html break. html heading level: 2; with: ' Recipe'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: entityID attribute: #name toValue: datum ]; name: 'name'; value: 'name'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: entityID attribute: #description toValue: datum ]; name: 'description'; value: 'description'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: entityID attribute: #ingredients toValue: datum ]; name: 'ingredients'; value: 'ingredients'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: entityID attribute: #steps toValue: datum ]; name: 'steps'; value: 'steps'.		]! !Object subclass: #HumTextPrettyToken	instanceVariableNames: 'foregroundColor backgroundColor isBold isItalic isUnderlined fontFamily fontSize string'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumTextPrettyToken commentStamp: 'RichardAlexanderGreen 9/25/2012 19:45' prior: 0!HumTextPrettyToken is a string that may be enhanced with color, emphasis, fonts, and font weightswhen it is "pretty printed".See also: HumTextPrettyPrinter.	foregroundColor 	backgroundColor 	isBold 	isItalic 	isUnderlined 	fontFamily 	fontSize!!HumTextPrettyToken methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/7/2012 20:08'!string		^ string ifNil: [ string := String new. ].! !!HumTextPrettyToken methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/7/2012 20:07'!string: aString 	self assert: ( aString isKindOf: String ).	string := aString.! !HumSurface subclass: #HumPane	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!HumPane subclass: #HumDiagram	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2012 13:57'!addConnection: anAssociation	"anAssociation := ( fromNode -> toNode )"	self assert: ( anAssociation isKindOf: Association ).	self connections add: anAssociation.! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2012 14:38'!addNode: anObject	"anObject should have a title selector"	self assert: (anObject class selectors includes: #title ).	self nodes add: anObject.! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2012 13:54'!connections	^ connections ifNil: [ connections := Set new. ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2012 16:44'!getPositionForNode: aNodeObject	^ self nodePositions at: aNodeObject ifAbsent: [ ^nil ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2012 16:42'!nodePositions	^ nodePositions ifNil: [ nodePositions := Dictionary new. ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2012 13:54'!nodes	^ nodes ifNil: [ nodes := Set new. ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2012 16:42'!setNode: aNodeObject position: aPosition	"Node should also be in nodes collection for internal consistency."	self addNode: aNodeObject.	self nodePositions at: aNodeObject  put: aPosition.! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/10/2012 13:01'!title	^ title ifNil: [ title := '** Diagram has no title!! **'].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/10/2012 13:02'!title: aString	title := aString.	! !!HumDiagram methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 9/14/2012 17:38'!onHtmlCanvas: html width: aWidth height: aHeight 	"Render this diagram on the given Seaside canvas.	Note: We use SVG.	"	|  |	self assert: ( html isKindOf: WACanvas ).	html div 		class: 'diagram'; 		id: (self title asCamelCase);		with: ["Label and Diagram"			html strong: self title.			html break.			"Eventually, we want to draw the diagram using SVG."			( html tag: 'svg' ) 				attributeAt: 'width' put: (aWidth asString);     				attributeAt: 'height' put: (aHeight asString);				attributeAt: 'viewBox' put: '0 0 1000 1000';				attributeAt: 'style' put: 'background: CYAN';				"FOLLOWING IS A STUB -- EVENTUALLY THIS WILL DRAW NODES AND CONNECTIONS"				with: ["SVG path element"					( html tag: 'path' )						attributeAt: 'd' put: 'M 100 100  q 0,100 100,100 ';						attributeAt: 'fill' put: 'none';						attributeAt: 'stroke' put: 'red';						attributeAt: 'stroke-width' put: '1'.					  ( html tag: 'text' ) 						attributeAt: 'x' put: 200;						attributeAt: 'y' put: 200;						attributeAt: 'font-size' put: 20;						attributeAt: 'fill' put: 'BLUE';						with: 'This is just a test of the SVG text rendering.'					].			].! !HumPane subclass: #HumMenu	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!Object subclass: #HumBox	instanceVariableNames: 'length width height topEdge bottomEdge eastEdge westEdge northEdge southEdge origin objects'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumBox commentStamp: 'RichardAlexanderGreen 3/7/2012 21:48' prior: 0!Use this class to model static 3D box-like objects such as rooms, walls, doors, and windows.Although the term Box might might not work well with rooms, doors, and windows.you can think of those things as boxes that happen to be hollow or filled with air.The coordinate system is geographic and rectilinear.Any unit of measure may be used. 
You may use meters, feet, cm, mmwhatever you feel comfortable with 
and suits the domain you are modeling.Box-like objects may be positioned adjacent to each other.Instance Variables:	length	<Number>	width	<Number>	height	<Number>	"By convention length is North-to-South, width is East-to-West, and height is Top-to-Bottom."	topEdge	<Number>	bottomEdge	<Number>	eastEdge	<Number>	westEdge	<Number>	northEdge	<Number>	southEdge	<Number>	origin	<HumBox>	objects	<Set>              -- I am a container. I may contain (and layout) other HumBox objects.!!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!bottomEdge	^ bottomEdge! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 14:00'!bottomEdge: aNumber	self assert: (aNumber isKindOf: Number ).	"Reset the bottom edge"	bottomEdge := aNumber.	"Force the top "	topEdge := bottomEdge + height.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!eastEdge	^ eastEdge! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 14:00'!eastEdge: aNumber	self assert: (aNumber isKindOf: Number ).	"Reset the East edge."	eastEdge := aNumber.	"Force the West edge."	westEdge := eastEdge - width.	! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:37'!height	"Get the height. By convention, height runs up and down."	^ height! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:57'!height: aNumber	"Reset the height. By convention, height runs up and down."	self assert: (aNumber isKindOf: Number ).	self assert: (aNumber >= 0 ).	height := aNumber.	"Hold botton steady and force the top."	topEdge := bottomEdge + height.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:35'!length	"Get the length. By convention, length runs North and South."	^ length! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:57'!length: aNumber	"Reset the length. By convention, length runs North and South."	self assert: (aNumber isKindOf: Number ).	self assert: (aNumber >= 0 ).	length := aNumber.	"Hold South steady and force the North."	northEdge := southEdge + length.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!northEdge	^ northEdge! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:59'!northEdge: aNumber	self assert: (aNumber isKindOf: Number ).	"Reset North edge."	northEdge := aNumber.	"Hold North steady and force South."	southEdge := northEdge - length.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 14:26'!objects	"This set includes objects which move when I do.  	(In this sense, I am a container.)	Note: Coordinates are relative to parent containers.	Therefore, there is no need to correct child coordinates when the parent container is moved.	(The 'root' container is probably a scene graph and will not be moved.)	Note: 	Selectors 'advance: aBox by: #( x y z )' and 'center: aBox at: #( x y z)' and 'position ...'
           will add boxes to the container.	However, selectors that reset edge coordinates operate assume no container.	"	^ objects ifNil: [ objects := Set new. ].! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:32'!origin	"Origin is always a zero-sized object at (0 0 0)."	^ origin ifNil: [ origin := HumBox new.  ].! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!southEdge	^ southEdge! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:59'!southEdge: aNumber	self assert: (aNumber isKindOf: Number ).	"Reset the South edge."	southEdge := aNumber.	"Force North edge."	northEdge := southEdge + length.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!topEdge	^ topEdge! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:59'!topEdge: aNumber	self assert: (aNumber isKindOf: Number ).	"Reset the top edge."	topEdge := aNumber.	"Force the bottom edge."	bottomEdge := topEdge - height.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!westEdge	^ westEdge! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:59'!westEdge: aNumber	self assert: (aNumber isKindOf: Number ).	"Reset the West edge."	westEdge := aNumber.	"Force the East edge."	eastEdge := westEdge + width.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:33'!width	"Get the width. By convention, the width runs East and West."	^ width! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:58'!width: aNumber	"Reset the width. By convention, the width runs East and West."	self assert: (aNumber isKindOf: Number ).	self assert: (aNumber >= 0 ).	width := aNumber.	"Hold West edge steady and force the East edge."	eastEdge := westEdge + width.! !!HumBox methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/31/2012 13:37'!initialize	"Set dimensions to zero."	"By convention length is North-South, width is East-West, and height is top-bottom."	length := 0.	width := 0.	height := 0.		"Position edges at zero."	bottomEdge := 0.	topEdge := 0.	eastEdge := 0.	westEdge := 0.	northEdge := 0.	southEdge := 0.! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 1/31/2012 14:02'!advance: aBox by: anArray 	"Move the box by the given increments."	| dEast dNorth dUp |	dEast := anArray at: 1.	dNorth := anArray at: 2.	dUp := anArray at: 3.		"Assure that aBox is in my collection. "	( self objects ) add: aBox.		"Compute edge positions to center aBox at those coordinates"	aBox eastEdge: (  aBox eastEdge + dEast ).	aBox northEdge: (  aBox northEdge + dNorth ).	aBox topEdge: (  aBox topEdge + dUp ).			! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 3/30/2012 19:15'!center	| array |	"Compute my center coordinates"	array := Array new: 3.	array at: 1 put: ( self westEdge + ( (self width ) * 0.5 ) ).	array at: 2 put: ( self southEdge + ( (self length ) * 0.5 ) ).	array at: 3 put: ( self bottomEdge + ( (self height ) * 0.5 ) ).	^array		! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 3/30/2012 17:10'!center: aBox at: anArray 	| east north top |	east := anArray at: 1.	north := anArray at: 2.	top := anArray at: 3.		"Assure that aBox is in my collection. "	( self objects ) add: aBox.		"Compute edge positions to center aBox at those coordinates"	aBox eastEdge: ( east + ( (aBox width ) * 0.5 ) ).	aBox northEdge: ( north + ( (aBox length ) * 0.5 ) ).	aBox topEdge: ( top + ( (aBox height ) * 0.5 ) ).		! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 3/30/2012 19:12'!center: aHumBox onTopOf: aHumBox2 	| center2 oldCenter newCenter |	self position: aHumBox onTopOf: aHumBox2.	center2 := aHumBox2 center.	oldCenter := aHumBox center.	newCenter := Array new: 3.	newCenter at: 1 put: ( center2 at: 1).	newCenter at: 2 put: ( center2 at: 2 ).	newCenter at: 3 put: ( oldCenter at: 3 ).	self center: aHumBox at: newCenter.! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 3/30/2012 16:42'!position: boxA eastOf: boxB	"Position A on East edge of B."	"Assure both are in my collection."	(self objects ) add: boxA.	(self objects ) add: boxB.	"By convention, A`s West edge will now equal B`s East edge."	boxA westEdge: ( boxB eastEdge ).	"Note that up-down  and north-south edges are not affected.	"! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 1/31/2012 13:34'!position: boxA northOf: boxB	"Position A on North edge of B."	"Assure both are in my collection."	(self objects ) add: boxA.	(self objects ) add: boxB.	"By convention, A`s South edget will now equal B`s North."	boxA southEdge: ( boxB northEdge ).! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 1/31/2012 13:34'!position: boxA onBottomOf: boxB	"Position A on bottom of B."	"Assure both are in my collection."	(self objects ) add: boxA.	(self objects ) add: boxB.	"By convention, A`s top will now equal B`s bottom."	boxA topEdge: ( boxB bottomEdge ).! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 1/31/2012 13:34'!position: boxA onTopOf: boxB	"Position A on top of B."	"Assure both are in my collection."	(self objects ) add: boxA.	(self objects ) add: boxB.	"By convention, A`s bottom will now equal B`s top."	boxA bottomEdge: ( boxB topEdge ).! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 1/31/2012 13:34'!position: boxA southOf: boxB	"Position A on South edge of B."	"Assure both are in my collection."	(self objects ) add: boxA.	(self objects ) add: boxB.	"By convention, A`s North edget will now equal B`s South."	boxA northEdge: ( boxB southEdge ).! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 1/31/2012 13:34'!position: boxA westOf: boxB	"Position A on West edge of B."	"Assure both are in my collection."	(self objects ) add: boxA.	(self objects ) add: boxB.	"By convention, A`s bottom will now equal B`s top."	boxA eastEdge: ( boxB westEdge ).! !HumBox subclass: #HumSpace	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumSpace commentStamp: 'RichardAlexanderGreen 3/7/2012 21:47' prior: 0!HumSpace is a synoym for HumBox.It is provided to make code more readable.The intent is that you would use HumBox to model things that are actually solid, like walls,but you would HumSpace to model things that are hollow (filled with air) for things like rooms, doors, windows.!HumBox subclass: #HumSolid	instanceVariableNames: 'typeOfSolid colorOfSolid'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumSolid commentStamp: 'RichardAlexanderGreen 3/30/2012 16:05' prior: 0!HumSolid is used to create solid objects such as avatars.
It is a subtype of HumBox in that each solid is expected to have bounding boxes.The methods of HumBox may be used for positioning where a loose position is adequate.!!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/30/2012 16:09'!color: aColor 	"What id the default (background) color of the surface and interior of this solid 3D object?"	self assert: (aColor isKindOf: Color ).	colorOfSolid := aColor.! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/30/2012 15:31'!type: aSymbol 	typeOfSolid := aSymbol.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumSolid class	instanceVariableNames: ''!!HumSolid class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 3/30/2012 15:30'!type: aSymbol height: aHeight width: aWidth depth: aDepth 	| solid |	solid := self new.	solid type: aSymbol.	"dimension up-down"	solid height: aHeight. 
	"dimension East-West"	solid width: aWidth.	"dimension North-South"	solid length: aDepth.	^solid! !