Object subclass: #HumTextLine	instanceVariableNames: 'string indentLevel'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumTextLine commentStamp: 'RichardAlexanderGreen 3/12/2013 11:35' prior: 0!A text is assumed have a collection of text-lines.Each text line is assumed to be a collection of tokens.Each token may have attributes that affect how it is rendered.For example, rendering attributes may include emphasis, color, highlight, link, editable.  (ToDo)Emphasis in turn might include isBold, isItalic, isUnderlined, relative height. (ToDo)Note -- Lines might be re-flowed during the rendering if the context permits / requires it.But the source lines in the text remain the same regardless of the rendering.We don't want to surprise the author by changing the source.(TODO: There is some conceptual conflict here that I have to resolve.)Instance Variables:	string	<String>	indentLevel	<Integer>!!HumTextLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 20:54'!indentLevel	"The indent level indicates the level of indentation,	  but not the rendering of the indentation."	^ indentLevel ifNil: [ indentLevel := 0 ].! !!HumTextLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 20:53'!indentLevel: aSmallInteger	indentLevel := aSmallInteger.! !!HumTextLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 17:51'!string	string ifNil: [ string := String new. ].	^string.! !!HumTextLine methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 18:21'!string: aByteString 	string := aByteString! !Object subclass: #HumEditor	instanceVariableNames: 'lineIndex characterIndex text keyboardActions'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumEditor commentStamp: 'RichardAlexanderGreen 8/7/2012 19:38' prior: 0!A HumEditor is attached to HumText.The editor provides the means to modify the text.The editor has a cursortPosition which defines where a cursor might be rendered and where character inserts and deletes may occur.The editor has a 'selection' which defines a part of the text that might be highlighted and processed.---Editor Actions   1. Usual text edit actions:      a) commands: (copy, cut, paste, un-do, save, open, print?, close window)      b) cursor moves: (up, down, left, right, top, bottom, . . .)   2. PA-specific actions:      a) [Line updated] event causes the logical-line and frame to be checked.         (1) The logical-line is rendered. 	           Keywords and nouns are emphasized. Nouns have links.          (2) If the logical-line is not understood (no definition in ontology or DSL),                the line is flagged (with a question-mark).         (3) If a noun lacks an antecedent in the frame, the noun is flagged (color code).      b) [Insert/Append Instruction] - Instructions are indented.         (1) In an action frame,                the automatic indent matches the preceding statement’s indent                unless it was a control statement (ending with a colon).                   And then, the indentation is increased by one.         (2) In plan and dialog frames,                instructions have only one level of indent                because control statements are not allowed in those contexts.         (3) In dialog frames,                the user indicates an instruction by starting the line with dot [tab].---!!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 18:37'!addLine: aString 	"Delegate to HumText instance."	(self text) addLine: aString! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 10:46'!characterIndex	"Character index is equal to the number of charactes to the left of the cursor."	^ characterIndex ifNil: [ characterIndex := 0 ].! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/12/2013 14:29'!characterIndex: aSmallInteger 	characterIndex := aSmallInteger.		(characterIndex < 0 ) 		ifTrue: [ characterIndex := 0.			"If sound is enabled, beep."			Beeper beep.			].! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 20:51'!currentLine	| result |	result := ( self lines ) at: ( self lineIndex ).	^result.! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/12/2013 14:22'!deletePriorCharacter	"Insert a character into the text at the current (cursor) position"	| humTextLine currentLine stringUpto stringAfter newLine currentIndex  |	"If cursor is at the front of the line, delete is a no op."	currentIndex := (self characterIndex).	( currentIndex = 0 ) ifTrue: [ Beeper beep. ^self ].	"Otherwise . . ."	humTextLine := (self lines) at: (self lineIndex).	currentLine := humTextLine string.	( currentIndex >= currentLine size )		ifFalse: [	stringUpto := currentLine copyFrom: 1 to: (currentIndex - 1).					stringAfter := currentLine copyFrom: (currentIndex+1) to: (currentLine size).					]		ifTrue: [ 	stringUpto := currentLine copyFrom: 1 to: (currentLine size - 1).			       	stringAfter := ''. 					].		newLine := stringUpto,  stringAfter.	humTextLine string: newLine.	"(self lines) at: (self lineIndex) put: humTextLine."	"Back the cursor."	self characterIndex: currentIndex - 1.	! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 10:49'!insertCharacter: aCharacter 	"Insert a character into the text at the current (cursor) position"	| humTextLine currentLine currentIndex stringUpto stringAfter newLine |	humTextLine := (self lines) at: (self lineIndex).	currentLine := humTextLine string.	currentIndex := self characterIndex.	( currentIndex >= currentLine size )		ifFalse: [	stringUpto := currentLine copyFrom: 1 to: currentIndex.					stringAfter := currentLine copyFrom: ( currentIndex +1 ) to: (currentLine size).					]		ifTrue: [ 	stringUpto := currentLine copy.			       	stringAfter := ''. 					].		newLine := stringUpto, (aCharacter asString), stringAfter.	humTextLine string: newLine.	"(self lines) at: (self lineIndex) put: humTextLine."	"Advance the cursor."	self characterIndex: (self characterIndex + 1).	! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 10:51'!insertLine	"Delegate to our HumText instance"	self text insertEmptyLineAfter: (self lineIndex).	"Adjust the cursor to point to the beginning of the new line."	lineIndex := lineIndex + 1.	characterIndex := 0.			! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 10:08'!lineIndex	^ lineIndex ifNil: [ lineIndex := 1 ].! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 20:32'!lineIndex: aSmallInteger 	| maxLine |	lineIndex := aSmallInteger.	maxLine := ((self text ) lines size).	( lineIndex >  maxLine ) ifTrue: [ lineIndex := maxLine].	( lineIndex < 1 ) ifTrue: [ lineIndex := 1 ].! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 10:36'!lines	^ self text lines.! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 17:42'!text	^ text ifNil: [ text := HumText new ].! !!HumEditor methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 7/31/2012 20:48'!interpretKey: aSymbol 	"Interpret various keyboard gestures."	| action |	keyboardActions ifNil: ["initialize"		keyboardActions := Dictionary  new.		keyboardActions			"Simple arrow keys"			at: #arrowUp put: [ self lineIndex: ( (self lineIndex) - 1) ];			at: #arrowDown put: [ self lineIndex: ( (self lineIndex) + 1 ) ];			at: #arrowLeft put: [ self characterIndex: ( (self characterIndex ) - 1) ];			at: #arrowRight put: [ self characterIndex: ( (self characterIndex ) + 1) ];						"Alt-Arrow keys"			at: #altArrowUp put: [ self lineIndex: 1];			at: #altArrowDown put: [ self lineIndex: ( self lines size ). 				                                   self characterIndex:  (self currentLine string size) ];			at: #altArrowLeft put: [ self characterIndex: 0 ];			at: #altArrowRight put: [ self characterIndex: (self currentLine string size) ];						"Escape key is a no-op at this time."			at: #escape put: [ Beeper beep ].		 ].	"Interpret the symbol (keyboard action name) given"	action := keyboardActions at: aSymbol 						ifAbsent: [ Error signal: 'No action for: ', (aSymbol asString)].	action value.	! !Object subclass: #HumSurface	instanceVariableNames: 'top bottom left right origin width height layer objects id title'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumSurface commentStamp: 'RichardAlexanderGreen 3/28/2013 10:55' prior: 0!HumSurface is like a movable canvas.It is also a container which collects other 2D objects which are also HumSurface instances.It has a set of layout methods.Instance Variables:	top	      <Number> -- top edge Y value	bottom	<Number> -- bottom edge Y value	left	      <Number> -- left edge X value	right	<Number> -- right edge X value	width	<Number> -- X extent	height	<Number> -- Y extent	layer	<Number> -- Z-order. Surfaces with higher layer numbers will overlay those with lower numbers.	origin	<HumSurface> -- a zero-size object positioned at (left top layer) = ( 0 0 0 )	objects	<Set> -- A set of dependent (child) objects. The children are rendered after I am.!!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:36'!bottom	^ bottom ifNil: [ bottom := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:56'!bottom: aNumber	"Reset the bottom edge."	bottom := self asMeasure: aNumber.	"Force top edge to be bottom + height"	top := bottom + (self height).! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/28/2013 10:49'!height	"What is the height of this object?	This is Y extent or length when surface is horizontal as seen on on table or document.	This is Z extent or height when surface is vertical as seen on a billboard.	The other dimensions are width and layer.	NOTE: In this model, a HumSurface has no thickness.	"	^ height ifNil: [ height := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:56'!height: aNumber.	"Reset the distance between top and bottom edges."	height := self asMeasure: aNumber.	"Force the bottom to be the top minus the height."	bottom := (self top) - height.! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/16/2012 12:31'!id	self assert: ( id isKindOf: String ).	self assert: ( id notEmpty ).	^ id! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2012 13:02'!id: aString 	id := aString.! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/4/2013 20:25'!initialize	| zero |	zero := HumMeasure quantity: 0 units: 'px'.	"zero := 0.00."	width := zero.	left := zero.	right := zero.		height := zero.	top := zero.	bottom := zero.		layer := zero.! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/4/2013 21:44'!initialize: units	| zero unitOfMeasure |	self assert: ( units isKindOf: String ).	"Reset #pixel to #px as needed.	In this case, the abbreviation is the preferred expression.	"	unitOfMeasure := units asString.	(units = 'pixel') ifTrue: [ unitOfMeasure := 'px' ]. 	(units = 'percent') ifTrue: [ unitOfMeasure := '%'].	zero := 0 perform: (units asSymbol).		width := zero.	left := zero.	right := zero.		height := zero.	top := zero.	bottom := zero.		layer := zero.! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/28/2013 10:36'!layer	"What layer is the surface in?	Surfaces with higher layer numbers will overlay (obscure) those with lower layer numbers.	You should avoid overlapping surfaces in the same layer. The result is not deterministic.	See also: #overlay:onTopOf:	"	"By default, a surface is in layer zero."	^ layer ifNil: [ layer := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:33'!layer: aNumber	layer := aNumber! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:35'!left	^ left ifNil: [ left := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/28/2013 10:17'!left: aNumber	| measure |	measure := self asMeasure: aNumber.	"Reset the left edge."	left := measure.	"Force the right edge to keep width constant."	right := left + (self width).! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 14:26'!objects	"I remember the 2d objects placed on me."	^ objects ifNil: [ objects := Set new. ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/28/2013 10:59'!origin	"a zero-size object positioned at ( left top layer ) = ( 0 0 0 )"		^ origin ifNil: [ origin := HumSurface new.  ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:35'!right	^ right ifNil: [ right := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:57'!right: aNumber		"Reset the right edge."	right := self asMeasure: aNumber.	"Force the left edge to keep the width constant."	left := right - (self width).! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2013 11:16'!title	^ title ifNil: [ self id ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2013 11:15'!title: aString	title := aString.	! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:36'!top	^ top ifNil: [ top := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:58'!top: aNumber	"Reset the top edge."	top := self asMeasure: aNumber.	"Force the bottom edge to keep the height constant."	bottom := top - (self height).! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:32'!width	^ width! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/27/2013 10:14'!width: anObject	"Reset the width. 	This is the X extent in most contexts.	See also: height and layer."	width := self asMeasure: anObject.	"Force the right edge to be consistent."	right := (self left) + width.! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 1/20/2012 14:36'!overlay: aHumSurfaceB onTopOf: aHumSurfaceA 	"Both objects are assumed (forced) to be present in my collection."	( self objects ) add: aHumSurfaceA.	( self objects ) add: aHumSurfaceB.	"By convention, surface B will be aligned with A's top and left edges."	aHumSurfaceB top: (aHumSurfaceA top).		aHumSurfaceB left: (aHumSurfaceA left).	"By convention, surface B will be placed in a higher numbered layer."	"Note: If there already was already another object on top and in same layer, 	   there is no attempt to place this one in-between."	aHumSurfaceB layer: (aHumSurfaceA layer) + 1.	! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 3/28/2013 10:40'!place: aHumSurfaceB above: aHumSurfaceA 	"Place B above A on the surface. 	(Not to be confused with putting B on a different layer.)"		"Assure that A and B are in my collection."	(self objects) add: aHumSurfaceA.	(self objects) add: aHumSurfaceB.		"By convention, set B's bottom will be equal to A's top.	i.e. There is no gap."	aHumSurfaceB bottom: ( aHumSurfaceA top ).		"By convention, B is now in the same layer as A."	aHumSurfaceB layer: ( aHumSurfaceA layer ).		! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 1/20/2012 14:23'!place: aHumSurface at: anArray 	| x y z |	x := anArray at: 1.	y := anArray at: 2.	z := anArray at: 3.		( self objects ) add: aHumSurface.	aHumSurface top: y; left: x; layer: z.! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 3/28/2013 10:40'!place: aHumSurfaceB below: aHumSurfaceA 	"Place B below A on the surface. (Not to be confused with putting B on a different  layer.)"	"TODO: Consider making calls to top: right: left: using blocks (closures) so that everything is dynamic.	 Counter: Use relative positions. 	          When rendering, we will iterate (self objects). 	          If child object positions are relative, we get the same effect.	"		"Assure that A and B are in my collection."	(self objects) add: aHumSurfaceA.	(self objects) add: aHumSurfaceB.		"By convention, set B's top to be equal to A's bottom.	i.e. There is no gap."	aHumSurfaceB top: ( aHumSurfaceA bottom ).		"By convention, B is now in the same layer as A."	aHumSurfaceB layer: ( aHumSurfaceA layer ).		! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 3/28/2013 10:40'!place: aHumSurfaceB leftOf: aHumSurfaceA 	"Place B left of A on the surface. "		"Assure that A and B are in my collection."	(self objects) add: aHumSurfaceA.	(self objects) add: aHumSurfaceB.		"By convention, set B's left to be equal to A's right.	i.e. There is no gap / gutter."	aHumSurfaceB left: ( aHumSurfaceA right ).		"By convention, B is now in the same layer as A."	aHumSurfaceB layer: ( aHumSurfaceA layer ).		! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 3/28/2013 10:41'!place: aHumSurfaceB rightOf: aHumSurfaceA 	"Place B right of A on the surface. "		"Assure that A and B are in my collection."	(self objects) add: aHumSurfaceA.	(self objects) add: aHumSurfaceB.		"By convention, set B's right to be equal to A's left.	i.e. There is no gap / gutter."	aHumSurfaceB left: ( aHumSurfaceA right ).		"By convention, B is now in the same layer as A."	aHumSurfaceB layer: ( aHumSurfaceA layer ).		! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/30/2012 14:04'!asHTML	" Render surface as HTML"	| myBlock html calc |	calc := HumCalculator new.		myBlock := [ self asHtmlCanvasOffsetX: (self left) y: (self top) ].	html := calc xml: 'html' 				with: [ (calc xml: 'head' 					            with: [ calc xml: 'title' 						                         with: ['Surface as HTML' ]						                ]),					      (calc xml: 'body'					              with: [ myBlock value ])					    ].					^html.! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/30/2012 13:48'!asHtmlCanvasOffsetX: offsetX y: offsetY	"Return a HTML <rect . . . /> element for this surface."	| xml canvasAttributes nextLayer viewX viewY calc |	xml := String new.	canvasAttributes := OrderedCollection new.	( id notNil ) ifTrue: [ canvasAttributes add: 'id' -> id ].		"Don't scale dimensions in this version"	canvasAttributes add: 'width' -> width asString.	canvasAttributes add: 'height' -> height asString.	viewX := left + offsetX.	viewY := top + offsetY.		canvasAttributes add: 'x' -> viewX asString.	canvasAttributes add: 'y' -> viewY negated asString.  "Flip our Y value because HTML has Y pointing down."		canvasAttributes add: 'style' -> 'border:3px solid black;'.	calc := HumCalculator new.	xml := '  ', ( calc xml: 'canvas' attributes: canvasAttributes ), String cr  .		nextLayer := ''.	(self objects )		do: [ :object | 			nextLayer := nextLayer, (object asHtmlCanvasOffsetX: viewX y: viewY).			].	xml := xml, nextLayer.	^xml. 		! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 3/16/2012 12:52'!asHumScript	| script space period |	space := ' '.	period := '.'.	script := '. Painter: '.	script := script, 'Paint surface with '.	script := script, space, 'id', space, (self id) quoted.	script := script, space, 'width', space, (self width) asString quoted.	script := script, space, 'height', space, (self height) asString quoted.	script := script, space, 'left', space, (self left) asString quoted.	script := script, space, 'top', space, (self top) asString quoted.		script := script, period.		( self objects )		do: [ :each | script := script, String cr, (each asHumScript ) ].		^script.! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 8/18/2013 20:59'!asMeasure: aQuantity	| measure |	( aQuantity isKindOf: HumMeasure )		ifTrue: [ measure := aQuantity ].	( aQuantity isKindOf: String ) 		ifTrue: [ measure := HumMeasure fromString: aQuantity ].	( aQuantity isKindOf: Number )		ifTrue: [ measure := HumMeasure quantity: aQuantity units: 'px' ].	self assert: ( measure isKindOf: HumMeasure ).	^measure! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/30/2012 13:50'!asSVG	| myBlock svg calc |		myBlock := [ self asSvgRectOffsetX: (self left) y: (self top) ].	calc := HumCalculator new.	svg := calc xml: 'svg' attributes: ( HumSurface svgAttributes ) with: myBlock.		^svg.! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 3/28/2013 10:48'!asSvgRect	"Return a SVG <rect . . . /> element for this surface."	| xml rectAttributes nextLayer calc |	self deprecated.	xml := String new.	rectAttributes := OrderedCollection new.	( id notNil ) ifTrue: [ rectAttributes add: 'id' -> id ].		"TODO: Determine what SVG scale and transpose should be applied to this surface's rectangle."	rectAttributes add: 'width' -> width asString.	rectAttributes add: 'height' -> height asString.	calc := HumCalculator new.	xml := calc xml: 'rect' attributes: rectAttributes .		"TODO: Order the objects by layer."	nextLayer := ''.	(self objects )		do: [ :object | 			nextLayer := nextLayer, object asSvgRect.			].	xml := xml, nextLayer.	^xml. 		! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 5/4/2013 21:53'!asSvgRectOffsetX: offsetX y: offsetY	"Return a SVG <rect . . . /> element for this surface."	| xml rectAttributes nextLayer viewX viewY calc |	xml := String new.	rectAttributes := OrderedCollection new.	( id notNil ) ifTrue: [ rectAttributes add: 'id' -> id ].		"Don't scale dimensions in this version"	rectAttributes add: 'width' -> width asString.	rectAttributes add: 'height' -> height asString.	( offsetX quantity = 0 ) ifTrue: [ viewX := left ] ifFalse: [ viewX := left + offsetX ].	( offsetY quantity = 0 ) ifTrue: [ viewY := top  ] ifFalse: [ viewY := top  + offsetY ].	rectAttributes add: 'x' -> viewX asString.	rectAttributes add: 'y' -> viewY negated asString.  "Flip our Y value because SVG has Y pointing down."	calc := HumCalculator new.	xml := calc xml: 'rect' attributes: rectAttributes .		nextLayer := ''.	(self objects )		do: [ :object | 			nextLayer := nextLayer, (object asSvgRectOffsetX: viewX y: viewY).			].	xml := xml, nextLayer.	^xml. 		! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 5/4/2013 20:57'!asSvgViewBox	| attributes viewBoxAttribute space myBlock svg calc |	"Set up standard attributes for the svg prolog."	calc := HumCalculator new.	space := $   asString.	attributes := OrderedCollection new.	attributes add: 'xmlns' -> 'http://www.w3.org/2000/svg'.	attributes add: 'xmlns:xlink' -> 'http://www.w3.org/1999/xlink'.	attributes add: 'width' -> '100%'.	attributes add: 'height' -> '100%'.		viewBoxAttribute := self left quantity asString, space, self top quantity asString, space, self width quantity asString, space, self height quantity asString.	attributes add: 'viewBox' -> viewBoxAttribute.		myBlock := [ self asSvgRectOffsetX: 0 px y: 0 px.  ].		svg := calc xmlOpen: 'svg' attributes: attributes.	svg := svg, '<g stroke="#001122" stroke-width="0.03" fill="ffeedd" >'.	svg := svg, ( myBlock value).	svg := svg, '</g>'.	svg := svg, '</svg>'.	^svg.! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/30/2012 13:50'!asXML	| myBlock xml calc |		myBlock := [ self asXMLRectOffsetX: (self left) y: (self top) ].	calc := HumCalculator new.	xml := calc xml: 'script' attributes: ( HumSurface humSurfaceAttributes ) with: myBlock.		^xml.! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/30/2012 13:49'!asXMLRectOffsetX: offsetX y: offsetY 	"Return a hum <surface . . . /> element for this surface."	| xml rectAttributes nextLayer viewX viewY calc |	xml := String new.	rectAttributes := OrderedCollection new.	( id notNil ) ifTrue: [ rectAttributes add: 'id' -> id ].		rectAttributes add: 'width' -> width asString.	rectAttributes add: 'height' -> height asString.	viewX := left + offsetX.	viewY := top + offsetY.		rectAttributes add: 'x' -> viewX asString.	rectAttributes add: 'y' -> viewY asString.  	calc := HumCalculator new.	xml := calc xml: 'hum:surface' attributes: rectAttributes .		nextLayer := ''.	(self objects )		do: [ :object | 			nextLayer := nextLayer, (object asXMLRectOffsetX: viewX y: viewY).			].	xml := xml, nextLayer.	^xml. 		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumSurface class	instanceVariableNames: ''!!HumSurface class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/16/2012 11:40'!humAttributes	"Set up standard attributes for the hum UI prolog."	| dict |	dict := OrderedCollection new.	dict add: 'src' -> 'scripts/hum.js'.	dict add: 'defer' -> 'defer'.	^dict.! !!HumSurface class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/16/2012 11:41'!humSurfaceAttributes	"Set up standard attributes for the hum UI prolog."	| dict |	dict := OrderedCollection new.	dict add: 'src' -> 'scripts/humSurface.js'.	dict add: 'defer' -> 'defer'.	^dict.! !!HumSurface class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 11/7/2012 12:44'!svgAttributes	"Will generate default attributes as follows:	<svg 	xmlns='http://www.w3.org/2000/svg' 			xmlns:xlink='http://www.w3.org/1999/xlink' 			width='100%'			height='100%'			>	Note: 100% width and height assumes that the actual size constraint 	will be defined in an enclosing <div . . .> tag.			"	| dict |	"Return default attributes for the svg prolog as a list of associations."	dict := OrderedCollection new.	dict add: 'xmlns' -> 'http://www.w3.org/2000/svg'.	dict add: 'xmlns:xlink' -> 'http://www.w3.org/1999/xlink'.	dict add: 'width' -> '100%'.	dict add: 'height' -> '100%'.	^dict.	! !HumSurface subclass: #HumPane	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!HumPane subclass: #HumDiagram	instanceVariableNames: 'connections nodes nodePositions positionNode nodeExtent nodeSpacing'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumDiagram methodsFor: 'layout' stamp: 'RichardAlexanderGreen 4/16/2013 09:59'!layoutDiagramWithNodeExtent: extentPoint nodeSpacing: spacingPoint	"Layout the diagram using the given node extent and spacing between node edges."		"Following must be set before calling me."	| xIncrement yIncrement nodePriority nodesByPriority |	self assert: ( extentPoint notNil ).	self assert: ( spacingPoint notNil ).	"Following is assumed in code below."	self assert: ( extentPoint  isKindOf: Point).	self assert: ( spacingPoint isKindOf: Point).	nodeExtent := extentPoint.	nodeSpacing := spacingPoint.		"Compute increments between grid locations."	"In this version, the placement is on a rectalinear grid.	But other/future versions may be radial and/or decrease as the number of priorNodes increases.	"	xIncrement := (nodeSpacing x) + (( nodeExtent x )/2).	yIncrement := (nodeSpacing y) + (( nodeExtent y )/2).		"Strategy: Prioritize the objects that have the most connections."	"Count the number of connections that each node has."	nodePriority := Dictionary new.	(self connections)		do: [ :map | 			| fromNode toNode fromCount toCount |			fromNode := map key.			toNode := map value. 			fromCount := nodePriority at: fromNode ifAbsent: [0].			nodePriority at: fromNode put: ( fromCount + 1).			toCount := nodePriority at: toNode ifAbsent: [0].			nodePriority at: toNode put: ( toCount + 1).			].	"Sort into a collection where nodes with most connections appear first."		nodesByPriority := SortedCollection new.	nodePriority 		keysAndValuesDo: [ :node :priority |			nodesByPriority add: ( (priority negated) -> node ).			]. 	"Place the nodes with the most connections on the first pass.	Note: This documentation uses term 'primary node' to refer to the node seen first.	      The primary node will be placed at 0@0.	"		nodesByPriority		do: [ :map |			| node xy |			node := map value.			xy := 0@0.			self layoutRecursiveWithNode: node relativePosition: xy seenBefore: (Set new).			xy := xy + (0@yIncrement).			]. 		! !!HumDiagram methodsFor: 'layout' stamp: 'RichardAlexanderGreen 4/17/2013 10:25'!layoutDistanceFromNode: nodeA toNode: nodeB	"Calculate the length of the connection between the nodes."	| xA xB yA yB xR yR r2 r|	xA := (( self nodePositions ) at: nodeA ) x.	yA := (( self nodePositions ) at: nodeA ) y.	xB := (( self nodePositions ) at: nodeB ) x.	yB := (( self nodePositions ) at: nodeB ) y.		xR := xA - xB.	yR := yA - yB.		r2 := ( xR * xR ) + ( yR * yR ).	r := r2 sqrt.	^r	! !!HumDiagram methodsFor: 'layout' stamp: 'RichardAlexanderGreen 4/18/2013 10:44'!layoutEnergyOnNode: nodeA fromNode: nodeB	"Calculate a energy scalar. 	 Rules are similar to elctrostatic energy.	 But since the layout is in a 2-D world, 	  the energy rules are linear. (in this version)	 Note: This method assumes that nodeA and nodeB are directly connected.	"	| r qA qB attraction repulsion attractionFactor repulsionFactor |		"Radius is the length of the connection between the nodes."	r := self layoutDistanceFromNode: nodeA toNode: nodeB.		"Attractive force increases when the radius increases.	This is analog of spring rate.	"	attractionFactor  := 1.0.	attraction := attractionFactor * r.		"Repulsion increases when charge Q (number of direct connections) increases.	"	repulsionFactor := 1.0.	qA := self countNeighborsOfNode: nodeA.	qB := self countNeighborsOfNode: nodeB.		repulsion := repulsionFactor * ( qA + qB ).	"TODO: Consider using minimum of qA or qB.	 TODO: Consider dividing by r.	"		^ ( attraction - repulsion ). 	"Notes: 	1. Return value is a scalar quantity. Not a vector.	2. Since the connected entities require space on the diagram,	     it may work better if we sqared the connection 'charge' quantities.	3. Perhaps we should divide by 'radius' in the repulsion calculation.	4. This calculation assumes the that nodeA and nodeB are directly connected.	5. What if return was ( attraction / repulsion )?	"! !!HumDiagram methodsFor: 'layout' stamp: 'RichardAlexanderGreen 4/16/2013 10:28'!layoutNode: aNode from: aPosition by: anIncrement	"Find a place for the given node starting from the given position.	 Increment the position until an empty position is found.	 Return the position where we placed the node.	"					| proposedPosition nodePosition |		proposedPosition := aPosition.	nodePosition := self getPositionForNode: aNode.	[ nodePosition  isNil]		whileTrue: [ "Is the proposed position empty?"								((self positionNode) at: proposedPosition ifAbsent: [nil])									ifNil: [ "Yes. It is empty"										nodePosition := proposedPosition.										self setNode: aNode position: nodePosition.										]									ifNotNil: ["compute next proposed position"						 					proposedPosition := proposedPosition + anIncrement.].															].							"At this point, proposedPosition should be the related node`s position"	self assert: ( nodePosition = (self getPositionForNode: aNode) ).			"Return the position where we placed the node."		^ nodePosition.! !!HumDiagram methodsFor: 'layout' stamp: 'RichardAlexanderGreen 4/16/2013 10:27'!layoutRecursiveWithNode: node relativePosition: relativePosition seenBefore: priorNodes	"Assign initial position to this node, and then, using recursion, to its neighbors.	- relativePosition is suggested first position to try. 	If that position is already filled, try other positions below it until one is found.	- priorNodes contains nodes that have been seen before in this recursion.	If this node is also in priorNodes, 	 it has already been handled and we return immediately to avoid a loop.	In some implementations,	  we might want to limit the depth (based on priorNodes size).	"	| xIncrement  xy downStreamNodes upStreamNodes yIncrement |	"Return immediately if this node has been seen before.	Otherwise add it to the nodes we have seen before and proceed."	( priorNodes includes: node ) ifTrue: [ ^self ] ifFalse: [ priorNodes add: node ].		"Following must be set before calling me."	self assert: ( nodeExtent notNil ).	self assert: ( nodeSpacing notNil ).	"Following is assumed in code below."	self assert: ( nodeExtent  isKindOf: Point).	self assert: ( nodeSpacing isKindOf: Point).		"Compute increments between grid locations."	"In this version, the placement is on a rectalinear grid.	But other/future versions may be radial and/or decrease as the number of priorNodes increases.	"	xIncrement := (nodeSpacing x) + (( nodeExtent x )/2).	yIncrement := (nodeSpacing y) + (( nodeExtent y )/2).		xy := self layoutNode: node from: relativePosition by: (0@yIncrement).		"Next: Find positions for nodes that are downstream from this node."	downStreamNodes := self getNodesDownstreamFromNode: node.	downStreamNodes				do: [ :downStreamNode | "Place downstream nodes to right and below of priority node."					self layoutRecursiveWithNode: downStreamNode 					             relativePosition: (xy + (xIncrement@0)) 					                  seenBefore: priorNodes.					"ToDo: Calculate which node positions are intersected by connecting lines.					       Assign the central node or a dummy node to those positions also.					       The parent node might be expanded to fill or the dummy node never drawn.					"					].				"Next: Find positions for nodes that are upstream from this node."	upStreamNodes := self getNodesUpstreamFromNode: node.	upStreamNodes				do: [ :upStreamNode | "Place upstream nodes to left and below priority node."					self layoutRecursiveWithNode: upStreamNode 					             relativePosition: (xy - (xIncrement@0))					                  seenBefore: priorNodes.					"ToDo: Calculate which node positions are intersected by connecting lines."					].	! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2012 13:57'!addConnection: anAssociation	"anAssociation := ( fromNode -> toNode )"	self assert: ( anAssociation isKindOf: Association ).	self connections add: anAssociation.! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/25/2013 12:40'!addNode: anObject	"A node object should have a title. 	(It should have something to display in a rendering or mouse-over or debug.) "	self assert: (anObject class selectors includes: #title ).	self nodes add: anObject.! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2013 08:54'!connections	^ connections ifNil: [ connections := Set new. ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/18/2013 10:22'!countNeighborsOfNode: aNode	"Return the number of neighbors of this node.	 (Count nodes that are directly connected to this node)"	| count |	count := 0.	( self connections ) 		do: [ :map | (((map key) = aNode) or: [(map value) = aNode]) 			ifTrue: [ count := count + 1 ] ].	^ count! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/16/2013 10:21'!getNodesDownstreamFromNode: thisNode 	"Return nodes that are connected downstream from this node."	| result |	result := Set new.	( self connections )		do: [ :connection |			| upstreamNode downstreamNode |			upstreamNode := connection key.			downstreamNode := connection value.			( upstreamNode = thisNode )				ifTrue: [ result add: downstreamNode ].			].	^ result.! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/16/2013 10:21'!getNodesUpstreamFromNode: thisNode 	"Return nodes that are connected upstream from this node."	| result |	result := Set new.	( self connections )		do: [ :connection |			| upstreamNode downstreamNode |			upstreamNode := connection key.			downstreamNode := connection value.			( downstreamNode = thisNode )				ifTrue: [ result add: upstreamNode ].			].	^ result.! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2012 16:44'!getPositionForNode: aNodeObject	^ self nodePositions at: aNodeObject ifAbsent: [ ^nil ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/13/2013 09:02'!nodeExtent: aPoint 	nodeExtent := aPoint! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2013 11:11'!nodePositions	^ nodePositions ifNil: [ nodePositions := Dictionary new. ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/13/2013 09:02'!nodeSpacing: aPoint 	nodeSpacing := aPoint! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2013 11:11'!nodes	^ nodes ifNil: [ nodes := Set new. ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2013 12:06'!positionNode	" What node is at a position"	^ positionNode ifNil: [ positionNode := Dictionary new. ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2013 12:05'!setNode: aNodeObject position: aPosition	"Node should also be in nodes collection for internal consistency."	self addNode: aNodeObject.	self nodePositions at: aNodeObject  put: aPosition.	self positionNode at: aPosition put: aNodeObject.! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/10/2012 13:01'!title	^ title ifNil: [ title := '** Diagram has no title!! **'].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/10/2012 13:02'!title: aString	title := aString.	! !!HumDiagram methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 4/13/2013 08:58'!asSVGonHtmlCanvas: html width: aWidth height: aHeight 	"Render this diagram on the given Seaside canvas.	Note: We use SVG.	"	|  |	self assert: ( html isKindOf: WACanvas ).	html div 		class: 'diagram'; 		id: (self title asCamelCase);		with: ["Label and Diagram"			html strong: self title.			html break.			"Eventually, we want to draw the diagram using SVG."			( html tag: 'svg' ) 				attributeAt: 'width' put: (aWidth asString);     				attributeAt: 'height' put: (aHeight asString);				attributeAt: 'viewBox' put: '0 0 1000 1000';				attributeAt: 'style' put: 'background: CYAN';				"FOLLOWING IS A STUB -- EVENTUALLY THIS WILL DRAW NODES AND CONNECTIONS"				"ToDo: Finish this after we have layout working."				with: ["SVG path element"					( html tag: 'path' )						attributeAt: 'd' put: 'M 100 100  q 0,100 100,100 ';						attributeAt: 'fill' put: 'none';						attributeAt: 'stroke' put: 'red';						attributeAt: 'stroke-width' put: '1'.					( html tag: 'text' ) 						attributeAt: 'x' put: 200;						attributeAt: 'y' put: 200;						attributeAt: 'font-size' put: 20;						attributeAt: 'fill' put: 'BLUE';						with: 'This is just a test of the SVG text rendering.'					].			].! !HumSurface subclass: #HumView	instanceVariableNames: 'entityID aHumBlackboard blackboard'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumView methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/24/2013 10:14'!blackboard	^ blackboard ifNil: [ Error signal: 'HumView blackboard accessed but no blackboard has been assigned.'].! !!HumView methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/24/2013 10:12'!blackboard: aHumBlackBoard	self assert: ( aHumBlackboard isKindOf: HumBlackBoard ).	blackboard := aHumBlackBoard.! !!HumView methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/24/2013 10:04'!checkRenderOn: html	html form with: [ 		html break. html heading level: 2; with: ' Recipe'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: entityID attribute: #name toValue: datum ]; name: 'name'; value: 'name'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: entityID attribute: #description toValue: datum ]; name: 'description'; value: 'description'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: entityID attribute: #ingredients toValue: datum ]; name: 'ingredients'; value: 'ingredients'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: entityID attribute: #steps toValue: datum ]; name: 'steps'; value: 'steps'.		]! !HumPane subclass: #HumMenu	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!Object subclass: #HumTextPrettyPrinter	instanceVariableNames: 'startCommentToEndOfLine'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumTextPrettyPrinter commentStamp: 'RichardAlexanderGreen 8/7/2012 19:28' prior: 0!HumTextPrettyPrinter is designed to pretty print a text based upon parameters provided.Parameters include:- string that begins a multi-line comment -- example: '/*' in several notations derived from the C langauge.- string that ends a multi-line comment. -- example: '*/' in several notations.- string that begins a whole-line comment -- example: '#' in several notations.- string that begins a remainder-of-line comment -- example '//' in several notations.- string that begins a compiler directive -- example '@' in Java and other languages.- string of special characters that may be included in names -- example '_' in many languages, '_-' in COBOL.- tokens that represent "keywords" -- exampe 'if', 'else', 'begin', 'end', 'for', 'def', 'class', 'public', 'private'.- balanced pairs -- For example: '(...)', '[...]', '{...}'- string delimiters -- For example: "..." and '...' - string for indentation -- For example: tab or '. '- treatment for keywords -- example: bold, foreground blue- treatment for whole-line comment -- example: italic, background dark green, foreground yellow.- treatment for remainder-of-line comments -- example: italic, foreground green- treatment for multi-line comments -- example: italic, foreground green- treatment for strings -- example: normal, forground cyan- treatment for special characters -- example: bold, forground red- treatment for whole-line comment -- example: italic, background dark green, foreground yellow.!!HumTextPrettyPrinter methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/7/2012 19:54'!addCommentToEndOfLineStartsWith: aString 	| |	self assert: (aString isKindOf:  String).	startCommentToEndOfLine := aString.! !!HumTextPrettyPrinter methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 8/7/2012 20:06'!parse: aHumTextLine 	|  tokens ppTokens |	"delimiters := (' ', startCommentToEndOfLine )."	tokens := ( aHumTextLine string ) substrings. 	ppTokens := OrderedCollection new.	tokens do: [ :token | 		| ppToken |		ppToken := HumTextPrettyToken new.		ppToken string: token.		ppTokens add: ppToken.		].	^ ppTokens.	! !Object subclass: #HumTextPrettyToken	instanceVariableNames: 'foregroundColor backgroundColor isBold isItalic isUnderlined fontFamily fontSize string'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumTextPrettyToken commentStamp: 'RichardAlexanderGreen 9/25/2012 19:45' prior: 0!HumTextPrettyToken is a string that may be enhanced with color, emphasis, fonts, and font weightswhen it is "pretty printed".See also: HumTextPrettyPrinter.	foregroundColor 	backgroundColor 	isBold 	isItalic 	isUnderlined 	fontFamily 	fontSize!!HumTextPrettyToken methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/7/2012 20:08'!string		^ string ifNil: [ string := String new. ].! !!HumTextPrettyToken methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/7/2012 20:07'!string: aString 	self assert: ( aString isKindOf: String ).	string := aString.! !Object subclass: #HumText	instanceVariableNames: 'string lines'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumText commentStamp: 'RichardAlexanderGreen 3/12/2013 11:36' prior: 0!HumText models a text.Text is multi-line and potentially enhanced with color, emphasis, fonts, and font weights.( Also known as "Attributed String" )The immediate intent is to support a code editor and rich text without going "over-board".See: HumTextPrettyToken.*** TODO: The current implementation is far from complete. ***Instance Variables:	string	< String >	lines	< OrderedCollection of HumTextLine >!!HumText methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/7/2012 19:46'!addLine: aString 	| newLine tempLines |	self assert: ( aString isKindOf: String ).	newLine := HumTextLine new.	newLine string: aString.	tempLines := self lines.	((tempLines size = 1) and: [( tempLines at: 1) string isEmpty])		ifTrue: [tempLines := OrderedCollection new. ].	tempLines add: newLine.	self lines: tempLines.! !!HumText methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 18:33'!insertEmptyLineAfter: lineIndex 	| currentLines tempLines |	currentLines := self lines.	tempLines := currentLines copyFrom: 1 to: lineIndex.	tempLines add: ( HumTextLine new).	tempLines addAll: ( currentLines copyFrom: ( lineIndex + 1 ) to:  currentLines size ).	lines := tempLines.! !!HumText methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 20:00'!lines	"Return the HumText list of  lines"	lines 		ifNil: [ "initialize the list"			lines := OrderedCollection new. 			lines add: ( HumTextLine new ).			].	^lines. ! !!HumText methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 20:28'!lines: anOrderedCollection 	( anOrderedCollection isKindOf:  OrderedCollection )		ifFalse: [ Error signal: 'Bad value sent to HumText>>lines: _']		ifTrue: [ |firstElement| firstElement := anOrderedCollection at: 1.			(firstElement isKindOf: HumTextLine) 			ifFalse: [ Error signal: 'First line should be a HumTextLine'] 			].	lines := anOrderedCollection! !!HumText methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 17:50'!string	| result |	result := String empty.	( self lines )		do: [ :line |			result := result, line string, String cr.			].	^result.! !Object subclass: #HumBox	instanceVariableNames: 'length width height topEdge bottomEdge eastEdge westEdge northEdge southEdge origin objects velocity'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumBox commentStamp: 'RichardAlexanderGreen 3/7/2012 21:48' prior: 0!Use this class to model static 3D box-like objects such as rooms, walls, doors, and windows.Although the term Box might might not work well with rooms, doors, and windows.you can think of those things as boxes that happen to be hollow or filled with air.The coordinate system is geographic and rectilinear.Any unit of measure may be used. 
You may use meters, feet, cm, mmwhatever you feel comfortable with 
and suits the domain you are modeling.Box-like objects may be positioned adjacent to each other.Instance Variables:	length	<Number>	width	<Number>	height	<Number>	"By convention length is North-to-South, width is East-to-West, and height is Top-to-Bottom."	topEdge	<Number>	bottomEdge	<Number>	eastEdge	<Number>	westEdge	<Number>	northEdge	<Number>	southEdge	<Number>	origin	<HumBox>	objects	<Set>              -- I am a container. I may contain (and layout) other HumBox objects.!!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/18/2013 21:00'!asMeasure: aQuantity	| measure |	( aQuantity isKindOf: HumMeasure )		ifTrue: [ measure := aQuantity ].	( aQuantity isKindOf: String ) 		ifTrue: [ measure := HumMeasure fromString: aQuantity ].	( aQuantity isKindOf: Number )		ifTrue: [ measure := HumMeasure quantity: aQuantity units: 'meter' ].	self assert: ( measure isKindOf: HumMeasure ).	^measure! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!bottomEdge	^ bottomEdge! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/18/2013 21:01'!bottomEdge: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset the bottom edge"	bottomEdge := measure.	"Force the top "	topEdge := bottomEdge + height.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!eastEdge	^ eastEdge! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/18/2013 21:02'!eastEdge: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset the East edge."	eastEdge := measure.	"Force the West edge."	westEdge := eastEdge - width.	! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:37'!height	"Get the height. By convention, height runs up and down."	^ height! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/18/2013 21:03'!height: aQuantity	| measure |	measure := self asMeasure: aQuantity.
	"Reset the height. By convention, height runs up and down."	height := measure.	self assert: ( height quantity >= 0.0 ).	"Hold botton steady and force the top."	topEdge := bottomEdge + height.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/18/2013 21:11'!initialize	"Set dimensions to zero."	| zero |	"By convention length is North-South, width is East-West, and height is top-bottom."	"Dimensions are arbitrary."	"TODO: Make all of these metrics a HumMeasure."	"TODO: Should the default system of meterics be MKS (Meters, Kilograms, Seconds)"	zero := 0 meter.	length := zero.	width := zero.	height := zero.	"Velocity vector = (northward, eastward, upward)"	velocity := { 0 mps. 0 mps. 0 mps.}. 	"Position edges at zero."	bottomEdge := zero.	topEdge := zero.	eastEdge := zero.	westEdge := zero.	northEdge := zero.	southEdge := zero.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:35'!length	"Get the length. By convention, length runs North and South."	^ length! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/18/2013 21:04'!length: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset the length. By convention, length runs North and South."	self assert: ( measure quantity >= 0.0 ).	length := measure.	"Hold South steady and force the North."	northEdge := southEdge + length.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!northEdge	^ northEdge! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/18/2013 21:04'!northEdge: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset North edge."	northEdge := measure.	"Hold North steady and force South."	southEdge := northEdge - length.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 14:26'!objects	"This set includes objects which move when I do.  	(In this sense, I am a container.)	Note: Coordinates are relative to parent containers.	Therefore, there is no need to correct child coordinates when the parent container is moved.	(The 'root' container is probably a scene graph and will not be moved.)	Note: 	Selectors 'advance: aBox by: #( x y z )' and 'center: aBox at: #( x y z)' and 'position ...'
           will add boxes to the container.	However, selectors that reset edge coordinates operate assume no container.	"	^ objects ifNil: [ objects := Set new. ].! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:32'!origin	"Origin is always a zero-sized object at (0 0 0)."	^ origin ifNil: [ origin := HumBox new.  ].! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!southEdge	^ southEdge! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/18/2013 21:04'!southEdge: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset the South edge."	southEdge := measure.	"Force North edge."	northEdge := southEdge + length.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!topEdge	^ topEdge! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/18/2013 21:05'!topEdge: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset the top edge."	topEdge := measure.	"Force the bottom edge."	bottomEdge := topEdge - height.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/21/2013 15:29'!volume	"Calculate the volume"	| v |	v := (self height) * (self width) * (self width).	"TODO: This should be a HumMeasure with dimension of L^3"	^v.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!westEdge	^ westEdge! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/18/2013 21:05'!westEdge: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset the West edge."	westEdge := measure.	"Force the East edge."	eastEdge := westEdge + width.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:33'!width	"Get the width. By convention, the width runs East and West."	^ width! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/18/2013 21:06'!width: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset the width. By convention, the width runs East and West."	self assert: (measure quantity >= 0.0 ).	width := measure.	"Hold West edge steady and force the East edge."	eastEdge := westEdge + width.! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 8/18/2013 21:36'!advance: aBox by: anArray 	"Move the box by the given increments.	anArray is velocity per step.	( velocity per second divided by steps per second )	It`s elements have units of L^1 T^-1.	"	| dEast dNorth dUp |	dEast  := self asMeasure: (anArray at: 1).	dNorth := self asMeasure: (anArray at: 2).	dUp    := self asMeasure: (anArray at: 3).		"Assure that aBox is in my collection. "	( self objects ) add: aBox.		"Compute edge positions to center aBox at those coordinates"	aBox eastEdge:  ( aBox eastEdge  + dEast ).	aBox northEdge: ( aBox northEdge + dNorth ).	aBox topEdge:   ( aBox topEdge   + dUp ).			! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 3/21/2013 15:44'!center	"Center of box (and/or center of bounding box)"	| array |	"Compute my center coordinates"	array := Array new: 3.	array at: 1 put: ( self westEdge + ( (self width ) * 0.5 ) ).	array at: 2 put: ( self southEdge + ( (self length ) * 0.5 ) ).	array at: 3 put: ( self bottomEdge + ( (self height ) * 0.5 ) ).	^array		! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 8/18/2013 21:33'!center: aBox at: anArray 	| east north top |	east  := self asMeasure: (anArray at: 1).	north := self asMeasure: (anArray at: 2).	top   := self asMeasure: (anArray at: 3).		"Assure that aBox is in my collection. "	( self objects ) add: aBox.		"Compute edge positions to center aBox at those coordinates"	aBox eastEdge:  ( east  + ( (aBox width  ) * 0.5 ) ).	aBox northEdge: ( north + ( (aBox length ) * 0.5 ) ).	aBox topEdge:   ( top   + ( (aBox height ) * 0.5 ) ).		! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 3/30/2012 19:12'!center: aHumBox onTopOf: aHumBox2 	| center2 oldCenter newCenter |	self position: aHumBox onTopOf: aHumBox2.	center2 := aHumBox2 center.	oldCenter := aHumBox center.	newCenter := Array new: 3.	newCenter at: 1 put: ( center2 at: 1).	newCenter at: 2 put: ( center2 at: 2 ).	newCenter at: 3 put: ( oldCenter at: 3 ).	self center: aHumBox at: newCenter.! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 3/30/2012 16:42'!position: boxA eastOf: boxB	"Position A on East edge of B."	"Assure both are in my collection."	(self objects ) add: boxA.	(self objects ) add: boxB.	"By convention, A`s West edge will now equal B`s East edge."	boxA westEdge: ( boxB eastEdge ).	"Note that up-down  and north-south edges are not affected.	"! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 1/31/2012 13:34'!position: boxA northOf: boxB	"Position A on North edge of B."	"Assure both are in my collection."	(self objects ) add: boxA.	(self objects ) add: boxB.	"By convention, A`s South edget will now equal B`s North."	boxA southEdge: ( boxB northEdge ).! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 1/31/2012 13:34'!position: boxA onBottomOf: boxB	"Position A on bottom of B."	"Assure both are in my collection."	(self objects ) add: boxA.	(self objects ) add: boxB.	"By convention, A`s top will now equal B`s bottom."	boxA topEdge: ( boxB bottomEdge ).! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 1/31/2012 13:34'!position: boxA onTopOf: boxB	"Position A on top of B."	"Assure both are in my collection."	(self objects ) add: boxA.	(self objects ) add: boxB.	"By convention, A`s bottom will now equal B`s top."	boxA bottomEdge: ( boxB topEdge ).! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 1/31/2012 13:34'!position: boxA southOf: boxB	"Position A on South edge of B."	"Assure both are in my collection."	(self objects ) add: boxA.	(self objects ) add: boxB.	"By convention, A`s North edget will now equal B`s South."	boxA northEdge: ( boxB southEdge ).! !!HumBox methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 1/31/2012 13:34'!position: boxA westOf: boxB	"Position A on West edge of B."	"Assure both are in my collection."	(self objects ) add: boxA.	(self objects ) add: boxB.	"By convention, A`s bottom will now equal B`s top."	boxA eastEdge: ( boxB westEdge ).! !HumBox subclass: #HumSpace	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumSpace commentStamp: 'RichardAlexanderGreen 3/26/2013 10:17' prior: 0!HumSpace is a synoym for HumBox.It is provided to make code more readable.The intent is that you would use HumSolid to model things that are mostly solid, like walls,but you would use HumSpace to model things that are hollow (filled with air) for things like rooms, doorways, gardens, landscapes. !HumBox subclass: #HumAssembly	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumAssembly commentStamp: 'RichardAlexanderGreen 3/26/2013 08:43' prior: 0!HumAssembly contains the methods for calculating aggregate metrics such as - total weight, - total floor space,- mass centroid (center of gravity)The assembly may also hold parameters that are global to the assembly.For example: Standard wall height. Standard panel width.Assembly subtypes may provide pre-defined parameterized standard assembliessuch as - wall unit assemblies- door assemblies- deck assemblies- posts, beams, trusses- appliances (toilet, refrigerator, washer, dryer, water heater, furnace)- wheels, axles- furniture (seat, desk, counter)!HumBox subclass: #HumSolid	instanceVariableNames: 'typeOfSolid colorOfSolid mass density material'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumSolid commentStamp: 'RichardAlexanderGreen 3/30/2012 16:05' prior: 0!HumSolid is used to create solid objects such as avatars.
It is a subtype of HumBox in that each solid is expected to have bounding boxes.The methods of HumBox may be used for positioning where a loose position is adequate.!!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/30/2012 16:09'!color: aColor 	"What id the default (background) color of the surface and interior of this solid 3D object?"	self assert: (aColor isKindOf: Color ).	colorOfSolid := aColor.! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2013 07:51'!density	"Return set density otherwise lookup the density of my material."	^ density ifNil: [ (self densityOfMaterial) ].! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/27/2013 09:44'!density: aMeasure	"What is the average density (mass per cube) of this solid?	*** Note: Use >>densityOfMaterial when possible. ***	*** Use this method to over-ride density given by material. ***	*** Example: You might use this method to provide average density of an aggregate. ***	"	self assert: ( aMeasure isKindOf: HumMeasure ).	"HumMeasure handles conversions to KMS units.	See also: methods in Number under HumMeasure category .	"	density := aMeasure.! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/27/2013 09:47'!densityOfMaterial	| result |	"The table is held on the class side to avoid clutter and instance bloat."	result := self class densityOfMaterial: material.	^result.! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2013 09:00'!gravity	"Return the value of Earth gravity acceleration at the given position 	(height above ground)."	^ ( HumMeasure quantity: 9.8 units: 'Meters*Second^-2' ).	"TODO:	Improve the value with more decimal places."! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2013 07:41'!mass	^ mass ifNil: [ (self volumn) * (self density)].! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/27/2013 09:41'!mass: aMeasure	"What is the mass of this object?"	self assert: ( aMeasure isKindOf: HumMeasure ).	"HumMeasure handles conversions to KMS units.	See also: methods in Number under HumMeasure category .	"	mass := aMeasure.! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2013 10:10'!material	^ material ifNil: [ Error signal: 'Material has not been set for this solid'].! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2013 10:05'!material: aString 	"See also: #densityOfMaterial for names of standard materials. "	self assert: ( aString isKindOf: String ).	material := aString.! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/21/2013 15:19'!type: aSymbol 	self assert: ( aSymbol isKindOf: Symbol ).	typeOfSolid := aSymbol.! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2013 07:50'!weight	"Get the Earth-bound weight of the object. (Not the same as weight)"	^ ( self mass ) * ( self gravity ).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumSolid class	instanceVariableNames: 'materialDensity'!!HumSolid class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 3/30/2012 15:30'!type: aSymbol height: aHeight width: aWidth depth: aDepth 	| solid |	solid := self new.	solid type: aSymbol.	"dimension up-down"	solid height: aHeight. 
	"dimension East-West"	solid width: aWidth.	"dimension North-South"	solid length: aDepth.	^solid! !!HumSolid class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/27/2013 09:37'!densityOfMaterial: aMaterial	"Return the average mass-density of the given material."	| result |	aMaterial ifNil: [ Error signal: 'No material given. Cannot lookup density.'].		(( self materialDensity ) isEmpty )		ifTrue: [ "Densities are in kilogram-mass per meter^3"			materialDensity at: 'air' put: 1.2.			materialDensity at: 'foam' put: 24.         "Expanded Polystyrene Insulation"			materialDensity at: 'snow' put: 480.        "snow, compacted"			materialDensity at: 'wood' put: 708.        "red oak (denser than most). "			materialDensity at: 'ice' put: 919.         "solid ice"			materialDensity at: 'water' put: 1000.			materialDensity at: 'seawater' put: 1030.			materialDensity at: 'fiberglass' put: 1900. "Polyester and Continuous Rovings Laminate 70% E-glass"			materialDensity at: 'soil' put: 2082.       "picked wet sand as worst case. packed mud is 1906"			materialDensity at: 'sheetrock' put: 2320.  			materialDensity at: 'drywall'   put: 2320.  			materialDensity at: 'concrete' put: 2370.			materialDensity at: 'glass' put: 2580.      "window glass"			materialDensity at: 'rock'  put: 2700.      "granite, limestone, marble"			materialDensity at: 'stone' put: 2700.      "granite, limestone, marble"			materialDensity at: 'aluminum' put: 2739.			materialDensity at: 'titanium' put: 4500.			materialDensity at: 'steel' put: 7849.			materialDensity at: 'copper' put: 8900.			materialDensity at: 'lead' put: 11300.			].	result := HumMeasure quantity: (materialDensity at: (self aMaterial)) units: #kilogramPerCubicMeter.	^result.! !