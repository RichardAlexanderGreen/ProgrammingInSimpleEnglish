Object subclass: #HumWidget	instanceVariableNames: 'attributeName attributeValue entityName blackboard canvas'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumWidget commentStamp: 'RichardAlexanderGreen 1/15/2016 15:06' prior: 0!A HumWidget provides a view of a single Attribute.A HumWidget is connected to a Hum Blackboard.See: HumEntityAttributeNote: Some Attributes are collections and some attributes are HumEntity objects.The primative datatypes include:- String . . an array of characters- Text . . . an array of lines of tokens with styling- Measure. . a quantity with a unit of measure and precision- Date . . . a calendar date (DateAndTime)- Category . some value within an enumerated set - Collection a collection of objects (entities)- Identifer . . Identifies an entity instance in a World Base.Future primative datatypes might include media types:- Image  . . a 2D picture (very technology dependent)The reference implementation renders a HumWidget as an HTML5 widget.However, the design intent requires that a HumWidget NOT be coupled to a specific rendering technology.A widget may also be a controller. That means:- It may react to external events (messages or calls from the HumScribe actor).>> highlight: aColor (Change the background or border color to indicate focus.)>> visible: aBoolean (If the widget is invisible, it occupies space but is not rendered.)- It may update the attribute value that is in its view.>> store: aValueQ: What is the relation between Sensor, Scribe, Widget, Canvas, Solid, ViewPort.A: The Scribe interprets inputs from the Sensor and updates a Widget.The Widget is drawn on a Canvas which is painted on a Surface.A Surface might be painted on a Solid within a Scene.Note: A Surface is not rendered if it is not visible to the Viewport`s Camera. The flow is Sensor >> Scribe >> Widget >> Canvas >> Surface >> ViewPort (Camera).!!HumWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/10/2016 08:45'!canvas: aHumCanvas 	"Canvas on which to draw the widget - "	self assert: (aHumCanvas isKindOf: HumCanvas).	canvas := aHumCanvas.! !!HumWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2016 14:17'!attributeValue: aString	"Set current value of attribute -- in display/input format."	"See >>store: -- which sets the value and also notifies the blackboard."	attributeValue := aString.! !!HumWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2014 15:14'!entityName: aString 	entityName := aString.! !!HumWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2016 15:12'!canvas	"Canvas on which to draw the widget - "	^canvas ifNil: [ canvas := HumCanvas new. ].	"Q: What is the relation between Sensor, Scribe, Widget, Canvas, Solid, ViewPort.A: The Scribe interprets inputs from the Sensor and updates a Widget.The Widget is drawn on a Canvas which is painted on a Surface.A Surface might be painted on a Solid within a Scene.Note: A Surface is not rendered if it is not visible to the Viewport`s Camera. The flow is Sensor >> Scribe >> Widget >> Canvas >> Surface >> ViewPort (Camera)."! !!HumWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2014 12:44'!attributeName	^attributeName! !!HumWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2014 12:43'!attributeName: aString	"name of attribute"	attributeName := aString.! !!HumWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/5/2015 12:22'!attributeValue	^ attributeValue ifNil: [ '' ].! !!HumWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2014 15:15'!blackboard: aHumBlackBoard 	blackboard := aHumBlackBoard. ! !!HumWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/31/2015 20:15'!formCanvas	^self canvas formCanvas.! !!HumWidget methodsFor: 'events-triggering' stamp: 'RichardAlexanderGreen 1/15/2016 14:02'!store: anObject 	"Set my attribute value and store it on my blackboard."	"TODO: Perhaps this should be #update: method to correspond with other UI controller conventions."  	self attributeValue: anObject.	"Note: The blackboard might send the value to it`s world-base, if it has a world-base."	blackboard setEntityName: entityName attribute: attributeName toValue: anObject.! !!HumWidget methodsFor: 'Render As' stamp: 'RichardAlexanderGreen 4/21/2015 09:53'!asXUL	"Render widget and data as XUL code"	self subclassResponsibility.! !!HumWidget methodsFor: 'Render As' stamp: 'RichardAlexanderGreen 4/21/2015 09:53'!asHTML	"Render widget and data as HTML code"	self subclassResponsibility.! !!HumWidget methodsFor: 'Render As' stamp: 'RichardAlexanderGreen 4/23/2015 08:26'!asMorph	"Render widget and data as Morph object  	- See: MorphicModel hierarchy"	self subclassResponsibility.! !!HumWidget methodsFor: 'Render As' stamp: 'RichardAlexanderGreen 4/21/2015 09:53'!asMagritteMorph	"Render widget and data as Magritte Morph object"	self subclassResponsibility.! !!HumWidget methodsFor: 'Render As' stamp: 'RichardAlexanderGreen 4/21/2015 09:53'!asJSF	"Render widget and data as Jave Server Face code"	self subclassResponsibility.! !!HumWidget methodsFor: 'Render As' stamp: 'RichardAlexanderGreen 4/21/2015 09:53'!asGlamorBrick	"Render widget and data as Glamor Brick object"	self subclassResponsibility.! !!HumWidget methodsFor: '*HumSeaside' stamp: 'RichardAlexanderGreen 3/26/2014 16:50'!renderContentOn: aWAHtmlCanvas	"Default: Render self via a simple input tag"	| |	aWAHtmlCanvas textInput 		attributeAt: 'id' put: (self attributeName );		callback: [:value | self store: value ];		with: (self attributeValue asString).! !!HumWidget methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/16/2016 08:57'!about" The traditional idea of a widget is that it is a component in a view. (MVC concept)But in a 3D virtual-reality context, the widget concept must be extended.""Q: What is the relation between Sensor, Scribe, Widget, Canvas, Solid, ViewPort.A: The Scribe interprets inputs from the Sensor and updates a Widget.The Widget is drawn on a Canvas which is painted on a Surface.A Surface might be painted on a Solid within a Scene.Note: A Surface is not rendered if it is not visible to the Viewport`s Camera. The flow is Sensor >> Scribe >> Widget >> Canvas >> Surface >> ViewPort (Camera).""Q: What is the relationship between Sensor, Scribe, Widget, Blackboard, Dialog?A: The Scribe interprets Sensor inputs and updates both the view and the Dialog.The update of a Dialog might wait until form data is submitted."" Note: An Avatar may be a kind of widget. It is in the 3D view and may interact with the user."" A Scene is mostly decoration, but it may also trigger interaction via proximity triggers.That means that a proximity trigger may be a kind of widget.Examples:U: User-Avatar enters the conference room.U: User-Avatar is facing the receptionist."! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumWidget class	instanceVariableNames: 'blackboard'!!HumWidget class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 3/26/2014 15:53'!onEntity: anEntityName attribute: anAttributeName blackboard: aHumBlackBoard   "Create an instance of me with given connections."	| widget |	widget := self basicNew.	widget 		blackboard: aHumBlackBoard;		entityName: anEntityName;		attributeName: anAttributeName;		attributeValue: ( aHumBlackBoard getEntityName: anEntityName attribute: anAttributeName ).	^widget.! !Object subclass: #HumBox	instanceVariableNames: 'length width height topEdge bottomEdge eastEdge westEdge northEdge southEdge origin velocity id solidColor rotation tiltUpDown polygons equationOfMotion'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumBox commentStamp: 'RichardAlexanderGreen 8/24/2015 09:01' prior: 0!HumBox is designed to facilitate layout.It has boundaries called Edges. The boundary metrics provide position and extent information.HumBox coordinates are { East. North. Up. } .X-Y plane is plan view projection. X-Z plane is front view projection.Box-like (enclosing box) objects may be positioned adjacent to each other.A HumAssembly is a container that may hold other boxes.Use the subtype HumSolid to model 3D scene objects such as rooms, walls, doors, and windows.Although the term Box might might not seem to map well to hollow objects such as rooms, doors, and windows,you can think of those things as boxes that happen to be hollow or filled with air.The coordinate system is geographic and rectilinear.Any unit of measure may be used. 
You may use meters, feet, cm, mmwhatever you feel comfortable with 
and suits the domain you are modeling.
If an ordinary number is given as a dimension, it will be assumed to be in meters.Note: Hum scene dimensions are plan view: . X points East. . Y points North. . Z points up.Instance Variables:	length	<Number> y 	width	<Number> x	height	<Number> z	"By convention length is North-to-South, width is East-to-West, and height is Top-to-Bottom."		eastEdge	<Number> x	westEdge	<Number> x	northEdge	<Number> y	southEdge	<Number> y	topEdge	    <Number> z	bottomEdge	<Number> z			origin	<HumBox>!!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/3/2015 09:02'!centerY	"Y dimension points North" 	^( self southEdge + ( (self length ) * 0.5 ) ).! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/20/2016 10:13'!equationOfMotion	"The equation-of-motion should be a block with args: box and time"	equationOfMotion 			ifNil: [ self equationOfMotion: [ :box :time | box centerAt: (box center) + (velocity*time) ] ].	^equationOfMotion.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/5/2015 11:42'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title;		nextPutAll: '(', self id,')'.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/12/2013 13:46'!id: aString height: aHeight width: aWidth depth: aDepth 	"synonym"	^ self id: aString height: aHeight width: aWidth length: aDepth.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/3/2015 09:02'!centerZ	"Z dimension points up." 	^( self bottomEdge + ( (self height ) * 0.5 )  ).! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/5/2013 17:27'!id	"Identifier used in rendering context"	^ id ifNil: [ id := self identityHash printString ].! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/29/2016 09:11'!equationOfMotion: fcSelfAndTime	"The equation-of-motion should be a block with args: box and time"	self assert: ( fcSelfAndTime isKindOf: BlockClosure ).	self assert: ( fcSelfAndTime numArgs = 2 ).	equationOfMotion := fcSelfAndTime.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/29/2016 08:43'!initialize	"Set dimensions to zero."	| zero |	"By convention length is North-South, width is East-West, and height is top-bottom."	"X: East is +. West is -."	"Y: North is +. South is -."	"Z: Up is +. Down is -."	"Default system of metrics is MKS (Meters, Kilograms, Seconds)"	zero := 0 meter.	length := zero.	width := zero.	height := zero.	"Velocity vector = (northward, eastward, upward)"	self velocity: (HumVector newFrom: { 0 mps. 0 mps. 0 mps. }).	"Position edges at zero."	bottomEdge := zero.	topEdge := zero.	eastEdge := zero.	westEdge := zero.	northEdge := zero.	southEdge := zero.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/9/2015 11:03'!xyzString	| s x y z space |	x := self centerX.	y := self centerY.	z := self centerZ.	self assert: (x isKindOf: HumMeasure).	space := ' '.	s := '( ',(x quantityAsString), space, (y quantityAsString), space, (z quantityAsString), ')'.	^s.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/13/2015 08:53'!rSquared	"How far am I from the origin? Use R-squared of my centroid as metric."	| cx cy cz rSquared |	cx := self centerX.	cy := self centerY.	cz := self centerZ.	rSquared := (cx*cx) + (cy*cy) + (cz*cz).	^rSquared.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/29/2016 08:47'!center	"Center of box (and/or center of bounding box) -- { x y z } = { east north up }"	| position |	"Compute my center coordinates - { east. north. up }"	position := HumVector newFrom: { self centerX.  self centerY.  self centerZ. }.	^position.		! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/24/2015 09:21'!id: aString height: aHeight width: aWidth length: aLength 	self initialize;	     id: aString; 	     height: aHeight; 	     width: aWidth; 	     length: aLength.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/13/2015 12:21'!solidColor: aColor	"What color should be used to render box or bounding-box in a view?"	self assert: (aColor isNil or: [aColor isKindOf: Color]).	solidColor := aColor.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/3/2015 09:02'!centerX	"X axis points East" 	^(self westEdge + ( (self width ) * 0.5 )).! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/12/2013 13:51'!id: aString	"Identifier used in rendering contexts"	id := aString.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2016 11:20'!velocity: aHumVector	"What is the 3D object`s current velocity?"	self assert: (aHumVector isKindOf: HumVector).	self assert: (aHumVector dimensions = (1.0 meterPerSecond dimensions) ).	velocity := aHumVector.! !!HumBox methodsFor: 'accessing - edges' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!bottomEdge	^ bottomEdge! !!HumBox methodsFor: 'accessing - edges' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!northEdge	^ northEdge! !!HumBox methodsFor: 'accessing - edges' stamp: 'RichardAlexanderGreen 8/18/2013 21:05'!topEdge: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset the top edge."	topEdge := measure.	"Force the bottom edge."	bottomEdge := topEdge - height.! !!HumBox methodsFor: 'accessing - edges' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!southEdge	^ southEdge! !!HumBox methodsFor: 'accessing - edges' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!eastEdge	^ eastEdge! !!HumBox methodsFor: 'accessing - edges' stamp: 'RichardAlexanderGreen 8/18/2013 21:02'!eastEdge: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset the East edge."	eastEdge := measure.	"Force the West edge."	westEdge := eastEdge - width.	! !!HumBox methodsFor: 'accessing - edges' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!topEdge	^ topEdge! !!HumBox methodsFor: 'accessing - edges' stamp: 'RichardAlexanderGreen 8/18/2013 21:05'!westEdge: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset the West edge."	westEdge := measure.	"Force the East edge."	eastEdge := westEdge + width.! !!HumBox methodsFor: 'accessing - edges' stamp: 'RichardAlexanderGreen 10/8/2015 14:39'!southEdge: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset the South edge."	southEdge := measure.	"Force North edge."	northEdge := southEdge + length.! !!HumBox methodsFor: 'accessing - edges' stamp: 'RichardAlexanderGreen 2/29/2016 09:24'!bottomEdge: aQuantity	"WARNING: Assumes the box has default orientation."	| measure |	measure := self asMeasure: aQuantity.	"Reset the bottom edge"	bottomEdge := measure.	"Force the top "	topEdge := bottomEdge + height.! !!HumBox methodsFor: 'accessing - edges' stamp: 'RichardAlexanderGreen 2/29/2016 09:26'!aboutEdges	^'WARNING: The set/get methods for edges assume a default orientation.'.! !!HumBox methodsFor: 'accessing - edges' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!westEdge	^ westEdge! !!HumBox methodsFor: 'accessing - edges' stamp: 'RichardAlexanderGreen 8/18/2013 21:04'!northEdge: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset North edge."	northEdge := measure.	"Hold North steady and force South."	southEdge := northEdge - length.! !!HumBox methodsFor: 'access' stamp: 'RichardAlexanderGreen 10/13/2015 15:18'!exploded	^{ self }.! !!HumBox methodsFor: 'coloring' stamp: 'RichardAlexanderGreen 10/19/2015 09:46'!resetColoring	self nextColor.	colorStream position: 0.! !!HumBox methodsFor: 'coloring' stamp: 'RichardAlexanderGreen 10/19/2015 09:47'!nextColor	 "Select from a sequence of colors. Enables reproducable result."	| colorSequence  nextColor |	colorStream 		ifNil: [ colorSequence := { Color red. Color orange. Color yellow. Color green. Color blue. Color purple. }.						colorStream := ReadStream on: colorSequence.  			].	(colorStream atEnd) ifTrue: [ colorStream position: 0 ].	nextColor := colorStream next.	^nextColor.		! !!HumBox methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/12/2013 15:45'!x3dExtent	"Return x y z extents as a string	Note: This needs to map Hum coordinates to X3D coordinates.	TODO: HumSolid may override to subtract some clearance quantity (e.g. 1 or 2 mm) from quantities.	"	|s|	"X"	s :=         ( self mm: width  ).	"Y"	s := s, ' ', ( self mm: length ).	"Z"	s := s, ' ', ( self mm: height ).	^s.! !!HumBox methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/5/2013 11:23'!x3dCenter	"Center of box (and/or center of bounding box) -- { x y z }	Note: This needs to map Hum coordinates to X3D coordinates.	"	| s |	"X"	s := ( self westEdge + ( (self width ) * 0.5 ) ) quantity asString.	"Y"	s := s, ' ', ( self southEdge + ( (self length ) * 0.5 ) ) quantity asString.
	"Z"	s := s, ' ', ( self bottomEdge + ( (self height ) * 0.5 ) ) quantity asString.	^s		! !!HumBox methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 7/29/2015 11:40'!asX3D	"Return a string in X3D notation representing this box / thing.	Caller is responsible for embedding this in a scene.	"	|  x3d calc space position extent |	space := String space.		position := Dictionary new.	position at: 'translation' put: ( self x3dCenter ).	extent := Dictionary new.	extent at: 'size' put: ( self x3dExtent ).	calc := HumCalculator new.	x3d := calc xml: 'transform' dictionary: position 						   with: [ calc xml: 'box' dictionary: extent ].  "TODO: Subtypes may add appearance and/or material elements"								^x3d.! !!HumBox methodsFor: 'polygons' stamp: 'RichardAlexanderGreen 10/13/2015 08:30'!polygons: aCollection 	"Computed polygons *may* be stored here."	polygons := aCollection.! !!HumBox methodsFor: 'polygons' stamp: 'RichardAlexanderGreen 10/13/2015 08:31'!addPolygon: aHumPolygon 	(self polygons) add: aHumPolygon! !!HumBox methodsFor: 'polygons' stamp: 'RichardAlexanderGreen 10/13/2015 08:32'!polygons	^ polygons ifNil: [ polygons := OrderedCollection new ].! !!HumBox methodsFor: 'stepping' stamp: 'RichardAlexanderGreen 6/24/2016 10:23'!jump: aTime	self assert: (aTime isKindOf: HumMeasure).	"Evaluate my equationOfMotion"	self equationOfMotion value: self value: aTime.	"TODO: Can we make this compatible with HumSimulator?"	! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 8/27/2015 14:06'!tiltDown: angleInDegrees	"Set tilt  (pitch)  in scene coordinates - Note: This is not additive."	self tiltDegrees: angleInDegrees negated.! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 10/9/2015 10:14'!slideDown: aHumMeasure 	"Move box (e.g. camera) up or down in the scene coordinates."	self topEdge: (self topEdge) - aHumMeasure.	"TODO: Refactor to make this work in camera coordinates - corrected for rotation and tilt."	self changed.! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 8/27/2015 14:06'!tiltUp: angleInDegrees	"Set tilt (pitch) in scene coordinates - Note: This is not additive."	self tiltDegrees: angleInDegrees.! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 3/11/2016 15:56'!rotation: angle	"Set my rotation in scene coordinates as a value expressed in radians "	| calc |	calc := HumCalculator new.	calc cases;		when: [ angle isKindOf: Float ] 			then: [ rotation := angle ];		when: [( angle isKindOf: HumMeasure ) and: [ angle units = #radian ] ] 			then: [ rotation := angle quantity ];		otherwise: [ Error signal: 'angle not in expected units' ].	self changed.	! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 8/3/2015 14:05'!tilt	"Get my tilt in scene coordinates as a value expressed in radians.	Positive value is an upward tilt. "	^tiltUpDown ifNil: [ tiltUpDown := 0.0. ].	! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 10/7/2015 20:18'!tiltDegrees: angleInDegrees	"Set my tilt (pitch) angle in scene coordinates. "	| |	(angleInDegrees isKindOf: HumMeasure)		ifTrue: [ ^self tilt: ( self tilt ) + ( angleInDegrees quantity degreesToRadians )  ].	"Otherwise:"	self tilt: ( self tilt ) + ( angleInDegrees degreesToRadians ).! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 8/27/2015 14:05'!rotateLeft: angleInDegrees	"Set rotation (yaw) in scene coordinates - Note: This is not additive."	self rotationDegrees: angleInDegrees.! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 11/10/2015 10:39'!tiltPolygons: inputPolygons 	"Correct the polygons for my tilt (pitch)."	| resultPolygons  centerY  centerZ |	(self tilt = 0) ifTrue: [ ^inputPolygons ].	centerY := self centerY.	centerZ := self centerZ.	resultPolygons := OrderedCollection new.	inputPolygons 		do: [ :polygon |			| resultPolygon |			resultPolygon := HumPolygon borderColor: polygon borderColor fillColor: polygon fillColor.			resultPolygon parentSolid: self.			resultPolygons add: resultPolygon.			polygon verticesDo: [  :x :y :z |				| alpha beta distance  relativeY relativeZ  tiltY tiltZ |				relativeY := y - centerY.				relativeZ := z - centerZ.				alpha := relativeY arcTan: relativeZ. "Float>>arcTan"				beta := alpha + (self tilt).				distance := ( (relativeY*relativeY) + (relativeZ*relativeZ) ) sqrt.				tiltY := ( distance * ( beta cos  ) ) + centerY.				tiltZ := ( distance * ( beta sin ) ) + centerZ.				resultPolygon addVertex: { x. tiltY. tiltZ. }.				 ].			].	^resultPolygons.! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 10/8/2015 13:55'!zslideRight: aHumMeasure 	"Move camera left or right --- TODO: Correct this for camera orientation."	self westEdge: (self westEdge) + aHumMeasure.	self changed.! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 8/3/2015 14:05'!rotation	"Get my rotation in scene coordinates as a value expressed in radians "	| |	^rotation ifNil: [ rotation := 0.0 ].	! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 8/3/2015 14:05'!slideLeft: aHumMeasure 	^self slideRight: (aHumMeasure negated).! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 11/10/2015 10:38'!rotatePolygons: inputPolygons 	"Correct the polygons for my rotation (yaw)."	| resultPolygons centerX centerY  |	centerX := self centerX.	centerY := self centerY.	resultPolygons := OrderedCollection new.	inputPolygons 		do: [ :polygon |			| resultPolygon |			resultPolygon := HumPolygon borderColor: polygon borderColor fillColor: polygon fillColor.			resultPolygon parentSolid: self.			resultPolygons add: resultPolygon.			polygon verticesDo: [  :x :y :z |				| alpha beta distance relativeX relativeY rotatedX rotatedY |				relativeX := x - centerX.				relativeY := y - centerY.				alpha := relativeY arcTan: relativeX.				beta := alpha + (self rotation).				distance := ((relativeX*relativeX) + (relativeY*relativeY)) sqrt.				rotatedX := (distance * ( beta cos ) )+ centerX.				rotatedY := (distance * ( beta sin ) ) + centerY.				resultPolygon addVertex: { rotatedX. rotatedY. z. }.				 ].			].	^resultPolygons.! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 8/27/2015 14:05'!rotateRight: angleInDegrees	"Set rotation (yaw) in scene coordinates - Note: This is not additive."	self rotationDegrees: angleInDegrees negated.! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 10/8/2015 14:31'!slideBackward: aHumMeasure 	"Slide in the South direction - TODO: adjust for camera rotation."	self slideForward: ( aHumMeasure negated ).! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 10/7/2015 20:21'!tilt: tiltInRadians	"Set my tilt in scene coordinates as a value expressed in radians.	Positive value is an upward tilt. "	| |	self assert: (tiltInRadians isKindOf: Float).	tiltUpDown := tiltInRadians.	self changed.	! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 3/11/2016 15:55'!rotationDegrees: angle	"Set my rotation angle in scene coordinates. "	| calc |	calc := HumCalculator new.	calc cases;		when: [ (angle isKindOf: HumMeasure) and: [angle units = #radian] ] 			then: [ self rotation: ( self rotation )+( angle quantity). ];		when: [ (angle isKindOf: HumMeasure) and: [angle units = #degree] ] 			then: [ self rotation: ( self rotation )+( angle quantity degreesToRadians ). ];		when: [ angle isKindOf: Float ]			then: [ self rotation: (self rotation) + angle ];		otherwise: [ Error signal: 'angle not in expected units' ].	self changed. ! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 10/8/2015 14:40'!slideForward: aHumMeasure 	"Slide in the North direction - TODO: adjust for camera rotation."	self southEdge:  ( self southEdge ) + aHumMeasure.	self changed.! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 10/8/2015 14:26'!slideRight: aHumMeasure 	"Move camera left or right --- TODO: Correct this for camera orientation."	self westEdge: (self westEdge) + aHumMeasure.	self changed.! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 8/3/2015 14:05'!slideUp: aHumMeasure 	^self slideDown: (aHumMeasure negated).! !!HumBox methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 5/9/2016 08:36'!centerAt: a3Vector 	"Center myself at the given coordinates. { east. north. up. }	Note: Those coordinates are relative to my container`s origin."	| eastOffset northOffset topOffset |	eastOffset  := self asMeasure: (a3Vector x).	northOffset := self asMeasure: (a3Vector y).	topOffset   := self asMeasure: (a3Vector z).		"Compute new edge positions to center aBox at those coordinates relative to my origin."	self eastEdge:   ( eastOffset  + ( ( self width  ) * 0.5 ) ).	self northEdge: ( northOffset + ( ( self length ) * 0.5 ) ).	self topEdge:    ( topOffset    + ( ( self height ) * 0.5 ) ).		! !!HumBox methodsFor: 'render as Three.js' stamp: 'RichardAlexanderGreen 7/29/2015 11:39'!asThreeJS	"Render this as a box in Three.js"	| js template dictionary calc |	"Note: Caller must merge this into a scene or group geometry"	template := '			var @ID = new THREE.Mesh( ( new THREE.CubeGeometry( @width, @length, @height   )  )			                            , ( new THREE.MeshBasicMaterial( { transparent: true } )  )			                            );			@ID.position.set( @x, @y, @z );			'. 	dictionary := Dictionary new.	dictionary	  at: 'ID' put: (self asCamelCase );	  at: 'width'  put: ( self mm: width  );	  at: 'length' put: ( self mm: length );	  at: 'height' put: ( self mm: height );		at: 'x' put: (self mm: #centerX );		at: 'y' put: (self mm: #centerY );		at: 'z' put: (self mm: #centerZ ).	calc := HumCalculator new.	js := calc fillTemplate: template fromDictionary: dictionary.	^js. ! !!HumBox methodsFor: 'render as Three.js' stamp: 'RichardAlexanderGreen 8/3/2015 09:19'!asCamelCase	^ (self id asCamelCase uncapitalized ).! !!HumBox methodsFor: 'private' stamp: 'RichardAlexanderGreen 8/18/2013 21:00'!asMeasure: aQuantity	| measure |	( aQuantity isKindOf: HumMeasure )		ifTrue: [ measure := aQuantity ].	( aQuantity isKindOf: String ) 		ifTrue: [ measure := HumMeasure fromString: aQuantity ].	( aQuantity isKindOf: Number )		ifTrue: [ measure := HumMeasure quantity: aQuantity units: 'meter' ].	self assert: ( measure isKindOf: HumMeasure ).	^measure! !!HumBox methodsFor: 'private' stamp: 'RichardAlexanderGreen 12/12/2013 14:11'!mmShave: aMeasure	"Format this measure to 3 digits accuracy - i.e. millimeter accuracy.	But first shave a millimeter from both ends."	^ (aMeasure - (2 millimeter)) quantity printShowingDecimalPlaces: 3.! !!HumBox methodsFor: 'private' stamp: 'RichardAlexanderGreen 1/31/2012 13:32'!origin	"Origin is always a zero-sized object at (0 0 0)."	^ origin ifNil: [ origin := HumBox new.  ].! !!HumBox methodsFor: 'private' stamp: 'RichardAlexanderGreen 12/22/2013 20:00'!mm: aMeasure	"Format this measure to 3 digits accuracy - i.e. millimeter accuracy"	( aMeasure isKindOf: HumMeasure )			ifTrue: [^ aMeasure quantity printShowingDecimalPlaces: 3.].	( aMeasure isKindOf: Symbol )			ifTrue: [ |measure|				measure := self perform: aMeasure.				^ measure quantity printShowingDecimalPlaces: 3. ].			self fail.	! !!HumBox methodsFor: 'accessing - dimensions' stamp: 'RichardAlexanderGreen 12/12/2013 13:50'!height: aQuantity	"Reset the up-down dimension."	| measure |	measure := self asMeasure: aQuantity.
	height := measure.	self assert: ( height quantity >= 0.0 ).	"Hold botton steady and force the top."	topEdge := bottomEdge + height.! !!HumBox methodsFor: 'accessing - dimensions' stamp: 'RichardAlexanderGreen 12/11/2013 13:03'!depth  "synonym"	^ length.! !!HumBox methodsFor: 'accessing - dimensions' stamp: 'RichardAlexanderGreen 12/12/2013 13:48'!length: aQuantity	"set North-South dimension"	| measure |	measure := self asMeasure: aQuantity.	"Reset the length. By convention, length runs North and South."	self assert: ( measure quantity >= 0.0 ).	length := measure.	"Hold South steady and force the North."	northEdge := southEdge + length.! !!HumBox methodsFor: 'accessing - dimensions' stamp: 'RichardAlexanderGreen 12/12/2013 13:49'!width: aQuantity	"Reset the East-West dimension"	| measure |	measure := self asMeasure: aQuantity.	self assert: (measure quantity >= 0.0 ).	width := measure.	"Hold West edge steady and force the East edge."	eastEdge := westEdge + width.! !!HumBox methodsFor: 'accessing - dimensions' stamp: 'RichardAlexanderGreen 1/31/2012 13:33'!width	"Get the width. By convention, the width runs East and West."	^ width! !!HumBox methodsFor: 'accessing - dimensions' stamp: 'RichardAlexanderGreen 1/31/2012 13:35'!length	"Get the length. By convention, length runs North and South."	^ length! !!HumBox methodsFor: 'accessing - dimensions' stamp: 'RichardAlexanderGreen 12/11/2013 12:56'!depth: aHumMeasure 	"synonym"	self length: aHumMeasure.! !!HumBox methodsFor: 'accessing - dimensions' stamp: 'RichardAlexanderGreen 8/24/2015 09:21'!volume	"Calculate the volume"	| v |	v := (self height) * (self width) * (self length).	"TODO: This should be a HumMeasure with dimension of L^3"	^v.! !!HumBox methodsFor: 'accessing - dimensions' stamp: 'RichardAlexanderGreen 1/31/2012 13:37'!height	"Get the height. By convention, height runs up and down."	^ height! !!HumBox methodsFor: 'events' stamp: 'RichardAlexanderGreen 10/8/2015 14:45'!changed	| comma |	"Notify my dependents."	super changed.	"x,y,z are HumMeasure"	comma := ', '.	"Transcript cr; 		show: 'id: ', self id, '(x,y,z): ', self centerX quantityAsString, comma, self centerY quantityAsString, comma, self centerZ quantityAsString;		show: ' (rot,tilt): ', self rotation asString, comma, self tilt asString."! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumBox class	instanceVariableNames: ''!!HumBox class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/28/2015 09:08'!id: aString 	"Instantiate an instance with these parameters"	| instance |	instance := self basicNew.	instance initialize.  "Initialize everything to zero."	instance id: aString.	^instance.! !!HumBox class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/10/2015 11:50'!id: aString  height: aHeight width: aWidth length: aLength 	"Instantiate an instance with these parameters"	| instance |	instance := self basicNew.	instance initialize.  "Initialize everything to zero."	instance id: aString  height: aHeight width: aWidth depth: aLength.	^instance.! !!HumBox class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/11/2013 13:36'!id: aString  height: aHeight width: aWidth depth: aLength 	"instantiate with these parameters"	| instance |	^self id: aString  height: aHeight width: aWidth length: aLength .! !Object subclass: #HumPolygon	instanceVariableNames: 'vertices borderColor fillColor parentSolid'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumPolygon commentStamp: 'RichardAlexanderGreen 7/29/2015 16:23' prior: 0!HumPolygon is used in HumViewPort to represent both 3D scene polygons and 2D projection ploygons.It also differs from standard Shape polygon by having a fill-color.The convention is to list vertices in a counter-clockwise direction as seen from the 'outside' of a solid. The 'normal' of the surface is thereby defined by a right-hand rule, where the resulting vector points away from the interior of the solid.!!HumPolygon methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 11/11/2015 09:29'!top	"If points are 2D, Return max y."	| maxY |	maxY := 0 meter.	self verticesDo: [ :x :y :z |  y > maxY ifTrue: [maxY := y] ].	^maxY.! !!HumPolygon methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 11/30/2015 08:57'!left	| minY |	"Trick because we collection has max: method but no min: method."	minY := self vertices max: [ :vertex | (vertex at: 2) negated ]. 	^minY negated.! !!HumPolygon methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 11/30/2015 08:48'!right	| maxY |	maxY := self vertices max: [ :vertex | (vertex at: 2) ].	^maxY! !!HumPolygon methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 11/30/2015 10:14'!bottom	"If points are 2D, Return min y or zero."	| minY  |	minY := self vertices max: [ :vertex | (vertex at: 2) negated ].	^minY negated.! !!HumPolygon methodsFor: 'testing' stamp: 'RichardAlexanderGreen 11/10/2015 11:40'!inFrontOfCamera	"Return true if at least one y-value is positive."	|  |	"This only works properly if vertices have been transformed into camera coordinates."	self verticesDo: [ :x :y :z | ( y quantity > 0.0 ) ifTrue: [ ^true ] ].	^false.! !!HumPolygon methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/22/2015 12:39'!fillColor: aColor 	fillColor := aColor! !!HumPolygon methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/22/2015 12:40'!borderColor: aColor 	borderColor := aColor! !!HumPolygon methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/7/2015 10:42'!parentSolid	"Remember where I came from."	^ parentSolid ifNil: [ Error signal: 'parentSolid not defined' ].! !!HumPolygon methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/14/2015 08:26'!borderColor	^ borderColor ifNil: [ borderColor := Color blue ].! !!HumPolygon methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/19/2016 10:25'!vertices	"The convention is to list vertices in a counter-clockwise direction as seen from the 'outside' of a solid."	^vertices ifNil: [ vertices := H3dPath new ].! !!HumPolygon methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/22/2015 13:06'!fillColor	^ fillColor ifNil: [  fillColor := Color gray. ].! !!HumPolygon methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/4/2016 09:16'!path	^self vertices.! !!HumPolygon methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/22/2015 15:38'!color: aColor 	"Specify border-color or fll-color instead."	self shouldNotBeImplemented.! !!HumPolygon methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/8/2016 08:03'!addVertex: aScenePoint 	"The convention is to list vertices in a counter-clockwise direction as seen from the 'outside' of a solid."	| calc |	"Comment: Wishing to be programmer-friendly or more generic, we allow more than one kind of point.	     Of course: There will be consequences."	calc := HumCalculator new.	calc cases;		when: [ ( self vertices size > 0 )  and: [aScenePoint = vertices last] ]			then: [ "Do not add redundant scene point." ];		when: [ ( aScenePoint isKindOf: Array ) and: [ aScenePoint size >= 2 ] ]  "Allow for 3D to 2D mapping."			then:  [ self path addVertex: aScenePoint. ];		when: [ ( aScenePoint isKindOf: Collection ) and: [ aScenePoint size = 3 ] ] "Allow for collection instead of array."			then:  [ self halt. self vertices add: aScenePoint. ];		when: [ aScenePoint isKindOf: HumVector ]			then: [ self path addVertex: { aScenePoint x. aScenePoint y. aScenePoint z. } ];			when: [ aScenePoint isKindOf: Point ]			then: [ "okay" self path addVertex: aScenePoint ];  "Viewport XY pixel coordinates"		otherwise: [ Error signal: 'Scene point is not of expected type' ].	! !!HumPolygon methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/2/2015 17:18'!parentSolid: aHumSolid 	"Remember where I came from."	parentSolid := aHumSolid. ! !!HumPolygon methodsFor: 'transforms' stamp: 'RichardAlexanderGreen 3/19/2016 15:10'!pitch: pitchAngle 	"Return a new polygon with my points adjusted by pitch about origin."	| newPolygon |	newPolygon := HumPolygon new.	self vertices do: [ :vertex |  newPolygon addVertex: (vertex pitch: pitchAngle). ].	^newPolygon! !!HumPolygon methodsFor: 'transforms' stamp: 'RichardAlexanderGreen 3/19/2016 15:17'!roll: rollAngle 	"Return a new polygon with my points adjusted by roll about origin."	| newPolygon |	newPolygon := HumPolygon new.	self vertices do: [ :vertex |  newPolygon addVertex: (vertex roll: rollAngle). ].	^newPolygon! !!HumPolygon methodsFor: 'transforms' stamp: 'RichardAlexanderGreen 3/12/2016 09:14'!yaw: yawAngle aboutPivot: pivot	"Return a new polygon with my points adjusted by yaw about origin."	| newPolygon |	newPolygon := H3dPath new.	self vertices do: [ :vertex |  newPolygon addVertex: (vertex yaw: yawAngle aboutPivot: pivot). ].	"See HumVector"	^newPolygon! !!HumPolygon methodsFor: 'transforms' stamp: 'RichardAlexanderGreen 3/11/2016 14:17'!yaw: yawAngle 	"Return a new polygon with my points adjusted by yaw about origin."	| newPolygon |	newPolygon := H3dPath new.	self vertices do: [ :vertex |  newPolygon addVertex: (vertex yaw: yawAngle). ].	"See HumVector"	^newPolygon! !!HumPolygon methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 11/30/2015 09:05'!drawOn: aHumCanvas 	aHumCanvas drawPolygon: self scale: ((5 px )/ (1 millimeter)).! !!HumPolygon methodsFor: 'enumerating' stamp: 'RichardAlexanderGreen 7/17/2015 15:18'!verticesDo: aBlockClosure 	self vertices do: [ :vertex |		| x y z |		x := vertex at: 1. y := vertex at: 2. 		(vertex size = 3) ifTrue: [ z := vertex at: 3 ] ifFalse: [ z := nil ].		aBlockClosure value: x value: y value: z. 		].! !!HumPolygon methodsFor: 'enumerating' stamp: 'RichardAlexanderGreen 11/14/2015 08:10'!asTriangles	| center triangles firstVertex priorVertex triangle |	self assert: (vertices size > 2) description: 'A polygon should have at least 3 vertices.'.	triangles := OrderedCollection new.	center := self centroid.	firstVertex := vertices first.	priorVertex := firstVertex.	vertices 		allButFirstDo:  [ :thisVertex |  			"Make a polygon with same colors"			triangle := HumPolygon borderColor: (self fillColor) fillColor: (self fillColor).			triangle parentSolid: (self parentSolid).			triangle				addVertex: center; 				addVertex: priorVertex;				addVertex: thisVertex.			triangles add: triangle.			priorVertex := thisVertex.		].			triangle				addVertex: center; 				addVertex: priorVertex;				addVertex: firstVertex.			triangles add: triangle.		^triangles.	! !!HumPolygon methodsFor: 'enumerating' stamp: 'RichardAlexanderGreen 8/20/2015 16:04'!xzPoints	"Flatten my 3D points to 2D points in X-Z (viewport/billboard) plane. "	| xzVertices  |	xzVertices := OrderedCollection new.	self verticesDo: [ :x :y :z | xzVertices add: (x@z) ].	^xzVertices.	! !!HumPolygon methodsFor: 'enumerating' stamp: 'RichardAlexanderGreen 4/4/2016 10:01'!xyPoints	"Flatten my 3D points to 2D points in X-Y (floor plan) plane"	| xyVertices |	xyVertices := OrderedCollection new.	self verticesDo: [ :x :y :z | 		self assert: ( (x isKindOf: HumMeasure) and: [x units = #px]).		xyVertices add: (x quantity) @ (y quantity). 		].	^xyVertices.	! !!HumPolygon methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 11/10/2015 17:48'!meanRsquared	"Compute the centroid of the vertices."	|  meanRsquared n |	n := self vertices size.	self assert: (n > 0).	meanRsquared := 0.	self verticesDo: [ :xMeasure :yMeasure :zMeasure |		| thisSquared x y z |		x := xMeasure quantity.		y := yMeasure quantity.		z := zMeasure quantity.		thisSquared := (x*x) + (y*y) + (z*z).		meanRsquared := meanRsquared + thisSquared.		].		^(meanRsquared / n).! !!HumPolygon methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 9/10/2015 12:51'!<= aHumPolygon 	"Z-ordering: Is my north-most point more northerly than the other."	| myNorthMost otherNorthMost result |	myNorthMost := self northMostPoint.	otherNorthMost := aHumPolygon northMostPoint.	(myNorthMost = otherNorthMost)		ifFalse: [ result := ( myNorthMost >= otherNorthMost ). ]		ifTrue: [ | myCentroid otherCentroid |			myCentroid := self centroid.			otherCentroid := aHumPolygon centroid.			result := ( myCentroid at: 2) >= (otherCentroid at: 2).			 ].		^result.! !!HumPolygon methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 11/10/2015 17:46'!maxRsquared	"Compute the centroid of the vertices."	|  maxSquared n |	n := self vertices size.	self assert: (n > 0).	maxSquared := 0.	self verticesDo: [ :xMeasure :yMeasure :zMeasure |		| thisSquared x y z |		x := xMeasure quantity.		y := yMeasure quantity.		z := zMeasure quantity.		thisSquared := (x*x) + (y*y) + (z*z).		(thisSquared > maxSquared) ifTrue: [ maxSquared := thisSquared ].		].		^maxSquared.! !!HumPolygon methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 10/19/2015 10:00'!> aHumPolygon 	"Is my north-most point more northerly than the other."	| result |	result := ( self <= aHumPolygon ) not.		^result.! !!HumPolygon methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 11/2/2015 08:34'!centroid	"Compute the centroid of the vertices."	| sumX sumY sumZ centroid n |	n := self vertices size.	self assert: (n > 2).	sumX := sumY := sumZ := 0.0 meter.	self verticesDo: [ :x :y :z |		sumX := sumX + x.		sumY := sumY + y.		sumZ := sumZ + z.		].	centroid := {  sumX / n. sumY / n. sumZ / n. }.	^centroid.! !!HumPolygon methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 11/10/2015 17:47'!minRsquared	"Compute the centroid of the vertices."	|  minSquared n |	n := self vertices size.	self assert: (n > 0).	minSquared := 0.	self verticesDo: [ :xMeasure :yMeasure :zMeasure |		| thisSquared x y z |		x := xMeasure quantity.		y := yMeasure quantity.		z := zMeasure quantity.		thisSquared := (x*x) + (y*y) + (z*z).		(thisSquared < minSquared) ifTrue: [ minSquared := thisSquared ].		].		^minSquared.! !!HumPolygon methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 10/14/2015 13:12'!northMostPoint	"Find the value of the point that is furtherest North (z-Ordering)"	| northMost |	"Hum coordinate axis point {East. North. Up.}"	northMost := ( (self vertices) first ) at: 2.	self verticesDo: [ :x :y :z | northMost := northMost max: y ].	^northMost.	! !!HumPolygon methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 10/19/2015 10:13'!rSquared	| xyz cx cy cz rSquared |	xyz  := self centroid.	cx := xyz at: 1.	cy := xyz at: 2.	cz := xyz at: 3.	rSquared := (cx*cx) + (cy*cy) + (cz*cz).	^rSquared.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumPolygon class	instanceVariableNames: 'fillColor'!!HumPolygon class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/14/2015 08:28'!parentSolid: aHumSolid fillColor: aColor 	| instance |	self assert:(aColor isKindOf: Color).	instance := self new.	instance fillColor: aColor.	instance borderColor: aColor.	instance parentSolid: aHumSolid.	^instance.! !!HumPolygon class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/22/2015 12:39'!fillColor: aColor 	| instance |	self assert:(aColor isKindOf: Color).	instance := self new.	instance fillColor: aColor.	^instance.! !!HumPolygon class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 7/17/2015 15:22'!color: aColor 	| instance |	instance := self new.	instance color: aColor.	^instance.! !!HumPolygon class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 7/22/2015 12:36'!borderColor: aColor 	| instance |	instance := self new.	instance color: aColor.	^instance.! !!HumPolygon class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 7/22/2015 12:37'!borderColor: aBorderColor fillColor: aFillColor	| instance |	instance := self new.	instance borderColor: aBorderColor;  fillColor: aFillColor.	^instance.! !!HumPolygon class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 9/2/2015 11:56'!copy: aHumPolygon withTransform: aTransformBlock	"copy the given polygon colors. Transform the vertices via the block.	The block takes :x :y :z and returns tranformed 3D { tx. ty. tz. } or tx@ty point."	| instance |	instance := self borderColor: aHumPolygon borderColor fillColor: aHumPolygon fillColor.	aHumPolygon		verticesDo: [ :x :y :z |			| transformedVertex |			transformedVertex := aTransformBlock value: x value: y value: z.			instance addVertex: transformedVertex.			 ].	^instance! !HumWidget subclass: #HumLayoutWidget	instanceVariableNames: 'widgets'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumLayoutWidget commentStamp: 'RichardAlexanderGreen 7/5/2015 12:24' prior: 0!Layout will arrange children in row or column.!!HumLayoutWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2016 14:37'!reorder: aSortBlock	"Re-order the widgets according to the given sort criteria."	self notYetImplemented.! !!HumLayoutWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/5/2015 11:34'!widgets	^ widgets ifNil: [ widgets := OrderedCollection new. ]! !!HumLayoutWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/6/2015 11:46'!addWidget: aHumWidget 	(self widgets) add: aHumWidget.! !HumLayoutWidget subclass: #HumColumnLayoutWidget	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumColumnLayoutWidget commentStamp: 'RichardAlexanderGreen 7/5/2015 12:25' prior: 0!Layout children in a column.!!HumColumnLayoutWidget methodsFor: 'Render As' stamp: 'RichardAlexanderGreen 7/6/2015 19:51'!asMorph	| layoutMorph childMorphs |	layoutMorph := AlignmentMorph new.	childMorphs := OrderedCollection new.	(self widgets) 		do: [ :widget |			 | child |			child := widget asMorph.			child cellPositioning: #topLeft; autoFit: true.			childMorphs add: child. 			].		layoutMorph  setAsColumn 				color: Color white;			vResizing: #shrinkWrap;			hResizing: #shrinkWrap;			layoutInset: 1;			wrapCentering: #center;			cellPositioning: #topLeft.				childMorphs		do: [ :each | layoutMorph addMorphBack: each ].	^layoutMorph.! !!HumColumnLayoutWidget methodsFor: 'Render As' stamp: 'RichardAlexanderGreen 7/5/2015 12:47'!asHTML	"Generate a div containing child widget renderings."	|  html calc columnGenerator |	calc := HumCalculator new.		columnGenerator := [ | innerHTML |		innerHTML := String new.		( self widgets ) do: [ :widget | 			| cellHTML |			cellHTML := calc xml: 'tr' 									with: [calc xml: 'td' 													with: [ widget asHTML ]													].			innerHTML := innerHTML, cellHTML. 			].			innerHTML. "returned value"		].	html := calc xml: 'div' 						with: [ calc xml: 'table' 										with: [  columnGenerator value  ]. 												].	^html.	! !Object subclass: #HumTextPrettyToken	instanceVariableNames: 'foregroundColor backgroundColor isBold isItalic isUnderlined fontFamily fontSize string'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumTextPrettyToken commentStamp: 'RichardAlexanderGreen 9/25/2012 19:45' prior: 0!HumTextPrettyToken is a string that may be enhanced with color, emphasis, fonts, and font weightswhen it is "pretty printed".See also: HumTextPrettyPrinter.	foregroundColor 	backgroundColor 	isBold 	isItalic 	isUnderlined 	fontFamily 	fontSize!!HumTextPrettyToken methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/7/2012 20:07'!string: aString 	self assert: ( aString isKindOf: String ).	string := aString.! !!HumTextPrettyToken methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/7/2012 20:08'!string		^ string ifNil: [ string := String new. ].! !AlphaImageMorph subclass: #HumViewPortMorph	instanceVariableNames: 'viewPort'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumViewPortMorph methodsFor: 'event handling' stamp: 'RichardAlexanderGreen 9/11/2015 18:47'!handlesMouseOver: evt	^true.! !!HumViewPortMorph methodsFor: 'event handling' stamp: 'RichardAlexanderGreen 9/11/2015 18:48'!mouseEnter: anEvent	anEvent hand newKeyboardFocus: self.! !!HumViewPortMorph methodsFor: 'event handling' stamp: 'RichardAlexanderGreen 10/15/2015 16:15'!handleKeystroke: anEvent	| keyValue keyCharacter calc dJump |	self assert: ( anEvent isKindOf: KeyboardEvent ).	dJump := 1 meter.	calc := HumCalculator new.	keyValue := anEvent keyValue.	keyCharacter := anEvent keyCharacter. 	calc cases;		when: [ keyCharacter asLowercase  = $q  ] then: [ self delete ];		when: [ keyCharacter asLowercase = $f ] then: [ self camera slideForward: dJump ];		when: [ keyCharacter asLowercase = $b ] then: [ self camera slideBackward: dJump ];		when: [ keyCharacter asLowercase = $l ] then: [ self camera slideLeft: dJump ];		when: [ keyCharacter asLowercase = $r ] then: [ self camera slideRight: dJump ];				when: [ anEvent commandKeyPressed ] 			then: [ | calc2 dTilt newTilt |				dTilt := (5 degrees). 				newTilt := (self camera tilt) + (5 degreesToRadians).				 calc2 := HumCalculator new.				calc2 cases;					when: [ keyValue = 30 "arrowUp" ] 		then: [ self camera tiltUp: dTilt ];					when: [ keyValue = 31 "arrowDown" ] 	then: [ self camera tiltDown: dTilt ];					when: [ keyValue = 28 "arrowLeft" ] 		then: [ self camera rotateLeft: dTilt ];					when: [ keyValue = 29 "arrowRight" ] 	then: [ self camera rotateRight: dTilt ];					otherwise: [ Transcript cr; show: anEvent keyString, ' keyValue not handled.' ].				];		when: [ keyValue = 30 "arrowUp" ] 		then: [ self camera slideUp: dJump ];		when: [ keyValue = 31 "arrowDown" ] 	then: [ self camera slideDown: dJump ];		when: [ keyValue = 28 "arrowLeft" ] 		then: [ self camera slideLeft: dJump ];		when: [ keyValue = 29 "arrowRight" ] 	then: [ self camera slideRight: dJump ];				otherwise: [ Transcript cr; show: anEvent keyString, ' keyValue not handled.' ].	self changed.! !!HumViewPortMorph methodsFor: 'event handling' stamp: 'RichardAlexanderGreen 9/11/2015 18:49'!mouseLeave: anEvent	anEvent hand newKeyboardFocus: nil.! !!HumViewPortMorph methodsFor: 'access' stamp: 'RichardAlexanderGreen 9/11/2015 19:34'!viewPort	^ viewPort! !!HumViewPortMorph methodsFor: 'access' stamp: 'RichardAlexanderGreen 9/11/2015 19:33'!camera	| camera |	camera := self viewPort camera.	^camera.! !!HumViewPortMorph methodsFor: 'access' stamp: 'RichardAlexanderGreen 9/11/2015 19:29'!viewPort: aHumViewPort 	viewPort := aHumViewPort.! !HumWidget subclass: #HumDateWidget	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumDateWidget commentStamp: 'RichardAlexanderGreen 4/23/2015 08:33' prior: 0!Widget enables user to view/enter a date.!!HumDateWidget methodsFor: '*HumSeaside' stamp: 'RichardAlexanderGreen 3/27/2014 16:13'!renderContentOn: aWAHtmlCanvas	"render self via a simple input tag"	| |	aWAHtmlCanvas textInput	  type: 'date'; 		attributeAt: 'id' put: (self attributeName );		callback: [:value | self store: value ];		with: (self attributeValue asString).! !HumBox subclass: #HumSolid	instanceVariableNames: 'typeOfSolid mass density material faces wireFrameColor colorStream'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumSolid commentStamp: 'RichardAlexanderGreen 8/24/2015 08:51' prior: 0!HumSolid is used to create visible VR objects such as room wallsand the parts of avatars.
It is a subtype of HumBox in that each solid is expected to have a bounding box.The methods of HumBox may be used for positioning.!!HumSolid methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/5/2013 17:26'!x3dShape: typeOfShape diffuseColor: diffuseColor specularColor: specularColor	"Produce X3D XML shape element - override instance variable color?"	| x3d calc template parameters |	calc := HumCalculator new.	template := '				<Transform translation="@position">					<Shape>						<Appearance>							<Material diffuseColor="@diffuseColor" specularColor="@specularColor" />						</Appearance>						<@typeOfShape DEF="NONE" id="@id" size="@extent" />					</Shape>				</Transform>				'.	parameters := Dictionary new.	parameters at: 'id' put: (self id);						at: 'position' put: ( self x3dCenter );	           at: 'typeOfShape' put: typeOfShape;              at: 'diffuseColor'  put: diffuseColor;              at: 'specularColor'  put: specularColor;              at: 'extent'   put: ( self x3dExtent ).	x3d := calc fillTemplate: template fromDictionary: parameters.	^x3d.! !!HumSolid methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/5/2013 12:05'!x3dShape	"Produce X3D XML shape element"	| x3d  |	"Check that my typeOfSolid instance variable is x3d compatible."	self assert: ( #( #box #cone #cylinder #sphere) includes: typeOfSolid ).	x3d := self x3dShape: (typeOfSolid asString) diffuseColor: (self x3dColor) specularColor: '0.5 0.5 0.5'.	^x3d.! !!HumSolid methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 7/17/2015 15:39'!x3dColor	"Translate my Smalltalk Color to x3dColor string"	| result sp c |	self assert: ( solidColor isKindOf: Color ).	c := solidColor.	sp := String space.	result := (c red   printShowingDecimalPlaces:2 ), sp, 	          (c green printShowingDecimalPlaces:2 ), sp, 	          (c blue  printShowingDecimalPlaces:2 ).	^result.! !!HumSolid methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/10/2013 12:56'!x3dMaterialColorRed: red green: green blue: blue alpha: alpha 	"Return X3D element for appearance/material of this color and opacity."	| x3d calc space dict |	"All of the arguments are between zero and one."	{ red. green. blue. alpha. } do: [ :x | self assert: ( x >= 0.0 and: [ x <= 1.0 ]) ].	space := String space.  calc := HumCalculator new.  dict := Dictionary new.  dict at: 'color' put: (red printShowingDecimalPlaces:2), space,                       (green printShowingDecimalPlaces:2), space,                        (blue printShowingDecimalPlaces:2), space,                       (alpha printShowingDecimalPlaces:2).	x3d := calc xml: 'material' dictionary: dict.	^x3d.! !!HumSolid methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/4/2013 12:02'!x3dExampleJSON	| json |		"Following is here to hold some useful patterns while I think over the design strategy."	json := '	{  "html": {    "-xmlns": "http://www.w3.org/1999/xhtml",    "head": {      "meta": [        {          "-http-equiv": "X-UA-Compatible",          "-content": "chrome=1"        },        {          "-http-equiv": "Content-Type",          "-content": "text/html;charset=utf-8"        }      ],      "title": "Primitives: Box, Cone, Cylinder and Sphere Primitives",      "link": {        "-rel": "stylesheet",        "-type": "text/css",        "-href": "x3dom.css"      }    },    "body": {      "h1": "Primitives: Box, Cone, Cylinder and Sphere Primitives",      "p": [        {          "-class": "case",          "X3D": {            "-xmlns": "http://www.web3d.org/specifications/x3d-namespace",            "-id": "boxes",            "-showStat": "true",            "-showLog": "false",            "-x": "0px",            "-y": "0px",            "-width": "400px",            "-height": "400px",            "Scene": {              "Background": { "-skyColor": "1 1 1" },              "Transform": [                {                  "-DEF": "coneTrafo",                  "-translation": "-4.5 0 0",                  "Shape": {                    "-DEF": "coneShape",                    "Appearance": {                      "-DEF": "coneApp",                      "Material": {                        "-diffuseColor": "0 1 0",                        "-specularColor": ".5 .5 .5"                      }                    },                    "Cone": { "-DEF": "cone" }                  }                },                {                  "-DEF": "boxTrafo",                  "-translation": "-1.5 0 0",                  "Shape": {                    "-DEF": "boxShape",                    "Appearance": {                      "-DEF": "boxApp",                      "Material": {                        "-diffuseColor": "1 0 0",                        "-specularColor": ".5 .5 .5"                      }                    },                    "Box": { "-DEF": "box" }                  }                },                {                  "-DEF": "sphereTrafo",                  "-translation": "1.5 0 0",                  "Shape": {                    "-DEF": "sphereShape",                    "Appearance": {                      "-DEF": "sphereApp",                      "Material": {                        "-diffuseColor": "0 0 1",                        "-specularColor": ".5 .5 .5"                      }                    },                    "Sphere": { "-DEF": "sphere" }                  }                },                {                  "-DEF": "cylinderTrafo",                  "-translation": "4.5 0 0",                  "Shape": {                    "-DEF": "cylinderShape",                    "Appearance": {                      "-DEF": "cylinderApp",                      "Material": {                        "-diffuseColor": "1 1 0",                        "-specularColor": ".5 .5 .5"                      }                    },                    "Cylinder": {                      "-DEF": "cylinder",                      "-radius": "1.0",                      "-height": "2.0"                    }                  }                }              ],              "Viewpoint": {                "-centerOfRotation": "0 0 0",                "-position": "0 0 15",                "-orientation": "0 1 0 0"              }            }          }        },        {          "-class": "case",          "#text": "   "        }      ],      "script": {        "-type": "text/javascript",        "-src": "x3dom.js"      }    }  }}	'.	^ json.! !!HumSolid methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 7/17/2015 15:39'!x3dMaterial	"Return X3D element for appearance/material of this color and opacity.	"	| x3d c |	self assert: ( solidColor isKindOf: Color ).	c := solidColor.	x3d := self x3dMaterialColorRed: (c red) green: (c green) blue: (c blue) alpha: (c alpha).	^x3d.! !!HumSolid methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/4/2013 12:03'!x3dExampleXML	"Example to aid design 	- This example shows how X3D is embedded in an HTML page."	| xml |	xml := '	<!!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml">	<head>        <meta http-equiv="X-UA-Compatible" content="chrome=1" />		<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />		<title>Primitives: Box, Cone, Cylinder and Sphere Primitives</title>        <link rel="stylesheet" type="text/css" href="x3dom.css" /	</head>       <body>    <h1>Primitives: Box, Cone, Cylinder and Sphere Primitives</h1>		<p class="case">		<X3D xmlns="http://www.web3d.org/specifications/x3d-namespace" id="boxes" showStat="true" showLog="false" x="0px" y="0px" width="400px" height="400px">			<Scene>				<Background skyColor="1 1 1"" />								<Transform DEF="coneTrafo" translation="-4.5 0 0">					<Shape DEF="coneShape">						<Appearance DEF="coneApp">							<Material diffuseColor="0 1 0" specularColor=".5 .5 .5" />						</Appearance>						<Cone DEF="cone" />					</Shape>				</Transform>								<Transform DEF="boxTrafo" translation="-1.5 0 0">					<Shape DEF="boxShape">						<Appearance DEF="boxApp"> 							<Material diffuseColor="1 0 0" specularColor=".5 .5 .5" />						</Appearance>						<Box DEF="box" />					</Shape>				</Transform>                				<Transform DEF="sphereTrafo" translation="1.5 0 0">					<Shape DEF="sphereShape">						<Appearance DEF="sphereApp">							<Material diffuseColor="0 0 1" specularColor=".5 .5 .5" />						</Appearance>						<Sphere DEF="sphere" />					</Shape>				</Transform>								<Transform DEF="cylinderTrafo" translation="4.5 0 0">					<Shape DEF="cylinderShape">						<Appearance DEF="cylinderApp">							<Material diffuseColor="1 1 0" specularColor=".5 .5 .5" />						</Appearance>						<Cylinder DEF="cylinder" radius="1.0" height="2.0" />					</Shape>				</Transform>                				<Viewpoint centerOfRotation="0 0 0" position="0 0 15" orientation="0 1 0 0" />			</Scene>        </X3D>	</p>		<p class="case"> &nbsp; </p>		<script type="text/javascript" src="x3dom.js"></script>   </body></html>'.	^xml.! !!HumSolid methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/10/2013 12:48'!asX3D	"Return a string in X3D notation representing this box / thing.	Caller is responsible for embedding this in a scene.	"	| template x3d calc dictionary |	"TODO: Replace this with a template implementation"	template := '	<Transform translation="@translation">		<Shape ID:="@ID">			<Appearance>				<Material diffuseColor="@diffuseColor" />			</Appearance>			<@type size="@boxExtent" />		</Shape>	</Transform>
  '.  dictionary := (Dictionary new).  dictionary 		at: 'translation' put: ( self x3dCenter );		at: 'ID' put: (self id);		at: 'diffuseColor' put: ( self x3dColor );		at: 'type' put: ( typeOfSolid );		at: 'boxExtent' put: ( self x3dExtent ).	calc := HumCalculator new.	x3d := calc fillTemplate: template fromDictionary: dictionary. 	^x3d.! !!HumSolid methodsFor: 'render via VPython' stamp: 'RichardAlexanderGreen 10/23/2014 14:46'!asVPython	| pythonCode |	pythonCode := self asVPythonThing.	^pythonCode! !!HumSolid methodsFor: 'render via VPython' stamp: 'RichardAlexanderGreen 12/12/2015 10:30'!asVPythonThing	"A solid has color and is visible."	| pythonCode |	pythonCode := id asCamelCase uncapitalized	                              ,' = BoxThing( label = "',id,'"'	                              ,', length = ', ( length quantity printShowingDecimalPlaces: 3 ) "millimeter precision"	                              ,', width = ',  ( width quantity printShowingDecimalPlaces: 3 )	                              ,', height = ', ( height quantity printShowingDecimalPlaces: 3 )								  ,', pos = ', ( self asVPythonPosition )	                              ,', aColor = color.', self color name	                              ,' )'.	^pythonCode! !!HumSolid methodsFor: 'render via VPython' stamp: 'RichardAlexanderGreen 12/12/2015 10:27'!asVPythonPosition	"Generate VPythgon code giving position."	|  comma eastString northString upString centerString |	        		comma := ', '.      		eastString := ( self westEdge + ( self width / 2 )) quantity printShowingDecimalPlaces: 3.  "Number"        northString := ( self southEdge + ( self length / 2 )) quantity printShowingDecimalPlaces: 3.        upString := ( self bottomEdge + ( self height / 2 )) quantity printShowingDecimalPlaces: 3.        centerString := '( ', eastString, comma, northString, comma, upString, ' )'.	^centerString.! !!HumSolid methodsFor: 'render as Three.js' stamp: 'RichardAlexanderGreen 12/24/2013 10:01'!asThreeJS	"Render this solid  as a cube via three.js"	| js template dictionary calc|	"Note: Caller must merge this into a scene or group geometry"	template := '			var @ID = new THREE.Mesh( ( new THREE.CubeGeometry( @width, @length, @height )  )			                            , ( new THREE.MeshBasicMaterial( { color: 0x@color } )  )			                            );			@ID.position.set( @x, @y, @z );	'. 	"TODO: Dispatch to other kinds of shapes per the solid`s type."	dictionary := Dictionary new.	dictionary	  at: 'ID'    put: ( self asCamelCase );	  at: 'color' put: ( self color printHtmlString asLowercase );		  at: 'x' put: ( self mm: ( self centerX ) );	  at: 'y' put: ( self mm: ( self centerY ) );	  at: 'z' put: ( self mm: ( self centerZ ) );		  at: 'width'  put: ( self mm: width  );	  at: 'length' put: ( self mm: length );		at: 'height' put: ( self mm: height ).			calc := HumCalculator new.	js := calc fillTemplate: template fromDictionary: dictionary.	^js. 	! !!HumSolid methodsFor: 'polygons' stamp: 'RichardAlexanderGreen 10/15/2015 16:24'!asPolygons	"Translate each face into a list of 3D points."	^self asPolygonsColoredBy: [ self solidColor ].! !!HumSolid methodsFor: 'polygons' stamp: 'RichardAlexanderGreen 11/7/2015 10:35'!asPolygonsColoredBy: aColorRule	"Generate polygons from the solid`s dimension. - Subtypes should over-ride."	"Color by evaluating the given color rule block."	"Hum coordinates are plan view. X points East. Y points North. Z points up."	|  polygon rotatedPolygons tiltedPolygons |	polygons := OrderedCollection new.	"North surface "	polygon := HumPolygon parentSolid: self fillColor: (aColorRule value). "Polygon"	polygon "Go clockwise as seen from outside the cube looking South"		addVertex: { westEdge.  northEdge. topEdge. };		addVertex: { eastEdge.  northEdge. topEdge. }; "<"		addVertex: { eastEdge.  northEdge. bottomEdge. }; "v"		addVertex: { westEdge. northEdge. bottomEdge. }. ">"	polygons add: polygon.		"East surface"	polygon := HumPolygon parentSolid: self fillColor: (aColorRule value).	polygon "Go clockwise as seen from outside the cube looking West"		addVertex: { eastEdge. northEdge. topEdge. };		addVertex: { eastEdge. southEdge. topEdge. }; "<"		addVertex: { eastEdge. southEdge. bottomEdge. }; "V"		addVertex: { eastEdge. northEdge. bottomEdge. }. ">"	polygons add: polygon copy.		"West surface"	polygon := HumPolygon parentSolid: self fillColor: (aColorRule value).	polygon "Go clockwise as seen from outside the cube looking East"		addVertex: { westEdge. southEdge. topEdge. };		addVertex: { westEdge. northEdge. topEdge. }; "<"		addVertex: { westEdge. northEdge. bottomEdge. }; "V"		addVertex: { westEdge. southEdge. bottomEdge. }. ">"	polygons add: polygon copy.		"Bottom surface"	polygon := HumPolygon parentSolid: self fillColor: (aColorRule value).	polygon "Go clockwise as seen from outside the cube looking Up and North at the bottom"		addVertex: { eastEdge. southEdge. bottomEdge. };		addVertex: { westEdge. southEdge. bottomEdge. }; "<"		addVertex: { westEdge. northEdge. bottomEdge. }; "V"		addVertex: { eastEdge. northEdge. bottomEdge. }. ">"	polygons add: polygon copy.		"Top surface"	polygon := HumPolygon parentSolid: self fillColor: (aColorRule value).	polygon "Go clockwise as seen from outside the cube looking down and North"		addVertex: { eastEdge. northEdge. topEdge. };  		addVertex: { westEdge. northEdge. topEdge. }; "<"		addVertex: { westEdge. southEdge. topEdge. }; "V"		addVertex: { eastEdge. southEdge. topEdge. }. ">"	polygons add: polygon copy.		"South surface"	polygon := HumPolygon parentSolid: self fillColor: (aColorRule value).	polygon "Go clockwise as seen from outside the cube looking North"		addVertex: { eastEdge. southEdge. topEdge. };		addVertex: { westEdge. southEdge. topEdge. }; "<"		addVertex: { westEdge. southEdge. bottomEdge. }; "V"		addVertex: { eastEdge.  southEdge. bottomEdge. }. ">"	polygons add: polygon copy.		(self rotation = 0.0) 		ifTrue: [ rotatedPolygons := polygons ]		ifFalse: [ rotatedPolygons := self rotatePolygons: polygons ].	(self tilt = 0.0) 		ifTrue: [ tiltedPolygons := rotatedPolygons ]		ifFalse: [ tiltedPolygons := self tiltPolygons: rotatedPolygons ].	^tiltedPolygons. 	! !!HumSolid methodsFor: 'polygons' stamp: 'RichardAlexanderGreen 11/10/2015 10:49'!asPolygonsColorCoded	"Color code the facets of the solid."	 ^self asPolygonsColoredBy: [ self nextColor ]. 	! !!HumSolid methodsFor: 'access' stamp: 'RichardAlexanderGreen 8/24/2015 09:39'!mass	^ mass ifNil: [ mass := (self volume) * (self density)].! !!HumSolid methodsFor: 'access' stamp: 'RichardAlexanderGreen 4/27/2013 09:47'!densityOfMaterial	| result |	"The table is held on the class side to avoid clutter and instance bloat."	result := self class densityOfMaterial: material.	^result.! !!HumSolid methodsFor: 'access' stamp: 'RichardAlexanderGreen 4/27/2013 09:41'!mass: aMeasure	"What is the mass of this object?"	self assert: ( aMeasure isKindOf: HumMeasure ).	"HumMeasure handles conversions to KMS units.	See also: methods in Number under HumMeasure category .	"	mass := aMeasure.! !!HumSolid methodsFor: 'access' stamp: 'RichardAlexanderGreen 9/3/2015 10:13'!solidColor	^solidColor ifNil: [ solidColor := Color gray. ]! !!HumSolid methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/26/2013 10:05'!material: aString 	"See also: #densityOfMaterial for names of standard materials. "	self assert: ( aString isKindOf: String ).	material := aString.! !!HumSolid methodsFor: 'access' stamp: 'RichardAlexanderGreen 4/27/2013 09:44'!density: aMeasure	"What is the average density (mass per cube) of this solid?	*** Note: Use >>densityOfMaterial when possible. ***	*** Use this method to over-ride density given by material. ***	*** Example: You might use this method to provide average density of an aggregate. ***	"	self assert: ( aMeasure isKindOf: HumMeasure ).	"HumMeasure handles conversions to KMS units.	See also: methods in Number under HumMeasure category .	"	density := aMeasure.! !!HumSolid methodsFor: 'access' stamp: 'RichardAlexanderGreen 7/17/2015 15:36'!color	^solidColor ifNil: [ solidColor := Color gray. ].! !!HumSolid methodsFor: 'access' stamp: 'RichardAlexanderGreen 12/5/2013 12:08'!initialize	super initialize.	self type: #box.! !!HumSolid methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/26/2013 10:10'!material	^ material ifNil: [ Error signal: 'Material has not been set for this solid'].! !!HumSolid methodsFor: 'access' stamp: 'RichardAlexanderGreen 10/9/2015 10:10'!weight	"Get the Earth-bound weight of the object.  (in Newtons)."	^ ( self mass ) * ( 1.0 gravity ).! !!HumSolid methodsFor: 'access' stamp: 'RichardAlexanderGreen 7/29/2015 11:46'!attachCanvas: aCanvas toFace: aSymbol 	"Attach the  canvas to the face. -- Used for billboards. 	Maybe someday for texture, costume, decoration?"	( self faces ) at: aSymbol put: aCanvas.! !!HumSolid methodsFor: 'access' stamp: 'RichardAlexanderGreen 7/20/2015 20:06'!type: aSymbol 	"TODO: Why was this coded? 	I would expect subtyping of HumSolid to provide 'type' information."	self assert: ( aSymbol isKindOf: Symbol ).	self assert: ( #( #box #rotation #elipsoid #extrusion #space ) includes: aSymbol ).	typeOfSolid := aSymbol.! !!HumSolid methodsFor: 'access' stamp: 'RichardAlexanderGreen 7/17/2015 15:35'!color: aColor 	"What id the default (background) color of the surface and interior of this solid 3D object?"	self assert: ( aColor isKindOf: Color ).	self solidColor: aColor.! !!HumSolid methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/26/2013 07:51'!density	"Return set density otherwise lookup the density of my material."	^ density ifNil: [ (self densityOfMaterial) ].! !!HumSolid methodsFor: 'access' stamp: 'RichardAlexanderGreen 7/23/2015 10:36'!faces	"Hold image/canvas to be attached to a face."	^faces ifNil: [  faces := Dictionary new. ]! !!HumSolid methodsFor: 'access' stamp: 'RichardAlexanderGreen 9/3/2015 10:14'!wireFrameColor	^wireFrameColor ifNil: [ wireFrameColor := Color black ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumSolid class	instanceVariableNames: 'materialDensity'!!HumSolid class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 12/12/2013 13:44'!id: anId type: aSymbol height: aHeight width: aWidth length: aDepth "Create an instance . . ."	| solid |	solid := self new.	"delegate to super"	solid id: anId height: aHeight width: aWidth length: aDepth.	"and add: "	solid type: aSymbol.	^solid! !!HumSolid class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 12/11/2013 13:31'!id: anId type: aSymbol height: aHeight width: aWidth depth: aDepth 	"synonym"	^ self id: anId type: aSymbol height: aHeight width: aWidth length: aDepth. ! !!HumSolid class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/27/2013 09:37'!densityOfMaterial: aMaterial	"Return the average mass-density of the given material."	| result |	aMaterial ifNil: [ Error signal: 'No material given. Cannot lookup density.'].		(( self materialDensity ) isEmpty )		ifTrue: [ "Densities are in kilogram-mass per meter^3"			materialDensity at: 'air' put: 1.2.			materialDensity at: 'foam' put: 24.         "Expanded Polystyrene Insulation"			materialDensity at: 'snow' put: 480.        "snow, compacted"			materialDensity at: 'wood' put: 708.        "red oak (denser than most). "			materialDensity at: 'ice' put: 919.         "solid ice"			materialDensity at: 'water' put: 1000.			materialDensity at: 'seawater' put: 1030.			materialDensity at: 'fiberglass' put: 1900. "Polyester and Continuous Rovings Laminate 70% E-glass"			materialDensity at: 'soil' put: 2082.       "picked wet sand as worst case. packed mud is 1906"			materialDensity at: 'sheetrock' put: 2320.  			materialDensity at: 'drywall'   put: 2320.  			materialDensity at: 'concrete' put: 2370.			materialDensity at: 'glass' put: 2580.      "window glass"			materialDensity at: 'rock'  put: 2700.      "granite, limestone, marble"			materialDensity at: 'stone' put: 2700.      "granite, limestone, marble"			materialDensity at: 'aluminum' put: 2739.			materialDensity at: 'titanium' put: 4500.			materialDensity at: 'steel' put: 7849.			materialDensity at: 'copper' put: 8900.			materialDensity at: 'lead' put: 11300.			].	result := HumMeasure quantity: (materialDensity at: (self aMaterial)) units: #kilogramPerCubicMeter.	^result.! !HumLayoutWidget subclass: #HumRowLayoutWidget	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumRowLayoutWidget commentStamp: 'RichardAlexanderGreen 7/5/2015 12:25' prior: 0!Layout children in a row.!!HumRowLayoutWidget methodsFor: 'Render As' stamp: 'RichardAlexanderGreen 1/8/2016 11:43'!asMorph	| morph childMorphs |	morph := AlignmentMorph new.	childMorphs := OrderedCollection new.	(self widgets) do: [ :widget | childMorphs add: (widget asMorph) ].	morph inARow: childMorphs.	morph cellPositioning: #topLeft.	^morph.! !!HumRowLayoutWidget methodsFor: 'Render As' stamp: 'RichardAlexanderGreen 7/5/2015 12:36'!asHTML	"Generate a div containing child widget renderings."	|  html calc rowGenerator |	calc := HumCalculator new.		rowGenerator := [ | innerHTML |		innerHTML := String new.		( self widgets ) do: [ :widget | 			| cellHTML |			cellHTML := calc xml: 'td' with: [ widget asHTML ].			innerHTML := innerHTML, cellHTML. 			].			innerHTML. "returned value"		].	html := calc xml: 'div' 						with: [ calc xml: 'table' 										with: [ calc xml: 'tr' 														with: [ rowGenerator value  ] 												]  								].	^html.	! !HumSolid subclass: #HumExtrusion	instanceVariableNames: 'polygon path'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumExtrusion commentStamp: 'RichardAlexanderGreen 10/26/2015 16:59' prior: 0!The surface of the solid is defined by a xy-list of points. that is extruded along a 3D path.The polygon must have a 0@0 point.The 3D path directs how the 0@0 point is dragged to produce the extrusion.!!HumExtrusion methodsFor: 'render via VPython' stamp: 'RichardAlexanderGreen 12/12/2015 09:06'!asVPython	self shouldBeImplemented ! !!HumExtrusion methodsFor: 'polygons' stamp: 'RichardAlexanderGreen 6/23/2016 11:34'!asPolygonsColoredBy: aColorRule	self shouldBeImplemented.	"To create a set of layers, 	translate the polygon`s points 	 so that the 0@0 point is translated to each point in the guide path."	"Create  polygons (triangles) by connecting the layers."	self shouldBeImplemented ! !!HumExtrusion methodsFor: 'access' stamp: 'RichardAlexanderGreen 12/12/2015 09:14'!polygon: aHumPolygon	"Define the polygon that will be extruded along a path."	self assert: (aHumPolygon isKindOf: HumPolygon).	polygon := aHumPolygon.	self shouldBeImplemented ! !!HumExtrusion methodsFor: 'access' stamp: 'RichardAlexanderGreen 10/26/2015 16:59'!path: a3DPath	"Define the 3D path used to extrude the polygon."	path := a3DPath.! !Object subclass: #HumEditor	instanceVariableNames: 'lineIndex characterIndex text keyboardActions selectionStart selectionEnd selectionAnchor undoStack redoStack'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumEditor commentStamp: 'RichardAlexanderGreen 6/24/2016 09:04' prior: 0!A HumEditor is attached to HumText.The editor provides the means to modify the text. (text is model, editor is controller - but not a viewer)(See also HumWidget, HumCanvas, )The editor has a cursorPosition  which defines where a cursor might be rendered  and where character inserts and deletes may occur.The editor has a 'selection' which defines a part of the text that might be highlighted and processed.---Editor Actions   1. Usual text edit actions:      a) cursor moves: (up, down, left, right, top, bottom, . . .)      b) selection moves: (shift-up, shift-down, shift-right, shift-left)      c) commands: (copy, cut, paste)      d) undo?    2. PA-specific actions:      a) [Line updated] event causes the logical-line and frame to be checked.         (1) The logical-line is rendered. 	           Keywords and nouns are emphasized. Nouns have links.          (2) If the logical-line is not understood (no definition in ontology or DSL),                the line is flagged (with a question-mark).         (3) If a noun lacks an antecedent in the frame, the noun is flagged (color code).      b) [Insert/Append Instruction] - Instructions are indented.         (1) In an action frame,                the automatic indent matches the preceding statement’s indent                unless it was a control statement (ending with a colon).                   And then, the indentation is increased by one.         (2) In plan and dialog frames,                instructions have only one level of indent                because control statements are not allowed in those contexts.         (3) In dialog frames,                the user indicates an instruction by starting the line with dot [tab].---!!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/14/2014 13:48'!update: aText	"When text is updated, we are informed. Put on undo stack."	self undoStack add: aText copy.	"TODO: Also track the cursor. 	self undoStack add: { aText copy. lineIndex. characterIndex. }	"! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 17:42'!text	^ text ifNil: [ text := HumText new ].! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/8/2014 23:30'!selectionAnchor	"Return selection anchor."	^ selectionAnchor ifNil: [selectionAnchor := lineIndex @ characterIndex ].! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 18:37'!addLine: aString 	"Delegate to HumText instance."	(self text) addLine: aString! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/9/2014 11:34'!initialize	"Set up undo stack and notification."	self undoStack.! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/9/2014 10:33'!insertCharacter: aCharacter 	"Insert a character into the text at the current (cursor) position"	| humTextLine currentLine currentIndex stringUpto stringAfter newLine |	humTextLine := (self lines) at: (self lineIndex).	currentLine := humTextLine string.	currentIndex := self characterIndex.	( currentIndex >= currentLine size )		ifFalse: [	stringUpto := currentLine copyFrom: 1 to: currentIndex.					stringAfter := currentLine copyFrom: ( currentIndex +1 ) to: (currentLine size).					]		ifTrue: [ 	stringUpto := currentLine copy.			       	stringAfter := ''. 					].		newLine := stringUpto, (aCharacter asString), stringAfter.	humTextLine string: newLine.	"notify model"	text changed.	"(self lines) at: (self lineIndex) put: humTextLine."	"Advance the cursor."	self characterIndex: (self characterIndex + 1).	! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/9/2014 10:56'!deletePriorCharacter	"Insert a character into the text at the current (cursor) position"	| humTextLine currentLine stringUpto stringAfter newLine currentIndex  |	"If cursor is at the front of the line, delete is a no op."	currentIndex := (self characterIndex).	( currentIndex = 0 ) ifTrue: [ Beeper beep. ^self ].	"Otherwise . . ."	humTextLine := (self lines) at: (self lineIndex).	currentLine := humTextLine string.	( currentIndex >= currentLine size )				ifTrue: [ 	"Delete the last character in the line."						stringUpto := currentLine copyFrom: 1 to: (currentLine size - 1).			       stringAfter := ''. 					]				ifFalse: [	 "Delete the character left of the cursor."						 stringUpto := currentLine copyFrom: 1 to: (currentIndex - 1).					   stringAfter := currentLine copyFrom: (currentIndex+1) to: (currentLine size).					].		newLine := stringUpto,  stringAfter.	humTextLine string: newLine.	text changed.	"(self lines) at: (self lineIndex) put: humTextLine."	"Back the cursor."	self characterIndex: currentIndex - 1.	! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/8/2014 12:39'!emptySelection	"The selection is empty.	start and end are at current cursor"	selectionAnchor := lineIndex @ characterIndex.	selectionStart := selectionAnchor.	selectionEnd   := selectionAnchor.! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 20:51'!currentLine	| result |	result := ( self lines ) at: ( self lineIndex ).	^result.! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/8/2014 23:18'!characterIndex: aSmallInteger 	"character index ranges from 0 (left of line) to ()"	| n |	characterIndex := aSmallInteger.		(characterIndex < 0 ) 		ifTrue: [ characterIndex := 0.			self beep.			].		n := ( text lines at: lineIndex	) size.		(characterIndex > n ) 		ifTrue: [ characterIndex := n.			self beep.			]. ! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/9/2014 10:19'!updateSelection	"Selection extends from an anchor-point to current cursor position.	Constraint: Start < End.	"	| currentRowColumn anchorRow currentRow anchorColumn currentColumn calc |	currentRow := self lineIndex.	currentColumn := self characterIndex.	currentRowColumn := currentRow @ currentColumn.	anchorRow := selectionAnchor x.	anchorColumn := selectionAnchor y.		calc := HumCalculator new.	calc cases;		when: [currentRow > anchorRow] then: [selectionStart := selectionAnchor. selectionEnd   := currentRowColumn];		when: [currentRow < anchorRow] then: [selectionEnd   := selectionAnchor. selectionStart := currentRowColumn];		when: [currentColumn > anchorColumn] then: [selectionStart := selectionAnchor. selectionEnd   := currentRowColumn];		when: [currentColumn <= anchorColumn]then: [selectionEnd  := selectionAnchor. selectionStart := currentRowColumn];		otherwise: [Error signal: 'programming error'].					! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 10:46'!characterIndex	"Character index is equal to the number of charactes to the left of the cursor."	^ characterIndex ifNil: [ characterIndex := 0 ].! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 10:36'!lines	^ self text lines.! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 10:08'!lineIndex	^ lineIndex ifNil: [ lineIndex := 1 ].! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/14/2014 13:44'!selectedText	"Return selected text as a string with CR inserted as needed at ends of lines."	| result calc startRow startColumn endRow endColumn line|	calc := HumCalculator new.	result := String new.	startRow  := selectionStart x.	endRow    := selectionEnd x.		(startRow to: endRow) 	 do: [ :row | 		line := (text lines at: row ) string.		calc cases;			when: [row = startRow and: [row < endRow]] 				then: [startColumn := selectionStart y. endColumn := line size. ];			when: [row = startRow and: [row = endRow]] 				then: [startColumn := selectionStart y. endColumn := selectionEnd y. ];			when: [row = endRow and: [row > startRow]]   				then: [startColumn := 0. endColumn := selectionEnd y. ];			otherwise: [Error signal: 'eh?'].		(endColumn > line size) ifTrue: [endColumn := line size].				(startColumn+1 to: endColumn)			do: [:column |				result := result, ((line at: column) asString).				].		 (endRow > startRow and: [(row < endRow) and: [endColumn = line size]]  ) 				ifTrue:	[result := result, String cr]		].		^result.! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 20:32'!lineIndex: aSmallInteger 	| maxLine |	lineIndex := aSmallInteger.	maxLine := ((self text ) lines size).	( lineIndex >  maxLine ) ifTrue: [ lineIndex := maxLine].	( lineIndex < 1 ) ifTrue: [ lineIndex := 1 ].! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/13/2014 19:46'!insertLine	"Delegate to our HumText instance"	self text insertEmptyLineAfter: (self lineIndex).	"Adjust the cursor to point to the beginning of the new line."	lineIndex := lineIndex + 1.	characterIndex := 0.			! !!HumEditor methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 10/14/2014 12:49'!redo	"Replace text with text that was replaced at last undo."	| stack replacedText |	stack := self redoStack.	stack ifEmpty: [ self beep. ^self ].	replacedText := stack removeLast.	text := replacedText.! !!HumEditor methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 10/13/2014 18:54'!undoStack	undoStack 		ifNil: [ "Setup notification. See #update:"			      self text addDependent: self.						"Initialize stack"			      undoStack := OrderedCollection new.			      undoStack add: text copy. ].	^undoStack.	! !!HumEditor methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 12/10/2015 10:14'!interpretKey: aSymbol 	"Interpret various keyboard gestures."	| action |	keyboardActions ifNil: ["initialize"		keyboardActions := Dictionary  new.		keyboardActions			"Simple arrow keys"			at: #arrowUp      put: [ self lineIndex: ( (self lineIndex) - 1 ).  self emptySelection. ];			at: #arrowDown put: [ self lineIndex: ( (self lineIndex) + 1 ).  self emptySelection. ];			at: #arrowLeft   put: [ self characterIndex: ( (self characterIndex ) - 1).  self emptySelection. ];			at: #arrowRight put: [ self characterIndex: ( (self characterIndex ) + 1).  self emptySelection. ];						"Alt-Arrow keys"			at: #altArrowUp      put: [ self lineIndex: 1. self emptySelection.];			at: #altArrowDown put: [ self lineIndex: ( self lines size ). 				                                  self characterIndex:  (self currentLine string size). self emptySelection. ];			at: #altArrowLeft   put: [ self characterIndex: 0. self emptySelection. ];			at: #altArrowRight  put: [ self characterIndex: (self currentLine string size). self emptySelection. ];						"Shift-Arrow keys move cursor same as simple arrow keys, but selection is updated."			at: #shiftArrowUp      put: [ self lineIndex: ( (self lineIndex) - 1). self updateSelection. ];			at: #shiftArrowDown put: [ self lineIndex: ( (self lineIndex) + 1 ). self updateSelection. ];			at: #shiftArrowLeft    put: [ self characterIndex: ( (self characterIndex ) - 1). self updateSelection. ];			at: #shiftArrowRight  put: [ self characterIndex: ( (self characterIndex ) + 1). self updateSelection. ];						"Escape key is a no-op at this time."			at: #escape put: [ Beeper beep ].		 ].	"Interpret the symbol (keyboard action name) given"	action := keyboardActions at: aSymbol 						ifAbsent: [ Error signal: 'No action for: ', (aSymbol asString)].	action value.	! !!HumEditor methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 10/8/2014 23:18'!beep	"If sound is enabled, beep."				Beeper beep.! !!HumEditor methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 10/14/2014 12:50'!redoStack	^ redoStack ifNil: [ redoStack := OrderedCollection new ].! !!HumEditor methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 10/14/2014 13:46'!undo	"Replace text with last item from undo stack."	| stack priorText replacedText |	stack := self undoStack.	stack ifEmpty: [ Error signal: 'Undo stack should never be empty'. self beep. ^self].	(stack size = 1) ifTrue: [self beep. ^self].		"last contains current text"	self assert: ( stack last = text ).	replacedText := stack removeLast. 	self redoStack add: replacedText.	stack ifEmpty: [Error signal: 'programming error?'].	"Now top contains priorText"	priorText := stack last.	text := priorText.	"TODO: Keep track of where the cursor was."! !DisplayObject subclass: #HumCanvas	instanceVariableNames: 'brushPosition formCanvas brushColor pixelsPerMillimeter skyColor'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumCanvas commentStamp: 'RichardAlexanderGreen 1/15/2016 14:47' prior: 0!A Canvas is a surface on which to paint. (It is not interactive. See HumScribe)HumCanvas provides a wrapper on an actual implementation.The goal is to keep the API simple.Where Canvas / FormCanvas / . . .  provide more than one way to accomplish the same thing, HumCanvas should provide just one.Use Cases:- Set and position brush:- - canvas brush: aForm.  (TODO: Replace this with something that is not raster-based.)- - canvas moveTo: aPoint. (Note: points are in pixel coordinates.)- Draw lines.- - canvas drawTo: aPoint. - Draw curves:- - canvas drawCurve: aListOfPoints. - Draw and fill polygons.- - drawPolygon: aPolygon.  (HumPolygon attributes include vertices, fill-color, border-color.)- - drawPolygonBorderedPolygon: aPolygon. (Use current brush to draw border)- Draw text.- - drawText: aText. (Defaults to vector-based font, and round-nib pen.)- - drawText: aText brush: aForm font: aVectorFont. - Paint images.- - loadImageFromFileNamed: aFileName.- - paintImageOnSurface: aHumSurface scale: pixelsPerMillimeter.=========================Consider possible future use cases:- Enable canvas to be a 3D surface. - - I prefer parameterized design to hand-crafting.- - Accordingly, I also prefer textures that are determined by a solid`s specified material and algorithmically painted rather then mapping from flat images.!!HumCanvas methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 8/9/2015 09:53'!brushColor	"Get my brush color."		^brushColor ifNil: [brushColor := Color black].! !!HumCanvas methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 8/9/2015 09:54'!brushPosition	"Get my latest brush position."	^brushPosition ifNil: [ Error signal: 'brush position has not been set' ]! !!HumCanvas methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 8/28/2015 11:19'!scalePixelsPerMillimeter	"How many pixels per millimeter of camera viewbox?"	^ pixelsPerMillimeter ifNil: [ 4 ].! !!HumCanvas methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 8/26/2015 21:56'!drawTextLines: textLines withFont: aFont	| lineHeight em myCanvas |	lineHeight := aFont height.	em := aFont linearWidthOf: $m.	myCanvas := (self formCanvas)."FormCanvas"	textLines		keysAndValuesDo: [ :key :value |			| string |						string:= "(key printPaddedWith: Character space to: 3 ), ' ', " value.			myCanvas drawString: string at: em@(key*(lineHeight)) font: aFont color: (Color black). 			].! !!HumCanvas methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 8/11/2015 10:36'!formCanvas: aFormCanvas 	"What form should I draw on."	formCanvas := aFormCanvas.	self fillBackground.! !!HumCanvas methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 8/27/2015 07:01'!moveBrushTo: aCanvasPoint	"Position the brush, but do not paint yet."	|  |	self assert: (aCanvasPoint isKindOf: Point).	self brushPosition: aCanvasPoint.	 	! !!HumCanvas methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 10/5/2015 10:52'!skyColor: aColor	"What color to use for background fill?"	skyColor := aColor.! !!HumCanvas methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 8/26/2015 21:55'!borderWidth: aWidth borderColor: aColor 	self formCanvas form border: (formCanvas form boundingBox) width: aWidth fillColor: aColor.! !!HumCanvas methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 8/28/2015 11:17'!scalePixelsPerMillimeter: aNumber	"How many pixels per millimeter of viewbox?"	pixelsPerMillimeter := aNumber.! !!HumCanvas methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 11/3/2015 09:11'!projectScenePoint: aScenePoint cameraDepth: aCameraDepth	"Translate from scene coordinates (meters) to canvas coordinates (px)"	| aCanvasPoint  sceneX sceneY sceneZ screenX screenY x y xOffset yOffset dxdy dzdy |	self assert: (aScenePoint isKindOf: Array ).	self assert: (aScenePoint size > 1).	"Map East-West to x; North-South to y; Up-Down to z, Time to w."	sceneX := aScenePoint at: 1.	sceneY := aScenePoint at: 2.	sceneZ := aScenePoint at: 3.		dxdy := (sceneX / sceneY) quantity.  "East over North"	dzdy := (sceneZ / sceneY) quantity.		screenX :=  aCameraDepth * dxdy.	screenY :=  aCameraDepth * dzdy.		x := (screenX * (self scalePixelsPerMillimeter)) quantity rounded.	y := (screenY * (self scalePixelsPerMillimeter)) quantity rounded.		xOffset := self formCanvas form width // 2.	yOffset := self formCanvas form height // 2.	aCanvasPoint := ( x + xOffset )@(y +  yOffset). 	^aCanvasPoint.! !!HumCanvas methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 11/3/2015 10:25'!paintTo: aCanvasPoint 	self assert: (aCanvasPoint isKindOf: Point).	"The point should be inside the canvas bounds. Rectangle"	self assert: (self formCanvas clipRect containsPoint: aCanvasPoint ) 	      description: 'Attempt to move brush beyond canvas: ', (aCanvasPoint asString).	"TODO: Put pixels from brush onto my Form."	self formCanvas line: self brushPosition to: aCanvasPoint width: 2 color: self brushColor.	self brushPosition: aCanvasPoint.! !!HumCanvas methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 8/9/2015 09:53'!brushPosition: aPoint 	"Remember my latest brush position."	brushPosition := aPoint! !!HumCanvas methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 8/9/2015 10:15'!formCanvas 	"What form should I draw on."	^formCanvas ifNil: [  formCanvas := FormCanvas on: (Form extent: DisplayScreen boundingBox extent depth: 32) ].! !!HumCanvas methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 10/5/2015 10:54'!skyColor	"What color to use for background fill?"	^ skyColor ifNil: [ skyColor := Color cyan lighter lighter  ]! !!HumCanvas methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 1/15/2016 15:14'!about"Q: What is the relation between Sensor, Scribe, Widget, Canvas, Solid, ViewPort.A: The Scribe interprets inputs from the Sensor and updates a Widget.The Widget is drawn on a Canvas which is painted on a Surface.A Surface might be painted on a Solid within a Scene.Note: A Surface is not rendered if it is not visible to the Viewport`s Camera. The flow is Sensor >> Scribe >> Widget >> Canvas >> Surface >> ViewPort (Camera)."! !!HumCanvas methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 4/4/2016 10:08'!scalePoint: aScenePoint scaleRatio: pxPerMeter 	"Return a x@y point by scaling the given scene point"	| sceneX sceneY canvasX canvasY |	(((aScenePoint isKindOf: HumVector) 		or: [aScenePoint isKindOf: Array])		or: [aScenePoint isKindOf: OrderedCollection]	)		ifFalse: [ Error signal: 'Scene Point is not of expected type' ].	sceneX := aScenePoint at: 1.	sceneY := aScenePoint at: 2.	( sceneX isPixels ) 		ifTrue: [ "Already scaled."			canvasX := sceneX quantity rounded. 			canvasY := sceneY quantity rounded. 			] 		ifFalse: [ "Apply scale factor"			canvasX := ( sceneX * pxPerMeter ) quantity rounded. 			canvasY := ( sceneY * pxPerMeter ) quantity rounded.			].	^ canvasX @ canvasY.		! !!HumCanvas methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 10/5/2015 10:49'!fillBackground	| rectangle fillColor |	fillColor := self skyColor.	rectangle := Rectangle origin: 0@0 extent: formCanvas  extent .	"self formCanvas 				frameAndFillRectangle: rectangle 				fillColor: fillColor 				borderWidth: 2 topLeftColor: fillColor bottomRightColor: fillColor."	self formCanvas form fillWithColor: fillColor.! !!HumCanvas methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 8/9/2015 09:52'!brushColor: aColor 	"Set my brush color."	self assert: ( aColor isKindOf: Color ).	brushColor := aColor.! !!HumCanvas methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 9/11/2015 18:41'!asMorph	| morph baseForm |	"morph := self formCanvas form asMorph."	baseForm :=  self formCanvas form.	morph := HumViewPortMorph withForm: baseForm.	morph isOpaque: true. 	^morph.	! !!HumCanvas methodsFor: 'drawing-polygons' stamp: 'RichardAlexanderGreen 11/3/2015 10:23'!drawHumPolygon: aHumPolygon 	"The HumPolygon contains 3D points  and specifies fill and border colors. 	We translate to 2D and draw on our form."	| polygonVertices  borderWidth aBorderColor firstPoint  |	borderWidth := 3.  "TODO: MAGIC NUMBER."	aBorderColor := aHumPolygon borderColor.	self brushColor: aBorderColor.	"aFillColor := aHumPolygon fillColor."	"Transform to 2D points"	polygonVertices := aHumPolygon xyPoints. 	firstPoint := "self scaleScenePoint:" ( polygonVertices at: 1 ).	self moveBrushTo: firstPoint.	polygonVertices allButFirstDo: [ :vertex |			| nextPoint |			nextPoint := "self scaleScenePoint:" vertex.			self paintTo: nextPoint.			 ].	self paintTo: firstPoint.! !!HumCanvas methodsFor: 'drawing-polygons' stamp: 'RichardAlexanderGreen 7/22/2015 15:31'!drawPolygon: aHumPolygon scale: pxPerMeter 	|  vertices  |	self assert: ( aHumPolygon isKindOf: HumPolygon).	self assert: ( pxPerMeter isKindOf: HumMeasure).		self brushColor: aHumPolygon borderColor.	vertices := aHumPolygon vertices.	self moveBrushTo: ( self scalePoint: (vertices first) scaleRatio: pxPerMeter ).	vertices allButFirstDo: [ :vertex |  self paintTo: (self scalePoint: vertex scaleRatio: pxPerMeter) ].	self paintTo: ( self scalePoint: (vertices first) scaleRatio: pxPerMeter).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumCanvas class	instanceVariableNames: 'canvas'!!HumCanvas class methodsFor: 'instance-creation' stamp: 'RichardAlexanderGreen 9/26/2015 10:15'!extent: anExtent 	"Create an instance with the give extent (pixel metrics)"	| instance actualCanvas |	instance := self new.	actualCanvas := FormCanvas extent: anExtent depth: nil origin: 0@0 clipRect: (Rectangle origin: 0@0 extent: anExtent ).	instance formCanvas:  actualCanvas.	^instance.	! !!HumCanvas class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 9/26/2015 10:18'!extent: anExtent depth: aDepth origin: anOrigin clipRect: aClipRectangle	"Create an instance with the given extent, origin, and clipping rectangle - given in pixel metrics."	| internalCanvas instance |	internalCanvas := FormCanvas extent: anExtent depth: aDepth origin: anOrigin clipRect: aClipRectangle.	instance := self new.	instance formCanvas: internalCanvas.	^instance.! !!HumCanvas class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 9/26/2015 10:19'!onForm: aForm 	"Create an instance using the given form."	| instance |	instance := self new.	instance formCanvas: (FormCanvas on: aForm).	^instance.! !HumWidget subclass: #HumTextWidget	instanceVariableNames: 'rows'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumTextWidget commentStamp: 'RichardAlexanderGreen 12/11/2015 10:35' prior: 0!Widget enables a user to view/enter/edit a multi-line text value for an attribute.Expect "Text" datatype to be used for attributes that are short descriptions, diary entries, brief instructions.Typical values may contain "end-of-line" charactersand slots display at least two lines.Note: The  "tab" and "return" keystrokes may mean "indent" and "newline" in this view-context.See also: HumText HumTextEditor!!HumTextWidget methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/10/2016 09:16'!asMorph	| morph |	"Instantiate a TextMorph of some kind."	morph := self attributeValue asTextMorph.	"Set some visual properties."	morph 		backgroundColor: Color white;		margins: 5;		borderWidth: 2.	"TODO: Wire up the UI interaction: 	  KeyStroke >> Morph(TextMorphForEditView ) >> HumTextWidget >> HumTextEditor >> HumText"	^morph.! !!HumTextWidget methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 7/6/2015 11:09'!asHTML	"Generate HTML textarea element"	| html calc |	calc := HumCalculator new.	html := calc xml: 'textarea' with: [ self attributeValue ].	^html.! !!HumTextWidget methodsFor: '*HumSeaside' stamp: 'RichardAlexanderGreen 3/26/2014 16:50'!renderContentOn: aWAHtmlCanvas	"render self via a text area tag"	| |	aWAHtmlCanvas textArea 		attributeAt: 'id' put: (self attributeName );		rows: (self rows);		callback: [:value | self store: value ];		with: (self attributeValue asString).! !!HumTextWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/9/2014 11:05'!rows	"How many rows should we display?" 	^ rows! !!HumTextWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/9/2014 11:04'!rows: aSmallInteger	"How many rows should we display?" 	rows := aSmallInteger. ! !HumWidget subclass: #HumImageWidget	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumImageWidget commentStamp: 'RichardAlexanderGreen 1/15/2016 14:36' prior: 0!a container for a read-only imageDisplay an attribute whose datatype is some kind of image. (TODO)!HumSolid subclass: #HumSpace	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumSpace commentStamp: 'RichardAlexanderGreen 6/23/2016 11:36' prior: 0!HumSpace is a synoym for HumBox.It is provided to make code more readable.The intent is that you would use HumSolid to model things that are mostly solid, like walls,but you would use HumSpace to model things that are hollow (filled with air) for things like rooms, doorways, gardens, landscapes.Consider: A HumWall (TBD) might have HumSurface objects mapped to its main faces. !!HumSpace methodsFor: 'render via VPython' stamp: 'RichardAlexanderGreen 12/12/2015 10:32'!asVPythonThing	"A space has no color and is not visible."	| pythonCode |	pythonCode := id, ' = BoxThing( label = "',id,'"'	                              ,', length = ', (length quantity printShowingDecimalPlaces: 3) "millimeter precision"	                              ,', width = ',   (width quantity printShowingDecimalPlaces: 3)	                              ,', height = ', (height quantity printShowingDecimalPlaces: 3)								  ,', pos = ', ( self asVPythonPosition )	                              ,', visible = false'	                              ,' )'.	^pythonCode! !!HumSpace methodsFor: 'polygons' stamp: 'RichardAlexanderGreen 10/7/2015 19:46'!asPolygons	"Return an empty collection of polygons - HumSpace is not drawn. It is used for spacing in layout logic."	^ 	OrderedCollection new.! !!HumSpace methodsFor: 'polygons' stamp: 'RichardAlexanderGreen 10/7/2015 19:46'!asPolygonsColorCoded	"Return an empty collection of polygons - HumSpace is not drawn. It is used for spacing in layout logic."	^ 	OrderedCollection new.! !Object subclass: #HumSurface	instanceVariableNames: 'top bottom left right origin width height layer id title shapes backgroundColor canvas borderColor fillColor defaultUnits'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumSurface commentStamp: 'RichardAlexanderGreen 11/11/2015 10:16' prior: 0!HumSurface is like a movable canvas - a rectangular 2D surface.Instance Variables:	(Values are HumMeasure - e.g. 'px' for pixels)	top   <Number> -- top edge Y value                   (The values for edge positions are relative to the container.)	bottom	<Number> -- bottom edge Y value	left	  <Number> -- left edge X value	right	<Number> -- right edge X value			width	<Number> -- X extent	height	<Number> -- Y extent	layer	<Number> -- Z-order. Surfaces with higher layer numbers will overlay those with lower numbers.			origin	<HumSurface> -- a zero-size object positioned at (left top layer) = ( 0 0 0 )		(origin is private -- It provides syntax sugar.)	shapes	<Set> -- A set of dependent (child) shapes. 		The children are rendered after I am.!!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 7/23/2015 10:19'!place: aHumSurfaceB rightOf: aHumSurfaceA 	"Place B right of A on the surface. "		"Assure that A and B are in my collection."	self addShape: aHumSurfaceA.	self addShape: aHumSurfaceB.		"By convention, set B's right to be equal to A's left.	i.e. There is no gap / gutter."	aHumSurfaceB left: ( aHumSurfaceA right ).		"By convention, B is now in the same layer as A."	aHumSurfaceB layer: ( aHumSurfaceA layer ).		! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 7/23/2015 10:17'!overlay: aHumSurfaceB onTopOf: aHumSurfaceA 	"Both shapes are assumed (forced) to be present in my collection."	self addShape: aHumSurfaceA.	self addShape: aHumSurfaceB.	"By convention, surface B will be aligned with A's top and left edges."	aHumSurfaceB top: (aHumSurfaceA top).		aHumSurfaceB left: (aHumSurfaceA left).	"By convention, surface B will be placed in a higher numbered layer."	"Note: If there already was already another shape on top and in same layer, 	   there is no attempt to place this one in-between."	aHumSurfaceB layer: (aHumSurfaceA layer) + 1.	! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 7/23/2015 10:18'!place: aHumSurfaceB above: aHumSurfaceA 	"Place B above A on the surface. 	(Not to be confused with putting B on a different layer.)"		"Assure that A and B are in my collection."	self addShape: aHumSurfaceA.	self addShape: aHumSurfaceB.		"By convention, set B's bottom will be equal to A's top.	i.e. There is no gap."	aHumSurfaceB bottom: ( aHumSurfaceA top ).		"By convention, B is now in the same layer as A."	aHumSurfaceB layer: ( aHumSurfaceA layer ).		! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 7/23/2015 10:19'!place: aHumSurfaceB below: aHumSurfaceA 	"Place B below A on the surface. (Not to be confused with putting B on a different  layer.)"	"TODO: Consider making calls to top: right: left: using blocks (closures) so that everything is dynamic.	 Counter: Use relative positions. 	          When rendering, we will iterate (self shapes). 	          If child shape positions are relative, we get the same effect.	"		"Assure that A and B are in my collection."	self addShape: aHumSurfaceA.	self addShape: aHumSurfaceB.		"By convention, set B's top to be equal to A's bottom.	i.e. There is no gap."	aHumSurfaceB top: ( aHumSurfaceA bottom ).		"By convention, B is now in the same layer as A."	aHumSurfaceB layer: ( aHumSurfaceA layer ).		! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 11/11/2015 09:14'!expandToFit	|  |	((self height) < (self bbHeight)) ifTrue: [self height: (self bbHeight)].	((self width) < (self bbWidth)) ifTrue: [self width: (self bbWidth)].	! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 7/23/2015 10:18'!place: aHumSurface at: anArray 	| x y z |	x := anArray at: 1.	y := anArray at: 2.	z := anArray at: 3.		self addShape: aHumSurface.	aHumSurface top: y; left: x; layer: z.! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 7/23/2015 10:19'!place: aHumSurfaceB leftOf: aHumSurfaceA 	"Place B left of A on the surface. "		"Assure that A and B are in my collection."	self addShape: aHumSurfaceA.	self addShape: aHumSurfaceB.		"By convention, set B's left to be equal to A's right.	i.e. There is no gap / gutter."	aHumSurfaceB left: ( aHumSurfaceA right ).		"By convention, B is now in the same layer as A."	aHumSurfaceB layer: ( aHumSurfaceA layer ).		! !!HumSurface methodsFor: 'render as HTML' stamp: 'RichardAlexanderGreen 7/13/2015 08:34'!asHtmlCanvasOffsetX: offsetX y: offsetY	"Return a HTML <rect . . . /> element for this surface."	| xml canvasAttributes nextLayer viewX viewY calc |	xml := String new.	canvasAttributes := Dictionary new.	( id notNil ) ifTrue: [ canvasAttributes add: 'id' -> id ].		"Don't scale dimensions in this version"	canvasAttributes at: 'width' put: width asString.	canvasAttributes at: 'height' put: height asString.	viewX := left + offsetX.	viewY := top + offsetY.		canvasAttributes at: 'x' put: viewX asString.	canvasAttributes at: 'y' put: viewY negated asString.  "Flip our Y value because HTML has Y pointing down."	canvasAttributes at: 'style' put: 'border:3px solid black;'.	calc := HumCalculator new.	xml := '  ', ( calc xml: 'canvas' dictionary: canvasAttributes ), String cr  .		nextLayer := ''.	(self shapes )		do: [ :shape | 			nextLayer := nextLayer, (shape asHtmlCanvasOffsetX: viewX y: viewY).			].	xml := xml, nextLayer.	^xml. 		! !!HumSurface methodsFor: 'render as HTML' stamp: 'RichardAlexanderGreen 10/30/2012 14:04'!asHTML	" Render surface as HTML"	| myBlock html calc |	calc := HumCalculator new.		myBlock := [ self asHtmlCanvasOffsetX: (self left) y: (self top) ].	html := calc xml: 'html' 				with: [ (calc xml: 'head' 					            with: [ calc xml: 'title' 						                         with: ['Surface as HTML' ]						                ]),					      (calc xml: 'body'					              with: [ myBlock value ])					    ].					^html.! !!HumSurface methodsFor: 'accessing - bounds' stamp: 'RichardAlexanderGreen 7/13/2015 10:18'!bbWidth	"Find my bounding box edge."	|  bbWidth |	bbWidth := ((self bbRight) - (self bbLeft)) abs.	^bbWidth.! !!HumSurface methodsFor: 'accessing - bounds' stamp: 'RichardAlexanderGreen 11/30/2015 08:53'!bbRight	"Find my bounding box edge."	| myEdge  |	myEdge := self bbEdge: #right.	^myEdge.! !!HumSurface methodsFor: 'accessing - bounds' stamp: 'RichardAlexanderGreen 11/30/2015 08:53'!bbBottom	"Find my bounding box edge."	| myEdge  |	myEdge := self bbEdge: #bottom.	^myEdge.! !!HumSurface methodsFor: 'accessing - bounds' stamp: 'RichardAlexanderGreen 7/13/2015 09:15'!bbHeight	"Find my bounding box edge."	|  bbHeight |	bbHeight := ((self bbTop) - (self bbBottom)) abs.	^bbHeight.! !!HumSurface methodsFor: 'accessing - bounds' stamp: 'RichardAlexanderGreen 11/30/2015 08:53'!bbLeft	"Find my bounding box edge."	| myEdge  |	myEdge := self bbEdge: #left.	^myEdge.! !!HumSurface methodsFor: 'accessing - bounds' stamp: 'RichardAlexanderGreen 11/30/2015 08:52'!bbTop	"Find my bounding box edge."	| myEdge  |	myEdge := self bbEdge: #top.	^myEdge.! !!HumSurface methodsFor: 'accessing - bounds' stamp: 'RichardAlexanderGreen 11/30/2015 09:54'!bbEdge: aSymbol	"Find my bounding box edge. 	aSymbol names an edge."	| myEdge  |	self assert: ( { #bottom. #left. #right. #top. } includes: aSymbol ).	myEdge := self perform: aSymbol.	self shapes 		do: [ :shape | 				| otherEdge |				otherEdge := (shape perform: aSymbol).				( ({#right. #top.} includes: aSymbol ) and: [otherEdge > myEdge] ) ifTrue: [ myEdge := otherEdge ].				( ({#left. #bottom.} includes: aSymbol ) and: [otherEdge < myEdge] ) ifTrue: [ myEdge := otherEdge ].				].	^myEdge.! !!HumSurface methodsFor: 'render as XML' stamp: 'RichardAlexanderGreen 7/13/2015 08:36'!asXMLRectOffsetX: offsetX y: offsetY 	"Return a hum <surface . . . /> element for this surface."	| xml rectAttributes nextLayer viewX viewY calc |	xml := String new.	rectAttributes := Dictionary new.	( id notNil ) ifTrue: [ rectAttributes add: 'ID' -> id ].		rectAttributes at: 'width' put: width asString.	rectAttributes at: 'height' put: height asString.	viewX := left + offsetX.	viewY := top + offsetY.		rectAttributes at: 'x' put: viewX asString.	rectAttributes at: 'y' put: viewY asString.  	calc := HumCalculator new.	xml := calc xml: 'hum:surface' dictionary: rectAttributes .		nextLayer := ''.	(self shapes )		do: [ :shape | 			nextLayer := nextLayer, (shape asXMLRectOffsetX: viewX y: viewY).			].	xml := xml, nextLayer.	^xml. 		! !!HumSurface methodsFor: 'render as XML' stamp: 'RichardAlexanderGreen 12/9/2013 10:16'!asXML	| myBlock xml calc |		myBlock := [ self asXMLRectOffsetX: (self left) y: (self top) ].	calc := HumCalculator new.	xml := calc xml: 'script' dictionary: ( HumSurface humSurfaceAttributes ) with: myBlock.		^xml.! !!HumSurface methodsFor: 'utility' stamp: 'RichardAlexanderGreen 11/30/2015 10:47'!asMeasure: aQuantity	| measure |	( aQuantity isKindOf: HumMeasure )		ifTrue: [ measure := aQuantity ].	( aQuantity isKindOf: String ) 		ifTrue: [ measure := HumMeasure fromString: aQuantity ].	( aQuantity isKindOf: Number )		ifTrue: [ measure := aQuantity perform: (self defaultUnits asSymbol) ].			self assert: ( measure isKindOf: HumMeasure ).	self assert: ( measure units = (self defaultUnits)) description: ('Expecting ', defaultUnits, ' but got: ', measure units).		^measure! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/16/2012 12:31'!id	self assert: ( id isKindOf: String ).	self assert: ( id notEmpty ).	^ id! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2013 11:16'!title	^ title ifNil: [ self id ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:56'!bottom: aNumber	"Reset the bottom edge."	bottom := self asMeasure: aNumber.	"Force top edge to be bottom + height"	top := bottom + (self height).! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:33'!layer: aNumber	layer := aNumber! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/11/2015 09:37'!right	^ right ifNil: [self right: 0 meter ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/28/2013 10:59'!origin	"a zero-size object positioned at ( left top layer ) = ( 0 0 0 )"		^ origin ifNil: [ origin := HumSurface new.  ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/21/2015 10:17'!backgroundColor		^ backgroundColor ifNil: [backgroundColor := Color gray ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/11/2015 09:37'!left	^ left ifNil: [ self left: 0 meter ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/28/2013 10:17'!left: aNumber	| measure |	measure := self asMeasure: aNumber.	"Reset the left edge."	left := measure.	"Force the right edge to keep width constant."	right := left + (self width).! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:36'!top	^ top ifNil: [ top := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2012 13:02'!id: aString 	id := aString.! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/23/2015 10:58'!borderColor	"What color is my border, ifany?"	^borderColor ifNil: [ borderColor := Color black ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/11/2015 09:35'!bottom	^ bottom ifNil: [ self bottom: 0 meter ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/30/2015 10:51'!initialize: units	| zero unitOfMeasure |	self assert: ( units isKindOf: String ).	"Reset #pixel to #px as needed.	In this case, the abbreviation is the preferred expression.	"	unitOfMeasure := units asString.	(units = 'pixel') ifTrue: [ unitOfMeasure := 'px' ]. 	(units = 'percent') ifTrue: [ unitOfMeasure := '%'].	zero := 0 perform: (units asSymbol).	self defaultUnits: (zero units).		width := zero.	left := zero.	right := zero.		height := zero.	top := zero.	bottom := zero.		layer := zero.! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/13/2015 09:16'!shapes	"I remember the 2d objects placed on me."	^ shapes ifNil: [ shapes := Set new. ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:58'!top: aNumber	"Reset the top edge."	top := self asMeasure: aNumber.	"Force the bottom edge to keep the height constant."	bottom := top - (self height).! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/28/2013 10:36'!layer	"What layer is the surface in?	Surfaces with higher layer numbers will overlay (obscure) those with lower layer numbers.	You should avoid overlapping surfaces in the same layer. The result is not deterministic.	See also: #overlay:onTopOf:	"	"By default, a surface is in layer zero."	^ layer ifNil: [ layer := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:57'!right: aNumber		"Reset the right edge."	right := self asMeasure: aNumber.	"Force the left edge to keep the width constant."	left := right - (self width).! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/27/2013 10:14'!width: anObject	"Reset the width. 	This is the X extent in most contexts.	See also: height and layer."	width := self asMeasure: anObject.	"Force the right edge to be consistent."	right := (self left) + width.! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/23/2015 10:59'!fillColor	"What color is my fill, ifany?"	^fillColor ifNil: [ fillColor := Color gray ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/23/2015 10:20'!addShape: aHumSurface 	(self shapes) add: aHumSurface.! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/11/2015 09:35'!height	"What is the height of this object?	This is Y extent or length when surface is horizontal as seen on on table or document.	This is Z extent or height when surface is vertical as seen on a billboard.	The other dimensions are width and layer.	NOTE: In this model, a HumSurface has no thickness.	"	^ height ifNil: [ self height: 0 meter ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2013 11:15'!title: aString	title := aString.	! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/30/2015 10:28'!defaultUnits: aSymbol	^defaultUnits := aSymbol.	! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/11/2015 09:36'!width	^ width ifNil: [ self width: 0 meter. ]! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/13/2015 11:56'!backgroundColor: aColor	"Set color to be used when background is rendered."	self assert: (aColor isKindOf: Color).	backgroundColor := aColor.! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/30/2015 10:23'!initialize	self initialize: 'px'.	! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/30/2015 10:28'!defaultUnits	^defaultUnits ifNil: [ defaultUnits := 'px' ].	! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:56'!height: aNumber.	"Reset the distance between top and bottom edges."	height := self asMeasure: aNumber.	"Force the bottom to be the top minus the height."	bottom := (self top) - height.! !!HumSurface methodsFor: 'render as SVG' stamp: 'RichardAlexanderGreen 7/13/2015 08:33'!asSvgRect	"Return a SVG <rect . . . /> element for this surface."	| xml rectAttributes nextLayer calc |	self delegated.	xml := String new.	rectAttributes := Dictionary new.	( id notNil ) ifTrue: [ rectAttributes at: 'ID' put: id ].		"TODO: Determine what SVG scale and transpose should be applied to this surface's rectangle."	rectAttributes at: 'width' put: width asString.	rectAttributes at: 'height' put: height asString.	calc := HumCalculator new.	xml := calc xml: 'rect' dictionary: rectAttributes .		"TODO: Order the shapes by layer."	nextLayer := ''.	(self shapes )		do: [ :shape | 			nextLayer := nextLayer, shape asSvgRect.			].	xml := xml, nextLayer.	^xml. 		! !!HumSurface methodsFor: 'render as SVG' stamp: 'RichardAlexanderGreen 7/13/2015 08:35'!asSvgRectOffsetX: offsetX y: offsetY	"Return a SVG <rect . . . /> element for this surface."	| xml rectAttributes nextLayer viewX viewY calc |	xml := String new.	rectAttributes := Dictionary new.	( id notNil ) ifTrue: [ rectAttributes at: 'ID' put: id ]. "TODO: CLEAN UP THIS HACK."		"Don't scale dimensions in this version"	rectAttributes at: 'width' put: width asString.	rectAttributes at: 'height' put: height asString.	( offsetX quantity = 0 ) ifTrue: [ viewX := left ] ifFalse: [ viewX := left + offsetX ].	( offsetY quantity = 0 ) ifTrue: [ viewY := top  ] ifFalse: [ viewY := top  + offsetY ].	rectAttributes at: 'x' put: viewX asString.	rectAttributes at: 'y' put: viewY negated asString.  "Flip our Y value because SVG has Y pointing down."	calc := HumCalculator new.	xml := calc xml: 'rect' dictionary: rectAttributes .		nextLayer := ''.	(self shapes )		do: [ :shape | 			nextLayer := nextLayer, (shape asSvgRectOffsetX: viewX y: viewY).			].	xml := xml, nextLayer.	^xml. 		! !!HumSurface methodsFor: 'render as SVG' stamp: 'RichardAlexanderGreen 5/5/2015 12:29'!asSvgViewBox	| attributes viewBoxAttribute space myBlock svg calc |	"Set up standard attributes for the svg prolog."	calc := HumCalculator new.	space := $   asString.	attributes := Dictionary new.	attributes at: 'xmlns' put: 'http://www.w3.org/2000/svg'.	attributes at: 'xmlns:xlink' put: 'http://www.w3.org/1999/xlink'.	attributes at: 'width' put: '100%'.	attributes at: 'height' put: '100%'.		viewBoxAttribute := self left quantity asString, space, 	                              self top quantity asString, space, 	                              self width quantity asString, space, 	                              self height quantity asString.	attributes add: 'viewBox' -> viewBoxAttribute.		myBlock := [ self asSvgRectOffsetX: 0 px y: 0 px.  ].		svg := calc xmlOpen: 'svg' dictionary: attributes.	svg := svg, '<g stroke="#001122" stroke-width="0.03" fill="ffeedd" >'.	svg := svg, ( myBlock value).	svg := svg, '</g>'.	svg := svg, '</svg>'.	^svg.! !!HumSurface methodsFor: 'render as SVG' stamp: 'RichardAlexanderGreen 5/5/2015 12:24'!asSVG	"Generate the opening <svg . . . > element."	| myBlock svg calc |		myBlock := [ self asSvgRectOffsetX: (self left) y: (self top) ].	calc := HumCalculator new.	svg := calc xml: 'svg' dictionary: ( HumSurface svgAttributes ) with: myBlock.		^svg.! !!HumSurface methodsFor: 'render on canvas' stamp: 'RichardAlexanderGreen 7/22/2015 12:07'!canvas	"Attach a canvas - for placing drawings and images on the surface"	^canvas ifNil:[ canvas := HumCanvas new ].! !!HumSurface methodsFor: 'render on canvas' stamp: 'RichardAlexanderGreen 1/15/2016 15:14'!about"Q: What is the relation between Sensor, Scribe, Widget, Canvas, Solid, ViewPort.A: The Scribe interprets inputs from the Sensor and updates a Widget.The Widget is drawn on a Canvas which is painted on a Surface.A Surface might be painted on a Solid within a Scene.Note: A Surface is not rendered if it is not visible to the Viewport`s Camera. The flow is Sensor >> Scribe >> Widget >> Canvas >> Surface >> ViewPort (Camera)."! !!HumSurface methodsFor: 'render on canvas' stamp: 'RichardAlexanderGreen 9/26/2015 10:40'!asMorph	| result |	result := self canvas formCanvas form asMorph.	^result.! !!HumSurface methodsFor: 'render on canvas' stamp: 'RichardAlexanderGreen 7/23/2015 10:54'!drawOn: aHumCanvas 	"Draw self on the given canvas."	| polygon |	self assert: (aHumCanvas isKindOf: HumCanvas).	polygon := HumPolygon borderColor: (self borderColor) fillColor: (self fillColor).	polygon		addVertex: { left. top. };		addVertex: { left. bottom. };		addVertex: { right. bottom. };		addVertex: { right. top. }.	aHumCanvas drawPolygon: polygon scale: ((5 px)/(1 millimeter)). 	! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 7/13/2015 08:36'!generateHumScript	"Proof of concept: Generate Hum code."	| script space period |	space := ' '.	period := '.'.	script := '. Painter: '.	script := script, 'Paint surface with '.	script := script, space, 'id', space, (self id) quoted.	script := script, space, 'width', space, (self width) asString quoted.	script := script, space, 'height', space, (self height) asString quoted.	script := script, space, 'left', space, (self left) asString quoted.	script := script, space, 'top', space, (self top) asString quoted.		script := script, period.		( self shapes )		do: [ :shape | script := script, String cr, (shape generateHumScript ) ].		^script.! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 11/11/2015 10:18'!asBillBoard	"Convert the surface to a thin HumBox."	"Note: Dimensions given in pixels will be coverted to millimeters."	| billboard zCanvas |	billboard := HumSolid new.	billboard		id: 'billboard';		length: 0.001;  "one millimeter thick"		width: self width asMillimeters;    "Same as my width"		height: self height asMillimeters;		solidColor: self backgroundColor; 		westEdge: self left asMillimeters; 		northEdge: self layer asMillimeters;		topEdge: (1.75 meter) + (top asMillimeters). "Hang at adult eye level"	"Draw children, if any, on canvas"	zCanvas := self canvas.	(self shapes) 		do: [ :shape |  			"TODO: Position the part on the billboard"			shape drawOn: zCanvas.			].	"Attach the canvas to the South face of the billboard."		billboard attachCanvas: zCanvas toFace: #North.	^billboard.		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumSurface class	instanceVariableNames: ''!!HumSurface class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/9/2013 10:22'!humSurfaceAttributes	"Set up standard attributes for the hum UI prolog."	| dict |	dict := Dictionary new.	dict at: 'src' put: 'scripts/humSurface.js'.	dict at: 'defer' put: 'defer'.	^dict.! !!HumSurface class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/9/2013 10:22'!svgAttributes	"Will generate default attributes as follows:	<svg 	xmlns='http://www.w3.org/2000/svg' 			xmlns:xlink='http://www.w3.org/1999/xlink' 			width='100%'			height='100%'			>	Note: 100% width and height assumes that the actual size constraint 	will be defined in an enclosing <div . . .> tag.			"	| dict |	"Return default attributes for the svg prolog as a list of associations."	dict := Dictionary new.	dict at: 'xmlns' put: 'http://www.w3.org/2000/svg'.	dict at: 'xmlns:xlink' put: 'http://www.w3.org/1999/xlink'.	dict at: 'width' put: '100%'.	dict at: 'height' put: '100%'.	^dict.	! !!HumSurface class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/16/2012 11:40'!humAttributes	"Set up standard attributes for the hum UI prolog."	| dict |	dict := OrderedCollection new.	dict add: 'src' -> 'scripts/hum.js'.	dict add: 'defer' -> 'defer'.	^dict.! !Object subclass: #HumTextPrettyPrinter	instanceVariableNames: 'startCommentToEndOfLine'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumTextPrettyPrinter commentStamp: 'RichardAlexanderGreen 8/7/2012 19:28' prior: 0!HumTextPrettyPrinter is designed to pretty print a text based upon parameters provided.Parameters include:- string that begins a multi-line comment -- example: '/*' in several notations derived from the C langauge.- string that ends a multi-line comment. -- example: '*/' in several notations.- string that begins a whole-line comment -- example: '#' in several notations.- string that begins a remainder-of-line comment -- example '//' in several notations.- string that begins a compiler directive -- example '@' in Java and other languages.- string of special characters that may be included in names -- example '_' in many languages, '_-' in COBOL.- tokens that represent "keywords" -- exampe 'if', 'else', 'begin', 'end', 'for', 'def', 'class', 'public', 'private'.- balanced pairs -- For example: '(...)', '[...]', '{...}'- string delimiters -- For example: "..." and '...' - string for indentation -- For example: tab or '. '- treatment for keywords -- example: bold, foreground blue- treatment for whole-line comment -- example: italic, background dark green, foreground yellow.- treatment for remainder-of-line comments -- example: italic, foreground green- treatment for multi-line comments -- example: italic, foreground green- treatment for strings -- example: normal, forground cyan- treatment for special characters -- example: bold, forground red- treatment for whole-line comment -- example: italic, background dark green, foreground yellow.!!HumTextPrettyPrinter methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 8/7/2012 20:06'!parse: aHumTextLine 	|  tokens ppTokens |	"delimiters := (' ', startCommentToEndOfLine )."	tokens := ( aHumTextLine string ) substrings. 	ppTokens := OrderedCollection new.	tokens do: [ :token | 		| ppToken |		ppToken := HumTextPrettyToken new.		ppToken string: token.		ppTokens add: ppToken.		].	^ ppTokens.	! !!HumTextPrettyPrinter methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/7/2012 19:54'!addCommentToEndOfLineStartsWith: aString 	| |	self assert: (aString isKindOf:  String).	startCommentToEndOfLine := aString.! !HumWidget subclass: #HumViewPort	instanceVariableNames: 'scene camera projectionMode bounds pixelsPerMillimeter repaintBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumViewPort commentStamp: 'RichardAlexanderGreen 7/29/2015 11:56' prior: 0!This ViewPort class is a wrapper on one or more 3D viewport implementations. It is intended for use with HumSurface and HumSolid objects.Note that the dimensions and positions of those objects are HumMeasures.Intended features:- The view is 3D.-- That means that the view will be affected by the "camera" (viewport) position.-- The camera can be moved to effect pan, zoom, and rotation, orbit.-- If no camera position is given, the camera will be positioned automatically.The basic intent of the Hum 3D package is to simplify the API.Most 3D API seem overly complex because they mix scene and rendering. We wish to avoid that in Hum.We would like to achieve the level of simplicity seen in VPython.The strategy involves separating the scene description from the rendering logic.The motivation for HumViewPort is that there should be a simple way to set-up and view 3D scenes. See: HumViewPortTests>>testV330DrawABox.!!HumViewPort methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 11/3/2015 11:08'!selectSolidsInFrontOfCamera	"Return collection of solids whose centers are in front of camera."	| cameraSolids sceneSolids |		cameraSolids := OrderedCollection new.  "solids with points transformed to camera coordinates"	 "Explode each assembly to get constituent solids."	sceneSolids := ((scene exploded) reject: [ :part | part isKindOf: HumCamera]).	( sceneSolids ) 		do: [ :solid |			| centerInSceneFrame centerInCameraFrame |			centerInSceneFrame := solid center.			centerInCameraFrame := self transformPointIntoCameraFrame:  centerInSceneFrame.			((centerInCameraFrame y) quantity > 0.0 ) 				ifTrue: [ cameraSolids add: solid. ].			 ].	^cameraSolids.! !!HumViewPort methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/5/2015 10:29'!scene: aScene 	self assert: (aScene isKindOf:  HumScene ).	scene := aScene.	scene addDependent: self.! !!HumViewPort methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/29/2015 12:55'!camera: aCamera 	"Which camera (in the scene)?"	self assert: ( aCamera isKindOf: HumCamera ).	camera := aCamera.! !!HumViewPort methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/29/2015 13:00'!scalePixelsPerMillimeter	^pixelsPerMillimeter ifNil: [ pixelsPerMillimeter := (5 px) / (1 millimeter) ].! !!HumViewPort methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/29/2015 12:55'!camera	"Which camera (in the scene)?"	^camera ifNil: [ Error signal: 'Viewport needs a camera.' ]! !!HumViewPort methodsFor: 'render' stamp: 'RichardAlexanderGreen 12/11/2015 10:15'!paintScene	"Render solids in my scene as polygons projected onto my canvas."	| flatPolygons aCanvas |	"Solid faces are 3D polygons. Project to 2D viewport canvas."	flatPolygons := self mapPolygonsFrom3Dto2D.	aCanvas := self canvas.	flatPolygons		do: [ :polygon |			self paintHumPolygon: polygon.			 ].	self repaint: [ self paintScene. ].	'This works in simple scenes but easily fails when things get just a little more complex.	What is needed is a kind of pixel matrix where each pixel includes depth (distance from camera) information.	Then, while painting, pixels that are closer in may overlay pixels that are farther out.'.	! !!HumViewPort methodsFor: 'render' stamp: 'RichardAlexanderGreen 10/5/2015 10:47'!repaint	"Repaint using stored block."	self assert: (repaintBlock notNil).	self assert: (repaintBlock isKindOf: BlockClosure ).	self canvas fillBackground.	repaintBlock value.! !!HumViewPort methodsFor: 'render' stamp: 'RichardAlexanderGreen 11/2/2015 09:16'!paintHumPolygon: aHumPolygon 	"The HumPolygon may contain 3D points and specifies fill and border colors. 	We project to 2D and draw on our form."	|   aBorderWidth aBorderColor  aFillColor scaledVertices |	aBorderWidth := 2.	aBorderColor := aHumPolygon borderColor.	aFillColor := aHumPolygon fillColor.	scaledVertices := OrderedCollection new.	aHumPolygon verticesDo: [ :x :y :z | scaledVertices add: (x@y) ].	self formCanvas drawPolygon: scaledVertices fillStyle: aFillColor borderWidth: aBorderWidth borderColor: aBorderColor.! !!HumViewPort methodsFor: 'render' stamp: 'RichardAlexanderGreen 9/11/2015 19:30'!asMorph	| morph |	morph := (self canvas) asMorph.	self assert: (morph isKindOf: HumViewPortMorph ).	morph viewPort: self.	^morph.! !!HumViewPort methodsFor: 'render' stamp: 'RichardAlexanderGreen 10/5/2015 10:40'!repaint: aBlock	"Which method to use when repainting?"	repaintBlock := aBlock.! !!HumViewPort methodsFor: 'render' stamp: 'RichardAlexanderGreen 11/3/2015 10:27'!renderSceneAsWireFrame	"Render solids in my scene as polygons projected onto my canvas."	| flatPolygons aCanvas |	"Solid faces are 3D polygons. Project to 2D viewport canvas."	flatPolygons := self mapPolygonsFrom3Dto2D.	aCanvas := self canvas.	flatPolygons		do: [ :polygon |			aCanvas drawHumPolygon: polygon.			 ].	self repaint: [ self renderSceneAsWireFrame ].		! !!HumViewPort methodsFor: 'render' stamp: 'RichardAlexanderGreen 11/10/2015 17:51'!renderScene	"Render solids in my scene as polygons projected onto my canvas."	^self renderSceneAsTriangles.	! !!HumViewPort methodsFor: 'render' stamp: 'RichardAlexanderGreen 11/2/2015 08:15'!paintSceneAsTriangles	"Render solids in my scene as polygons projected onto my canvas."	|  triangles aCanvas |	"Solid faces are 3D polygons. Project to 2D viewport canvas."	triangles := self mapPolygonsToTriangles.	aCanvas := self canvas.	triangles		do: [ :triangle |			self paintHumPolygon: triangle.			 ].	self repaint: [ self paintSceneAsTriangles. ]	! !!HumViewPort methodsFor: 'render' stamp: 'RichardAlexanderGreen 11/10/2015 17:51'!zrenderScene	"Render solids in my scene as polygons projected onto my canvas."	| flatPolygons aCanvas |	"Solid faces are 3D polygons. Project to 2D viewport canvas."	flatPolygons := self mapPolygonsFrom3Dto2D.	aCanvas := self canvas.	flatPolygons		do: [ :polygon |			self paintHumPolygon: polygon.			 ].	self repaint: [ self renderScene ].	! !!HumViewPort methodsFor: 'render' stamp: 'RichardAlexanderGreen 11/10/2015 17:57'!paintSceneColorCoded	"Render solids in my scene as polygons projected onto my canvas."	^ self renderSceneAsTriangles. 	! !!HumViewPort methodsFor: 'render' stamp: 'RichardAlexanderGreen 12/11/2015 11:07'!renderSceneAsTriangles		"Render solids in my scene as polygons projected onto my canvas."	|  triangles aCanvas |	"Solid faces are 3D polygons. Project to 2D viewport canvas."	triangles := self mapTrianglesFrom3Dto2D.	aCanvas := self canvas.	triangles		do: [ :polygon |			self paintHumPolygon: polygon.			 ].	self repaint: [ self renderSceneAsTriangles ].	'TODO: Find algorithm that maps 3D triangle (tesselation) to pixels	while tracking depth (distance from camera) of 3D point	so that near point pixels will overlap far point pixels'.	! !!HumViewPort methodsFor: 'projection' stamp: 'RichardAlexanderGreen 11/3/2015 11:08'!transformPointIntoCameraFrame: aPoint3D 	"Transform the point into the camera`s coordinate system."	| sceneX sceneY sceneZ 	cameraX cameraY cameraZ 	translatedX translatedY translatedZ  	rotatedX rotatedY rotatedZ  	vectorDistance alpha beta  calc |	calc := HumCalculator new.	calc cases;		when: [ aPoint3D isKindOf: Array ]			then: [ 				sceneX := aPoint3D at: 1.  "offset East"				sceneY := aPoint3D at: 2.  "offset North"				sceneZ := aPoint3D at: 3.  "offset Up" ];		when: [ aPoint3D isKindOf: HumVector ]			then: [ 				sceneX := aPoint3D x.				sceneY := aPoint3D y.				sceneZ := aPoint3D z.							 ];		otherwise: [ Error signal: 'aPoint3D not of expected type' ].		"Translate"	translatedX := sceneX - (camera eyeX).	translatedY := sceneY - (camera eyeY).	translatedZ := sceneZ - (camera eyeZ).	"Rotate"	vectorDistance := ((translatedX*translatedX) + (translatedY*translatedY) "+ (translatedZ*translatedZ)") sqrt.	alpha := (translatedX quantity/ vectorDistance quantity) arcCos.  "rise over run"	beta := alpha - (camera rotation).	rotatedX := vectorDistance * (beta cos).	rotatedY := vectorDistance * (beta sin).	rotatedZ := translatedZ.		"Tilt"	vectorDistance := ("(translatedX*translatedX) +" (rotatedY*rotatedY) + (rotatedZ*rotatedZ)) sqrt.	alpha := (rotatedZ quantity /  vectorDistance quantity) arcSin. "rise over run"	beta := alpha - (camera tilt).	cameraX := rotatedX.	cameraY := vectorDistance * (beta cos).	cameraZ := vectorDistance * (beta sin).	^HumVector newFrom: { cameraX. cameraY. cameraZ. }.	! !!HumViewPort methodsFor: 'projection' stamp: 'RichardAlexanderGreen 11/3/2015 09:11'!mapPolygonsToViewPort: aCollectionOfPolygons 	"Map from 3D to 2D"	| cameraDepth transformToCanvas2D viewportPolygons |	viewportPolygons := OrderedCollection new.	cameraDepth := self camera depth.	transformToCanvas2D := [ :x :y :z | self projectScenePoint: { x. y. z. } cameraDepth: cameraDepth ].	aCollectionOfPolygons		do: [ :polygon |					| viewportPolygon |					viewportPolygon := HumPolygon copy: polygon withTransform: transformToCanvas2D.					viewportPolygons add: viewportPolygon.					 ].	^viewportPolygons! !!HumViewPort methodsFor: 'projection' stamp: 'RichardAlexanderGreen 11/10/2015 17:46'!mapPolygonsFrom3Dto2DcolorCoded	"Each solid in the scene provides a collection of polygons with points in 3D scene coordinates. 	Those polygons are translated into new polygons with points in 2D viewport coordinates."	| scenePolygons cameraPolygons viewportPolygons cameraDepth transformToCanvas2D |	scenePolygons := OrderedCollection new.  "For debug?"	cameraPolygons := OrderedCollection new.	viewportPolygons := OrderedCollection new.		((scene parts) reject: [ :part | part isKindOf: HumCamera])		do: [ :solid |			| solidPolygons |			solidPolygons := solid asPolygonsColorCoded.			solid resetColoring.			( solidPolygons ) "Provides crude z-order - North to South ordering. See HumPolygon"				do: [ :solidPolygon  | 					| transformedPolygon  |					"Project onto camera frustrum"					transformedPolygon := self transformPolygonToCameraFrame:  solidPolygon.					cameraPolygons add: transformedPolygon.					].			 ].	cameraDepth := self camera depth.	transformToCanvas2D := [ :x :y :z | self projectScenePoint: { x. y. z. } cameraDepth: cameraDepth ].			"TODO: Cull faces that are behind the camera."			"TODO: Sort faces to draw those that are far from camera under those that are close."	(cameraPolygons sort: [:a :b | (a maxRsquared) > (b maxRsquared) ]) 		do: [ :cameraPolygon |			| viewportPolygon |			viewportPolygon := HumPolygon copy: cameraPolygon withTransform: transformToCanvas2D.			viewportPolygons add: viewportPolygon.			].	^viewportPolygons.! !!HumViewPort methodsFor: 'projection' stamp: 'RichardAlexanderGreen 12/11/2015 10:27'!mapPolygonsFrom3Dto2D	"Each solid in the scene provides a collection of polygons with points in 3D scene coordinates. 	Those polygons are translated into new polygons with points in 2D viewport coordinates."	|   cameraSolids viewportPolygons     cameraPolygons culledPolygons sortedPolygons  transformedPolygons cameraTriangles |	cameraSolids := self selectSolidsInFrontOfCamera.	cameraPolygons := self getPolygonsForSolids: cameraSolids.	cameraTriangles := OrderedCollection new.	transformedPolygons := cameraPolygons collect: [ :polygon | self transformPolygonToCameraFrame: polygon ].	culledPolygons := transformedPolygons select: [ :polygon |  self cameraCanSeePolygon: polygon  ].	sortedPolygons := culledPolygons sort: [ :a :b | a northMostPoint  >  b northMostPoint ].	viewportPolygons := self mapPolygonsToViewPort: sortedPolygons.	'This works in simple scenes but simply fails when things get just a little more complex.	What is needed is a kind of pixel matrix where each pixel includes depth (distance from camera) information.	We could extend BitBlt and BitMap classes to get that effect - But their implementations are hidden behind primatives.	Then, while painting, pixels that are closer in may overlay pixels that are farther out.'.	'Of course, much of this might be obviated by delegating to an external 3D scene painter.'.	 ^viewportPolygons.! !!HumViewPort methodsFor: 'projection' stamp: 'RichardAlexanderGreen 11/7/2015 10:39'!transformPolygonToCameraFrame: aScenePolygon 	"Return a new polygon with the points transformed into camera`s coordinate system."	| transformedPolygon cameraDepth |	"Initialize polygon colors"	transformedPolygon := HumPolygon parentSolid: aScenePolygon parentSolid fillColor: aScenePolygon fillColor.	"Get camera depth"	cameraDepth := self camera depth.	aScenePolygon 		verticesDo: [ :x :y :z | 			| cameraXYZ  |			cameraXYZ := self transformPointIntoCameraFrame: { x. y. z. }.			transformedPolygon addVertex: cameraXYZ.			].	^transformedPolygon.! !!HumViewPort methodsFor: 'projection' stamp: 'RichardAlexanderGreen 11/10/2015 10:53'!getPolygonsForSolids: aCollectionOfSolids colorRule: aOneArgumentBlock	"Return polygons corresponding to the surfaces of the given solids."	| polygons |	polygons := OrderedCollection new.	aCollectionOfSolids		do: [ :solid | 			| solidPolygons |			solidPolygons := solid asPolygonsColoredBy: aOneArgumentBlock.			polygons addAll: solidPolygons.			].	"NOTE: These polygons are not transformed."	^polygons.! !!HumViewPort methodsFor: 'projection' stamp: 'RichardAlexanderGreen 7/22/2015 16:04'!projectionMode	"Map the scene polygons onto the viewport using orthogonal or perspective projection?"	^ projectionMode ifNil: [ projectionMode := #perspective ]! !!HumViewPort methodsFor: 'projection' stamp: 'RichardAlexanderGreen 7/16/2015 20:00'!projectionMode: aSymbol 	self assert: (#( #orthographic #perspective ) includes: aSymbol ).	projectionMode := aSymbol.! !!HumViewPort methodsFor: 'projection' stamp: 'RichardAlexanderGreen 11/3/2015 09:11'!projectScenePoint: aViewPoint cameraDepth: aCameraDepth	"Translate from camera view coordinates (meters) to canvas coordinates (px)"	| aCanvasPoint  sceneX sceneY sceneZ screenX screenY x y xOffset yOffset dxdy dzdy |	self assert: (aViewPoint isKindOf: Array ).	self assert: (aViewPoint size = 3).	"Map East-West to x; North-South to y; Up-Down to z, Time to w."	sceneX := aViewPoint at: 1.	sceneY := aViewPoint at: 2.	sceneZ := aViewPoint at: 3.		dxdy := (sceneX / sceneY) quantity.  "East over North"	dzdy := (sceneZ / sceneY) quantity.		screenX :=  aCameraDepth * dxdy.	screenY :=  aCameraDepth * dzdy.		x := (screenX * (self scalePixelsPerMillimeter)) quantity rounded.	y := (screenY * (self scalePixelsPerMillimeter)) quantity rounded.		xOffset := self canvas formCanvas extent x // 2.	yOffset := self canvas formCanvas extent y // 2.	aCanvasPoint := ( xOffset + x )@(yOffset - y). "flip y"	^aCanvasPoint.! !!HumViewPort methodsFor: 'projection' stamp: 'RichardAlexanderGreen 12/11/2015 11:04'!cameraCanSeePolygon: aHumPolygon 	"The camera can see the polygon 		if . . . y/x and z/x angles for at least one point are within the camera`s field of view."	aHumPolygon verticesDo: [ :x :y :z | 		| answer |		"Delegate to camera (HumCamera)"		answer := self camera isPointInFieldOfView: { x. y. z. }.		(answer) ifTrue: [ ^true. ].		].	^false.	! !!HumViewPort methodsFor: 'projection' stamp: 'RichardAlexanderGreen 11/3/2015 09:11'!zmapPolygonsFrom3Dto2D	"Each solid in the scene provides a collection of polygons with points in 3D scene coordinates. 	Those polygons are translated into new polygons with points in 2D viewport coordinates."	|   cameraSolids viewportPolygons cameraDepth transformToCanvas2D  |	cameraSolids := self selectSolidsInFrontOfCamera.	viewportPolygons := OrderedCollection new. "Collect resulting 2D polygons"	"Define the function we use to may from 3D to camera pixel point."	cameraDepth := self camera depth.	transformToCanvas2D := [ :x :y :z | self projectScenePoint: { x. y. z. } cameraDepth: cameraDepth ].	"Paint distant objects before those that are near."	( cameraSolids sorted: [ :aSolid :bSolid | aSolid rSquared < bSolid rSquared ] ) "Use R-squared to avoid taking square root."		do: [ :cameraSolid |			| cameraPolygons culledPolygons |			cameraPolygons := cameraSolid polygons. "These HumPolygons were computed above."			culledPolygons := (cameraPolygons select: [ :polygon |  polygon inFrontOfCamera  ] ).			(culledPolygons sort: [ :a :b | a northMostPoint  >  b northMostPoint ])				do: [ :culledPolygon |					| viewportPolygon |					viewportPolygon := HumPolygon copy: culledPolygon withTransform: transformToCanvas2D.					viewportPolygons add: viewportPolygon.					 ].			 ].	^viewportPolygons.! !!HumViewPort methodsFor: 'projection' stamp: 'RichardAlexanderGreen 11/2/2015 08:09'!mapToCanvas: aHumCanvas bounds: aRectangle 	"Declare where to draw me. Drawing is defered. See . . ."	self canvas: aHumCanvas.	bounds := aRectangle.	"TODO: These declarations should affect asMorph."	! !!HumViewPort methodsFor: 'projection' stamp: 'RichardAlexanderGreen 11/10/2015 11:01'!getPolygonsForSolids: aCollectionOfSolids 	"Return polygons corresponding to the surfaces of the given solids."	| polygons |	polygons := OrderedCollection new.	aCollectionOfSolids		do: [ :solid | 			| solidPolygons |			solidPolygons := solid asPolygonsColorCoded.			polygons addAll: solidPolygons.			].	"NOTE: These polygons are not transformed."	^polygons.! !!HumViewPort methodsFor: 'projection' stamp: 'RichardAlexanderGreen 11/10/2015 17:48'!mapTrianglesFrom3Dto2D	"Each solid in the scene provides a collection of polygons with points in 3D scene coordinates. 	Those polygons are translated into new polygons with points in 2D viewport coordinates."	|   cameraSolids viewportPolygons     cameraPolygons culledPolygons sortedPolygons  transformedPolygons cameraTriangles |	cameraSolids := self selectSolidsInFrontOfCamera.	cameraPolygons := self getPolygonsForSolids: cameraSolids.    	cameraTriangles := OrderedCollection new.	cameraPolygons do: [ :quad | |triangles|  triangles := quad asTriangles. cameraTriangles addAll: triangles ].	transformedPolygons := cameraTriangles collect: [ :polygon | self transformPolygonToCameraFrame: polygon ].	culledPolygons := transformedPolygons select: [ :polygon |  self cameraCanSeePolygon: polygon  ].	sortedPolygons := culledPolygons sort: [ :a :b | a meanRsquared  >  b meanRsquared ].	viewportPolygons := self mapPolygonsToViewPort: sortedPolygons.	^viewportPolygons.! !!HumViewPort methodsFor: 'projection' stamp: 'RichardAlexanderGreen 11/3/2015 10:46'!projectPolygon: aScenePolygon 	"Return a new polygon with the points transformed into camera`s coordinate system."	| transformedPolygon cameraDepth |	"Initialize polygon colors"	transformedPolygon := HumPolygon borderColor: aScenePolygon borderColor fillColor: aScenePolygon fillColor.	"Get camera depth"	cameraDepth := self camera depth.	aScenePolygon 		verticesDo: [ :x :y :z | 			| cameraXYZ canvasXZ |			cameraXYZ := self transformPointIntoCameraFrame: { x. y. z. }.			canvasXZ := self projectScenePoint: cameraXYZ cameraDepth: cameraDepth.			transformedPolygon addVertex: canvasXZ.			].	^transformedPolygon.! !!HumViewPort methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 8/31/2015 19:01'!scalePoint: aScenePoint scaleRatio: pxPerMeter 	"Return a x@y point by scaling the given scene point"	| sceneX sceneY canvasX canvasY |	((aScenePoint isKindOf: Array) or: [aScenePoint isKindOf: OrderedCollection])		ifFalse: [ Error signal: 'Scene Point is not of expected type' ].	sceneX := aScenePoint at: 1.	sceneY := aScenePoint at: 2.	( sceneX isPixels ) 		ifTrue: [ "Already scaled."			canvasX := sceneX quantity rounded. 			canvasY := sceneY quantity rounded. 			] 		ifFalse: [ "Apply scale factor"			canvasX := ( sceneX * pxPerMeter ) quantity rounded. 			canvasY := ( sceneY * pxPerMeter ) quantity rounded.			].			^ canvasX @ canvasY.		! !!HumViewPort methodsFor: 'events' stamp: 'RichardAlexanderGreen 10/5/2015 10:30'!changed	super changed.! !!HumViewPort methodsFor: 'events' stamp: 'RichardAlexanderGreen 10/9/2015 11:18'!update: anObject 	"Something in my model has been changed."	self assert: (anObject == scene).	"Transcript cr; show: 'Scene changed.'."	self repaint.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumViewPort class	instanceVariableNames: ''!!HumViewPort class methodsFor: 'instance-creation' stamp: 'RichardAlexanderGreen 7/16/2015 19:50'!onScene: aScene viaCamera: aCamera	"Create an instance attached to the given camera in the given scene." 	| instance |	self assert: (aScene isKindOf: HumScene).	self assert: (aCamera isKindOf: HumCamera).	self assert: (aScene parts includes: aCamera).	instance := self new.	instance scene: aScene; camera: aCamera.	^instance.		 ! !!HumViewPort class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 7/17/2015 16:04'!pxPerMillimeter	| px mm pxPer |	mm := 1 millimeter.	px := (7.0/900.0) inch.            "verticle = HumMeasure( 0.0001975555 meter ) "	px := (11.25/1440.0) inch.  "horizontal = HumMeasure( 0.0001984375 meter )"	pxPer := mm / px.              " 5.03937. . .  on my laptop"	^pxPer quantity asInteger.    "Round to 5 px per mm"! !HumWidget subclass: #HumStringWidget	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumStringWidget commentStamp: 'RichardAlexanderGreen 4/23/2015 09:14' prior: 0!Widget enables user to view/enter a one-line string value.Note: Most attributes have string values.!!HumStringWidget methodsFor: '*HumSeaside' stamp: 'RichardAlexanderGreen 3/26/2014 15:03'!renderContentOn: aWAHtmlCanvas	"render self via a simple input tag"	| |	aWAHtmlCanvas textInput 		attributeAt: 'id' put: (self attributeName );		callback: [:value | self store: value ];		with: (self attributeValue asString).! !!HumStringWidget methodsFor: 'Render As' stamp: 'RichardAlexanderGreen 7/6/2015 11:14'!asHTML	"Generate HTML input element"	| html calc |	calc := HumCalculator new.	html := calc xml: 'input' dictionary: ((Dictionary new) at: 'name' put: (self attributeName); yourself)					with: [ self attributeValue ].	^html.	! !!HumStringWidget methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/8/2016 11:33'!asMorph	|  morph |	morph := attributeValue asTextMorph. 	morph 		color: Color black;                        "<< Foreground text color"		backgroundColor: Color white;		borderWidth: 2;		margins: 5.	^morph.! !HumWidget subclass: #HumFormWidget	instanceVariableNames: 'view'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumFormWidget commentStamp: 'RichardAlexanderGreen 1/15/2016 14:34' prior: 0!Form Widget is a container for attribute widgets.It corresponds to a Hum view frame.When appropriately rendered, it is expected to provide typical fill-in-the blank form actions.. tab from active slot to active slot.. [[ submit ]] -- submit changed data, return to prior dialog. [[ reset ]] -- reset field values to some prior state. [[ quit ]] -- ignore changed values, return to prior dialog!!HumFormWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/20/2014 15:22'!view: aHumView 	view := aHumView.! !!HumFormWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/24/2014 17:33'!view  "Return my view"	^ view ifNil: [Error signal: (self class,' not properly initialized')]! !!HumFormWidget methodsFor: '*HumSeaside' stamp: 'RichardAlexanderGreen 4/20/2015 11:49'!renderContentOn: aWAHtmlCanvas	| tag |	tag := aWAHtmlCanvas tag: 'view'.	tag	attributeAt: 'id' put: (self view id).	tag with: [ "A view becomes an HTML form."		aWAHtmlCanvas form 			attributeAt: 'id' put: (self view id); 			with: [ self view renderMarkupLinesViaSeasideOn: aWAHtmlCanvas ].		].	! !!HumFormWidget methodsFor: '*HumSeaside' stamp: 'RichardAlexanderGreen 3/25/2014 09:54'!renderOn: aWAHtmlCanvas	| tag |	tag := aWAHtmlCanvas tag: 'view'.	tag	attributeAt: 'id' put: (self view id).	tag with: [ "A view becomes an HTML form."		aWAHtmlCanvas form 			attributeAt: 'id' put: (self view id); 			with: [ self view renderMarkupLinesViaSeasideOn: aWAHtmlCanvas ].		].	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumFormWidget class	instanceVariableNames: ''!!HumFormWidget class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 3/20/2014 15:21'!onView: aHumView 	| instance |	instance := self basicNew.	instance view: aHumView.	^instance.! !HumWidget subclass: #HumCollectionWidget	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumCollectionWidget commentStamp: 'RichardAlexanderGreen 4/23/2015 09:13' prior: 0!Collection widget is a contain providing a view of an attribute that is a collection.Examples:. An order has a list of order-items.. A recipe has a set of ingredients.. A recipe has a list of instructions.. A bill-of-material has a set of part-counts.. An inventory has a set of part-counts.The view is typically a table where each row is a view of an item in the collection.In a Hum View, the table is typically specified like this:. Table of Order-Items:| Item | Catalog-Number | Description | Quantity |  !HumWidget subclass: #HumMeasureWidget	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumMeasureWidget commentStamp: 'RichardAlexanderGreen 1/15/2016 14:45' prior: 0!Widget enables user to view/enter a measure (quantity, unit-of-measure).See HumMeasure class.TODO: Should the widget also store a HumMeasure instance?!!HumMeasureWidget methodsFor: '*HumSeaside' stamp: 'RichardAlexanderGreen 3/27/2014 17:18'!renderContentOn: aWAHtmlCanvas	"render self via a simple input tag"	| |	aWAHtmlCanvas numberInput 	  type: 'number';		attributeAt: 'id' put: (self attributeName );		callback: [:value | self store: value ];		with: (self attributeValue asString).! !HumSolid subclass: #HumRotation	instanceVariableNames: 'xyList nWedges'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumRotation commentStamp: 'RichardAlexanderGreen 9/2/2015 18:54' prior: 0!a rotation is defined by a list of 2D points which indicate a surface of rotation about the Z axis.Each 2D point is translated into a set of 3D points which divide a circle whose radius is equal to the x value of the 2D point.The circle is in a plane who Z value is equal to the Y value of the 2D point.Instance variables:xyList (the list of 2D points mentioned above.)nWedges (the number of wedges in each circle)Examples 3-sided pyramid: xyList := #( 0@10 10@0 0@0). nWedges := 3.cube: #( 0@10 10@10 10@0 0@0 ). nWedges := 4.cylinder: #( 0@10 10@10 10@0 0@0 ). nWedges := 100.torus (with triangular section): #(  10@10 15@5 10@5 10@10 ). nWedges := 100.!!HumRotation methodsFor: 'access' stamp: 'RichardAlexanderGreen 9/2/2015 19:20'!nWedges: numberOfWedges	nWedges := numberOfWedges.! !!HumRotation methodsFor: 'access' stamp: 'RichardAlexanderGreen 9/2/2015 19:40'!xyList: aCollection 	"List of XY (XZ) points that define surface of revolution."	xyList := aCollection 					collect: [ :point |  						| x y xMeasure yMeasure |						x := point x.						y := point y.						xMeasure := self asMeasure: x.						yMeasure := self asMeasure: y.						{ xMeasure. yMeasure. }.						].						! !!HumRotation methodsFor: 'polygons' stamp: 'RichardAlexanderGreen 11/10/2015 17:59'!asPolygonsColoredBy: aColorRule	"Produce polygons from the xyList points and the rotation nWedges."	|  priorAngle pi makePoint fillColor borderColor tPolygons wedgeAngle centerX centerY centerZ |	tPolygons := OrderedCollection new.	fillColor := self solidColor.	borderColor := self wireFrameColor.	priorAngle := 0.0.	pi := Float pi.	wedgeAngle := (2*pi)/nWedges.	centerX := self centerX.	centerY := self centerY.	centerZ := self centerZ.	makePoint := [ :angle :xy |  			| x y z radius |			radius := xy at: 1.			x := radius * (angle sin).			y := radius * (angle cos).			z := xy at: 2.			{ x + centerX.  y + centerY.  z + centerZ. }			].	 ( wedgeAngle to: (2*pi) by: wedgeAngle )		do: [ :currentAngle |			| priorXY |			priorXY := xyList at: 1.			xyList 				allButFirstDo:  [ :xy |					| polygon  |					fillColor := (aColorRule value).  "Select from a sequence of colors."					polygon := HumPolygon borderColor: borderColor fillColor: fillColor.					polygon parentSolid: self.					polygon 						addVertex: (makePoint value: currentAngle value: xy);						addVertex: (makePoint value: currentAngle value: priorXY);						addVertex: (makePoint value: priorAngle value: priorXY);						addVertex: (makePoint value: priorAngle value: xy).					priorXY := xy.					tPolygons add: polygon.					]. "xy"			priorAngle := currentAngle.	  		]. "currentAngle"	^tPolygons.! !!HumRotation methodsFor: 'render via VPython' stamp: 'RichardAlexanderGreen 12/12/2015 09:06'!asVPython	self shouldBeImplemented ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumRotation class	instanceVariableNames: ''!!HumRotation class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 9/2/2015 19:18'!id: aString type: aSymbol xyList: listOfPoints nWedges: numberOfWedges 	| instance listOfRadius listOfZ maxRadius maxZ minZ |	instance := self new.	listOfRadius := listOfPoints collect: [ :point | point x ].	listOfZ := listOfPoints collect: [ :point | point y ].	maxRadius := listOfRadius max.	maxZ := listOfZ max.	minZ := listOfZ min.	instance		width: (maxRadius * 2);		height: (maxZ - minZ);		xyList: listOfPoints;		nWedges: numberOfWedges.	^instance.! !HumRotation subclass: #HumElipsoid	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumElipsoid methodsFor: 'polygons' stamp: 'RichardAlexanderGreen 10/7/2015 13:12'!asPolygons	^ self asPolygonsColoredBy: [ self solidColor ].! !!HumElipsoid methodsFor: 'polygons' stamp: 'RichardAlexanderGreen 11/30/2015 08:02'!asPolygonsColoredBy: aBlockRule	"Produce polygons from the xyList points and the rotation nWedges."	|  priorAngle pi makePoint fillColor borderColor  wedgeAngle centerX centerY centerZ xMax yMax zMax |	polygons := OrderedCollection new.	fillColor := self solidColor.	borderColor := self wireFrameColor.	priorAngle := 0.0.	pi := Float pi.	wedgeAngle := (2*pi)/16.	centerX := self centerX.	centerY := self centerY.	centerZ := self centerZ.	xMax := self width / 2.0.	yMax := self length / 2.0.	zMax := self height / 2.0.	"Wikipedia:	The surface of the ellipsoid may be parameterized in several ways. One possible choice which singles out the 'z'-axis is:	x = a * cos u * cos v	y = b * cos u * sin v	z = c * sin u	where u is in [ -pi/2, +pi/2 ] and v is in [ -pi, +pi ].	"	makePoint := [ :u :v  |  			| x y z  |			x := xMax * (u cos ) * (v cos).			y := yMax * (u cos) * (v sin).			z := zMax * (u sin).			{ x + centerX.  y + centerY.  z + centerZ. }			].	 ( ((pi/2.0) negated) to: (pi/2.0) by: wedgeAngle ) do: [ :u |			 ( (pi negated) to: pi by: wedgeAngle ) do: [ :v |					| polygon  |					fillColor := aBlockRule value.  "Evaluate the given rule."					polygon := HumPolygon borderColor: borderColor fillColor: fillColor.					polygon parentSolid: (self).					polygon 						addVertex: ( makePoint value: u value: v );						addVertex: ( makePoint value: u + wedgeAngle value: v );						addVertex: ( makePoint value: u + wedgeAngle value: v + wedgeAngle );						addVertex: ( makePoint value: u value: v + wedgeAngle ).					polygons add: polygon.				 ]. "v"			]. "u"	^polygons.! !!HumElipsoid methodsFor: 'polygons' stamp: 'RichardAlexanderGreen 10/7/2015 13:13'!asPolygonsColorCoded	^ self asPolygonsColoredBy: [ self nextColor ].! !!HumElipsoid methodsFor: 'render via VPython' stamp: 'RichardAlexanderGreen 12/12/2015 09:06'!asVPython	self shouldBeImplemented ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumElipsoid class	instanceVariableNames: ''!!HumElipsoid class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/7/2015 12:13'!id: anId type: aType height: aHeight width: aWidth length: aDepth 	"Create an instance . . . NOTE: length (North-South dimension) is ignored."	| instance |	instance := self new. "Initialize enclosing box edge values."	instance id: anId; type: aType; height: aHeight; width: aWidth; length: aDepth. 	^instance! !!HumElipsoid class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 10/7/2015 12:10'!id: anId type: aType height: aHeight diameter: aWidth  	"Create an instance . . . NOTE: Currently we just rotate an elipse. "	| rotation xyPoints nFacets  pi |	self halt.	pi := Float pi.	xyPoints := OrderedCollection new.	nFacets := 10.	( 1 to: nFacets ) 		do: [ :facet   |			| x y angle |			angle := ( pi / nFacets) * facet.			y := ( aHeight / nFacets ) * facet.			x := (angle sin) * (aWidth / 2).			xyPoints add: x@(y - (aHeight / 2.0)).			].	"Currently we just rotate an elipse. TODO: Elipsiod with 3 a,b,c radius."	rotation := self id: anId type: aType xyList: xyPoints nWedges: nFacets. 		^rotation! !HumSurface subclass: #HumPane	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumPane commentStamp: 'RichardAlexanderGreen 7/13/2015 09:09' prior: 0!A Pane is a subtype of Surface (HumSurface).Panes may contain other panes.It is also a container which collects other 2D shapes which are also HumSurface instances.It has a set of layout methods.A pane may receive "UI events" (speech act statements) from the Scribe.!!HumPane methodsFor: 'drawing' stamp: 'RichardAlexanderGreen 12/11/2015 09:15'!drawTextLines: textLines onCanvas: aCanvas font: aFont 	|   lineHeight em depth clipRectangle extent maxLineLength |	self assert: (aCanvas isKindOf: HumCanvas).	self assert: (aFont isKindOf: AbstractFont).	lineHeight := aFont height.	em := aFont linearWidthOf: $m.	height := ( lineHeight * (textLines size + 2) ).	maxLineLength := (textLines values max: [ :line | line size ] ).	width := em* (maxLineLength + 2).	textLines keysAndValuesDo: [ :key :value |  width := width max: (em*(value size)) ].	depth := 32.	origin := 0@0.	extent := width@height.	clipRectangle := Rectangle origin: origin extent: extent. 	canvas := HumCanvas  extent: extent depth: depth origin: origin clipRect: clipRectangle.	canvas drawTextLines: textLines withFont: aFont..! !!HumPane methodsFor: 'event' stamp: 'RichardAlexanderGreen 7/23/2015 18:15'!textChanged: aHumTextEditor 	"Text to be displayed in this pane has changed."	| myCanvas  lines |	"Draw the text lines on my canvas."	myCanvas := self canvas.	lines := aHumTextEditor lines.	self drawTextLines: lines onCanvas: myCanvas font: (StandardFonts defaultFont). 	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumPane class	instanceVariableNames: ''!!HumPane class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 7/10/2015 12:03'!id: aString height: h width: w background: aColor	| instance |	instance := self new.	instance id: aString; height: h; width: w; backgroundColor: aColor.	^instance.! !HumPane subclass: #HumDiagram	instanceVariableNames: 'connections nodes nodeExtent nodeSpacing mapNodePosition mapPositionNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumDiagram commentStamp: 'RichardAlexanderGreen 5/5/2015 12:02' prior: 0!A HumDiagram is a viewbox in a HumSurface for visualizing a Graph.HumDiagram knows how to layout the graph. NOTE: HumDiagram has functions that overlap HumGraph.TODO: REFACTOR HumDiagram to use HumGraph as a model.Instance Variables:	connections	<Set>	nodes	<Set>	nodePositions	<Dictionary>	positionNode	<Dictionary>	nodeExtent	<PTEvent | Point | TTPoint>	nodeSpacing	<PTEvent | Point | TTPoint>!!HumDiagram methodsFor: 'layout' stamp: 'RichardAlexanderGreen 6/23/2014 13:52'!layoutDistanceFromNode: nodeA toNode: nodeB	"Calculate the length of the connection between the nodes."	| xA xB yA yB xR yR r2 r|	xA := (( self mapNodePosition ) at: nodeA ) x.	yA := (( self mapNodePosition ) at: nodeA ) y.	xB := (( self mapNodePosition ) at: nodeB ) x.	yB := (( self mapNodePosition ) at: nodeB ) y.		xR := xA - xB.	yR := yA - yB.		r2 := ( xR * xR ) + ( yR * yR ).	r := r2 sqrt.	^r	! !!HumDiagram methodsFor: 'layout' stamp: 'RichardAlexanderGreen 4/16/2013 10:27'!layoutRecursiveWithNode: node relativePosition: relativePosition seenBefore: priorNodes	"Assign initial position to this node, and then, using recursion, to its neighbors.	- relativePosition is suggested first position to try. 	If that position is already filled, try other positions below it until one is found.	- priorNodes contains nodes that have been seen before in this recursion.	If this node is also in priorNodes, 	 it has already been handled and we return immediately to avoid a loop.	In some implementations,	  we might want to limit the depth (based on priorNodes size).	"	| xIncrement  xy downStreamNodes upStreamNodes yIncrement |	"Return immediately if this node has been seen before.	Otherwise add it to the nodes we have seen before and proceed."	( priorNodes includes: node ) ifTrue: [ ^self ] ifFalse: [ priorNodes add: node ].		"Following must be set before calling me."	self assert: ( nodeExtent notNil ).	self assert: ( nodeSpacing notNil ).	"Following is assumed in code below."	self assert: ( nodeExtent  isKindOf: Point).	self assert: ( nodeSpacing isKindOf: Point).		"Compute increments between grid locations."	"In this version, the placement is on a rectalinear grid.	But other/future versions may be radial and/or decrease as the number of priorNodes increases.	"	xIncrement := (nodeSpacing x) + (( nodeExtent x )/2).	yIncrement := (nodeSpacing y) + (( nodeExtent y )/2).		xy := self layoutNode: node from: relativePosition by: (0@yIncrement).		"Next: Find positions for nodes that are downstream from this node."	downStreamNodes := self getNodesDownstreamFromNode: node.	downStreamNodes				do: [ :downStreamNode | "Place downstream nodes to right and below of priority node."					self layoutRecursiveWithNode: downStreamNode 					             relativePosition: (xy + (xIncrement@0)) 					                  seenBefore: priorNodes.					"ToDo: Calculate which node positions are intersected by connecting lines.					       Assign the central node or a dummy node to those positions also.					       The parent node might be expanded to fill or the dummy node never drawn.					"					].				"Next: Find positions for nodes that are upstream from this node."	upStreamNodes := self getNodesUpstreamFromNode: node.	upStreamNodes				do: [ :upStreamNode | "Place upstream nodes to left and below priority node."					self layoutRecursiveWithNode: upStreamNode 					             relativePosition: (xy - (xIncrement@0))					                  seenBefore: priorNodes.					"ToDo: Calculate which node positions are intersected by connecting lines."					].	! !!HumDiagram methodsFor: 'layout' stamp: 'RichardAlexanderGreen 5/5/2015 12:21'!layoutEnergyOnNode: nodeA fromNode: nodeB	"Calculate a energy scalar. 	 Rules are similar to elctrostatic energy.	 But since the layout is in a 2-D world, 	  the energy rules are linear. (in this version)	 Note: This method assumes that nodeA and nodeB are directly connected.	"	| r qA qB attraction repulsion attractionFactor repulsionFactor |		"Radius is the length of the connection between the nodes."	r := self layoutDistanceFromNode: nodeA toNode: nodeB.		"Attractive force increases when the radius increases.	This is analog of spring rate.	"	attractionFactor  := 1.0.	attraction := attractionFactor * r.		"Repulsion increases when charge Q (number of direct connections) increases.	"	repulsionFactor := 1.0.	qA := self countNeighborsOfNode: nodeA.	qB := self countNeighborsOfNode: nodeB.		repulsion := repulsionFactor * ( qA + qB ).	"TODO: Consider using minimum of qA or qB.	 TODO: Consider dividing by r.	"		^ ( attraction - repulsion ). 	"Notes: 	1. Return value is a scalar quantity. Not a vector.	2. Since the connected entities require space on the diagram,	     it may work better if we sqared the connection 'charge' quantities.	3. Perhaps we should divide by 'radius' in the repulsion calculation.	4. This calculation assumes the that nodeA and nodeB are directly connected.	5. What if return was ( attraction / repulsion )?	"	"TODO: Refactor so that attraction and repulsion factors are instance variables and externally adjustable."	"TODO: Set up a UI where user can tinker with the factors. (And we can verify the intended layout effects.)"	! !!HumDiagram methodsFor: 'layout' stamp: 'RichardAlexanderGreen 5/5/2015 12:11'!layoutNode: aNode from: aPosition by: anIncrement	"Find a place for the given node starting from the given position.	 Increment the position until an empty position is found.	 Return the position where we placed the node.	Typically, aPosition is down-right from an existing node, and the increment is down - giving a tree-like structure.	"					| proposedPosition nodePosition |		proposedPosition := aPosition.	nodePosition := self getPositionForNode: aNode.	"If the node has already been positioned, leave it where it is."	[ nodePosition  isNil]		whileTrue: [ "Is the proposed position empty?"			((self mapPositionNode) at: proposedPosition ifAbsent: [nil])				ifNil: [ "Yes. It is empty"					nodePosition := proposedPosition.					self setNode: aNode position: nodePosition.					]				ifNotNil: ["Compute next proposed position"						 proposedPosition := proposedPosition + anIncrement.					].			].				"At this point, proposedPosition should be the related node`s position"	self assert: ( nodePosition = (self getPositionForNode: aNode) ).			"Return the position where we placed the node."		^ nodePosition.! !!HumDiagram methodsFor: 'layout' stamp: 'RichardAlexanderGreen 6/23/2014 13:57'!layoutDiagramWithNodeExtent: extentPoint nodeSpacing: spacingPoint	"Layout the diagram using the given node extent and spacing between node edges."	| xIncrement yIncrement nodePriority nodesByPriority |	"Following must be set before calling me."	self assert: ( extentPoint notNil ).	self assert: ( spacingPoint notNil ).	"Following is assumed in code below."	self assert: ( extentPoint  isKindOf: Point).	self assert: ( spacingPoint isKindOf: Point).	"Reset these instance (global) variables!!"	nodeExtent := extentPoint.	nodeSpacing := spacingPoint.		"Compute increments between grid locations."	"In this version, the placement is on a rectalinear grid.	But other/future versions may be radial and/or decrease as the number of priorNodes increases.	"	xIncrement := (nodeSpacing x) + (( nodeExtent x )/2).	yIncrement := (nodeSpacing y) + (( nodeExtent y )/2).		"Strategy: Prioritize the objects that have the most connections."	"Count the number of connections that each node has."	nodePriority := Dictionary new.	(self connections)		do: [ :map | 			| fromNode toNode fromCount toCount |			fromNode := map key.			toNode := map value. 			fromCount := nodePriority at: fromNode ifAbsent: [0].			nodePriority at: fromNode put: ( fromCount + 1).			toCount := nodePriority at: toNode ifAbsent: [0].			nodePriority at: toNode put: ( toCount + 1).			].	"Sort into a collection where nodes with most connections appear first."		nodesByPriority := SortedCollection new.	nodePriority 		keysAndValuesDo: [ :node :priority |			nodesByPriority add: ( (priority negated) -> node ).			]. 	"Place the nodes with the most connections on the first pass.	Note: This documentation uses term 'primary node' to refer to the node seen first.	      The primary node will be placed at 0@0.	"		nodesByPriority		do: [ :map |			| node xy |			node := map value.			xy := 0@0.			self layoutRecursiveWithNode: node relativePosition: xy seenBefore: (Set new).			xy := xy + (0@yIncrement).			]. 		! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/13/2013 09:02'!nodeSpacing: aPoint 	nodeSpacing := aPoint! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/13/2013 09:02'!nodeExtent: aPoint 	nodeExtent := aPoint! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/16/2013 10:21'!getNodesUpstreamFromNode: thisNode 	"Return nodes that are connected upstream from this node."	| result |	result := Set new.	( self connections )		do: [ :connection |			| upstreamNode downstreamNode |			upstreamNode := connection key.			downstreamNode := connection value.			( downstreamNode = thisNode )				ifTrue: [ result add: upstreamNode ].			].	^ result.! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2013 11:11'!nodes	^ nodes ifNil: [ nodes := Set new. ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/23/2014 13:53'!setNode: aNodeObject position: aPosition	"Node should also be in nodes collection for internal consistency."	self addNode: aNodeObject.	self mapNodePosition at: aNodeObject  put: aPosition.	self mapPositionNode at: aPosition put: aNodeObject.! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/23/2014 13:55'!mapPositionNode	" What node is at a position"	^ mapPositionNode ifNil: [ mapPositionNode := Dictionary new. ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2012 13:57'!addConnection: anAssociation	"anAssociation := ( fromNode -> toNode )"	self assert: ( anAssociation isKindOf: Association ).	self connections add: anAssociation.! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/10/2012 13:02'!title: aString	title := aString.	! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/18/2013 10:22'!countNeighborsOfNode: aNode	"Return the number of neighbors of this node.	 (Count nodes that are directly connected to this node)"	| count |	count := 0.	( self connections ) 		do: [ :map | (((map key) = aNode) or: [(map value) = aNode]) 			ifTrue: [ count := count + 1 ] ].	^ count! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/23/2014 13:54'!mapNodePosition	^ mapNodePosition ifNil: [ mapNodePosition := Dictionary new. ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/16/2013 10:21'!getNodesDownstreamFromNode: thisNode 	"Return nodes that are connected downstream from this node."	| result |	result := Set new.	( self connections )		do: [ :connection |			| upstreamNode downstreamNode |			upstreamNode := connection key.			downstreamNode := connection value.			( upstreamNode = thisNode )				ifTrue: [ result add: downstreamNode ].			].	^ result.! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/10/2012 13:01'!title	^ title ifNil: [ title := '** Diagram has no title!! **'].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 6/23/2014 13:52'!getPositionForNode: aNodeObject	^ self mapNodePosition at: aNodeObject ifAbsent: [ ^nil ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2013 08:54'!connections	^ connections ifNil: [ connections := Set new. ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/25/2013 12:40'!addNode: anObject	"A node object should have a title. 	(It should have something to display in a rendering or mouse-over or debug.) "	self assert: (anObject class selectors includes: #title ).	self nodes add: anObject.! !!HumDiagram methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 4/13/2013 08:58'!asSVGonHtmlCanvas: html width: aWidth height: aHeight 	"Render this diagram on the given Seaside canvas.	Note: We use SVG.	"	|  |	self assert: ( html isKindOf: WACanvas ).	html div 		class: 'diagram'; 		id: (self title asCamelCase);		with: ["Label and Diagram"			html strong: self title.			html break.			"Eventually, we want to draw the diagram using SVG."			( html tag: 'svg' ) 				attributeAt: 'width' put: (aWidth asString);     				attributeAt: 'height' put: (aHeight asString);				attributeAt: 'viewBox' put: '0 0 1000 1000';				attributeAt: 'style' put: 'background: CYAN';				"FOLLOWING IS A STUB -- EVENTUALLY THIS WILL DRAW NODES AND CONNECTIONS"				"ToDo: Finish this after we have layout working."				with: ["SVG path element"					( html tag: 'path' )						attributeAt: 'd' put: 'M 100 100  q 0,100 100,100 ';						attributeAt: 'fill' put: 'none';						attributeAt: 'stroke' put: 'red';						attributeAt: 'stroke-width' put: '1'.					( html tag: 'text' ) 						attributeAt: 'x' put: 200;						attributeAt: 'y' put: 200;						attributeAt: 'font-size' put: 20;						attributeAt: 'fill' put: 'BLUE';						with: 'This is just a test of the SVG text rendering.'					].			].! !!HumDiagram methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 5/5/2015 12:03'!asSVGonHtml: html width: aWidth height: aHeight 	"TODO: REFACTOR to render as HTML string."	|  |	self assert: ( html isKindOf: String ).	html div 		class: 'diagram'; 		id: (self title asCamelCase);		with: ["Label and Diagram"			html strong: self title.			html break.			"Eventually, we want to draw the diagram using SVG."			( html tag: 'svg' ) 				attributeAt: 'width' put: (aWidth asString);     				attributeAt: 'height' put: (aHeight asString);				attributeAt: 'viewBox' put: '0 0 1000 1000';				attributeAt: 'style' put: 'background: CYAN';				"FOLLOWING IS A STUB -- EVENTUALLY THIS WILL DRAW NODES AND CONNECTIONS"				"ToDo: Finish this after we have layout working."				with: ["SVG path element"					( html tag: 'path' )						attributeAt: 'd' put: 'M 100 100  q 0,100 100,100 ';						attributeAt: 'fill' put: 'none';						attributeAt: 'stroke' put: 'red';						attributeAt: 'stroke-width' put: '1'.					( html tag: 'text' ) 						attributeAt: 'x' put: 200;						attributeAt: 'y' put: 200;						attributeAt: 'font-size' put: 20;						attributeAt: 'fill' put: 'BLUE';						with: 'This is just a test of the SVG text rendering.'					].			].! !!HumDiagram methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 5/5/2015 11:58'!asSVGonSeasideCanvas: html width: aWidth height: aHeight 	"Render this diagram on the given Seaside canvas.	Note: We use SVG.	"	|  |	self assert: ( html isKindOf: (self seasideCanvas) ).	html div 		class: 'diagram'; 		id: (self title asCamelCase);		with: ["Label and Diagram"			html strong: self title.			html break.			"Eventually, we want to draw the diagram using SVG."			( html tag: 'svg' ) 				attributeAt: 'width' put: (aWidth asString);     				attributeAt: 'height' put: (aHeight asString);				attributeAt: 'viewBox' put: '0 0 1000 1000';				attributeAt: 'style' put: 'background: CYAN';				"FOLLOWING IS A STUB -- EVENTUALLY THIS WILL DRAW NODES AND CONNECTIONS"				"ToDo: Finish this after we have layout working."				with: ["SVG path element"					( html tag: 'path' )						attributeAt: 'd' put: 'M 100 100  q 0,100 100,100 ';						attributeAt: 'fill' put: 'none';						attributeAt: 'stroke' put: 'red';						attributeAt: 'stroke-width' put: '1'.					( html tag: 'text' ) 						attributeAt: 'x' put: 200;						attributeAt: 'y' put: 200;						attributeAt: 'font-size' put: 20;						attributeAt: 'fill' put: 'BLUE';						with: 'This is just a test of the SVG text rendering.'					].			].! !HumPane subclass: #HumMenu	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumMenu commentStamp: 'RichardAlexanderGreen 1/20/2014 09:48' prior: 0!A HumMenu represents a traditional UI menu with a list of command words.A Menu may invoke a submenu.!HumPane subclass: #HumView	instanceVariableNames: 'entityID entityName blackboard ontology viewFrame formWidget lastLevel calc'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumView commentStamp: 'RichardAlexanderGreen 3/27/2014 20:49' prior: 0!A HumView operates a MVC (model-view-controller)   where the model values are in a Blackboard. (See: HumBlackBoard).A Hum Ontology provides the metadata that is used to interpret views.A typical view shows the data for a single object instance.However, an object may have component/related objects and collections of component/related objects.A view contains a collection of widgets. (See: HumWidget and HumMarkupLine)View content and layout may be specified by a Hum View Frame. (See: HumFrame4View)Instance Variables:	entityName 	- an entity-type-name.	entityID 		- an entity-identifier known to blackboard	blackboard	 	- aHumBlackboard	ontology 		- aHumOntology ... provides source of view and informs the interpretation of attributes	viewFrame 		- fetched from ontology . . . contains markup lines	formWidget 	- The formWidget provides run-time interpretation of the view via Seaside - see >>renderContentOn:	lastLevel		- Tracks the nesting of lists.		TODO: Perhaps this should be a HumWidget and inherit from WAComponent.  OR: We could use WAFormTag as a component?  OR: Define a HumForm widget which is informed by a HumView and an Ontology.TODO: Should some Hum-Thing should correspond/subclass WAApplication? (WAApplication defines libraries.)!!HumView methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 4/20/2015 08:29'!renderFrameLine: aHumMarkupLine viaSeasideCanvas: aWAHtmlCanvas 	| html heading marker remainder level aString markupSource entity |	markupSource := aHumMarkupLine source.	aWAHtmlCanvas break.	self calc.	"Maintain spacing."	aString := calc given: markupSource replaceAll: '  ' with: '&nbsp;&nbsp;'.		"Is this markup line a heading?"	heading := 'none'.	(1 to: 5)		do: [ :i |			marker := '!!!!!!!!!!' copyFrom: 1 to: i.			( aString beginsWith: marker ) 				ifTrue: [ "Set the heading type and extract the remainder."					heading := 'h', (marker size) asString. 					remainder := (calc given: aString extractAfter: marker ) ]. 			].	"If this is a heading, render the whole line as a heading. "		"Call self recursively to catch any additional emphasis (e.g. italics)"	( heading = 'none'	) ifFalse: [ aWAHtmlCanvas heading level: (heading size); with: remainder. ^self ].	"Is this markup line a bullet/numbered list item."		#( '-----' '#####')		do: [ :leaderType |				level := 0.		(1 to: 5 )			do: [ :i |				marker := leaderType copyFrom: 1 to: i.				( aString beginsWith: marker ) 					ifTrue: [ "Set the heading type and extract the remainder."						level := (marker size). 						remainder := (calc given: aString extractAfter: marker ) ]. 				].		( level > 0 )			ifTrue: [				html := ''.				( (lastLevel isNil ) or: [ level > lastLevel ] ) 					ifTrue:[ 						(marker beginsWith: '-') ifTrue: [ self modeStack push: 'ul'].						(marker beginsWith: '#') ifTrue: [ self modeStack push: 'ol'].						html := '<',(self modeStack top),'>'.						].				"TODO: Figure out how to emit '</ul>' and '</ol>.' -- Might need MODES. (heavens)"				( (lastLevel notNil ) and: [ level < lastLevel ] ) 					ifTrue:[ 						html := '</',(self modeStack top),'>'. 						].				lastLevel := level.				html := html, (calc xml: 'li' with: (self halt "renderMarkupAsHTML5: remainder ")).				^html.					].			].		"TODO: AT THIS POINT - OUTPUT UP TO NEXT MARK-UP"	remainder := self renderUpToNextWidget: aString on: aWAHtmlCanvas.	aString := remainder.	['*[*]*' match: aString]		whileTrue: [ "Interpret by calling a HumWidget"			| between widget |			between := calc given: aString extractBetween: '[' and: ']'.			remainder := calc given: aString extractAfter: ']'.			entity := (self entityName).			((between at: (between size)) isDigit)				ifTrue: ["Update text"					| attributeName rows |					attributeName := calc given: between extractUpto: ' '.					rows := calc given: between extractAfter: ' '.					widget := HumTextWidget onEntity: entity attribute: between blackboard: blackboard.					widget rows: (rows asNumber).					]				ifFalse: ["Update . . ."					| supertypes |					"Default type is a simple string"					widget := HumStringWidget onEntity: entity attribute: between blackboard: blackboard.					"Check for special types"					supertypes := ontology allSupertypesOf: between.					(supertypes include: 'date')							ifTrue: [ widget := HumDateWidget onEntity: entity attribute: between blackboard: blackboard ].					(supertypes include: 'measure')							ifTrue: [ widget := HumMeasureWidget onEntity: entity attribute: between blackboard: blackboard ].					(supertypes include: 'collection')							ifTrue: [ widget := HumCollectionWidget onEntity: entity attribute: between blackboard: blackboard ].					(supertypes include: 'category')							ifTrue: [widget := HumCategoryWidget onEntity: entity attribute: between blackboard: blackboard.								widget categories: (ontology categoriesOf: between).								].					].			self renderUpToNextWidget: aString on: aWAHtmlCanvas.				widget renderContentOn: aWAHtmlCanvas.			aString := remainder.			]. 	! !!HumView methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 3/27/2014 22:22'!renderUpToNextWidget: aMarkupString on: html	"Render mark-up that does not involve heading/list/widget"	| wip remainder delimiters tokens target |		"Precondition: Caller has already handled and removed markup for header or list."	#( '!!' '-' '#' ) do: [:mark | self assert: (aMarkupString beginsWith: mark) not ].		"Break up the line. We will only render non-widget stuff."	self calc.	wip := calc given: aMarkupString extractUpto: '['.	remainder := calc given: aMarkupString extractAfter: wip.		"TODO: Interpret emphasis -- if any"	self interpretEmphasisIn: wip on: html.		^remainder.! !!HumView methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 3/27/2014 22:21'!interpretEmphasisIn: aString on: aWAHtmlCanvas 	"Stub"	aWAHtmlCanvas text: aString.! !!HumView methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 3/25/2014 10:01'!renderMarkupLinesViaSeasideOn: aWAHtmlCanvas 	"Render the ontology view frame lines via Seaside"	| |	(self view) frameLines		do: [:frameLine | self renderFrameLine: frameLine viaSeasideCanvas: aWAHtmlCanvas.].! !!HumView methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 3/20/2014 15:21'!asWidget	"Initialize a HumFormWidget for this view"	^formWidget ifNil: [ formWidget := HumFormWidget onView: self]! !!HumView methodsFor: 'tests' stamp: 'RichardAlexanderGreen 2/24/2013 10:04'!checkRenderOn: html	html form with: [ 		html break. html heading level: 2; with: ' Recipe'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: entityID attribute: #name toValue: datum ]; name: 'name'; value: 'name'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: entityID attribute: #description toValue: datum ]; name: 'description'; value: 'description'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: entityID attribute: #ingredients toValue: datum ]; name: 'ingredients'; value: 'ingredients'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: entityID attribute: #steps toValue: datum ]; name: 'steps'; value: 'steps'.		]! !!HumView methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2014 12:47'!entityName	^entityName ifNil: [Error signal: 'No entity name has been set for this view.']! !!HumView methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2014 12:53'!blackboard	^ blackboard ifNil: [ Error signal: 'No blackboard has been assigned to this view.'].! !!HumView methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/25/2014 09:59'!view	^ viewFrame ifNil: [Error signal: (self class asString),' not initialized']! !!HumView methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2014 12:46'!entityName: aString	"Set"	entityName := aString.! !!HumView methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/24/2014 17:36'!view: aViewNameString 	"Fetch the view frame of that name."	viewFrame :=  ontology fetchFrameByName: ('View: ',aViewNameString,'.').	self entityName: aViewNameString.	self id: aViewNameString.	! !!HumView methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/20/2014 14:43'!ontology: aHumOntology 	ontology := aHumOntology. ! !!HumView methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/20/2014 14:50'!blackboard: aHumBlackBoard	self assert: ( aHumBlackBoard isKindOf: HumBlackBoard ).	blackboard := aHumBlackBoard.! !!HumView methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/27/2014 21:09'!calc	"Create a calculator to be shared . . ."	^ calc ifNil: [ calc := HumCalculator new ].! !HumBox subclass: #HumAssembly	instanceVariableNames: 'parts'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumAssembly commentStamp: 'RichardAlexanderGreen 8/24/2015 09:02' prior: 0!HumAssembly contains the methods for calculating aggregate metrics such as: - bounding box,- total weight, - total floor space,- mass centroid (center of gravity)Assembly subtypes may provide pre-defined parameterized standard assembliessuch as - wall unit assemblies- door assemblies- deck assemblies- posts, beams, trusses- appliances (toilet, refrigerator, washer, dryer, water heater, furnace)- wheels, axles- furniture (seat, desk, counter)"Represents an assembly of parts.Positions parts relative to each other.Note: Currently no provision is made for clearances between parts.This may cause problems with rendering / viewing.TODO: Provide some minimal clearance between HumSolids during positioning or rendering.- Strategy A: Add one millimeter to given positions when positioning.- Strategy B: Subtract two millimeters from all three extents when rendering.(Numbers would round or show centimeters for some tabular views,      but would be sent in millimeters for rendering.)"!!HumAssembly methodsFor: 'render as VPython' stamp: 'RichardAlexanderGreen 10/23/2014 15:03'!asVPython	"Render my parts via Visual Python Things"	| pythonCode |	"Note: Put the assembly in a scene.	The preamble code must be generated via HumScene."	pythonCode := String new.	self parts do: [ :part | pythonCode := pythonCode, String cr, (part asVPython) ].	pythonCode := pythonCode, String cr.	^pythonCode.	! !!HumAssembly methodsFor: 'polygons' stamp: 'RichardAlexanderGreen 11/2/2015 17:08'!asPolygons	"Return polygons for my parts."	| assemblyPolygons |	assemblyPolygons := OrderedCollection new.	self exploded 		do: [ :part | 			| partPolygons |			partPolygons := part asPolygons.			assemblyPolygons addAll: partPolygons.		 	].	^assemblyPolygons.! !!HumAssembly methodsFor: 'polygons' stamp: 'RichardAlexanderGreen 10/19/2015 09:45'!asPolygonsColorCoded	"Return polygons for my parts."	| assemblyPolygons |	assemblyPolygons := OrderedCollection new.	self parts 		do: [ :part | 			| partPolygons |			partPolygons := part asPolygonsColorCoded.			assemblyPolygons addAll: partPolygons.		 	].	^assemblyPolygons.! !!HumAssembly methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/9/2013 09:54'!asX3D	"Return a string representing this assembly as a X3D element and scene.	"	|  x3d calc |	calc := HumCalculator new.	x3d := calc xml: 'X3D' dictionary: (self x3dBoilerPlate)	           with: [ self x3dScene ].	^x3d.! !!HumAssembly methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/10/2013 12:23'!x3dBackground	"Provide (default) X3D background element (skybox)"	| x3d |	x3d := '	<Background groundColor="0.7 0.7 0.7"                    skyAngle="0.05 1.5 1.59"                    skyColor="0.6 0.6 0.4  0.4 0.4 0.7  0.3 0.3 0.6  0.1 0.1 0.3"/>  '.	^x3d.! !!HumAssembly methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/5/2013 14:22'!x3dScene	"Return a string representing this assembly as a X3D scene.	"	|  x3d calc |	calc := HumCalculator new.	x3d := calc xml: 'Scene' with: [ ( self x3dBackground ), ( self x3dObjects ) ].	^x3d.! !!HumAssembly methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 10/29/2014 12:25'!x3DOM	"TODO: Generate HTML to enable X3DOM viewing in Browser."	| html |	self shouldBeImplemented.
	html := '<!!DOCTYPE html><html lang="en" style="width:100%; height:100%; border:0; margin:0; padding:0;"><head>    <meta charset="utf-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta name="apple-mobile-web-app-capable" content="yes">    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    <meta name="description" content="">    <meta name="keywords" content="">    <meta name="index" content="follow">    <meta name="revisit-after" content="2 days">        <title>Model: Landing Gear </title>        <link rel="stylesheet" href="static/x3dom.css" type="text/css" charset="utf-8"></link>    <link rel="stylesheet" type="text/css" href="static/css/jquery-ui-1.9.2.custom.css" />    <link rel="stylesheet" type="text/css" href="static/css/ui.css"/>    <style>        .x3dom-logContainer { bottom: 0px; position: absolute; }        body { width:100%; height:100%; border:0; margin:0; padding:0; }    </style>    <script src="static/x3dom-full.js" type="text/javascript"></script>        <script type="text/javascript" src="static/js/jquery-1.9.0.min.js"></script>    <script type="text/javascript" src="static/js/jquery-ui-1.9.2.custom.min.js"></script>    <script type="text/javascript" src="static/js/settings.js"></script>    <script type="text/javascript" src="static/js/ui.js"></script>     <script>        // LOD LUT HACK        //x3dom.debug.usePrecisionLevelAsTexCoord = true;    </script>     </head><body><div class="container" style="width:100%; height:100%; border:0; margin:0; padding:0;">    <div class="uiTransparent" id="statsWidget" style="right:4px; top:4px;">        <form class="uiHalfTransparent section" >            <!!-- Statistics-->            <div class="uiTransparent" title="Statistics">Statistics</div>            <div id="statistics" class="uiTransparent" >                <!!-- FPS -->                <div class="setting" id="fpsSetting" title="Frames per Second">                    <div id="FPS" style="font-size: 1.5em; ">                    </div>                </div>                <!!-- rendered triangles -->                <div class="setting" id="renderedTriangles" title="Amount of triangles currently rendered and total">                    <div class="settingName">Rendered Triangles</div>                    <div class="settingControlFullSize">                        <div id="renderedTrianglesPB" class="progress triangles" ><span></span></div>                    </div>                </div>                            </div>        </form>        <form class="uiHalfTransparent section">            <!!-- interaction -->            <div class="uiTransparent" title="Interaction">Interaction</div>            <div id="interaction" class="uiTransparent" >                              <!!-- Error Bound-->                                <div class="setting" id="errorBoundSetting" >                    <div class="settingName" id="ebTitle">Error Bound (Pixels): 1</div>                    <div class="settingControlFullSize">                        <div id="errorBoundSlider"></div>                    </div>                </div>                                <!!-- Interaction Factor-->                <div class="setting" id="interactionFactorSetting" >                    <div class="settingName" id="ifTitle">Interaction Factor: 1</div>                    <div class="settingControlFullSize">                        <div id="interactionFactorSlider"></div>                    </div>                </div>                                <!!-- Render Mode-->                <div class="setting" id="renderMode" title="Render mode settings">                    <div class="settingName" id="renderModeRadio">Render Mode</div>                    <div class="settingControlFullSize">                        <input type="radio" name="rendermode" id="renderPointsButton"><label for="renderPointsButton" class="roundBorders">Points</label></input>                        <input type="radio" name="rendermode" id="renderTrianglesButton" checked><label for="renderTrianglesButton" class="roundBorders">Faces</label></input>                                            </div>                </div>                             <div class="setting">                    <!!-- reset View -->                    <button id="rvButton" title="reset camera to initial position">Reset View</button>                </div>            </div>        </form>    </div>    <div id="HUDs_Div">       <div id="X3DOM_AOPT_Links" class="group" style="margin:2px; margin-top:26px; padding:4px; background-color:rgba(199,202,204,.7); position:absolute; float:center; z-index:1000;">         <a href="http://www.x3dom.org">X3DOM </a> output created with <a href="http://www.instantreality.org">InstantReality </a> aopt tool.      </div>             </div>        <x3d id="x3dElement" swfpath="static/x3dom.swf" showStat="false" showLog="false" style="width:100%; height:100%; border:0; margin:0; padding:0;">      <scene doPickPass="false">        <navigationInfo headlight="false"></navigationInfo>        <background skyColor="0 0 0"></background>                <directionalLight DEF="KEY_LIGHT"  color="0.9 0.9 1.0" direction="-0.7 -0.7 -0.3" intensity="1.0"></directionalLight>        <directionalLight DEF="FILL_LIGHT" color="0.9 0.7 0.4" direction="0.7   0.7 -0.3" intensity="0.9"></directionalLight>        <directionalLight DEF="BACK_LIGHT" color="1.0 0.9 0.0" direction="0.0   0.7  0.7" intensity="0.4"></directionalLight>              <inline DEF="MODEL" url="data/landinggear/landinggear-pop.x3d" mapDEFToID="true" nameSpaceName="model"></inline>      </scene>    </x3d>            </div></body></html>'.	^html.
! !!HumAssembly methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/9/2013 09:57'!x3dBoilerPlate	"Provide boilerplate attributes for X3D element"	"profile='Interchange' version='3.2' 	 xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' 	 xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-3.2.xsd'"	| attributes |	attributes := Dictionary new.	attributes		at: 'profile' put: 'Interchange';		at: 'version' put: '3.2';		at: 'xsd' put: 'http://www.w3.org/2001/XMLSchema-instance';		at: 'xsd:noNamespaceSchemaLocation' put: 'http://www.web3d.org/specifications/x3d-3.2.xsd'.	^attributes.! !!HumAssembly methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/10/2013 17:10'!x3dObjects	"Render each of the objects in my collection"	| x3d |
	x3d := '<Group ID="', (self id asString), '" >', String cr.	(self parts)		do: [ :part | x3d := x3d, (part asX3D) ].	x3d := x3d, '</Group>'.		^x3d.! !!HumAssembly methodsFor: 'enumerating' stamp: 'RichardAlexanderGreen 10/13/2015 15:17'!exploded	"Explode assemblies so that all the parts of parts become visible."	| allParts |	allParts := OrderedCollection new.	(self parts) do: [ :subassembly |  (subassembly exploded) do: [ :each | allParts add: each ] ].	^allParts.! !!HumAssembly methodsFor: 'events' stamp: 'RichardAlexanderGreen 10/8/2015 14:45'!changed	super changed.	"Transcript cr; show: 'Assembly ',self id,' changed.'."! !!HumAssembly methodsFor: 'events' stamp: 'RichardAlexanderGreen 10/8/2015 14:45'!update:  anObject 	"TBD"	"Transcript cr; show: 'Assembly: ', self id, ' sees update of: ', anObject asString."	self changed.! !!HumAssembly methodsFor: 'events' stamp: 'RichardAlexanderGreen 10/8/2015 14:46'!update: anAspect with: anObject 	"TBD"	Transcript cr; show: 'Assembly: ', self id, ' sees update of: ', anObject asString.	self halt.! !!HumAssembly methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/28/2015 08:44'!addPart: aHumBox	"Add the component to my parts list"	| |	self assert: ( aHumBox isKindOf: HumBox ).	(self parts) add: aHumBox.	"When the part is changed, the assembly (me myself) (e.g. scene) will be notified."	aHumBox addDependent: self.	aHumBox when: #changed send: #changed  to: self with: aHumBox.! !!HumAssembly methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/10/2013 12:00'!parts	^ parts ifNil: [ parts := Set new ].! !!HumAssembly methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/10/2013 13:57'!addParts: aCollection	"Add the component to my parts list"	| |	aCollection do: [ :each | self addPart: each ].! !!HumAssembly methodsFor: 'render as Three.js' stamp: 'RichardAlexanderGreen 12/12/2015 09:01'!asThreeJS	"render the parts contained in this assembly"	| js calc dictionary prologTemplate |	dictionary := Dictionary new.	dictionary at: 'assemblyID' put: (self asCamelCase ).	calc := HumCalculator new.	"TODO: Add method to generate Three.js boiler plate."	"Initialize geometry for this assembly."	prologTemplate := String cr, 'var @assemblyID = new THREE.Geometry();'.	js := calc fillTemplate: prologTemplate fromDictionary: dictionary.		( self parts )		do: [ :part | 				| assemblyTemplate assemblyJS |				"Create the part"				js := js, ( part asThreeJS ).				"Merge it into the assembly."				assemblyTemplate := '			THREE.GeometryUtils.merge( @assemblyID, @partID );', String cr.				dictionary at: 'partID' put: ( part asCamelCase ).				"The template drives this, producing one line of code."				assemblyJS := calc fillTemplate: assemblyTemplate fromDictionary: dictionary. 				js := js, assemblyJS. 				].	^js.! !!HumAssembly methodsFor: 'aggregate metrics' stamp: 'RichardAlexanderGreen 7/13/2015 11:02'!bbEastEdge	"Find my bounding box edge."	| myEdge |	myEdge :=self eastEdge.	self parts 		do: [ :part | 				| otherEdge |				otherEdge := (part eastEdge).				( otherEdge > myEdge ) ifTrue: [ myEdge := otherEdge ]				].	^eastEdge := myEdge.! !!HumAssembly methodsFor: 'aggregate metrics' stamp: 'RichardAlexanderGreen 7/13/2015 10:43'!bbTopEdge	"Find my bounding box edge."	| myEdge |	myEdge := self topEdge.	self parts 		do: [ :part | 				| otherEdge |				otherEdge := (part topEdge).				(otherEdge > myEdge ) ifTrue: [ myEdge := otherEdge ]				].	^topEdge := myEdge.! !!HumAssembly methodsFor: 'aggregate metrics' stamp: 'RichardAlexanderGreen 7/13/2015 10:44'!bbWestEdge	"Find my bounding box edge."	| myEdge |	myEdge := self westEdge.	self parts 		do: [ :part | 				| otherEdge |				otherEdge := (part westEdge).				(otherEdge < myEdge ) ifTrue: [ myEdge := otherEdge ]				].	^westEdge := myEdge.! !!HumAssembly methodsFor: 'aggregate metrics' stamp: 'RichardAlexanderGreen 7/13/2015 10:44'!bbSouthEdge	"Find my bounding box edge."	| myEdge |	myEdge := self southEdge.	self parts 		do: [ :part | 				| otherEdge |				otherEdge := (part southEdge).				(otherEdge < myEdge ) ifTrue: [ myEdge := otherEdge ]				].	^southEdge := myEdge.! !!HumAssembly methodsFor: 'aggregate metrics' stamp: 'RichardAlexanderGreen 7/11/2015 18:19'!bbWidth	"width of my bounding box"	| |	height := ( self bbEastEdge ) - ( self bbWestEdge ).	^height.! !!HumAssembly methodsFor: 'aggregate metrics' stamp: 'RichardAlexanderGreen 7/11/2015 18:26'!bbHeight	"height of my bounding box"	| |	height := ((self bbTopEdge) - (self bbBottomEdge)) abs.	^height.! !!HumAssembly methodsFor: 'aggregate metrics' stamp: 'RichardAlexanderGreen 7/13/2015 10:23'!bbDepth	"Depth is another name for length."	^self bbLength.! !!HumAssembly methodsFor: 'aggregate metrics' stamp: 'RichardAlexanderGreen 7/13/2015 10:44'!bbNorthEdge	"Find my bounding box edge."	| myEdge |	myEdge :=self northEdge.	self parts 		do: [ :part | 				| otherEdge |				otherEdge := (part northEdge).				(otherEdge > myEdge ) ifTrue: [ myEdge := otherEdge ]				].	^northEdge := myEdge.! !!HumAssembly methodsFor: 'aggregate metrics' stamp: 'RichardAlexanderGreen 7/13/2015 11:03'!bbLength	"length of my bounding box"	| |	height := ((self bbNorthEdge) - (self bbSouthEdge)) abs.	^height.! !!HumAssembly methodsFor: 'aggregate metrics' stamp: 'RichardAlexanderGreen 7/13/2015 10:44'!bbBottomEdge	"Find my bounding box edge."	| myEdge |	myEdge := self bottomEdge.	self parts 		do: [ :part | 				| otherEdge |				otherEdge := (part bottomEdge).				(otherEdge < myEdge ) ifTrue: [ myEdge := otherEdge ]				].	^bottomEdge := myEdge.! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 10/9/2015 10:31'!zcenter: aBox at: anArray 	"Center the part (aBox) at the given coordinates. { east. north. up. }	Note: Those coordinates are relative to my origin."	| eastOffset northOffset topOffset |	eastOffset  := self asMeasure: (anArray at: 1).	northOffset := self asMeasure: (anArray at: 2).	topOffset   := self asMeasure: (anArray at: 3).		"Assure that aBox is in my collection. "	self addPart: aBox.		"Compute edge positions to center aBox at those coordinates relative to my origin."	aBox eastEdge:  ( eastOffset  + ( (aBox width  ) * 0.5 ) ).	aBox northEdge: ( northOffset + ( (aBox length ) * 0.5 ) ).	aBox topEdge:   ( topOffset   + ( (aBox height ) * 0.5 ) ).		! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/11/2013 12:03'!position: boxA above: boxB	"synonym"	self position: boxA onTopOf: boxB! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 10/6/2015 09:52'!zcenter: boxB onTopOf: boxA   "Center boxB over boxA"	| baseCenter raisedCenter newCenter |	self addParts: { boxB. boxA. }.	self position: boxB onTopOf: boxA.	raisedCenter := boxB center.	baseCenter := boxA center.  "Adjust the x,y coordinates to match the bottom box`s center"	newCenter := Array new: 3.	newCenter at: 1 put: ( baseCenter at: 1).	newCenter at: 2 put: ( baseCenter at: 2 ).	"Keep the new Z."	newCenter at: 3 put: ( raisedCenter at: 3 ).	self center: boxB at: newCenter.! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/11/2013 12:02'!center: aHumBox over: aHumBox2 	"synonym"	self center: aHumBox onTopOf: aHumBox2 ! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/10/2013 14:02'!position: boxA westOf: boxB	"Position A on West edge of B."  "Assure both are in my collection."	self addParts: { boxA. boxB. }.	"By convention, A`s bottom will now equal B`s top."	boxA eastEdge: ( boxB westEdge ).! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/11/2013 12:01'!position: boxA over: boxB	"synonym"	self position: boxA onTopOf: boxB! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 10/6/2015 10:03'!center: boxB northOf: boxA   "Center boxB over boxA"	| newCenter |	self addParts: { boxB. boxA. }.	newCenter := { boxA centerX. ((boxA centerY) + boxA length). boxA centerZ.  }.	self center: boxB at: newCenter.! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/11/2013 12:00'!position: boxA below: boxB	"synonym"	self position: boxA onBottomOf: boxB! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/10/2013 14:01'!position: boxA northOf: boxB	"Position A on North edge of B."	"Assure both are in my collection."	self addParts: { boxA. boxB. }.  "By convention, A`s South edget will now equal B`s North."	boxA southEdge: ( boxB northEdge ).! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/10/2013 14:01'!position: boxA onTopOf: boxB	"Position A on top of B."  "Assure both are in my collection."	self addParts: { boxA. boxB. }.	"By convention, A`s bottom will now equal B`s top."	boxA bottomEdge: ( boxB topEdge ).! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 10/6/2015 10:03'!center: boxB southOf: boxA   "Center boxB over boxA"	| newCenter |	self addParts: { boxB. boxA. }.	newCenter := { boxA centerX. ((boxA centerY) - boxA length). boxA centerZ.  }.	self center: boxB at: newCenter.! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/11/2013 11:25'!position: boxA eastOf: boxB	"Position A on East edge of B."	"Assure both are in my collection."	self addParts: { boxA. boxB. }.	"By convention, A`s West edge will now equal B`s East edge. (zero clearance)"	boxA westEdge: ( boxB eastEdge ).	"Note that up-down  and north-south edges are not affected.	"! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 10/9/2015 18:54'!center: aBox at: a3Vector 	"Center the part (aBox) at the given coordinates. { east. north. up. }	Note: Those coordinates are relative to my origin."	|  calc |	calc := HumCalculator new.	calc cases;		when: [ a3Vector isKindOf: Array ] then: [ aBox centerAt: (HumVector newFrom: a3Vector). ];		when: [ a3Vector isKindOf: HumVector ] then: [ aBox centerAt: a3Vector ];		otherwise: [ Error signal: 'unexpected type sent to HumAssembly>>center:at:' ].	"Make sure I have that box in my parts list."	self addPart: aBox.		! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 10/8/2015 15:13'!advance: aBox by: anArray 	"Move the box by the given increments.	anArray is velocity per step.	( velocity per second divided by steps per second )	It`s elements have units of L^1 T^-1.	Note: This method moves box in assembly (scene) frame, not the boxes frame.	TODO: Think about moving box in its own coordinates - correcting for rotation and tilt.	"	| dEast dNorth dUp |	dEast  := self asMeasure: (anArray at: 1).	dNorth := self asMeasure: (anArray at: 2).	dUp    := self asMeasure: (anArray at: 3).		"Assure that aBox is in my collection. "	( self parts ) add: aBox.		"Compute edge positions to center aBox at those coordinates."	aBox eastEdge:  ( aBox eastEdge  + dEast ).	aBox northEdge: ( aBox northEdge + dNorth ).	aBox topEdge:   ( aBox topEdge   + dUp ).			! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/11/2013 12:03'!center: aHumBox above: aHumBox2 	"synonym"	self center: aHumBox onTopOf: aHumBox2 ! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 10/6/2015 10:10'!center: boxB eastOf: boxA   "Center boxB over boxA"	| newCenter |	self addParts: { boxB. boxA. }.	newCenter := { ((boxA centerX) + ( (boxA width + boxB width)/2.0) ). boxA centerY. boxA centerZ.  }.	self center: boxB at: newCenter.! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 10/6/2015 10:07'!center: boxB onTopOf: boxA   "Center boxB over boxA"	| newCenter |	self addParts: { boxB. boxA. }.	newCenter := { boxA centerX. boxA centerY. ((boxA centerZ) + ((boxA height + boxB height) / 2.0 )) }.	self center: boxB at: newCenter.! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 10/6/2015 10:08'!center: boxB below: boxA   "Center boxB over boxA"	| newCenter |	self addParts: { boxB. boxA. }.	newCenter := { boxA centerX. boxA centerY. ((boxA centerZ) - ((boxA height + boxB height) / 2.0 )) }.	self center: boxB at: newCenter.! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/10/2013 14:01'!position: boxA onBottomOf: boxB	"Position A on bottom of B."  "Assure both are in my collection."	self addParts: { boxA. boxB. }.	"By convention, A`s top will now equal B`s bottom."	boxA topEdge: ( boxB bottomEdge ).! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/11/2013 11:25'!position: boxA southOf: boxB	"Position A on South edge of B."  "Assure both are in my collection."	self addParts: { boxA. boxB. }.	"By convention, A`s North edge will now equal B`s South. (zero clearance)"	boxA northEdge: ( boxB southEdge ).! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/11/2013 12:04'!position: boxA under: boxB	"synonym"	self position: boxA onBottomOf: boxB! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 10/6/2015 10:17'!center: boxB westOf: boxA   "Center boxB over boxA"	| newCenter |	self addParts: { boxB. boxA. }.	newCenter := { ((boxA centerX) - ( (boxA width + boxB width)/2.0) ). boxA centerY. boxA centerZ.  }.	self center: boxB at: newCenter.! !HumAssembly subclass: #HumCamera	instanceVariableNames: 'orientationVector'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumCamera commentStamp: 'RichardAlexanderGreen 6/23/2016 11:42' prior: 0!The camera is modeled as a 'virtual' HumBox HumAssembly.It is initialized with the fustrum on the North Edge (away from the eye)and the eye pin-hole on the South Edge.The dimensions of the box determine the aspect ratio and the angle of view.To get a bug-eye (microscopic) view,   make the camera dimensions microscopic.To get a cosmic view (as seen via a telescope),   make the camera dimensions cosmic in scale.The camera is set up as an assembly to enable representing a camera as seen by another camera.  For example, a lense may be painted or represented as a cylinder. However, the default is just a box.!!HumCamera methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 10/15/2015 16:43'!unitSideways	"Return unit vector pointing along my internal x axis due to my rotation and tilt."	| x y z alpha beta unitVector |	alpha := (self rotation) + ( 90.0 degreesToRadians ).	beta := self tilt.	x := ( alpha sin ) * ( 1.0 ).	y := ( alpha cos ) * ( beta cos ).	z := ( alpha cos ) * ( beta sin ).	unitVector := HumVector newFrom: { x. y. z. } units: 'none'. "unit vector is dimensionless"	self assert: (  ( unitVector length quantity - 1.0 ) abs < (0.001 )  ).	^unitVector.! !!HumCamera methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 10/10/2015 12:40'!unitUpDown	"Return unit vector pointing along my internal x axis due to my rotation and tilt."	| x y z alpha beta unitVector |	alpha := ( self rotation ).	beta := ( self tilt ) + ( 90.0 degreesToRadians ).	x := ( alpha sin ) * ( 1.0 ).	y := ( alpha cos ) * ( beta cos ).	z := ( alpha cos ) * ( beta sin ).	unitVector := HumVector newFrom: { x. y. z. } units: 'none'. "unit vector is dimensionless"	self assert: (  ( unitVector length quantity - 1.0 ) abs < (0.001 )  ).	^unitVector.! !!HumCamera methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 10/10/2015 12:32'!unitForward	"Return unit vector pointing along my internal y axis due to my rotation and tilt."	| x y z alpha beta unitVector |	alpha := self rotation.	beta := self tilt.	x := ( alpha sin ) * ( 1.0 ).	y := ( alpha cos ) * ( beta cos ).	z := ( alpha cos ) * ( beta sin ).	unitVector := HumVector newFrom: { x. y. z. } units: 'none'. "unit vector is dimensionless"	self assert: (  ( unitVector length quantity - 1.0 ) abs < (0.001 )  ).	^unitVector.! !!HumCamera methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 10/15/2015 16:39'!slideLeft: aDistance	^self slideRight: (aDistance negated).		! !!HumCamera methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 10/10/2015 12:32'!slideBackward: aDistance	self slideForward: ( aDistance negated ).! !!HumCamera methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 10/10/2015 12:46'!slideUpward: aDistance	"Move in the direction the camera is pointing."	| myCentroid nextCentroid directionVector |	self assert: (aDistance isKindOf: HumMeasure). "a scalar"		myCentroid := self center.	self assert: (myCentroid isKindOf: HumVector).	directionVector := self unitUpDown.	self assert: (directionVector isKindOf: HumVector).	nextCentroid := myCentroid + (directionVector * aDistance).	self centerAt: nextCentroid.	self changed.		! !!HumCamera methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 10/10/2015 12:36'!slideForward: aDistance	"Move in the direction the camera is pointing."	| myCentroid nextCentroid directionVector |	self assert: (aDistance isKindOf: HumMeasure). "a scalar"		myCentroid := self center.	self assert: (myCentroid isKindOf: HumVector).	directionVector := self unitForward.	self assert: (directionVector isKindOf: HumVector).	nextCentroid := myCentroid + (directionVector * aDistance).	self centerAt: nextCentroid.	self changed.		! !!HumCamera methodsFor: 'move slide rotate tilt' stamp: 'RichardAlexanderGreen 10/15/2015 16:38'!slideRight: aDistance	"Move in the direction the camera is pointing."	| myCentroid nextCentroid directionVector |	self assert: (aDistance isKindOf: HumMeasure). "a scalar"		myCentroid := self center.	self assert: (myCentroid isKindOf: HumVector).	directionVector := self unitSideways.	self assert: (directionVector isKindOf: HumVector).	nextCentroid := myCentroid + (directionVector * aDistance).	self centerAt: nextCentroid.	self changed.		! !!HumCamera methodsFor: 'projection' stamp: 'RichardAlexanderGreen 8/3/2015 14:06'!eyeZ	"Eye in scene coordinates."	^((self topEdge) - ((self height) * 0.5) )! !!HumCamera methodsFor: 'projection' stamp: 'RichardAlexanderGreen 8/3/2015 14:07'!eyeY	"Eye in scene coordinates."	^(self northEdge) - (self depth).! !!HumCamera methodsFor: 'projection' stamp: 'RichardAlexanderGreen 10/10/2015 12:42'!eyeX	"Eye in scene coordinates.  	Note: In a simulation, this should be location of pin-hole; 	but . . . center point is more convenient."	^(self westEdge + ((self width) * 0.5) ).! !!HumCamera methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/11/2015 10:31'!isPointInFieldOfView: a3Dpoint 	"Is the given 3D point within my field of view.  	Note: The point must be in camera coordinates."	| x y z  pointDxDy pointDzDy  cameraDxDy cameraDzDy |		x := a3Dpoint at: 1.	y := a3Dpoint at: 2.	z := a3Dpoint at: 3.		"Is the point behind the camera`s aperture?"	(y  < (self depth)) ifTrue: [  ^false ].	"Is point in horizontal field of view?"	pointDxDy := x / y.	cameraDxDy :=  ( self width )  / ( self depth ).	( (pointDxDy abs) <= cameraDxDy ) ifFalse: [ ^false. ].	"Is point in verticle field of view?"	pointDzDy := z / y.	cameraDzDy :=  ( self height )  / ( self depth ).	( (pointDzDy abs) <= cameraDzDy ) ifFalse: [ ^false. ].	"Passed the filters. Looks okay."	^true.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumCamera class	instanceVariableNames: ''!!HumCamera class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 6/24/2016 08:57'!defaultCamera	"Dimension the virtual pin-hole camera box and position it"	| instance |	"These dimensions approximate a window at the position of a laptop screen.	To get other views, change the height, width, depth. 	Example: Try these dimensions on a millimeter scale - approximating dimensions of human eye.	"	instance := self		id: 'virtual pin-hole camera '		height: 7 inches  "height of my laptop screen"		width: 11 inches "width of my laptop screen"		depth: 20 inches. "typical distance from eye to laptop screen"	"Position it at a moderate adult eye height"	instance topEdge: (175 centimeter).	"Position North edge on zero plane."	instance northEdge: (1 centimeter).  "This hovers just in front of a default billboard."	"TODO: Add an assembly to model the camera as a box and cylinder."	^ instance.! !!HumCamera class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 9/17/2015 08:14'!onScene: aHumScene	"The scene will be notified when I am moved."	| instance |	instance := self defaultCamera.	instance scene: aHumScene.	^instance.! !HumAssembly subclass: #HumLayer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumLayer commentStamp: 'RichardAlexanderGreen 12/24/2013 09:25' prior: 0!In a CAD context, layers might be used to provide separate views for plumbing, walls, furniture, frames.In an animation or game context, layers may be used to group objects for special processing.For example, static objects, animated objects, players, and particles may be in separate layers.!HumAssembly subclass: #HumScene	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumScene commentStamp: 'RichardAlexanderGreen 12/11/2015 11:53' prior: 0!Scene attributes include sky, solids, cameras, layers.In a model-view-controller (MVC) context, a Scene is a model.We use a ViewPort Widget to visualize the content as seen by a Camera in the Scene.Data Flow:Scene entities include solids, assemblies, cameras.A user interface layout is controlled by Panes.A Pane may contain Widgets.A ViewPort Widget is a viewer-controller connected to a Camera in a Scene.I have found the Morph API and OpenGL API to be much too raster-oriented.Too much of the backend technology bleeds through into the API.I am trying to create an architecture (and API) where the rendering technology does not bleed into the view API (to say nothing of the scene representation).For example, the same scene could be rendered on a screen or via 3D printer.!!HumScene methodsFor: 'render as Three.js' stamp: 'RichardAlexanderGreen 10/29/2014 12:09'!asThreeJS	"Render the scene as ThreeJS"	| js calc prologTemplate epilogTemplate dictionary |	calc := HumCalculator new.	dictionary := Dictionary new.	dictionary at: 'sceneID' put: (self asCamelCase).	"Prolog: Create the ThreeJS scene with appropriate attributes."	js := self setupScene4ThreeJS.	"Render the content (layers or objects)"	js := js, ( self asThreeJSGeometry ).	"Append the epilog."	epilogTemplate := 'setupScene();'.	js := js, ( calc fillTemplate: epilogTemplate fromDictionary: dictionary ).	^js.! !!HumScene methodsFor: 'render as Three.js' stamp: 'RichardAlexanderGreen 10/29/2014 12:10'!setupFloor4ThreeJS	"Provide boilerplate that creates a visible floor."	| js |	"NOTE: JavaScript must call setupScene() before setupFloor()."	js := 'function setupFloor() {  // Floor  var geometry = new THREE.PlaneGeometry(2000, 2000, 20, 20);  var material = new THREE.MeshBasicMaterial({color: 0x9db3b5, overdraw: true});  var floor = new THREE.Mesh(geometry, material);  // floor.rotation.x = -90 * Math.PI / 180;  scene.add(floor);	}.'.	"TODO: Parameterize the size of the floor."	^ js.! !!HumScene methodsFor: 'render as Three.js' stamp: 'RichardAlexanderGreen 1/9/2014 08:49'!asThreeJSinHTML	"Wrap ThreeJS rendering with HTML5."	| html calc js worldScript dictionary  template |	calc := HumCalculator new.		html := '<!!DOCTYPE html><html lang="en">	<head>		<title>three.js webgl - orbit controls</title>		<meta charset="utf-8">		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">		<style>			body {				color: #000;				font-family:Monospace;				font-size:13px;				text-align:center;				font-weight: bold;				background-color: #fff;				margin: 0px;				overflow: hidden;			}			#info {				color:#000;				position: absolute;				top: 0px; width: 100%;				padding: 5px;			}			a {				color: red;			}		</style>	</head>	<body>		<div id="container"></div>		<!!--		<div id="info">			<a href="http://threejs.org" target="_blank">three.js</a> - orbit controls example		</div>		-->		<script src="js/three.min.js"></script>		<script src="js/OrbitControls.js"></script>		<script src="js/Detector.js"></script>				<script src="js/Stats.js"></script>		<script>			if ( !! Detector.webgl ) Detector.addGetWebGLMessage();			var container, stats;			var camera, controls, scene, renderer, myAssembly;			var cross;			init();			animate();			function init() {				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );				camera.position.z = 500;				controls = new THREE.OrbitControls( camera );				controls.addEventListener( "change", render );				scene = new THREE.Scene();				//scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );				// world								myAssembly = buildMyAssembly();  // Function is defined in separate script tag.				scene.add( myAssembly );								// lights				light = new THREE.DirectionalLight( 0xffffff );				light.position.set( 1, 1, 1 );				scene.add( light );				light = new THREE.DirectionalLight( 0x002288 );				light.position.set( -1, -1, -1 );				scene.add( light );				light = new THREE.AmbientLight( 0x222222 );				scene.add( light );				// renderer				renderer = new THREE.WebGLRenderer( { antialias: false } );				// renderer.setClearColor( scene.fog.color, 1 );				renderer.setSize( window.innerWidth, window.innerHeight );				container = document.getElementById( "container" );				container.appendChild( renderer.domElement );								// stats pane				stats = new Stats();				stats.domElement.style.position = "absolute";				stats.domElement.style.top = "0px";				stats.domElement.style.zIndex = 100;				container.appendChild( stats.domElement );				//				window.addEventListener( "resize", onWindowResize, false );			}			function onWindowResize() {				camera.aspect = window.innerWidth / window.innerHeight;				camera.updateProjectionMatrix();				renderer.setSize( window.innerWidth, window.innerHeight );				render();			}			function animate() {				requestAnimationFrame( animate );				controls.update();			}			function render() {				renderer.render( scene, camera );				stats.update();			}		'.		"Define a geometry named by (self asCamelCase)."		js := (self asThreeJSGeometry ).  		"Generate additional function to build geometry and insert it into scene."		dictionary := Dictionary new.		dictionary at: 'assemblyID' put: (self asCamelCase ).		template := '			function buildMyAssembly() {			', js,			'  return @assemblyID;			}'.		worldScript := calc fillTemplate: template fromDictionary: dictionary.		html := html, worldScript.				"Complete the HTML."		html := html, '		</script>	</body></html>'.	^html.! !!HumScene methodsFor: 'render as Three.js' stamp: 'RichardAlexanderGreen 1/1/2014 09:14'!asThreeJSGeometry	"Render the assembly as ThreeJS geometry"	| js |	"Render the content (layers or objects)"	js := ( super asThreeJS ).	^js.! !!HumScene methodsFor: 'render as Three.js' stamp: 'RichardAlexanderGreen 10/29/2014 12:09'!setupScene4ThreeJS	""	| js |	js := 'var camera, scene, renderer;function setupScene() {  document.body.style.backgroundColor = "#d7f0f7";  setupThreeJS();  requestAnimationFrame(function animate() {    renderer.render(scene, camera);    requestAnimationFrame(animate);  });}function setupThreeJS() {  scene = new THREE.Scene();  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);  camera.position.y = 400;  camera.position.z = 400;  camera.rotation.x = -45 * Math.PI / 180;  renderer = new THREE.CanvasRenderer();  renderer.setSize(window.innerWidth, window.innerHeight);  document.body.appendChild(renderer.domElement);}'.	^js, String cr.! !!HumScene methodsFor: 'render as VPython' stamp: 'RichardAlexanderGreen 10/23/2014 14:28'!asVPython	"render scene and the objects in it via VPython."	| pythonCode |	pythonCode := self asVPythonPreamble.	pythonCode := pythonCode, ( super asVPython ).	^ pythonCode.! !!HumScene methodsFor: 'render as VPython' stamp: 'RichardAlexanderGreen 10/22/2014 13:22'!asVPythonPreamble	| pythonCode |	pythonCode := 'from visual import *import Thingfrom Thing import BoxThingfrom Thing import PipeThing# Set window attributesscene.width=800scene.height=800scene.title="Scene Title"scene.background = ( 0.7, 0.7, 0.7 )# Set camera/viewport attributesscene.autoscale = Truescene.center = ( 4*12, 13*12, 4*12 )scene.up = ( 0, 0, 1 )'.	^ pythonCode.! !!HumScene methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 6/24/2016 10:22'!jump: aTime	"TODO: Is this consistent with HumSimulator?"	self parts do: [ :part | part jump: aTime ].! !HumAssembly subclass: #HumVR	instanceVariableNames: 'scenes jumpTime'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumVR commentStamp: 'RichardAlexanderGreen 6/24/2016 10:37' prior: 0!A Virtual Reality contains one or more Scenes.see also: HumScene.HumVR is a model.HumVRController is the intended controller.!!HumVR methodsFor: 'stepping' stamp: 'RichardAlexanderGreen 6/24/2016 10:26'!jumpTime	jumpTime ifNil: [ self jumpTime: (HumMeasure seconds: 1) ].	^jumpTime.! !!HumVR methodsFor: 'stepping' stamp: 'RichardAlexanderGreen 6/24/2016 10:26'!jumpTime: aTime	self assert: (aTime isKindOf: HumMeasure).	self assert: (aTime dimensions = (HumMeasure seconds: 1) dimensions ).	jumpTime := aTime.! !!HumVR methodsFor: 'stepping' stamp: 'RichardAlexanderGreen 6/24/2016 10:40'!jump:  aTime	"Execute equations of motion, etc."	self jumpTime: aTime.	self scenes do: [ :scene | scene jump: (self jumpTime) ].	"TODO: Make compatible to HumSimulator."! !!HumVR methodsFor: 'stepping' stamp: 'RichardAlexanderGreen 6/24/2016 10:44'!start	"Start stepping."	self jump: (self jumpTime) "*** STUB ***  TODO: Fork a process and start it stepping."! !!HumVR methodsFor: 'stepping' stamp: 'RichardAlexanderGreen 2/29/2016 08:03'!stop	"Stop stepping"	! !!HumVR methodsFor: 'access' stamp: 'RichardAlexanderGreen 2/29/2016 08:01'!addScene: aHumScene 	self scenes at: aHumScene id put: aHumScene.! !!HumVR methodsFor: 'access' stamp: 'RichardAlexanderGreen 2/29/2016 07:58'!scenes	^ scenes ifNil: [  scenes := Dictionary new ].! !HumWidget subclass: #HumCategoryWidget	instanceVariableNames: 'categories'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumCategoryWidget commentStamp: 'RichardAlexanderGreen 1/15/2016 14:32' prior: 0!Widget enables user to view and pick a category valuefor a noun of category type.The value of the attribute, if any, is the current value - displayed when I am rendered.!!HumCategoryWidget methodsFor: '*HumSeaside' stamp: 'RichardAlexanderGreen 3/27/2014 16:49'!renderContentOn: aWAHtmlCanvas	"render self via a simple input tag"	|  |aWAHtmlCanvas select		list: (self categories);		attributeAt: 'id' put: (self attributeName );		callback: [:value | self store: value ];		with: (self attributeValue asString).! !!HumCategoryWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/27/2014 16:50'!categories	^categories ifNil: [Error signal: 'categories have not been initialized']! !!HumCategoryWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/27/2014 16:28'!categories: anArrayOfCategoryNames 	categories := anArrayOfCategoryNames. ! !