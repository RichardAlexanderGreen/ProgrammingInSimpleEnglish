Object subclass: #HumEditor	instanceVariableNames: 'lineIndex characterIndex text keyboardActions'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumEditor commentStamp: 'RichardAlexanderGreen 8/7/2012 19:38' prior: 0!A HumEditor is attached to HumText.The editor provides the means to modify the text.The editor has a cursortPosition which defines where a cursor might be rendered and where character inserts and deletes may occur.The editor has a 'selection' which defines a part of the text that might be highlighted and processed.---Editor Actions   1. Usual text edit actions:      a) commands: (copy, cut, paste, un-do, save, open, print?, close window)      b) cursor moves: (up, down, left, right, top, bottom, . . .)   2. PA-specific actions:      a) [Line updated] event causes the logical-line and frame to be checked.         (1) The logical-line is rendered. 	           Keywords and nouns are emphasized. Nouns have links.          (2) If the logical-line is not understood (no definition in ontology or DSL),                the line is flagged (with a question-mark).         (3) If a noun lacks an antecedent in the frame, the noun is flagged (color code).      b) [Insert/Append Instruction] - Instructions are indented.         (1) In an action frame,                the automatic indent matches the preceding statement’s indent                unless it was a control statement (ending with a colon).                   And then, the indentation is increased by one.         (2) In plan and dialog frames,                instructions have only one level of indent                because control statements are not allowed in those contexts.         (3) In dialog frames,                the user indicates an instruction by starting the line with dot [tab].---!!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 18:37'!addLine: aString 	"Delegate to HumText instance."	(self text) addLine: aString! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 10:46'!characterIndex	"Character index is equal to the number of charactes to the left of the cursor."	^ characterIndex ifNil: [ characterIndex := 0 ].! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/12/2013 14:29'!characterIndex: aSmallInteger 	characterIndex := aSmallInteger.		(characterIndex < 0 ) 		ifTrue: [ characterIndex := 0.			"If sound is enabled, beep."			Beeper beep.			].! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 20:51'!currentLine	| result |	result := ( self lines ) at: ( self lineIndex ).	^result.! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/12/2013 14:22'!deletePriorCharacter	"Insert a character into the text at the current (cursor) position"	| humTextLine currentLine stringUpto stringAfter newLine currentIndex  |	"If cursor is at the front of the line, delete is a no op."	currentIndex := (self characterIndex).	( currentIndex = 0 ) ifTrue: [ Beeper beep. ^self ].	"Otherwise . . ."	humTextLine := (self lines) at: (self lineIndex).	currentLine := humTextLine string.	( currentIndex >= currentLine size )		ifFalse: [	stringUpto := currentLine copyFrom: 1 to: (currentIndex - 1).					stringAfter := currentLine copyFrom: (currentIndex+1) to: (currentLine size).					]		ifTrue: [ 	stringUpto := currentLine copyFrom: 1 to: (currentLine size - 1).			       	stringAfter := ''. 					].		newLine := stringUpto,  stringAfter.	humTextLine string: newLine.	"(self lines) at: (self lineIndex) put: humTextLine."	"Back the cursor."	self characterIndex: currentIndex - 1.	! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 10:49'!insertCharacter: aCharacter 	"Insert a character into the text at the current (cursor) position"	| humTextLine currentLine currentIndex stringUpto stringAfter newLine |	humTextLine := (self lines) at: (self lineIndex).	currentLine := humTextLine string.	currentIndex := self characterIndex.	( currentIndex >= currentLine size )		ifFalse: [	stringUpto := currentLine copyFrom: 1 to: currentIndex.					stringAfter := currentLine copyFrom: ( currentIndex +1 ) to: (currentLine size).					]		ifTrue: [ 	stringUpto := currentLine copy.			       	stringAfter := ''. 					].		newLine := stringUpto, (aCharacter asString), stringAfter.	humTextLine string: newLine.	"(self lines) at: (self lineIndex) put: humTextLine."	"Advance the cursor."	self characterIndex: (self characterIndex + 1).	! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 10:51'!insertLine	"Delegate to our HumText instance"	self text insertEmptyLineAfter: (self lineIndex).	"Adjust the cursor to point to the beginning of the new line."	lineIndex := lineIndex + 1.	characterIndex := 0.			! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 10:08'!lineIndex	^ lineIndex ifNil: [ lineIndex := 1 ].! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/31/2012 20:32'!lineIndex: aSmallInteger 	| maxLine |	lineIndex := aSmallInteger.	maxLine := ((self text ) lines size).	( lineIndex >  maxLine ) ifTrue: [ lineIndex := maxLine].	( lineIndex < 1 ) ifTrue: [ lineIndex := 1 ].! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 10:36'!lines	^ self text lines.! !!HumEditor methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 7/30/2012 17:42'!text	^ text ifNil: [ text := HumText new ].! !!HumEditor methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 7/31/2012 20:48'!interpretKey: aSymbol 	"Interpret various keyboard gestures."	| action |	keyboardActions ifNil: ["initialize"		keyboardActions := Dictionary  new.		keyboardActions			"Simple arrow keys"			at: #arrowUp put: [ self lineIndex: ( (self lineIndex) - 1) ];			at: #arrowDown put: [ self lineIndex: ( (self lineIndex) + 1 ) ];			at: #arrowLeft put: [ self characterIndex: ( (self characterIndex ) - 1) ];			at: #arrowRight put: [ self characterIndex: ( (self characterIndex ) + 1) ];						"Alt-Arrow keys"			at: #altArrowUp put: [ self lineIndex: 1];			at: #altArrowDown put: [ self lineIndex: ( self lines size ). 				                                   self characterIndex:  (self currentLine string size) ];			at: #altArrowLeft put: [ self characterIndex: 0 ];			at: #altArrowRight put: [ self characterIndex: (self currentLine string size) ];						"Escape key is a no-op at this time."			at: #escape put: [ Beeper beep ].		 ].	"Interpret the symbol (keyboard action name) given"	action := keyboardActions at: aSymbol 						ifAbsent: [ Error signal: 'No action for: ', (aSymbol asString)].	action value.	! !Object subclass: #HumTextPrettyPrinter	instanceVariableNames: 'startCommentToEndOfLine'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumTextPrettyPrinter commentStamp: 'RichardAlexanderGreen 8/7/2012 19:28' prior: 0!HumTextPrettyPrinter is designed to pretty print a text based upon parameters provided.Parameters include:- string that begins a multi-line comment -- example: '/*' in several notations derived from the C langauge.- string that ends a multi-line comment. -- example: '*/' in several notations.- string that begins a whole-line comment -- example: '#' in several notations.- string that begins a remainder-of-line comment -- example '//' in several notations.- string that begins a compiler directive -- example '@' in Java and other languages.- string of special characters that may be included in names -- example '_' in many languages, '_-' in COBOL.- tokens that represent "keywords" -- exampe 'if', 'else', 'begin', 'end', 'for', 'def', 'class', 'public', 'private'.- balanced pairs -- For example: '(...)', '[...]', '{...}'- string delimiters -- For example: "..." and '...' - string for indentation -- For example: tab or '. '- treatment for keywords -- example: bold, foreground blue- treatment for whole-line comment -- example: italic, background dark green, foreground yellow.- treatment for remainder-of-line comments -- example: italic, foreground green- treatment for multi-line comments -- example: italic, foreground green- treatment for strings -- example: normal, forground cyan- treatment for special characters -- example: bold, forground red- treatment for whole-line comment -- example: italic, background dark green, foreground yellow.!!HumTextPrettyPrinter methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/7/2012 19:54'!addCommentToEndOfLineStartsWith: aString 	| |	self assert: (aString isKindOf:  String).	startCommentToEndOfLine := aString.! !!HumTextPrettyPrinter methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 8/7/2012 20:06'!parse: aHumTextLine 	|  tokens ppTokens |	"delimiters := (' ', startCommentToEndOfLine )."	tokens := ( aHumTextLine string ) substrings. 	ppTokens := OrderedCollection new.	tokens do: [ :token | 		| ppToken |		ppToken := HumTextPrettyToken new.		ppToken string: token.		ppTokens add: ppToken.		].	^ ppTokens.	! !Object subclass: #HumBox	instanceVariableNames: 'length width height topEdge bottomEdge eastEdge westEdge northEdge southEdge origin velocity id'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumBox commentStamp: 'RichardAlexanderGreen 3/7/2012 21:48' prior: 0!Use this class to model static 3D box-like objects such as rooms, walls, doors, and windows.Although the term Box might might not work well with rooms, doors, and windows.you can think of those things as boxes that happen to be hollow or filled with air.The coordinate system is geographic and rectilinear.Any unit of measure may be used. 
You may use meters, feet, cm, mmwhatever you feel comfortable with 
and suits the domain you are modeling.Box-like objects may be positioned adjacent to each other.Instance Variables:	length	<Number>	width	<Number>	height	<Number>	"By convention length is North-to-South, width is East-to-West, and height is Top-to-Bottom."	topEdge	<Number>	bottomEdge	<Number>	eastEdge	<Number>	westEdge	<Number>	northEdge	<Number>	southEdge	<Number>	origin	<HumBox>	objects	<Set>              -- I am a container. I may contain (and layout) other HumBox objects.!!HumBox methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/9/2013 10:29'!asX3D	"Return a string in X3D notation representing this box / thing.	Caller is responsible for embedding this in a scene.	"	| templateString x3d calc space position extent |	space := String space.	  position := Dictionary new.  position at: 'translation' put: ( self x3dCenter ).	extent := Dictionary new.	extent at: 'size' put: ( self x3dExtent ).	calc := HumCalculator new.	x3d := calc xml: 'transform' dictionary: position 						   with: [ calc xml: 'box' dictionary: extent ].  "TODO: Subtypes may add appearance and/or material elements"								^x3d.! !!HumBox methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/5/2013 11:23'!x3dCenter	"Center of box (and/or center of bounding box) -- { x y z }	Note: This needs to map Hum coordinates to X3D coordinates.	"	| s |	"X"	s := ( self westEdge + ( (self width ) * 0.5 ) ) quantity asString.	"Y"	s := s, ' ', ( self southEdge + ( (self length ) * 0.5 ) ) quantity asString.
	"Z"	s := s, ' ', ( self bottomEdge + ( (self height ) * 0.5 ) ) quantity asString.	^s		! !!HumBox methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/12/2013 15:45'!x3dExtent	"Return x y z extents as a string	Note: This needs to map Hum coordinates to X3D coordinates.	TODO: HumSolid may override to subtract some clearance quantity (e.g. 1 or 2 mm) from quantities.	"	|s|	"X"	s :=         ( self mm: width  ).	"Y"	s := s, ' ', ( self mm: length ).	"Z"	s := s, ' ', ( self mm: height ).	^s.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/18/2013 21:00'!asMeasure: aQuantity	| measure |	( aQuantity isKindOf: HumMeasure )		ifTrue: [ measure := aQuantity ].	( aQuantity isKindOf: String ) 		ifTrue: [ measure := HumMeasure fromString: aQuantity ].	( aQuantity isKindOf: Number )		ifTrue: [ measure := HumMeasure quantity: aQuantity units: 'meter' ].	self assert: ( measure isKindOf: HumMeasure ).	^measure! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!bottomEdge	^ bottomEdge! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/18/2013 21:01'!bottomEdge: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset the bottom edge"	bottomEdge := measure.	"Force the top "	topEdge := bottomEdge + height.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/12/2013 15:23'!center	"Center of box (and/or center of bounding box) -- { x y z }"	| array |	"Compute my center coordinates"	array := Array new: 3.	array at: 1 put: ( self centerX ).	array at: 2 put: ( self centerY ).	array at: 3 put: ( self centerZ ).	^array		! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/12/2013 15:21'!centerX ^(self westEdge + ( (self width ) * 0.5 )).! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/12/2013 15:22'!centerY ^( self southEdge + ( (self length ) * 0.5 ) ).! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/12/2013 15:22'!centerZ ^( self bottomEdge + ( (self height ) * 0.5 )  ).! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/11/2013 13:03'!depth  "synonym"	^ length.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/11/2013 12:56'!depth: aHumMeasure 	"synonym"	self length: aHumMeasure.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!eastEdge	^ eastEdge! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/18/2013 21:02'!eastEdge: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset the East edge."	eastEdge := measure.	"Force the West edge."	westEdge := eastEdge - width.	! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:37'!height	"Get the height. By convention, height runs up and down."	^ height! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/12/2013 13:50'!height: aQuantity	"Reset the up-down dimension."	| measure |	measure := self asMeasure: aQuantity.
	height := measure.	self assert: ( height quantity >= 0.0 ).	"Hold botton steady and force the top."	topEdge := bottomEdge + height.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/5/2013 17:27'!id	"Identifier used in rendering context"	^ id ifNil: [ id := self identityHash printString ].! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/12/2013 13:51'!id: aString	"Identifier used in rendering contexts"	id := aString.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/12/2013 13:46'!id: aString height: aHeight width: aWidth depth: aDepth 	"synonym"	^ self id: aString height: aHeight width: aWidth length: aDepth.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/12/2013 13:46'!id: aString height: aHeight width: aWidth length: aDepth 	self initialize;	     id: aString; 	     height: aHeight; 	     width: aWidth; 	     depth: aDepth.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/5/2013 12:06'!initialize	"Set dimensions to zero."	| zero |	"By convention length is North-South, width is East-West, and height is top-bottom."	"X: East is +. West is -."	"Y: North is +. South is -."	"Z: Up is +. Down is -."	"Default system of metrics is MKS (Meters, Kilograms, Seconds)"	zero := 0 meter.	length := zero.	width := zero.	height := zero.	"Velocity vector = (northward, eastward, upward)"	velocity := { 0 mps. 0 mps. 0 mps.}. 	"Position edges at zero."	bottomEdge := zero.	topEdge := zero.	eastEdge := zero.	westEdge := zero.	northEdge := zero.	southEdge := zero.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:35'!length	"Get the length. By convention, length runs North and South."	^ length! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/12/2013 13:48'!length: aQuantity	"set North-South dimension"	| measure |	measure := self asMeasure: aQuantity.	"Reset the length. By convention, length runs North and South."	self assert: ( measure quantity >= 0.0 ).	length := measure.	"Hold South steady and force the North."	northEdge := southEdge + length.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/22/2013 20:00'!mm: aMeasure	"Format this measure to 3 digits accuracy - i.e. millimeter accuracy"	( aMeasure isKindOf: HumMeasure )			ifTrue: [^ aMeasure quantity printShowingDecimalPlaces: 3.].	( aMeasure isKindOf: Symbol )			ifTrue: [ |measure|				measure := self perform: aMeasure.				^ measure quantity printShowingDecimalPlaces: 3. ].			self fail.	! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/12/2013 14:11'!mmShave: aMeasure	"Format this measure to 3 digits accuracy - i.e. millimeter accuracy.	But first shave a millimeter from both ends."	^ (aMeasure - (2 millimeter)) quantity printShowingDecimalPlaces: 3.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!northEdge	^ northEdge! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/18/2013 21:04'!northEdge: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset North edge."	northEdge := measure.	"Hold North steady and force South."	southEdge := northEdge - length.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 14:26'!objects	"This set includes objects which move when I do.  	(In this sense, I am a container.)	Note: Coordinates are relative to parent containers.	Therefore, there is no need to correct child coordinates when the parent container is moved.	(The 'root' container is probably a scene graph and will not be moved.)	Note: 	Selectors 'advance: aBox by: #( x y z )' and 'center: aBox at: #( x y z)' and 'position ...'
           will add boxes to the container.	However, selectors that reset edge coordinates operate assume no container.	"	^ objects ifNil: [ objects := Set new. ].! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:32'!origin	"Origin is always a zero-sized object at (0 0 0)."	^ origin ifNil: [ origin := HumBox new.  ].! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!southEdge	^ southEdge! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/18/2013 21:04'!southEdge: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset the South edge."	southEdge := measure.	"Force North edge."	northEdge := southEdge + length.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!topEdge	^ topEdge! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/18/2013 21:05'!topEdge: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset the top edge."	topEdge := measure.	"Force the bottom edge."	bottomEdge := topEdge - height.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/21/2013 15:29'!volume	"Calculate the volume"	| v |	v := (self height) * (self width) * (self width).	"TODO: This should be a HumMeasure with dimension of L^3"	^v.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 15:16'!westEdge	^ westEdge! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/18/2013 21:05'!westEdge: aQuantity	| measure |	measure := self asMeasure: aQuantity.	"Reset the West edge."	westEdge := measure.	"Force the East edge."	eastEdge := westEdge + width.! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/31/2012 13:33'!width	"Get the width. By convention, the width runs East and West."	^ width! !!HumBox methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/12/2013 13:49'!width: aQuantity	"Reset the East-West dimension"	| measure |	measure := self asMeasure: aQuantity.	self assert: (measure quantity >= 0.0 ).	width := measure.	"Hold West edge steady and force the East edge."	eastEdge := westEdge + width.! !!HumBox methodsFor: 'render as Three.js' stamp: 'RichardAlexanderGreen 12/24/2013 10:01'!asCamelCase	^ (self id asCamelCase withFirstCharacterDownshifted ).! !!HumBox methodsFor: 'render as Three.js' stamp: 'RichardAlexanderGreen 12/24/2013 12:16'!asThreeJS	"Render this as a box in Three.js"	| js template dictionary calc|	"Note: Caller must merge this into a scene or group geometry"	template := '			var @ID = new THREE.Mesh( ( new THREE.CubeGeometry( @width, @length, @height   )  )			                            , ( new THREE.MeshBasicMaterial( { transparent: true } )  )			                            );			@ID.position.set( @x, @y, @z );'. 	dictionary := Dictionary new.	dictionary	  at: 'ID' put: (self asCamelCase );	  at: 'width'  put: ( self mm: width  );	  at: 'length' put: ( self mm: length );		at: 'height' put: ( self mm: height );		at: 'x' put: (self mm: #centerX );		at: 'y' put: (self mm: #centerY );		at: 'z' put: (self mm: #centerZ ).	calc := HumCalculator new.	js := calc fillTemplate: template fromDictionary: dictionary.	^js. ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumBox class	instanceVariableNames: ''!!HumBox class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/11/2013 13:36'!id: aString  height: aHeight width: aWidth depth: aLength 	"instantiate with these parameters"	| instance |	^self id: aString  height: aHeight width: aWidth length: aLength .! !!HumBox class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/11/2013 13:36'!id: aString  height: aHeight width: aWidth length: aLength 	"instantiate with these parameters"	| instance |	instance := self basicNew.	instance id: aString  height: aHeight width: aWidth depth: aLength.	^instance.! !HumBox subclass: #HumSolid	instanceVariableNames: 'typeOfSolid colorOfSolid mass density material'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumSolid commentStamp: 'RichardAlexanderGreen 3/30/2012 16:05' prior: 0!HumSolid is used to create solid objects such as avatars.
It is a subtype of HumBox in that each solid is expected to have bounding boxes.The methods of HumBox may be used for positioning where a loose position is adequate.!!HumSolid methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/10/2013 12:48'!asX3D	"Return a string in X3D notation representing this box / thing.	Caller is responsible for embedding this in a scene.	"	| template x3d calc dictionary |	"TODO: Replace this with a template implementation"	template := '	<Transform translation="@translation">		<Shape ID:="@ID">			<Appearance>				<Material diffuseColor="@diffuseColor" />			</Appearance>			<@type size="@boxExtent" />		</Shape>	</Transform>
  '.  dictionary := (Dictionary new).  dictionary 		at: 'translation' put: ( self x3dCenter );		at: 'ID' put: (self id);		at: 'diffuseColor' put: ( self x3dColor );		at: 'type' put: ( typeOfSolid );		at: 'boxExtent' put: ( self x3dExtent ).	calc := HumCalculator new.	x3d := calc fillTemplate: template fromDictionary: dictionary. 	^x3d.! !!HumSolid methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/10/2013 12:53'!x3dColor	"Translate my Smalltalk Color to x3dColor string"	| result sp c |	self assert: ( colorOfSolid isKindOf: Color ).	c := colorOfSolid.	sp := String space.	result := (c red   printShowingDecimalPlaces:2 ), sp, 	          (c green printShowingDecimalPlaces:2 ), sp, 	          (c blue  printShowingDecimalPlaces:2 ).	^result.! !!HumSolid methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/4/2013 12:02'!x3dExampleJSON	| json |		"Following is here to hold some useful patterns while I think over the design strategy."	json := '	{  "html": {    "-xmlns": "http://www.w3.org/1999/xhtml",    "head": {      "meta": [        {          "-http-equiv": "X-UA-Compatible",          "-content": "chrome=1"        },        {          "-http-equiv": "Content-Type",          "-content": "text/html;charset=utf-8"        }      ],      "title": "Primitives: Box, Cone, Cylinder and Sphere Primitives",      "link": {        "-rel": "stylesheet",        "-type": "text/css",        "-href": "x3dom.css"      }    },    "body": {      "h1": "Primitives: Box, Cone, Cylinder and Sphere Primitives",      "p": [        {          "-class": "case",          "X3D": {            "-xmlns": "http://www.web3d.org/specifications/x3d-namespace",            "-id": "boxes",            "-showStat": "true",            "-showLog": "false",            "-x": "0px",            "-y": "0px",            "-width": "400px",            "-height": "400px",            "Scene": {              "Background": { "-skyColor": "1 1 1" },              "Transform": [                {                  "-DEF": "coneTrafo",                  "-translation": "-4.5 0 0",                  "Shape": {                    "-DEF": "coneShape",                    "Appearance": {                      "-DEF": "coneApp",                      "Material": {                        "-diffuseColor": "0 1 0",                        "-specularColor": ".5 .5 .5"                      }                    },                    "Cone": { "-DEF": "cone" }                  }                },                {                  "-DEF": "boxTrafo",                  "-translation": "-1.5 0 0",                  "Shape": {                    "-DEF": "boxShape",                    "Appearance": {                      "-DEF": "boxApp",                      "Material": {                        "-diffuseColor": "1 0 0",                        "-specularColor": ".5 .5 .5"                      }                    },                    "Box": { "-DEF": "box" }                  }                },                {                  "-DEF": "sphereTrafo",                  "-translation": "1.5 0 0",                  "Shape": {                    "-DEF": "sphereShape",                    "Appearance": {                      "-DEF": "sphereApp",                      "Material": {                        "-diffuseColor": "0 0 1",                        "-specularColor": ".5 .5 .5"                      }                    },                    "Sphere": { "-DEF": "sphere" }                  }                },                {                  "-DEF": "cylinderTrafo",                  "-translation": "4.5 0 0",                  "Shape": {                    "-DEF": "cylinderShape",                    "Appearance": {                      "-DEF": "cylinderApp",                      "Material": {                        "-diffuseColor": "1 1 0",                        "-specularColor": ".5 .5 .5"                      }                    },                    "Cylinder": {                      "-DEF": "cylinder",                      "-radius": "1.0",                      "-height": "2.0"                    }                  }                }              ],              "Viewpoint": {                "-centerOfRotation": "0 0 0",                "-position": "0 0 15",                "-orientation": "0 1 0 0"              }            }          }        },        {          "-class": "case",          "#text": "   "        }      ],      "script": {        "-type": "text/javascript",        "-src": "x3dom.js"      }    }  }}	'.	^ json.! !!HumSolid methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/4/2013 12:03'!x3dExampleXML	"Example to aid design 	- This example shows how X3D is embedded in an HTML page."	| xml |	xml := '	<!!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml">	<head>        <meta http-equiv="X-UA-Compatible" content="chrome=1" />		<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />		<title>Primitives: Box, Cone, Cylinder and Sphere Primitives</title>        <link rel="stylesheet" type="text/css" href="x3dom.css" /	</head>       <body>    <h1>Primitives: Box, Cone, Cylinder and Sphere Primitives</h1>		<p class="case">		<X3D xmlns="http://www.web3d.org/specifications/x3d-namespace" id="boxes" showStat="true" showLog="false" x="0px" y="0px" width="400px" height="400px">			<Scene>				<Background skyColor="1 1 1"" />								<Transform DEF="coneTrafo" translation="-4.5 0 0">					<Shape DEF="coneShape">						<Appearance DEF="coneApp">							<Material diffuseColor="0 1 0" specularColor=".5 .5 .5" />						</Appearance>						<Cone DEF="cone" />					</Shape>				</Transform>								<Transform DEF="boxTrafo" translation="-1.5 0 0">					<Shape DEF="boxShape">						<Appearance DEF="boxApp"> 							<Material diffuseColor="1 0 0" specularColor=".5 .5 .5" />						</Appearance>						<Box DEF="box" />					</Shape>				</Transform>                				<Transform DEF="sphereTrafo" translation="1.5 0 0">					<Shape DEF="sphereShape">						<Appearance DEF="sphereApp">							<Material diffuseColor="0 0 1" specularColor=".5 .5 .5" />						</Appearance>						<Sphere DEF="sphere" />					</Shape>				</Transform>								<Transform DEF="cylinderTrafo" translation="4.5 0 0">					<Shape DEF="cylinderShape">						<Appearance DEF="cylinderApp">							<Material diffuseColor="1 1 0" specularColor=".5 .5 .5" />						</Appearance>						<Cylinder DEF="cylinder" radius="1.0" height="2.0" />					</Shape>				</Transform>                				<Viewpoint centerOfRotation="0 0 0" position="0 0 15" orientation="0 1 0 0" />			</Scene>        </X3D>	</p>		<p class="case"> &nbsp; </p>		<script type="text/javascript" src="x3dom.js"></script>   </body></html>'.	^xml.! !!HumSolid methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/5/2013 09:18'!x3dMaterial	"Return X3D element for appearance/material of this color and opacity.	"	| x3d c |	self assert: ( colorOfSolid isKindOf: Color ).	c := colorOfSolid.	x3d := self x3dMaterialColorRed: (c red) green: (c green) blue: (c blue) alpha: (c alpha).	^x3d.! !!HumSolid methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/10/2013 12:56'!x3dMaterialColorRed: red green: green blue: blue alpha: alpha 	"Return X3D element for appearance/material of this color and opacity."	| x3d calc space dict |	"All of the arguments are between zero and one."	{ red. green. blue. alpha. } do: [ :x | self assert: ( x >= 0.0 and: [ x <= 1.0 ]) ].	space := String space.  calc := HumCalculator new.  dict := Dictionary new.  dict at: 'color' put: (red printShowingDecimalPlaces:2), space,                       (green printShowingDecimalPlaces:2), space,                        (blue printShowingDecimalPlaces:2), space,                       (alpha printShowingDecimalPlaces:2).	x3d := calc xml: 'material' dictionary: dict.	^x3d.! !!HumSolid methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/5/2013 12:05'!x3dShape	"Produce X3D XML shape element"	| x3d  |	"Check that my typeOfSolid instance variable is x3d compatible."	self assert: ( #( #box #cone #cylinder #sphere) includes: typeOfSolid ).	x3d := self x3dShape: (typeOfSolid asString) diffuseColor: (self x3dColor) specularColor: '0.5 0.5 0.5'.	^x3d.! !!HumSolid methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/5/2013 17:26'!x3dShape: typeOfShape diffuseColor: diffuseColor specularColor: specularColor	"Produce X3D XML shape element - override instance variable color?"	| x3d calc template parameters |	calc := HumCalculator new.	template := '				<Transform translation="@position">					<Shape>						<Appearance>							<Material diffuseColor="@diffuseColor" specularColor="@specularColor" />						</Appearance>						<@typeOfShape DEF="NONE" id="@id" size="@extent" />					</Shape>				</Transform>				'.	parameters := Dictionary new.	parameters at: 'id' put: (self id);						at: 'position' put: ( self x3dCenter );	           at: 'typeOfShape' put: typeOfShape;              at: 'diffuseColor'  put: diffuseColor;              at: 'specularColor'  put: specularColor;              at: 'extent'   put: ( self x3dExtent ).	x3d := calc fillTemplate: template fromDictionary: parameters.	^x3d.! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/12/2013 15:02'!color	^colorOfSolid ifNil: [ colorOfSolid := Color gray. ].! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/12/2013 14:35'!color: aColor 	"What id the default (background) color of the surface and interior of this solid 3D object?"	self assert: ( aColor isKindOf: Color ).	colorOfSolid := aColor.! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2013 07:51'!density	"Return set density otherwise lookup the density of my material."	^ density ifNil: [ (self densityOfMaterial) ].! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/27/2013 09:44'!density: aMeasure	"What is the average density (mass per cube) of this solid?	*** Note: Use >>densityOfMaterial when possible. ***	*** Use this method to over-ride density given by material. ***	*** Example: You might use this method to provide average density of an aggregate. ***	"	self assert: ( aMeasure isKindOf: HumMeasure ).	"HumMeasure handles conversions to KMS units.	See also: methods in Number under HumMeasure category .	"	density := aMeasure.! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/27/2013 09:47'!densityOfMaterial	| result |	"The table is held on the class side to avoid clutter and instance bloat."	result := self class densityOfMaterial: material.	^result.! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 10/7/2013 15:01'!gravity	"Return the value of Earth gravity acceleration at sealevel. "	"TODO: Provide #gravityAtHeight: (height above ground)."	^ ( HumMeasure quantity: 9.8 units: 'Meters*Second^-2' ).	"TODO:	Improve the value with more decimal places."! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/5/2013 12:08'!initialize	super initialize.	self type: #box.! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2013 07:41'!mass	^ mass ifNil: [ (self volumn) * (self density)].! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/27/2013 09:41'!mass: aMeasure	"What is the mass of this object?"	self assert: ( aMeasure isKindOf: HumMeasure ).	"HumMeasure handles conversions to KMS units.	See also: methods in Number under HumMeasure category .	"	mass := aMeasure.! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2013 10:10'!material	^ material ifNil: [ Error signal: 'Material has not been set for this solid'].! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2013 10:05'!material: aString 	"See also: #densityOfMaterial for names of standard materials. "	self assert: ( aString isKindOf: String ).	material := aString.! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/21/2013 15:19'!type: aSymbol 	self assert: ( aSymbol isKindOf: Symbol ).	typeOfSolid := aSymbol.! !!HumSolid methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/26/2013 07:50'!weight	"Get the Earth-bound weight of the object. (Not the same as weight)"	^ ( self mass ) * ( self gravity ).! !!HumSolid methodsFor: 'render as Three.js' stamp: 'RichardAlexanderGreen 12/24/2013 10:01'!asThreeJS	"Render this solid  as a cube via three.js"	| js template dictionary calc|	"Note: Caller must merge this into a scene or group geometry"	template := '			var @ID = new THREE.Mesh( ( new THREE.CubeGeometry( @width, @length, @height )  )			                            , ( new THREE.MeshBasicMaterial( { color: 0x@color } )  )			                            );			@ID.position.set( @x, @y, @z );	'. 	"TODO: Dispatch to other kinds of shapes per the solid`s type."	dictionary := Dictionary new.	dictionary	  at: 'ID'    put: ( self asCamelCase );	  at: 'color' put: ( self color printHtmlString asLowercase );		  at: 'x' put: ( self mm: ( self centerX ) );	  at: 'y' put: ( self mm: ( self centerY ) );	  at: 'z' put: ( self mm: ( self centerZ ) );		  at: 'width'  put: ( self mm: width  );	  at: 'length' put: ( self mm: length );		at: 'height' put: ( self mm: height ).			calc := HumCalculator new.	js := calc fillTemplate: template fromDictionary: dictionary.	^js. 	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumSolid class	instanceVariableNames: 'materialDensity'!!HumSolid class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 12/11/2013 13:31'!id: anId type: aSymbol height: aHeight width: aWidth depth: aDepth 	"synonym"	^ self id: anId type: aSymbol height: aHeight width: aWidth length: aDepth. ! !!HumSolid class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 12/12/2013 13:44'!id: anId type: aSymbol height: aHeight width: aWidth length: aDepth "Create an instance . . ."	| solid |	solid := self new.	"delegate to super"	solid id: anId height: aHeight width: aWidth length: aDepth.	"and add: "	solid type: aSymbol.	^solid! !!HumSolid class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/27/2013 09:37'!densityOfMaterial: aMaterial	"Return the average mass-density of the given material."	| result |	aMaterial ifNil: [ Error signal: 'No material given. Cannot lookup density.'].		(( self materialDensity ) isEmpty )		ifTrue: [ "Densities are in kilogram-mass per meter^3"			materialDensity at: 'air' put: 1.2.			materialDensity at: 'foam' put: 24.         "Expanded Polystyrene Insulation"			materialDensity at: 'snow' put: 480.        "snow, compacted"			materialDensity at: 'wood' put: 708.        "red oak (denser than most). "			materialDensity at: 'ice' put: 919.         "solid ice"			materialDensity at: 'water' put: 1000.			materialDensity at: 'seawater' put: 1030.			materialDensity at: 'fiberglass' put: 1900. "Polyester and Continuous Rovings Laminate 70% E-glass"			materialDensity at: 'soil' put: 2082.       "picked wet sand as worst case. packed mud is 1906"			materialDensity at: 'sheetrock' put: 2320.  			materialDensity at: 'drywall'   put: 2320.  			materialDensity at: 'concrete' put: 2370.			materialDensity at: 'glass' put: 2580.      "window glass"			materialDensity at: 'rock'  put: 2700.      "granite, limestone, marble"			materialDensity at: 'stone' put: 2700.      "granite, limestone, marble"			materialDensity at: 'aluminum' put: 2739.			materialDensity at: 'titanium' put: 4500.			materialDensity at: 'steel' put: 7849.			materialDensity at: 'copper' put: 8900.			materialDensity at: 'lead' put: 11300.			].	result := HumMeasure quantity: (materialDensity at: (self aMaterial)) units: #kilogramPerCubicMeter.	^result.! !Object subclass: #HumTextPrettyToken	instanceVariableNames: 'foregroundColor backgroundColor isBold isItalic isUnderlined fontFamily fontSize string'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumTextPrettyToken commentStamp: 'RichardAlexanderGreen 9/25/2012 19:45' prior: 0!HumTextPrettyToken is a string that may be enhanced with color, emphasis, fonts, and font weightswhen it is "pretty printed".See also: HumTextPrettyPrinter.	foregroundColor 	backgroundColor 	isBold 	isItalic 	isUnderlined 	fontFamily 	fontSize!!HumTextPrettyToken methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/7/2012 20:08'!string		^ string ifNil: [ string := String new. ].! !!HumTextPrettyToken methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 8/7/2012 20:07'!string: aString 	self assert: ( aString isKindOf: String ).	string := aString.! !Object subclass: #HumSurface	instanceVariableNames: 'top bottom left right origin width height layer objects id title'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumSurface commentStamp: 'RichardAlexanderGreen 1/20/2014 10:29' prior: 0!HumSurface is like a movable canvas - a rectangular 2D surface.It is also a container which collects other 2D objects which are also HumSurface instances.It has a set of layout methods.Instance Variables:	top   <Number> -- top edge Y value	bottom	<Number> -- bottom edge Y value	left	  <Number> -- left edge X value	right	<Number> -- right edge X value			width	<Number> -- X extent	height	<Number> -- Y extent	layer	<Number> -- Z-order. Surfaces with higher layer numbers will overlay those with lower numbers.			origin	<HumSurface> -- a zero-size object positioned at (left top layer) = ( 0 0 0 )	objects	<Set> -- A set of dependent (child) objects. The children are rendered after I am.!!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:36'!bottom	^ bottom ifNil: [ bottom := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:56'!bottom: aNumber	"Reset the bottom edge."	bottom := self asMeasure: aNumber.	"Force top edge to be bottom + height"	top := bottom + (self height).! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/28/2013 10:49'!height	"What is the height of this object?	This is Y extent or length when surface is horizontal as seen on on table or document.	This is Z extent or height when surface is vertical as seen on a billboard.	The other dimensions are width and layer.	NOTE: In this model, a HumSurface has no thickness.	"	^ height ifNil: [ height := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:56'!height: aNumber.	"Reset the distance between top and bottom edges."	height := self asMeasure: aNumber.	"Force the bottom to be the top minus the height."	bottom := (self top) - height.! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/16/2012 12:31'!id	self assert: ( id isKindOf: String ).	self assert: ( id notEmpty ).	^ id! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2012 13:02'!id: aString 	id := aString.! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/4/2013 20:25'!initialize	| zero |	zero := HumMeasure quantity: 0 units: 'px'.	"zero := 0.00."	width := zero.	left := zero.	right := zero.		height := zero.	top := zero.	bottom := zero.		layer := zero.! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 5/4/2013 21:44'!initialize: units	| zero unitOfMeasure |	self assert: ( units isKindOf: String ).	"Reset #pixel to #px as needed.	In this case, the abbreviation is the preferred expression.	"	unitOfMeasure := units asString.	(units = 'pixel') ifTrue: [ unitOfMeasure := 'px' ]. 	(units = 'percent') ifTrue: [ unitOfMeasure := '%'].	zero := 0 perform: (units asSymbol).		width := zero.	left := zero.	right := zero.		height := zero.	top := zero.	bottom := zero.		layer := zero.! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/28/2013 10:36'!layer	"What layer is the surface in?	Surfaces with higher layer numbers will overlay (obscure) those with lower layer numbers.	You should avoid overlapping surfaces in the same layer. The result is not deterministic.	See also: #overlay:onTopOf:	"	"By default, a surface is in layer zero."	^ layer ifNil: [ layer := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:33'!layer: aNumber	layer := aNumber! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:35'!left	^ left ifNil: [ left := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/28/2013 10:17'!left: aNumber	| measure |	measure := self asMeasure: aNumber.	"Reset the left edge."	left := measure.	"Force the right edge to keep width constant."	right := left + (self width).! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 14:26'!objects	"I remember the 2d objects placed on me."	^ objects ifNil: [ objects := Set new. ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/28/2013 10:59'!origin	"a zero-size object positioned at ( left top layer ) = ( 0 0 0 )"		^ origin ifNil: [ origin := HumSurface new.  ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:35'!right	^ right ifNil: [ right := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:57'!right: aNumber		"Reset the right edge."	right := self asMeasure: aNumber.	"Force the left edge to keep the width constant."	left := right - (self width).! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2013 11:16'!title	^ title ifNil: [ self id ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2013 11:15'!title: aString	title := aString.	! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:36'!top	^ top ifNil: [ top := 0 ].! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/14/2012 20:58'!top: aNumber	"Reset the top edge."	top := self asMeasure: aNumber.	"Force the bottom edge to keep the height constant."	bottom := top - (self height).! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2012 13:32'!width	^ width! !!HumSurface methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/27/2013 10:14'!width: anObject	"Reset the width. 	This is the X extent in most contexts.	See also: height and layer."	width := self asMeasure: anObject.	"Force the right edge to be consistent."	right := (self left) + width.! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 1/20/2012 14:36'!overlay: aHumSurfaceB onTopOf: aHumSurfaceA 	"Both objects are assumed (forced) to be present in my collection."	( self objects ) add: aHumSurfaceA.	( self objects ) add: aHumSurfaceB.	"By convention, surface B will be aligned with A's top and left edges."	aHumSurfaceB top: (aHumSurfaceA top).		aHumSurfaceB left: (aHumSurfaceA left).	"By convention, surface B will be placed in a higher numbered layer."	"Note: If there already was already another object on top and in same layer, 	   there is no attempt to place this one in-between."	aHumSurfaceB layer: (aHumSurfaceA layer) + 1.	! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 3/28/2013 10:40'!place: aHumSurfaceB above: aHumSurfaceA 	"Place B above A on the surface. 	(Not to be confused with putting B on a different layer.)"		"Assure that A and B are in my collection."	(self objects) add: aHumSurfaceA.	(self objects) add: aHumSurfaceB.		"By convention, set B's bottom will be equal to A's top.	i.e. There is no gap."	aHumSurfaceB bottom: ( aHumSurfaceA top ).		"By convention, B is now in the same layer as A."	aHumSurfaceB layer: ( aHumSurfaceA layer ).		! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 1/20/2012 14:23'!place: aHumSurface at: anArray 	| x y z |	x := anArray at: 1.	y := anArray at: 2.	z := anArray at: 3.		( self objects ) add: aHumSurface.	aHumSurface top: y; left: x; layer: z.! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 3/28/2013 10:40'!place: aHumSurfaceB below: aHumSurfaceA 	"Place B below A on the surface. (Not to be confused with putting B on a different  layer.)"	"TODO: Consider making calls to top: right: left: using blocks (closures) so that everything is dynamic.	 Counter: Use relative positions. 	          When rendering, we will iterate (self objects). 	          If child object positions are relative, we get the same effect.	"		"Assure that A and B are in my collection."	(self objects) add: aHumSurfaceA.	(self objects) add: aHumSurfaceB.		"By convention, set B's top to be equal to A's bottom.	i.e. There is no gap."	aHumSurfaceB top: ( aHumSurfaceA bottom ).		"By convention, B is now in the same layer as A."	aHumSurfaceB layer: ( aHumSurfaceA layer ).		! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 3/28/2013 10:40'!place: aHumSurfaceB leftOf: aHumSurfaceA 	"Place B left of A on the surface. "		"Assure that A and B are in my collection."	(self objects) add: aHumSurfaceA.	(self objects) add: aHumSurfaceB.		"By convention, set B's left to be equal to A's right.	i.e. There is no gap / gutter."	aHumSurfaceB left: ( aHumSurfaceA right ).		"By convention, B is now in the same layer as A."	aHumSurfaceB layer: ( aHumSurfaceA layer ).		! !!HumSurface methodsFor: 'layout' stamp: 'RichardAlexanderGreen 3/28/2013 10:41'!place: aHumSurfaceB rightOf: aHumSurfaceA 	"Place B right of A on the surface. "		"Assure that A and B are in my collection."	(self objects) add: aHumSurfaceA.	(self objects) add: aHumSurfaceB.		"By convention, set B's right to be equal to A's left.	i.e. There is no gap / gutter."	aHumSurfaceB left: ( aHumSurfaceA right ).		"By convention, B is now in the same layer as A."	aHumSurfaceB layer: ( aHumSurfaceA layer ).		! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 10/30/2012 14:04'!asHTML	" Render surface as HTML"	| myBlock html calc |	calc := HumCalculator new.		myBlock := [ self asHtmlCanvasOffsetX: (self left) y: (self top) ].	html := calc xml: 'html' 				with: [ (calc xml: 'head' 					            with: [ calc xml: 'title' 						                         with: ['Surface as HTML' ]						                ]),					      (calc xml: 'body'					              with: [ myBlock value ])					    ].					^html.! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 12/9/2013 10:11'!asHtmlCanvasOffsetX: offsetX y: offsetY	"Return a HTML <rect . . . /> element for this surface."	| xml canvasAttributes nextLayer viewX viewY calc |	xml := String new.	canvasAttributes := Dictionary new.	( id notNil ) ifTrue: [ canvasAttributes add: 'id' -> id ].		"Don't scale dimensions in this version"	canvasAttributes at: 'width' put: width asString.	canvasAttributes at: 'height' put: height asString.	viewX := left + offsetX.	viewY := top + offsetY.		canvasAttributes at: 'x' put: viewX asString.	canvasAttributes at: 'y' put: viewY negated asString.  "Flip our Y value because HTML has Y pointing down."	canvasAttributes at: 'style' put: 'border:3px solid black;'.	calc := HumCalculator new.	xml := '  ', ( calc xml: 'canvas' dictionary: canvasAttributes ), String cr  .		nextLayer := ''.	(self objects )		do: [ :object | 			nextLayer := nextLayer, (object asHtmlCanvasOffsetX: viewX y: viewY).			].	xml := xml, nextLayer.	^xml. 		! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 3/16/2012 12:52'!asHumScript	| script space period |	space := ' '.	period := '.'.	script := '. Painter: '.	script := script, 'Paint surface with '.	script := script, space, 'id', space, (self id) quoted.	script := script, space, 'width', space, (self width) asString quoted.	script := script, space, 'height', space, (self height) asString quoted.	script := script, space, 'left', space, (self left) asString quoted.	script := script, space, 'top', space, (self top) asString quoted.		script := script, period.		( self objects )		do: [ :each | script := script, String cr, (each asHumScript ) ].		^script.! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 8/18/2013 20:59'!asMeasure: aQuantity	| measure |	( aQuantity isKindOf: HumMeasure )		ifTrue: [ measure := aQuantity ].	( aQuantity isKindOf: String ) 		ifTrue: [ measure := HumMeasure fromString: aQuantity ].	( aQuantity isKindOf: Number )		ifTrue: [ measure := HumMeasure quantity: aQuantity units: 'px' ].	self assert: ( measure isKindOf: HumMeasure ).	^measure! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 12/9/2013 10:16'!asSVG	| myBlock svg calc |		myBlock := [ self asSvgRectOffsetX: (self left) y: (self top) ].	calc := HumCalculator new.	svg := calc xml: 'svg' dictionary: ( HumSurface svgAttributes ) with: myBlock.		^svg.! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 3/3/2014 10:06'!asSvgRect	"Return a SVG <rect . . . /> element for this surface."	| xml rectAttributes nextLayer calc |	self delegated.	xml := String new.	rectAttributes := Dictionary new.	( id notNil ) ifTrue: [ rectAttributes at: 'ID' put: id ].		"TODO: Determine what SVG scale and transpose should be applied to this surface's rectangle."	rectAttributes at: 'width' put: width asString.	rectAttributes at: 'height' put: height asString.	calc := HumCalculator new.	xml := calc xml: 'rect' dictionary: rectAttributes .		"TODO: Order the objects by layer."	nextLayer := ''.	(self objects )		do: [ :object | 			nextLayer := nextLayer, object asSvgRect.			].	xml := xml, nextLayer.	^xml. 		! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 12/9/2013 10:52'!asSvgRectOffsetX: offsetX y: offsetY	"Return a SVG <rect . . . /> element for this surface."	| xml rectAttributes nextLayer viewX viewY calc |	xml := String new.	rectAttributes := Dictionary new.	( id notNil ) ifTrue: [ rectAttributes at: 'ID' put: id ]. "TODO: CLEAN UP THIS HACK."		"Don't scale dimensions in this version"	rectAttributes at: 'width' put: width asString.	rectAttributes at: 'height' put: height asString.	( offsetX quantity = 0 ) ifTrue: [ viewX := left ] ifFalse: [ viewX := left + offsetX ].	( offsetY quantity = 0 ) ifTrue: [ viewY := top  ] ifFalse: [ viewY := top  + offsetY ].	rectAttributes at: 'x' put: viewX asString.	rectAttributes at: 'y' put: viewY negated asString.  "Flip our Y value because SVG has Y pointing down."	calc := HumCalculator new.	xml := calc xml: 'rect' dictionary: rectAttributes .		nextLayer := ''.	(self objects )		do: [ :object | 			nextLayer := nextLayer, (object asSvgRectOffsetX: viewX y: viewY).			].	xml := xml, nextLayer.	^xml. 		! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 12/9/2013 10:18'!asSvgViewBox	| attributes viewBoxAttribute space myBlock svg calc |	"Set up standard attributes for the svg prolog."	calc := HumCalculator new.	space := $   asString.	attributes := Dictionary new.	attributes at: 'xmlns' put: 'http://www.w3.org/2000/svg'.	attributes at: 'xmlns:xlink' put: 'http://www.w3.org/1999/xlink'.	attributes at: 'width' put: '100%'.	attributes at: 'height' put: '100%'.		viewBoxAttribute := self left quantity asString, space, self top quantity asString, space, self width quantity asString, space, self height quantity asString.	attributes add: 'viewBox' -> viewBoxAttribute.		myBlock := [ self asSvgRectOffsetX: 0 px y: 0 px.  ].		svg := calc xmlOpen: 'svg' dictionary: attributes.	svg := svg, '<g stroke="#001122" stroke-width="0.03" fill="ffeedd" >'.	svg := svg, ( myBlock value).	svg := svg, '</g>'.	svg := svg, '</svg>'.	^svg.! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 12/9/2013 10:16'!asXML	| myBlock xml calc |		myBlock := [ self asXMLRectOffsetX: (self left) y: (self top) ].	calc := HumCalculator new.	xml := calc xml: 'script' dictionary: ( HumSurface humSurfaceAttributes ) with: myBlock.		^xml.! !!HumSurface methodsFor: 'converting' stamp: 'RichardAlexanderGreen 12/9/2013 11:01'!asXMLRectOffsetX: offsetX y: offsetY 	"Return a hum <surface . . . /> element for this surface."	| xml rectAttributes nextLayer viewX viewY calc |	xml := String new.	rectAttributes := Dictionary new.	( id notNil ) ifTrue: [ rectAttributes add: 'ID' -> id ].		rectAttributes at: 'width' put: width asString.	rectAttributes at: 'height' put: height asString.	viewX := left + offsetX.	viewY := top + offsetY.		rectAttributes at: 'x' put: viewX asString.	rectAttributes at: 'y' put: viewY asString.  	calc := HumCalculator new.	xml := calc xml: 'hum:surface' dictionary: rectAttributes .		nextLayer := ''.	(self objects )		do: [ :object | 			nextLayer := nextLayer, (object asXMLRectOffsetX: viewX y: viewY).			].	xml := xml, nextLayer.	^xml. 		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumSurface class	instanceVariableNames: ''!!HumSurface class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/16/2012 11:40'!humAttributes	"Set up standard attributes for the hum UI prolog."	| dict |	dict := OrderedCollection new.	dict add: 'src' -> 'scripts/hum.js'.	dict add: 'defer' -> 'defer'.	^dict.! !!HumSurface class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/9/2013 10:22'!humSurfaceAttributes	"Set up standard attributes for the hum UI prolog."	| dict |	dict := Dictionary new.	dict at: 'src' put: 'scripts/humSurface.js'.	dict at: 'defer' put: 'defer'.	^dict.! !!HumSurface class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/9/2013 10:22'!svgAttributes	"Will generate default attributes as follows:	<svg 	xmlns='http://www.w3.org/2000/svg' 			xmlns:xlink='http://www.w3.org/1999/xlink' 			width='100%'			height='100%'			>	Note: 100% width and height assumes that the actual size constraint 	will be defined in an enclosing <div . . .> tag.			"	| dict |	"Return default attributes for the svg prolog as a list of associations."	dict := Dictionary new.	dict at: 'xmlns' put: 'http://www.w3.org/2000/svg'.	dict at: 'xmlns:xlink' put: 'http://www.w3.org/1999/xlink'.	dict at: 'width' put: '100%'.	dict at: 'height' put: '100%'.	^dict.	! !HumBox subclass: #HumAssembly	instanceVariableNames: 'parts'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumAssembly commentStamp: 'RichardAlexanderGreen 12/11/2013 11:42' prior: 0!HumAssembly contains the methods for calculating aggregate metrics such as - total weight, - total floor space,- mass centroid (center of gravity)The assembly may also hold parameters that are global to the assembly.For example: Standard wall height. Standard panel width.Assembly subtypes may provide pre-defined parameterized standard assembliessuch as - wall unit assemblies- door assemblies- deck assemblies- posts, beams, trusses- appliances (toilet, refrigerator, washer, dryer, water heater, furnace)- wheels, axles- furniture (seat, desk, counter)"Represents an assembly of parts.Positions parts relative to each other.Note: Currently no provision is made for clearances between parts.This may cause problems with rendering / viewing.TODO: Provide some minimal clearance between HumSolids during positioning or rendering.- Strategy A: Add one millimeter to given positions when positioning.- Strategy B: Subtract two millimeters from all three extents when rendering.(Numbers would round or show centimeters for some tabular views,      but would be sent in millimeters for rendering.)"!!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/5/2013 08:13'!advance: aBox by: anArray 	"Move the box by the given increments.	anArray is velocity per step.	( velocity per second divided by steps per second )	It`s elements have units of L^1 T^-1.	"	| dEast dNorth dUp |	dEast  := self asMeasure: (anArray at: 1).	dNorth := self asMeasure: (anArray at: 2).	dUp    := self asMeasure: (anArray at: 3).		"Assure that aBox is in my collection. "	( self objects ) add: aBox.		"Compute edge positions to center aBox at those coordinates"	aBox eastEdge:  ( aBox eastEdge  + dEast ).	aBox northEdge: ( aBox northEdge + dNorth ).	aBox topEdge:   ( aBox topEdge   + dUp ).			! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/11/2013 12:03'!center: aHumBox above: aHumBox2 	"synonym"	self center: aHumBox onTopOf: aHumBox2 ! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/13/2013 10:19'!center: aBox at: anArray 	"Center the part (aBox) at the given coordinates.	Note: Those coordinates are relative to my origin."	| east north top |	east  := self asMeasure: (anArray at: 1).	north := self asMeasure: (anArray at: 2).	top   := self asMeasure: (anArray at: 3).		"Assure that aBox is in my collection. "	self addPart: aBox.		"Compute edge positions to center aBox at those coordinates relative to my origin."	aBox eastEdge:  ( east  + ( (aBox width  ) * 0.5 ) ).	aBox northEdge: ( north + ( (aBox length ) * 0.5 ) ).	aBox topEdge:   ( top   + ( (aBox height ) * 0.5 ) ).		! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/21/2013 16:41'!center: boxB onTopOf: boxA   "Center boxB over boxA"	| baseCenter raisedCenter newCenter |	self addParts: { boxB. boxA. }.	self position: boxB onTopOf: boxA.	raisedCenter := boxB center.	baseCenter := boxA center.  "Adjust the x,y coordinates to match the bottom box`s center"	newCenter := Array new: 3.	newCenter at: 1 put: ( baseCenter at: 1).	newCenter at: 2 put: ( baseCenter at: 2 ).	"Keep the new Z."	newCenter at: 3 put: ( raisedCenter at: 3 ).	self center: boxB at: newCenter.! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/11/2013 12:02'!center: aHumBox over: aHumBox2 	"synonym"	self center: aHumBox onTopOf: aHumBox2 ! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/11/2013 12:03'!position: boxA above: boxB	"synonym"	self position: boxA onTopOf: boxB! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/11/2013 12:00'!position: boxA below: boxB	"synonym"	self position: boxA onBottomOf: boxB! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/11/2013 11:25'!position: boxA eastOf: boxB	"Position A on East edge of B."	"Assure both are in my collection."	self addParts: { boxA. boxB. }.	"By convention, A`s West edge will now equal B`s East edge. (zero clearance)"	boxA westEdge: ( boxB eastEdge ).	"Note that up-down  and north-south edges are not affected.	"! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/10/2013 14:01'!position: boxA northOf: boxB	"Position A on North edge of B."	"Assure both are in my collection."	self addParts: { boxA. boxB. }.  "By convention, A`s South edget will now equal B`s North."	boxA southEdge: ( boxB northEdge ).! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/10/2013 14:01'!position: boxA onBottomOf: boxB	"Position A on bottom of B."  "Assure both are in my collection."	self addParts: { boxA. boxB. }.	"By convention, A`s top will now equal B`s bottom."	boxA topEdge: ( boxB bottomEdge ).! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/10/2013 14:01'!position: boxA onTopOf: boxB	"Position A on top of B."  "Assure both are in my collection."	self addParts: { boxA. boxB. }.	"By convention, A`s bottom will now equal B`s top."	boxA bottomEdge: ( boxB topEdge ).! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/11/2013 12:01'!position: boxA over: boxB	"synonym"	self position: boxA onTopOf: boxB! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/11/2013 11:25'!position: boxA southOf: boxB	"Position A on South edge of B."  "Assure both are in my collection."	self addParts: { boxA. boxB. }.	"By convention, A`s North edge will now equal B`s South. (zero clearance)"	boxA northEdge: ( boxB southEdge ).! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/11/2013 12:04'!position: boxA under: boxB	"synonym"	self position: boxA onBottomOf: boxB! !!HumAssembly methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 12/10/2013 14:02'!position: boxA westOf: boxB	"Position A on West edge of B."  "Assure both are in my collection."	self addParts: { boxA. boxB. }.	"By convention, A`s bottom will now equal B`s top."	boxA eastEdge: ( boxB westEdge ).! !!HumAssembly methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/9/2013 09:54'!asX3D	"Return a string representing this assembly as a X3D element and scene.	"	|  x3d calc |	calc := HumCalculator new.	x3d := calc xml: 'X3D' dictionary: (self x3dBoilerPlate)	           with: [ self x3dScene ].	^x3d.! !!HumAssembly methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/10/2013 12:23'!x3dBackground	"Provide (default) X3D background element (skybox)"	| x3d |	x3d := '	<Background groundColor="0.7 0.7 0.7"                    skyAngle="0.05 1.5 1.59"                    skyColor="0.6 0.6 0.4  0.4 0.4 0.7  0.3 0.3 0.6  0.1 0.1 0.3"/>  '.	^x3d.! !!HumAssembly methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/9/2013 09:57'!x3dBoilerPlate	"Provide boilerplate attributes for X3D element"	"profile='Interchange' version='3.2' 	 xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' 	 xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-3.2.xsd'"	| attributes |	attributes := Dictionary new.	attributes		at: 'profile' put: 'Interchange';		at: 'version' put: '3.2';		at: 'xsd' put: 'http://www.w3.org/2001/XMLSchema-instance';		at: 'xsd:noNamespaceSchemaLocation' put: 'http://www.web3d.org/specifications/x3d-3.2.xsd'.	^attributes.! !!HumAssembly methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/10/2013 17:10'!x3dObjects	"Render each of the objects in my collection"	| x3d |
	x3d := '<Group ID="', (self id asString), '" >', String cr.	(self parts)		do: [ :part | x3d := x3d, (part asX3D) ].	x3d := x3d, '</Group>'.		^x3d.! !!HumAssembly methodsFor: 'render as X3D' stamp: 'RichardAlexanderGreen 12/5/2013 14:22'!x3dScene	"Return a string representing this assembly as a X3D scene.	"	|  x3d calc |	calc := HumCalculator new.	x3d := calc xml: 'Scene' with: [ ( self x3dBackground ), ( self x3dObjects ) ].	^x3d.! !!HumAssembly methodsFor: 'render as Three.js' stamp: 'RichardAlexanderGreen 12/24/2013 12:20'!asThreeJS	"render the parts contained in this assembly"	"TODO: Add method to generate Three.js boiler plate."	| js calc dictionary prologTemplate |	dictionary := Dictionary new.	dictionary at: 'assemblyID' put: (self asCamelCase ).	calc := HumCalculator new.	"Initialize geometry for this assembly."	prologTemplate := String cr, 'var @assemblyID = new THREE.Geometry();'.	js := calc fillTemplate: prologTemplate fromDictionary: dictionary.	( self parts )		do: [ :part | 				| assemblyTemplate assemblyJS |				"Create the part"				js := js, ( part asThreeJS ).				"Merge it into the assembly."				assemblyTemplate := '			THREE.GeometryUtils.merge( @assemblyID, @partID );', String cr.				dictionary at: 'partID' put: ( part asCamelCase ).				assemblyJS := calc fillTemplate: assemblyTemplate fromDictionary: dictionary.				js := js, assemblyJS. 				].	^js.! !!HumAssembly methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/10/2013 13:56'!addPart: aHumBox	"Add the component to my parts list"	| |	self assert: ( aHumBox isKindOf: HumBox ).	(self parts) add: aHumBox.! !!HumAssembly methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/10/2013 13:57'!addParts: aCollection	"Add the component to my parts list"	| |	aCollection do: [ :each | self addPart: each ].! !!HumAssembly methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/10/2013 12:00'!parts	^ parts ifNil: [ parts := Set new ].! !Object subclass: #HumWidget	instanceVariableNames: 'attributeName attributeValue'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumWidget commentStamp: 'RichardAlexanderGreen 1/20/2014 11:01' prior: 0!A HumWidget provides a view of a single Attribute.See: HumEntityAttributeNote: Some Attributes are collections and some attributes are HumEntity objects.The primative datatypes include:- String . . an array of characters- Text . . . an array of lines of tokens with styling- Measure. . a quantity with a unit of measure and precision- Date . . . a calendar date- Category . some value within an enumerated set - Image  . . a 2D picture (very technology dependent)- Collection a collection of objects (entities)The reference implementation renders a HumWidget as an HTML5 widget.However, the design intent requires that a HumWidget NOT be coupled to a specific rendering technology.!!HumWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2014 12:44'!attributeName	^attributeName! !!HumWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2014 12:43'!attributeName: aString	"name of attribute"	attributeName := aString.! !!HumWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2014 12:45'!attributeValue	^ attributeValue ! !!HumWidget methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2014 12:44'!attributeValue: aString	"Current value of attribute -- in display/input format"	attributeValue := aString.! !HumWidget subclass: #HumDateWidget	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!HumWidget subclass: #HumCollectionWidget	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!HumWidget subclass: #HumMeasureWidget	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!HumWidget subclass: #HumCategoryWidget	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!HumAssembly subclass: #HumScene	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumScene commentStamp: 'RichardAlexanderGreen 12/24/2013 09:21' prior: 0!Scene attributes include sky, cameras / viewports, layers.!!HumScene methodsFor: 'render as Three.js' stamp: 'RichardAlexanderGreen 1/1/2014 09:12'!asThreeJS	"Render the scene as ThreeJS"	| js calc prologTemplate epilogTemplate dictionary |	calc := HumCalculator new.	dictionary := Dictionary new.	dictionary at: 'sceneID' put: (self asCamelCase).	"Prolog: Create the ThreeJS scene with appropriate attributes."	js := self setupScene.	"Render the content (layers or objects)"	js := js, ( self asThreeJSGeometry ).	"Append the epilog."	epilogTemplate := 'setupScene();'.	js := js, ( calc fillTemplate: epilogTemplate fromDictionary: dictionary ).	^js.! !!HumScene methodsFor: 'render as Three.js' stamp: 'RichardAlexanderGreen 1/1/2014 09:14'!asThreeJSGeometry	"Render the assembly as ThreeJS geometry"	| js |	"Render the content (layers or objects)"	js := ( super asThreeJS ).	^js.! !!HumScene methodsFor: 'render as Three.js' stamp: 'RichardAlexanderGreen 1/9/2014 08:49'!asThreeJSinHTML	"Wrap ThreeJS rendering with HTML5."	| html calc js worldScript dictionary  template |	calc := HumCalculator new.		html := '<!!DOCTYPE html><html lang="en">	<head>		<title>three.js webgl - orbit controls</title>		<meta charset="utf-8">		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">		<style>			body {				color: #000;				font-family:Monospace;				font-size:13px;				text-align:center;				font-weight: bold;				background-color: #fff;				margin: 0px;				overflow: hidden;			}			#info {				color:#000;				position: absolute;				top: 0px; width: 100%;				padding: 5px;			}			a {				color: red;			}		</style>	</head>	<body>		<div id="container"></div>		<!!--		<div id="info">			<a href="http://threejs.org" target="_blank">three.js</a> - orbit controls example		</div>		-->		<script src="js/three.min.js"></script>		<script src="js/OrbitControls.js"></script>		<script src="js/Detector.js"></script>				<script src="js/Stats.js"></script>		<script>			if ( !! Detector.webgl ) Detector.addGetWebGLMessage();			var container, stats;			var camera, controls, scene, renderer, myAssembly;			var cross;			init();			animate();			function init() {				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );				camera.position.z = 500;				controls = new THREE.OrbitControls( camera );				controls.addEventListener( "change", render );				scene = new THREE.Scene();				//scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );				// world								myAssembly = buildMyAssembly();  // Function is defined in separate script tag.				scene.add( myAssembly );								// lights				light = new THREE.DirectionalLight( 0xffffff );				light.position.set( 1, 1, 1 );				scene.add( light );				light = new THREE.DirectionalLight( 0x002288 );				light.position.set( -1, -1, -1 );				scene.add( light );				light = new THREE.AmbientLight( 0x222222 );				scene.add( light );				// renderer				renderer = new THREE.WebGLRenderer( { antialias: false } );				// renderer.setClearColor( scene.fog.color, 1 );				renderer.setSize( window.innerWidth, window.innerHeight );				container = document.getElementById( "container" );				container.appendChild( renderer.domElement );								// stats pane				stats = new Stats();				stats.domElement.style.position = "absolute";				stats.domElement.style.top = "0px";				stats.domElement.style.zIndex = 100;				container.appendChild( stats.domElement );				//				window.addEventListener( "resize", onWindowResize, false );			}			function onWindowResize() {				camera.aspect = window.innerWidth / window.innerHeight;				camera.updateProjectionMatrix();				renderer.setSize( window.innerWidth, window.innerHeight );				render();			}			function animate() {				requestAnimationFrame( animate );				controls.update();			}			function render() {				renderer.render( scene, camera );				stats.update();			}		'.		"Define a geometry named by (self asCamelCase)."		js := (self asThreeJSGeometry ).  		"Generate additional function to build geometry and insert it into scene."		dictionary := Dictionary new.		dictionary at: 'assemblyID' put: (self asCamelCase ).		template := '			function buildMyAssembly() {			', js,			'  return @assemblyID;			}'.		worldScript := calc fillTemplate: template fromDictionary: dictionary.		html := html, worldScript.				"Complete the HTML."		html := html, '		</script>	</body></html>'.	^html.! !!HumScene methodsFor: 'render as Three.js' stamp: 'RichardAlexanderGreen 12/24/2013 13:05'!setupFloor	"Provide boilerplate that creates a visible floor."	| js |	"NOTE: JavaScript must call setupScene() before setupFloor()."	js := 'function setupFloor() {  // Floor  var geometry = new THREE.PlaneGeometry(2000, 2000, 20, 20);  var material = new THREE.MeshBasicMaterial({color: 0x9db3b5, overdraw: true});  var floor = new THREE.Mesh(geometry, material);  // floor.rotation.x = -90 * Math.PI / 180;  scene.add(floor);	}.'.	"TODO: Parameterize the size of the floor."	^ js.! !!HumScene methodsFor: 'render as Three.js' stamp: 'RichardAlexanderGreen 12/24/2013 12:58'!setupScene	""	| js |	js := 'var camera, scene, renderer;function setupScene() {  document.body.style.backgroundColor = "#d7f0f7";  setupThreeJS();  requestAnimationFrame(function animate() {    renderer.render(scene, camera);    requestAnimationFrame(animate);  });}function setupThreeJS() {  scene = new THREE.Scene();  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);  camera.position.y = 400;  camera.position.z = 400;  camera.rotation.x = -45 * Math.PI / 180;  renderer = new THREE.CanvasRenderer();  renderer.setSize(window.innerWidth, window.innerHeight);  document.body.appendChild(renderer.domElement);}'.	^js, String cr.! !HumAssembly subclass: #HumLayer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumLayer commentStamp: 'RichardAlexanderGreen 12/24/2013 09:25' prior: 0!In a CAD context, layers might be used to provide separate views for plumbing, walls, furniture, frames.In an animation or game context, layers may be used to group objects for special processing.For example, static objects, animated objects, players, and particles may be in separate layers.!HumBox subclass: #HumSpace	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumSpace commentStamp: 'RichardAlexanderGreen 3/26/2013 10:17' prior: 0!HumSpace is a synoym for HumBox.It is provided to make code more readable.The intent is that you would use HumSolid to model things that are mostly solid, like walls,but you would use HumSpace to model things that are hollow (filled with air) for things like rooms, doorways, gardens, landscapes. !HumWidget subclass: #HumImageWidget	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!HumWidget subclass: #HumStringWidget	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!HumWidget subclass: #HumTextWidget	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumTextWidget commentStamp: 'RichardAlexanderGreen 1/20/2014 10:58' prior: 0!HumTextWidget is a HumWidget that displays a HumText object. (See: HumText class in Hum-RunTime category)!HumSurface subclass: #HumPane	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumPane commentStamp: 'RichardAlexanderGreen 1/20/2014 09:44' prior: 0!A pane is a 2D UI object. Panes may contain other panes.A pane is a subtype of Surface (HumSurface).A pane receives "UI events" (speech act statements) from the Scribe.!HumPane subclass: #HumDiagram	instanceVariableNames: 'connections nodes nodePositions positionNode nodeExtent nodeSpacing'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumDiagram commentStamp: 'RichardAlexanderGreen 1/20/2014 09:47' prior: 0!A HumDiagram is a kind of directed graph visualized via a viewbox in a HumSurface.Instance Variables:	connections	<Set>	nodes	<Set>	nodePositions	<Dictionary>	positionNode	<Dictionary>	nodeExtent	<PTEvent | Point | TTPoint>	nodeSpacing	<PTEvent | Point | TTPoint>!!HumDiagram methodsFor: 'layout' stamp: 'RichardAlexanderGreen 4/16/2013 09:59'!layoutDiagramWithNodeExtent: extentPoint nodeSpacing: spacingPoint	"Layout the diagram using the given node extent and spacing between node edges."		"Following must be set before calling me."	| xIncrement yIncrement nodePriority nodesByPriority |	self assert: ( extentPoint notNil ).	self assert: ( spacingPoint notNil ).	"Following is assumed in code below."	self assert: ( extentPoint  isKindOf: Point).	self assert: ( spacingPoint isKindOf: Point).	nodeExtent := extentPoint.	nodeSpacing := spacingPoint.		"Compute increments between grid locations."	"In this version, the placement is on a rectalinear grid.	But other/future versions may be radial and/or decrease as the number of priorNodes increases.	"	xIncrement := (nodeSpacing x) + (( nodeExtent x )/2).	yIncrement := (nodeSpacing y) + (( nodeExtent y )/2).		"Strategy: Prioritize the objects that have the most connections."	"Count the number of connections that each node has."	nodePriority := Dictionary new.	(self connections)		do: [ :map | 			| fromNode toNode fromCount toCount |			fromNode := map key.			toNode := map value. 			fromCount := nodePriority at: fromNode ifAbsent: [0].			nodePriority at: fromNode put: ( fromCount + 1).			toCount := nodePriority at: toNode ifAbsent: [0].			nodePriority at: toNode put: ( toCount + 1).			].	"Sort into a collection where nodes with most connections appear first."		nodesByPriority := SortedCollection new.	nodePriority 		keysAndValuesDo: [ :node :priority |			nodesByPriority add: ( (priority negated) -> node ).			]. 	"Place the nodes with the most connections on the first pass.	Note: This documentation uses term 'primary node' to refer to the node seen first.	      The primary node will be placed at 0@0.	"		nodesByPriority		do: [ :map |			| node xy |			node := map value.			xy := 0@0.			self layoutRecursiveWithNode: node relativePosition: xy seenBefore: (Set new).			xy := xy + (0@yIncrement).			]. 		! !!HumDiagram methodsFor: 'layout' stamp: 'RichardAlexanderGreen 4/17/2013 10:25'!layoutDistanceFromNode: nodeA toNode: nodeB	"Calculate the length of the connection between the nodes."	| xA xB yA yB xR yR r2 r|	xA := (( self nodePositions ) at: nodeA ) x.	yA := (( self nodePositions ) at: nodeA ) y.	xB := (( self nodePositions ) at: nodeB ) x.	yB := (( self nodePositions ) at: nodeB ) y.		xR := xA - xB.	yR := yA - yB.		r2 := ( xR * xR ) + ( yR * yR ).	r := r2 sqrt.	^r	! !!HumDiagram methodsFor: 'layout' stamp: 'RichardAlexanderGreen 4/18/2013 10:44'!layoutEnergyOnNode: nodeA fromNode: nodeB	"Calculate a energy scalar. 	 Rules are similar to elctrostatic energy.	 But since the layout is in a 2-D world, 	  the energy rules are linear. (in this version)	 Note: This method assumes that nodeA and nodeB are directly connected.	"	| r qA qB attraction repulsion attractionFactor repulsionFactor |		"Radius is the length of the connection between the nodes."	r := self layoutDistanceFromNode: nodeA toNode: nodeB.		"Attractive force increases when the radius increases.	This is analog of spring rate.	"	attractionFactor  := 1.0.	attraction := attractionFactor * r.		"Repulsion increases when charge Q (number of direct connections) increases.	"	repulsionFactor := 1.0.	qA := self countNeighborsOfNode: nodeA.	qB := self countNeighborsOfNode: nodeB.		repulsion := repulsionFactor * ( qA + qB ).	"TODO: Consider using minimum of qA or qB.	 TODO: Consider dividing by r.	"		^ ( attraction - repulsion ). 	"Notes: 	1. Return value is a scalar quantity. Not a vector.	2. Since the connected entities require space on the diagram,	     it may work better if we sqared the connection 'charge' quantities.	3. Perhaps we should divide by 'radius' in the repulsion calculation.	4. This calculation assumes the that nodeA and nodeB are directly connected.	5. What if return was ( attraction / repulsion )?	"! !!HumDiagram methodsFor: 'layout' stamp: 'RichardAlexanderGreen 4/16/2013 10:28'!layoutNode: aNode from: aPosition by: anIncrement	"Find a place for the given node starting from the given position.	 Increment the position until an empty position is found.	 Return the position where we placed the node.	"					| proposedPosition nodePosition |		proposedPosition := aPosition.	nodePosition := self getPositionForNode: aNode.	[ nodePosition  isNil]		whileTrue: [ "Is the proposed position empty?"								((self positionNode) at: proposedPosition ifAbsent: [nil])									ifNil: [ "Yes. It is empty"										nodePosition := proposedPosition.										self setNode: aNode position: nodePosition.										]									ifNotNil: ["compute next proposed position"						 					proposedPosition := proposedPosition + anIncrement.].															].							"At this point, proposedPosition should be the related node`s position"	self assert: ( nodePosition = (self getPositionForNode: aNode) ).			"Return the position where we placed the node."		^ nodePosition.! !!HumDiagram methodsFor: 'layout' stamp: 'RichardAlexanderGreen 4/16/2013 10:27'!layoutRecursiveWithNode: node relativePosition: relativePosition seenBefore: priorNodes	"Assign initial position to this node, and then, using recursion, to its neighbors.	- relativePosition is suggested first position to try. 	If that position is already filled, try other positions below it until one is found.	- priorNodes contains nodes that have been seen before in this recursion.	If this node is also in priorNodes, 	 it has already been handled and we return immediately to avoid a loop.	In some implementations,	  we might want to limit the depth (based on priorNodes size).	"	| xIncrement  xy downStreamNodes upStreamNodes yIncrement |	"Return immediately if this node has been seen before.	Otherwise add it to the nodes we have seen before and proceed."	( priorNodes includes: node ) ifTrue: [ ^self ] ifFalse: [ priorNodes add: node ].		"Following must be set before calling me."	self assert: ( nodeExtent notNil ).	self assert: ( nodeSpacing notNil ).	"Following is assumed in code below."	self assert: ( nodeExtent  isKindOf: Point).	self assert: ( nodeSpacing isKindOf: Point).		"Compute increments between grid locations."	"In this version, the placement is on a rectalinear grid.	But other/future versions may be radial and/or decrease as the number of priorNodes increases.	"	xIncrement := (nodeSpacing x) + (( nodeExtent x )/2).	yIncrement := (nodeSpacing y) + (( nodeExtent y )/2).		xy := self layoutNode: node from: relativePosition by: (0@yIncrement).		"Next: Find positions for nodes that are downstream from this node."	downStreamNodes := self getNodesDownstreamFromNode: node.	downStreamNodes				do: [ :downStreamNode | "Place downstream nodes to right and below of priority node."					self layoutRecursiveWithNode: downStreamNode 					             relativePosition: (xy + (xIncrement@0)) 					                  seenBefore: priorNodes.					"ToDo: Calculate which node positions are intersected by connecting lines.					       Assign the central node or a dummy node to those positions also.					       The parent node might be expanded to fill or the dummy node never drawn.					"					].				"Next: Find positions for nodes that are upstream from this node."	upStreamNodes := self getNodesUpstreamFromNode: node.	upStreamNodes				do: [ :upStreamNode | "Place upstream nodes to left and below priority node."					self layoutRecursiveWithNode: upStreamNode 					             relativePosition: (xy - (xIncrement@0))					                  seenBefore: priorNodes.					"ToDo: Calculate which node positions are intersected by connecting lines."					].	! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2012 13:57'!addConnection: anAssociation	"anAssociation := ( fromNode -> toNode )"	self assert: ( anAssociation isKindOf: Association ).	self connections add: anAssociation.! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/25/2013 12:40'!addNode: anObject	"A node object should have a title. 	(It should have something to display in a rendering or mouse-over or debug.) "	self assert: (anObject class selectors includes: #title ).	self nodes add: anObject.! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2013 08:54'!connections	^ connections ifNil: [ connections := Set new. ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/18/2013 10:22'!countNeighborsOfNode: aNode	"Return the number of neighbors of this node.	 (Count nodes that are directly connected to this node)"	| count |	count := 0.	( self connections ) 		do: [ :map | (((map key) = aNode) or: [(map value) = aNode]) 			ifTrue: [ count := count + 1 ] ].	^ count! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/16/2013 10:21'!getNodesDownstreamFromNode: thisNode 	"Return nodes that are connected downstream from this node."	| result |	result := Set new.	( self connections )		do: [ :connection |			| upstreamNode downstreamNode |			upstreamNode := connection key.			downstreamNode := connection value.			( upstreamNode = thisNode )				ifTrue: [ result add: downstreamNode ].			].	^ result.! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/16/2013 10:21'!getNodesUpstreamFromNode: thisNode 	"Return nodes that are connected upstream from this node."	| result |	result := Set new.	( self connections )		do: [ :connection |			| upstreamNode downstreamNode |			upstreamNode := connection key.			downstreamNode := connection value.			( downstreamNode = thisNode )				ifTrue: [ result add: upstreamNode ].			].	^ result.! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/14/2012 16:44'!getPositionForNode: aNodeObject	^ self nodePositions at: aNodeObject ifAbsent: [ ^nil ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/13/2013 09:02'!nodeExtent: aPoint 	nodeExtent := aPoint! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2013 11:11'!nodePositions	^ nodePositions ifNil: [ nodePositions := Dictionary new. ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/13/2013 09:02'!nodeSpacing: aPoint 	nodeSpacing := aPoint! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2013 11:11'!nodes	^ nodes ifNil: [ nodes := Set new. ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2013 12:06'!positionNode	" What node is at a position"	^ positionNode ifNil: [ positionNode := Dictionary new. ].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2013 12:05'!setNode: aNodeObject position: aPosition	"Node should also be in nodes collection for internal consistency."	self addNode: aNodeObject.	self nodePositions at: aNodeObject  put: aPosition.	self positionNode at: aPosition put: aNodeObject.! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/10/2012 13:01'!title	^ title ifNil: [ title := '** Diagram has no title!! **'].! !!HumDiagram methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 9/10/2012 13:02'!title: aString	title := aString.	! !!HumDiagram methodsFor: 'rendering' stamp: 'RichardAlexanderGreen 4/13/2013 08:58'!asSVGonHtmlCanvas: html width: aWidth height: aHeight 	"Render this diagram on the given Seaside canvas.	Note: We use SVG.	"	|  |	self assert: ( html isKindOf: WACanvas ).	html div 		class: 'diagram'; 		id: (self title asCamelCase);		with: ["Label and Diagram"			html strong: self title.			html break.			"Eventually, we want to draw the diagram using SVG."			( html tag: 'svg' ) 				attributeAt: 'width' put: (aWidth asString);     				attributeAt: 'height' put: (aHeight asString);				attributeAt: 'viewBox' put: '0 0 1000 1000';				attributeAt: 'style' put: 'background: CYAN';				"FOLLOWING IS A STUB -- EVENTUALLY THIS WILL DRAW NODES AND CONNECTIONS"				"ToDo: Finish this after we have layout working."				with: ["SVG path element"					( html tag: 'path' )						attributeAt: 'd' put: 'M 100 100  q 0,100 100,100 ';						attributeAt: 'fill' put: 'none';						attributeAt: 'stroke' put: 'red';						attributeAt: 'stroke-width' put: '1'.					( html tag: 'text' ) 						attributeAt: 'x' put: 200;						attributeAt: 'y' put: 200;						attributeAt: 'font-size' put: 20;						attributeAt: 'fill' put: 'BLUE';						with: 'This is just a test of the SVG text rendering.'					].			].! !HumPane subclass: #HumMenu	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumMenu commentStamp: 'RichardAlexanderGreen 1/20/2014 09:48' prior: 0!A HumMenu represents a traditional UI menu with a list of command words.A Menu may invoke a submenu.!HumPane subclass: #HumView	instanceVariableNames: 'entityID aHumBlackboard blackboard widgets entityName'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-UI'!!HumView commentStamp: 'RichardAlexanderGreen 1/20/2014 13:01' prior: 0!A HumView operates a MVC (model-view-controller) where the model data is in a Blackboard. (See: HumBlackBoard).A typical view shows the data for a single object instance.However, an object may have component/related objects and collections of component/related objects.A view contains a collection of widgets. (See: HumWidget and HumMarkupLine)View content and layout may be specified by a Hum View Frame. (See: HumFrame4View)Instance Variables:	entityID	<ProtoObject | PseudoContext>	aHumBlackboard	<Object>	blackboard	<ProtoObject>!!HumView methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2014 12:32'!addWidget: aHumWidget	"Each HumWidget has a unique name.	We will use it to access widgets in our widgets dictionary."	(self widgets) at: ( aHumWidget name ) put: aHumWidget.! !!HumView methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2014 12:53'!blackboard	^ blackboard ifNil: [ Error signal: 'No blackboard has been assigned to this view.'].! !!HumView methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/24/2013 10:12'!blackboard: aHumBlackBoard	self assert: ( aHumBlackboard isKindOf: HumBlackBoard ).	blackboard := aHumBlackBoard.! !!HumView methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2014 12:47'!entityName	^entityName ifNil: [Error signal: 'No entity name has been set for this view.']! !!HumView methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2014 12:46'!entityName: aString	"Set"	entityName := aString.! !!HumView methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/8/2014 12:28'!widgets	"a view includes a collection of widgets. 	Each widget has a name and an object."	^widgets ifNil: [widgets := Dictionary new.]! !!HumView methodsFor: 'tests' stamp: 'RichardAlexanderGreen 2/24/2013 10:04'!checkRenderOn: html	html form with: [ 		html break. html heading level: 2; with: ' Recipe'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: entityID attribute: #name toValue: datum ]; name: 'name'; value: 'name'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: entityID attribute: #description toValue: datum ]; name: 'description'; value: 'description'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: entityID attribute: #ingredients toValue: datum ]; name: 'ingredients'; value: 'ingredients'.		html break. html textInput callback: [:datum | self blackBoard setEntityID: entityID attribute: #steps toValue: datum ]; name: 'steps'; value: 'steps'.		]! !!HumView methodsFor: 'updating' stamp: 'RichardAlexanderGreen 3/8/2014 12:52'!updateBlackboardFromWidgets	"Update the blackboard using data entered into our widgets."	| entity attribute value |	entity := self entityName.	(self widgets)			do: [ :widget |			attribute := widget attributeName.			value := widget attributeValue.			blackboard setEntityID: entity attribute: attribute toValue: value.			].! !!HumView methodsFor: 'updating' stamp: 'RichardAlexanderGreen 3/8/2014 12:47'!updateWidgetsFromBlackboard	"Get the data for each of our widgets from the blackboard."	"Traverse the widgets in the widgets dictionary"	(self widgets)			valuesDo: [ :widget |			(self blackboard) getEntityID: (self entityName) attribute: (widget attributeName).			].! !