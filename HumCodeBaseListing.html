	<head>		<style>			body {font-family: MONOSPACE;}				method {   }		comment { color: DarkGreen; }		todo { color: Red; }		r { color: Red; }		return { color: Blue; }		</style>	</head><body><h1>Hum Code Base</h1><h3>Hum-FileIn -- HumFileInSubclass &gt;&gt; subclassMethod:</h3><pre>subclassMethod: anArgument3   | localVariable3 |   localVariable3 := anArgument3.   </pre><h3>Hum-FileIn -- HumFileIn &gt;&gt; anotherMethod:</h3><pre>anotherMethod: anArgument2   "This is a second method to check for iteration anomolies."   | localVariable2 |   "Another minor edit."   localVariable2 := anArgument2.   </pre><h3>Hum-FileIn -- HumFileIn &gt;&gt; someMethod:</h3><pre>someMethod: anArgument   "This method provides means to test file in from generated code."   |  |   someInstanceVariable := anArgument.   "Minor Edit"   ^someInstanceVariable.   </pre><h3>Hum-FileIn -- HumFileOut &gt;&gt; myInstanceVariable</h3><pre>myInstanceVariable   ^ myInstanceVariable.   </pre><h3>Hum-Graph -- HumGraphTests &gt;&gt; test110GraphHasNodes</h3><pre>test110GraphHasNodes   "A graph has a collection (set) of nodes"   | graph |   graph := HumGraph new.   self assert: ( graph nodes isEmpty ).</pre><h3>Hum-Graph -- HumGraphTests &gt;&gt; test120GraphHasConnections</h3><pre>test120GraphHasConnections   "A graph has a collection (set) of connections."   | graph |   graph := HumGraph new.   self assert: ( graph connections isEmpty ).</pre><h3>Hum-Graph -- HumGraphTests &gt;&gt; test130PutGetNode</h3><pre>test130PutGetNode   "A graph has a collection (set) of nodes"   | graph node node2 |   graph := HumGraph new.   self assert: ( graph nodes isEmpty ).      node := 'My content just happens to be a string but I could be any kind of object'.   graph addNode: node.   self assert: ( graph nodes size = 1 ).      graph nodes do: [ :entry | self assert: (entry == node )].</pre><h3>Hum-Graph -- HumGraphTests &gt;&gt; test140PutGetConnector</h3><pre>test140PutGetConnector   "A graph has a collection (set) of connections."   | graph node node2 |   graph := HumGraph new.   self assert: ( graph nodes isEmpty ).      node := 'My content just happens to be a string but I could be any kind of object'.   graph addNode: node.   self assert: ( graph nodes size = 1 ).      node2 := 'My content also just happens to be a string but I could be any kind of object'.   graph addNode: node2.   self assert: ( graph nodes size = 2 ).      graph addConnection: ( node -&gt; node2 ) label: 'A connection represents some kind of relationship.'.   self assert: ( graph connections size = 1 ).</pre><h3>Hum-Graph -- HumGraphTests &gt;&gt; test150PutGetLabeledConnections</h3><pre>test150PutGetLabeledConnections   "A graph has a collection (set) of connections"   | graph nodeA nodeB |   graph := HumGraph new.   self assert: ( graph nodes isEmpty ).      nodeA := 'My content just happens to be a string but I could be any kind of object'.   graph addNode: nodeA.   self assert: ( graph nodes size = 1 ).      nodeB := 'My content also just happens to be a string but I could be any kind of object'.   graph addNode: nodeB.   self assert: ( graph nodes size = 2 ).      graph addConnection: ( nodeA -&gt; nodeB ) label: 'A to B'.   self assert: ( graph connections size = 1 ).      graph addConnection: ( nodeB -&gt; nodeA ) label: 'B to A'. "Creates a cycle."   self assert: ( graph connections size = 2 ).      graph addConnection: ( nodeA -&gt; nodeB ) label: 'A to B again'.   self assert: ( graph connections size = 3 ).</pre><h3>Hum-Graph -- HumGraphTests &gt;&gt; test152PutGetParallelConnections</h3><pre>test152PutGetParallelConnections   "A graph has a collection (set) of nodes"   | graph nodeA nodeB nodeC nDownStream downStreamNodes connectionsFromA nConnections |   graph := HumGraph new.   self assert: ( graph nodes isEmpty ).      nodeA := 'A'.   graph addNode: nodeA.   self assert: ( graph nodes size = 1 ).      nodeB := 'B'.   graph addNode: nodeB.   self assert: ( graph nodes size = 2 ).      nodeC := 'C'.   graph addNode: nodeC.   self assert: ( graph nodes size = 3 ).   graph addConnection: ( nodeA -&gt; nodeB ) label: 'A to B'.   self assert: ( graph connections size = 1 ).      graph addConnection: ( nodeB -&gt; nodeA ) label: 'B to A'. "creates a CYCLE"   self assert: ( graph connections size = 2 ).      graph addConnection: ( nodeA -&gt; nodeB ) label: 'A to B again'.   self assert: ( graph connections size = 3 ).      graph addConnection: ( nodeA -&gt; nodeC ) label: 'A to C'.   self assert: ( graph connections size = 4 ).      connectionsFromA := graph connectionsFrom: nodeA.   nConnections := connectionsFromA size.   self expect: 3 actual: nConnections description: 'Node A has 3 outbound connections.'.      downStreamNodes := graph nodesDownStreamFrom: nodeA.   nDownStream := downStreamNodes size.   self expect: 2 actual: nDownStream description: 'Expect two nodes down-stream from nodeA.'.   self assert: (downStreamNodes includes: nodeB). "But it includes it just once."   self assert: (downStreamNodes includes: nodeC).   </pre><h3>Hum-Graph -- HumGraphTests &gt;&gt; test160DetectCycle</h3><pre>test160DetectCycle   "A graph has a collection (set) of nodes"   | graph nodeA nodeB nodeC |   false ifFalse: [ Transcript cr; show: 'test160DetectCycle is turned off.'. ^self.].   graph := HumGraph new.   self assert: ( graph nodes isEmpty ).      nodeA := 'A'.   graph addNode: nodeA label: 'nodeA'.   nodeB := 'B'.   graph addNode: nodeB label: 'nodeB'.   nodeC := 'C'.   graph addNode: nodeC label: 'nodeC'.   graph addConnection: ( nodeA -&gt; nodeB ) label: 'A to B'.   graph addConnection: ( nodeB -&gt; nodeC ) label: 'B to C'.   self assert: (graph hasCycle) not.   graph addConnection: ( nodeC -&gt; nodeA ) label: 'C to A creates cycle'.   self assert: (graph hasCycle).      </pre><h3>Hum-Graph -- HumGraph &gt;&gt; addConnection:</h3><pre>addConnection: anAssociation    Error signal: 'a connection without a label is bad practice.'.   self addConnection: anAssociation label: 'unknown'.</pre><h3>Hum-Graph -- HumGraph &gt;&gt; addConnection:label:</h3><pre>addConnection: anAssociation label: aString   "Note: A pair of nodes may have more than one relation."   | fromNode toNode connection |   self assert: (anAssociation isKindOf: Association).   "Make sure the nodes are in the node set."   fromNode := anAssociation key.   toNode := anAssociation value.   self addNode: fromNode.   self addNode: toNode.   "There can be multiple connections between two nodes. But must have distinct labels."   ( self connectionLabels ) add: { anAssociation. aString. }. "A Dictionary might produce more readable code."   connection := Dictionary new.   connection at: #fromNode put: fromNode.   connection at: #toNode put: toNode.   connection at: #label put: aString.   self connections add: connection.</pre><h3>Hum-Graph -- HumGraph &gt;&gt; addNode:</h3><pre>addNode: anObject    "Add the given object to the set of nodes"   " Note that each object / node is unique"   self addNode: anObject label: (anObject asString).</pre><h3>Hum-Graph -- HumGraph &gt;&gt; addNode:label:</h3><pre>addNode: anObject label: aString   "Add the given object to the Set of node-labels"   " Note that each object / node is unique"   "TODO: Shouldn't this be an association?"   ( self nodeLabels ) add: { aString. anObject. }</pre><h3>Hum-Graph -- HumGraph &gt;&gt; connectionLabels</h3><pre>connectionLabels   "Note: A pair of nodes may have more than one relation."   "See: #addConnection:label:"   "Set of { fromNode -&gt; toNode. label. }"   ^ connectionLabels ifNil: [ connectionLabels := Set new ].</pre><h3>Hum-Graph -- HumGraph &gt;&gt; connections</h3><pre>connections   "Return the connections (associations) in this graph."   | bagConnections |   "TODO: Improve code readability.   Refactor such that connections = Dictionary    and each connection = Dictionary with keyes #fromNode #toNode #label. "   bagConnections := Bag new.   (self connectionLabels)      do: [ :entry |         "entry looks like {  association. label.  }"         bagConnections add: (entry at: 1 ).         ].   ^bagConnections.</pre><h3>Hum-Graph -- HumGraph &gt;&gt; connectionsFrom:</h3><pre>connectionsFrom: aNode    "Get the outbound connections from this node. "   | outboundConnections |   outboundConnections := Set new.   (self connectionLabels)      do: [ :connectionLabel |            | association label fromNode toNode |            association := connectionLabel at: 1.            label := connectionLabel at: 2.            fromNode := association key.            toNode := association value.            (fromNode = aNode)                   ifTrue: [ outboundConnections add: connectionLabel ].          ].   ^outboundConnections.</pre><h3>Hum-Graph -- HumGraph &gt;&gt; countNeighborsOfNode:</h3><pre>countNeighborsOfNode: aNode   "Return the number of neighbors of this node.    (Count nodes that are directly connected to this node)"   | count |   count := 0.   ( self connections )       do: [ :map | (((map key) = aNode) or: [(map value) = aNode])          ifTrue: [ count := count + 1 ] ].   ^ count</pre><h3>Hum-Graph -- HumGraph &gt;&gt; hasCycle</h3><pre>hasCycle   "Does the graph contain at least one cycle?"   | |   nodeLabels      do: [:nodeLabel |         | label rootNode downStream |         label := nodeLabel at: 1.         rootNode := nodeLabel at: 2.         "downStreamFrom: will not extend leafs that match root"         downStream := self nodesDownStreamFrom: rootNode.         ((downStream leafNodes) include: rootNode) ifTrue: [^true].         ].   ^false.</pre><h3>Hum-Graph -- HumGraph &gt;&gt; nodeLabels</h3><pre>nodeLabels   ^nodeLabels ifNil: [ nodeLabels := Set new ].</pre><h3>Hum-Graph -- HumGraph &gt;&gt; nodes</h3><pre>nodes   "Return the nodes in this graph."   | bagNodes |   bagNodes := Bag new.   (self nodeLabels)      do: [ :entry |         "entry looks like {  label. object. }"         bagNodes add: (entry at: 2 ).         ].   ^bagNodes.</pre><h3>Hum-Graph -- HumGraph &gt;&gt; nodesDownStreamFrom:</h3><pre>nodesDownStreamFrom: aRootNode    "Collect the nodes that are down-stream from a root node."   | upStream downStream |   "Set up recursive loop."   upStream := Set new.   "Avoid cycles."   downStream := self nodesDownStreamFrom: aRootNode butNotIn: upStream.   ^downStream.   </pre><h3>Hum-Graph -- HumGraph &gt;&gt; nodesDownStreamFrom:butNotIn:</h3><pre>nodesDownStreamFrom: aRootNode butNotIn: upStreamNodes    "Find nodes that are down-stream from the root node but not in the upStreamNodes."   | downStreamNodes immediateBranchNodes |   "Note: It is possible for a pair of nodes to have more than one relationship."   immediateBranchNodes := Set new.   (self connectionLabels)      do: [ :connectionLabel |         | association label fromNode toNode |          "Unpack the tuple."         association := connectionLabel at: 1.         self assert: (association isKindOf: Association). "Might be changed to Association"         label := connectionLabel at: 2.         fromNode := association key.         toNode := association value.         (fromNode = aRootNode) ifTrue: [ immediateBranchNodes add: toNode ].         ].   downStreamNodes := immediateBranchNodes.   "TODO: ADD RECURSION AFTER THIS IS DEBUGGED."   ^downStreamNodes.   </pre><h3>Hum-IDE -- HumCodeBase &gt;&gt; everythingIsClassSide</h3><pre>everythingIsClassSide   "This is organized as a singleton - all the methods are on the class side."</pre><h3>Hum-IDE -- HumCodeStream &gt;&gt; <<</h3><pre>&lt;&lt; aString    self assert: (aString isKindOf: String).   (self stream) &lt;&lt; aString.   </pre><h3>Hum-IDE -- HumCodeStream &gt;&gt; asString</h3><pre>asString   ^self printString.</pre><h3>Hum-IDE -- HumCodeStream &gt;&gt; contents</h3><pre>contents   ^(self stream) contents.</pre><h3>Hum-IDE -- HumCodeStream &gt;&gt; limit</h3><pre>limit   "At what point do we assume code generation has run amock?"   ^ limit ifNil: [ limit := 200 ].</pre><h3>Hum-IDE -- HumCodeStream &gt;&gt; limit:</h3><pre>limit: aSmallInteger    limit := aSmallInteger</pre><h3>Hum-IDE -- HumCodeStream &gt;&gt; printString</h3><pre>printString   ^(self stream) contents.</pre><h3>Hum-IDE -- HumCodeStream &gt;&gt; stream</h3><pre>stream   stream ifNil: [ stream := ReadWriteStream on: ''].   ((stream contents) size &gt; (self limit))      ifTrue: [Error signal: 'Code stream limit exceeded.'].   ^stream.</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; addActionLine:</h3><pre>addActionLine: aSourceString    | source calc |   source := aSourceString.   calc := HumCalculator new.   calc cases;      when: [source beginsWith: 'Action:']             then: [frame ifNotNil:[ self storeFrameInOntology ]. "Save prior frame, if any."                   "Start a new action frame. This action is in the role`s PUBLIC API."        
                 self frame: (HumFrame4Action ontology: ontology                                                     role: currentRole                                                    action: (calc given: source extractAfter: 'Action:')) ];      when: [source beginsWith: 'To:']             then: [frame ifNotNil:[ self storeFrameInOntology ]. "Save prior frame, if any."                   "Start a new action frame. This action is in the role`s PRIVATE API."                         self frame: (HumFrame4Action ontology: ontology                                                     role: currentRole                                                    action: (calc given: source extractAfter: 'To:')) ];      otherwise: [ | instructionLine |                        instructionLine := self parseInstruction: source.                        self frame appendFrameLine: instructionLine.                        self frame instructionLines add: instructionLine.].         </pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; addDictionaryLine:</h3><pre>addDictionaryLine: aSourceString    self frame addDictionaryLine: (self stripLeaderFrom: aSourceString).</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; addMarkUp:</h3><pre>addMarkUp: aSourceString    self frame addMarkUp: ( ( HumMarkupLine new ) source:  aSourceString) .</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; addPlanLine:</h3><pre>addPlanLine: aSourceString    "The kind of line is modal."   "Look for lines that reset the mode."   ( (aSourceString asLowercase beginsWith: 'precondition')     or: [aSourceString asLowercase beginsWith: 'pre:']   )      ifTrue: [mode := #preconditions.         frame appendFrameLine: (HumFrameLine source: aSourceString).         ^self.         ].   ( (aSourceString beginsWith: 'Action:') or: [aSourceString beginsWith: 'Actions:'])      ifTrue: [mode := #actions.         frame appendFrameLine: (HumFrameLine source: aSourceString).         ^self.         ].   "Process the source line according to mode set by prior source line."      (mode = #preconditions)      ifTrue: [         self appendPrecondition: aSourceString.         ^self         ].   (mode = #actions)      ifTrue: [ | aRole sourceMinusComment |         sourceMinusComment := self programmersAssistant removeCommentFromSource: aSourceString.         (sourceMinusComment sameAs: '')             ifTrue: [frame appendFrameLine: (HumCommentLine source: aSourceString).]            ifFalse: [               aRole := self programmersAssistant getLabelFromSource: aSourceString.               aRole ifNil: [Error signal: 'Plan actions must have roles.'].               self appendRole: aRole action: (self programmersAssistant removeLabelFromSource: aSourceString).               ].            ^self.         ].   (mode isNil)      ifTrue: [ "Default mode is preconditions -- Allows 'Preconditions:' label to be omitted in source file."         mode := #preconditions.          self appendPrecondition: aSourceString.         ^self         ].   Error signal: 'How did we fall through addPlanLine: ...?'.       </pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; addVignetteInstruction:</h3><pre>addVignetteInstruction: anInstructionLine    ( self frame ) addVignetteInstruction: anInstructionLine. </pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; addVignetteLine:</h3><pre>addVignetteLine: aSourceString    | source calc |   source := aSourceString.   calc := HumCalculator new.   "DEBUG   (aSourceString endsWith: '].')       ifTrue: [          Transcript cr;             show: aSourceString;             show: ' ';               show: vignetteMode;            show: ' ';            show: (frame patterns at: 1) asString.         ].   "   calc cases;      when: [(source beginsWith: 'U:')            and: [self vignetteMode = #pattern]]         then: [frame addVignettePattern: (calc given: source extractAfter: 'U:')            ];      when: [(source beginsWith: 'U:')            and: [self vignetteMode = #response]]         then: [| pattern |            "Store prior vignette frame and Start a new vignette frame."            frame patterns size &gt; 0               ifTrue: ["Store prior vignette frame and Start a new vignette frame."                  self storeFrameInOntology. ].            pattern := calc given: source extractAfter: 'U:'.            frame := HumFrame4Vignette                  ontology: self ontology                  vignetteContext: self vignetteContext                  pattern: pattern.            self vignetteMode: #pattern.            frame addVignettePattern: pattern            ];      when: [source beginsWith: 'S:']         then: ["Starting response."            self vignetteMode: #response.            frame addVignetteResponse: (calc given: source extractAfter: 'S:')            ];      when: [source sameAs: '']         then: ["Ignore blank line."         ];      when: [ source beginsWith: ' ' ]         then: ["Should be response line."             frame addVignetteResponse: source.            ];      when: [source beginsWith: '.']         then: ["Add instruction line."            frame addVignetteInstruction: (calc given: source extractAfter: '.')            ];      otherwise: [Error signal: 'Vignette line type not recognized.']</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; addVignetteResponse:</h3><pre>addVignetteResponse: aResponseString    (self frame) addVignetteResponse: aResponseString.</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; appendFrameLine:</h3><pre>appendFrameLine: aSourceString    "Create appropriate frameLine type and append to frame."   | calc source |   self assert: (aSourceString isKindOf: String).   source := self stripLeaderFrom: aSourceString.   calc := HumCalculator new.   calc cases;      when: [self frame isKindOf: HumFrame4Plan] then: [ self addPlanLine: source ];      when: [self frame isKindOf: HumFrame4View] then: [ frame addMarkUp: source ];      when: [self frame isKindOf: HumFrame4Action] then: [ self addActionLine: source ];      when: [self frame isKindOf: HumFrame4Comment] then: [ frame appendFrameLine: (HumCommentLine source: source) ];      when: [self frame isKindOf: HumFrame4Dictionary] then: [ frame addDictionaryLine: source ];      "For vignette lines, we want to preserve leading dot because it identifies instruction lines."      when: [self frame isKindOf: HumFrame4Vignette] then: [ self addVignetteLine: aSourceString ];      otherwise: [ Error signal: 'Unknown frame type.'].   </pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; appendInstructionRole:statement:</h3><pre>appendInstructionRole: aRole statement: aStatement    self frame appendInstructionRole: aRole statement: aStatement.</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; appendInstructionRole:statement:comment:</h3><pre>appendInstructionRole: aRole statement: aStatement comment: aComment    self frame appendInstructionRole: aRole statement: aStatement comment: aComment .</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; appendInstructionStatement:</h3><pre>appendInstructionStatement: aStatement    "Append a simple instruction (no delegation, no comment) to the frame."   |  |   self frame appendInstructionStatement: aStatement.</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; appendPrecondition:</h3><pre>appendPrecondition: aPreconditionStatement    self assert: ( self frame isKindOf: HumFrame4Plan ).   self frame appendPrecondition: (self stripLeaderFrom: aPreconditionStatement) .</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; appendRole:action:</h3><pre>appendRole: aRole action: aStatement    "Pass through to frame."   self frame appendInstructionRole: aRole statement: aStatement.</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; checkFrameSyntax</h3><pre>checkFrameSyntax   | errors |   errors := self frame checkSyntaxWithOntology: self ontology.   ^errors.</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; compileToOntology:</h3><pre>compileToOntology: aHumOntology    "Delegate to the frame."   | errors |   errors := self frame compileToOntology: aHumOntology.   ^errors.</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; frame</h3><pre>frame   "If frame is not initialized before this call, we have a logic error."   ^frame ifNil: [ Error signal: 'frame has not bee initialized in FrameEditor instance.'].</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; frame:</h3><pre>frame: aFrame    "What frame am I editing ?"   frame := aFrame</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; getInstructionAt:</h3><pre>getInstructionAt: aSmallInteger    ^self lines at: aSmallInteger .</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; isEmpty</h3><pre>isEmpty   ^ (frame isNil) or: [frame isEmpty].</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; lines</h3><pre>lines   ^ (self frame) lines.</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; nextVignetteContext:</h3><pre>nextVignetteContext: aString    frame nextVignetteContext: aString</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; ontology</h3><pre>ontology   ^ (ontology) ifNil: [ Error signal: 'Frame Updater instance must have an ontology.']</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; ontology:</h3><pre>ontology: aHumOntology    ontology := aHumOntology.</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; parseInstruction:</h3><pre>parseInstruction: sourceWith    |  resultLine source comment role stmt |   self assert: (sourceWith isKindOf: String).   resultLine := HumInstructionLine source: sourceWith.   source := self stripLeaderFrom: sourceWith.   comment := HumCalculator given: source extractIncludingMatching: '()'.   (comment isNil)       ifFalse: [ | beforeComment afterComment |         beforeComment := HumCalculator given: source extractUpto: comment.         afterComment := HumCalculator given: source extractAfter: comment.         source := beforeComment, afterComment.         resultLine comment: comment.         ].   "Allow blank lines for readability."   (source sameAs: ' ') ifTrue: [^resultLine].   "Identify pattern and parse accordingly."   role := HumProgrammersAssistant getLabelFromSource: source.   stmt := HumProgrammersAssistant removeLabelFromSource: source.   resultLine := HumInstructionLine role: role statement: stmt.   (comment isNil) ifFalse: [resultLine comment: comment].   ^resultLine.</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; prettyPrint</h3><pre>prettyPrint   "Pretty print the frame content (rendering as HTML)."   | html |   html := ontology view renderFrame: frame withCritique: false withBase: false.   ^html</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; programmersAssistant</h3><pre>programmersAssistant   ^ programmersAssistant ifNil: [programmersAssistant := HumProgrammersAssistant new].</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; putInstruction:at:</h3><pre>putInstruction: aHumInstruction at: aSmallInteger    | myLines |   myLines :=  (self lines).   ( myLines isEmpty)       ifFalse: [ myLines  at: aSmallInteger put: aHumInstruction .]      ifTrue: [ myLines add: aHumInstruction ].      </pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; storeFrameInOntology</h3><pre>storeFrameInOntology   "Store my frame in my ontology"   | |   "The frame must have a title."   self assert: ( frame titleLine notNil ).   (self ontology) storeFrame: frame.</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; stripLeaderFrom:</h3><pre>stripLeaderFrom: aLine    | stmt calc |   (aLine = '.') ifTrue: ["Assume blank instruction line." ^''].   stmt := aLine.   calc := HumCalculator new.   [stmt beginsWith: '. ']      whileTrue: [ stmt := calc given: stmt extractAfter: '. '].   ^stmt</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; vignetteContext</h3><pre>vignetteContext   | result |   result := frame vignetteContext.   ^result.</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; vignetteMode</h3><pre>vignetteMode   "What mode is the vignette parser in?"   vignetteMode ifNil: [ vignetteMode := #pattern ].   self assert: ( vignetteMode = #pattern or: [ vignetteMode = #response ]).   ^vignetteMode</pre><h3>Hum-IDE -- HumFrameUpdater &gt;&gt; vignetteMode:</h3><pre>vignetteMode: newMode   "What mode is the vignette parser in?"   self assert: ( newMode = #pattern or: [ newMode = #response ]).   vignetteMode := newMode.</pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; clearOntology</h3><pre>clearOntology   ontology := HumOntology new.</pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; getAnnotationFromSource:</h3><pre>getAnnotationFromSource: aSourceString    "Match '[...]' if any, and extract it from source."   | annotation  |   annotation := self class getAnnotationFromSource: aSourceString.   ^annotation.</pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; getCommentFromSource:</h3><pre>getCommentFromSource: aSourceString    "Match '(...)' if any, and extract it from source."   | comment  |   comment := self class getCommentFromSource: aSourceString.   ^comment.</pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; getLabelFromSource:</h3><pre>getLabelFromSource: aSourceString   "Match 'word:' at the front of the string.   Note: word may be hyphenated. "   | label |   label := self class getLabelFromSource: aSourceString.   ^label.</pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; loadOntology:fromTextFileNamed:</h3><pre>loadOntology: anOntology fromTextFileNamed: fileName   "Load an ontology from the given text file."   | stream |   self ontology: anOntology.   ontology file: fileName.   ontology title: fileName.   stream := StandardFileStream readOnlyFileNamed: fileName.   stream position: 0. "Just in case."   self loadOntologyFromTextStream: stream.   ^ontology.   </pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; loadOntologyFromSaveFileNamed:</h3><pre>loadOntologyFromSaveFileNamed: aFileNameString    "Reload an ontology from the given save file."   |  |   self ontology: (HumOntology new).   self loadOntology: (ontology) fromTextFileNamed: aFileNameString.   ^ontology.</pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; loadOntologyFromTextFileNamed:</h3><pre>loadOntologyFromTextFileNamed: fileName   "Load an ontology from the given text file."   |  |   ontology ifNil: [ self ontology: (HumOntology baseOntology) ].   self loadOntology: (ontology) fromTextFileNamed: fileName.   ^ontology.   </pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; loadOntologyFromTextStream:</h3><pre>loadOntologyFromTextStream: aStream    "Discover frame type and store each frame in ontology."   |  sourceLine frameUpdater  isActionSubFrameCase |   "Use ontology provided by caller or lazy initialization."   frameUpdater := (HumFrameUpdater new) ontology: (self ontology).   "Define a function to detect action subframe case."   sourceLine := String new. "This satisfies compiler that sourceLine is defined before lambda uses it."   isActionSubFrameCase := [(frameUpdater frame isKindOf: HumFrame4Action)                              and: [(sourceLine beginsWith: 'Action:') or: [sourceLine beginsWith: 'To:']]].   "Read frames from the stream."   [(sourceLine := aStream nextLine) notNil]      whileTrue: ["For each line in the stream:"         ((sourceLine beginsWith: '===') or: [frameUpdater isEmpty or: [isActionSubFrameCase value]])             ifTrue: [ "Store prior frame, if any. Start new frame."               (frameUpdater isEmpty) ifFalse: [ frameUpdater storeFrameInOntology ].               "Get a fresh frameUpdater."               frameUpdater := (HumFrameUpdater new) ontology: ontology..               "Get the title line and discover what kind of frame comes next."               (sourceLine beginsWith: '===') ifTrue: [sourceLine := aStream nextLine].               frameUpdater frame: (self makeFramePerTitleLine: sourceLine).               ]            ifFalse: ["self haltIf: ('*Smalltalk*' match: sourceLine asString)."               frameUpdater appendFrameLine: sourceLine]         ].   "Strore frame - unless frame is empty."      (frameUpdater isEmpty) ifFalse: [ frameUpdater storeFrameInOntology ].   ^ontology.   </pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; makeFramePerTitleLine:</h3><pre>makeFramePerTitleLine: source    "The label on the title line indicates the kind of frame."   | label calc |   source ifNil: [^nil].   self assert: (source isKindOf: String).   label := self getLabelFromSource: source.   label ifNil: [^nil].   calc := HumCalculator new.   calc cases;      when: [label sameAs: 'View'] then: [ frame := ( HumFrame4View ontology: ontology title: source ) ];      when: [label sameAs: 'Pane'] then: [ frame := ( HumFrame4View ontology: ontology title: source ) ];      when: [label sameAs: 'Layout'] then: [ frame := ( HumFrame4View ontology: ontology title: source ) ];      when: [label sameAs: 'Comment'] then: [ frame := (HumFrame4Comment new) titleLine: source; ontology: ontology. ];      when: [label sameAs: 'Questions'] then: [ frame := (HumFrame4Comment new) titleLine: source ];     when: [label sameAs: 'Dictionary'] then: [ frame := (HumFrame4Dictionary ontology: ontology title: source)];      when: [label sameAs: 'Goal']             then: [ frame := HumFrame4Plan ontology: ontology                                                 goal: (calc given: source extractAfter: (label,':') ) ];      when: [label sameAs: 'Role']             then: [ currentRole := (calc given: source extractBetween: (label,':') and: '.') trimBoth.                      frame := HumFrame4Action new.                       ];      when: [(label sameAs: 'Action') and: [frame isKindOf:HumFrame4Action ]]             then: [ (frame isEmpty) ifFalse: [frame compileToOntology: ontology ].                     frame := HumFrame4Action ontology: ontology                                                   role: currentRole                                                action: (calc given: source extractAfter: (label,':')).                     frame appendFrameLine: (HumFrameLine source: source).                   ];      when: [label sameAs: 'To']             then: [ (frame isEmpty) ifFalse: [frame compileToOntology: ontology ].                     frame := HumFrame4Action ontology: ontology                                                   role: currentRole                                                action: (calc given: source extractAfter: (label,':')).                     frame appendFrameLine: (HumFrameLine source: source).                   ];      when: [(label sameAs: 'Context') or: [label sameAs: 'Dialog']]            then: [ frame := HumFrame4Vignette ontology: ontology                                          vignetteContext: (calc given: source extractBetween: (label,':') and: '.')                                                  pattern: nil ];     otherwise: [Error signal: 'Fell thru cases in makeFramePerTitleLine.'].   "Track which ontology the frame was defined in."   frame origin: ontology title copy.   ^frame.</pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; ontology</h3><pre>ontology   "Return the ontolgy. If nil initialize one."   ^ ontology ifNil: [ ontology := HumOntology new. ].</pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; ontology:</h3><pre>ontology: aHumOntology   ontology := aHumOntology</pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; parseActionLine:</h3><pre>parseActionLine: source    "An action line begins with 'Action:' or 'To:' label.   An action line may include a comment and/or annotation.   "   | tokenTypePairs tokenPairsWithNounsMarked     |   tokenTypePairs := self class parseActionLine: source.      "Look-up #word types to see if they are #noun types."   tokenPairsWithNounsMarked := OrderedCollection new.   tokenTypePairs do: [ :association |        | token tokenType |      token := association key.      tokenType := association value.      ( tokenType = #word )          ifFalse: [ tokenPairsWithNounsMarked add: association ]         ifTrue: [ "Is this word a noun?"             (self ontology isNoun: token)               ifFalse:  [ tokenPairsWithNounsMarked add: association ]               ifTrue: [  tokenPairsWithNounsMarked add: ( token -&gt; #noun ) ].            ].      ].   ^ tokenPairsWithNounsMarked.</pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; parseActionLine:keywords:</h3><pre>parseActionLine: aString keywords: aCollection    "An action line begins with 'Action:' or 'To:' keyword.   It may also include a comment and/or annotation."
   self shouldBeImplemented </pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; parseInstructionSource:keywords:</h3><pre>parseInstructionSource: source keywords: keywords   "Parse the source -- Return a list of token-type pairs: ( token -&gt; tokenType ).   Parse the source -- Return a list of token-type pairs: ( token -&gt; tokenType ).   tokenType is one of: #word #keyword #punctuation #comment #annotation.   "   | tokenTypePairs tokenPairsWithNounsMarked secondToken firstToken firstTokenType calc |   tokenTypePairs := self class parseInstructionSource: source keywords: keywords.      "Look-up #word types to see if they are #noun types."   tokenPairsWithNounsMarked := OrderedCollection new.   tokenTypePairs do: [ :association |        | token tokenType |      token := association key.      tokenType := association value.      ( tokenType = #word )          ifFalse: [ tokenPairsWithNounsMarked add: association ]         ifTrue: [ "Is this word a noun?"             (self ontology isNoun: token)               ifFalse:  [ tokenPairsWithNounsMarked add: association ]               ifTrue: [  tokenPairsWithNounsMarked add: ( token -&gt; #noun ) ].            ].      ].   "If second token is colon, first token is a role."      firstToken := (tokenPairsWithNounsMarked at: 1) key.   firstTokenType := (tokenPairsWithNounsMarked at: 1) value.   secondToken := (tokenPairsWithNounsMarked at: 2) key.   calc := HumCalculator new.   calc cases;      when: [ (secondToken = ':' and: [ firstTokenType = #keyword])  ]          then: [ "Do nothing" ];      when: [ (secondToken = ':' and: [ firstTokenType = #word])  ]          then: [ tokenPairsWithNounsMarked at: 1 put: ( firstToken -&gt; #role ).].   ^ tokenPairsWithNounsMarked.</pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; parseMarkupSource:</h3><pre>parseMarkupSource: aSourceString    | result |   result := self class parseMarkupSource: aSourceString.   ^result.</pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; parseSource:keywords:</h3><pre>parseSource: source keywords: keywords   "Parse the source -- Return a list of token-type pairs: ( token -&gt; tokenType ).   Parse the source -- Return a list of token-type pairs: ( token -&gt; tokenType ).   tokenType is one of: #word #keyword #punctuation.   See also: &gt;&gt;parseInstructionSource: keywords:   "   | tokenTypePairs tokenPairsWithNounsMarked     |   self assert: ( keywords isKindOf: Collection ).   tokenTypePairs := self class parseSource: source keywords: keywords.      "Look-up #word types to see if they are #noun types."   tokenPairsWithNounsMarked := OrderedCollection new.   tokenTypePairs do: [ :association |        | token tokenType |      token := association key.      tokenType := association value.      ( tokenType = #word )          ifFalse: [ tokenPairsWithNounsMarked add: association ]         ifTrue: [ "Is this word a noun?"             (self ontology isNoun: token)               ifFalse:  [ tokenPairsWithNounsMarked add: association ]               ifTrue: [  tokenPairsWithNounsMarked add: ( token -&gt; #noun ) ].            ].      ].   ^ tokenPairsWithNounsMarked.</pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; removeAnnotationFromSource:</h3><pre>removeAnnotationFromSource: aSourceString    | cleanerSource |   cleanerSource := self class removeAnnotationFromSource: aSourceString.   ^cleanerSource. </pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; removeCommentFromSource:</h3><pre>removeCommentFromSource: aSourceString    | cleanerSource |   cleanerSource := self class removeCommentFromSource: aSourceString.   ^cleanerSource. </pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; removeLabelFromSource:</h3><pre>removeLabelFromSource: aSourceString    "If there is a label, remove it and return the remainder."   | remainder |   remainder := self class removeLabelFromSource: aSourceString.   ^remainder.</pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; saveOntologyOnFileNamed:</h3><pre>saveOntologyOnFileNamed: aFileName    "Save my ontology on the given ReferenceStream file."   "Note: This method  does not provide any kind of versioning."   "ToDo: If we save ontology in a WorldBase instead,           the WorldBase could provide versioning."   | referenceStream |   self shouldNotImplement. "This version of Smalltalk does not provide the needed ReferenceStream class."   "Open the file for write -- clear it if necessary."   referenceStream := nil. "ReferenceStream fileNamed: aFileName."   "Write the various data structures to the file."   referenceStream nextPut: ontology.   referenceStream close.   </pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; writeFrame:onStream:</h3><pre>writeFrame: aFrame onStream: aStream   "Write frame-lines to given stream in canonical format.    *** NO SENDERS ***   - Lines have canonical format to simplify reading them back.    - Customize per frame-type as needed.   See also: writeOntolgyFrame:onStream: - which appears to do the same thing."   |  cr dotLeader |   cr := String cr.   dotLeader := '. '.   aStream nextPutAll: ( '===', cr ).   aStream nextPutAll: (( aFrame title ), cr ).   ( aFrame frameLines )         do: [ :frameLine |            "My indent convention involves dot leader"            ( (frameLine isKindOf: HumInstructionLine) and: [ frameLine indent &gt; 1 ] )                   ifTrue: [ (1 to: frameLine indent) do: [ :i |  aStream nextPutAll: dotLeader ] ].                              aStream nextPutAll: ( dotLeader, (frameLine source ), cr).                            ].   </pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; writeOntologyContextVignettesOnStream:</h3><pre>writeOntologyContextVignettesOnStream: aStream   | contexts vignettes cr |   cr := String cr.   contexts := ontology contexts sorted.   contexts      do: [ :aContext |         aStream nextPutAll: '===', cr.         aStream nextPutAll: 'Context: ', aContext, '.', cr.         vignettes := (ontology vignettesForContext: aContext) sorted: [ :aFrame :bFrame | (aFrame title) &lt; (bFrame title) ].         vignettes            do: [ :aVignetteFrame |                  aStream nextPutAll: cr.                  self writeOntologyVFrame: aVignetteFrame onStream: aStream.                ].          ].</pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; writeOntologyFrame:onStream:</h3><pre>writeOntologyFrame: aFrame onStream: aStream   "Write to given stream - customize per frame-type as needed."   |  cr dotLeader |   cr := String cr.   dotLeader := '. '.   aStream nextPutAll: ( '===', cr ).   aStream nextPutAll: (( aFrame title ), cr ).   ( aFrame frameLines )         do: [ :frameLine |            "Eh? - All lines have the same dotLeader ???  What was I thinking???"            aStream nextPutAll: dotLeader, (frameLine source ), cr.                        "See also: writeOntologyFrameWithIndents:onStream:"                ].   </pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; writeOntologyFrameWithIndents:onStream:</h3><pre>writeOntologyFrameWithIndents: aSubFrame onStream: aStream   "Vignette and View frames use dot-leader only for instruction lines."   |  cr dotLeader |   cr := String cr.   dotLeader := '. '.   ( aSubFrame frameLines )         do: [ :frameLine |            "My indent convention involves dot leader"            ( (frameLine isKindOf: HumInstructionLine) and: [ frameLine indent &gt; 1 ] )                   ifTrue: [ (1 to: frameLine indent) do: [ :i |  aStream nextPutAll: dotLeader ] ].            "NOTE: This assumes the source does not contain its own dot-leader."                  aStream nextPutAll: ( (frameLine source ), cr ).                            ].   </pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; writeOntologyFramesOfType:onStream:</h3><pre>writeOntologyFramesOfType: aFrameClass onStream: aStream   "Select frames of given class and write them on the stream."   | selectedFrames sortedFrames dotLeader cr |   dotLeader := '. '.   cr := String cr.   selectedFrames := (ontology frames) select: [ :frameX | frameX isKindOf: aFrameClass ].   sortedFrames := selectedFrames sorted: [ :frameA :frameB | (frameA title) &lt; (frameB title) ].    sortedFrames       do: [ :aFrame | self writeOntologyFrame: aFrame onStream: aStream. ].</pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; writeOntologyOnTextFileNamed:</h3><pre>writeOntologyOnTextFileNamed: aFileName    "Save my ontology in text format on the file with the given name. "   | fileStream  |   self assert: ( aFileName isKindOf: String ).   self assert: ( ontology isKindOf: HumOntology ).   fileStream := FileStream forceNewFileNamed: aFileName.    "Order: Comment, Dictionary, Vignette, Role-Action, Plan, View"   " -- NOTE: Original file order (if any) is not maintained. That means that comment frames may lack original context."   self writeOntologyFramesOfType: HumFrame4Comment onStream: fileStream.   self writeOntologyFramesOfType: HumFrame4Dictionary onStream: fileStream.   "Write context vignettes in consolidated frames."   self writeOntologyContextVignettesOnStream: fileStream.   "Write role-actions in consolidated frames."   self writeOntologyRoleActionsOnStream: fileStream.   "Write the remaining frames. ( Plan, View )"   self writeOntologyFramesOfType: HumFrame4Plan onStream: fileStream.   self writeOntologyFramesOfType: HumFrame4View onStream: fileStream.      fileStream nextPutAll: ( '===', String cr ).   fileStream close.</pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; writeOntologyRoleActionsOnStream:</h3><pre>writeOntologyRoleActionsOnStream: aStream   "Write role-action frames ordered by role and action."   | roles  cr |   cr := String cr.   roles := ontology roles sorted.   roles      do: [ :aRole |         | actionStatements actionStatementsSorted |         aStream nextPutAll: '===', cr.         aStream nextPutAll: 'Role: ', aRole, cr.         actionStatements := (ontology actionsOf: aRole). "Returns a set of HumStatement"         actionStatementsSorted := actionStatements sorted: [ :aStatement :bStatement | (aStatement source) &lt; (bStatement source) ].         actionStatementsSorted            do: [ :anActionStatement |                  | anActionFrame |                  aStream nextPutAll: cr.                  anActionFrame := ontology getFrameForRole: aRole action: anActionStatement.                  self writeOntologyFrame: anActionFrame onStream: aStream.                ].          ].</pre><h3>Hum-IDE -- HumProgrammersAssistant &gt;&gt; writeOntologyVFrame:onStream:</h3><pre>writeOntologyVFrame: aFrame onStream: aStream   "Write UI frames: Vignette and View frames only use dot-leader for instruction lines."   |  cr dotLeader |   cr := String cr.   dotLeader := '. '.   ( aFrame frameLines )         do: [ :frameLine |            "My indent convention involves dot leader"            ( frameLine isKindOf: HumInstructionLine )                    ifTrue: [ (1 to: frameLine indent) do: [ :i |  aStream nextPutAll: dotLeader ] ].                              aStream nextPutAll: ( (frameLine source ), cr).                            ].   </pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; beep</h3><pre>beep   "Signal that cursor is out-of-bounds."   Beeper beep.</pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; bumpColumn:</h3><pre>bumpColumn: anInteger    self column: (self column) + anInteger.</pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; bumpRow:</h3><pre>bumpRow: anInteger    self row: (self row) + anInteger.</pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; column</h3><pre>column   "What is the current column position of the cursor?"   ^column ifNil: [ column := 1 ].</pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; column:</h3><pre>column: anInteger    "Move cursor to given column position."   column := anInteger.   (column &lt; 1) ifTrue: [ column := 1.  self beep. ].</pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; currentLine</h3><pre>currentLine   ^self lineAt: (self row).</pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; currentLine:</h3><pre>currentLine: aString    self lines at: (self row) put: aString.   self hasNewContent: true.</pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; cursorPosition</h3><pre>cursorPosition   "Where is the insert point?"   ^ (self row)@(self column).</pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; deleteOrMerge</h3><pre>deleteOrMerge   "Delete character to left of cursor.   If cursor is at beginning of line,    append current line to prior line and move everything up."   |  currentLine calc |   currentLine := self currentLine.   calc := HumCalculator new.   calc cases;      when: [ self cursorPosition = (1@1) ]         then: [ self beep ];      when: [ (column &gt; 1) and: [ column &gt; currentLine size ] ]         then: [ self bumpColumn: -1 ];          when: [ column &gt; 1 ]         then: [ |  stringBefore stringAfter  |            stringBefore := currentLine copyFrom: 1 to: ( column - 2 ).            stringAfter := currentLine copyFrom: column to: currentLine size.            self currentLine: (stringBefore, stringAfter).            ];      when: [ column = 1 ]          then: [ | stringBefore stringAfter linesAfter |             stringBefore := self lineAt: (row-1).            stringAfter := currentLine.            self currentLine: ''.            self bumpRow: -1.            self currentLine: (stringBefore,stringAfter).            self column: stringBefore size + 1.            "Move remaining lines up"            linesAfter := Dictionary new.            (self lines)               keysAndValuesDo: [ :key :value |                  (key &gt; (row+1))                     ifTrue: [ linesAfter at: (key - 1) put: value ]                     ifFalse: [ linesAfter at: key put: value ].                   ].            lines := linesAfter.            ];      otherwise: [ Error signal: 'How did we get here?' ].   </pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; drawTextOnCanvas:font:</h3><pre>drawTextOnCanvas: aHumCanvas font: aFont       aHumCanvas drawTextLines: (self lines) withFont: aFont   </pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; drawTextOnPane:font:</h3><pre>drawTextOnPane: aHumPane font: aFont    self assert: ( aHumPane isKindOf: HumPane).   self assert: ( aFont isKindOf: AbstractFont).  "I would prefer a vector-based font."   aHumPane textChanged: self.   </pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; hasNewContent</h3><pre>hasNewContent   "Has the content been changed? -- (Dirty data flag)"   ^hasNewContent ifNil: [ hasNewContent := false ].</pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; hasNewContent:</h3><pre>hasNewContent: aBoolean    "Set true whenever the content has been changed."   self assert: (aBoolean isKindOf: Boolean).   hasNewContent := aBoolean   "TODO: Notify watchers if the boolean is true."</pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; insertCharacter:</h3><pre>insertCharacter: aCharacter    | currentLine stringBefore stringAfter |   currentLine := self lineAt: (self row).   (self column &gt; currentLine size)      ifTrue: [ currentLine := currentLine padRightTo: (self column - 1) ].   stringBefore := currentLine copyFrom: 1 to: (self column - 1).   stringAfter := currentLine copyFrom: (self column) to: (currentLine size).   self currentLine: (stringBefore, aCharacter asString, stringAfter).   self bumpColumn: 1.   self hasNewContent: true.</pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; keyStroke:</h3><pre>keyStroke: aCharacter   "Respond to simple keyboard input. (KISS: a character)   NOTE simplification: Input is a character, not an event."   | calc |   self assert: (aCharacter isKindOf: Character).   calc := HumCalculator new.   calc       switch: aCharacter;      on: Character arrowUp do: [ self bumpRow: -1 ];            on: Character arrowDown do: [ self bumpRow:  1 ];      on: Character arrowLeft do: [ self bumpColumn: -1 ];      on: Character arrowRight do: [ self bumpColumn: 1 ];      on: Character cr do: [ self splitRow ];      on: Character delete do: [ self deleteOrMerge ];      otherwise: [ self insertCharacter: aCharacter ].   "NOTE: Character does not support control, command, or shift modes."      </pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; lineAt:</h3><pre>lineAt: anInteger    "Get string for given row"   | aLine |   aLine := (self lines) at: anInteger ifAbsent: [ '' ].   ^aLine.</pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; lines</h3><pre>lines   "PRIVATE: My text lines.    Use '... lineAt: row' or 'currentLine' to access lines as strings."   ^lines ifNil: [ lines := Dictionary new ].   </pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; row</h3><pre>row   "What is the current row position of the cursor?"   ^row ifNil: [ row := 1 ].</pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; row:</h3><pre>row: anInteger    "Move cursor to given row position."   row := anInteger.   (row &lt; 1) ifTrue: [ row := 1. self beep. ].   "Note: You can move row beyond current lines."</pre><h3>Hum-IDE -- HumTextEditor &gt;&gt; splitRow</h3><pre>splitRow   | currentLine linesAfter stringBefore stringAfter |   linesAfter := Dictionary new.   "Everything after the current row is moved down one."   (self lines)      keysAndValuesDo: [ :key :value |         (key &gt; (self row))            ifTrue: [ linesAfter at: (key + 1) put: value ]            ifFalse: [ linesAfter at: key put: value ].          ].   "Split the current line."   currentLine := self lineAt: (self row).   (self column &gt; currentLine size)      ifTrue: [ currentLine := currentLine padRightTo: (self column - 1) ].   stringBefore := currentLine copyFrom: 1 to: (self column - 1).   stringAfter := currentLine copyFrom: (self column) to: (currentLine size).   self currentLine: stringBefore.   self bumpRow: 1.   self currentLine: stringAfter.   self column: 1.   self hasNewContent: true.</pre><h3>Hum-Language -- HumCommentLine &gt;&gt; source:</h3><pre>source: aString   "override supertype parsing"   source := aString.</pre><h3>Hum-Language -- HumConditionLine &gt;&gt; <=</h3><pre>&lt;= aHumConditionLine    "Provide a way to order preconditions   so that we get repeatable sequences when running a plan."   ^(self source) &lt;= (aHumConditionLine source)</pre><h3>Hum-Language -- HumConditionLine &gt;&gt; annotation</h3><pre>annotation   ^ annotation ifNil: [ '' ].</pre><h3>Hum-Language -- HumConditionLine &gt;&gt; annotation:</h3><pre>annotation: aString    "Annotation may indicate that condition is 'assumed'.  Other cases are not yet defined."   self assert: (aString sameAs: 'assumed').   annotation := aString.</pre><h3>Hum-Language -- HumConditionLine &gt;&gt; checkSyntaxWithOntology:</h3><pre>checkSyntaxWithOntology: aHumOntology    |  nouns errors correspondingPlanFrame |   errors := OrderedCollection new.   statement := HumStatement from: (self statement).   nouns := aHumOntology nounsInStatement: statement.   ( nouns isEmpty )       ifTrue: [ errors add:( 'Precondition {" ', statement source, ' "} has no known nouns!' ) ].      "Is the precondition assumed?"   ( ( self annotation ) sameAs: 'assumed' ) ifTrue: [ ^errors ].      "Otherwise: See if we have a plan for satisfying this precondition."   correspondingPlanFrame := aHumOntology getPlanFrameForGoal: statement.   "NOTE: #getPlanFrameForGoal: will return an empty plan frame  if there is none in the ontology.    Also, the ontology might contain an empty frame.    In either case, an empty frame is not a usable subplan.   "   ( correspondingPlanFrame isNoPlan )       ifTrue: [ errors add:  'Precondition {" ', statement source, ' "} has no plan.'].   ^errors.</pre><h3>Hum-Language -- HumConditionLine &gt;&gt; comment</h3><pre>comment   ^ comment ifNil: [ '' ].</pre><h3>Hum-Language -- HumConditionLine &gt;&gt; compileLineToOntology:</h3><pre>compileLineToOntology: aHumOntology    "compile a precondition line into the ontology.   Update where-used.   "   | problems |   problems := self checkSyntaxWithOntology: aHumOntology.   ^problems.</pre><h3>Hum-Language -- HumConditionLine &gt;&gt; source</h3><pre>source
   | s |   s := self statement asString.   (self comment isEmpty) ifFalse: [ s := s, ( self comment ) ].   (self annotation isEmpty) ifFalse: [ s := s, ( self annotation ) ].   ^ s. </pre><h3>Hum-Language -- HumConditionLine &gt;&gt; source:</h3><pre>source: aString   "DEBUG: Should not be 'Precondition' or: 'Pre'"   self assert: (aString asLowercase beginsWith: 'pre') not.   ^super source: aString.</pre><h3>Hum-Language -- HumConditionLine &gt;&gt; statement</h3><pre>statement      ^ statement ifNil: [ '' ].</pre><h3>Hum-Language -- HumConditionLine &gt;&gt; statement:</h3><pre>statement: aSource    "Set my statement."   statement := nil.   ( aSource isKindOf:  String ) ifTrue: [ statement := HumStatement from: aSource ].   ( aSource isKindOf: HumStatement ) ifTrue: [ statement := aSource ].   self assert: ( statement isKindOf: HumStatement ).   </pre><h3>Hum-Language -- HumDictionaryLine &gt;&gt; comment</h3><pre>comment   ^ comment ifNil: [ comment := String new. ].</pre><h3>Hum-Language -- HumDictionaryLine &gt;&gt; compileLineToOntology:</h3><pre>compileLineToOntology: aHumOntology    "Add nouns and noun-relations to the ontology.   If statement does not match a dictionary statement pattern,   return an error.   "   | lineErrors s |   "We may discover syntax errors while compiling.    Return an empty list when statement matches okay.   "   lineErrors := OrderedCollection new.       s := HumProgrammersAssistant removeCommentFromSource: self source.     ( s trimBoth isEmpty ) ifTrue: [ ^lineErrors ].      ( '* is a kind of*' match: s )      ifTrue: [ | subtype supertypes |           subtype := ( s findTokens: ' ' ) at: 1.            supertypes := self getListAfter: ' is a kind of'.            self assert: ( supertypes size = 1 ).            aHumOntology addNoun: subtype isA: ( supertypes at: 1 ).             ^lineErrors.            ].   ( '* is a type of*' match: s )      ifTrue: [ | subtype supertypes |           subtype := ( s findTokens: ' ' ) at: 1.            supertypes := self getListAfter: ' is a type of'.            self assert: ( supertypes size = 1 ).            aHumOntology addNoun: subtype isA: ( supertypes at: 1 ).             ^lineErrors.            ].   ( '* is an *' match: s )      ifTrue: [ | subtype supertypes |           subtype := ( s findTokens: ' ' ) at: 1.            supertypes := self getListAfter: 'is an '.            self assert: ( supertypes size = 1 ).            aHumOntology addNoun: subtype isA: ( supertypes at: 1 ).             ^lineErrors.            ].   ( '* is a *' match: s )      ifTrue: [ | subtype supertypes |           subtype := ( s findTokens: ' ' ) at: 1.            supertypes := self getListAfter: ' is a '.            self assert: ( supertypes size = 1 ).            aHumOntology addNoun: subtype isA: ( supertypes at: 1 ).             ^lineErrors.            ].   ( '* subtypes include *' match: s )      ifTrue: [ | supertype subtypes |            supertype := ( s findTokens: ' ' ) at: 1.            subtypes := self getListAfter: ' include '.            self assert: ( subtypes size &gt;= 1 ).            subtypes do: [ :sub | aHumOntology addNoun: sub isA: ( supertype ). ].            ^lineErrors.            ].   ( '* attributes include *' match: s )       ifTrue: [ | entity attributes |         attributes := self getListAfter: 'include'.         entity := ( s findTokens: ' ' ) at: 1.         aHumOntology addEntity: entity attributes: attributes.         ^lineErrors.           ].      ( '* categories include *' match: s )       ifTrue: [ | attribute categories |         categories := self getListAfter: 'include'.         attribute := ( s findTokens: ' ' ) at: 1.         categories             do: [ :category |                   ((category at: 1) isLetter)                      ifFalse: [ |error|                         error := 'Category name must be a word. But see: {', category, '}'.                        self assert: (error isKindOf: String).                        lineErrors add: error.                        ^lineErrors.                          ].                     ].         aHumOntology categoriesOf: attribute include: categories.         ^lineErrors.           ].      (( '*includes a set of*' match: s )     or: [ '*has a set of*' match: s  ] )      ifTrue: [ | attribute entity |           attribute := ( self getListAfter: 'a set of' ) at: 1.            entity := ( s findTokens: ' ' ) at: 1.            aHumOntology addEntity: entity attribute: attribute.            aHumOntology addNoun: attribute isA: 'set'.            ^ lineErrors.            ].   (( '*includes a list of*' match: s )     or: [ '*has a list of*' match: s ] )      ifTrue: [ | entity attribute|             attribute := ( self getListAfter: 'a list of' ) at: 1.            entity := ( s findTokens: ' ' ) at: 1.            aHumOntology addEntity: entity attribute: attribute.            aHumOntology addNoun: attribute isA: 'list'.            ^ lineErrors.            ].            (( '*is synonym for*' match: s) or: ['*is a synonym for*' match: s])      ifTrue: [ | synonym aNoun |            synonym := ( s findTokens: ' ' ) at: 1.            aNoun := self getListAfter: ' synonym for '.            ( aNoun size = 1 ) ifFalse: [ ^lineErrors add: ( 'Expecting one word but see more in: {', aNoun, '}' )].            aHumOntology addNoun: synonym isSynonymFor: ( aNoun at: 1 ).             ^lineErrors.            ].

   (( '*is shorthand for*' match: s) or: ['*is a shorthand for*' match: s])      ifTrue: [ | shorthand aNoun |            shorthand := ( s findTokens: ' ' ) at: 1.            aNoun := self getListAfter: ' shorthand for '.            ( aNoun size = 1 ) ifFalse: [ ^lineErrors add: ( 'Expecting one word but see more in: {', aNoun, '}' )].            aHumOntology addNoun: shorthand isSynonymFor: ( aNoun at: 1 ).             ^lineErrors.            ].   (( '*is abbreviation for*' match: s) or: ['*is an abbreviation for*' match: s])      ifTrue: [ | abbreviation aNoun |            abbreviation := ( s findTokens: ' ' ) at: 1.            aNoun := self getListAfter: ' abbreviation for '.            ( aNoun size = 1 ) ifFalse: [ ^lineErrors add: ( 'Expecting one word but see more in: {', aNoun, '}' )].            aHumOntology addNoun: abbreviation isSynonymFor: ( aNoun at: 1 ).             ^lineErrors.].   "Comment: Shorthand and synonym and abbreviation features enable jargon.    One could argue that enabling jargon improves readability - or not.   We could treat these nouns as subtypes and everything would work    ... except that subtype graphs would show anomolous subtypes.   "
   "If we fall through to here,     the statement was not matched to any dictionary statement pattern."         lineErrors add:( 'Dictionary statement not understood: ', s).         ^ lineErrors.</pre><h3>Hum-Language -- HumDictionaryLine &gt;&gt; getListAfter:</h3><pre>getListAfter: aString    | s sAfter list |   s := HumProgrammersAssistant removeCommentFromSource:  self source.   sAfter := HumCalculator given: s extractAfter: aString.    list := sAfter findTokens: ', .'.   "Remove the word 'and' from the list."   list removeAllSuchThat: [ :item | item sameAs: 'and' ].   ^list.</pre><h3>Hum-Language -- HumDictionaryLine &gt;&gt; source</h3><pre>source   "Construct a source line based on convention and content of my attributes."   ^source ifNil: [ source := '*** No Source? ***' ].</pre><h3>Hum-Language -- HumDictionaryLine &gt;&gt; statement</h3><pre>statement   ^ statement ifNil: [ statement := HumStatement source: (self source). ]</pre><h3>Hum-Language -- HumDictionaryLine &gt;&gt; statement:</h3><pre>statement: aStatementString    statement := HumStatement from: aStatementString.</pre><h3>Hum-Language -- HumFrame4Action &gt;&gt; actionStatement</h3><pre>actionStatement   ^ actionStatement ifNil:[ Error signal: 'Action frame must have an action statement']. </pre><h3>Hum-Language -- HumFrame4Action &gt;&gt; actionStatement:</h3><pre>actionStatement: anObject   actionStatement := nil.   (anObject isKindOf: String)             ifTrue: [ actionStatement := HumStatement from: anObject ].   (anObject isKindOf: HumStatement )      ifTrue: [ actionStatement := anObject ].   (anObject isKindOf: HumInstructionLine) ifTrue: [ actionStatement := anObject statement].   self assert: ( actionStatement isKindOf: HumStatement ).   </pre><h3>Hum-Language -- HumFrame4Action &gt;&gt; appendInstructionRole:statement:</h3><pre>appendInstructionRole: aRole statement: aStatement    | frameLine |   frameLine := ( HumInstructionLine role: aRole statement: aStatement ).   self instructionLines add: frameLine.   self frameLines add: frameLine.</pre><h3>Hum-Language -- HumFrame4Action &gt;&gt; appendInstructionRole:statement:comment:</h3><pre>appendInstructionRole: aRole statement: aStatement comment: aComment      | actionInstruction |      actionInstruction := HumInstructionLine new.   actionInstruction role: aRole; statement: aStatement; comment: aComment.      self instructionLines add: actionInstruction.   self frameLines add:  actionInstruction .</pre><h3>Hum-Language -- HumFrame4Action &gt;&gt; appendInstructionStatement:</h3><pre>appendInstructionStatement: aSource    | actionInstruction |      actionInstruction := HumInstructionLine new.   actionInstruction role: ''; statement: aSource; comment: ' '.      self instructionLines add: actionInstruction.   self frameLines add:  actionInstruction .</pre><h3>Hum-Language -- HumFrame4Action &gt;&gt; checkSyntaxWithOntology:</h3><pre>checkSyntaxWithOntology: anOntology    "Critique the instructions for this role action."   |  critique lineCritique action actionNouns |         "Return the critique as a sequence of strings."   critique := OrderedCollection new.      "The action should contain at least one noun."   action := self actionStatement.   actionNouns := anOntology nounsInStatement: action.   ( actionNouns size &gt; 0 )       ifFalse: [ critique add: ( 'Action statement {',( action asString ),'} has no known nouns!' ) ].         "There should be at least one instruction for the action statement."         ( self instructionLines size &gt; 0 )      ifFalse: [ critique add: 'Action {', self titleLine,'} has no instructions.'. ].            "Nouns in the instructions should find antecedants in the action statement."   (self instructionLines)       do: [ :instruction |          lineCritique := ( instruction checkSyntaxWithOntology: anOntology defaultRole: (self role)).         critique := critique, lineCritique.         lineCritique := ( instruction checkForAntecedantsIn: (self actionStatement) withOntology: anOntology ).         critique := critique, lineCritique.                  ].    "TODO: The line after  'For . . .  : ' or  'If . . .  : '  or 'Else:' should be indented."      "TODO: Think about how indentation should be assured.    In the editor context, the indentation should be automatic.   Note: Indentation is an attribute of an instruction line.   "   ^critique.</pre><h3>Hum-Language -- HumFrame4Action &gt;&gt; compileToOntology:</h3><pre>compileToOntology: aHumOntology    "Compile the frame into the ontology."   | nLinesIn nLinesOut |   "Make sure frame is stored."   aHumOntology storeFrame: self.   "Index the role-action"      aHumOntology indexRole: self role action: self actionStatement.   nLinesIn := self frameLines size.   "Add the instruction sequence"   ( self instructionLines )       do: [ :instruction |         "aHumOntology appendInstruction: instruction toRole: (self role) action: (self actionStatement)."         (instruction role sameAs: '')             ifFalse: [ aHumOntology indexFrame: self relation: #invokesAction object: (instruction title). ].         ].   nLinesOut := self frameLines size.   self assert: (nLinesOut = nLinesIn ) description: 'compileToOntology affects source.'.   "Return no errors."      ^ (self checkSyntaxWithOntology:  aHumOntology ).          </pre><h3>Hum-Language -- HumFrame4Action &gt;&gt; instructionLines</h3><pre>instructionLines   ^ instructions ifNil: [ instructions := OrderedCollection new ].</pre><h3>Hum-Language -- HumFrame4Action &gt;&gt; instructions</h3><pre>instructions   ^ instructions ifNil: [ instructions := OrderedCollection new. ].</pre><h3>Hum-Language -- HumFrame4Action &gt;&gt; instructions:</h3><pre>instructions: anObject   instructions := anObject</pre><h3>Hum-Language -- HumFrame4Action &gt;&gt; role</h3><pre>role   ^ role.</pre><h3>Hum-Language -- HumFrame4Action &gt;&gt; role:</h3><pre>role: anObject   role := anObject</pre><h3>Hum-Language -- HumFrame4Action &gt;&gt; titleLine</h3><pre>titleLine   "Format a cannonical title line."   ^ 'Role: ', ( self role asString capitalized), ' -- ', ( self actionStatement asString ).</pre><h3>Hum-Language -- HumFrame4Comment &gt;&gt; appendFrameLine:</h3><pre>appendFrameLine: aLine   | frameLine calc |    calc := HumCalculator new.   calc cases;      when: [  aLine isKindOf: HumCommentLine ] then: [ frameLine := aLine ];      when: [ aLine isKindOf: String ] then: [ frameLine := HumCommentLine new. frameLine source: aLine ];      otherwise: [ Error signal: 'Comment value is not of expected type.' ].   self assert: (frameLine isKindOf: HumCommentLine).   self frameLines add: frameLine.</pre><h3>Hum-Language -- HumFrame4Data &gt;&gt; appendEntity:attrribute:value:</h3><pre>appendEntity: aEntityName attrribute: anAttributeName value: aValueString    |  colon indent |   indent := '. '.   colon := ': '.   ( ( priorEntityName isNil ) or: [(aEntityName sameAs: priorEntityName) not]  )      ifTrue: [ self appendFrameLine: (aEntityName, colon ).            priorEntityName := aEntityName ].   self appendFrameLine:  ( indent, anAttributeName, colon, aValueString ).</pre><h3>Hum-Language -- HumFrame4Data &gt;&gt; asString</h3><pre>asString   | s cr |   cr := String cr.   s := 'Data Frame', cr.   s := s, '---', cr.   ( self frameLines )      do: [ :line | s := s, line asString, cr. ].   s := s, '---', cr.         ^s.</pre><h3>Hum-Language -- HumFrame4Dictionary &gt;&gt; addDictionaryLine:</h3><pre>addDictionaryLine: aSourceString    | dictionaryLine |   dictionaryLine := HumDictionaryLine new source: aSourceString.   self frameLines add: dictionaryLine.</pre><h3>Hum-Language -- HumFrame4Dictionary &gt;&gt; compileToOntology:</h3><pre>compileToOntology: aHumOntology    "Each dictionary line will have some additive effect on the ontology."   | syntaxErrors lineErrors |   "Make sure frame is stored."   aHumOntology storeFrame: self.   "We may discover syntax errors while compiling."   syntaxErrors := OrderedCollection new.   (self frameLines select: [ :frameLine | frameLine isKindOf: HumDictionaryLine ] )      do: [ :dictionaryLine |         lineErrors := dictionaryLine compileLineToOntology: aHumOntology.         syntaxErrors := syntaxErrors, lineErrors.
         ].   ^syntaxErrors.</pre><h3>Hum-Language -- HumFrame4Plan &gt;&gt; actionStatements</h3><pre>actionStatements   ^self planActions.</pre><h3>Hum-Language -- HumFrame4Plan &gt;&gt; appendInstructionRole:statement:</h3><pre>appendInstructionRole: aRole statement: aStatement    | instruction |   instruction :=  ( HumInstructionLine role: aRole statement: aStatement ).   self planActions add: instruction.   self frameLines add:  instruction.</pre><h3>Hum-Language -- HumFrame4Plan &gt;&gt; appendPrecondition:</h3><pre>appendPrecondition: aSource    | precondition |   precondition := (HumConditionLine new) statement: aSource.   self assert: ( precondition isKindOf: HumConditionLine ).   self preconditions add: precondition.   self frameLines add: precondition.</pre><h3>Hum-Language -- HumFrame4Plan &gt;&gt; appendPrecondition:annotation:</h3><pre>appendPrecondition: aStatement annotation: anAnnotation   | precondition |   precondition := (HumConditionLine new) statement: aStatement.   precondition annotation: anAnnotation.   self assert: ( precondition isKindOf: HumConditionLine ).   self preconditions add: precondition.   self frameLines add: precondition.</pre><h3>Hum-Language -- HumFrame4Plan &gt;&gt; appendRole:action:</h3><pre>appendRole: aRole action: aSource    "Add 'role: action-statement' to plan-frame"   | |      self appendRole: aRole action: aSource comment: nil.</pre><h3>Hum-Language -- HumFrame4Plan &gt;&gt; appendRole:action:comment:</h3><pre>appendRole: aRole action: aSource comment: aComment   "Add 'role: action-statement. (comment)' to plan-frame"   | actionInstruction |      actionInstruction := HumInstructionLine new.   actionInstruction role: aRole; statement: aSource; comment: aComment.      self planActions add: actionInstruction.   self frameLines add:  actionInstruction .</pre><h3>Hum-Language -- HumFrame4Plan &gt;&gt; check</h3><pre>check   "Check the basic integrity of the plan frame."   | problems |   "The callers sees the problems in the same order we do."   problems := OrderedCollection new.   "The plan frame must have a goal."   ( self goal isNil )       ifTrue: [ problems add: 'A plan frame must have a goal.']      ifFalse: [ ( self goal source size &gt; 5 )                   ifFalse: [ problems add: 'A plan frame must have a goal.' ].             ].      "A plan frame should have at least two preconditions."   (( self preconditions size ) &gt; 1) ifFalse: [ problems add: 'A plan frame should have at least two preconditions.' ].   ^problems.</pre><h3>Hum-Language -- HumFrame4Plan &gt;&gt; checkSyntaxWithOntology:</h3><pre>checkSyntaxWithOntology: anOntology   | frameErrors lineErrors  checkLines  |   frameErrors := OrderedCollection new.   "Check stand-alone syntax.   Detect statements with no nouns.   Detect statements that have not been defined.   "   checkLines := (self preconditions), (self planActions).   checkLines      do: [ :frameLine |          ( frameLine isKindOf: HumInstructionLine )            ifTrue: [ lineErrors := (frameLine checkSyntaxWithOntology: anOntology defaultRole: (frameLine role)).]            ifFalse: [lineErrors := (frameLine checkSyntaxWithOntology: anOntology).].                  (lineErrors isEmpty) ifFalse: [ frameErrors := frameErrors, lineErrors ].         ].   "Check data flow.    Each statement's nouns must have antecedants in the goal statement."   checkLines      do: [ :frameLine |         lineErrors := (frameLine checkForAntecedantsIn: (self goal) withOntology: anOntology ).         (lineErrors isEmpty) ifFalse: [ frameErrors := frameErrors, lineErrors ].         ].   ^frameErrors.</pre><h3>Hum-Language -- HumFrame4Plan &gt;&gt; compileToOntology:</h3><pre>compileToOntology: aHumOntology    "Check the basic integrity of the plan frame.   If it is viable, put it into ontology."   | problems |   "Make sure frame is stored."   aHumOntology storeFrame: self.   "The callers sees the problems in the same order we do."   problems := self checkSyntaxWithOntology: aHumOntology.         "A plan frame should have at least two preconditions. (should not must)"   (( self preconditions size ) &gt; 1)       ifFalse: [ problems add: 'No preconditions.'.         (planActions size &gt; 0)             ifTrue: [problems add:' Action will be taken as soon as plan starts.']             ifFalse: [problems add: 'Plan frame is empty.']         ].      "The plan frame must have a goal."   ( self goal isNil )       ifTrue: [ problems add: 'A plan frame must have a goal.']      ifFalse: [ ( self goal source size &gt; 5 )                   ifFalse: [ problems add: 'A plan frame must have a goal.']                  ifTrue: [ "Looks like we have a goal"                     aHumOntology addPlanFrame: self ForGoal: (self goal source).                        "If the frame has a goal, store the frame regardless of errors."                     aHumOntology storeFrame: self.                     ] .            ].   "Compile the preconditions"         (self preconditions)      do: [ :precondition |             | thisProblem |             thisProblem := precondition compileLineToOntology: aHumOntology.             problems := problems, thisProblem.             "Index the precondition"             "aHumOntology frameRelations add: { (self title). #precondition. (precondition statement asString). }."            ontology indexFrame: self relation: #precondition object: (precondition statement asString).            "TODO: Decide if we want the title or the frame itself. (frame reference)"            "Note: The title may change when the goal statement is edited. However, recompile should fix."            "Note: Our structure could enable changing definition, changes all references."            ].      "Compile the actions"         ( self actionStatements )      do: [ :action |             | thisProblem |             thisProblem := action compileLineToOntology: aHumOntology.             problems := problems, thisProblem.             "Index the precondition"             "aHumOntology frameRelations add: { (self title). #invokesAction. ( action titleLine ). }."             ontology indexFrame: self relation: #invokesAction object: (action titleLine).             ].      ^problems.</pre><h3>Hum-Language -- HumFrame4Plan &gt;&gt; goal</h3><pre>goal   "Get the plan frame's goal statement."   ^ goal</pre><h3>Hum-Language -- HumFrame4Plan &gt;&gt; goal:</h3><pre>goal: aSource    "This instance variable contains the plan frame's goal statement."   | goalStatement |  ( aSource isKindOf: String ) ifTrue: [ goalStatement := HumStatement from: aSource.].  ( aSource isKindOf: HumStatement ) ifTrue: [ goalStatement := aSource.].   goal := goalStatement.   titleLine := 'Goal: ', goalStatement source.</pre><h3>Hum-Language -- HumFrame4Plan &gt;&gt; isNoPlan</h3><pre>isNoPlan   "Frame is no plan if there are no preconditions and no actions.   Either the preconditions or the action may be empty, but not both.   However, both could have the statement: 'None.' to indicate that the programmer   has not simply forgotten this frame.   Comment: If goal appears as a precondition elsewhere,   . but has no preconditions and no action needed to make it true,   . it could be annotated as [Assumed.] where it appears as a precondition   . and then no frame would be required for it.   TODO: Think about a feature    . where a precondition marked [Assumed] in one context    . is automatically marked [Assumed] everywhere.   "   self preconditions isEmpty      ifFalse: [ ^false ].   self planActions isEmpty      ifFalse: [ ^false ].   ^true.</pre><h3>Hum-Language -- HumFrame4Plan &gt;&gt; planActions</h3><pre>planActions  "A sequence of actions to be performed after preconditions are satisfied.   Generally, a single action is better form, but multiple actions are allowed.   Multiple actions will be performed in the sequence given by the author.  "   ^ planActions ifNil: [ planActions := OrderedCollection new. ].</pre><h3>Hum-Language -- HumFrame4Plan &gt;&gt; preconditions</h3><pre>preconditions   "Preconditions are ordered to preserve the author`s sequence,   and to make locally-run unit test sequences repeatable.    However, during actual runtime execution,      preconditions will be executed asynchronously     with dynamic scheduling.   Required sequences should be indicated by the plan tree structure or via Action procedure.   "   ^ preconditions ifNil: [ preconditions := OrderedCollection new ].</pre><h3>Hum-Language -- HumFrame4View &gt;&gt; addMarkUp:</h3><pre>addMarkUp: aSource    | frameLine |   (aSource isKindOf: String)      ifTrue: [ frameLine := HumMarkupLine source: aSource ].   (aSource isKindOf: HumMarkupLine )      ifTrue: [ frameLine := aSource ].   frameLine ifNil: [Error signal: 'Unexpected object type.'].      self frameLines add: frameLine.</pre><h3>Hum-Language -- HumFrame4View &gt;&gt; compileToOntology:</h3><pre>compileToOntology: aHumOntology   ""   | errors |   "Make sure frame is stored."   aHumOntology storeFrame: self.   errors := OrderedCollection new.   "Index cases where a widget refers to another view."   (self frameLines select: [:frameLine | frameLine isKindOf: HumMarkupLine ])      do: [ :frameLine |         | widgets |         widgets := frameLine widgets.         widgets            do: [ :widget |                  ('[pane: *]' match: widget)                  ifTrue: ["Index this case."                     | viewName |                     viewName := (HumCalculator given: widget extractBetween: '[pane:' and: ']') trimBoth.                     "(aHumOntology frameRelations) add: { (self title). #invokesView. viewName. }"                     aHumOntology indexFrame: self relation: #invokesView object: viewName.                     ].               ].         ].      ^errors := (super compileToOntology: aHumOntology ).</pre><h3>Hum-Language -- HumFrame4View &gt;&gt; entity</h3><pre>entity   ^ entity ifNil: [ entity := HumCalculator given: (self titleLine) extractAfter: ': '].</pre><h3>Hum-Language -- HumFrame4View &gt;&gt; entity:</h3><pre>entity: anObject   entity := anObject</pre><h3>Hum-Language -- HumFrame4View &gt;&gt; viewEntity:</h3><pre>viewEntity: anEntityType.    "What entity-type is this view displaying."   entity := anEntityType.</pre><h3>Hum-Language -- HumFrame4View &gt;&gt; viewName:</h3><pre>viewName: aString   "Caller passes the name of the view - to be used in calls."   viewName := aString.   "View-name is a noun."   self ontology addNoun: aString isA: 'view'. </pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; addPattern:</h3><pre>addPattern: aPatternString    "Enter a pattern -- What pattern will the vignette respond to?"   "Nil is ignored when parser is running."   aPatternString ifNil: [^self].      (self patterns) add: aPatternString trimBoth.</pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; addVignetteInstruction:</h3><pre>addVignetteInstruction: anInstructionLine    "Append an instruction to be executed in response to the user / client."   | instruction |   ( anInstructionLine isKindOf: HumInstructionLine )      ifTrue: [ instruction := anInstructionLine ]      ifFalse: [ | role stmt |         "check for role"         role := HumProgrammersAssistant getLabelFromSource: anInstructionLine.         stmt := HumProgrammersAssistant removeLabelFromSource: anInstructionLine.         instruction := ( HumInstructionLine role: role statement: stmt).].      (self instructionLines ) add: instruction.   (self frameLines ) add: instruction.</pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; addVignettePattern:</h3><pre>addVignettePattern: patternString    "Append an Pattern to be matched in response to the user / client."   |  |   (self patterns ) add: patternString.   (self frameLines ) add: (HumVignettePatternLine source: ('U: ',patternString)).</pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; addVignetteResponse:</h3><pre>addVignetteResponse: aResponseString    "Append a verbal response line."   | markup |   markup :=  ( HumMarkupLine source: aResponseString ).   self responseLines add: markup.   self frameLines add: (HumVignetteResponseLine source: ('S: ', aResponseString)).</pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; checkSyntaxWithOntology:</h3><pre>checkSyntaxWithOntology: anOntology   "Check the vignette for syntax problems."   | critique patternCritique nouns |   "First get the critique of the frame lines."   critique := OrderedCollection new.   ( self frameLines )      do: [ :frameLine |          | lineErrors |         ( frameLine isKindOf: HumInstructionLine )            ifTrue: [lineErrors := (frameLine checkSyntaxWithOntology: anOntology defaultRole: 'DialogAgent').]            ifFalse: [lineErrors := (frameLine checkSyntaxWithOntology: anOntology).].         (lineErrors isEmpty) ifFalse: [ critique := critique, lineErrors ].         ].   patternCritique := OrderedCollection new.      "The vignette must have a context and a pattern."   ( vignetteContext isEmptyOrNil  ) ifTrue: [ critique add: 'Vignette has no context!' ].   ( patterns isEmptyOrNil ) ifTrue: [ critique add: 'Vignette has no pattern!' ].            "The nextContext should be known to the ontology.   NOTE: This assumes that a Frame4Vignette contains a single vignette.   "   (( anOntology vignettesForContext: ( self nextVignetteContext ) ) isEmpty )
       ifTrue: [ critique add: 'Vignette`s next context {',( self nextVignetteContext ),'} is unknown in ontology. ' ].      "Each [noun] field  in the pattern should reference known nouns."   nouns := self patternNouns.   nouns       do: [ :noun |          (anOntology isNoun: noun)             ifFalse: [ patternCritique add: 'Vignette pattern references unknown noun: ', noun.]           ].      critique := critique, patternCritique.      ^critique.</pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; compileToOntology:</h3><pre>compileToOntology: anOntology   "Update the ontology with this vignette."   | |   "Make sure frame is stored."   anOntology storeFrame: self.      anOntology addVignette: self toContext: (self vignetteContext trimBoth ).      "Index any external action calls."   ( self instructionLines )      do: [ :instructionLine |         ( instructionLine role = '' )            ifFalse: [ "(ontology frameRelations) add: { (self title). #invokesAction. ( instructionLine title ).}. "                  ontology indexFrame: self relation: #invokesAction object: (instructionLine title)]            ifTrue: ["Index 'Show view' and 'Ask view' cases."               | sourceString |               sourceString := instructionLine statement source.               (sourceString beginsWith: 'Ask') "Ask for attribute values via the given view."                  ifTrue: [ |viewName|                     viewName := (HumCalculator given: sourceString extractBetween: 'Ask' and: '.') trimBoth asLowercase.                     ontology indexFrame: self relation: #invokesView object: viewName.                      ].               (sourceString beginsWith: 'Show') "Show (read-only) attribute values via the given view."                  ifTrue: [ |viewName|                     viewName := (HumCalculator given: sourceString extractBetween: 'Show' and: '.') trimBoth asLowercase.                     ontology indexFrame: self relation: #invokesView object: viewName.                      ].               (sourceString beginsWith: 'New') "Create a new entity in the dialog blackboard."                  ifTrue: [ |entityName|                     entityName := (HumCalculator given: sourceString extractBetween: 'New' and: '.') trimBoth asLowercase.                     ontology indexFrame: self relation: #creates object: entityName.                      ].                                 (sourceString beginsWith: 'Push context') "Place given context on top of context-stack."                  ifTrue: [ |contextName|                     contextName := (HumCalculator given: sourceString extractBetween: 'Push context' and: '.') trimBoth asLowercase.                     ontology indexFrame: self relation: #invokesContext object: contextName.                      ].               ].         ].      ^ ( self checkSyntaxWithOntology: anOntology ) .</pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; inputToken:isEquivalentTo:</h3><pre>inputToken: inputToken isEquivalentTo: patternToken   "Is the input equivalent to the pattern?   Allow for common synonyms.   "    | calc patternLC inputLC |   "Simple case."   (inputToken sameAs: patternToken) ifTrue: [^true].      "Handle tricky pattern tokens."      calc := HumCalculator new.   patternLC := patternToken asLowercase.   inputLC := inputToken asLowercase.   calc cases;      when: [ patternLC = '.' ]    then: [ ^(inputLC = '!') ];      when: [ patternLC = 'hello'] then: [ ^(#('hi' 'hey' 'howdy') includes: inputLC) ];      otherwise: [^false].</pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; inputTokensIn:</h3><pre>inputTokensIn: aString   "Return the pattern tokens in the given string."   | tokens |   tokens := HumCalculator findTokensInString: aString.   tokens := HumCalculator removeNoiseWordTokensFrom: tokens.      "Extract strings in the input as separate tokens."   "TODO: Numbers followed by measurement units should be treated as a single token."   (tokens include: '"')      ifTrue: [| correctedTokens collecting string |         correctedTokens := OrderedCollection new.         string := String new.         collecting := false.         tokens do: [:token |             ( collecting or: [token = '"'])                   ifFalse: [ correctedTokens add: token ]                  ifTrue: [                     string := string, token.                     (collecting and: [token = '"'] )                         ifTrue: [ correctedTokens add: string. collecting := false. ]                        ifFalse: [collecting := true.]                     ]            ].         tokens := correctedTokens.         ].   ^tokens.    </pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; instructionLines</h3><pre>instructionLines   "Return the vignette's instruction lines. "   ^ instructionLines ifNil: [ instructionLines := OrderedCollection new. ].</pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; nextVignetteContext</h3><pre>nextVignetteContext   "By default, the next context is the current context."   ( nextContext isEmptyOrNil )  ifTrue: [ nextContext := vignetteContext ].   ^ nextContext.</pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; nextVignetteContext:</h3><pre>nextVignetteContext: aContextName    "What will be the context after the response is rendered?   The context stack prioritizes responses to otherwise identical user patterns.   NOTE: This assumes that vignette frame contains a single set of patterns and a single response.   "   nextContext := aContextName.</pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; patternFields:</h3><pre>patternFields: pattern   "Parse the pattern and return the [noun] fields - including the brackets.   TODO: DOES THIS BELONG IN HumVignettePatternLine"   | fields s field |   fields := OrderedCollection new.   s := self pattern.   self assert: ( s isKindOf: String ).   [ field := HumCalculator given: s extractBetween: '[' and: ']'.  ( field size &gt; 0 )  ]      whileTrue: [  fields add: ( '[', field, ']' ).                   s := HumCalculator given: s extractAfter: ']'.                ].   ^fields.   </pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; patternMatchScore:</h3><pre>patternMatchScore: aString   "How well does the string (from client) match the pattern int this vignette?   Score a point for each token matched in order.   TODO: DOES THIS BELONG IN HumPatternLine?   "   | points bestPatternPoints calc |      calc := HumCalculator new.   points := 0.   bestPatternPoints := 0.      "But first, one pattern has to match. Then we score it."   ( self patterns )      do: [:pattern |         | patternTokens inputTokens  xInput xPattern |         self assert: [ pattern isKindOf: String ].                  "These parsers remove noise words (a, an, the)."         patternTokens := (self patternTokensIn: pattern).         inputTokens   := (self inputTokensIn: aString).                  "Attempt to match input to pattern."         xInput := 1.         xPattern := 1.         points := 0.         [ (xPattern &lt;= patternTokens size ) and: [xInput &lt; (inputTokens size)] ]            whileTrue: [ "For each pattern token"                  |  patternToken inputToken |                  patternToken := patternTokens at: xPattern.                  inputToken := inputTokens at: xInput.                  calc cases;                  when: [patternToken = '*']                  then: ["Match everything upto next pattern token"                        | nextPatternToken xNextInput  |                        nextPatternToken := patternTokens at: (xPattern + 1).                        "Does the remaining input have the next pattern token?                        If not, we are done scoring.                         "                        "xNextInput := inputTokens indexOf: nextPatternToken startingAt: xInput ifAbsent: [ -1 ]."                        xNextInput := 0.                        (1 to: inputTokens size)                            do: [:i | ( (i &gt;= xInput)                                          and: [ self inputToken: (inputTokens at: i) isEquivalentTo: nextPatternToken])                                              ifTrue: [xNextInput := i]                                  ].                        ( xNextInput = 0 )                           ifTrue: ["Match fails. Force to next pattern."                              points := 0.  "TODO:  No credit for partial match?"                              xPattern := 9999.                              ]                           ifFalse: ["Matching so far. Continue to next pattern token."                              xInput := xNextInput.                              xPattern := xPattern + 1.                              points := points + 1.                              ].                                                ];                  when: [ patternToken = '[' ]                  then: ["Assign the next inputToken to the noun named between [...]"                        | xNextPattern |                                                                         "For now, assume the next input token matches the bracket expression."                        points := points + 1.                                                "Advance the pattern token index to the closing bracket."                        "A missing bracket should have been caught at compile-time."                        xNextPattern := patternTokens indexOf: ']' startingAt: xPattern                                                                     ifAbsent: [Error signal: 'no closing bracket?'].                        xPattern := xNextPattern + 1.                        patternToken := patternTokens at: xPattern.                        "Advance the input to the next pattern token."                        xInput := inputTokens indexOf: patternToken ifAbsent: [ inputTokens size + 1 ].                        (xInput &lt;= inputTokens size) ifTrue: [points := points + 1 ].                                               ];                  when: [self inputToken: inputToken isEquivalentTo: patternToken]                  then:["Increment the score"                        points := points + 1.                        ];                  otherwise: ["The input token does not match the pattern."                        "Force out to the next pattern."                        points := 0.                        xPattern := 9999.                        ].                  xInput := xInput + 1.                     xPattern := xPattern + 1.                     ((xInput &gt; inputTokens size) and: [ xPattern &lt;= patternTokens size ])                     ifTrue: ["We ran out of input before we ran out of pattern."                        "Partial match does not score."                        points := 0.                        "Force out to the next pattern."                        xPattern := 9999.                        ].                  ]. "Each token"             ( points &gt; bestPatternPoints ) ifTrue: [ bestPatternPoints := points ].         ]. "Each pattern"   ^ bestPatternPoints.</pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; patternNouns</h3><pre>patternNouns   "TODO: DOES THIS BELONG IN HumVignettePatternLine ?"   | nouns |   nouns := Set new.   ( self patterns )      do: [ :pattern |         nouns := nouns addAll: (self patternNouns: pattern ).         ].   ^ nouns.</pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; patternNouns:</h3><pre>patternNouns: pattern   "Parse the pattern and return the nouns referenced in [noun] fields.    When the pattern is recognized, the noun value will be placed on the dialog's blackboard.'   TODO: DOES THIS BELONG IN HumVignettePatternLine?   "   | fields s field |   fields := OrderedCollection new.   s := pattern.   self assert: ( s isKindOf: String ).   [ field := HumCalculator given: s extractBetween: '[' and: ']'.  ( field size &gt; 0 )  ]      whileTrue: [  fields add: (  field ).                   s := HumCalculator given: s extractAfter: ']'.                ].   ^fields.   </pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; patternTokensIn:</h3><pre>patternTokensIn: aString    "Return the pattern tokens in the given string.   WARNING: Uppercase is preserved.   TODO: DOES THIS BELONG IN HumVignettePatternLine?   "   | tokens |   tokens := HumCalculator findTokensInString: aString.   tokens := HumCalculator removeNoiseWordTokensFrom: tokens.   ^tokens.</pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; patterns</h3><pre>patterns   ^ patterns ifNil: [ patterns := OrderedCollection new ].</pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; responseLines</h3><pre>responseLines   "What will be the verbal response? "   ^ responseLines ifNil: [ responseLines := OrderedCollection new. ].</pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; titleLine</h3><pre>titleLine   | s |   self patterns isEmpty      ifTrue: [s := 'Context: "', ( vignetteContext asString), '" pattern: "nil"'.]      ifFalse: [s := 'Context: "', ( vignetteContext asString), '" pattern: "', ( (patterns at: 1) asString ),'"'.].      ^s.</pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; vignetteContext</h3><pre>vignetteContext   "The context is used to prioritize responses when two or more patterns match a user input.   It also provides a category seen when viewing the collection of vignettes.   "   ( vignetteContext isEmptyOrNil ) ifTrue: [ Error signal: 'A vignette context is missing.'].   ^ vignetteContext</pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; vignetteContext:</h3><pre>vignetteContext: aContextString    "The context is used to prioritize responses when two or more patterns match a user input.   It also provides a category seen when viewing the collection of vignettes.   "   vignetteContext := aContextString. </pre><h3>Hum-Language -- HumFrame4Vignette &gt;&gt; zpatternMatchScore:</h3><pre>zpatternMatchScore: aString   "How well does the string (from client) match the pattern int this vignette?   Score a point for each token matched in order.   "   | points bestPatternPoints  |   points := 0.   bestPatternPoints := 0.      "(aString beginsWith: 'My name is') ifTrue: [self halt]." "DEBUG"      "But first, one pattern has to match. Then we score it."   ( self patterns )      do: [:pattern |         | patternTokens inputTokens  xInput xPattern |         self assert: [ pattern isKindOf: String ].                  "Remove noise words and punctuation"         patternTokens := (self patternTokensIn: pattern).         inputTokens   := (self inputTokensIn: aString).                  "Attempt to match input to pattern."         xInput := 1.         xPattern := 1.         points := 0.         [ xPattern &lt;= patternTokens size ]            whileTrue: [ "For each pattern token"                  | continue patternToken inputToken |                  continue := true.                  patternToken := patternTokens at: xPattern.                  (patternToken = '*')                      ifTrue: ["Match everything upto next pattern token"                        | nextPatternToken xNextInput  |                        nextPatternToken := patternTokens at: (xPattern + 1).                        "Does the remaining input have the next pattern token?                        If not, we are done scoring.                         "                        xNextInput := inputTokens indexOf: nextPatternToken startingAt: xInput ifAbsent: [ -1 ].                        ( xNextInput &lt; 0 )                           ifTrue: ["Match fails. Force to next pattern."                              points := 0.  "TODO:  No credit for partial match?"                              xPattern := 9999.                              continue := false.                              ]                           ifFalse: ["Matching so far. Continue to next pattern token."                              xInput := xNextInput.                              xPattern := xPattern + 1.                              points := points + 1.                              ].                                                continue := false.                        ].                  (continue and: [ patternToken = '[' ])                     ifTrue: ["Assign the next inputToken to the noun named between [...]"                        | xNextPattern |                                                 "TODO: HOW SHOULD WE INTERPRET THIS?                        Will we assign the next input to the noun value                        or require the next input to match the noun value?                        TODO: HOW SHOULD WE SCORE THIS?                        "                        "For now, assume the next input token matches the bracket expression."                        "Advance the pattern token index to the closing bracket."                        xNextPattern := patternTokens indexOf: ']' startingAt: xPattern ifAbsent: [Error signal: 'no closing bracket?'].                        xPattern := xNextPattern.                        points := points + 1.                        continue := false.                        ].                  inputToken := inputTokens at: xInput.                                    (continue and: [self inputToken: inputToken isEquivalentTo: patternToken])                     ifTrue: ["Increment the score"                        points := points + 1.                        continue := false.                        ].                     (continue)                     ifTrue: ["The input token does not match the pattern."                        "Force out to the next pattern."                        points := 0.                        xPattern := 9999.                        ].                  xInput := xInput + 1.                     xPattern := xPattern + 1.                     ((xInput &gt; inputTokens size) and: [ xPattern &lt;= patternTokens size ])                     ifTrue: ["We ran out of input before we ran out of pattern."                        "Force out to the next pattern."                        points := 0.                        xPattern := 9999.                        ].                  ]. "Each token"             ( points &gt; bestPatternPoints ) ifTrue: [ bestPatternPoints := points ].         ]. "Each pattern"   ^ bestPatternPoints.</pre><h3>Hum-Language -- HumFrameLine &gt;&gt; checkForAntecedantsIn:withOntology:</h3><pre>checkForAntecedantsIn: aHumStatement withOntology: aHumOntology    | antecedants myNouns result |   antecedants := aHumOntology nounsInStatement: aHumStatement.   myNouns := aHumOntology nounsInStatement: self statement.   result := OrderedCollection new.   ( antecedants includesAllOf: myNouns )      ifTrue: [ ^result ].   ( myNouns copyWithoutAll:  antecedants )      do: [ :noun |         result add: 'The noun: "',noun,'" has no antecedant.'.          ].   ^result.</pre><h3>Hum-Language -- HumFrameLine &gt;&gt; checkSyntaxWithOntology:</h3><pre>checkSyntaxWithOntology: aHumOntology    |  nouns errors  |   errors := OrderedCollection new.   nouns := aHumOntology nounsInStatement: (self statement).   (nouns isEmpty )       ifTrue: [ errors add:( 'Statement { ', self statement source ,' } has no known nouns!' ) ].   ^ errors.</pre><h3>Hum-Language -- HumFrameLine &gt;&gt; comment</h3><pre>comment   "Any frame line can have a comment."   ^comment ifNil: [comment := ''].</pre><h3>Hum-Language -- HumFrameLine &gt;&gt; comment:</h3><pre>comment: aString   "Any frame line can have a comment."   | test |   aString ifNil: [comment := nil. ^self].   test := HumCalculator given: aString extractIncludingMatching: '()'.   (test isNil)      ifTrue: [comment := aString]      ifFalse: [comment := HumCalculator given: test extractBetween: '(' and: ')'].      </pre><h3>Hum-Language -- HumFrameLine &gt;&gt; compileLineToOntology:</h3><pre>compileLineToOntology: aHumOntology    "Compile this instruction line."   | errors |    "Subtypes should implement."   "Error signal: 'Subtypes should implement.'."   errors := OrderedCollection new.   ^ errors.</pre><h3>Hum-Language -- HumFrameLine &gt;&gt; doTokensIn:at:matchPatternTokensIn:at:</h3><pre>doTokensIn: input at: x matchPatternTokensIn: patternTokens at: xPattern   "See if we can get any matching sequence."   "TODO: Everything in this method category should probably be in HumOntologyTranslator."   | pToken atParameter isMatch |   isMatch := false.   "If we run out of pattern, we have succeeded."   ( xPattern &gt; (patternTokens size) ) ifTrue: [ ^true ].   "If we run out self before we run out of pattern, we have failed."   ( x &gt; ( input size ) ) ifTrue: [^false].   "A pattern token that is a digit will match anything.     Proceed to next token in both lists.    But if there is no match there, the pattern token could still match the next self token, so try that.   "   pToken := patternTokens at: xPattern.   atParameter := ( ( ( pToken size = 1) and: [ pToken isAllDigits ] ) ).   atParameter         ifTrue: [ isMatch := (self doTokensIn: input at: (x + 1) matchPatternTokensIn: patternTokens at: (xPattern + 1) )                              or: [self doTokensIn: input at: (x + 1) matchPatternTokensIn: patternTokens at: (xPattern + 0 ) ].                  ^isMatch.                ].   "Remainder assumes that current pattern token is NOT a digit."               self assert: (  atParameter not  ).   "If the current pattern token matches the current self token, proceed to the next token in both lists."   ( ( patternTokens at: xPattern ) sameAs: ( input at: x ) )         ifTrue: [ "Proceed to next token in both lists"                  isMatch := self doTokensIn: input at: (x + 1) matchPatternTokensIn: patternTokens at: (xPattern + 1).                   ^isMatch                ]         ifFalse: [ "See if the next token in self matches the pattern token"                  isMatch := self doTokensIn: input at: (x + 1) matchPatternTokensIn: patternTokens at: (xPattern + 0).                  ^isMatch. ].         "At this point we have a mismatch for sure. (I think maybe.)"   isMatch := false.            ^isMatch.</pre><h3>Hum-Language -- HumFrameLine &gt;&gt; extractPatternParameters:</h3><pre>extractPatternParameters: aPatternString    "Extract parameters (tokens) from source that match the pattern."   | parameters patternTokens selfTokens isMatch |      self assert: ( aPatternString isKindOf: String ).   patternTokens := self getTokensIn: ( aPatternString asLowercase ).     selfTokens := self getTokensIn: ( self source asLowercase ).   "Search to see if a sequence in my tokens matches a sequence in pattern tokens."   isMatch := self doTokensIn: selfTokens at: 1 matchPatternTokensIn: patternTokens at: 1.      isMatch ifFalse: [ Error signal: 'Attempt to get parameters when pattern does not match.' ].   parameters := OrderedCollection new.   self getParametersIn: selfTokens at: 1 thatMatchParametersIn: patternTokens at: 1 accumulating: parameters.   ^ parameters reversed.</pre><h3>Hum-Language -- HumFrameLine &gt;&gt; generateCodeFrom:using:</h3><pre>generateCodeFrom: aTemplateString using: parameterValues    "Generate code (string) from the template replacing parameters with values in the parameter list."   "TODO: Does this method belong in HumOntologyTranslator ?"   | templateTokens code  |   self assert: ( aTemplateString isKindOf: String ).   self assert: ( parameterValues isKindOf: OrderedCollection ).   code := String new.   templateTokens := self getTokensIn: aTemplateString.   templateTokens       do: [ :token | "For each token:"         | atParameter |         atParameter := ( ( ( token size = 1 ) and: [ token isAllDigits ] ) ).         atParameter            ifTrue: [ code := code, ( parameterValues at:  ( token asNumber ) ).  ]            ifFalse: [ code := code, token ].         ].   ^code.</pre><h3>Hum-Language -- HumFrameLine &gt;&gt; getParametersIn:at:thatMatchParametersIn:at:accumulating:</h3><pre>getParametersIn: input at: x thatMatchParametersIn: patternTokens at: xPattern accumulating: parameters   "See if we can get any matching sequence."   | pToken atParameter  isMatch parameter |   isMatch := false.    parameter := nil.   "If we run out of pattern, we have succeeded."   ( xPattern &gt; (patternTokens size) ) ifTrue: [ ^true ].   "If we run out self before we run out of pattern, we have failed."   ( x &gt; ( input size ) ) ifTrue: [^false].   "A pattern token that is a digit will match anything.     Proceed to next token in both lists.    But if there is no match there, the pattern token could still match the next self token, so try that.   "   pToken := patternTokens at: xPattern.   atParameter := ( ( ( pToken size = 1) and: [ pToken isAllDigits ] ) ).   atParameter         ifTrue: [ isMatch := (self getParametersIn: input at: (x + 1 ) thatMatchParametersIn: patternTokens at: (xPattern + 1 ) accumulating: parameters )                           or: [self getParametersIn: input at: (x + 1 ) thatMatchParametersIn: patternTokens at: (xPattern + 0 ) accumulating: parameters ].                   isMatch ifTrue: [ parameters add: ( input at: x ) ].                    ^isMatch.               ].   "Remainder assumes that current pattern token is not a parameter."               self assert: ( atParameter not ).   "If the current pattern token matches the current self token, proceed to the next token in both lists."   ( ( patternTokens at: xPattern ) sameAs: ( input at: x ) )         ifTrue: [ "Proceed to next token in both lists"                  isMatch := self getParametersIn: input at: (x + 1) thatMatchParametersIn:patternTokens at: (xPattern + 1) accumulating: parameters.                   ^isMatch                ]         ifFalse: [ "See if the next token in self matches the pattern token"                  isMatch := self getParametersIn: input at: (x + 1) thatMatchParametersIn:patternTokens at: (xPattern + 0) accumulating: parameters.                  ^isMatch. ].         "At this point we have a mismatch for sure. (I think maybe.)"   isMatch := false.            ^isMatch.</pre><h3>Hum-Language -- HumFrameLine &gt;&gt; getTokensIn:</h3><pre>getTokensIn: aString   "This is a helper for #matchesPattern: (). It implements a Hum-friendly tokenizer."   "TODO: Does this method belong in HumOntologyTranslator ?  It also might be in HumCalculator."   | punctuation whiteSpace tokens |   "Punctuation does not include hyphen because nouns may be hypenated."   punctuation := '~!@#$%^&*()_+`={}|[[]\:";&lt;&gt;?,./'.    "White space includes space, cr, tab."      whiteSpace := '          '.   "Tokens are all lower-case and include punctuation."   tokens := ( aString asLowercase ) findTokens: ( punctuation, whiteSpace ) keep: (punctuation, whiteSpace).      ^tokens.</pre><h3>Hum-Language -- HumFrameLine &gt;&gt; matchesPattern:</h3><pre>matchesPattern: aPatternString    "Does some part of the frame-line match the given pattern?"   | patternTokens selfTokens isMatch |   self assert: ( aPatternString isKindOf: String ).   patternTokens := self getTokensIn: ( aPatternString asLowercase ).     selfTokens := self getTokensIn: ( self source asLowercase ).   "Search to see if a sequence in my tokens matches a sequence in pattern tokens."   isMatch := self doTokensIn: selfTokens at: 1 matchPatternTokensIn: patternTokens at: 1.    ^isMatch.</pre><h3>Hum-Language -- HumFrameLine &gt;&gt; onMatch:generate:</h3><pre>onMatch: aPatternString generate: aTemplateString    "When some part of the content in the current line matches the pattern,    - Generate code from the template.    - Replace parameters indicated by digits with corresponding values in the parameter array.   "   | code parameters |   self assert: ( aPatternString isKindOf: String ).   self assert: ( aTemplateString isKindOf: String ).   "If there is no match, there is nothing to do. Return an empty string."   code := String new.   ( self matchesPattern: aPatternString ) ifFalse: [ ^code ].   "Otherwise, we have a match.   Generate some code.   "   parameters := self extractPatternParameters: aPatternString.   code := self generateCodeFrom: aTemplateString using: parameters.   ^code.</pre><h3>Hum-Language -- HumFrameLine &gt;&gt; printOn:</h3><pre>printOn: aStream   "Append to the argument, aStream, a sequence of characters that     identifies the receiver."   | title |   title := self class name.   aStream      "nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);"      nextPutAll: title;      nextPutAll: '( ', self source, ' )';      nextPutAll: String cr.</pre><h3>Hum-Language -- HumFrameLine &gt;&gt; sameAs:</h3><pre>sameAs: anotherFrameLine   (anotherFrameLine isKindOf: String)      ifTrue: [^ (self source) sameAs: anotherFrameLine.].   (anotherFrameLine isKindOf: HumFrameLine )      ifTrue: [^ ( self source ) sameAs: ( anotherFrameLine source ).].   "Eh? Why are we here?"   Error signal: 'unexpected type'.   </pre><h3>Hum-Language -- HumFrameLine &gt;&gt; source</h3><pre>source   ^ source</pre><h3>Hum-Language -- HumFrameLine &gt;&gt; source:</h3><pre>source: aString    self assert: ( aString isKindOf: String ).   source := aString.   "Any frame line might have a comment between ()."   self comment: (HumCalculator given: source extractIncludingMatching: '()')."   (self comment size &gt; 0)      ifTrue: [ self statement: (HumCalculator given: source extractUpto: '(' ). ]      ifFalse: [ self statement: aString ]."   </pre><h3>Hum-Language -- HumFrame &gt;&gt; appendFrameLine:</h3><pre>appendFrameLine: aFrameLine   "Append a line to the frame."   (aFrameLine isKindOf: HumFrameLine ) ifFalse: [Error signal: 'not a frameLine'].   self frameLines add: aFrameLine.</pre><h3>Hum-Language -- HumFrame &gt;&gt; checkSyntaxWithOntology:</h3><pre>checkSyntaxWithOntology: anOntology   | frameErrors lineErrors    |   frameErrors := OrderedCollection new.   "Check stand-alone syntax.   Detect statements with no nouns.   Detect statements that have not been defined.   "   (self frameLines reject: [:frameLine | (frameLine isKindOf: HumCommentLine )])      do: [ :frameLine |          lineErrors := (frameLine checkSyntaxWithOntology: anOntology).         (lineErrors isEmpty) ifFalse: [ frameErrors := frameErrors, lineErrors ].         ].   ^frameErrors.</pre><h3>Hum-Language -- HumFrame &gt;&gt; compileToOntology:</h3><pre>compileToOntology: aHumOntology    | problems lineProblems |   problems := OrderedCollection new.   self frameLines      do: [ :frameLine |         lineProblems := ( frameLine compileLineToOntology: aHumOntology ).         problems := problems, lineProblems.         ].   "Regardless of errors add frame to the ontology."      aHumOntology storeFrame: self.   ^problems.</pre><h3>Hum-Language -- HumFrame &gt;&gt; debug</h3><pre>debug   "Am I in debug mode?"   ^ debug ifNil: [debug := false].</pre><h3>Hum-Language -- HumFrame &gt;&gt; debug:</h3><pre>debug: aBoolean    self assert: (aBoolean isKindOf: Boolean).   debug := aBoolean.</pre><h3>Hum-Language -- HumFrame &gt;&gt; delegateToTranslator</h3><pre>delegateToTranslator   Error signal: 'This frame function should be delegated to HumOntologyTranslator.'</pre><h3>Hum-Language -- HumFrame &gt;&gt; delegated</h3><pre>delegated   Error signal: 'Should be implemented in Ontology Viewer (HumOntologyViewer)'.</pre><h3>Hum-Language -- HumFrame &gt;&gt; frameLines</h3><pre>frameLines   ^frameLines ifNil: [ frameLines := OrderedCollection new.]</pre><h3>Hum-Language -- HumFrame &gt;&gt; frameName</h3><pre>frameName   "The name of the frame is guaranteed to be a string.   Generally, it is the same as the titleLine.   "   | frameName |   frameName := (self titleLine) asString.   ^ frameName.</pre><h3>Hum-Language -- HumFrame &gt;&gt; initialize</h3><pre>initialize   "The instance should always be a subtype."   | instance |   instance := self.   self assert: (instance className = 'HumFrame') not.   </pre><h3>Hum-Language -- HumFrame &gt;&gt; isEmpty</h3><pre>isEmpty   | hasTitle hasContent result |   hasTitle := ((titleLine notNil) and: [titleLine &gt; '']).   hasContent := (self frameLines size &gt; 0).   result := (hasContent or: [hasTitle]) not.   ^result.            </pre><h3>Hum-Language -- HumFrame &gt;&gt; linesAsHTMLwithOntology:</h3><pre>linesAsHTMLwithOntology: anOntology   | html cr |   cr := String cr.   html := cr.   self frameLines       do: [ :frameLine |            html := html, '&lt;br/&gt;', ( frameLine asHTML5withOntology: anOntology ) ].   ^html.</pre><h3>Hum-Language -- HumFrame &gt;&gt; ontology</h3><pre>ontology   ^ ontology</pre><h3>Hum-Language -- HumFrame &gt;&gt; ontology:</h3><pre>ontology: anOntology   Transcript cr; show: 'Ontology: ', anOntology title.   ontology := anOntology.   self origin: anOntology title.</pre><h3>Hum-Language -- HumFrame &gt;&gt; origin</h3><pre>origin   "Where did this frame come from?"   ^origin ifNil: [ origin := 'unknown' ].</pre><h3>Hum-Language -- HumFrame &gt;&gt; origin:</h3><pre>origin: aString   "Where did this frame come from?"   origin := aString.</pre><h3>Hum-Language -- HumFrame &gt;&gt; prettyPrintWithOntology:</h3><pre>prettyPrintWithOntology: aHumOntology   "Pretty-print using HTML5 and CSS   --  This is a read-only view for ontology code listing."   | html calc |   self delegated.   calc := HumCalculator new.   html :=   calc xml: 'frame'      with: [         (calc xml: 'frameTitle' with: [  self titleLine asString ]),         (self linesAsHTMLwithOntology: aHumOntology)         ].   ^html.   </pre><h3>Hum-Language -- HumFrame &gt;&gt; printOn:</h3><pre>printOn: aStream   "Append to the argument, aStream, a sequence of characters that     identifies the receiver."   | title |   title := self class name.   aStream      "nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);"      nextPutAll: title;      nextPutAll: '( ', self frameName, ' )';      nextPutAll: String cr.</pre><h3>Hum-Language -- HumFrame &gt;&gt; title</h3><pre>title   ^ self titleLine </pre><h3>Hum-Language -- HumFrame &gt;&gt; titleLine</h3><pre>titleLine   ^titleLine         </pre><h3>Hum-Language -- HumFrame &gt;&gt; titleLine:</h3><pre>titleLine: anObject   titleLine := anObject asString.</pre><h3>Hum-Language -- HumFrame &gt;&gt; uniqueIdentifier</h3><pre>uniqueIdentifier   "Note: Lazy initialization for this frame`s identifier."   ^ uniqueIdentifier            ifNil: [ uniqueIdentifier := HumIdentifier createUniqueIdentifierForEntityName: (self title) inContext: ('Creating ontology ', self class asString). ].</pre><h3>Hum-Language -- HumFrame &gt;&gt; zcompileToOntology:</h3><pre>zcompileToOntology: aHumOntology    | problems lineProblems |   "Regardless of errors add frame to the ontology."      aHumOntology storeFrame: self.   "Looking for trouble!"   problems := OrderedCollection new.   self frameLines      do: [ :frameLine |         "Action, Plan, and Vignette frames all may have instruction lines."         ( frameLine isKindOf: HumInstructionLine )            ifTrue: [ lineProblems := frameLine compileLineToOntology: aHumOntology defaultRole: 'DialogAgent'.]            ifFalse: [lineProblems := frameLine compileLineToOntology: aHumOntology.].         problems := problems, lineProblems.         ].   ^problems.</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; =</h3><pre>= anInstruction   "??? Looks like bad code ???  "   ( anInstruction isKindOf: String) ifTrue: [ ^ statement = anInstruction ].   ( anInstruction isKindOf: HumInstructionLine ) ifTrue: [ ^ statement = ( anInstruction statement ) ].   "Find out where this is used.  (2015-12-26: None of the unit tests trip over this halt.)"   self halt.</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; annotation</h3><pre>annotation   ^ annotation ifNil: [^'' ].</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; annotation:</h3><pre>annotation: aString    "Annotation may indicate timing for simulations.    [native] indicates that the statement should be native to the agents that implement the role.   When a statement is [native], the critique should not expect an definition in the current ontology.   "   annotation := aString.</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; checkSyntaxWithOntology:</h3><pre>checkSyntaxWithOntology: aHumOntology    |  errors |   Error signal: 'In this context, call "checkSyntaxWithOntology: aHumOntology defaultRole: aRole"  instead.'.   errors := OrderedCollection new.   ^ errors.</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; checkSyntaxWithOntology:defaultRole:</h3><pre>checkSyntaxWithOntology: aHumOntology defaultRole: aRole   |  nouns errors theRole |   errors := OrderedCollection new.   "Forgive a nil statement. Sometimes an instruction line has no statement."   statement ifNil: [^errors].   "Ignore empty statement"   (statement source trimBoth  =  '' ) ifTrue: [ ^errors ].   "Check that the nouns in the statement are known. (defined in the ontology)."   nouns := aHumOntology nounsInStatement: statement.   ( nouns isEmpty )       ifTrue: [ errors add: ( 'Statement: {', statement source ,'} has no known nouns!' ) ].      "Check that a delegated action is defined in the ontology."   theRole := self role.   ( theRole = '') ifTrue: [ theRole := aRole ].   ( aHumOntology isActionDefined: self inRole: theRole )       ifFalse: [ errors add: ('Action: {', statement source, '} has not been defined.') ].      ^ errors.</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; comment</h3><pre>comment   ^ comment ifNil: [''].</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; comment:</h3><pre>comment: aString    "Comment is not executable. May be displayed in certain contexts."   comment := aString.</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; compileLineToOntology:</h3><pre>compileLineToOntology: aHumOntology    "Compile this instruction line."   | errors |    "Check syntax"   errors := self checkSyntaxWithOntology: aHumOntology defaultRole: (self role).   "remember the errors - May show in HTML and other views"   problems := errors.   ^ errors.</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; compileLineToOntology:defaultRole:</h3><pre>compileLineToOntology: aHumOntology defaultRole: aRole   "Compile this instruction line."   | errors |    "TODO: Kludge some polymorphism.    TODO: Fix-up string arguments"      "Check syntax"   errors := self checkSyntaxWithOntology: aHumOntology defaultRole: aRole.   "remember the errors - May show in HTML and other views"   problems := errors.   ^ errors.</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; indent</h3><pre>indent   "How many indents (tabs) before the start of the code-text ?"   ^ indent ifNil: [ indent := 1 ].</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; indent:</h3><pre>indent: aSmallInteger   "How many indents (tabs) before the start of the code-text ?"   indent := aSmallInteger.   (indent &lt; 1 ) ifTrue: [ indent := 1].</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; jobTicket</h3><pre>jobTicket   "There should be a job ticket if the (run-time) caller expects one."   ^ jobTicket ifNil: [ Error signal: 'no jobTicket']</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; jobTicket:</h3><pre>jobTicket: aJobTicket   "At run-time, a job ticket may be associated with action request."   self assert: ( aJobTicket isKindOf: HumJobTicket ).   jobTicket := aJobTicket.   "TODO: This instance variable is here because the run-time needs to pass a jobTicket when delegating an instruction. (?)         I think there is something wrong in that calling logic. See: ???"</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; onComment:</h3><pre>onComment: aBlockClosure    "If instruction includes a comment, execute the block."   comment ifNil: [^self].   (comment size &gt; 1 ) ifTrue: aBlockClosure.</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; onRole:</h3><pre>onRole: aBlockClosure    "If instruction includes a role prefix, execute the block."   role ifNil: [^self ].   (role size &gt; 1) ifTrue: aBlockClosure.</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; role</h3><pre>role   "What role am I delegating to? If none, the instruction is to myself."   ^ role  ifNotNil: [ (role) ] ifNil: [''].    "TODO: Consider returning #self instead of an empty string."</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; role:</h3><pre>role: aString    "Delegate the task (statement) to this role at run-time. "   role := aString.</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; source</h3><pre>source   "Construct a source line based on convention and content of my attributes."   | s |   s := self statement asString.   (self role trimBoth isEmpty ) ifFalse: [ s :=( role,': ', s ) ].   (self comment trimBoth isEmpty) ifFalse: [ s := s,' (', ( self comment ), ') ' ].   (self annotation trimBoth isEmpty) ifFalse: [ s := s, ' [', ( self annotation ), '] ' ].   source ifNil: [ source := s. ].   ^ s. </pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; source:</h3><pre>source: aString   "Should not be: 'Action:' block-label."   self assert: (aString beginsWith: 'Action:') not.   ^super source: aString.</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; statement</h3><pre>statement   "What will be done . . . will be done at run-time."   ^ statement          ifNil: [ "FIX UP !!!"            source ifNil: [Error signal: 'Blank instruction line.'].            statement := HumStatement source: source.            ].</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; statement:</h3><pre>statement: aSource    "What to do  at run-time?"   | x |   ( aSource isKindOf: String )       ifTrue: [ "Convert to HumStatement"         | sourceString |         sourceString := aSource.         x := 0.         [ sourceString beginsWith: '. ' ]             whileTrue: [ "Count the indents."               x := x + 1.               sourceString := sourceString copyFrom: 3 to: (sourceString size).               ].         statement := HumStatement from: sourceString.          "Determine the indent level."         self indent: x.         ^self.         ].   ( aSource isKindOf: HumStatement )      ifTrue: ["Copy the Statement."         statement := aSource copy.         self indent: 1.         ^self. ].   self assert: ( statement notNil ).   </pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; title</h3><pre>title   ^ self titleLine.</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; titleLine</h3><pre>titleLine   ^ ( self role), ': ', ( self statement asString ).</pre><h3>Hum-Language -- HumInstructionLine &gt;&gt; translation:</h3><pre>translation: aString    translation := aString.</pre><h3>Hum-Language -- HumMarkupLine &gt;&gt; checkSyntaxWithOntology:</h3><pre>checkSyntaxWithOntology: aHumOntology    "Syntax errors in mark-up mainly have to do with widgets that won't work.   Other errors will simply be rendered as-is.   "   |  errors widgets widgetNoun |   ""   errors := OrderedCollection new.   widgets := self widgets.   "Look for unknown nouns in widgets."   widgets       do: [ :widget |          widgetNoun := HumMarkupLine widgetNounIn: widget.         ( aHumOntology isNoun: widgetNoun )            ifFalse: [ errors add: ('In {', widget, '} the widget contains unknown noun: {', widgetNoun,'}' ) ].         ].   "TODO: Look for unknown widget-types in widgets.    . Known widget types include     . . [page:  TITLE ] -- Link to local page (a la wiki)    . . [link: TITLE | URL] -- Link to a remote page given by the URL/URI    . . [pane: TITLE] -- Insert given pane    . . [range: LB - UB ] -- Provide a slider or similar device on input; a progress bar on output.    . Attribute types with specific rendering should eventually include     . . [category] [text] [date] [email] -- HTML5 can handle directly    . . [measure] -- accept and validate quantity, unit-of-measure, plus-or-minus    . . [collection -- display a table? (default rendering or ???)   "   widgets      do: [ :widget |          ].      ^errors.</pre><h3>Hum-Language -- HumMarkupLine &gt;&gt; compileLineToOntology:</h3><pre>compileLineToOntology: aHumOntology    |  errors widgets  |   ""   errors := OrderedCollection new.   widgets := self widgets.   "Look for unknown nouns in widgets."   widgets       do: [ :widget |          | widgetNoun |         widgetNoun := HumMarkupLine widgetNounIn: widget.         ( aHumOntology isNoun: widgetNoun )            ifFalse: [ errors add: ('In {', widget, '} the widget contains unknown noun: {', widgetNoun,'}' ) ]            ifTrue: [                aHumOntology addNoun: widgetNoun.               aHumOntology addNoun: widgetNoun reference: self.                ].         ].   "TODO: Look for unknown widget-types in widgets."   widgets      do: [ :widget |          ].      ^errors.</pre><h3>Hum-Language -- HumMarkupLine &gt;&gt; generateCodeOfType:fromTokens:at:</h3><pre>generateCodeOfType: aSymbol fromTokens: tokens at: xToken   "Generate code of the given type HTML/Seaside/JavaScript based on token stream."   | currentToken code cr doubleQuote singleQuote calc |      self delegated.   calc := HumCalculator new.   "Current experiment is to generate HTML5 from Hum mark-up."   self assert: aSymbol = #HTML.   code := String new.   cr := String cr.   "If we ran out of tokens, we are done?"   ( xToken &gt; tokens size ) ifTrue: [ ^self ].   currentToken := tokens at: xToken.   "If we are at beginning of line, there are special rules."   ( xToken = 1 )      ifTrue: [ "Look for heading, list, or instruction."         (currentToken = '.')             ifTrue: [ "Line is instruction." "Ignore it for now. Make a comment line as a reminder."               code := '&lt;!-- ', source, ' --&gt;'.                 ^ code.               ].         (currentToken = '!')             ifTrue: ["Line is heading. But what level?"               | level |               level := 1.               [ (level &lt; (tokens size))  and: [ (tokens at: level + 1 ) = '!' ] ] whileTrue: [ level := level + 1 ].               "Remainder of line is in this header"               code := calc xml: ('h', (level asString))  with: [ self generateCodeOfType: aSymbol fromTokens: tokens at: level + 1 ] .               ^code.               ].         (currentToken = '-' )             ifTrue: ["Line is list. But what level?"               | level |               level := 1.               [ (level &lt; (tokens size))  and: [ (tokens at: level + 1 ) = '-' ] ] whileTrue: [ level := level + 1 ].               "If level has changed, we need to output &lt;ul&gt; or &lt;/ul&gt;"               ( level &gt; indentLevel ) ifTrue: [ code := '&lt;ul&gt;', cr. ].               ( level &lt; indentLevel ) ifTrue: [ code := '&lt;/ul&gt;', cr. ].               "Remainder of line is in this header"               code := code, (calc xml: 'li' with: [ self generateCodeOfType: aSymbol fromTokens: tokens at: level + 1 ]) .               ^code.               ].            "If we have come this far, the line begins with nothing special."              "Go on as if we were not on the first token."         ].      "Look for quotes -- we need to remove tokens between quotes from translation."      doubleQuote := $".      singleQuote := $".         (currentToken = doubleQuote or: [ currentToken = singleQuote ] )         ifTrue: [ | quote removal x |             quote := currentToken.            removal := String new.            x := xToken + 1.            [ ( x &lt; (tokens size) ) and: [ tokens at: x = quote ] ] whileFalse: [ removal := removal, (tokens at: x). x := x + 1. ].            code := code, removal, quote, (self generateCodeOfType: aSymbol fromTokens: tokens at: ( x + 1 )   ).            ^code.            ].      "Look for emphasis -- tokens between are in scope of  . . ."      (currentToken = '*' or: [[ currentToken = '~' ]  or: [ currentToken = '_' ] ] )         ifTrue: [ | emphasis removal x |             emphasis := currentToken.            removal := String new.            x := xToken + 1.            [ ( x &lt; (tokens size) ) and: [ tokens at: x = emphasis ] ] whileFalse: [ removal := removal, (tokens at: x). x := x + 1. ].            code := code, removal, emphasis, (self generateCodeOfType: aSymbol fromTokens: tokens at: ( x + 1 )   ).            "Note: Above is a bit simplistic.             It assumes there is nothing to be interpreted in the string between emphasis tokens.            The following would not work properly: *~bold-italic~*  *_bold-and-underlined_*            TODO: Make this smarter.            "            ^code.            ].      "Look for widgets."      ( currentToken = '[' )         ifTrue: [ "What we do depends on the type of widget."            | nextToken |            nextToken := (tokens at: (xToken + 1) ).            ( nextToken = 'page' )               ifTrue: [self generatePageWidgetFromTokens: tokens at: nextToken ].            ].</pre><h3>Hum-Language -- HumMarkupLine &gt;&gt; generateHtmlTableFor:withOntology:</h3><pre>generateHtmlTableFor: aNoun withOntology: anOntology   | singular attributes html  |      self delegated.   singular := anOntology singularFormOfNoun: aNoun.   attributes := anOntology allAttributesOfEntity: singular.   "If the entity has no attributes, generate a default table."   ( attributes size = 0 )      ifTrue: [^'&lt;table name="',aNoun,'"&gt;&lt;tr&gt;&lt;th&gt;',aNoun,' has no attributes in current ontology.&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;'].  "Otherwise generate a normal table."   html := '&lt;table name="',aNoun,'" &gt;'.   html := html, '&lt;tr&gt;'.   attributes do: [:attribute | html := html, '&lt;th&gt;', attribute, '&lt;/th&gt;'.].    html := html, '&lt;/tr&gt;'.   html := html, '&lt;tr&gt;'.   attributes do: [:attribute | html := html, '&lt;td&gt;', attribute, ' value &lt;/td&gt;'.]. "STUB"   html := html, '&lt;/tr&gt;'.   html := html, '&lt;/table&gt;'.   ^html.</pre><h3>Hum-Language -- HumMarkupLine &gt;&gt; getWidgetArgument:</h3><pre>getWidgetArgument: aWidgetString   "Parse the widget string to get verb`s argument, if any."   | argument |   (aWidgetString includesSubString: ':')      ifFalse: [^''].   argument := HumCalculator given: aWidgetString extractBetween: ':' and: ']'.   self assert: (argument size &gt; 0).   ^argument</pre><h3>Hum-Language -- HumMarkupLine &gt;&gt; getWidgetNoun:</h3><pre>getWidgetNoun: aWidgetString   "Parse the widget-string to get the widget`s noun (blackboard entity-attribute-name), if any."   | noun |   (aWidgetString includesSubString: ':') "[verb: argument] pattern has no blackboard noun."      ifTrue: [^''].   (aWidgetString beginsWith: '[[')   "[[button]] has no blackboard noun."      ifTrue: [ ^'' ].   noun := HumCalculator given: aWidgetString  extractBetween: '[' and: ']'.   ^noun   </pre><h3>Hum-Language -- HumMarkupLine &gt;&gt; getWidgetVerb:</h3><pre>getWidgetVerb: aWidgetString   "Parse the widget-string to get the widget`s verb, if any."   | verb |   (aWidgetString includesSubString: ':')      ifFalse: [^''].   verb := HumCalculator given: aWidgetString extractBetween: '[' and: ':'.   self assert: (verb size &gt; 0).   ^verb</pre><h3>Hum-Language -- HumMarkupLine &gt;&gt; widgets</h3><pre>widgets   "Scan the source matching pairs of [. . .] or [[. . .]]."   | widgets  s button widget |   widgets := OrderedCollection new.      s := self source.   "Scan for widgets"         [ widget := HumCalculator given: s extractBetween: '[' and: ']'.     ( widget size &gt; 0 ) ]      whileTrue: [  "Watch out for [[button label]] pattern."               ( widget beginsWith: '[')                     ifTrue: [ "This widget looks like a button. Return [[button label]]."                                widgets add: ( '[', widget, ']]' ).                                s := HumCalculator given: s extractAfter: ']]'.                                 ]                     ifFalse: [ "This widget does not look like a button. Return [content]."                                  widgets add: ( '[', widget, ']' ).                                     s := HumCalculator given: s extractAfter: ']'.                                 ].                ].   ^widgets.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; asJava</h3><pre>asJava   "This is crude version.   Futures:   - Roles become classes.   - Entity-Attribute relations become classes with get/set methods.   - Noun types are one of: ( Entity Category Enumeration String Measure TimeStamp ).   - Dialogs are become method calls with blocks.   - Views are still interpreted.   "   | code nounCode actionCode |   code := ''.   nounCode := self nounsAsJava.   code := code, nounCode.   actionCode := self rolesAsJava.   code := code, actionCode.   ^ code.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; attachAction:toActorClass:fromSource:</h3><pre>attachAction: aMethodName toActorClass: aClassName fromSource: aSource   "Attach the given method source       to the given class          under the given method name."   | methods |   methods := self getMethodsForClass: aClassName.   self assert: (methods isKindOf: Dictionary ).   methods at: aMethodName put: aSource.     </pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; attachPrologToActorClass:fromSource:</h3><pre>attachPrologToActorClass: aClassName fromSource: aSourceString    "Attach the given prologue source code to the named class."   | |   "Note: There can be only one prologue for each actor class"   ( self prologues ) at: aClassName put: aSourceString.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; contextEntity:</h3><pre>contextEntity: aString    contextEntity := aString</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; countLeading:inString:</h3><pre>countLeading: aCharacter inString: line   "Count leading"   | n ch |   ( aCharacter isKindOf: Character ) ifTrue: [ ch := aCharacter ].   ( aCharacter isKindOf: String ) ifTrue: [ ch := aCharacter at: 1 ].   self assert: ( ch isKindOf: Character ).   self assert: ( (line at: 1) = ch ).   n := 1.   [ (line at: n) = ch ] whileTrue: [n := n+1].  ^n-1.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; genHTML:</h3><pre>genHTML: generatedCodeString   "Append generated code to 'html' instance variable. (YIKES!)"   | |      "If code begins with a tag, insert cr to improve readability."   ( generatedCodeString beginsWith: '&lt;' )     ifTrue: [(self html) nextPutAll: (String cr, generatedCodeString).]     ifFalse: ["Otherwise, it is caller`s responsibility to prepend cr &lt;br/&gt;"               (self html) nextPutAll: generatedCodeString.               ].
  "TODO: REFACTOR this HTML generator to eliminate this side-effect stuff."   </pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateErlangDocumentation</h3><pre>generateErlangDocumentation   | translationStrategy runTimeStrategy |   translationStrategy := 'Erlang Translation Strategy   Each Hum role is translated into Erlang module.   Hum Instructions become Erlang patterns - that match on the HumStatement source.   The Hum statement source becomes an Erlang atom for matching purposes.   Delegation become an Erlang message.   '.   runTimeStrategy := 'Erlang Run-Time Strategy   The Hum run-time will be implemented in Erlang.   The Hum-Erlang run-time actors include: Coordinator, Dispatcher, Messenger, BlackBoard, WorldBase, Bookkeeper.   It also seems likely that the Hum-Erlang run-time will also include DialogAgent, and Scribe actors.   However, it may make more sense to implement those actors in JavaScript. (TBD).   '.   "2015-12-26: I wrote some experimental versions of an Erlang Messenger some time ago.   I think (but may mis-remember) that I also wrote an experimental Erlang WorldBase.    "   ^translationStrategy, runTimeStrategy.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateErlangForActionCall:</h3><pre>generateErlangForActionCall: aString   "Translate a Hum Action call into an Erlang OTP call."   | erlang colon quote comma roleAtom statementString  statementAtom nounValues |   self assert: (aString isKindOf: String).   "Extract the statement string from the Instruction Line."   "TODO: HumStatement knows how to parse better than HumCalculator. It knows about comments and annotations."      colon := $: asString.   quote := $' asString.   comma := $, asString.   roleAtom := (HumCalculator given: aString extractUpto: colon) asLowercase.   statementString := (HumCalculator given: aString extractAfter: colon) trimBoth.   statementAtom := quote, statementString, quote.   nounValues := self generateErlangNounValuesForStatement: statementString.   erlang := '?CALL( ', roleAtom, comma, statementAtom, ', [ ', nounValues, ' ] )', comma, String cr.   ^erlang   </pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateErlangForActionHeader:</h3><pre>generateErlangForActionHeader: aString    "Then: The do header looks like 'do( { action-statement, noun-values } )' "   | erlang quote statementString    nounValues |   quote := $' asString.   (aString beginsWith: 'Action:')      ifTrue: [ statementString := (HumCalculator given: aString extractAfter: 'Action:') trimBoth. ]      ifFalse: [ statementString := aString ].   "TODO: Fix case where statementString contains single quote/s."   nounValues := self generateErlangNounValuesForStatement: statementString.      erlang := 'do( { ', quote, statementString, quote, ', [ ', nounValues, ' ] } ) -&gt;', String cr.   ^ erlang.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateErlangForEntity:</h3><pre>generateErlangForEntity: anEntity   "Translate entity into an Erlang record data structure. &lt;&lt;&lt; OBSOLETE   -record( entity, { attribute, attribute, attribute } ).      "   | erlangCode comma attributes separator supertypes |      Error signal: 'Decided after giving it more thought that this translation concept is a bad idea'.   "After all, action call will be ?CALL({',roleAtom,',"',statementString,'",NounValues}). where NounValues is a list of {noun, noun-value} tuples."      self assert: (anEntity isKindOf: String).   comma := ', '.   separator := ' '.   "Generate the preamble."   erlangCode := '-record( ', (self nounAsCamelCase: anEntity) uncapitalized, comma, '{'.   "Generate the tuple elements."   attributes := (ontology immediateAttributesOfEntity: anEntity) asArray.  "Note: Attributes that are also entities imply nested records."   self assert: ( (attributes at: 1) isKindOf: String).  "Assume a collection of String"   attributes       do: [ :attribute |          erlangCode := erlangCode, separator, (self nounAsCamelCase: attribute) uncapitalized.           separator := comma. "Remaining attributes will be separated by a comma."         ].         supertypes := (ontology immediateSupertypesOf: anEntity) asArray.  "Note: Attributes that are also entities imply nested records."   self assert: ( (attributes at: 1) isKindOf: String).  "Assume a collection of String"   supertypes       do: [ :supertype |          erlangCode := erlangCode, separator, (self nounAsCamelCase: supertype) uncapitalized.           separator := comma. "Remaining attributes will be separated by a comma."         ].   erlangCode := erlangCode, ' }  ).' .   ^erlangCode.   </pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateErlangForInstruction:</h3><pre>generateErlangForInstruction: aHumInstructionLine    "Generate self-call or RPC for given instruction."   | role statement comment erlangCode cr indent quote statementAtom |   role := aHumInstructionLine role.   statement := aHumInstructionLine statement.   comment := aHumInstructionLine comment.   erlangCode := ReadWriteStream on: ''.   cr := String cr.   indent := '  '.   quote := $' asString.   statementAtom := quote, statement source, quote.   "Insert comment, if any, before the Erlang translation of the statement."   (comment &gt; ' ')       ifTrue: [ erlangCode &lt;&lt;  indent &lt;&lt; '% ' &lt;&lt; comment &lt;&lt; cr ].    "If a role-label is present, the action is delegated to another role; otherwise calling self."   (role &gt; ' ')      ifTrue: [ | rpc |           rpc := self generateErlangForActionCall: aHumInstructionLine source.          erlangCode &lt;&lt; indent &lt;&lt; rpc.         ]      ifFalse: [ erlangCode &lt;&lt; indent &lt;&lt; (self generateErlangForSelfCall: statement source) &lt;&lt; cr].   ^erlangCode contents.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateErlangForPlanFrame:</h3><pre>generateErlangForPlanFrame: aHumFrame4Plan    "Translate the plan frame into an Erlang data structure.   planFrame = { goal, [ precondition, precondition ] , [ action, action ] }   "   | erlangCode goalStatement quote indent comma |   quote := $' asString.   comma := ', '.   indent := '  '.   erlangCode := 'planFrame = { '.  "Start tuple."   goalStatement := aHumFrame4Plan goal source.   erlangCode := erlangCode, quote, goalStatement, quote, comma. "Goal-statement is first element of tuple"   erlangCode := erlangCode, String cr, indent, ' [  '.  "Start list of preconditions."   aHumFrame4Plan preconditions do: [  :precondition |      erlangCode := erlangCode, String cr, indent, quote, precondition source, quote.      indent := '  , '.       ].   indent := '  '.   erlangCode := erlangCode, String cr, indent, ' ], '.  "End list of preconditions."   erlangCode := erlangCode, String cr, indent, ' ['.  "Start list of actions."   aHumFrame4Plan planActions do: [  :action |      erlangCode := erlangCode, String cr, indent, quote, action source, quote.      indent := '  , '.  "Separate list items with a comma."       ].   indent := '  '.   erlangCode := erlangCode, String cr, indent, ' ] '. "End list of actions."   erlangCode := erlangCode, String cr,  ' }'.      ^erlangCode.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateErlangForRole:</h3><pre>generateErlangForRole: aRoleName   "Generate Erlang code for the given role-name."   | moduleDeclarationCode moduleLogicCode cr actionStatements quote |   "Generate the module`s declarations."   cr := String cr.   quote := $' asString.   moduleDeclarationCode := ReadWriteStream on: ''.   moduleDeclarationCode &lt;&lt; '-module(' &lt;&lt; aRoleName &lt;&lt; ').' &lt;&lt; cr.   moduleDeclarationCode &lt;&lt; '-export([do/1]).' &lt;&lt; cr.   moduleDeclarationCode &lt;&lt; '-define( CALL( Role, Statement, NounValues ), ?TBD( Role, Statement, NounValues ).' &lt;&lt; cr.   "TODO: Define TBD string (see above) - Call is routed to appropriate Hum Dispatcher via Hum Messenger."   "Following causes compiler to show macro expansion. "   moduleDeclarationCode &lt;&lt; '-compile:file( File, [' &lt;&lt;quote &lt;&lt; 'P' &lt;&lt; quote &lt;&lt; ']).' &lt;&lt; cr.      "Generate the logic for each action frame."   moduleLogicCode := ReadWriteStream on: ''.   actionStatements := self ontology actionsOf: aRoleName.   self assert: (actionStatements size &gt; 0).   actionStatements       do: [ :actionStatement |          | actionHeader frame frameLines |         actionHeader := self generateErlangForActionHeader: actionStatement source.         moduleLogicCode &lt;&lt; actionHeader.         frame := self ontology getFrameForRole: aRoleName capitalized  action: actionStatement.         frameLines := frame frameLines.         self assert: (frameLines size &gt; 0).         frameLines do: [ :frameLine |                 | erlangInstruction |               erlangInstruction := self generateErlangForInstruction: frameLine. "Already contains needed cr."               moduleLogicCode &lt;&lt; erlangInstruction.               ].         moduleLogicCode &lt;&lt; '  okay.' &lt;&lt; cr &lt;&lt; cr.   "Final line of function -- returns okay."         ].      ^moduleDeclarationCode contents, moduleLogicCode contents.      </pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateErlangForRoles</h3><pre>generateErlangForRoles   "Generate a Erlang module file for each Hum role."</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateErlangForSelfCall:</h3><pre>generateErlangForSelfCall: aString   "Translate a Hum Self call into an Erlang self call."   | erlang statementString nounValues quote |   self assert: (aString isKindOf: String).   self assert: ( '*:*' match: aString ) not.   statementString := aString trimBoth.   [ statementString beginsWith: '. ']       whileTrue: [ statementString := statementString copyFrom: 3 to: (statementString size) ].   "TODO: HumStatement knows how to parse better than above. It knows about comments and annotations."   nounValues := self generateErlangNounValuesForStatement: statementString.   quote := $' asString.   erlang := 'do( { ', quote, statementString, quote, ', [ ', nounValues, ' ] } ),'.   ^erlang   </pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateErlangNounValuesForStatement:</h3><pre>generateErlangNounValuesForStatement: aStatementString   |  statementNouns nounValueTuples firstNoun quote |   "Get statement nouns."   statementNouns := self ontology nounsInStatement: aStatementString.   self assert: ( statementNouns size &gt; 0 ).    quote := $' asString.   nounValueTuples := ReadWriteStream on: ''.   firstNoun := true.   statementNouns do: [ :noun |      (firstNoun) ifFalse: [ nounValueTuples &lt;&lt; ', ' ].  "After the first noun, we need a comma separator."      firstNoun := false.      nounValueTuples &lt;&lt; '{' &lt;&lt; quote &lt;&lt; noun &lt;&lt; quote.      nounValueTuples &lt;&lt; ', ' &lt;&lt; ( (self ontology nounAsCamelCase: noun ) capitalized ) &lt;&lt; '}'.      ].      ^ nounValueTuples contents.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateHTMLforMarkupLines:blackboard:</h3><pre>generateHTMLforMarkupLines: aListOfFrameLines blackboard: aBlackboard   "Build HTML for the given list of frame-lines"   |  remainder calc source translator2 cr |   cr := String cr.   calc := HumCalculator new.   "My code produces side-effect in instance-variable 'html', (shame on me)    so I need another instance as helper.   TODO: Refactor this generator to make it properly recursive without side-effects.   "   translator2 := HumOntologyTranslator new.      aListOfFrameLines      do: [:frameLine |          source := frameLine source.         calc cases; "Start case block"            when: [source = '']             then:["blank line indicates paragraph break"                    self genHTML: '&lt;br/&gt;'                   ];             when: [source beginsWith: '!']             then: [ "Generate heading"                     | level n |                     level := self countLeading: '!' inString: source.                     remainder := source copyFrom: level+1 to: source size.                     n := level asString.                     self genHTML: '&lt;h',n,'&gt;'                                 , ([translator2 generateHTMLforMarkupString: remainder blackboard: aBlackboard.                                      translator2 html contents.] value)                                 , '&lt;/h',n,'&gt;',cr.                     ];             when: [source beginsWith: '-']             then: [ "Generate list item. Let CSS do the indent."                     | level n |                     level := self countLeading: '-' inString: source.                     remainder := source copyFrom: level+1 to: source size.                     n := level asString.                     self genHTML: '&lt;item',n,'&gt; &bull; '                                 , ([translator2 generateHTMLforMarkupString: remainder blackboard: aBlackboard.                                      translator2 html contents.] value)                                 , '&lt;/item',n,'&gt;'.                     ];            when: [ source beginsWith: '|']            then: [ | columns |                     columns := source findTokens: '|'.                     self genHTML: '&lt;tr&gt;'.                       columns do: [:column |                          translator2 := HumOntologyTranslator ontology: (self ontology).                          translator2 generateHTMLforMarkupString: column blackboard: aBlackboard.                          self genHTML: '&lt;td&gt;',(translator2 html contents),'&lt;/td&gt;'.                          ].                     self genHTML: '&lt;/tr&gt;'.                   ];                  otherwise: [               remainder := self generateHTMLforMarkupString: source blackboard: aBlackboard.                "There should be no remainder"               self assert: (remainder = '').               ].         ].    ^self html contents.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateHTMLforMarkupString:blackboard:</h3><pre>generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard   "Build output until we see a substring matching aStopString."   "When we need to recurse,      we pass the remainder of line.   WARNING: Results are appended to 'html' instance-variable.   "   |  remainder |   remainder := aMarkupString.       "Emphasis patterns.  (bold, italic, underline, superscript)"   remainder := self when: remainder matchesPattern: '*1*' produce: [:x | self genHTML: '&lt;b&gt;',x,'&lt;/b&gt;'].   remainder := self when: remainder matchesPattern: '~1~' produce: [:x | self genHTML: '&lt;i&gt;',x,'&lt;/i&gt;'].   remainder := self when: remainder matchesPattern: '_1_' produce: [:x | self genHTML: '&lt;u&gt;',x,'&lt;/u&gt;'].   remainder := self when: remainder matchesPattern: '^1^' produce: [:x | self genHTML: '&lt;sup&gt;',x,'&lt;/sup&gt;'].   "Hypertext"   remainder := self when: remainder matchesPattern: '[link:1|2]'                   produce: [:x :url |  self genHTML: '&lt;a href="',url trimBoth,'"&gt;',x trimBoth,'&lt;/a&gt;'].   remainder := self when: remainder matchesPattern: '[image:1|2]'                   produce: [:x :url |  self genHTML: '&lt;img src="',url trimBoth,'" alt="',x trimBoth,'"/&gt;'].      remainder := self when: remainder matchesPattern: '[page:1]'                         produce: [:x |                            | filename |                           filename := (x asCamelCase),'.html'.   "Should work in most file systems"                           self genHTML: '&lt;a href="',filename,'"&gt;',x,'&lt;/a&gt;'].      "Delegate to another pane."   remainder := self when: remainder matchesPattern: '[pane:1]'                         produce: [:x |                            (ontology isViewName: x)                               ifFalse: [ self humParserError: ('Expected view name but found: ', x)  inCodeFragment: remainder]                              ifTrue: [ | frame frameLines |                                 frame := ontology fetchFrameByName: x.                                 frameLines := frame frameLines.                                 self generateHTMLforMarkupLines: frameLines blackboard: aBlackBoard.                                 ].                               ].   "Button"   "Treat button as a special case?"   remainder := self when: remainder matchesPattern: '[[1]]'                   produce: [ :x |                              | buttonLabel buttonType |                             buttonLabel := x trimBoth.                             buttonType := buttonLabel asLowercase.                           ( #('submit' 'reset' ) includes: (buttonType) ) ifFalse: [buttonType := 'button'].                                   self genHTML: '&lt;button name="',buttonLabel,'" type="',buttonType,'"&gt;',buttonLabel,'&lt;/button&gt;'.                            ].      "Radio Button or Comment"   remainder := self when: remainder matchesPattern: '(1)'                     produce: [:x |                            "Is a radio button intended?"                           (x size = 1 )                               ifTrue: [ self genHTML: '&lt;input name="',x,'" type="radio"/&gt;']                             ifFalse: [ "Parse the interior of the comment -- It might contain links, etc."                                self genHTML: (self generateHTMLforMarkupString: x blackboard: aBlackBoard).                                   ]                           ].   "Input widgets"   "TODO: When view is invoked with 'Show:' rather than 'Ask:', the input fields should be disabled."   remainder := self when: remainder matchesPattern: '[1`s 2]'  "[entity`s attribute]"                        produce: [:entity :attribute |                            ( ontology isAttribute: attribute )                              ifFalse: [ self humParserError: ('Expected attribute name but found: ', attribute) inCodeFragment: remainder]                              ifTrue: [| value |                                 value := aBlackBoard getEntityName: entity attribute: attribute.                                 self genHTML: '&lt;input type="text" name="', entity,':',attribute,                                                '" value="',(value ifNil: ''),'"/&gt;'.                                 "TODO: Adapt input to datatype."                                  ].                           ].      remainder := self when: remainder matchesPattern: '[1 2]'   "text widget"                        produce: [:textAttribute :rows |                            ( ontology isAttribute: textAttribute )                              ifFalse: [ self humParserError: 'Expected attribute name but found: ', textAttribute ]                              ifTrue: [| value |                                 value := aBlackBoard getEntityName: contextEntity attribute: textAttribute.                                 self genHTML: '&lt;textarea type="text" name="', textAttribute,'" rows="',rows,'"&gt;'                                            ,(value ifNil: ['']),'&lt;/textarea&gt;'.                                  ].                           ].                           remainder := self when: remainder matchesPattern: '[1]'    "attribute widget"                         produce: [:attribute |                            "Catch checkbox case"                           ( attribute size = 1 )                              ifTrue:["Generate checkbox widget."                                 self genHTML: '&lt;input type="checkbox" name="', attribute,'"/&gt;'.                                 ]                     ifFalse: ["Generate attribute input widget."                        ( ontology isAttribute: attribute )                                  ifFalse: [ self humParserError: ('Expected attribute name but found: ', attribute) inCodeFragment: remainder ]                                  ifTrue: [| value |                                      value := (aBlackBoard getEntityName: contextEntity attribute: attribute) ifNil: [''].                                     self genHTML: '&lt;input type="text" name="', contextEntity,':',attribute, '" value="',value,'"/&gt;'.                                     "TODO: Adapt input to datatype.                                      . Category should be drop-down or small radio group.                                    . Measure should be number plus drop-down.                                    . Date should be . . .                                    . Money should be . . .                                    . Duration should be . . .                                     "                                      ].                       ].                           ].         "table row -- Should be implemented elsewhere."   self assert: ( remainder beginsWith: '|' ) not.  "Just ordinary text."  ( (remainder findTokens: '*~_^[]|()' keep: '*~_^[]|()') size &lt;= 1 )      ifTrue: [ "Consume remainder"         self genHTML: remainder.         ^remainder := ''.                  ].  "Recurse"   self assert: (remainder beginsWith: ']' ) not.   ^self generateHTMLforMarkupString: remainder blackboard: aBlackBoard.   </pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateHTMLforViewFrame:blackboard:</h3><pre>generateHTMLforViewFrame: aHumFrame4View blackboard: aHumBlackBoard    "Wrap viewframe lines with  HTML form and submit logic."   | calc formHTML innerHTML formAttributes |   "Translate the Hum markup"   self contextEntity: aHumFrame4View entity.   innerHTML := self generateHTMLforMarkupLines: (aHumFrame4View frameLines) blackboard: aHumBlackBoard.   "Add a submit button"   innerHTML := innerHTML, String cr, ' &lt;input type="submit" value="Go!"   style="color:WHITE; background:GREEN"/&gt;'.   "The user might not be ready to fill-in-the-blanks. Give user a way to decline."   innerHTML := innerHTML, String cr, ' &lt;input type="submit" value="NoGo!" style="color:WHITE; background:RED"/&gt;'.   "TODO: The Scribe must interpret 'Go!' versus 'NoGo!' -- to invoke appropriate dialog vignette."   "Wrap in a form."   formAttributes := Dictionary new.   formAttributes      at: 'id'     put: aHumFrame4View title;      at: 'action' put: aHumFrame4View title;      at: 'method' put: 'POST';      at: 'enctype' put: 'application/x-www-form-urlencoded'; "Is this really needed? Is is correct for my intent?"      at: 'class' put: 'Ask'.   calc := HumCalculator new.   formHTML := calc xml: 'form' dictionary: formAttributes with: innerHTML.   ^formHTML.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateJavaCallForFrameLine:</h3><pre>generateJavaCallForFrameLine: aHumInstructionLine    | instructionCode statementCode roleCode commentCode cr documentation tab indentation  |   self assert: (aHumInstructionLine isKindOf: HumInstructionLine).
self halt.   roleCode := 'this'.   commentCode := ''.   cr := String cr.   "space := Character space asString."   tab := Character tab asString.   indentation := (1 to: (aHumInstructionLine indent)) inject: '' into: [:s :next | s, tab ].    documentation := '/** ', (aHumInstructionLine source ), ' */', cr.   statementCode := self generateJavaCallForStatement: (aHumInstructionLine statement ).   "Generate optional code if role or comment is present."   aHumInstructionLine onRole: [ roleCode := ' a', (aHumInstructionLine role capitalized) ].   aHumInstructionLine onComment: [ commentCode := ('/* ', (aHumInstructionLine comment ), ' */'). ].   "Generate Java code -- depending on type of statement."   (aHumInstructionLine statement isConditional ) "Does the statement begin with For/If/Else ???"      ifTrue: [ instructionCode := indentation, documentation, indentation, statementCode, commentCode. ]      ifFalse: [instructionCode := indentation, documentation, indentation, roleCode,'.', statementCode, '; ', commentCode. ].   ^instructionCode.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateJavaCallForStatement:</h3><pre>generateJavaCallForStatement: aHumStatement    | nouns code comma space parend |   code := ''.   space := ' '.   comma := ','.   parend := ' )'.   code := code, (aHumStatement asCamelCaseWithOntology: ontology),'('.   nouns := ontology nounsInStatement: aHumStatement.   nouns      do: [ :aNoun |             | javaNoun |            javaNoun := aHumStatement nounAsCamelCase: aNoun.            code := code, space, 'a', javaNoun capitalized, comma.            ].   code := code, parend.   ( code endsWith: (comma, parend ) )       ifTrue: [ code := (code copyFrom: 1 to: (code findString: (comma, parend))-1), parend ].   self assert: ( code endsWith: parend ).   self assert: (( code endsWith: (comma, parend) ) not).            self assert: ( '*, )*' match: code ) not.   ^code.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateJavaConditionalForStatement:</h3><pre>generateJavaConditionalForStatement: aHumStatement    | code source |   code := ''.   source := aHumStatement source.   (source beginsWith: 'For ' )      ifTrue: [ code := self generateJavaIterationForStatement: aHumStatement ].   ( source beginsWith: 'If ')      ifTrue: [ code := self generateJavaIfForStatement: aHumStatement ].   ( source beginsWith: 'Else:')      ifTrue: [ code := self generateJavaElseForStatement: aHumStatement ].         self assert: ( code = '' ) not.   ^code.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateJavaForFrame:</h3><pre>generateJavaForFrame: aHumFrame4Action    "Translate frame to Java using the nouns given in the ontology."   | selectorCode frameCode cr indentation priorIndent space tab javaDoc |   cr := String cr.   space := $   asString.   tab := String tab.   indentation := tab.   javaDoc := '/** ', aHumFrame4Action actionStatement asString,' */'.   selectorCode := self generateJavaMethodDeclarationForStatement: aHumFrame4Action actionStatement.   frameCode := ''.   priorIndent := 0.   ( aHumFrame4Action frameLines )       do: [ :frameLine |         (frameLine indent &lt; priorIndent )             ifTrue: [ "Insert a block-end bracket with appropriate indent."               indentation := (1 to: priorIndent) inject: '' into: [:s :next | s, tab ].                frameCode := frameCode, cr, indentation, '}'.            ].         frameCode := frameCode, cr, (self generateJavaForFrameLine: frameLine).         "TODO: Translate if/else/for"         priorIndent := frameLine indent.         ].   ^ javaDoc, cr, selectorCode, space, '{', frameCode, cr, '}' .</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateJavaForFrameLine:</h3><pre>generateJavaForFrameLine: aHumInstructionLine    | instructionCode statementCode roleCode commentCode cr documentation tab indentation  |   roleCode := 'this'.   commentCode := ''.   cr := String cr.   "space := Character space asString."   tab := Character tab asString.   indentation := (1 to: (aHumInstructionLine indent)) inject: '' into: [:s :next | s, tab ].    documentation := '/** ', (aHumInstructionLine source ), ' */', cr.   statementCode := self generateJavaForStatement: (aHumInstructionLine statement ).   "Generate optional code if role or comment is present."   aHumInstructionLine onRole: [ roleCode := ' a', (aHumInstructionLine role capitalized) ].   aHumInstructionLine onComment: [ commentCode := ('/* ', (aHumInstructionLine comment ), ' */'). ].   "Generate Java code -- depending on type of statement."   (aHumInstructionLine statement isConditional ) "Does the statement begin with For/If/Else ???"      ifTrue: [ instructionCode := indentation, documentation, indentation, statementCode, commentCode. ]      ifFalse: [instructionCode := indentation, documentation, indentation, roleCode,'.', statementCode, '; ', commentCode. ].   ^instructionCode.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateJavaForPlanFrame:</h3><pre>generateJavaForPlanFrame: aHumFrame4Plan    "The plan is data, so translation involves translating each goal frame into a series of Java setters.   /* prologue */   public HumPlan plan = new HumPlan();   public HumPlanFrame frame = new HumPlanFrame();   /* for each goal frame in the ontology */   frame.setGoal('...')      .addPrecondition('...')      .addPrecondition('...')      .addAction('...');   plan.addGoalFrame(frame);      "   | javaCode goalStatement indent |   javaCode := String new.   indent := '  '.   goalStatement := aHumFrame4Plan goal source.   javaCode := indent, 'planFrame.setGoal("', goalStatement, '")'.   aHumFrame4Plan preconditions do: [  :precondition |      javaCode := javaCode, String cr, indent, indent, '.addPrecondition("', precondition source, '")'].   aHumFrame4Plan planActions do: [  :action |      javaCode := javaCode, String cr, indent, indent, '.addAction("', action source, '")' ].   ^javaCode.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateJavaForStatement:</h3><pre>generateJavaForStatement: aHumStatement    | code  |   "TODO -- This will fail if there is a comment appended to the statement."   ( aHumStatement isConditional )       ifTrue: [ code := self generateJavaConditionalForStatement: aHumStatement ]      ifFalse: [code := self generateJavaCallForStatement: aHumStatement . ].         ^code</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateJavaIterationForStatement:</h3><pre>generateJavaIterationForStatement: aHumStatement    "Given a Hum for-statement, generate a Java for-statement."   | code |   "TODO: Refactor this to use a template. (Should be cleaner code.)"   aHumStatement onMatch:  'For each 1 in the 2:' do: [ :item :container |   code := 'for ( ', (aHumStatement nounAsCamelCase: item) capitalized            , ' ', (aHumStatement nounAsCamelCase: item)                  , ' : ', (aHumStatement nounAsCamelCase: container ),'.',(aHumStatement nounAsCamelCase: item),'s'                  , ' )  {' ].   ^code.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateJavaMethodDeclarationForStatement:</h3><pre>generateJavaMethodDeclarationForStatement: aHumStatement    | nouns code comma space parend |   code := ''.   space := ' '.   comma := ', '.   parend := ' )'.   code := code,'public void ', (aHumStatement asCamelCaseWithOntology: ontology),'( '.   nouns := ontology nounsInStatement: aHumStatement.   nouns      do: [ :aNoun |          | javaNoun |         javaNoun := aHumStatement nounAsCamelCase: aNoun.         code := code, javaNoun capitalized , space, 'a', javaNoun capitalized, comma.         ].   code := code, parend.   ( code endsWith: (comma, parend ) )       ifTrue: [ code := (code copyFrom: 1 to: (code findString: (comma, parend))-1), parend ].   self assert: ( code endsWith: parend ).   self assert: (( code endsWith: (comma, parend) ) not).            self assert: ( '*, )*' match: code ) not.   ^code.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateJavaScriptAngularReadMe</h3><pre>generateJavaScriptAngularReadMe   "Angular is a JavaScript user interface framework."   "Angular-Bootstrap simplifies the programming of layouts and rich interface effects."   self shouldNotImplement.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateSeasideForView:</h3><pre>generateSeasideForView: aHumFrame4View    "Implement the view frame via Seaside components.   This is a code generator.   "   | tab cr frameCode |      self moveCodeGenerator.      cr := String cr.   tab := String tab.   frameCode := String new.   frameCode := frameCode, tab, 'html form with: [ ', cr.   aHumFrame4View frameLines      do: [ :line |         | lineCode |         "Generate Seaside code for each line in the view frame"         lineCode := self generateSeasideForViewMarkup: line.         frameCode := frameCode, tab, tab, lineCode, cr.         "TODO: SUSPECT THERE SHOULD BE A COMMA IN GENERATED CODE ABOVE."         ].   frameCode := frameCode, tab, tab,  ']', cr.   ^frameCode.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateSeasideForViewMarkup:</h3><pre>generateSeasideForViewMarkup: aHumMarkupLine    "Generate Seaside code to implement a view mark-up line."   | lineCode  fieldName source|      self moveCodeGenerator.   "Parse into tokens"   source := aHumMarkupLine source.   lineCode := String new.   lineCode := lineCode, 'html break. '.   "Generate for heading"   (source beginsWith: '!' )       ifTrue: [ lineCode := lineCode, (self generateSeasideHeadingFor: source )].       "Generate input fields."   fieldName := ( HumCalculator given: source extractBetween: '[' and: ']' ).   fieldName ifNotNil: [ lineCode := lineCode, (self generateSeasideWidgetForField: fieldName )].      ^lineCode. </pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateSeasideHeadingFor:</h3><pre>generateSeasideHeadingFor: source   "Generate Seaside heading code for the given heading line."   | headingString end outlineCode  quote period|         self moveCodeGenerator.   self assert: (source beginsWith: '!' ).   quote := $' asString.   period := $. asString.   headingString := source.    end := headingString size.                                       (source beginsWith: '!' )       ifTrue: [ outlineCode := 'html heading level: 1; with: ',                                 quote, (headingString copyFrom: 1+1 to: end), quote, period. ].   (source beginsWith: '!!' )       ifTrue: [ outlineCode := 'html heading level: 2; with: ',                                 quote, (headingString copyFrom: 2+1 to: end), quote, period. ].   (source beginsWith: '!!!' )       ifTrue: [ outlineCode := 'html heading level: 3; with: ',                                 quote, (headingString copyFrom: 3+1 to: end), quote, period. ].   (source beginsWith: '!!!!' )       ifTrue: [ outlineCode := 'html heading level: 4; with: ',                                 quote, (headingString copyFrom: 4+1 to: end), quote, period. ].   (source beginsWith: '!!!!!' )       ifTrue: [ outlineCode := 'html heading level: 5; with: ',                                 quote, (headingString copyFrom: 5+1 to: end), quote, period. ].   ^outlineCode.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateSeasideWidgetForField:</h3><pre>generateSeasideWidgetForField: fieldName   | widgetCode commentCode semicolon period|      self moveCodeGenerator.  self assert: ( fieldName notNil ).    semicolon := $; asString.   period := $. asString.   "This is the default to cover when we fall through the cases."   commentCode := ' "*** Widget not handled [', fieldName,'] ***" '.   "Does widget contain a colon. If not, we have a simple attribute."   ( fieldName includesSubString: ':' )       ifFalse: [                commentCode := '"*** Update attribute [',fieldName,'] ***"'.               widgetCode := 'html textInput'                 ,' callback: [:datum | self blackBoard setEntityID: entityID attribute: #', fieldName                  ,' toValue: datum ]'                 , semicolon                 ,' name: ', (fieldName surroundedBySingleQuotes)                 , semicolon                 ,' value: ',(fieldName surroundedBySingleQuotes)                  , period.                ( fieldName size = 1 )  "Over-ride and invoke a Seaside checkbox instead."                  ifTrue: [ commentCode := '"*** TODO: Generate code for check-box: [',fieldName,'] ***' ].                  ].   "TODO: REFACTOR above so that it is more sensitive to the attribute`s data-type.    Text should render as text-area.   A category should render as a select or radio group.   A date-time as a date-picker.   A set or list should render as a table.   Perhaps a measure should render as text (validated to numeric) plus a select (of unit-of-measure).   "   ( fieldName beginsWith: 'page:')      ifTrue: [ | pageName | "[page: local page reference]"               pageName := ( HumCalculator given: fieldName extractAfter: 'page:' ).               commentCode := ' "*** Generate code for page: ', pageName ,'****" '.               widgetCode := widgetCode, 'html anchor '                                 ,'url: ', (('./',(pageName asCamelCase)) surroundedBySingleQuotes)                                 , semicolon                                 ,'with: ', (pageName surroundedBySingleQuotes )                                 , period.               ].   ( fieldName beginsWith: 'link:')      ifTrue: [  "[link: text | uri ]"            | linkName linkURL |            linkName := ( HumCalculator given: fieldName extractBetween: 'link:' and: '|' ).            linkURL := ( HumCalculator given: fieldName extractAfter: '|').            commentCode := ' "*** Generate code for link: ', linkName ,'****" '.            widgetCode := widgetCode, 'html anchor '                                 ,'url: ', ( linkURL surroundedBySingleQuotes )                                 , semicolon                                 ,'with: ', ( linkName surroundedBySingleQuotes )                                 , period.               ].   ( fieldName beginsWith: 'pane:')      ifTrue: [ | paneName | "[pane: name of a Hum view]"               paneName := ( HumCalculator given: fieldName extractAfter: 'pane:' ).               commentCode := ' "*** Generate code for pane: ', paneName, '****" '.                              widgetCode := '(self ontology fetchFrameByName: ', paneName                                 ,') asSeasideWithOntology: (self ontology)', period.               ].   "TODO: Hum panes need to be enclosed in table &lt;td&gt; or perhaps &lt;div&gt;     . . . so that they can be placed side-by-side.    . . . (The alternative using CSS {position: ABSOLUTE} is much more difficult.)   PERHAPS: We might require that the author indicate the table like this:   | [pane: left-navigation] | [pane: content] |    That would simplify the code generation,      but it leaks HTML constraints to the view code.   In any case, this code-block needs to 'call' the view-code.   "                  ^ commentCode, String cr, widgetCode.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateSeasideWidgetsForSource:</h3><pre>generateSeasideWidgetsForSource: aSourceString   "Generate Seaside calls for the widgets found in this mark-up line."   | calc between before after wip |      self moveCodeGenerator.   "*** CALLER MUST REPLACE ALL [] WITH {} BECAUSE WE GENERATE [] IN SEASIDE CODE. ***"   wip := aSourceString.      "Match button."   ( '*{{*}}*' match: wip )      ifTrue: [ calc := HumCalculator new.         between := calc given: wip extractBetween: '{{' and: '}}'.         before := calc given: wip extractUpto: '{{'.         after  := calc given: wip extractAfter: '}}'.         wip := before,'&lt;button name="',between,'" /&gt;'.         "Get all the buttons before we go on."         wip := wip, (self generateSeasideWidgetsForSource: after).         ].   "Match check-box"    ( '*{#}*' match: wip )      ifTrue: [ calc := HumCalculator new.         between := calc given: wip extractBetween: '{' and: '}'.         before := calc given: wip extractUpto: '{'.         after  := calc given: wip extractAfter: '}'.         wip := before,'&lt;input name="',between,'" type="checkbox"/&gt;'.         "Get all the check-boxes before we go on."         wip := wip, (self generateSeasideWidgetsForSource: after).         ].   "Match other widgets."   ( '*{*}*' match: wip )      ifTrue: [ calc := HumCalculator new.         between := calc given: wip extractBetween: '{' and: '}'.         before := calc given: wip extractUpto: '{'.         after  := calc given: wip extractAfter: '}'.                "Name followed by space and digit means multi-line text box"         ( between matchesRegex: '^.*\b\d$'  )            ifTrue: [ | name d |               name := calc given: between extractUpto: ' '.               d := calc given: between extractAfter: ' '.               wip := before,'&lt;textarea name="',name,'" rows=',d,' cols=60 /&gt;&lt;/textarea&gt;'.               wip := wip, (self generateSeasideWidgetsForSource: after).               ]            ifFalse: ["Not a textarea . . ."               "TODO: If the attribute-name is plural, render as a table."               | noun |               noun := between.               (ontology isPluralNoun: noun)                  ifFalse: [wip := before,'&lt;input name="',between,'" /&gt;',after.]                  ifTrue:  [wip := before, (self generateSeasideTableFor: noun ), after.].               ].         "TODO: Special handling for other types: category, date-time, measure."         ].   "Match radio-button -- TODO: THIS RADIO BUTTON STRATEGY WILL FAIL."      ( '*(#)*' match: wip )         ifTrue: [ calc := HumCalculator new.         between := calc given: wip extractBetween: '(' and: ')'.         self assert: (between size = 1).         before := calc given: wip extractUpto: '('.         after  := calc given: wip extractAfter: ')'.         "Call myself recursively"         wip := before,'&lt;input name="',between,'" type="radio"/&gt;'.         wip := wip, (self generateSeasideWidgetsForSource: after).         "TODO: Need &lt;group&gt; tags."         ].         ^wip.   </pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateSmalltalk</h3><pre>generateSmalltalk   "This is crude version.   Futures:   - Roles become classes.   - Entity-Attribute relations become class accessors.   - Noun types are one of: ( Entity Category Enumeration String Measure TimeStamp ).   - Dialogs are become method calls with blocks.   - Views are still interpreted.   "   | code |   code := ''.   ontology framesByName      keysAndValuesDo: [  :frameName :frame |         | frameCode |         frameCode := self generateSmalltalkForFrame: frame.         code := code, frameCode.         ].   ^ code.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateSmalltalkActionFor:</h3><pre>generateSmalltalkActionFor: aHumFrame4Action    "Translate frame to Smalltalk using the nouns given in the ontology."   | selectorCode frameCode priorIndent cr tab indentation |   cr := String cr.   tab := String tab.   selectorCode := self generateSmalltalkForStatement: aHumFrame4Action actionStatement.   "Translate the lines. Adding block ends when indent is reduced."   frameCode := ''.   priorIndent := 0.   aHumFrame4Action frameLines      do: [ :line |         | lineCode |         (line indent &lt; priorIndent )             ifTrue: [ "Insert a block-end bracket with appropriate indent."               indentation := (1 to: priorIndent) inject: '' into: [:s :next | s, tab ].                frameCode := frameCode, indentation, '].', cr.            ].         lineCode := self generateSmalltalkForFrameLine: line.         frameCode := frameCode, lineCode,  cr.         priorIndent := line indent.         ].   ^ selectorCode, String cr, frameCode .</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateSmalltalkForConditional:</h3><pre>generateSmalltalkForConditional: aHumStatement    | code source|   code := ''.   source := aHumStatement source.   (source beginsWith: 'For ' )      ifTrue: [ code := self generateSmalltalkIterationFor: aHumStatement ].   ( source beginsWith: 'If ')      ifTrue: [ code := self generateSmalltalkIfFor: aHumStatement ].   ( source beginsWith: 'Else:')      ifTrue: [ code := self asSmalltalkElse ].         self assert: ( code = '' ) not.   ^code.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateSmalltalkForFrame:</h3><pre>generateSmalltalkForFrame: aHumFrame   "Translate frame to Smalltalk using the nouns given in the ontology."   | frameCode |   (aHumFrame isKindOf: HumFrame4Action) ifTrue: [ ^self generateSmalltalkActionFor: aHumFrame ].   frameCode := ''.   aHumFrame frameLines      do: [ :line |         | lineCode |         lineCode := self generateSmalltalkForFrameLine: line.         frameCode := frameCode, lineCode, String cr.         ].   ^frameCode.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateSmalltalkForFrameLine:</h3><pre>generateSmalltalkForFrameLine: anInstructionLine    | instructionCode statementCode roleCode commentCode quote cr documentation tab indentation  |   self assert: (anInstructionLine isKindOf: HumInstructionLine).   roleCode := ' self'.   commentCode := ''.   quote := $" asString.   cr := String cr.   "space := Character space asString."   tab := Character tab asString.   indentation := (1 to: (anInstructionLine indent)) inject: '' into: [:s :next | s, tab ].    documentation := quote, (anInstructionLine source ), quote, cr.   statementCode := self generateSmalltalkForStatement: (anInstructionLine statement ).   anInstructionLine onRole: [ roleCode := ' a', (anInstructionLine role capitalized) ].   anInstructionLine onComment: [ commentCode := (quote, (anInstructionLine comment ), quote). ].   (anInstructionLine statement isConditional )       ifTrue: [ instructionCode := indentation, documentation, indentation, statementCode, commentCode. ]      ifFalse: [instructionCode := indentation, documentation, indentation, roleCode, ' ', statementCode, '. ', commentCode. ].   ^instructionCode.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateSmalltalkForStatement:</h3><pre>generateSmalltalkForStatement: aHumStatement    | nouns code  colon space |   "TODO -- This will fail if there is a comment appended to the statement."   ( aHumStatement isConditional )       ifTrue: [ code := self generateSmalltalkForConditional: aHumStatement.          ^code ].   code := ''.   colon := ':'.   space := ' '.   code := code, ( aHumStatement asCamelCase ), 'Q'.   nouns := ontology nounsInStatement: aHumStatement.   nouns      do: [ :aNoun |          | camelCase |         camelCase := aHumStatement nounAsCamelCase: aNoun.         code := code, camelCase, colon, space, 'a', camelCase capitalized, space.         ].         ^code</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateSmalltalkIfFor:</h3><pre>generateSmalltalkIfFor: aHumStatement    "Translate a Hum if-statement into a Smalltalk (  ) ifTrue: [] expression."   | code  statement smalltalkIf |   statement := aHumStatement.   code := ''.   "TODO: Refactor this to use a template. (Should be cleaner code.)"   "TODO: Refactor to make the operator an argument."   smalltalkIf := [:entity1 :attribute2 :entity3 :attribute4 :op |      '(  ( blackboard entity: ',(statement nounAsCamelCase: entity1 ) quoted                           , ' attribute: ',  (statement nounAsCamelCase: attribute2 ) quoted                     , ' ) ',op,' ( blackboard entity: ', (statement nounAsCamelCase: entity3 ) quoted                     , ' attribute: ', ( statement nounAsCamelCase: attribute4 ) quoted                     , ' ) )  ifTrue: ['      ].   statement onMatch: 'If 1 2 is greater than 3 4 :'            do: [ :entity1 :attribute2 :entity3 :attribute4 |               ^code := smalltalkIf valueWithArguments: { entity1. attribute2. entity3. attribute4. '&gt;'.}               ].   statement onMatch: 'If 1 2 &gt; 3 4 :'            do: [ :entity1 :attribute2 :entity3 :attribute4 |               ^code := smalltalkIf valueWithArguments: { entity1. attribute2. entity3. attribute4. '&gt;'.}               ].   statement onMatch: 'If 1 2 is less than 3 4 :'            do: [ :entity1 :attribute2 :entity3 :attribute4 |               ^code := smalltalkIf valueWithArguments: { entity1. attribute2. entity3. attribute4. '&lt;'.}               ].   statement onMatch: 'If 1 2 &lt; 3 4 :'            do: [ :entity1 :attribute2 :entity3 :attribute4 |               ^code := smalltalkIf valueWithArguments: { entity1. attribute2. entity3. attribute4. '&lt;'.}               ].   statement onMatch: 'If 1 2 = 3 4 :'            do: [ :entity1 :attribute2 :entity3 :attribute4 |               ^code := smalltalkIf valueWithArguments: { entity1. attribute2. entity3. attribute4. '='.}               ].   statement onMatch: 'If 1 2 is equal to 3 4 :'            do: [ :entity1 :attribute2 :entity3 :attribute4 |               ^code := smalltalkIf valueWithArguments: { entity1. attribute2. entity3. attribute4. '='.}               ].         self assert: ( code = '' ) not.   ^code.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateSmalltalkIterationFor:</h3><pre>generateSmalltalkIterationFor: aHumStatement    |     code statement |  statement := aHumStatement.   code := ''.   statement onMatch:  'For each 1 in the 2:'              do: [ :item :container |      code := '( self blackboard entity: ', (statement nounAsCamelCase: container) quoted                 , ' attribute: ', (statement nounAsCamelCase: item ) quoted                 , ' ) do: [ :', (statement nounAsCamelCase: item), ' | '                  , String cr                  , '     | a', (statement nounAsCamelCase: item) capitalized, ' |'                  , String cr                      , '     a', (statement nounAsCamelCase: item) capitalized, ' := ', (statement nounAsCamelCase: item), '.'      ].    "TODO: Refactor this to use a template. (Should be cleaner code.)"   ^code.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateSmalltalkOnFile:</h3><pre>generateSmalltalkOnFile: aFileName   "Open file and produce File-Out / File-In format."     "Following is template for file-out / file-in format.""@@Superclass subclass: #@@ClassName   instanceVariableNames: '@@InstanceVariables'   classVariableNames: ''   poolDictionaries: ''   category: '@@ClassCategory'!!@@ClassName commentStamp: '@@Stamp' prior: 0!@@ClassComment!!@@ClassName methodsFor: '@@MethodCategory' stamp: '@@Stamp'!@@MethodSelector   ""@@MethodComment""   | @@LocalVariables |   @@MethodCode   !!"         | code |   self shouldBeImplemented.   code := ''.   "This is crude version.   Futures:   - Roles become classes.   - Entity-Attribute relations become class accessors.   - Noun types are one of: ( Entity Category Enumeration String Measure TimeStamp ).   - Dialogs become method calls with blocks.   - Views are translated to Seaside html onRender: methods.   "   self framesByName      keysAndValuesDo: [  :frameName :frame |         | frameCode |         frameCode := frame asSmalltalkWithOntology: self.         code := code, frameCode.         ].</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; generateXamarinReadMe</h3><pre>generateXamarinReadMe   "Xamarin runs on Windows, iOS, and Android devices.  (client side)   However, some components are platform-specific."   "See XamarinHQ on YouTube for tutorials."   self shouldNotImplement.   </pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; getMethodsForClass:</h3><pre>getMethodsForClass: aClassName   "Get the methods colletion (a Dictionary) for the given Class"   | methods |   methods := ( self methodsForClasses ) at: aClassName ifAbsent: [ nil ].   methods       ifNil: [ methods := Dictionary new.                   ( self methodsForClasses ) at: aClassName put: methods.                  ].   ^methods.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; html</h3><pre>html   ^html ifNil: [html := ReadWriteStream on: ''.].</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; humParserError:inCodeFragment:</h3><pre>humParserError: aComplaint inCodeFragment: aCodeFragment   |  complaintHTML errorMessage |   "TODO: In the future, we might not want this to stop execution."   errorMessage := aComplaint, ' in {',aCodeFragment,'}'.   Error signal: errorMessage.   "Generate HTML to embed critique near problem"   complaintHTML := HumCalculator xml: 'errorNote' with: [ errorMessage ].   ^complaintHTML.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; methodsForClasses</h3><pre>methodsForClasses   ^ methodsForClasses ifNil: [ methodsForClasses := Dictionary new ].</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; moveCodeGenerator</h3><pre>moveCodeGenerator   (self isKindOf: HumOntologyTranslator)      ifFalse: [Error signal: 'Move this code generator to HumOntologyTranslator'].</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; nounAsCamelCase:</h3><pre>nounAsCamelCase: aNoun    "Generate camel-case string the the given noun."   | camelCase tokens |   camelCase := String new.   tokens := (aNoun trimBoth) findTokens: '-'.    tokens do: [  :token | camelCase := camelCase, (token asLowercase capitalized) ].   "Note: First letter is also capitalized.    Caller must decide if this is appropriate to translation."   ^camelCase.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; nounsAsJava</h3><pre>nounsAsJava   "Emit java code that implements noun relations."   "Currently this emits all classes into a single code stream.    In the future, we might want to find a way to map the stream into separate '.java' files.   "   | code entities cr tab semicolon space fnToGetSupertype |   code := ''.   cr := String cr.   tab := String tab.   semicolon := ';'.   space := String space.   "Get a list of the entities."   entities := Set new.   ( ontology entityAttributes ) do: [ :eachMap |  entities add: (eachMap key) ].   "Define a private function that determines the correct supertype for a given noun."   fnToGetSupertype := [ :noun :default |          |  typeName supertypes |         supertypes := ontology immediateSupertypesOf: noun.         ( supertypes size = 0 ) ifTrue: [ typeName := default ].         ( supertypes size &gt; 0 ) ifTrue: [ typeName :=  ( HumOntology nounAsCamelCase:  ( supertypes asSortedCollection at: 1 ) ) capitalized ].         ( supertypes size &gt; 1 ) ifTrue: [Error signal: '// WARNING: Cannot correctly translate ', noun, ' to Java because it has more than one supertype.', cr. ].         "TODO: Fix this up so that multiple inheritance is correctly handled."         "Function returns the discovered supertype or the default supertype"         typeName.      ].   "Emit a class for each entity."   ( entities asSortedCollection ) do: [ :entity |       | attributes extendsSupertype  |      "Everything extends Entity class -- which provides toHTML(), toXML(), and persistence methods (TBD)."      extendsSupertype := fnToGetSupertype value:  entity value: 'Entity'.      "TODO: If the entity has a single superclass, override the extendsSuperType value with that superclass name."      code := code, cr, 'public class ', (HumOntology nounAsCamelCase:  entity) capitalized , ' extends ', extendsSupertype, ' {', cr.      "Get the entity's attributes."      attributes := ontology immediateAttributesOfEntity: entity.      "Emit instance variable declarations for each attribute. -- Default type is String."      ( attributes asSortedCollection ) do: [ :attribute |         |  typeName |         typeName := fnToGetSupertype value: attribute value: 'String'.         ( entities include:  attribute ) ifTrue: [ typeName :=  ( HumOntology nounAsCamelCase:  attribute ) capitalized ].         "If noun is plural, make the type Bag&lt;Entity&gt;"         ( ontology isPluralNoun: attribute )             ifTrue: [                | singular |               singular := ontology singularFormOfNoun: attribute.               typeName := 'Bag&lt;',(HumOntology nounAsCamelCase: singular),'&gt;'  ].         code := code, tab, 'public ', typeName, space, ( HumOntology nounAsCamelCase: attribute), semicolon, cr.         ].      "Class ends with closing brace and a comment."      code := code, '} // Entity: ', (HumOntology nounAsCamelCase:  entity) capitalized, cr.      ].   "Comment: This demonstrates that entities can be translated to java classes.                      It also demonstrates that Hum is ~type-safe~."   ^code.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; ontology</h3><pre>ontology   ^ ontology ifNil: [ontology := HumOntology new.]</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; ontology:</h3><pre>ontology: aHumOntology    ontology := aHumOntology.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; prologues</h3><pre>prologues   ^ prologues ifNil: [ prologues := Dictionary new ].</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; rolesAsJava</h3><pre>rolesAsJava   | code cr |   code := ''.   cr := String cr.   ( ontology roles asSortedCollection   )      do: [ :role |          | actions |         code := code, cr, '/** Actor: ', role capitalized,                       cr, ' * Generated from Hum ontology: ', (ontology fromFile) asString,                       cr, ' */'.         code := code, cr, 'public class ', role capitalized, ' extends Actor { ', cr, cr.         actions := ontology actionsOf: role.                  ( actions asSortedCollection )            do: [ :actionStatement |               | frame frameCode frameName |               frameName := 'Role: ', role capitalized, ' -- ', actionStatement source.               frame := ontology fetchFrameByName: frameName.               frameCode := self generateJavaForFrame: frame.               code := code, frameCode.               ].         code := code, cr, cr, '} // Actor: ', role capitalized, cr.         ].   ^code.</pre><h3>Hum-Language -- HumOntologyTranslator &gt;&gt; when:matchesPattern:produce:</h3><pre>when: aSource matchesPattern: aPattern produce: aBlock   | patternStream sourceStream arguments remainder sourceCharacter patternCharacter s uptoMark markupCharacters |     (aSource = '') ifTrue: [ ^aSource ].   "Convertstrings to streams."   patternStream := ReadStream on: aPattern.   sourceStream := ReadStream on: aSource.      "Does source begin with markup?"   markupCharacters := '~^*_[]()|'.   uptoMark := String new.   [ sourceStream atEnd or: [ markupCharacters includes: (sourceStream peek)] ]      whileFalse:["Output ordinary text until a markup character is seen"         uptoMark := uptoMark, (sourceStream next asString).          ].   ( uptoMark size &gt; 0 )       ifTrue: [ self genHTML: uptoMark.         remainder := HumCalculator given: aSource extractAfter: uptoMark.           ^remainder.         ].  "The source must begin with a markup character."   self assert: ( markupCharacters includes: (sourceStream peek) ).      "If the pattern does not match,      return the source      so that the caller can try another pattern."   (( patternStream peek ) = ( sourceStream peek )) ifFalse: [^aSource].  "If there is a match, build the argument list."   arguments := OrderedCollection new.   [ patternStream atEnd or: [ sourceStream atEnd ]]      whileFalse: [             patternCharacter := patternStream next.            sourceCharacter := sourceStream next.            ( patternCharacter isDigit )              ifFalse: ["Compare pattern character to source character."                 "Does the pattern match the source?                   If not, return the source so that caller can try another pattern."                 ( patternCharacter = sourceCharacter ) ifFalse: [ ^aSource ].                 ]               ifTrue: ["Accumulate upto next delimiter or end"                  | nextPatternCharacter |                  nextPatternCharacter := patternStream next.                  s := String new.                  [ sourceStream atEnd or: [ sourceCharacter == nextPatternCharacter ]]                         whileFalse: [                        (markupCharacters includes: sourceCharacter) ifTrue: [^aSource].                        s := s, sourceCharacter asString.                        sourceCharacter := sourceStream next.                        ].                  arguments add: s.                  ].         ].   "If we matched, run the production block"   ( patternStream atEnd and: [arguments notEmpty] )       ifTrue: [ aBlock valueWithArguments: arguments ]      ifFalse: [^aSource].   "Return the remainder of the source."   remainder := String new.   [ sourceStream atEnd ]       whileFalse: [ remainder := remainder, (sourceStream next asString). ].  ^remainder.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; asHTML5</h3><pre>asHTML5   "Render the ontology as an HTML5 page.   . No critique.   . No base frames.   "   | html    |   html := self asHTML5withCritique: false withBase: false.   ^html</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; asHTML5withCritique</h3><pre>asHTML5withCritique   "Render the ontology as an HTML5 page.   . Include critique.   . Do not expand base frames.   "   | html    |   html := self asHTML5withCritique: true withBase: false.   ^html</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; asHTML5withCritique:withBase:</h3><pre>asHTML5withCritique: withCritique withBase: withBase   "Render the ontology as an HTML5 page.   . Since HTML is based on XML, we create XML elements.   "   | html heading   |   "Creating a fresh calculator initializes XML indent."   calc := HumCalculator new.   html := calc xml: 'html'             with: [ "Build the HTML header"                     ( calc xml: 'head'                      with: [ (calc xml: 'title'                               with: [ (ontology title) asString ]),                           self css.                           ]),                  "Build the HTML body"                     (calc xml: 'body'                     with: [ | bodyLines |                            bodyLines := ''.                           "Render the ontology fiilename, if any, as an HTML5 heading element."                           heading := calc xml: 'heading' with: [  'Ontology: ',(ontology title asString) ].                           (ontology framesByName keysSortedSafely)                               do: [ :frameName  |                                  | frame |                                 frame := ontology framesByName at: frameName.                                 "Delegate rendering of the frames to the frames."                                  bodyLines := bodyLines,                                                    ( self renderFrame: frame withCritique: withCritique withBase: withBase ).                                 "The &lt;hr/&gt; seems to be needed. I cannot figure out how to do that with CSS."                                 ] .                           heading, bodyLines, String cr, '&lt;hr/&gt;'.                           "The &lt;hr/&gt; also seems to be needed. I cannot figure out how to do that in CSS either."                           ] )                  ].   "TODO: Add plan-tree rendering.  Render plan-tree for each goal that is invoked in a vignette."   "See: renderPlanTreeForGoal: aGoal"   "TODO: Add noun-tree rendeing. Render a noun-tree for each entity."   "See: renderNounTreeForNoun: aNoun"   "TODO: Add role-dependency rendering. Render a dependency tree for each role."   "TODO: Add context-path rendering.  Render the context path diagram starting with 'Start' context. "   ^html.    </pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; asHTML5withCritiqueSkippingBaseOntology</h3><pre>asHTML5withCritiqueSkippingBaseOntology   "Render the ontology as an HTML5 page.   . Since HTML is based on XML, we create XML elements.   "   | html    |   html := self asHTML5withCritique: true  withBase: false.   ^html.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; buildDiagramForNoun:onDiagram:</h3><pre>buildDiagramForNoun: aNoun onDiagram: aDiagram   "Add the noun`s relationships to that diagram."   | attributes supertypes |   attributes := ontology immediateAttributesOfEntity: aNoun.   attributes do: [ :attribute | aDiagram addConnection:  ( aNoun -&gt; attribute ) label: #attribute ].   supertypes := ontology allSupertypesOf: aNoun.   supertypes do: [ :supertype | aDiagram addConnection: ( aNoun -&gt; supertype ) label: #supertype ].   supertypes do: [ :supertype | self buildDiagramForNoun: supertype onDiagram:  aDiagram ]      </pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; buildNounTreeForNoun:indent:</h3><pre>buildNounTreeForNoun: aNoun indent: anIndentLevel    ""   |  nounTree subTree singular supertypes properties attributes |   self assert: (anIndentLevel &lt; 5).   nounTree := OrderedCollection new.   attributes := self immediateAttributesOfEntity: aNoun.   supertypes := self allSupertypesOf: aNoun.   properties := attributes, supertypes.   (properties sorted)      do: [ :property  |         nounTree add: ( aNoun -&gt; { anIndentLevel. property.} ).         singular := self singularFormOfNoun: property.         subTree := self buildNounTreeForNoun: singular indent: (anIndentLevel + 1).         nounTree := nounTree, subTree.         "Detect a cycle in the tree."         ( nounTree anySatisfy: [ :map |  (map value at: 2) = aNoun ] )             ifTrue: [ Error signal: 'cycle detected in noun tree' ].         ].      ^nounTree.   </pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; css</h3><pre>css   "generate HTML Cascading Style Sheet (CSS) code segment"   | html  |   calc := HumCalculator new.   html := calc xml: 'style'          with: ['             body {font-family: MONOSPACE;}            heading {font-size: X-LARGE; }                     title1, title2, title3, title4, title5 {font-weight: BOLD;}            title1 {font-size: 200%;}            title2 {font-size: 150%;}            title3 {font-size: 125%;}            title4 {font-size: 100%;}            frameTitle {color: BLUE; font-size: LARGER; font-weight: BOLD;}                        n, noun {color: PURPLE;}            k, keyword {font-weight: BOLD;}            r, role {font-style: ITALIC;font-weight: BOLD;}                        statement {color: BLUE;}            c, comment {color: GREEN;}            annotation {}                        pattern {}            markup {font-family: MONOSPACE;}            widget {color: RED;}                                    HumFrame {}            frameLine, CommentLine, DictionaryLine, PreconditionLine  {margin-left: 1em;}            InstructionLine {margin-left: 1em; color: BLUE;}               InstructionLine.indent1 {margin-left: 1em;}                  InstructionLine.indent2 {margin-left: 2em;}                  InstructionLine.indent3 {margin-left: 3em;}                  InstructionLine.indent4 {margin-left: 4em;}                                 textarea {vertical-align: top;}               form {border-style: outset; padding: 1em;}            table {}            th {background: CYAN;}            td {background: LIGHTGREY;}            errorNote { color: DARKRED; }            critiqueLine { color: DARKRED; margin-left: 1em; }            commentLine { color: DARKGREEN; margin-left: 1em; }            ' ].   "TODO: Consider using class='indentN' to control indent in action frames.    That would enable multi-level indent in Action Frames.   "   ^html.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; generateCategoryPullDownFor:</h3><pre>generateCategoryPullDownFor: aNoun    "Render category noun as a pull-down selection."   | html categoryList|   categoryList := ontology categoriesOf: aNoun.   self assert: (categoryList size &gt; 0).   "Use global HumCalculator to generate XML "   html := calc xml: 'select' dictionary: { 'name'-&gt;aNoun }                        with: [ calc xml: 'option' list: (categoryList sorted) ].   ^html.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; generateHtmlTableFor:</h3><pre>generateHtmlTableFor: anEntity   "Generate a dummy table showing the attributes for this entity-name."    | singular attributes html  |   singular := ontology singularFormOfNoun: anEntity.   attributes := ontology allAttributesOfEntity: singular.   "If the entity has no attributes, generate a default table."   ( attributes size = 0 )      ifTrue: [^'&lt;table name="',anEntity,'"&gt;&lt;tr&gt;&lt;th&gt;',anEntity,' has no attributes in current ontology.&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;'].  "Otherwise generate a normal table."   html := '&lt;table name="',anEntity,'" &gt;'.   html := html, '&lt;tr&gt;'.   attributes do: [:attribute | html := html, '&lt;th&gt;', attribute, '&lt;/th&gt;'.].    html := html, '&lt;/tr&gt;'.   html := html, '&lt;tr&gt;'.   attributes do: [:attribute | html := html, '&lt;td&gt;', attribute, ' value &lt;/td&gt;'.].    html := html, '&lt;/tr&gt;'.   html := html, '&lt;/table&gt;'.   ^html.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; initialize</h3><pre>initialize   calc := HumCalculator new.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; modeStack</h3><pre>modeStack   "Stack to track list-type modes."   ^ modeStack ifNil: [ modeStack := Stack new.]</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; ontology:</h3><pre>ontology: aHumOntology    ontology := aHumOntology.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; render:onFileNamed:</h3><pre>render: asSymbol onFileNamed: aNewFile   | string file |   string := self renderAs: asSymbol.   file := StandardFileStream forceNewFileNamed: aNewFile.    file nextPutAll: string.   file close.   ^string.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderActionFrame:</h3><pre>renderActionFrame: aHumFrame4Action    "Render action frame with indentation.   --  This is a read-only view for ontology code listing."   | html  innerHTML frameLines statementIndent  titleHtml |   calc := HumCalculator new. "By-Product: Initializes XML indent"   innerHTML := ''.   statementIndent := 1.   frameLines := aHumFrame4Action frameLines.   ( frameLines reject: [:aFrameLine | |s| s := aFrameLine source. (s beginsWith: 'Action:') or: [s beginsWith: 'To:']] )      do: [ :frameLine |         | s |         s := frameLine statement source trimBoth.         "Else: reduces indent for self."         ( s asLowercase beginsWith: 'else') ifTrue: [ statementIndent := statementIndent - 1 ].         (frameLine isKindOf: HumInstructionLine) ifTrue: [ frameLine indent: statementIndent ].         innerHTML := innerHTML,'&lt;br/&gt;', String cr, (self renderFrameLine: frameLine ).         "If, Else, for-each, all increase indent."         (s endsWith: ':') ifTrue:  [ statementIndent := statementIndent + 1 ].          ].   titleHtml := calc xml: 'frameTitle' with: [  aHumFrame4Action titleLine asString ].   html := calc xml: 'ActionFrame' with: [        titleHtml,         '&lt;br/&gt;&lt;b&gt;Role: &lt;/b&gt;',         (calc xml: 'role' with: [ (aHumFrame4Action role capitalized),'.' ]),         '&lt;br/&gt;&lt;b&gt;Action: &lt;/b&gt;',         (calc xml: 'action' with: [ self renderInstruction: ( aHumFrame4Action actionStatement ) ]), innerHTML.               ].   ^html.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderActionFrame:withCritique:</h3><pre>renderActionFrame: aHumFrame4Action withCritique: aBoolean   "Render source code.    --  This is a read-only view for ontology code listing."   | html  innerHTML frameLines statementIndent  titleHtml |   calc := HumCalculator new. "By-Product: Initializes XML indent"   innerHTML := ''.   statementIndent := 1.   frameLines := aHumFrame4Action frameLines.   ( frameLines reject: [:aFrameLine | |s| s := aFrameLine source. (s beginsWith: 'Action:') or: [s beginsWith: 'To:']] )      do: [ :frameLine |         | s |         s := frameLine statement source trimBoth.         "Else: reduces indent for self."         ( s asLowercase beginsWith: 'else') ifTrue: [ statementIndent := statementIndent - 1 ].         (frameLine isKindOf: HumInstructionLine) ifTrue: [ frameLine indent: statementIndent ].         innerHTML := innerHTML,'&lt;br/&gt;', String cr, (self renderFrameLine: frameLine ).         "If, Else, for-each, all increase indent."         (s endsWith: ':') ifTrue:  [ statementIndent := statementIndent + 1 ].          ].   titleHtml := calc xml: 'frameTitle' with: [  aHumFrame4Action titleLine asString ].   html := calc xml: 'HumFrame' with: [        titleHtml,         '&lt;br/&gt;&lt;b&gt;Role: &lt;/b&gt;',         (calc xml: 'role' with: [ (aHumFrame4Action role capitalized),'.' ]),         '&lt;br/&gt;&lt;b&gt;Action: &lt;/b&gt;',         (calc xml: 'action' with: [ self renderInstruction: ( aHumFrame4Action actionStatement ) ]), innerHTML.               ].   ^html.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderActionLine:</h3><pre>renderActionLine: aHumFrameLine    | source  isRedundant |   "Tests indicate this is redundant."   isRedundant := true.   isRedundant ifTrue: [self halt.  ^' '].
      source := aHumFrameLine source.   ^ calc xml: 'titleLine' with: [source].</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderAs:</h3><pre>renderAs: aSymbol    "FUTURE: Render as X -- Currently not needed."   self shouldBeImplemented.   self assert: ( aSymbol isKindOf: Symbol ).   self log: 'Ontology: Document ontology as: ', ( aSymbol asString ).    "Call the HTML rendering code."   (aSymbol = #HTML or: [ aSymbol = #HTML5 ])      ifTrue: [ self renderAsHTMLonFileNamed: ( (self file), '.html') ]      ifFalse: [ self shouldBeImplemented ].   </pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderAsHTMLonFileNamed:</h3><pre>renderAsHTMLonFileNamed: aNewFile    "Render as HTML5 and echo on given file."   | html file  |   html := self asHTML5.   file := StandardFileStream forceNewFileNamed: aNewFile.    file nextPutAll: html.   file close.   ^html.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderAsHTMLwithCritique:withBase:onFileNamed:</h3><pre>renderAsHTMLwithCritique: withCritique withBase: withBase onFileNamed: aNewFile    "Render as HTML5 and echo on given file."   | html file  |   html := self asHTML5withCritique: withCritique withBase: withBase.    file := StandardFileStream forceNewFileNamed: aNewFile.    file nextPutAll: html.   file close.   ^html.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderAsHTMLwithCritiqueOnFileNamed:</h3><pre>renderAsHTMLwithCritiqueOnFileNamed: aNewFile    "Render as HTML5 and echo on given file."   | html file  |   html := self asHTML5withCritique: true withBase: false.    file := StandardFileStream forceNewFileNamed: aNewFile.    file nextPutAll: html.   file close.   ^html.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderCommentIn:</h3><pre>renderCommentIn: aFrameLine    "Render comment (if any) as HTML"   | html commentString |   html := ''.   commentString := aFrameLine comment.   ( commentString notEmpty)      ifTrue: ["Remove extra parentheses"         | s |         (commentString beginsWith: '(' )            ifFalse: [  s := commentString ]            ifTrue: [  s := commentString copyFrom: 2 to: (commentString size - 1) ].          html := calc xml: 'comment' with: [ '(', s, ')' ] ].    ^html.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderConditionLine:</h3><pre>renderConditionLine: aHumConditionLine     | html xmlStatement xmlComment xmlAnnotation assembly  |   "Avoid empty statement element."      xmlStatement := (aHumConditionLine statement source isEmpty )       ifTrue: ['']       ifFalse: [( calc xml: 'statement' with: [self renderInstruction: (aHumConditionLine statement) ] ) ].   "Avoid empty comment element.   Note that parends are added for Hum consistency."   xmlComment := ( aHumConditionLine comment trimBoth isEmpty )       ifTrue: ['']       ifFalse: [ self renderCommentIn: aHumConditionLine  ].   "Render the annotation."      xmlAnnotation := ( aHumConditionLine annotation trimBoth isEmpty )       ifTrue: ['']       ifFalse: [ (  calc xml: 'annotation' with: [ '[ ', (aHumConditionLine annotation), ' ]' ]   ) ].   "Assemble it without any line breaks."      assembly := xmlStatement, xmlComment, xmlAnnotation.   html := (calc xml: 'PreconditionLine' with: [ assembly ]).   "TODO: Add hyperlink to frame (if any) that has goal matching this precondition."   ^html.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderCritiqueForFrame:</h3><pre>renderCritiqueForFrame: aHumFrame    "Return (HTML5) rendering of the frame`s critique"   | html problems myCalc  |   problems := aHumFrame compileToOntology: ontology.   problems isEmpty ifTrue: [^''].   myCalc := HumCalculator new.   html := (myCalc xml: 'critiqueLine' with: [ '&lt;br/&gt;&lt;br/&gt;&lt;u style="color: DARKRED"&gt;Critique:&lt;/u&gt;' ]).   problems       do: [ :critiqueText |          html := html, (myCalc xml: 'critiqueLine' with: [ '&lt;br/&gt;&nbsp; ', critiqueText ]).          ].   ^html.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderDictionaryLine:</h3><pre>renderDictionaryLine: aHumDictionaryLine    |  |               ^ calc xml: 'DictionaryLine'          with: [            (calc xml: 'statement'                 with: [(self renderStatement: (aHumDictionaryLine statement ) keywords: #('is' 'a' 'attributes' 'include' 'categories' 'list' 'set' 'subtypes' 'abbreviation' 'shorthand' 'synonym' 'for' ) )                      , (self renderCommentIn: aHumDictionaryLine)  ]                               )              ]. </pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderFrame:withCritique:</h3><pre>renderFrame: aHumFrame  withCritique: withCritique   "Render (pretty print) source code.    --  This is a read-only view for ontology code listing."   | html |   html := self renderFrame: aHumFrame withCritique: withCritique withBase: false.   ^html.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderFrame:withCritique:withBase:</h3><pre>renderFrame: aHumFrame  withCritique: withCritique withBase: withBaseOntology   "Render (pretty print) source code.    --  This is a read-only view for ontology code listing."   | html |   html := String new.      "Abbreviate the frame if we are skipping base ontology frames."   ((withBaseOntology = false) and: [aHumFrame origin = 'BaseOntology.txt'])      ifTrue: [             "html := calc xml: 'commentLine' with: [ (aHumFrame titleLine), ' -- See base ontology.'  ]. "            ^html.          ].   "Wrap the lines with a HumFrame tag."   "Note: &lt;frame&gt; has semantics in HTML, so we use &lt;HumFrame&gt; tag instead."   html :=      calc xml: 'HumFrame'            with: [ | frameHTML titleHTML subHTML|               calc cases;                  when: [ aHumFrame isKindOf: HumFrame4Action ]                      then: [ frameHTML := self renderActionFrame: aHumFrame ];                  when: [ aHumFrame isKindOf: HumFrame4Plan ]                      then: [ frameHTML := self renderPlanFrame: aHumFrame ];                  otherwise: [ "Tag the title line."                                    titleHTML := (calc xml: 'frameTitle' with: [  aHumFrame titleLine asString ]).                                    subHTML := self renderFrameLinesIn: aHumFrame.                                    frameHTML := titleHTML, subHTML. ].               withCritique ifTrue: [ frameHTML := frameHTML, (self renderCritiqueForFrame: aHumFrame ) ].               "Return"               frameHTML.               ].   ^'&lt;hr/&gt;',String cr,html.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderFrameLine:</h3><pre>renderFrameLine: frameLine     "Dispatch frameLine to rendering specialist."   | class |   self assert: (frameLine isKindOf: HumFrameLine).   class := frameLine class.   (class = HumConditionLine ) ifTrue: [^ self renderConditionLine: frameLine ].    (class = HumDictionaryLine ) ifTrue: [^ self renderDictionaryLine: frameLine ].    (class = HumInstructionLine ) ifTrue: [^ self renderInstructionLine: frameLine ].   "(class = HumCommentLine)          ifTrue: [^ calc xml: 'commentLine' with: [ frameLine source ]]."   (class = HumCommentLine)          ifTrue: [^ self renderCommentIn: frameLine ].   (class = HumVignettePatternLine)  ifTrue: [^ calc xml: 'patternLine' with: [ frameLine source] ].    (class = HumVignetteResponseLine) ifTrue: [^ calc xml: 'responseLine' with: [ frameLine source] ].       "Under some conditions we get an ordinary frame line in Action frames."   self assert: false description: 'Something has changed. Be careful.'.   (class = HumFrameLine and: [frameLine source sameAs: ' ']) ifTrue: [^' ' ].   (class = HumFrameLine and: [frameLine source beginsWith: 'Role:']) ifTrue: [^self renderActionLine: frameLine ].   (class = HumFrameLine and: [frameLine source beginsWith: 'Action:']) ifTrue: [^self renderActionLine: frameLine ].   (class = HumFrameLine and: [frameLine source beginsWith: 'To:']) ifTrue: [^self renderActionLine: frameLine ].      Error signal: 'FrameLine  subclass not handled: ', (class asString).</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderFrameLinesIn:</h3><pre>renderFrameLinesIn: aHumFrame    "Iterate throught the frame lines"    | html cr class |   "View frames are rendered as HTML forms with widgets."   class := aHumFrame class.   (class = HumFrame4View ) ifTrue: [^ self renderView: aHumFrame ].   "Plan frames are rendered with Precondition and Action sections"   (class = HumFrame4Plan ) ifTrue: [^ self renderPlanFrame: aHumFrame ].   "Action frames are rendered with Role: and Action: labels."   (class = HumFrame4Action ) ifTrue: [^ self renderActionFrame: aHumFrame ].      "Other frame types are just pretty-printed?"   cr := String cr.   html := cr.   aHumFrame frameLines       do: [ :frameLine |            html := html, '&lt;br/&gt;', ( self renderFrameLine: frameLine  ) ].   ^html.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderInstruction:</h3><pre>renderInstruction: aHumStatement   "Pretty-print statement as HTML"   | triggerWords keywords |   triggerWords := 'if else for-each for' findTokens: ' '.    keywords := #('giving').   ^self renderStatement: aHumStatement triggerWords: triggerWords keywords: keywords.    </pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderInstructionLine:</h3><pre>renderInstructionLine: aHumInstructionLine     "Pretty-print using HTML5 tags and CSS."   | html xmlRole xmlStatement xmlComment xmlAnnotation assembly  attr |   "Avoid an empty role element.   Note that colon may be  inserted for HTML readability."   xmlRole :=  ( aHumInstructionLine role sameAs: '' )        ifTrue: ['']       ifFalse: [ (( calc xml: 'role' with: [ (aHumInstructionLine role) ] ), ':' )].   "Avoid empty statement element."      xmlStatement := (aHumInstructionLine statement source isEmpty )       ifTrue: ['']       ifFalse: [( calc xml: 'statement' with: [self renderInstruction: (aHumInstructionLine statement)  ] ) ].   "Avoid empty comment element.   Note that parends are added for Hum consistency."   xmlComment := ( aHumInstructionLine comment trimBoth isEmpty )       ifTrue: ['']       ifFalse: [ self renderCommentIn: aHumInstructionLine ].   "Render the annotation."      xmlAnnotation := ( aHumInstructionLine annotation trimBoth isEmpty )       ifTrue: ['']       ifFalse: [ (  calc xml: 'annotation' with: [ ' [ ', (aHumInstructionLine annotation), ' ]' ]   ) ].   "Assemble it without any line breaks."      assembly := xmlRole, xmlStatement, xmlComment, xmlAnnotation.   attr := (Dictionary new) at: 'class' put: ('indent',(aHumInstructionLine indent asString)); yourself.   html := (calc xml: 'InstructionLine' dictionary: attr with: [ assembly ]).   ^html.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderMarkupAsHTML5:</h3><pre>renderMarkupAsHTML5: markupSource   "Render the given mark-up text as HTML headings, lists, emphasis."   "TODO: REFACTOR this with call to HumOntologyTranslator."    | html heading marker remainder level aString |   self assert: (markupSource isKindOf: String ).   "Maintain spacing."   aString := calc given: markupSource replaceAll: '  ' with: '&nbsp;&nbsp;'.      "Is this markup line a heading?"   heading := 'none'.   (1 to: 5)      do: [ :i |         marker := '!!!!!' copyFrom: 1 to: i.         ( aString beginsWith: marker )             ifTrue: [ "Set the heading type and extract the remainder."               heading := 'title', (marker size) asString.                remainder := (calc given: aString extractAfter: marker ) ].          ].   "If this is a heading, render the whole line as a heading. "      "Call self recursively to catch any additional emphasis (e.g. italics)"   ( heading = 'none'   ) ifFalse: [ ^html := calc xml: heading with: (self renderMarkupAsHTML5: remainder).].   "Is this markup line a bullet/numbered list item."      #( '-----' '#####')      do: [ :leaderType |            level := 0.      (1 to: 5 )         do: [ :i |            marker := leaderType copyFrom: 1 to: i.            ( aString beginsWith: marker )                ifTrue: [ "Set the heading type and extract the remainder."                  level := (marker size).                   remainder := (calc given: aString extractAfter: marker ) ].             ].      ( level &gt; 0 )         ifTrue: [            html := ''.            ( (lastLevel isNil ) or: [ level &gt; lastLevel ] )                ifTrue:[                   (marker beginsWith: '-') ifTrue: [ self modeStack push: 'ul'].                  (marker beginsWith: '#') ifTrue: [ self modeStack push: 'ol'].                  html := '&lt;',(self modeStack top),'&gt;'.                  ].            "TODO: Figure out how to emit '&lt;/ul&gt;' and '&lt;/ol&gt;.' -- Might need MODES. (heavens)"            ( (lastLevel notNil ) and: [ level &lt; lastLevel ] )                ifTrue:[                   html := '&lt;/',(self modeStack top),'&gt;'.                   ].            lastLevel := level.            html := html, (calc xml: 'li' with: (self renderMarkupAsHTML5: remainder )).            ^html.               ].         ].      "None of the above"   "Delegate emphasis"   html := self renderMarkupEmphasisAsHTML5: aString.   html := self renderWidgetsInMarkup: html.   ^html.         </pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderMarkupEmphasisAsHTML5:</h3><pre>renderMarkupEmphasisAsHTML5: aString    "Render bold, italic, underscore emphasis."   "REFACTOR: THIS FUNCTIONALITY BELONGS IN HumOntologyTranslator."   | wip between before after |  self assert: ( aString isKindOf: String ).   (( aString includes: $*) or: [ (aString includes: $~) or: [ aString includes: $_]])      ifFalse: [^aString].   "Initialize work-in-progress."   wip := aString.   ('*_*_*' match: wip )      ifTrue: [ "become *&lt;u&gt;*&lt;/u&gt;*"         between := calc given: wip extractBetween: '_' and: '_'.          before  := calc given: wip extractUpto: '_'.         after   := calc given: wip extractAfterSecond: '_'.         wip := before, '&lt;u&gt;', between, '&lt;/u&gt;', after.         ].   ('*~*~*' match: wip )      ifTrue: [ "become *&lt;i&gt;*&lt;/i&gt;*"         between := calc given: wip extractBetween: '~' and: '~'.          before  := calc given: wip extractUpto: '~'.         after   := calc given: wip extractAfterSecond: '~'.         wip := before, '&lt;i&gt;', between, '&lt;/i&gt;', after.         ].   "Cannot use #match: for asterisk case. So we use this trick:"   ((HumCalculator given: wip extractBetween: '*' and: '*') = '')      ifFalse: [         between := HumCalculator given: wip extractBetween: '*' and: '*'.         before := calc given: wip extractUpto: '*'.         after   := calc given: wip extractAfterSecond: '*'.         wip := before, '&lt;b&gt;', between, '&lt;/b&gt;', after.         ].      ^wip.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderNounTreeForNoun:</h3><pre>renderNounTreeForNoun: aNoun    "Render a noun-tree rooted at the given noun (entity)."   | cr string indentedNounTree priorIndent priorNoun |   self assert: (aNoun isKindOf: String).   cr := String cr.   string := cr, 'Noun Tree:', cr.   indentedNounTree := ontology buildNounTreeForNoun: aNoun indent: 0.   priorIndent := 999.   priorNoun := aNoun.   indentedNounTree       do: [ :mapPostPre |            | value indent property pad supertypes |            value := ( mapPostPre value ).  "= { indent. attribute. }"            indent := value at: 1.            property := value at: 2.            pad := String new: 3 + (indent * 5) withAll: (Character space).            ( priorIndent = 999 )                ifTrue: [ string := string, pad, aNoun, cr ].            supertypes := ontology immediateSupertypesOf: priorNoun.            ( supertypes includes: property )               ifTrue:  [string := string, pad, ' |=&gt; ', property, cr.]               ifFalse: [string := string, pad, ' |-&gt; ', property, cr.].            priorIndent := indent.            priorNoun := property.            ].   ^ string.   </pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderNounTreeForNounAsHTML:</h3><pre>renderNounTreeForNounAsHTML: aNoun    "Render a noun-tree rooted at the given noun (entity)."   | string html |   string := self renderNounTreeForNoun: aNoun.   html := HumCalculator given: string  replaceAll: '&gt;' with: '&gt;'.   ^html</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderPlanActionsIn:</h3><pre>renderPlanActionsIn: aHumFrame4Plan    "render precondition lines"   | html cr |   cr := String cr.   html := '&lt;br/&gt;&lt;b&gt;Actions:&lt;/b&gt;', cr.   (aHumFrame4Plan actionStatements)      do: [ :actionLine |         self assert: ( actionLine isKindOf: HumInstructionLine ).         html := html, '&lt;br/&gt;', (self renderInstructionLine: actionLine).         "html := html, '&lt;br/&gt;', ( self renderStatement: actionLine ), cr."         ].   ^ html</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderPlanFrame:</h3><pre>renderPlanFrame: aHumFrame4Plan    "Render source code.    --  This is a read-only view for ontology code listing."   | html  |   calc := HumCalculator new. "Initialize indent"   html :=   calc xml: 'HumFrame'      with: [         (calc xml: 'frameTitle' with: [  'Goal: ', ( self renderInstruction: (aHumFrame4Plan goal ) )]),         ( self renderPlanPreconditionsIn: aHumFrame4Plan ),         ( self renderPlanActionsIn: aHumFrame4Plan )               ].   ^html.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderPlanPreconditionsIn:</h3><pre>renderPlanPreconditionsIn: aHumFrame4Plan    "render precondition lines"   | html br|   "Always include this subheading."   html := '&lt;br/&gt;&lt;b&gt;Preconditions:&lt;/b&gt;'.   br := String cr, '&lt;br/&gt;'.   (aHumFrame4Plan preconditions)      do: [ :preconditionLine |         self assert: (preconditionLine isKindOf: HumFrameLine ).         html := html, br, (self renderFrameLine: preconditionLine ).         ].   ^ html</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderPlanTreeForGoal:</h3><pre>renderPlanTreeForGoal: aGoal   "Render HTML for a previous created planTree (generated by  buildPlanTreeForGoal: )"   | string cr indentedPlanTree priorIndent goalHTML |   "NOTE: The goals that are most relevant are those found in dialog vignettes."   "See: HumOntologyTests&gt;&gt;test540GetPlanTree    -- Call to this method is commented out.   See also: HumOntology&gt;&gt;buildPlanTreeForGoal:   "   cr := String cr.   string := cr, 'Plan Tree:', cr.   indentedPlanTree := ontology buildPlanTreeForGoal: aGoal indent: 0.   priorIndent := 999.   goalHTML := self renderInstruction: (HumStatement source: ( ( indentedPlanTree at: 1 ) key )).   indentedPlanTree       do: [ :mapPostPre |            | value indent precondition pad |            value := ( mapPostPre value ).  "= { indent. precondition. }"            indent := value at: 1.            precondition := value at: 2.            pad := String new: 2 + (indent * 5) withAll: (Character space).            ( priorIndent = 999 )                ifTrue: [ string := string, pad, goalHTML, cr ].            string := string, pad, ' |-&gt; ', (self renderInstruction: precondition ), cr.            priorIndent := indent.            ].   ^ string.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderStatement:keywords:</h3><pre>renderStatement: aHumStatement keywords: keywords    | tokenTypes html token type fragment |   html := ''.   tokenTypes := ontology parseStatement: aHumStatement triggerWords: #() keywords: keywords.   tokenTypes      do: [ :tokenType |   "For each token-type:"         token := tokenType key.         type := tokenType value.         fragment := ''.         "Assign a tag that the CSS can then style."         ( type = #word ) ifTrue: [ fragment := ' ', token ].         ( type = #noun ) ifTrue: [ fragment := ' &lt;n&gt;', token, '&lt;/n&gt;' ].         ( type = #keyword ) ifTrue: [ fragment := ' &lt;k&gt;', token, '&lt;/k&gt;' ].         ( type = #role ) ifTrue: [ fragment := ' &lt;r&gt;', token, '&lt;/r&gt;' ].         "Just another token with no particular type."         ( fragment = '' ) ifTrue: [ fragment := token ].         html := html, fragment.         ].   ^html</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderStatement:triggerWords:keywords:</h3><pre>renderStatement: aHumStatement triggerWords: triggerWords keywords: keywords    | tokenTypes html token type fragment |   html := ''.   tokenTypes := ontology parseStatement: aHumStatement triggerWords: triggerWords keywords: keywords.   tokenTypes      do: [ :tokenType |   "For each token-type:"         token := tokenType key.         type := tokenType value.         fragment := ''.         "Assign a tag that the CSS can then style."         ( type = #word ) ifTrue: [ fragment := ' ', token ].         ( type = #noun ) ifTrue: [ fragment := ' &lt;n&gt;', token, '&lt;/n&gt;' ].         ( type = #keyword ) ifTrue: [ fragment := ' &lt;k&gt;', token, '&lt;/k&gt;' ].         ( type = #role ) ifTrue: [ fragment := ' &lt;r&gt;', token, '&lt;/r&gt;' ].         "Just another token with no particular type."         ( fragment = '' ) ifTrue: [ fragment := token ].         html := html, fragment.         ].   ^html</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderView:</h3><pre>renderView: aHumViewFrame    "Views are rendered as HTML forms -- which is different from other frames."   | html cr br innerHTML |   cr := String cr.   br := cr, '&lt;br/&gt;'.   innerHTML := cr.   html := cr, (calc xml:'form' with: [      aHumViewFrame frameLines       do: [ :frameLine |            "Markup lines will control line-breaks without my help."            "Future: View might have instruction-lines for tables."            (frameLine isKindOf: HumMarkupLine)               ifTrue: [innerHTML := innerHTML, br, ( self renderMarkupAsHTML5: frameLine source )]               ifFalse:[innerHTML := innerHTML, br, ( self renderInstructionLine: frameLine source )                  ].             ].      "Block returns "      innerHTML.      ]   ).   ^html.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; renderWidgetsInMarkup:</h3><pre>renderWidgetsInMarkup: aSourceString    "Return HTML5 equivalent of the widgets found in this mark-up line."   |  between before after wip |   wip := aSourceString.   "Match button."   ( '*[[*]]*' match: wip )      ifTrue: [         between := calc given: wip extractBetween: '[[' and: ']]'.         before := calc given: wip extractUpto: '[['.         after  := calc given: wip extractAfter: ']]'.         wip := before,'&lt;button name="',between,'" /&gt;',after.         "Get all the buttons before we go on."         wip := self renderWidgetsInMarkup: wip.         ].   "Match check-box"    ( '*[#]*' match: wip )      ifTrue: [          between := calc given: wip extractBetween: '[' and: ']'.         before := calc given: wip extractUpto: '['.         after  := calc given: wip extractAfter: ']'.         wip := before,'&lt;input name="',between,'" type="checkbox"/&gt;',after.         "Get all the check-boxes before we go on."         wip := self renderWidgetsInMarkup: wip.         ].   "Match other widgets."   ( '*[*]*' match: wip )      ifTrue: [          between := calc given: wip extractBetween: '[' and: ']'.         before := calc given: wip extractUpto: '['.         after  := calc given: wip extractAfter: ']'.                "Name followed by space and digit means multi-line text box"         ( between matchesRegex: '^.*\b\d$'  )            ifTrue: [ | name d |               name := calc given: between extractUpto: ' '.               d := calc given: between extractAfter: ' '.               wip := before,'&lt;textarea name="',name,'" rows=',d,' cols=60 /&gt;&lt;/textarea&gt;',after.]            ifFalse: ["Not a textarea . . ."               "TODO: If the attribute-name is plural, render as a table."               | noun calc2 |               noun := between.               calc2 := HumCalculator new.               calc2 cases;                  when: [ ontology isPluralNoun: noun ]                      then: [wip := before, (self generateHtmlTableFor: noun ), after.  ];                  when: [ ontology isCategory: noun ]                     then: [ wip := before, (self generateCategoryPullDownFor: noun ), after. ];                  otherwise:                      [ wip := before, '&lt;input name="', noun, '" /&gt;', after ].               ].         "TODO: Special handling for other types: category, date-time, measure."         ].   "Match radio-button"      ( '*(#)*' match: wip )         ifTrue: [          between := calc given: wip extractBetween: '(' and: ')'.         self assert: ((between size) = 1).         before := calc given: wip extractUpto: '('.         after  := calc given: wip extractAfter: ')'.         wip := before,'&lt;input name="',between,'" type="radio"/&gt;',after.         "TODO: Need &lt;group&gt; tags. HOW ARE WE GOING TO DO THAT?"         ].         "If no widgets were found in this pass: Return;  Otherwise: Iterate."   ( wip = aSourceString )       ifTrue: [ ^aSourceString.]      ifFalse: [ ^ self renderWidgetsInMarkup: wip ].   </pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; showPlanTree:</h3><pre>showPlanTree: aPlanTree   "Display a previous created planTree (generated by  buildPlanTreeForGoal: )"   | string cr |   "See: HumOntologyTests&gt;&gt;test540GetPlanTree    -- Call to this method is commented out.   See also: HumOntology&gt;&gt;buildPlanTreeForGoal:   "   cr := String cr.    string := cr, 'Plan Tree:', cr.   aPlanTree       do: [ :mapPostPre |            string := string, ( mapPostPre key ) asString, ' -&gt; ', ( mapPostPre value ) asString, cr.            ].      "TODO: What does this produce?  It looks like a simple rendering with no indentation."   ^ string.</pre><h3>Hum-Language -- HumOntologyViewer &gt;&gt; showPlanTreeForGoal:</h3><pre>showPlanTreeForGoal: aGoal   "Display a previous created planTree (generated by  buildPlanTreeForGoal: )"   | string cr indentedPlanTree priorIndent |   "See: HumOntologyTests&gt;&gt;test540GetPlanTree    -- Call to this method is commented out.   See also: HumOntology&gt;&gt;buildPlanTreeForGoal:   "   cr := String cr.   string := cr, 'Plan Tree:', cr.   indentedPlanTree := ontology buildPlanTreeForGoal: aGoal indent: 0.   priorIndent := 999.   indentedPlanTree       do: [ :mapPostPre |            | value indent precondition pad |            value := ( mapPostPre value ).  "= { indent. precondition. }"            indent := value at: 1.            precondition := value at: 2.            pad := String new: 1 + (indent * 2) withAll: (Character space).            ( priorIndent = 999 )                ifTrue: [ string := string, pad, ( mapPostPre key ) asString, cr ].            string := string, pad, ' -&gt; ', precondition asString, cr.            priorIndent := indent.            ].   ^ string.</pre><h3>Hum-Language -- HumOntology &gt;&gt; actionsOf:</h3><pre>actionsOf: aRole   "The actions of a role define its public interface. (API).   NOTE: Statements prefixed with: 'To: ' name private methods.    "      ^self projectValuesOf: (self roleActions) from: (aRole capitalized).</pre><h3>Hum-Language -- HumOntology &gt;&gt; addEntity:attribute:</h3><pre>addEntity: anEntity attribute: anAttribute       "Define these nouns and their relationship."   | lcEntity lcAttribute |   lcEntity := anEntity asLowercase.   lcAttribute := anAttribute asLowercase.   self addNoun: lcEntity.   self addNoun: lcAttribute.   "Add entity-attribute relationship."   self entityAttributes add: ( lcEntity -&gt; lcAttribute ).</pre><h3>Hum-Language -- HumOntology &gt;&gt; addEntity:attributes:</h3><pre>addEntity: anEntity attributes: anAttributeCollection       "Define these nouns and their relationship." | entityName |   entityName := anEntity asLowercase.   self addNoun: entityName.   anAttributeCollection       do: [ :anAttribute |          self addEntity: anEntity attribute: anAttribute.         ].</pre><h3>Hum-Language -- HumOntology &gt;&gt; addNoun:</h3><pre>addNoun: aNoun    "Remember noun."   | singularNoun |   self assert: (aNoun isKindOf: String).   (#('a' 'an' 'the') includes: (aNoun))       ifTrue: [ "Error signal: 'Attempt to add article as noun.' "         ^self.         ].   "Watch for parsing bug -- NOTE: category nouns are not strings."   (aNoun at: 1) isLetter ifFalse: [ Error signal: 'noun must start with a letter.' ].      singularNoun := self singularFormOfNoun: aNoun.   self nouns add: singularNoun.   "Check if noun has an implied supertype."   self setAutomaticSupertypeForNoun: singularNoun.   </pre><h3>Hum-Language -- HumOntology &gt;&gt; addNoun:isA:</h3><pre>addNoun: aSubType isA: aSuperType       "Add these nouns and add is-A relation."   | theNoun theSuperType |   theNoun := aSubType asLowercase.   theSuperType := aSuperType asLowercase.   "Add these nouns in case they are not already added."   self addNoun: theNoun.   self addNoun: theSuperType.   "Add inverse relation -- Note: subtypes is also a Set."   self nounSubtypes add: ( theSuperType -&gt; theNoun).   </pre><h3>Hum-Language -- HumOntology &gt;&gt; addNoun:isDerivedFrom:</h3><pre>addNoun: aNoun isDerivedFrom: anotherNoun    self log: 'This ontology uses advanced features that have not been implemented yet.'   </pre><h3>Hum-Language -- HumOntology &gt;&gt; addNoun:isSynonymFor:</h3><pre>addNoun: aSynonym isSynonymFor: aStandardNoun    "Add these nouns and add is-A relation."   | theNoun theSynonym |   theNoun := aStandardNoun asLowercase.   theSynonym := aSynonym asLowercase.   "Add these nouns in case they are not already added."   self addNoun: theNoun.   self addNoun: theSynonym.   "Add inverse relation -- Note: subtypes is also a Set."   self nounSynonyms add: ( theSynonym -&gt; theNoun).   </pre><h3>Hum-Language -- HumOntology &gt;&gt; addNoun:reference:</h3><pre>addNoun: aNounString reference: aFrameLine    "Remember where nouns are referenced."   (self nounReferences ) add: ( aNounString -&gt; aFrameLine ).</pre><h3>Hum-Language -- HumOntology &gt;&gt; addNouns:</h3><pre>addNouns: anArrayOfNouns       anArrayOfNouns do: [ :noun | self addNoun: noun ].</pre><h3>Hum-Language -- HumOntology &gt;&gt; addPlanFrame:ForGoal:</h3><pre>addPlanFrame: aPlanFrame ForGoal: aGoalString    "Store frame as a plan frame - index as needed."   | |   self assert: ( aPlanFrame isKindOf: HumFrame4Plan ).   self storeFrame: aPlanFrame.   </pre><h3>Hum-Language -- HumOntology &gt;&gt; addRole:</h3><pre>addRole: aRole    self assert: (aRole isKindOf: String ).   self roles add: aRole capitalized.</pre><h3>Hum-Language -- HumOntology &gt;&gt; addViewFrame:</h3><pre>addViewFrame: aHumFrame4View    self storeFrame: aHumFrame4View.   self addNoun: aHumFrame4View entity isA: 'view'.</pre><h3>Hum-Language -- HumOntology &gt;&gt; addVignette:toContext:</h3><pre>addVignette: aFrame4Vignette toContext: aContext    "Add to store"   | contextKey |   contextKey := self cleanKey: aContext.   ( self contexts ) add: contextKey.   ( self contextVignettes ) add: ( contextKey -&gt; aFrame4Vignette ).      "frame defines context"   self indexFrame: aFrame4Vignette relation: #definesContext object: contextKey.</pre><h3>Hum-Language -- HumOntology &gt;&gt; allAttributesOfEntity:</h3><pre>allAttributesOfEntity: anEntity    "Get the attributes, the attributes of the attributes, and the attributes of the supertypes."   | allAttributes localAttributes tempAttributes localSupertypes localProperties entity |   (self attributeChain includes: anEntity) ifTrue: [ ^Set new. "Return empty set to terminate cycle." ].   self attributeChainPush: anEntity.   entity := anEntity asLowercase.   self assert: (entity sameAs: anEntity).   "Get the immediate properties of this entity."   localAttributes := self immediateAttributesOfEntity: anEntity.   self assert: (( localAttributes include: anEntity ) not ) description: 'An entity should not be an attribute of itself.'.   localSupertypes := self immediateSupertypesOf: anEntity.   self assert: (( localSupertypes include: anEntity ) not ) description: 'An entity should not be a supertype of itself.'.      "Entity properties include attributes and supertypes."   localProperties := localAttributes, localSupertypes.   self assert: ( localProperties include: anEntity ) not.      "For each local property: Look up attributes and add them to the result set."   allAttributes := localAttributes.   self assert: ( allAttributes include: anEntity ) not.   localProperties       do: [ :eachProperty |         "RECURSIVE CALL !!!"         tempAttributes := self allAttributesOfEntity: eachProperty.         allAttributes := allAttributes, tempAttributes.         "Detect cycles in the tree."         ( allAttributes include: anEntity )             ifTrue: [ Error signal: 'noun attribute-tree contains cycle at: ', anEntity ].          ].   self attributeChainPop: anEntity.      ^allAttributes   </pre><h3>Hum-Language -- HumOntology &gt;&gt; allSubtypesOf:</h3><pre>allSubtypesOf: aSuperType    "Get the subtypes (if any) of this noun and the subtypes of the subtypes all the way down"   | localSubtypes tempSubtypes allSubtypes |   localSubtypes := self immediateSubtypesOf: aSuperType asLowercase.   allSubtypes := localSubtypes.   localSubtypes       do: [ :eachSubtype |          "RECURSION: Get the subtypes for each of those subtypes."         tempSubtypes := self allSubtypesOf: eachSubtype.         "Merge the sets"         allSubtypes := allSubtypes, tempSubtypes.          "Detect cycles in the tree."         ( allSubtypes includes: aSuperType )             ifTrue: [ Error signal: 'noun subtype-tree contains a cycle at: ', aSuperType ].          ].   "Return the merged set of all subtypes."      ^allSubtypes.</pre><h3>Hum-Language -- HumOntology &gt;&gt; allSupertypesOf:</h3><pre>allSupertypesOf: aSubType    "Get the Supertypes (if any) of this noun and the Supertypes of the Supertypes all the way down"   | localSupertypes tempSupertypes allSupertypes |   localSupertypes := self immediateSupertypesOf: aSubType asLowercase.   allSupertypes := localSupertypes.   localSupertypes       do: [ :eachSupertype |          "RECURSION: Get the Supertypes for each of those Supertypes."         tempSupertypes := self allSupertypesOf: eachSupertype.         "Merge the sets"         allSupertypes := allSupertypes, tempSupertypes.          "Detect cycles in the tree."         ( allSupertypes includes: aSubType )             ifTrue: [ Error signal: 'noun Supertype-tree contains a cycle at: ', aSubType ].          ].   "Return the merged set of all Supertypes."      ^allSupertypes.</pre><h3>Hum-Language -- HumOntology &gt;&gt; appendInstruction:toRole:action:</h3><pre>appendInstruction: aHumInstruction toRole: aRole action: anAction    "Append the given instruction to the action's sequence of instructions."   | sequence instruction actionString actionFrame |      self assert: ( aRole isKindOf: String ).   actionString := (anAction isKindOf: String ) ifTrue: [ anAction ] ifFalse: [ anAction asString ].   self assert: ( actionString isKindOf: String ).      instruction := aHumInstruction copy.   ( instruction isKindOf: String ) ifTrue: [ instruction := HumInstructionLine statement: aHumInstruction ].            "Get the sequence of instructions belonging to this role action."   actionFrame := self getFrameForRole: aRole capitalized action: actionString.    sequence := actionFrame frameLines.      "Append the given instruction to the sequence."   sequence add: instruction.      "Assure that the data store is updated."   self storeFrame: actionFrame.</pre><h3>Hum-Language -- HumOntology &gt;&gt; appendRole:action:</h3><pre>appendRole: aRole action: actionStatement    "Add role and action statement."   | capRole |   Error signal: 'Use indexRole: aRole action: actionStatement.'.   self assert: ( aRole isKindOf: String ).   self assert: ( actionStatement isKindOf: HumStatement ).   "Assure role is in set."   capRole := aRole capitalized.   self addRole: capRole.      "Assure statement is in set."   self roleActions add: ( capRole -&gt; actionStatement ).</pre><h3>Hum-Language -- HumOntology &gt;&gt; asString</h3><pre>asString   | s |   s := (self class name), '( ', (self title), ' )'.   ^s</pre><h3>Hum-Language -- HumOntology &gt;&gt; attributeChain</h3><pre>attributeChain   ^attributeChain ifNil: [ attributeChain := Stack new.]</pre><h3>Hum-Language -- HumOntology &gt;&gt; attributeChainPop:</h3><pre>attributeChainPop: anAttribute   self assert: (self attributeChain top) = anAttribute.   self attributeChain pop.</pre><h3>Hum-Language -- HumOntology &gt;&gt; attributeChainPush:</h3><pre>attributeChainPush: anAttribute    self assert: ((self attributeChain) includes: anAttribute ) not.    (self attributeChain) push: anAttribute.    </pre><h3>Hum-Language -- HumOntology &gt;&gt; buildPlanTreeForGoal:indent:</h3><pre>buildPlanTreeForGoal: aGoal indent: anIndentLevel   "Build a list of associations: ( goalStatement -&gt; { anIndentLevel. precondition statement.} )"   | goalStatement planTree subTree rootFrame |   goalStatement := HumStatement from: aGoal.   planTree := OrderedCollection new.   rootFrame := self getPlanFrameForGoal: aGoal.   "Stop building the plan subtree if the root frame is not defined."   ( rootFrame isNoPlan ) ifTrue: [ ^planTree ].      ( rootFrame preconditions )      do: [ :precondition |         planTree add: ( goalStatement -&gt; { anIndentLevel. precondition statement.} ).         subTree := self buildPlanTreeForGoal: (precondition statement) indent: (anIndentLevel + 1).         planTree := planTree, subTree.         "Detect a cycle in the tree."         ( planTree anySatisfy: [ :map |  (map value at: 2) = goalStatement ] )             ifTrue: [ Error signal: 'cycle detected in plan tree' ].         ].         ^planTree.</pre><h3>Hum-Language -- HumOntology &gt;&gt; categoriesOf:</h3><pre>categoriesOf: anAttributeName    | categories |   ^categories := (self nounCategories) at: anAttributeName ifAbsent: [Set new].</pre><h3>Hum-Language -- HumOntology &gt;&gt; categoriesOf:include:</h3><pre>categoriesOf: anAttributeName include: anArrayOfCategoryNames   "Add this noun in case it is not already added;"   "and make it a kind of category"   | setOfCategories attribute |   attribute := anAttributeName trimBoth asLowercase.    self addNoun: attribute isA: 'category'.   setOfCategories := self categoriesOf: attribute.   anArrayOfCategoryNames       do: [:category |             setOfCategories add: category.             self addNoun: category.             ].   (self nounCategories) at: attribute put: setOfCategories.   </pre><h3>Hum-Language -- HumOntology &gt;&gt; checkPlanTreeForGoal:</h3><pre>checkPlanTreeForGoal: aGoal    | goalStatement planTreeProblems subTreeProblems rootFrame planFrame |   "Check for problems that would prevent the plan from working."   goalStatement := HumStatement from: aGoal.   planTreeProblems := OrderedCollection new.      "Safety check -- &gt;&gt;buildPlanTreeForGoal: . . . will stop execution if there is a cycle in the plan-tree."   self buildPlanTreeForGoal: aGoal indent: 0.   rootFrame := self getPlanFrameForGoal: goalStatement.   (rootFrame isNoPlan)       ifTrue: [ planTreeProblems add: 'Precondition: {', ( goalStatement asString ), '} has no plan frame.'.                   ^ planTreeProblems ].      " Look for preconditions that have no corresponding plan frame in the ontology."   ( rootFrame preconditions )      do: [ :precondition |         planFrame := self getPlanFrameForGoal: precondition statement.         planFrame ifNil: [ planTreeProblems add: 'Precondition: {', ( precondition statement asString ), '} has no plan frame.' ].         subTreeProblems := self checkPlanTreeForGoal:   ( precondition statement ).         planTreeProblems := planTreeProblems, subTreeProblems.         ].                     ^planTreeProblems.</pre><h3>Hum-Language -- HumOntology &gt;&gt; cleanKey:</h3><pre>cleanKey: aString   "Assure that the string will be a clean key -- convert to lower-case, trim blanks."   | camelCase |   camelCase := HumCalculator camelCase: aString.   ^camelCase.</pre><h3>Hum-Language -- HumOntology &gt;&gt; codeGenerator</h3><pre>codeGenerator   "Return a translator."   ^translator       ifNil: [          "Precondition: Assure we are compiled."         self compileAllFrames.         "TODO: This 'Assure we are compiled.' strategy will fail                 when the ontology is updated between translations."         "Post condition: translator is set."         translator := HumOntologyTranslator ontology: self.          ].</pre><h3>Hum-Language -- HumOntology &gt;&gt; collectPlanFramesForGoal:</h3><pre>collectPlanFramesForGoal: aGoalStatement    "| goalStatement planTree subTree rootFrame |   goalStatement := HumStatement from: aGoal.   planTree := OrderedCollection new.   rootFrame := self getPlanFrameForGoal: aGoal.   ( rootFrame preconditions )      do: [ :precondition |         planTree add: ( goalStatement -&gt; (precondition statement) ).         subTree := self buildPlanTreeForGoal: (precondition statement).         planTree := planTree, subTree.         ( planTree anySatisfy: [ :map |  map value = goalStatement ] )             ifTrue: [ Error signal: 'cycle detected in plan tree' ].         ].         ^planTree."   | problems rootFrame frameCollection subSet |   "First check to make sure the plan frames are complete."   problems := self checkPlanTreeForGoal:  aGoalStatement.   problems isEmpty       ifFalse: [ Error signal: 'There are problems with the plan tree for goal: ', (aGoalStatement asString)                                         , String cr, ' Problems: ', problems asString. ].   "Collect the plan frames."   frameCollection := Set new.   rootFrame := self getPlanFrameForGoal: aGoalStatement.   frameCollection add: rootFrame.   ( rootFrame preconditions )      do: [ :precondition |         subSet := self collectPlanFramesForGoal: (precondition statement).         frameCollection addAll: subSet.         ].   ^frameCollection.</pre><h3>Hum-Language -- HumOntology &gt;&gt; compileAllFrames</h3><pre>compileAllFrames   "Compile the dictionary frames first, then the others."    | dictionaryFrames otherFrames problems frameProblems |   "Return any problems found."   problems := OrderedCollection new.   "Reset the frame index"   frameRelations := nil.      "Compile the dictionary frames first."   dictionaryFrames := (self frames) select: [:frame | frame isKindOf: HumFrame4Dictionary ].   dictionaryFrames      do: [ :frame |          frameProblems := frame compileToOntology: self.          problems addAllLast: frameProblems.         ].         "Compile the remaining frames."   otherFrames := (self frames) select: [:frame | (frame isKindOf: HumFrame4Dictionary) not ].   otherFrames      do: [ :frame |          frameProblems := frame compileToOntology: self.          problems addAllLast: frameProblems.         ].         ^problems.</pre><h3>Hum-Language -- HumOntology &gt;&gt; contextVignettes</h3><pre>contextVignettes   "This list holds the (1:M) relation (context -&gt; vignette)."   contextVignettes ifNil: [ contextVignettes := OrderedCollection new. ].   "Vignettes are evaluated in the order seen."   "TODO: Decide if we need a priority attribute on a vignette to enable re-ordering."    self assert: (contextVignettes isKindOf: OrderedCollection ).   ^contextVignettes.</pre><h3>Hum-Language -- HumOntology &gt;&gt; contexts</h3><pre>contexts   ^ contexts ifNil: [  contexts := Set new. ]</pre><h3>Hum-Language -- HumOntology &gt;&gt; critiqueRole:action:</h3><pre>critiqueRole: aRole action: anAction    "Critique the instructions for this role action."   |  critique actionStatement sequence actionNouns instructionNouns |         "Return the critique as a sequence of strings."   critique := OrderedCollection new.      "The action should contain at least one noun."   actionStatement := self getRole:  aRole action: anAction.   actionNouns := self nounsInStatement: actionStatement.   ( actionNouns size &gt; 0 )       ifFalse: [ critique add: 'Action Statement has no known nouns.'].         "There should be at least one instruction for the action statement."         sequence := self instructionsForRole: aRole action: anAction.   ( sequence size &gt; 0 )      ifFalse: [ critique add: 'Action has no instructions.'].            "Nouns in the instructions should find antecedants in the action statement."   sequence       do: [ :instruction |          instructionNouns := self nounsInStatement: instruction statement.         ( actionNouns includesAllOf: instructionNouns )            ifFalse: [ critique add: ( 'Some nouns lack antecedants in: ', instruction statement source ) ].         ].       ^critique.</pre><h3>Hum-Language -- HumOntology &gt;&gt; debug</h3><pre>debug   "Am I in debug mode?"   ^ debug ifNil: [debug := false].</pre><h3>Hum-Language -- HumOntology &gt;&gt; entityAttributes</h3><pre>entityAttributes   "This instance variable is a map, a set of associations ( anEntity -&gt; anAttribute )"   ^entityAttributes ifNil: [ entityAttributes := Set new.].</pre><h3>Hum-Language -- HumOntology &gt;&gt; fetchFrameByIdentifier:</h3><pre>fetchFrameByIdentifier: aPrimaryKey    "Fetch the frame with this identifier."   | frame |   frame := ( self framesByIdentifier ) at: aPrimaryKey ifAbsent: [ Error signal: 'No such frame in this ontology!'].   ^frame.</pre><h3>Hum-Language -- HumOntology &gt;&gt; fetchFrameByName:</h3><pre>fetchFrameByName: aString    | frame |   self assert: (aString isKindOf: String).   "self assert: (aString endsWith: '.')."   frame := (self framesByName ) at: aString ifAbsent: [ Error signal: 'No frame by this name.'].   ^frame.</pre><h3>Hum-Language -- HumOntology &gt;&gt; file</h3><pre>file   ^ fromFile ifNil: [ fromFile := 'HumOntologyFile.ontology' ].</pre><h3>Hum-Language -- HumOntology &gt;&gt; file:</h3><pre>file: aString    fromFile := aString.</pre><h3>Hum-Language -- HumOntology &gt;&gt; findBestMatchingVignetteForInput:inContextStack:</h3><pre>findBestMatchingVignetteForInput: aString inContextStack: aStack    "Search the vignette frames for the one whose pattern is the best match   for the given input and context-stack."   | bestMatch stackCopy bestMatchScore |   self assert: ( aString isKindOf: String ).   self assert: ( aStack  isKindOf: Stack ).   self assert: ( aStack notEmpty ).   "We want the best match with a score better than zero."   bestMatchScore := 0.   aStack      do: [ :contextString |         "See if we have any vignettes that match that context."         | vignettesInContext |         vignettesInContext := self vignettesForContext: contextString.         "Get the bestMatch from that set."         vignettesInContext            do: [ :candidate |               | score |               score := candidate patternMatchScore: aString.               ( score &gt; bestMatchScore)                     ifTrue: [ bestMatch := candidate.                                 bestMatchScore := score.                              ].               ].         ].   ( bestMatchScore = 0 )         ifTrue: [ bestMatch := self hasNoVignetteMatchFor: aString. ].   ^ bestMatch.</pre><h3>Hum-Language -- HumOntology &gt;&gt; frameRelations</h3><pre>frameRelations   "The cross index collection tracks relationships between frames."   "Entries have the form: { frameA. #symbol. frameB. }     where the frames are identified by their titles.    Cases:      - { frameA.    #invokes. actionB. }  ( frameA may be action, plan, or vignette. )      - { vignetteA. #stacks. contextB. }      - { goalA.     #requires.  goalB. }  ( This very like plan tree. )   "   ^ frameRelations ifNil: [ frameRelations := Set new. ].</pre><h3>Hum-Language -- HumOntology &gt;&gt; frameRelationsWhere:</h3><pre>frameRelationsWhere:  aBlock   "Return frame relations where aBlock evaluates as true"   | selectedRelations |   selectedRelations := frameRelations          select:  [ :frameRelation |            | a r b |            a := frameRelation at: 1.            r := frameRelation at: 2.            b := frameRelation at: 3.            aBlock value: a value: r value: b ].   ^selectedRelations.</pre><h3>Hum-Language -- HumOntology &gt;&gt; frames</h3><pre>frames   ^ frames ifNil: [ frames := Set new. ].</pre><h3>Hum-Language -- HumOntology &gt;&gt; framesByIdentifier</h3><pre>framesByIdentifier   "Each frame is given a unique identifier.    This store indexes the frames their identifiers."   ^ framesByIdentifier ifNil: [ framesByIdentifier := Dictionary new. ].</pre><h3>Hum-Language -- HumOntology &gt;&gt; framesByName</h3><pre>framesByName   "Enable access to frames by their name (title line string)."   ^ framesByName ifNil: [ framesByName := Dictionary new ].</pre><h3>Hum-Language -- HumOntology &gt;&gt; fromFile</h3><pre>fromFile   "The file name serves as a natural identifier. "   ^ fromFile ifNil: [ ^ '(untitled)' ].</pre><h3>Hum-Language -- HumOntology &gt;&gt; getEntityAttributePhraseFromStatement:</h3><pre>getEntityAttributePhraseFromStatement: aHumStatement    "Return collection of 'entity attribute' pairs when statement contains possessive nouns."   | remainder  pairs |   pairs := OrderedCollection new.   remainder := aHumStatement source.   ['*`s *' match: remainder]      whileTrue: [  "Get the first entity and the attribute pair"         | entity attribute front back tokens |         front := HumCalculator given: remainder  extractUpto: '`s '.         back := HumCalculator given: remainder  extractAfter: '`s '.         tokens := HumCalculator findTokensInString: front.         entity := tokens last.         tokens := HumCalculator findTokensInString: back.         attribute := tokens first.         remainder := HumCalculator given: back extractAfter: attribute.         pairs add: (entity, ' ', attribute).         "TODO: Perhaps we should put '`s' in the pair. Leave a clue, other than the space, for other processes."         ].   ^pairs.</pre><h3>Hum-Language -- HumOntology &gt;&gt; getFrameForRole:action:</h3><pre>getFrameForRole: aRole action: anAction    "Get the frame that matches given role and action."   | frame  |   "TODO: Kludge some polymorphism.    TODO: Fix-up string arguments"      (self roleActions)      do: [:map |          | role frameAction |         role := map key.         frameAction := map value.         self assert: (role = (role capitalized)) description: 'Watch for index bug.'.         ( (role sameAs: aRole)            and: [frameAction matchesCandidateStatement: anAction inOntology: self])               ifTrue: ["Get the frame. If it does not exist, make it."                  | frameKey |                  frameKey := 'Role: ',aRole,' -- ',(frameAction source).                  frame := (self framesByName) at: frameKey                                     ifAbsent: [ "Make and store an action frame."                                                frame := HumFrame4Action ontology: self role: role action: frameAction.                                                 self storeFrame: frame.                                                frame.                                                ].                  ^frame.                  ].         ].   "If no frame is found/generated (will happen for a new role), return an empty frame."   frame ifNil: [frame := HumFrame4Action ontology: self role: aRole action: anAction.].   self assert: (frame isKindOf: HumFrame4Action) .   ^frame.</pre><h3>Hum-Language -- HumOntology &gt;&gt; getFramesThatDefineContext:</h3><pre>getFramesThatDefineContext: aContextName    "Get the vignette frames that define the given context."   | resultSet |   resultSet := Set new.      resultSet := self getFramesWithRelation: #definesContext object: ( self cleanKey: aContextName ).   ^resultSet.</pre><h3>Hum-Language -- HumOntology &gt;&gt; getFramesThatInvokeAction:</h3><pre>getFramesThatInvokeAction: anActionString    "Lookup the frames where action is invoked."   | resultSet  |   resultSet := self getFramesWithRelation: #invokesAction object: anActionString.   ^ resultSet.</pre><h3>Hum-Language -- HumOntology &gt;&gt; getFramesThatInvokeContext:</h3><pre>getFramesThatInvokeContext: aContextName    "Get frames with 'Push context &lt;aContextName&gt;.'  instructions."   | resultSet |   resultSet := self getFramesWithRelation: #invokesContext object: aContextName.   ^resultSet.</pre><h3>Hum-Language -- HumOntology &gt;&gt; getFramesThatInvokePrecondition:</h3><pre>getFramesThatInvokePrecondition: aStatementString    "Lookup the frames where precondition is invoked."   | resultSet  |   resultSet := self getFramesWithRelation: #precondition object: aStatementString.   ^ resultSet.</pre><h3>Hum-Language -- HumOntology &gt;&gt; getFramesThatInvokeView:</h3><pre>getFramesThatInvokeView: aViewName   "A view may be invoked by another view or by a vignette."   | resultSet |   "Compiler will scan views to index [pane: ...] pattern. "       "Compiler will scan vignettes to index instructions 'Show &lt;viewname&gt;.' and 'Ask &lt;viewname&gt;.'"   resultSet := self getFramesWithRelation: #invokesView object: aViewName.      ^resultSet.   </pre><h3>Hum-Language -- HumOntology &gt;&gt; getFramesWithRelation:object:</h3><pre>getFramesWithRelation: aSymbol object: aName   "Get frames that are indexed with given relation and object."   | resultSet |   resultSet := Set new.      (self frameRelations select: [:tuple | (tuple at: 2) = aSymbol])      do: [ :relation |      "Relation looks like { frameTitle. relationSymbol. someString. }"         | subject verb object |         subject := relation at: 1.         verb := relation at: 2.         object := relation at: 3.         (( verb = aSymbol ) and: [ object = (aName trimBoth asLowercase) ])               ifTrue: [ resultSet add: subject. ].         ].   ^resultSet.</pre><h3>Hum-Language -- HumOntology &gt;&gt; getPlanFrameForGoal:</h3><pre>getPlanFrameForGoal: aGoalString    | frame key |   key := 'Goal: ', aGoalString asString.   frame := (self framesByName )                      at: key                     ifAbsent: [ "Return an empty planFrame."                         ^ HumFrame4Plan ontology: self goal: (aGoalString asString).                        ].   self assert: ( frame isKindOf: HumFrame4Plan ).   ^frame.   </pre><h3>Hum-Language -- HumOntology &gt;&gt; getRole:action:</h3><pre>getRole: aRole action: aStringOrStatement    "Get the action if it already exists."   | actionStatement |   "TODO: Kludge some polymorphism.    TODO: Fix-up string arguments"      "Assure that we are dealing with a HumStatment."   actionStatement := aStringOrStatement copy.   ( actionStatement isKindOf: HumStatement )       ifFalse: [ actionStatement := HumStatement from: aStringOrStatement ].   "If the role action set already contains the action statement,       return an equivalent statement.   "      (self roleActions include: ( ( aRole capitalized ) -&gt; actionStatement ) )       ifFalse: [ "The role does not currently define a proper match"         "TODO: Refactor to handle polymorphism."         self error: 'Attempt to get a non-existent action statement.'.          ^nil ].   ^actionStatement.</pre><h3>Hum-Language -- HumOntology &gt;&gt; getViewFrame:</h3><pre>getViewFrame: nameString    "Get the view frame with the given name."   | frame viewName |   viewName := nameString.   (viewName endsWith: '.') ifTrue: [viewName := nameString copyFrom: 1 to: ((nameString size) - 1)].   frame := ( self framesByName )                   at: ('View: ', viewName trimBoth capitalized,'.')                  ifAbsent: ["If none, make one."                     Error signal: 'No such view as: ', viewName.                     frame := HumFrame4View ontology: self viewEntity: viewName.                     ].   ^frame.</pre><h3>Hum-Language -- HumOntology &gt;&gt; hasNoVignetteMatchFor:</h3><pre>hasNoVignetteMatchFor: aString    | defaultVignette |   (self debug) ifTrue: [Error signal: 'No vignette pattern match for {',aString,'}'].   defaultVignette := HumFrame4Vignette ontology: self vignetteContext: 'any' pattern: aString trimBoth.   defaultVignette addVignetteResponse: ('Sorry, { ', aString, '} is not understood.').   ^ defaultVignette.</pre><h3>Hum-Language -- HumOntology &gt;&gt; immediateAttributesOfEntity:</h3><pre>immediateAttributesOfEntity: anEntity    ^ self projectValuesOf: (self entityAttributes) from: anEntity.</pre><h3>Hum-Language -- HumOntology &gt;&gt; immediateSubtypesOf:</h3><pre>immediateSubtypesOf: aSuperType    "Get the subtypes (if any) of this noun."   ^ self projectValuesOf: (self nounSubtypes) from: aSuperType.</pre><h3>Hum-Language -- HumOntology &gt;&gt; immediateSupertypesOf:</h3><pre>immediateSupertypesOf: aNoun   "Get the immedate supertypes (if any) for this noun."    | mapSet supertypes |   "Initialize the result set."   supertypes := Set new.   "for each map ( supertype -&gt; subtype ):"   mapSet := self nounSubtypes.   mapSet       do: [ :nounSubtype |         ( nounSubtype value = aNoun )            ifTrue: [ supertypes add: nounSubtype key ].         ].   ^supertypes.</pre><h3>Hum-Language -- HumOntology &gt;&gt; indexFrame:relation:object:</h3><pre>indexFrame: aHumFrame relation: aSymbol object: aKeyString    "Add the given frame to the index"   | |   self assert: ( aSymbol isKindOf: Symbol ).   (self frameRelations) add: { aHumFrame title. aSymbol. (aKeyString trimBoth asLowercase). }.</pre><h3>Hum-Language -- HumOntology &gt;&gt; indexRole:action:</h3><pre>indexRole: aRole action: actionStatement    "Index role and action statement."   | capRole |      self assert: ( aRole isKindOf: String ).   self assert: ( actionStatement isKindOf: HumStatement ).   "Assure role is in set."   capRole := aRole capitalized.   self addRole: capRole.      "Assure statement is in set."   self roleActions add: ( capRole -&gt; actionStatement ).</pre><h3>Hum-Language -- HumOntology &gt;&gt; instructionsForRole:action:</h3><pre>instructionsForRole: aRole action: anAction   | actionFrame lines actionStatement |   self assert: (aRole &gt; '') description: 'Role cannot be empty for frame lookup.'.   (anAction isKindOf: HumStatement) ifTrue: [ actionStatement := anAction  ].   (anAction isKindOf: HumInstructionLine) ifTrue: [ actionStatement := anAction statement ].   (anAction isKindOf: String ) ifTrue: [ actionStatement := HumStatement source: anAction ].   self assert: (actionStatement isKindOf: HumStatement ).   actionFrame := self getFrameForRole: aRole capitalized action: actionStatement.   lines := actionFrame frameLines.   ^lines.     </pre><h3>Hum-Language -- HumOntology &gt;&gt; isActionDefined:inRole:</h3><pre>isActionDefined: anInstructionLine inRole: aRole   "Has the given statement been defined as an action for the given role?"   | instructions result |    "TODO: Kludge some polymorphism.    TODO: Fix-up string arguments"      (aRole &gt; ' ') ifFalse:[Error signal: 'Role cannot be empty for action lookup.'].   instructions := self instructionsForRole: aRole action: ( anInstructionLine statement ).   result := ( instructions size &gt; 0 ).   "(result) ifFalse: [ self halt. ]."   ^ result.</pre><h3>Hum-Language -- HumOntology &gt;&gt; isActionDefinedV01:</h3><pre>isActionDefinedV01: anInstructionLine    "See if we have a definition for the given action."   | numberOfDefinitions |   numberOfDefinitions := ( self roleActions )       count: [ :map |          ( map key = anInstructionLine  role ) and: [ map value = anInstructionLine statement ].         ].   self assert: ( numberOfDefinitions &lt; 2 ).   ^ numberOfDefinitions &gt; 0.      </pre><h3>Hum-Language -- HumOntology &gt;&gt; isAttribute:</h3><pre>isAttribute: aNameString   "Does the string name an attribute? (An attribute has no attributes of its own.)"   | result attributes |       "First: Does it name a noun?"   result := self isNoun: aNameString.   result ifFalse: [^false].      "An attribute has no attributes.     Nor is it a subtype of something that has attributes."   attributes := self allAttributesOfEntity: aNameString.   result := attributes size = 0.   ^result.   </pre><h3>Hum-Language -- HumOntology &gt;&gt; isCategory:</h3><pre>isCategory: aNameString   "Does the string name an attribute? (An attribute has no attributes of its own.)"   | result  |      "First: Does it name a noun?"   result := self isNoun: aNameString.   result ifFalse: [^false].      result := self yesNoun: aNameString isAKindOf: 'category'.   ^result.   </pre><h3>Hum-Language -- HumOntology &gt;&gt; isEntity:</h3><pre>isEntity: aNameString   "Does the string name an entity?"   | result attributes |      "First: Does it name a noun?"   result := self isNoun: aNameString.   result ifFalse: [^false].      "An entity has one or more attributes."   attributes := self allAttributesOfEntity: aNameString.   result := attributes size &gt; 0.   ^result.   </pre><h3>Hum-Language -- HumOntology &gt;&gt; isEntity:attribute:</h3><pre>isEntity: entityName attribute: attributeName   "Does this combination make sense? "   | result attributes |      "Does the first noun name an entity?"   result := self isEntity: entityName.   result ifFalse: [^false].      "Is the second noun an attribute of the first noun?"   attributes := self allAttributesOfEntity: entityName.   result := attributes includes: attributeName.   ^result.      </pre><h3>Hum-Language -- HumOntology &gt;&gt; isNoun:</h3><pre>isNoun: aNounString       "Is the given string a noun?"   | singular |   self assert: [ aNounString isKindOf: String ].   "TODO: Refactor to deal with possessive case. e.g. 'user`s name'. "   singular := self singularFormOfNoun: aNounString.   ^( self nouns ) include: singular.</pre><h3>Hum-Language -- HumOntology &gt;&gt; isPluralNoun:</h3><pre>isPluralNoun: aNoun   "Return true if the noun is plural."   | singular isSingular |   singular := self singularFormOfNoun: aNoun.   isSingular := (singular sameAs: aNoun).   ^isSingular not.   </pre><h3>Hum-Language -- HumOntology &gt;&gt; isViewName:</h3><pre>isViewName: aString    "Does the string name a view frame?"   | frame result |   frame := (self framesByName) at: ('View: ',aString trimBoth,'.') ifAbsent: [^false].   result := frame isKindOf: HumFrame4View.      ^result.</pre><h3>Hum-Language -- HumOntology &gt;&gt; nounAsCamelCase:</h3><pre>nounAsCamelCase: aString    |result delimiters tokens |   delimiters := '- '.   tokens := aString findTokens: delimiters keep: ' '.   result := tokens at: 1.   (tokens copyFrom: 2 to: tokens size)      do: [:token | result := result, (token capitalized) ].   ^result.</pre><h3>Hum-Language -- HumOntology &gt;&gt; nounCategories</h3><pre>nounCategories   "(self nounCategories) at: attribute put: setOfCategories."   ^ nounCategories ifNil: [ nounCategories := Dictionary new ].</pre><h3>Hum-Language -- HumOntology &gt;&gt; nounReferences</h3><pre>nounReferences   "(self nounReferences ) add: ( aNounString -&gt; aFrameLine )."   ^ nounReferences ifNil: [ nounReferences := Set new. ].</pre><h3>Hum-Language -- HumOntology &gt;&gt; nounSubtypes</h3><pre>nounSubtypes   "This instance variable is a map, a set of associations ( aSuperType -&gt; aSubType )."   "(self nounSubtypes) add: ( theSuperType -&gt; theNoun)."   ^ nounSubtypes ifNil: [ nounSubtypes := Set new.].</pre><h3>Hum-Language -- HumOntology &gt;&gt; nounSynonyms</h3><pre>nounSynonyms   "(self nounSynonyms) add: ( theSynonym -&gt; theNoun)."   ^nounSynonyms ifNil: [  nounSynonyms := Set new ].</pre><h3>Hum-Language -- HumOntology &gt;&gt; nouns</h3><pre>nouns   "This instance variable is the set of all nouns that have been defined so far."   ^nouns ifNil: [ nouns := Set new.].   </pre><h3>Hum-Language -- HumOntology &gt;&gt; nounsInStatement:</h3><pre>nounsInStatement: aHumStatement    "Return the (known) nouns found in the statement."   | tokens statement statementNouns nounSet |   "Forgive a nil statement. (Sometimes an instruction line has no statement.)"   aHumStatement ifNil: [ ^OrderedCollection new ].   "Forgive a string instead of a statement."   statement := aHumStatement.   (statement isKindOf: String) ifTrue: [ statement := HumStatement from: aHumStatement ].   self assert: ( statement isKindOf: HumStatement ).      tokens := statement tokens.   nounSet := self nouns copy.   statementNouns := tokens select: [ :token | nounSet includes: token ].   "TODO: Detect entity-attribute noun-phrase. Example: recipe`s bake-time."   ('*`s*' match: statement source)       ifTrue: [ | pairs | pairs := (self getEntityAttributePhraseFromStatement: statement).         "Remove nouns in each pair from the prior set."         pairs do: [ :pair |             | entity attribute |            entity := HumCalculator given: pair extractUpto: ' '.            attribute := HumCalculator given: pair extractAfter: ' '.            statementNouns remove: entity ifAbsent: [].            statementNouns remove: attribute ifAbsent: [].            statementNouns add: pair.             ].         ].   "TODO: Technical strategy for dealing with explicit constants in caller code."   "TODO: Detect quoted strings as nouns? -- (Caller side)"   "TODO: Detect measurements as nouns? -- (Caller side)"   "TODO: Detect names as nouns? -- (Caller side) "   ^statementNouns.   </pre><h3>Hum-Language -- HumOntology &gt;&gt; parseFrameLine:keywords:</h3><pre>parseFrameLine: frameLine keywords: keywords   "Parse the frameLine -- Return a list of token-type pairs: ( token -&gt; tokenType ).   TODO: Fix this up so that it returns comment and annotation as types."   | whitespace punctuation quote tokens tokenTypePairs tokenType i |   whitespace := String space, String tab, String crlf.   quote := $' asString.   punctuation := '~!@#$%^&*()_+`={}|[]\:";&lt;&gt;?,./', quote.   "Note: Preserve uppercase in tokens so that first word of a sentence is capitalized."   tokens := frameLine source  findTokens: ( punctuation, whitespace ) keep: punctuation.   tokenTypePairs := OrderedCollection new.   "QUESTION: Is the role-label part of the statement?    (I think it is part of an instruction, but the statement is separated.)"   i := 1.   [ i &lt;= tokens size ]         whileTrue: [          | token |         token := tokens at: i.         tokenType := #word.         ( self isNoun: token ) ifTrue: [ tokenType := #noun ].         ( keywords include: token ) ifTrue: [ tokenType := #keyword ].         ( punctuation includes: (token at: 1) )             ifTrue: [ tokenType := #punctuation. "Until proven otherwise."               "Does the source have a comment?"               (((token at: 1) = '(') and: ['*(*)*' match: (frameLine source) ] )                  ifTrue: [ "Advance index to closing parend"                     | commentString |                     commentString := '('.                     [ i &lt;= (tokens size) and:[( token at: 1) =')']]                         whileFalse: [ i := i+1. token := tokens at: i. commentString := commentString, ' ', token. ].                        token := commentString.                        tokenType := #comment.                        ].                "Does the source have annotation?"               (((token at: 1) = '[') and: ['*[*]*' match: (frameLine source) ] )                  ifTrue: [ "Advance index to closing parend"                     | annotationString |                     annotationString := '['.                     [ i &lt;= (tokens size) and: [( token at: 1) =']']]                         whileFalse: [ i := i+1. token := tokens at: i. annotationString := annotationString, ' ', token. ].                        token := annotationString.                        tokenType := #annotation.                        ].                ].         tokenTypePairs add: ( token -&gt; tokenType ).         ].   ^ tokenTypePairs.</pre><h3>Hum-Language -- HumOntology &gt;&gt; parseStatement:triggerWords:keywords:</h3><pre>parseStatement: aHumStatement triggerWords: triggerWords keywords: keywords    "Parse the statement -- Return a list of token-type pairs: ( token -&gt; tokenType ).   triggerWords are 'if else for-each' when they appear as first word.    TODO: Fix this up so that it returns comment and annotation as types."   |  whitespace punctuation quote tokens tokenTypes tokenType firstToken |   self assert: (triggerWords isKindOf: String) not.   self assert: (keywords isKindOf: String) not.   whitespace := Character separators.   quote := $' asString.   punctuation := '~!@#$%^&*()_+`={}|[]\:";&lt;&gt;?,./', quote.   "TODO: Scan to detect and remove strings delimited by quote or double-quote."   (aHumStatement source includes: '"') ifTrue: [Error signal: 'Strings as tokens is not implemented yet.'].   "Note: Preserve uppercase in tokens so that first word of a sentence is capitalized."   tokens := aHumStatement source  findTokens: ( punctuation, whitespace ) keep: punctuation.   tokenTypes := OrderedCollection new.   "QUESTION: Is the role-label part of the statement?    (I think it is part of an instruction, but the statement is separated.)"   firstToken := true.   tokens       do: [ :token |          tokenType := #word.         ( self isNoun: token ) ifTrue: [ tokenType := #noun ].         ( firstToken and: [triggerWords include: (token asLowercase)]) ifTrue: [ tokenType := #keyword ].         ( (firstToken not) and: [keywords include: (token asLowercase)]) ifTrue: [ tokenType := #keyword ].         ( punctuation includes: (token at: 1) ) ifTrue: [tokenType := #punctuation ].         ( token isAllDigits ) ifTrue: [ tokenType := #number. ].         tokenTypes add: ( token -&gt; tokenType ).         firstToken := false.         ].   "TODO: Detect measurement pattern: 'number unit-of-measure' "   ^ tokenTypes.</pre><h3>Hum-Language -- HumOntology &gt;&gt; planFrames</h3><pre>planFrames   | planFrames |   planFrames := Set new.   ( self framesByIdentifier )      keysAndValuesDo:  [ :key :value |          (value isKindOf: HumFrame4Plan)  ifTrue: [ planFrames add: value ].         ].   ^planFrames </pre><h3>Hum-Language -- HumOntology &gt;&gt; printOn:</h3><pre>printOn: aStream   aStream nextPutAll: (self asString).</pre><h3>Hum-Language -- HumOntology &gt;&gt; projectValuesOf:from:</h3><pre>projectValuesOf: aSetOfAssociations from: aKey   "encapsulate a bit of recurring code"   | resultSet |   self assert: ( aSetOfAssociations isKindOf: Collection ).   resultSet := Set new.   aSetOfAssociations do: [ :map | ( map key = aKey) ifTrue: [resultSet add: (map value)] ].   ^resultSet.</pre><h3>Hum-Language -- HumOntology &gt;&gt; roleActions</h3><pre>roleActions   "This instance variable is a map, a set of associations  ( role -&gt; actionStatement ) "   ^roleActions ifNil: [ roleActions := Set new.]</pre><h3>Hum-Language -- HumOntology &gt;&gt; roles</h3><pre>roles   "This instance variable contains the set of all roles that have been defined so far."   ^roles ifNil: [ roles := Set new.].</pre><h3>Hum-Language -- HumOntology &gt;&gt; setAutomaticSupertypeForNoun:</h3><pre>setAutomaticSupertypeForNoun: aNoun    "If a hyphenated nouns ends with the name of another noun,    it is automately a subtype of the other noun."   | tokens suffix |   "See if there is a hyphen in the noun."   tokens := aNoun findTokens: '-'.   ( tokens size &gt; 1 ) ifFalse: [^self].      "See if the last token is currently a noun."   suffix := tokens last.   (self isEntity: suffix ) ifFalse: [^self].     "The last token is currently a noun, so make this noun a subtype."   self nounSubtypes add: ( suffix -&gt; aNoun ).</pre><h3>Hum-Language -- HumOntology &gt;&gt; singularFormOfNoun:</h3><pre>singularFormOfNoun: aNoun    "If noun ends in 's'  remove the 's'.  Crude."   | s singular calc |   self assert: ( aNoun isKindOf: String ).      s := aNoun asLowercase.      "Following is first approximation.    TODO: Deal with other plural forms."   calc := HumCalculator new.   calc cases;      when: [ (s endsWith: 's' ) not] then: [ singular := s ];         "Following cases end in 's'. "      when: [ s endsWith: 'ss' ] then: [ singular := s ];      when: [ s endsWith: 'ies' ] then: [ singular :=  (s copyFrom: 1 to: (s size-3)),'y' ];      when: [ s endsWith: 'sses' ] then: [ singular :=  (s copyFrom: 1 to: (s size-2)) ];      otherwise: [  singular :=  (s copyFrom: 1 to: (s size-1)) ].   ^singular.   </pre><h3>Hum-Language -- HumOntology &gt;&gt; storeFrame:</h3><pre>storeFrame: aFrame    "Store this frame in the ontology.   The frame may be stored even if it has errors.   "   | primaryKey frameName |   self assert: (aFrame isKindOf: HumFrame ).   "If the frame does not have an ID (serial-number) give it one."   "The title of the frame can serve to index it but cannot be used to ID it       because the title can be changed by the user          while the intent of the frame remains the same."   primaryKey := aFrame uniqueIdentifier.   ( self framesByIdentifier ) at: primaryKey put: aFrame.      "Also enable caller to fetch a frame by its name."   frameName := aFrame frameName.   ( self framesByName ) at: frameName put: aFrame.      "Also enable caller to fetch frames by role."   ( aFrame isKindOf: HumFrame4Action )       ifTrue: [self indexRole: (aFrame role) action: aFrame actionStatement.].   "Enable caller to fetch vignettes by context-name."   ( aFrame isKindOf: HumFrame4Vignette )      ifTrue: [self addVignette: aFrame toContext: aFrame vignetteContext ].         "Also enable caller to fetch frame collection without any keys."   ( self frames ) add: aFrame.      </pre><h3>Hum-Language -- HumOntology &gt;&gt; title</h3><pre>title   ^ title ifNil: [ title :=  (self fromFile), ' -- No title yet.'. ].</pre><h3>Hum-Language -- HumOntology &gt;&gt; title:</h3><pre>title: aString    title := aString</pre><h3>Hum-Language -- HumOntology &gt;&gt; view</h3><pre>view   ^viewer ifNil: [ viewer := HumOntologyViewer ontology: self. ].</pre><h3>Hum-Language -- HumOntology &gt;&gt; vignettesForContext:</h3><pre>vignettesForContext: aRequestedContext   | vignettes calc requestedContext |   self assert: ( aRequestedContext isKindOf: String ).   "DEBUG ('*activity*' match: aRequestedContext ) ifTrue: [ self halt. ]."   requestedContext := self cleanKey: aRequestedContext.   calc := HumCalculator new.   vignettes := OrderedCollection new.   (self contextVignettes )      do: [ :contextVignette |         | contextName contextFrame  |         self assert: (contextVignette isKindOf: Association ).         contextName  := contextVignette key.         contextFrame := contextVignette value.         ( calc string: contextName isLike: requestedContext ignore: ' .' ) ifTrue: [ vignettes add: contextFrame ].         ].   ^vignettes.</pre><h3>Hum-Language -- HumOntology &gt;&gt; xparseString:keywords:</h3><pre>xparseString: aStatementString keywords: keywords    "Coding experiment to see if I can tweak existing code to handle quoted strings."   "Parse the statement string -- Return a list of token-type pairs: ( token -&gt; tokenType ).   TODO: Fix this up so that it returns comment and annotation as types."   | whitespace punctuation quote tokens tokenTypes tokenType doubleQuote isQuoteSeen |   whitespace := '          '.   quote := $' asString.   doubleQuote := $" asString.   isQuoteSeen := false.   "Note: Preserve uppercase in tokens so that first word of a sentence is capitalized."   punctuation := '~!@#$%^&*()_+`={}|[]\:;&lt;&gt;?,./', quote, doubleQuote.   tokens := aStatementString  findTokens: ( punctuation, whitespace ) keep: punctuation.   tokenTypes := OrderedCollection new.   "QUESTION: Is the role-label part of the statement?    (I think it is part of an instruction, but the statement is separated.)"   tokens       do: [ :token |          tokenType := #word. "default"         ( self isNoun: token ) ifTrue: [ tokenType := #noun ].         ( keywords include: token ) ifTrue: [ tokenType := #keyword ].         ( punctuation includes: (token at: 1) ) "WARNING: A sequence of punctuation is single token."             ifTrue: [tokenType := #punctuation ].         ( token isAllDigits ) ifTrue: [ tokenType := #number. ].         ( token = quote or: [token = doubleQuote] ) ifTrue: [tokenType := #quote. isQuoteSeen := true. ].         tokenTypes add: ( token -&gt; tokenType ).         ].   "Collapse quoted string."   isQuoteSeen       ifTrue: ["Collapse the tokens in the quoted string into a single token."         self shouldBeImplemented.         ].   "TODO: Detect measurement pattern: 'number unit-of-measure' "   ^ tokenTypes.</pre><h3>Hum-Language -- HumOntology &gt;&gt; yesNoun:isAKindOf:</h3><pre>yesNoun: aSubtype isAKindOf: aSuperType    "Is the noun a subtype of the given supertype? Used when matching action statements."   | result |   "Check for special case:   Action statement definitions in the base ontology may include 'entity' as a noun.   The noun 'entity' is not in the base ontology because it would cause too much clutter.   Example: 'New entity.' action statements.   "   (aSuperType = 'entity')      ifTrue: [ ^self isEntity: aSubtype ].   "Normal case:"   result := self nounSubtypes includes: ( aSuperType -&gt; aSubtype  ).   ^result.</pre><h3>Hum-Language -- HumOntology &gt;&gt; yesRole:hasAction:</h3><pre>yesRole: aRole hasAction: aSource   "Is the given action defined for the given role?"   | actionCandidate |   "Convert String to Statement, if needed."   (aSource isKindOf: String)      ifTrue: [actionCandidate := HumStatement source: aSource].   (aSource isKindOf: HumStatement)      ifTrue: [actionCandidate := aSource].   self assert: (actionCandidate isKindOf: HumStatement).       ^(self actionsOf: (aRole capitalized ) ) anySatisfy: [ :statement |        actionCandidate matchesTemplateStatement: statement inOntology: self.       ] .</pre><h3>Hum-Language -- HumParser2 &gt;&gt; alphanumeric:</h3><pre>alphanumeric: aString    "Match that part of the string that is alpha-numeric"   | empty result |   empty := ''.   result := empty.   aString      do: [:ch |         ( ch isLetter or: [ (ch = $ ) or: [ch isDigit]  ])            ifTrue: [ result := result, ch asString. ]            ifFalse: [^result].         ].   ^result.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; checkbox:</h3><pre>checkbox: aSource   "Does the current source start with a check box widget?"   | empty s |   empty := ''.   (aSource size &gt;= 3) ifFalse: [^empty].   s := aSource copyFrom: 1 to: 3.   ('[#]' matches: s)       ifTrue: [^s]      ifFalse: [^empty].   </pre><h3>Hum-Language -- HumParser2 &gt;&gt; checkbox:produce:</h3><pre>checkbox: aSource produce: aProductionBlock   "Does the current source start with a check box widget?"   | empty s |   empty := ''.   (aSource size &gt;= 3) ifFalse: [^empty].   s := aSource copyFrom: 1 to: 3.   ('[#]' matches: s)       ifTrue: [          | ch x |         ch := (s at: 2).         "A check box must contain a single letter.          (Otherwise the name will not be HTML/CSS compatible)"         (ch isLetter)             ifFalse: [Error signal: 'A checkbox must contain a single letter.'].         x := ch asString.         self push: (aProductionBlock value: x ). ^s]      ifFalse: [^empty].   </pre><h3>Hum-Language -- HumParser2 &gt;&gt; digits:</h3><pre>digits: source    "Match leading part of source that is digits"   | empty result |   empty := ''.   result := empty.   source      do: [:ch |         ( ch isDigit)            ifTrue: [ result := result, ch asString. ]            ifFalse: [^result].         ].   ^result.   </pre><h3>Hum-Language -- HumParser2 &gt;&gt; generateChoicesFor:inOntology:</h3><pre>generateChoicesFor: anAttributeName inOntology: aHumOntology    "Generate HTML choice tags"   | html choices |   html := String new.   choices := aHumOntology categoriesOf: anAttributeName.   choices      do: [:choice |         html := html, String cr, '  &lt;option name="',choice,'"&gt;',choice,'&lt;/option&gt;'.         ].   ^html.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; generatedCode</h3><pre>generatedCode   ""   | code |   code := ''.   (self stack)       do: [:item | code := code, item. ].   ^code.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; ignoreNext</h3><pre>ignoreNext   ^ignoreNext ifNil: [ ignoreNext := false. ].</pre><h3>Hum-Language -- HumParser2 &gt;&gt; ignoreNext:</h3><pre>ignoreNext: aBoolean    ignoreNext := aBoolean</pre><h3>Hum-Language -- HumParser2 &gt;&gt; markupSyntax</h3><pre>markupSyntax   "Experimental BNF syntax"   | markup heading text emphasis bold widget alphanum italic underline headingPrefix matched  pageWidget attributeWidget x ordinaryText textAreaWidget number d blank list listPrefix humNoun p t |         markup := [:s | self match: s oneOf: { heading. list. emphasis. widget. alphanum. }  ].      heading := [:s | self match: s sequence:{ headingPrefix. text. }                         produce:[|n| n := p size asString. self pop:2; push: ('&lt;h',n,'&gt;',t,'&lt;/h',n,'&gt;')] ].   "x is the matched text -- see alphanum below"   "n is the size of the match -- see _prefix below"   headingPrefix := [ :s | p := self match: s oneOf: { '!!!!!'. '!!!!'. '!!!'.  '!!'. '!'. } ].   list := [:s | self match: s sequence:{listPrefix. text.}                     produce: [ |n| n := p size asString.  self pop:2; push:('&lt;item',n,'&gt;',t,'&lt;/item',n,'&gt;')] ].   listPrefix := [ :s | p := (self match: s oneOf: { '-----'. '----'. '---'. '--'. '-'. } ) ].   text := [ :s | t := self match: s repeat: { ordinaryText. emphasis. } ].   ordinaryText := [:s | x := self match: s repeat: { alphanum. '.'. ','. '-'. '!'. '?'. ':'. } ].      alphanum := [ :s | x := self alphanumeric: s. ]. "Produces x."   number := [:s | d := self digits: s ].  "Produces d."   blank := [:s | self spaces: s ].      emphasis := [:s | self match: s oneOf: { bold. italic. underline. } ].   bold := [ :s | self match: s      sequence:{ '*'. alphanum. '*'.} produce:[self pop:3; push:('&lt;b&gt;',x,'&lt;/b&gt;')] ].      italic := [ :s | self match: s    sequence:{ '~'. alphanum. '~'.} produce:[self pop:3; push:('&lt;i&gt;',x,'&lt;/i&gt;')] ].      underline := [ :s | self match: s sequence:{ '_'. alphanum. '_'.} produce:[self pop:3; push:('&lt;u&gt;',x,'&lt;/u&gt;')] ].      widget := [:s | self match: s oneOf: { pageWidget. attributeWidget. textAreaWidget. } ].   humNoun := [:s | x := (self noun: s ) ].   pageWidget := [:s | self match: s sequence: {'[page:'. alphanum. ']'. }                              produce: [self pop:3; push:('&lt;a href="',x asCamelCase,'"&gt;',x,'&lt;/a&gt;')] ].   attributeWidget := [:s| self match: s sequence: {'['. humNoun. ']'.}                                             produce: [self pop:3; push:('&lt;input type="text" name="',x,'"&gt;&lt;/input&gt;')]].   textAreaWidget := [:s | self match: s sequence: { '['. humNoun. blank. number. ']'}                                 produce: [self pop:5; push:('&lt;textarea rows="',d,'" name="',x,'"&gt;&lt;/textarea&gt;')] ].      ^markup.   </pre><h3>Hum-Language -- HumParser2 &gt;&gt; markupSyntaxWithOntology:</h3><pre>markupSyntaxWithOntology: anOntology   "Experimental BNF syntax"   | markup heading text emphasis bold widget alphanum italic underline headingPrefix matched  pageWidget attributeWidget x ordinaryText textAreaWidget number d blank list listPrefix humNoun p t viewName v paneWidget code ordinaryLine url u linkWidget entityAttributeWidget entity eName attribute aName checkboxWidget radioWidget comment category categoryWidget |      markup := [:s | self match: s oneOf: { heading. list. ordinaryLine.  }  ].   ordinaryLine := [:s | self match: s repeat: {  emphasis. widget. ordinaryText. comment. }].      heading := [:s | self match: s sequence:{ headingPrefix. text. }                         produce:[|n| n := p size asString. self push: ('&lt;h',n,'&gt;',t,'&lt;/h',n,'&gt;')] ].   "x is the matched text -- see alphanum below"   "n is the size of the match -- see _prefix below"   headingPrefix := [ :s | p := self match: s oneOf: { '!!!!!'. '!!!!'. '!!!'.  '!!'. '!'. } ].      list := [:s | self match: s sequence:{listPrefix. text.}                     produce: [:z | |n| n := p size asString.                                         self pop:1;                                              push:('&lt;item',n,'&gt;&bull; ',t,'&lt;/item',n,'&gt;')] ].   listPrefix := [ :s | p := (self match: s oneOf: { '-----'. '----'. '---'. '--'. '-'. } ) ].   "TODO: FIGURE OUT HOW TO DO AN ORDERED (NUMBERED) LIST."   text := [ :s | t := self match: s repeat: { ordinaryText. emphasis. } ].   ordinaryText := [:s | x := self text: s "This does a push." ].   comment := [:s | self match: s sequence: { '('. ordinaryText. ')' } produce: [:z| self pop: 1; push: z ] ].      alphanum := [ :s | x := self alphanumeric: s. ]. "Produces x."   number := [:s | d := self digits: s ].  "Produces d."   blank := [:s | self spaces: s ].      emphasis := [:s | self match: s oneOf: { bold. italic. underline. } ].   bold := [ :s | self match: s      sequence:{'*'. alphanum. '*'.} produce:[:z| self push:('&lt;b&gt;',x,'&lt;/b&gt;')] ].      italic := [ :s | self match: s    sequence:{'~'. alphanum. '~'.} produce:[:z| self push:('&lt;i&gt;',x,'&lt;/i&gt;')] ].      underline := [ :s | self match: s sequence:{'_'. alphanum. '_'.} produce:[:z| self push:('&lt;u&gt;',x,'&lt;/u&gt;')] ].      widget := [:s | self match: s oneOf: { pageWidget. paneWidget. linkWidget.                                                          checkboxWidget. radioWidget. categoryWidget.                                                         attributeWidget. textAreaWidget.  entityAttributeWidget. } ].   humNoun := [:s | x := (self noun: s ) ].   entity := [:s | eName := (self ontology: anOntology isEntity: s)].   attribute := [:s | aName := (self ontology: anOntology isAttribute: s)].   category := [:s | aName := (self ontology: anOntology isCategory: s)].   attributeWidget := [:s| self match: s sequence: {'['. humNoun. ']'.}                                             produce: [:z | self push:('&lt;input type="text" name="',x,'" value=""/&gt;')]].   entityAttributeWidget := [:s| self match: s sequence: {'['. entity. blank. attribute. ']'.}                            produce: [:z | self push:('&lt;input type="text" name="',eName,':',aName,'" value=""/&gt;')]].                        "Note the name='...' value must be HTML, CSS, jQuery and HumBlackboard compatible "   textAreaWidget := [:s | self match: s sequence: { '['. humNoun. blank. number. ']'}                                 produce: [:z |self push:('&lt;textarea rows="',d,'" name="',x,'"&gt;&lt;/textarea&gt;')] ].  checkboxWidget := [:s | self checkbox: s                                  produce: [:z | self pushIgnore: '&lt;input type="checkbox" name="',z,'"/&gt;']].  radioWidget := [:s | self radioButton: s                              produce: [:z | self pushIgnore: '&lt;input type="radio" name="',z,'"/&gt;']].   categoryWidget := [:s| self match: s sequence: {'['. category. ']'.}                                         produce: [:z | "Generate the choice tag code."                                                    code := self generateChoicesFor: aName inOntology: anOntology.                                                  self push:('&lt;select name="',aName,'"&gt;',code,'&lt;/select&gt;')]].   pageWidget := [:s | self match: s sequence: {'[page:'. alphanum. ']'. }                              produce: [:z |self push:('&lt;a href="',x asCamelCase,'"&gt;',x,'&lt;/a&gt;')] ].  viewName := [:s | self ontology: anOntology isViewName: s                                               produce: [:z | v := z.]].   paneWidget := [:s | self match: s sequence: {'[pane:'. viewName. ']'. }                                       produce: [:z | self pop: 1; push: ('&lt;div name="',v trimBoth,'"&gt;'                                                                  ,(self ontology: anOntology produceView: v)                                                                  ,'&lt;/div&gt;')]].   url := [:s | u := self url: s ].   linkWidget := [:s | self match: s sequence: {'[link:'. alphanum. '|'. url. ']' }                                       produce: [:z | self push:'&lt;a href="',u,'"&gt;',x trimBoth,'&lt;/a&gt;'] ].      ^markup.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; markupSyntaxWithOntology:blackBoard:</h3><pre>markupSyntaxWithOntology: anOntology blackBoard: aBlackBoard   "Experimental BNF syntax"   | markup heading text emphasis bold widget alphanum italic underline headingPrefix matched  pageWidget attributeWidget x ordinaryText textAreaWidget number d blank list listPrefix humNoun p t viewName v paneWidget code ordinaryLine url u linkWidget entityAttributeWidget entity eName attribute aName checkboxWidget radioWidget comment category categoryWidget |      markup := [:s | self match: s oneOf: { heading. list. ordinaryLine.  }  ].   ordinaryLine := [:s | self match: s repeat: {  emphasis. widget. ordinaryText. comment. }].      heading := [:s | self match: s sequence:{ headingPrefix. text. }                         produce:[|n| n := p size asString. self push: ('&lt;h',n,'&gt;',t,'&lt;/h',n,'&gt;')] ].   "x is the matched text -- see alphanum below"   "n is the size of the match -- see _prefix below"   headingPrefix := [ :s | p := self match: s oneOf: { '!!!!!'. '!!!!'. '!!!'.  '!!'. '!'. } ].      list := [:s | self match: s sequence:{listPrefix. text.}                     produce: [:z | |n| n := p size asString.                                         self pop:1;                                              push:('&lt;item',n,'&gt;&bull; ',t,'&lt;/item',n,'&gt;')] ].   listPrefix := [ :s | p := (self match: s oneOf: { '-----'. '----'. '---'. '--'. '-'. } ) ].   "TODO: FIGURE OUT HOW TO DO AN ORDERED (NUMBERED) LIST."   text := [ :s | t := self match: s repeat: { ordinaryText. emphasis. } ].   ordinaryText := [:s | x := self text: s "This does a push." ].   comment := [:s | self match: s sequence: { '('. ordinaryText. ')' } produce: [:z| self pop: 1; push: z ] ].      alphanum := [ :s | x := self alphanumeric: s. ]. "Produces x."   number := [:s | d := self digits: s ].  "Produces d."   blank := [:s | self spaces: s ].      emphasis := [:s | self match: s oneOf: { bold. italic. underline. } ].   bold := [ :s | self match: s      sequence:{'*'. alphanum. '*'.} produce:[:z| self push:('&lt;b&gt;',x,'&lt;/b&gt;')] ].      italic := [ :s | self match: s    sequence:{'~'. alphanum. '~'.} produce:[:z| self push:('&lt;i&gt;',x,'&lt;/i&gt;')] ].      underline := [ :s | self match: s sequence:{'_'. alphanum. '_'.} produce:[:z| self push:('&lt;u&gt;',x,'&lt;/u&gt;')] ].      widget := [:s | self match: s oneOf: { pageWidget. paneWidget. linkWidget.                                                          checkboxWidget. radioWidget. categoryWidget.                                                         attributeWidget. textAreaWidget.  entityAttributeWidget. } ].   "humNoun := [:s | x := (self noun: s ). self halt. ]."   entity := [:s | eName := (self ontology: anOntology isEntity: s)].   attribute := [:s | aName := (self ontology: anOntology isAttribute: s)].   category := [:s | aName := (self ontology: anOntology isCategory: s)].   attributeWidget := [:s| self match: s sequence: {'['. attribute. ']'.}                                             produce: [:z | "Get data from black board."                                             |data| data := aBlackBoard getEntityName: v attribute: aName.                                             self push:('&lt;input type="text" name="',x,'" value="',data,'"/&gt;')]].   entityAttributeWidget := [:s| self match: s sequence: {'['. entity. blank. attribute. ']'.}                            produce: [:z | self push:('&lt;input type="text" name="',eName,':',aName,'" value=""/&gt;')]].                        "Note the name='...' value must be HTML, CSS, jQuery and HumBlackboard compatible "   textAreaWidget := [:s | self match: s sequence: { '['. attribute. blank. number. ']'}                                 produce: [:z |self push:('&lt;textarea rows="',d,'" name="',x,'"&gt;&lt;/textarea&gt;')] ].  checkboxWidget := [:s | self checkbox: s                                  produce: [:z | self pushIgnore: '&lt;input type="checkbox" name="',z,'"/&gt;']].  radioWidget := [:s | self radioButton: s                              produce: [:z | self pushIgnore: '&lt;input type="radio" name="',z,'"/&gt;']].   categoryWidget := [:s| self match: s sequence: {'['. category. ']'.}                                         produce: [:z | "Generate the choice tag code."                                                    code := self generateChoicesFor: aName inOntology: anOntology.                                                  self push:('&lt;select name="',aName,'"&gt;',code,'&lt;/select&gt;')]].   pageWidget := [:s | self match: s sequence: {'[page:'. alphanum. ']'. }                              produce: [:z |self push:('&lt;a href="',x asCamelCase,'"&gt;',x,'&lt;/a&gt;')] ].  viewName := [:s | self ontology: anOntology isViewName: s                                               produce: [:z | v := z.]].   paneWidget := [:s | self match: s sequence: {'[pane:'. viewName. ']'. }                                       produce: [:z | self pop: 1;                                                  push: ('&lt;div name="',v trimBoth,'"&gt;'                                                       ,(self ontology: anOntology blackBoard: aBlackBoard produceView: v)                                                       ,'&lt;/div&gt;')]].   url := [:s | u := self url: s ].   linkWidget := [:s | self match: s sequence: {'[link:'. alphanum. '|'. url. ']' }                                       produce: [:z | self push:'&lt;a href="',u,'"&gt;',x trimBoth,'&lt;/a&gt;'] ].      ^markup.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; match:oneOf:</h3><pre>match: source oneOf: anArrayOfSyntaxThings   | result empty |   empty := ''.   result := empty.   anArrayOfSyntaxThings      do: [:syntaxThing |         result := self match: source with: syntaxThing.         (result = empty ) ifFalse: [^result].         ].   ^result.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; match:oneOf:produce:</h3><pre>match: source oneOf: anArrayOfSyntaxThings produce: productionBlock   "Does current source match array? If so, run the production."   | result  empty |   self assert: ( productionBlock isKindOf: BlockClosure ).   empty := ''.   result := self match: source oneOf: anArrayOfSyntaxThings.   (result = empty) ifFalse: [ productionBlock value: result ].   ^result.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; match:repeat:</h3><pre>match: source repeat: anArrayOfSyntaxThings   "Does current source match array?"   | empty result nextSource  calc nextResult |   empty := ''.   result := empty. "By default if nothing matches front of source"   (source = empty)       ifTrue: [Error signal: 'Why are you calling repeat with empty source?'].   ( anArrayOfSyntaxThings isEmpty )      ifTrue: [Error signal: 'Why are you calling repeat with empty syntax?'].         anArrayOfSyntaxThings      do: [:syntaxThing|         result := self match: source with: syntaxThing.         (result = empty)             ifFalse: ["There was a match at current front. Move along now."               nextSource := HumCalculator substringFrom: source after: result.               (nextSource = empty)                   ifTrue: ["Hurray, we matched the whole source!"                     ^result].            "Call myself recursively."               nextResult := self match: nextSource repeat: anArrayOfSyntaxThings.               result := result, nextResult.               (result size &gt; 99 )                   ifTrue: [Error signal: 'Result looks too long for current debug mode.'].               ^result.                ].         ].   "If we fall through we've matched nothing"   self assert: ( result = empty ).   ^result.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; match:sequence:</h3><pre>match: source sequence: anArrayOfSyntaxThings   "Does current source match array?"   | empty result nextSource nextArray syntaxThing calc nextResult |   empty := ''.   (source = empty) ifTrue: [^''].   ( anArrayOfSyntaxThings isEmpty )      ifTrue: [^''].   syntaxThing := anArrayOfSyntaxThings at: 1.   result := self match: source with: syntaxThing.   (result = empty) ifTrue: [^result].   calc := HumCalculator new.   nextSource := (calc given: source extractAfter: result).    nextArray := anArrayOfSyntaxThings copyFrom: 2 to: anArrayOfSyntaxThings size.  (nextSource = empty) ifTrue: [^result].  (nextArray isEmpty) ifTrue: [^result].  nextResult := self match: nextSource sequence: nextArray.   (nextResult = empty) ifTrue: [^empty].   result := result, nextResult.   result size &gt; 99 ifTrue: [ Error signal: 'Result looks too long for current tests.'].   ^result.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; match:sequence:produce:</h3><pre>match: source sequence: anArrayOfSyntaxThings produce: productionBlock   "Does current source match array? If so, run the production."   | result  empty |   self assert: ( productionBlock isKindOf: BlockClosure ).   empty := ''.   result := self match: source sequence: anArrayOfSyntaxThings.   (result = empty) ifFalse: [ productionBlock value: result ].   ^result.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; match:with:</h3><pre>match: aString with: syntaxThing    "Does aString match with syntaxThing?"   | result empty |   empty := ''.   result := empty. "Null result is EMPTY string"      ( syntaxThing isKindOf: String )      ifTrue: [         ( (aString trimLeft) beginsWith: syntaxThing )             ifTrue: [  ^ syntaxThing ]            ifFalse: [ ^ empty ]          ].   ( syntaxThing isKindOf: BlockClosure ) ifFalse: [Error signal: 'Should be block closure in this context'].   result := syntaxThing value: aString.   (result = empty) ifFalse: [ ].   ^result.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; noun:</h3><pre>noun: source    "Match that part of the string that might name a Hum noun"   | empty result |   empty := ''.   result := empty.   source      do: [:ch |         ( ch isLetter or: [ (ch = $- ) or: [ch isDigit]  ])            ifTrue: [ result := result, ch asString. ]            ifFalse: [               "A Hum noun must start with a letter."               ((result at: 1) isLetter)                   ifFalse: [Error signal: 'A Hum noun must start with a letter'].               "A Hum noun must be more than a single letter."               (result size &gt; 1)                   ifFalse: [Error signal: 'A Hum noun must be more than a single letter.'].               ^result               ].         ].   ^result.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; ontology:blackBoard:produceView:</h3><pre>ontology: aHumOntology blackBoard: aBlackBoard produceView: aViewName    "Produce the HTML for the given view frame."   | parser syntax frame lines code |   "Set up an indepent parser so that we don't interfere with caller."   parser := self class new.   frame := aHumOntology getViewFrame: aViewName.   lines := frame frameLines.   (lines isEmpty) ifTrue: [ Error signal: 'View is empty or name is wrong'].   syntax := parser markupSyntaxWithOntology: aHumOntology blackBoard: aBlackBoard.   "Pass the view name through -- is also default entity-name."   aBlackBoard defaultEntity: aViewName trimBoth.   lines      do: [:frameLine |         | s |         s := frameLine source.         parser push: (String cr,'&lt;br/&gt;&nbsp; ').         (s trimBoth = '')             ifTrue: [ parser push: ('').]            ifFalse: [parser match: s with: syntax.].         ].   ^code := parser generatedCode .   </pre><h3>Hum-Language -- HumParser2 &gt;&gt; ontology:isAttribute:</h3><pre>ontology: aHumOntology isAttribute: aSource    "Does the current source, upto some delimiter, match an ontology attribute name?"   | parser result empty  |   parser := self class new.   empty := ''.   result := empty.   "An attribute name must be alphanumeric"   result := parser noun: aSource.   (result = empty)      ifTrue: [ Error signal: 'Expected a noun, but found:"',aSource ].   (aHumOntology isAttribute: result)      ifTrue: [ "self push: result." ^result ]      ifFalse: [Error signal: result,' does not name an attribute.'].   ^result.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; ontology:isCategory:</h3><pre>ontology: aHumOntology isCategory: aSource    "Does the current source, upto some delimiter, match an ontology category name?"   | parser result empty  |   parser := self class new.   empty := ''.   result := empty.   "A category name must be alphanumeric"   result := parser noun: aSource.   (result = empty)      ifTrue: [ Error signal: 'Expected a noun, but found:"',aSource ].   (aHumOntology isCategory: result)      ifTrue: [ "self push: result." ^result ]      ifFalse: [^empty.].   Error signal: 'How did we get here?'.   ^result.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; ontology:isEntity:</h3><pre>ontology: aHumOntology isEntity: aSource    "Does the current source, upto some delimiter, match an ontology entity name?"   | parser result empty  |   parser := self class new.   empty := ''.   result := empty.   "An entity name must be alphanumeric"   result := parser noun: aSource.   (result = empty)      ifTrue: [ Error signal: 'Expected a noun, but found:"',aSource ].   (aHumOntology isEntity: result)      ifTrue: [ "self push: result." ^result ]      ifFalse: [Error signal: result,' does not name an entity.'].   ^result.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; ontology:isViewName:</h3><pre>ontology: aHumOntology isViewName: aSource    "Does the current source, upto some delimiter, match an ontology view name?"   | parser result empty alpha |   parser := self class new.   empty := ''.   result := empty.   "a view name must be alphanumeric"   alpha := [:s | parser alphanumeric: s ].   result := parser match: aSource repeat: { alpha. '-'.}.   (result = empty)      ifTrue: [ Error signal: 'Expected alphanumeric, but found:"',aSource ].   (aHumOntology isViewName: result)      ifTrue: [ self push: result. ^result ]      ifFalse: [Error signal: result,' does not name a view frame.'].   ^result.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; ontology:isViewName:produce:</h3><pre>ontology: aHumOntology isViewName: aSource produce: productionBlock    "Does the current source, upto some delimiter, match an ontology view name?    If so, produce the given production"   | result empty alpha |      empty := ''.   result := empty.   "a view name must be alphanumeric"   alpha := [:s | self alphanumeric: s ].   result := self match: aSource repeat: { alpha. '-'.}.   (result = empty)      ifTrue: [ Error signal: 'Expected alphanumeric, but found:"',aSource ].   (aHumOntology isViewName: result)      ifTrue: [ self push: (productionBlock value: result)]      ifFalse: [Error signal: result,' does not name a view frame.'].   ^result.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; ontology:produceView:</h3><pre>ontology: aHumOntology produceView: aViewName    "Produce the HTML for the given view frame."   | parser syntax frame lines code |   "Set up an indepent parser so that we don't interfere with caller."   parser := self class new.   frame := aHumOntology getViewFrame: aViewName.   lines := frame frameLines.   (lines isEmpty) ifTrue: [ Error signal: 'View is empty or name is wrong'].   syntax := parser markupSyntaxWithOntology: aHumOntology.   lines      do: [:frameLine |         | s |         s := frameLine source.         parser push: (String cr,'&lt;br/&gt;&nbsp; ').         (s trimBoth = '')             ifTrue: [ parser push: ('').]            ifFalse: [parser match: s with: syntax.].         ].   ^code := parser generatedCode .   </pre><h3>Hum-Language -- HumParser2 &gt;&gt; pop:</h3><pre>pop: aSmallInteger    (1 to: aSmallInteger)      do: [:i | (self stack) removeLast.]   </pre><h3>Hum-Language -- HumParser2 &gt;&gt; push:</h3><pre>push: aString    (self ignoreNext)       ifFalse: [(self stack) addLast: aString.]      ifTrue: [self ignoreNext: false.].   ^aString</pre><h3>Hum-Language -- HumParser2 &gt;&gt; pushIgnore:</h3><pre>pushIgnore: aString    (self stack) addLast: aString.   self ignoreNext: true.   ^aString</pre><h3>Hum-Language -- HumParser2 &gt;&gt; radioButton:produce:</h3><pre>radioButton: aSource produce: aProductionBlock   "Does the current source start with a radio button widget?"   | empty s |   empty := ''.   (aSource size &gt;= 3) ifFalse: [^empty].   s := aSource copyFrom: 1 to: 3.   ('(#)' matches: s)       ifTrue: [          | ch x |         ch := (s at: 2).         "A radio button must contain a single letter.          (Otherwise the name will not be HTML/CSS compatible)"         (ch isLetter)             ifFalse: [Error signal: 'A radio button must contain a single letter.'].         x := ch asString.         self push: (aProductionBlock value: x ). ^s]      ifFalse: [^empty].   </pre><h3>Hum-Language -- HumParser2 &gt;&gt; spaces:</h3><pre>spaces: source    "Match leading part of source that is digits"   | empty result |   empty := ''.   result := empty.   source      do: [:ch |         ( ch = Character space  or: [ ch = Character tab ] )            ifTrue: [ result := result, ch asString. ]            ifFalse: [^result].         ].   ^result.   </pre><h3>Hum-Language -- HumParser2 &gt;&gt; stack</h3><pre>stack   ^stack ifNil: [ stack := OrderedCollection new.]</pre><h3>Hum-Language -- HumParser2 &gt;&gt; text:</h3><pre>text: aString    "Return that part of string that contains no mark-up."   | empty result |   empty := ''.   result := empty.      aString      do: [:ch |         "Terminate on any character that indicates emphasis or widget."         ( '*~_[]()' includes: ch )            ifFalse: [ result := result, ch asString. ]            ifTrue: [^self push: result.].         ].   ^self push: result.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; top</h3><pre>top   | item |   item := (self stack) last.   ^item.</pre><h3>Hum-Language -- HumParser2 &gt;&gt; url:</h3><pre>url: source   "Does current source match a URL pattern?"   | alpha prefix server url result p x u nom parser |   parser := self class new.   alpha := [:s | parser alphanumeric: s ].   nom := [:s | parser match: s oneOf: { alpha. '-'. '_'.} ].   prefix := [:s | p := parser match: s oneOf: {'http://'. 'https://'. } ].   server := [:s | x := (parser match: s repeat: { nom. '.'. '/'. }) trimBoth ].   "Note: Calling trimBoth above might accidentally clean up a bad URL."   url := [:s | u := parser match: s sequence: { prefix. server. } produce: [:t | parser push:(p,x)] ].   result := parser match: source with: url.   ^result.</pre><h3>Hum-Language -- HumStatement &gt;&gt; =</h3><pre>= aStatement    ( aStatement isKindOf: String )  ifTrue: [ ^source sameAs: aStatement ].   ( aStatement isKindOf: HumStatement ) ifTrue: [ ^ source sameAs: aStatement source ].   ^self halt.</pre><h3>Hum-Language -- HumStatement &gt;&gt; asCamelCase</h3><pre>asCamelCase    "Convert this statement to camelCase."   | tokens code   first |   code := ''.   first := true.   tokens := (self source) findTokens: ' ,.-'.  "Do not inlude articles in the camel case."   (tokens reject: [:token | #( 'a' 'an' 'the' ) includes: (token asLowercase) ])      do: [ :token |            first ifTrue: [ code := code, token asLowercase .                              first := false.]                  ifFalse: [ code := code, (token capitalized) ].         ].      ^code</pre><h3>Hum-Language -- HumStatement &gt;&gt; asCamelCaseWithOntology:</h3><pre>asCamelCaseWithOntology: aHumOntology    "Convert this statement to camelCase."   | tokens code   first |      code := ''.   first := true.   tokens := (self source) findTokens: ' ,.-'.   (tokens reject: [:token | #('a' 'an' 'the') includes: token ] )      do: [ :token |            first ifTrue: [ code := code, token asLowercase .                  first := false.]               ifFalse: [ code := code, (token capitalized) ].         ].   "TODO: Deal with polymorphism by looking up the proper definition.   Can borrow algorithm from prior version of SimpleEnglish ?   However, by removing nouns from the camelCase, I could just let Java do the work.   BAD IDEA: Depending on Java would make the semantics target-language-dependent.   "   ^code</pre><h3>Hum-Language -- HumStatement &gt;&gt; asString</h3><pre>asString   ^ self source asString.</pre><h3>Hum-Language -- HumStatement &gt;&gt; delegateToTranslator</h3><pre>delegateToTranslator   Error signal: 'This statement function should be delegated to Ontology Translator (HumOntologyTranslator).'</pre><h3>Hum-Language -- HumStatement &gt;&gt; errors</h3><pre>errors   ^errors ifNil: [ errors := Set new.].</pre><h3>Hum-Language -- HumStatement &gt;&gt; hash</h3><pre>hash    "This HACK (which may be a bad idea) makes HumStatement hash the same as a matching string.   It makes set lookup work.   But maybe it makes some coding error too forgiven.   "   ^ ( source hash ).</pre><h3>Hum-Language -- HumStatement &gt;&gt; isConditional</h3><pre>isConditional   (source beginsWith: 'For ' ) ifTrue: [ ^true ].   ( source beginsWith: 'If ')   ifTrue: [ ^true ].   ( source beginsWith: 'ElseIf ')   ifTrue: [ ^true ].   ( source beginsWith: 'Else:') ifTrue: [ ^true ].   ^false.   </pre><h3>Hum-Language -- HumStatement &gt;&gt; isSatisfied:</h3><pre>isSatisfied: aBoolean    self assert: (aBoolean isKindOf: Boolean ).   isSatisfied := aBoolean.</pre><h3>Hum-Language -- HumStatement &gt;&gt; matchesCandidateStatement:inOntology:</h3><pre>matchesCandidateStatement: aCandidate inOntology: aHumOntology   "Does the candidate match me? (Candidate nouns might be subtypes of my nouns.)"   | statement candidateTokens myTokens calc |   calc := HumCalculator new.   calc cases;      when: [aCandidate isKindOf: HumStatement] then: [statement := aCandidate ];      when: [aCandidate isKindOf: String ] then: [ statement := HumStatement from: aCandidate. ];      otherwise: [ Error signal: 'expecting a statement type'].   (self source sameAs: statement source ) ifTrue: [^true]. "shortcut"   "Get tokens minus articles."   candidateTokens := ( statement tokens ) reject: [ :token | #('a' 'an' 'the') includes: token ] .   myTokens := ( self tokens ) reject: [ :token | #('a' 'an' 'the') includes: token ] .   "TODO: Parse allowing for quoted strings."   ( myTokens size = candidateTokens size ) ifFalse: [ ^false ].   "Is my noun a supertype of the argument`s noun?"   ( 1 to: (myTokens size) )      do: [ :x |         | myToken candidateToken |         myToken := myTokens at: x.         candidateToken := candidateTokens at: x.         ( myToken sameAs: candidateToken )            ifTrue: ["continue"]            ifFalse: [ "Is myToken a noun? If so, see if my token is a supertype"               ( aHumOntology yesNoun: candidateToken isAKindOf: myToken  )                  ifTrue: ["continue"]                  ifFalse: [ ^false ].                  "TODO: A series of nouns (example: entity attribute attribute) matches a single noun. "                  ].         ].   ^ true.      </pre><h3>Hum-Language -- HumStatement &gt;&gt; matchesTemplateStatement:inOntology:</h3><pre>matchesTemplateStatement: aStatementTemplate inOntology: aHumOntology    "Do I match the given template? (My nouns may be subtypes of template nouns)"   | templateTokens myTokens |   self assert: ( aStatementTemplate isKindOf: HumStatement ).   "First try a shortcut."   ( self source sameAs: aStatementTemplate source) ifTrue: [^true].   "Get tokens minus articles."   myTokens := ( self tokens ) difference: #('a' 'an' 'the').   templateTokens := ( aStatementTemplate tokens ) difference: #('a' 'an' 'the').   ( templateTokens size &lt;= myTokens size ) ifFalse: [ ^false ].   "TODO: Parse statements containing quoted strings."      "Is each template noun a supertype of my noun?"   ( 1 to: (templateTokens size) )      do: [ :x |         | templateToken myToken |         templateToken := templateTokens at: x.         myToken := myTokens at: x.         ( templateToken sameAs: myToken )            ifTrue: ["continue"]            ifFalse: [ "Is myToken a noun? If so, see if my token is a supertype"               ( aHumOntology yesNoun: myToken isAKindOf: templateToken  )                  ifTrue: ["continue"]                  ifFalse: [ ^false ].                  "TODO: A series of nouns (example: entity attribute attribute) matches a single noun. "                  ].         ].   ^ true.      </pre><h3>Hum-Language -- HumStatement &gt;&gt; noun:value:</h3><pre>noun: aNoun value: aValueObject    "Noun values are set at run-time just prior to executing the statement.   Record the name value pair for this noun.   (The noun is assumed to be one that appears in the statement source.)      Comment: The noun value is also on the actor`s blackboard. So this might be redundant.   On the other hand, in any other run-time, the noun would be populated via the calling mechanism.    So this is a reasonable simulation.      TODO: Decide how to handle a noun that is an entity. (What does the valueObject argument look like?)   It could be an identifier. The local blackboard could supply attribute values as needed - with WorldBase as collaborator.      Comment: If an entity is updated after the original job ticket is sent,      it is not obvious whether we should use the old values or the new.   In general, I think that the new values would be the correct choice.   However, this may be very situation dependent.      We could move the question to the coder by having exposing 'Blackboard: Synchronize entity.' (API).   I don't particularly like that solution because the philosophy of Hum is that persistence mechanisms should be transparent.   However, it does solve the problem.   "   self assert: ( aNoun isKindOf: String ).   self assert: ( aValueObject notNil ).   ( self nounValues ) at: aNoun put: aValueObject.</pre><h3>Hum-Language -- HumStatement &gt;&gt; nounAsCamelCase:</h3><pre>nounAsCamelCase: aString    "Delegate to ontology class"   ^ HumOntology nounAsCamelCase: aString.</pre><h3>Hum-Language -- HumStatement &gt;&gt; nounValues</h3><pre>nounValues   "Noun values are set at run-time.    Typically, they are found on a blackboard and transcribed as needed.   Noun values are transcribed to action-call from Agent`s blackboard.   Noun values are transcribed to goal-call from Dialog blackboard.   Noun values are transcribed to view-call from Dialog blackboard.   Noun values are transcribed to view-return message from Scribe blackboard.   "   ^ nounValues ifNil: [ nounValues := Dictionary new.].</pre><h3>Hum-Language -- HumStatement &gt;&gt; onMatch:do:</h3><pre>onMatch: aPatternString do: aBlockClosure    "When my source matches pattern, execute the block with matching arguments.    Use this to parse lines, interpret lines, generate code."   HumCalculator given: (self source) onMatch: aPatternString do: aBlockClosure.</pre><h3>Hum-Language -- HumStatement &gt;&gt; printOn:</h3><pre>printOn: aStream   "Append to the argument, aStream, a sequence of characters that     identifies the receiver."   | title |   title := self class name.   aStream      "nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);"      nextPutAll: title;      nextPutAll: '( ', self source, ' )';      nextPutAll: String cr.</pre><h3>Hum-Language -- HumStatement &gt;&gt; role</h3><pre>role   ^role ifNil: [ Error signal: 'role was not set in HumStatement']</pre><h3>Hum-Language -- HumStatement &gt;&gt; role:</h3><pre>role: aString   "What role is meant to execute this statement?   If this is an action statement,    the Dispatcher will assign execution    to an available actor that claims the role at run-time.   "   role := aString.</pre><h3>Hum-Language -- HumStatement &gt;&gt; sameAs:</h3><pre>sameAs: aHumStatement    "Return true if receiver is semantically equivalent to (argument) aHumStatement."   (aHumStatement isKindOf: String)      ifTrue: [^ (self source) sameAs: aHumStatement ].   (aHumStatement isKindOf: HumStatement)      ifTrue: [^ (self source) sameAs: (aHumStatement source) ].   "TODO: Allow variations in use of 'a' 'an' 'the'.   "      "TODO: Allow a cascade of nouns. (example: entity attribute-entity attribute-entity attribute)"   Error signal: 'argument not of expected type'</pre><h3>Hum-Language -- HumStatement &gt;&gt; source</h3><pre>source   ^ source ifNil: [ source := '' ].</pre><h3>Hum-Language -- HumStatement &gt;&gt; source:</h3><pre>source: aSource      "Set and check the source string."   |  lastCharacter |      "Remember my source string."   source := '*** SOURCE IS NOT VALID ***'.   ( aSource isKindOf:  String )       ifTrue: [ source := aSource trimBoth.].   ( aSource isKindOf:  HumStatement ) ifTrue: [ source := aSource source.].   ( aSource isKindOf: HumConditionLine ) ifTrue: [ source := aSource source.].      self assert:   ( source = '*** SOURCE IS NOT VALID ***' ) not.   source := HumProgrammersAssistant removeCommentFromSource: source.   "Reset errors."   errors := Set new.       "self stripLeader." "Leader is a UI artifact. Not really part of the source."   source := HumProgrammersAssistant removeLeaderFromSource: source.   self stripRole. "Check: Source should not contain a role prefix in this context."      (source sameAs: '')       ifTrue: ["Statement may be empty after comment and leader is removed." ^self].   "Syntax check: A statement ends with a period or a colon."   lastCharacter :=  ( source at: ( source size )).    ( lastCharacter = $. ) ifTrue: [^self].   ( lastCharacter = $: ) ifTrue: [^self].   "Last character was not a period or colon."    self syntaxError: 'Statement must end with a period or colon.'.   </pre><h3>Hum-Language -- HumStatement &gt;&gt; stripRole</h3><pre>stripRole   "Source should not contain a role prefix in this context.    Signal an error if caller has sent source with role prefix."   | tokens quote punctuation whitespace |   whitespace := '          '.   whitespace := Character separators.   quote := $' asString.   punctuation := '~!@#$%^&*()_+`={}|[]\:";&lt;&gt;?,./', quote.   "Note: Preserve uppercase in tokens so that first word of a sentence is capitalized."   tokens := source  findTokens: ( punctuation, whitespace ) keep: punctuation.   ((tokens size &gt; 2) and: [(tokens at: 2) = ':'])         ifTrue: [ "Found a role label in the source"            Error signal: 'Found role label in source.'.            "role := tokens at: 1.            source := HumCalculator given: source extractAfter: ':'" ].</pre><h3>Hum-Language -- HumStatement &gt;&gt; syntaxError:</h3><pre>syntaxError: anErrorMessage    "Error signal: anErrorMessage."   (self errors) add: anErrorMessage.</pre><h3>Hum-Language -- HumStatement &gt;&gt; tokens</h3><pre>tokens   "Return the tokens in the statement as an array of strings."   |  tokens |   tokens := HumOntology tokensInString: (self source).   "WARNING: Hum has a quirk: Accent (`) is used as apostrophe.                        Avoid complication distinguishing uses of single-quote."   ^tokens.</pre><h3>Hum-Language -- HumStatement &gt;&gt; translation</h3><pre>translation   "How might the statement be translated into another programming language?"   ^translation</pre><h3>Hum-Language -- HumStatement &gt;&gt; translation:</h3><pre>translation: aString    "How might the statement be translated into another programming language?"   translation := aString</pre><h3>Hum-Language -- HumVignettePatternLine &gt;&gt; checkSyntaxWithOntology:</h3><pre>checkSyntaxWithOntology: aHumOntology   "TODO: Look for [noun]. Is the noun defined in the ontology?"   self shouldBeImplemented .   ^ OrderedCollection new.</pre><h3>Hum-Language -- HumVignetteResponseLine &gt;&gt; checkSyntaxWithOntology:</h3><pre>checkSyntaxWithOntology: aHumOntology   "TODO: Look for [noun]. Is the noun defined in the ontology?"   self shouldBeImplemented.    ^ OrderedCollection new.</pre><h3>Hum-RunTime -- HumActor &gt;&gt; blackboard</h3><pre>blackboard   ^ blackboard ifNil: [ blackboard := HumBlackBoard new. ].</pre><h3>Hum-RunTime -- HumActor &gt;&gt; blackboard:</h3><pre>blackboard: aHumBlackBoard    self assert: (aHumBlackBoard isKindOf: HumBlackBoard).   blackboard := aHumBlackBoard</pre><h3>Hum-RunTime -- HumActor &gt;&gt; checkIn</h3><pre>checkIn   | statement quotedRoles instruction jobTicket |   "First, check-in with the messenger."   "TODO: REFACTOR THIS CALL.  ---  Why? Why? "   ( self messenger ) registerActor: self atURI: (self uri).   "Don't check-in with self."   ( self isKindOf: HumDispatcher ) ifTrue: [^self.].   "Coordinator is not dispatched by Dispatcher"   ( self isKindOf: HumCoordinator ) ifTrue: [^self.].   "Allow Dialog Agents to be dispatched for Push messages."   ( self isKindOf: HumDialogAgent )       ifTrue: ["Continue"].   "We don't expect Scribes here.    A Dialog Agent should dispatch its own Scribe."   ( self isKindOf: HumScribe )   ifTrue: [ Error signal: 'We don`t expect a Scribe checkIn.'].   "Send check-in message to my Dispatcher."   quotedRoles := ''.   ( self roles )      do: [ :role | quotedRoles := quotedRoles, ' ', role quoted ].         statement := HumStatement source: 'Check-in actor with roles.'.   statement role: #dispatcher;             noun: 'actor' value: myURI;             noun: 'roles' value: quotedRoles;      translation: ('self checkInActor: ', myID quoted, ' at: ', myURI quoted, 'withRoles: #(', quotedRoles, ')').      jobTicket := HumJobTicket title: 'checkIn:',myID.   instruction := HumInstructionLine new.   instruction     role: #dispatcher;      statement: statement;      jobTicket: jobTicket.   self delegateAction: instruction toRole: #dispatcher onJob: jobTicket.   </pre><h3>Hum-RunTime -- HumActor &gt;&gt; checkOut</h3><pre>checkOut   "Tell the Dispather that this actor is no longer available for assignments."   | statement jobTicket instruction |   "Don't check-in with self."   (self isKindOf: HumDispatcher ) ifTrue: [^self.].   "Coordinator is not dispatched by Dispatcher"   (self isKindOf: HumCoordinator ) ifTrue: [^self.].   "Send check-out message to my Dispatcher."      statement := HumStatement source: 'Check-out actor.'.   statement role: #dispatcher;             noun: 'actor' value: myURI;      translation: ('self checkOutActor: ', myID quoted, ' at: ', myURI quoted).      jobTicket := HumJobTicket title: 'checkOut:',myID.   instruction := HumInstructionLine new.   instruction     role: #dispatcher;      statement: statement.   self delegateAction: instruction toRole: #dispatcher onJob: jobTicket.</pre><h3>Hum-RunTime -- HumActor &gt;&gt; completedAction:inRole:onJob:</h3><pre>completedAction: anAction inRole: aRoleString onJob: aHumJobTicket    "Following is first-cut direct call.   When this is debugged, put an asynch wrapper on it.   "   | dispatcher   |   self assert: ( anAction isKindOf: HumInstructionLine).   dispatcher := (self messenger) getActorInstanceFromID: (self dispatcherID).   "TODO: Refactor above - It is using the messengers back door and is only valid in test mode."   self assert: (dispatcher isKindOf: HumDispatcher ).   dispatcher actor: (self id) completedAction: anAction.</pre><h3>Hum-RunTime -- HumActor &gt;&gt; completedInstruction:inRole:onJob:</h3><pre>completedInstruction: aHumInstructionLine inRole: aRoleString onJob: aHumJobTicket    "Following is first-cut direct call.   When this is debugged, put an asynch wrapper on it.   "   | dispatcher   |   self assert: ( aHumInstructionLine isKindOf: HumInstructionLine).   dispatcher := (self messenger) getActorInstanceFromID: (self dispatcherID).   "TODO: Refactor above - It is using the messengers back door and is only valid in test mode."   self assert: (dispatcher isKindOf: HumDispatcher ).   dispatcher actor: (self id) completedAction: aHumInstructionLine.</pre><h3>Hum-RunTime -- HumActor &gt;&gt; delegateAction:toRole:onJob:</h3><pre>delegateAction: anAction toRole: aRole onJob: aJobTicket   "Delegate action to another role."   | |      (self roles includes: aRole)      ifTrue: [ "If the role is one of my own, do action myself."         self runAction: anAction inRole: aRole onJob:  aJobTicket ]      ifFalse: ["Otherwise have the dispatcher send it to some actor that knows the role."         anAction jobTicket: aJobTicket.         (self messenger) sendAction: anAction toID: (self dispatcherID) fromID: myID. "STUB"].   </pre><h3>Hum-RunTime -- HumActor &gt;&gt; dispatcherID</h3><pre>dispatcherID   ^self configuration dispatcherID.</pre><h3>Hum-RunTime -- HumActor &gt;&gt; ontology</h3><pre>ontology   ^self configuration ontology.</pre><h3>Hum-RunTime -- HumActor &gt;&gt; roles</h3><pre>roles   (roles isNil and: [self class = HumActor]) ifNil: [ Error signal: 'Actor {', myID,'} has no role.' ].   ^roles ifNil: [ roles := { self class name. }].</pre><h3>Hum-RunTime -- HumActor &gt;&gt; roles:</h3><pre>roles: anArray    self assert: ( anArray isKindOf: Array ).   roles := anArray.</pre><h3>Hum-RunTime -- HumActor &gt;&gt; runAction:inRole:onJob:</h3><pre>runAction: anAction inRole: aRole onJob: aHumJobTicket   "Run the action frame named ..."    | ontology lines |   self assert: (anAction isKindOf: HumInstructionLine ).   ontology := self configuration ontology.   self assert: (ontology frames notEmpty).   "TODO: Ontology has instruction sequence, but lacks frame lines."   lines := ontology instructionsForRole: aRole action: anAction.   ( lines size &gt; 0 )       ifFalse: [Error signal: 'Action: {',anAction source,'} is not defined for role: {',aRole,'}.'].   ( lines select: [:line | line isKindOf: HumInstructionLine ] )      do: [ :frameLine |       self runInstruction: frameLine inRole: aRole onJob: aHumJobTicket.      ].   "Tell Dispatcher that we completed action normally."   self completedAction: anAction inRole: aRole onJob: aHumJobTicket.</pre><h3>Hum-RunTime -- HumActor &gt;&gt; runInstruction:inRole:onJob:</h3><pre>runInstruction: anInstruction inRole: aRole onJob: aJobTicket   "Execute, simulate, or log the given statement"   | charge aStatement |   self assert: ( anInstruction isKindOf: HumInstructionLine ).   aStatement := anInstruction statement.   "If instruction role is not one of my roles, delegate the instruction."   ( anInstruction role &gt; '' )      ifTrue: [(self roles includes: anInstruction role)                         ifFalse: [ ^self delegateAction: anInstruction toRole: anInstruction role onJob: aJobTicket ].                  ].   "If statement has a translation (assume Smalltalk), run the translation."         ( aStatement translation notNil )       ifTrue: ["Execute in Smalltalk -- TODO: What if translation is for Erlang/Java/...?"         Compiler evaluate: (aStatement translation) for: self logged: false.         "Charge to job ticket"            charge := HumMeasure quantity: 1 units: #step.            aJobTicket appendCharge: charge forAction: aStatement byActor: myID inRole: aRole onJob: aJobTicket.         "Tell Dispatcher that we completed action normally."         self completedInstruction: anInstruction inRole: aRole onJob: aJobTicket.         ^self.         ]      ifFalse: [ "Simulate execution"         "Append to log"         | s |         s := aStatement source trimBoth.         ( s = '' ) ifFalse: [ "Do not simulate execution of blank or comment-only statements."            self stepLog add: ('Actor: {', myID,'} is doing: {', s, '}' ).             ( aStatement nounValues )               keysAndValuesDo: [ :noun :value | stepLog add: ('. with: ', noun, ' = ', value asString). ].            "Charge to job ticket"               charge := HumMeasure quantity: 1 units: #step.               aJobTicket appendCharge: charge forAction: aStatement byActor: myID inRole: aRole onJob: aJobTicket.            ].         ^ self.         ].   Error signal: 'Statement type not handled.'.</pre><h3>Hum-RunTime -- HumActor &gt;&gt; updateBlackBoardFromBlackBoard:</h3><pre>updateBlackBoardFromBlackBoard: aHumBlackBoard    "Update my blackboard with entries from callers blackboard."   | |   self halt. "I want to check where this happens."   "Delegate this to Blackboard. Note: Subtypes might want to override."   ( self blackboard ) updateBlackBoardFromBlackBoard: aHumBlackBoard. </pre><h3>Hum-RunTime -- HumActor &gt;&gt; zrunInstruction:inRole:onJob:</h3><pre>zrunInstruction: anInstruction inRole: aRole onJob: aJobTicket   "Execute, simulate, or log the given statement"   | charge aStatement |   self assert: ( anInstruction isKindOf: HumInstructionLine ).   aStatement := anInstruction statement.   "If instruction role is not one of my roles, delegate the instruction."   ( anInstruction role &gt; '' )      ifTrue: [(self roles includes: anInstruction role)                         ifFalse: [ ^self delegateAction: anInstruction toRole: anInstruction role onJob: aJobTicket ].                  ].   "If statement has a translation (assume Smalltalk), run the translation."         ( aStatement translation notNil )       ifTrue: ["Execute in Smalltalk -- TODO: What if translation is for Erlang/Java/...?"         Compiler evaluate: (aStatement translation) for: self logged: false.         "Charge to job ticket"            charge := HumMeasure quantity: 1 units: #step.            aJobTicket appendCharge: charge forAction: aStatement byActor: myID inRole: aRole onJob: aJobTicket.         "Tell Dispatcher that we completed action normally."         self completedInstruction: anInstruction inRole: aRole onJob: aJobTicket.         ^self.         ]      ifFalse: [ "Simulate execution"         "Append to log"         self stepLog add: ('Actor: {', myID,'} is doing: {',aStatement source,'}' ).         ( aStatement nounValues )            keysAndValuesDo: [ :noun :value | stepLog add: ('. with: ', noun, ' = ', value asString). ].         "Charge to job ticket"            charge := HumMeasure quantity: 1 units: #step.            aJobTicket appendCharge: charge forAction: aStatement byActor: myID inRole: aRole onJob: aJobTicket.         ^ self.         ].   Error signal: 'Statement type not handled.'.</pre><h3>Hum-RunTime -- HumBase &gt;&gt; entitiesOfType</h3><pre>entitiesOfType   ^ entitiesOfType ifNil: [ entitiesOfType := Dictionary new ].</pre><h3>Hum-RunTime -- HumBase &gt;&gt; entitiesWithValue</h3><pre>entitiesWithValue   "A dictionary of sets. The set of entities with the given { attribute value }."   ^ entitiesWithValue ifNil: [ entitiesWithValue := Dictionary new].</pre><h3>Hum-RunTime -- HumBase &gt;&gt; entityAttributeValue</h3><pre>entityAttributeValue   "A dictionary holding a temporal stack of {value event} for each {entity attribute}.    The top of the stack has the current {value event}."   ^ entityAttributeValue ifNil: [ entityAttributeValue := Dictionary new ].</pre><h3>Hum-RunTime -- HumBase &gt;&gt; entityID:entityType:attribute:value:event:</h3><pre>entityID: anID entityType: aType attribute: anAttribute value: aValue event: anEvent   "Create a record of entity-attribute-value from event."   |  priorValue |      "Add entity to set of that type."   "ASSUMED: The entity does not change type over time."   self insert: anID at: aType into: (self entitiesOfType).      "Add entity to index by value."   "TODO: entitiesWithValue is meant to be current value. We need to remove old entry, if any."   priorValue := self getEntityID: anID attribute: anAttribute.    priorValue      ifNotNil: [self remove: anID at: { anAttribute. priorValue. } from: ( self entitiesWithValue ).].   self insert: anID at: { anAttribute. aValue. } into: ( self entitiesWithValue ).      "Add record."   self push: { aValue. anEvent. } at: { anID. anAttribute. } onto: ( self entityAttributeValue ).   "( self entityAttributeValue ) at: { anID. anAttribute. } put: { aValue. anEvent. }."    </pre><h3>Hum-RunTime -- HumBase &gt;&gt; eventWho:what:where:why:</h3><pre>eventWho: aWho what: aWhat where: aWhere why: aWhy    | stamp yyyy mo day hh mm ss nn when eventID event |   stamp := DateAndTime current.   yyyy := stamp year.   mo   := stamp month.   day  := stamp dayOfMonth.   hh   := stamp hour.   mm   := stamp minute.   ss   := stamp seconds.   nn   := stamp asNanoSeconds // 1000. "??? apparent precision is microseconds in MacOS"   when := yyyy.   { mo. day. hh. mm. ss. } do: [ :x | when := (when * 100) + x ].   when := (when * 1e6) + ( nn \\ 1e6 ).      "when := yyyy*1e4+mo*1e2+day*1e2+hh*1e2+mm*1e2+ss*1e12+nn."   ..   eventID := when.   event := { when. aWho. aWhat. aWhere. aWhy. }.   (self events) at: eventID put: event.   ^eventID.   </pre><h3>Hum-RunTime -- HumBase &gt;&gt; events</h3><pre>events   ^ events ifNil: [ events := Dictionary new].</pre><h3>Hum-RunTime -- HumBase &gt;&gt; findEntitiesOfType:</h3><pre>findEntitiesOfType: anEntityType    | setOfEntities |   setOfEntities := (self entitiesOfType) at: anEntityType ifAbsent: [ Set new ].   ^setOfEntities.</pre><h3>Hum-RunTime -- HumBase &gt;&gt; findEntitiesWhereAttribute:satisfies:</h3><pre>findEntitiesWhereAttribute: anAttributeType satisfies: aBlockClosure    "Get collections of entities where current attribute value satisfies condition"   | setOfEntities |   setOfEntities := Set new.   ( self entityAttributeValue )      keysAndValuesDo: [ :k :v |         | entityID attributeType attributeValue stack tuple |         entityID       := k at: 1.         attributeType  := k at: 2.         stack := v.          tuple := stack top.         attributeValue := tuple at: 1.         ( attributeType = anAttributeType )            ifTrue: [                ( aBlockClosure value: attributeValue )                   ifTrue: [ setOfEntities add: entityID ]               ]         ].   ^setOfEntities.   </pre><h3>Hum-RunTime -- HumBase &gt;&gt; getEntityID:attribute:</h3><pre>getEntityID: anEntityID attribute: anAttributeType    "Get the current value for given entityID attributeType"   | result tuple stack |   stack := ( self entityAttributeValue ) at: { anEntityID. anAttributeType } ifAbsent: [ ^nil ].   tuple := stack top.   result := tuple at: 1.    ^result.</pre><h3>Hum-RunTime -- HumBase &gt;&gt; insert:at:into:</h3><pre>insert: anItem at: aKey into: aDictionaryOfSets   "Insert the item into a set at the given key."   | setOfEntities  |   "Add entity to set associated with that key."   setOfEntities := aDictionaryOfSets  at: aKey ifAbsent: [ Set new ].   setOfEntities add: anItem.   aDictionaryOfSets at: aKey put: setOfEntities.</pre><h3>Hum-RunTime -- HumBase &gt;&gt; push:at:onto:</h3><pre>push: anItem at: aKey onto: aDictionaryOfStacks   "Insert the item into a list at the given key."   | listOfEntities  |   "Add entity to list of that type."   listOfEntities := aDictionaryOfStacks  at: aKey ifAbsent: [ Stack new ].   listOfEntities push: anItem.   aDictionaryOfStacks at: aKey put: listOfEntities.</pre><h3>Hum-RunTime -- HumBase &gt;&gt; remove:at:from:</h3><pre>remove: anEntityID at: aKey from: aDictionaryOfSets    "Remove the entityID from the set associated with the key."   | set |   set := aDictionaryOfSets at: aKey ifAbsent: [^self].   set remove: anEntityID ifAbsent: [^self].</pre><h3>Hum-RunTime -- HumBlackBoard &gt;&gt; appendEntity:toEntity:list:</h3><pre>appendEntity: childEntityID toEntity: parentEntityID list: anAttributeName    "Append the given child entity to the named list attribute"   | list attribute |   self assert: ( childEntityID isKindOf: HumIdentifier ).      self assert: ( parentEntityID isKindOf: HumIdentifier ).   self assert: ( anAttributeName isKindOf: String ).   attribute := self cleanAttribute: anAttributeName.   list := self getEntityID: parentEntityID attribute: attribute.   ( list isKindOf: OrderedCollection )      ifFalse: [ list := OrderedCollection new].   list addLast: childEntityID.   self setEntityID: parentEntityID attribute: attribute toValue: list.</pre><h3>Hum-RunTime -- HumBlackBoard &gt;&gt; businessEvent</h3><pre>businessEvent   "What business event is in progress?"   ^businessEvent ifNil: [Error signal: 'event not set']</pre><h3>Hum-RunTime -- HumBlackBoard &gt;&gt; businessEvent:</h3><pre>businessEvent: aString   "What business event is in progress?"   "TODO: We need a stronger (W5) business-event representation."   "TODO: Create a Business Event class with W5 (who, what, when, where, why) attributes."   ^businessEvent := aString</pre><h3>Hum-RunTime -- HumBlackBoard &gt;&gt; cleanAttribute:</h3><pre>cleanAttribute: anAttributeNameString    | result |   result := ((anAttributeNameString isKindOf: String )                                  ifTrue: [ anAttributeNameString ]                                 ifFalse: [ Error signal: 'Sent blackboard non-string value?'.                                            anAttributeNameString asString. ]) trimBoth asLowercase.   ^result.</pre><h3>Hum-RunTime -- HumBlackBoard &gt;&gt; cleanEntity:</h3><pre>cleanEntity: anEntityTypeString    "Assure that the type-name is properly-trimmed, lowercase string"   | result |   anEntityTypeString ifNil: [ Error signal: 'Why was entity-type nil?'].    result := anEntityTypeString trimBoth asLowercase.   [result endsWith: '.'] whileTrue: [ result := result copyFrom: 1 to: (result size - 1)].   self assert: (result isKindOf: String).   ^result.</pre><h3>Hum-RunTime -- HumBlackBoard &gt;&gt; clearEntity:</h3><pre>clearEntity: anEntityType    "Clear all data for the given entity-name / entity-type."   | quadsToBe cleanName |   "REFACTOR/RETHINK: The BlackBoard seems to be built for single instances of an entity-type."   "TODO: Think about the interaction between business roles, views, and persistence."   "Hum`s general rule is 'Persist everthing, then add purge rules.'"   "REFACTOR/RETHINK: The WorldBase should check for valid ID (defensive code). "      Error signal: 'Why are we doing this?'.  "TODO: Why would we do this? -- Original test case (ClubMechV02.txt) was for a NEW entity."   "Why? - Because an long-running dialog may have already created an entity of this type,           but a new vignette is creating another entity of this type."      cleanName := self cleanEntity: anEntityType.   "(cleanName = 'topic') ifTrue: [self halt.]."      (self entityIdentifiers) removeKey: cleanName ifAbsent: ["Okay."].    quadsToBe := Dictionary new.   quads      keysAndValuesDo: [ :key :value |         | association entityLabel |         association := key.         entityLabel := HumCalculator given: (association key asString) extractUpto: ':'.         (entityLabel sameAs: cleanName)            ifFalse: [ quadsToBe at: key put: value ].         ].   "At this point, quadsToBe has no data associated with the entity-type."   quads := quadsToBe.   </pre><h3>Hum-RunTime -- HumBlackBoard &gt;&gt; entityIdentifiers</h3><pre>entityIdentifiers   "What identifier is associated with a entity type noun (entity name)?"   ^ entityIdentifiers ifNil: [entityIdentifiers := Dictionary new].</pre><h3>Hum-RunTime -- HumBlackBoard &gt;&gt; generateNewIdentifierForEntityName:</h3><pre>generateNewIdentifierForEntityName: anEntityName   "Create a unique identifier for an instance of the given entity-name noun."   | id entity |   entity := self cleanEntity: anEntityName.   id := HumIdentifier createUniqueIdentifierForEntityName: entity inContext: (self businessEvent).   ^id.</pre><h3>Hum-RunTime -- HumBlackBoard &gt;&gt; getEntityID:attribute:</h3><pre>getEntityID: entityID attribute: anAttributeName    " Get requested value (if any) from the blackboard instance "   | valueAndTau value tau attribute |   self assert: (entityID isKindOf: HumIdentifier ).   attribute := self cleanAttribute: anAttributeName.      valueAndTau := ( self quads ) at: ( entityID -&gt; attribute ) ifAbsent: [ ^nil ].   "ToDo: If I don't have it, maybe WorldBase does. "   "TODO: If the entity-attribute-value is updated in the worldbase, are the Blackboards notified?  If so, how?"   value := valueAndTau at: 1.   tau := valueAndTau at: 2.   self assert: (tau notNil).   ^ value.</pre><h3>Hum-RunTime -- HumBlackBoard &gt;&gt; getEntityName:attribute:</h3><pre>getEntityName: anEntityName attribute: anAttributeName    "Get the entityID for that entity-name and fetch the requested attribute."   | value entityName entityID attributeName  |   entityName := self cleanEntity: anEntityName.   attributeName := self cleanAttribute: anAttributeName.      entityID := self identifierForEntityName: entityName.   value := self getEntityID: entityID attribute: attributeName.   ^value.</pre><h3>Hum-RunTime -- HumBlackBoard &gt;&gt; identifierForEntityName:</h3><pre>identifierForEntityName: anEntityName    "Do I already have an entity of that name?     If so, assign the same ID. Otherwise, get a new identifier."   | id entity |    entity := self cleanEntity: anEntityName.   id := (self entityIdentifiers) at: entity         ifAbsent: [ entityIdentifiers at: entity put: (self generateNewIdentifierForEntityName: entity). ].   ^id.</pre><h3>Hum-RunTime -- HumBlackBoard &gt;&gt; makeEntityOfType:</h3><pre>makeEntityOfType: anEntityType    "Add a new entity ID for the given entity type. (entity name)."   | entityIdentifier entity |   "Generally invoked via 'New entityType.' in a dialog vignette. "   entity := self cleanEntity: anEntityType.   entityIdentifier := self generateNewIdentifierForEntityName: entity.   "NOTE: If dialog blackboard already contains an entity of this type, it is no longer accessable."   (self entityIdentifiers) at: entity put: entityIdentifier.   </pre><h3>Hum-RunTime -- HumBlackBoard &gt;&gt; quads</h3><pre>quads   "a dictionary of { aValue. tau. } keyed by ( entityID -&gt; attribute )"   ^ quads ifNil: [ quads := Dictionary new. ].</pre><h3>Hum-RunTime -- HumBlackBoard &gt;&gt; setEntityID:attribute:toValue:</h3><pre>setEntityID: entityID attribute: anAttributeName toValue: aValue   "Store given value in the blackboard with a time-stamp.     *** Side Effect: Notify the World Base. ***"   | tau  attributeName |   self assert: ( entityID isKindOf: HumIdentifier ).   attributeName := self cleanAttribute: anAttributeName.         "Put value of entity attribute and the timestamp."   tau := (self businessEvent hash). "TODO: Relate this to a business event."   ( self quads ) at: ( entityID -&gt; attributeName ) put: { aValue. tau. }.      "Update the world base also."   ( self worldbase isKindOf: String )             ifTrue: [ "Replace string with a worldbase instance."                  (worldbase = 'none') ifTrue: ["This blackboard does not persist data immediately." ^self].                  self worldbase: (HumWorldBase openWorldBase: worldbase).                  ].                   self assert: (self worldbase isKindOf: HumWorldBase ).   ( self worldbase ) setEntityID: entityID attribute: attributeName toValue: aValue.      "NOTE: Mutation in the world-base is treated via versioning."   "TODO: Blackboard detects mutations ? -- And then what?"   "TODO: Code critic flags mutation as Error?"   "COMMENT: Mutation in a business-entity is mainly a danger when a natural-key is mutated."</pre><h3>Hum-RunTime -- HumBlackBoard &gt;&gt; setEntityName:attribute:toValue:</h3><pre>setEntityName: anEntityName attribute: anAttributeName toValue: aValue   "for now -- same as:"   | entityID entityName attributeName |  entityName := self cleanEntity: anEntityName.  attributeName := self cleanAttribute: anAttributeName.   "Do I already have an entity of that name?     If so, assign the same ID. Otherwise, get a new identifier."   entityID := self identifierForEntityName: entityName.      ( anAttributeName sameAs: aValue asString   )      ifTrue: ["When the value matches the attribute name, the value references an entity."         | referencedEntityID |         referencedEntityID := self identifierForEntityName: anAttributeName.         self setEntityID: entityID attribute: attributeName toValue: referencedEntityID.         ^self.         ].      self setEntityID: entityID attribute: attributeName toValue: aValue.      </pre><h3>Hum-RunTime -- HumBlackBoard &gt;&gt; updateBlackBoardFromBlackBoard:</h3><pre>updateBlackBoardFromBlackBoard: aHumBlackBoard    "Update myself from entries in the other blackboard."   | otherQuads |   Error signal: 'I don`t expect this to be used in current coding environment.'.   "Assume that caller is not sharing this blackboard."   self assert: (aHumBlackBoard == self ) not.   "Interpret caller quads"   otherQuads := aHumBlackBoard quads.   self assert: ( otherQuads isKindOf: Dictionary ).   otherQuads          keysAndValuesDo: [ :key :value |            | entityID entityName attributeType newValue  |            "Parse dictionary key - it is a map of the form: (entitID -&gt; attributeType)"            entityID := key key.            attributeType := key value.            self assert: ( entityID isKindOf: HumIdentifier ).            entityName := entityID entityName.            "Parse dictionary value - It is a tuple of the form: { value. tau. }"            newValue := value at: 1.            "tau := value at: 2."            "Update myself -- Note: I will generate my own tau."            self entityIdentifiers at: entityName put: entityID.            self setEntityID: entityID attribute: attributeType toValue: newValue.            ]   </pre><h3>Hum-RunTime -- HumBlackBoard &gt;&gt; worldbase</h3><pre>worldbase   ^ worldbase ifNil: [Error signal: 'Blackboard configured without a world base.']</pre><h3>Hum-RunTime -- HumBlackBoard &gt;&gt; worldbase:</h3><pre>worldbase: aHumWorldBase    self assert: ((aHumWorldBase isKindOf: HumWorldBase) or: [aHumWorldBase = 'none']).   worldbase := aHumWorldBase</pre><h3>Hum-RunTime -- HumBookkeeper &gt;&gt; chargesBy:</h3><pre>chargesBy: attribute   "Produce dictionary of sums for given subdivision type."   | sums |   sums := Dictionary new.   jobTickets       do: [ :ticket |         | charges |         charges := ticket charges.                  charges do: [:charge |            | key sumBy units amount x |            amount := charge at: 'measure'.            sumBy := charge at: attribute.            units := amount units.            key := sumBy,':',units.            x := sums at: key                 ifAbsent: [ |q| q := amount copy quantity: 0. q].            x := x + amount.            sums at: key put: x.            ].         ].      ^sums.</pre><h3>Hum-RunTime -- HumBookkeeper &gt;&gt; chargesByAction</h3><pre>chargesByAction   "Produce dictionary of sums keyed by action."   | sums |   sums := self chargesBy: 'action'.   ^sums.</pre><h3>Hum-RunTime -- HumBookkeeper &gt;&gt; chargesByActor</h3><pre>chargesByActor   "Produce dictionary of sums keyed by actor."   | sums |   sums := self chargesBy: 'ID'.      ^sums.</pre><h3>Hum-RunTime -- HumBookkeeper &gt;&gt; chargesByJob</h3><pre>chargesByJob   "Produce dictionary of sums keyed by job."   | sums |   sums := self chargesBy: 'job'.   ^sums.</pre><h3>Hum-RunTime -- HumBookkeeper &gt;&gt; chargesByMetric</h3><pre>chargesByMetric   "Produce dictionary of sums keyed by unit of measure. "   | sums |   sums := Dictionary new.   jobTickets       do: [ :ticket |         | charges |         charges := ticket charges.         charges do: [:charge |            | key sumBy units amount x |            amount := charge at: 'measure'.            units := amount units.            sumBy := 'total'.            key := sumBy,':',units.            x := sums at: key                 ifAbsent: [ |q| q := amount copy quantity: 0. q].            x := x + amount.            sums at: key put: x.            ].         ].      ^sums.</pre><h3>Hum-RunTime -- HumBookkeeper &gt;&gt; chargesByRole</h3><pre>chargesByRole   "Produce dictionary of sums keyed by role-name.."   | sums |   sums := self chargesBy: 'role'.   ^sums.</pre><h3>Hum-RunTime -- HumBookkeeper &gt;&gt; jobTickets</h3><pre>jobTickets   ^ jobTickets ifNil: [ jobTickets := OrderedCollection new. ].</pre><h3>Hum-RunTime -- HumBookkeeper &gt;&gt; recordJobTicket:</h3><pre>recordJobTicket: aHumJobTicket    "Add the given job ticket to my collection of job tickets."   (self jobTickets) add: aHumJobTicket.</pre><h3>Hum-RunTime -- HumBusinessEvent &gt;&gt; what:</h3><pre>what: aString   "What is the cause/actor doing in the business event?"   what := aString</pre><h3>Hum-RunTime -- HumBusinessEvent &gt;&gt; when:</h3><pre>when: aTimeStamp   "When (at what date-time) is business event happening?"   when := aTimeStamp</pre><h3>Hum-RunTime -- HumBusinessEvent &gt;&gt; where:</h3><pre>where: aString   "Where (at what location/context) is business event happening?"   where := aString</pre><h3>Hum-RunTime -- HumBusinessEvent &gt;&gt; who:</h3><pre>who: aString   "Who is the cause/actor in the business event"   who := aString</pre><h3>Hum-RunTime -- HumBusinessEvent &gt;&gt; who:what:when:where:why:</h3><pre>who: aWho what: aWhat when: aTimeStamp where: aWhere why: aJobTicket   "Set the business event attributes."   self who: aWho; what: aWhat; when: aTimeStamp; where: aWhere; why: aJobTicket.</pre><h3>Hum-RunTime -- HumBusinessEvent &gt;&gt; why:</h3><pre>why: aJobTicket   "Why (job-ticket) is business event happening?"   why := aJobTicket</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; cases</h3><pre>cases   "Initialize case cascade.   Usage:   calculator cases;       when: [ block returning boolean] then: [ some action];       when: [ block returning boolean] then: [ some action];       otherwise: [ action if all the when-blocks are false ].   See also:      object caseOf: {value-&gt;block. value-&gt;block.} otherwise: [action if no value matches]      "   priorCaseIsTrue := false.   </pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; doTokensIn:at:matchPatternTokensIn:at:</h3><pre>doTokensIn: input at: xInput matchPatternTokensIn: pattern at: xPattern   | result |   result := self class doTokensIn: input at: xInput matchPatternTokensIn: pattern at: xPattern.   ^result.</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; exdent</h3><pre>exdent   "Remove a tab from the global indent string."   indentString := priorIndent ifNil: [ Error signal: 'priorIndent not set' ].   </pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; fillTemplate:fromDictionary:</h3><pre>fillTemplate: template fromDictionary: dictionary   "Create a String based on the given template and parameters."   | result |   result := template.   [ result includesSubString: '@']      whileTrue: ["Replace the first parameter with its value"         | front back name value delimiters |            front := self given: result extractUpto: '@'.         back := self given: result extractAfter: '@'.         "Get and remove the name of the parameter"         delimiters := '                ~!@#$%^&*()_+`-=[]\{}|:";&lt;&gt;?,./'''.         name := (back substrings: delimiters ) at: 1.         "Insert the value of the parameter"         value := dictionary at: name.         self assert: (value isKindOf: String ).         back := self given: back extractAfter: name.         result := front, value, back.         ].   ^result.</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; given:extractAfter:</h3><pre>given: sourceString extractAfter: stringA    "Return the substring in the sourceString between the two."   | result |   result := HumCalculator given: sourceString extractAfter: stringA.   ^result.</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; given:extractAfterSecond:</h3><pre>given: input extractAfterSecond: marker    "Parse cases like matching quotes or markup emphasis."   | wip result |   wip := self given: input extractAfter: marker.   result := self given: wip extractAfter: marker.   ^result.</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; given:extractBetween:and:</h3><pre>given: sourceString extractBetween: stringA and: stringB   "Return the substring in the sourceString between the two."   | result |   result := HumCalculator given: sourceString extractBetween: stringA and: stringB.   ^result.</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; given:extractUpto:</h3><pre>given: sourceString extractUpto: stringA    "Return the substring in the sourceString between the two."   |   result |   result := HumCalculator given: sourceString extractUpto: stringA.   ^result.</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; given:onMatch:do:</h3><pre>given: inputString onMatch: aPatternString do: aBlockClosure    "When the inputString matches pattern, execute the block with matching arguments.    Use this to parse lines, interpret lines, generate code."   self class given: inputString onMatch: aPatternString do: aBlockClosure </pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; given:replaceAll:with:</h3><pre>given: input replaceAll: old with: new    |result|   result := self class given: input replaceAll: old with: new.   ^result. </pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; given:topic:doOnce:</h3><pre>given: s topic: aTopic doOnce: aBlock   "Use this to produce subheadings."   (s = (self topicDictionary at: aTopic ifAbsent: '') )       ifFalse: [ aBlock value: aTopic value: s.         self topicDictionary at: aTopic put: aTopic.         ].   </pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; indent</h3><pre>indent   "Append a tab to the global indent string."   priorIndent := indentString ifNil: [''].   indentString := indentString, String tab.   </pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; indentLevel:</h3><pre>indentLevel: n    "Reset the indent level. Produce indent string (tabs)."   self assert: (n isKindOf: Integer ).   indentString := String new.   (1 to: n) do: [:i | indentString := indentString, String tab.].</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; initialize</h3><pre>initialize   indentString := String new.</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; justTheWordsIn:</h3><pre>justTheWordsIn: aString   ^self class justTheWordsIn: aString.</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; on:do:</h3><pre>on: aValue do: aBlockClosure    ( testValue = aValue )       ifTrue: [ priorCaseIsTrue := true.          aBlockClosure value ].</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; otherwise:</h3><pre>otherwise: thenBlock   "If a prior case was true, ignore this case.     Otherwise, execute this block."      ( self priorCaseIsTrue ) ifTrue: [ ^self ].   "otherwise"   thenBlock value.   ^self.   </pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; parse:</h3><pre>parse: aString   "Parse into { token. type. start. stop. }"   | sequence |   sequence := self class parse: aString.   ^sequence.         </pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; priorCaseIsTrue</h3><pre>priorCaseIsTrue   ^ priorCaseIsTrue ifNil: [priorCaseIsTrue := false ].</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; scoreCandidate:againstPattern:</h3><pre>scoreCandidate: candidateString againstPattern: patternString   "Return a score indicating the number of tokens that match."    | candidateTokens patternTokens commonTokens |   self assert: (candidateString isKindOf: String).   self assert: (patternString isKindOf: String).      "Parse."   candidateTokens := HumCalculator justTheWordsIn: candidateString.   patternTokens := HumCalculator justTheWordsIn: patternString.   commonTokens := candidateTokens intersection: patternTokens.   ^commonTokens size.      </pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; string:isLike:</h3><pre>string: stringA isLike: stringB    "Compare ignoring differences in whitespace."   ^self class string: stringA isLike: stringB. </pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; string:isLike:ignore:</h3><pre>string: aString isLike: aString2 ignore: aString3    ^self class string: aString isLike: aString2 ignore: aString3.</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; switch:</h3><pre>switch: aCharacter    self testValue: aCharacter.</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; testValue:</h3><pre>testValue: anObject    testValue := anObject</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; when:then:</h3><pre>when: whenBlock then: thenBlock   "If the whenBlock evaluated to true, execute the thenBlock."   | |   "If a prior case was true, ignore this case."      ( self priorCaseIsTrue ) ifTrue: [ ^self ].   "If the when block is true"   ( whenBlock value )       ifTrue: [          priorCaseIsTrue := true.          thenBlock value ].   ^self.   </pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; xml:dictionary:</h3><pre>xml: aTagString dictionary: aDictionaryOrList    "Create a stand-alone tag (ending with '/&gt;') with the given attribute values."   | xml space equals quote dictionary |   dictionary := aDictionaryOrList asDictionary.  space := String space.   equals := '='.   quote := $" asString.   "Don not mess with indent here. Caller should handle."   xml := '&lt;', aTagString.   dictionary keysSortedSafely       do: [ :key  |         | value |         value := dictionary at: key.          xml := xml, space, key asString, equals, quote, value asString, quote.         ].   xml := xml, ' /&gt;', String cr.   ^xml.</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; xml:dictionary:with:</h3><pre>xml: aTagString dictionary: aDictionary with: aBlockClosure    "Generate the front tag and the end tag with block to produce the middle"   | frontTag xml cr dictionary |   dictionary := aDictionary asDictionary.   cr := String cr.   self indent.   frontTag :=  self xmlOpen: aTagString dictionary: dictionary.   xml := indentString, frontTag, cr,           indentString, ( aBlockClosure value ), cr,            indentString, '&lt;/', aTagString, '&gt;', cr.   "Restore prior indent"   self exdent.   ^xml.</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; xml:list:</h3><pre>xml: tagString list: anArray    "Iterate: Enclose each item with given tagString"   | result |   self indent.   result := String new.   anArray       do: [ :each | |s|         s := '&lt;',tagString,'&gt;',each,'&lt;/',tagString,'&gt;'.         result := result, String cr, indentString, s.         ].   self exdent.   ^result.</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; xml:with:</h3><pre>xml: aTag with: aBlock    "Fix up the indent after we get this working."   | xml cr  insert |   insert := aBlock value.   self assert: ( insert isKindOf: String ).   cr := String cr.   self indent.   xml  := indentString,'&lt;', aTag, '&gt;', cr          , indentString, insert, cr          , indentString, '&lt;/', aTag, '&gt;', cr.   "Restore prior indent."   self exdent.   ^xml.</pre><h3>Hum-RunTime -- HumCalculator &gt;&gt; xmlOpen:dictionary:</h3><pre>xmlOpen: aTagString dictionary: aDictionary    "Create an opening tag ( NOT ending with '/&gt;' ) with the given attribute values."   | xml space equals quote |   self assert: ( aDictionary isKindOf: Dictionary ).   space := String space.   equals := '='.   quote := $" asString.
  "Do no mess with indent here. Caller should handle."   xml := '&lt;', aTagString.   aDictionary keysSortedSafely       do: [ :key  |         | value |         value := aDictionary at: key.          value ifNil: [  Error signal: 'Nil passed where xml attribute was expected.'].         xml := xml, space,  key, equals, quote,  value, quote.         ].      xml := xml, ' &gt;', String cr.   ^xml.</pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; bookkeeperID</h3><pre>bookkeeperID   ^ bookkeeperID</pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; bookkeeperID:</h3><pre>bookkeeperID: anObject   bookkeeperID := anObject</pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; clock</h3><pre>clock   "What object is providing time-keeping?"   ^ clock ifNil: [clock := HTime "class singleton"].</pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; clock:</h3><pre>clock: anObjectThatImplementsNow   "Clock must be an object that imlements &gt;&gt;now as a number of seconds (an Integer)."   self assert: ( anObjectThatImplementsNow respondsTo: #now ).   clock := anObjectThatImplementsNow.</pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; configuration:</h3><pre>configuration: aHumConfiguration    "Copy configuration."   self assert: (aHumConfiguration isKindOf: HumConfiguration ).   self copyFrom: aHumConfiguration.</pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; debug</h3><pre>debug   "Am I in debug mode?"   ^ debug ifNil: [debug := false].</pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; dispatcherID</h3><pre>dispatcherID   ^ dispatcherID ifNil: [ Error signal: 'A configuration must have a Dispatcher.' ].</pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; dispatcherID:</h3><pre>dispatcherID: anObject   dispatcherID := anObject</pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; getWorldBase</h3><pre>getWorldBase   "Get this configuration`s worldbase instance."   | worldbaseInstance |   worldbaseInstance := (self messenger) getActorInstanceFromID: (self worldbaseID).   ^worldbaseInstance.   </pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; isTest</h3><pre>isTest  "Are we running in TEST mode?"   ^isTest ifNil: [ isTest := true. ].   </pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; isTest:</h3><pre>isTest: aBoolean   "Are we running in TEST mode?"   isTest := aBoolean   </pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; messenger</h3><pre>messenger   ^ messengerProxy          ifNil: [ "Set up messenger with my clock."            messengerProxy := HumMessenger new.            messengerProxy clock: self.             messengerProxy. "return"            ].</pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; messenger:</h3><pre>messenger: aHumMessenger   "Set the messenger -- Use to configure mocks when needed."   self assert: (aHumMessenger isKindOf: HumMessenger).  messengerProxy := aHumMessenger.</pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; messengerID</h3><pre>messengerID   ^ messengerID</pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; messengerID:</h3><pre>messengerID: aString   messengerID := aString.   ('*URL*' match: aString) ifTrue: [self halt].   ('*ID' match: aString ) ifFalse: [ Error signal: 'ID is not in expected (MOCK) format.' ].</pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; messengerID:dispatcherID:bookkeeperID:worldbaseID:</h3><pre>messengerID: idMessenger dispatcherID: idDispatcher bookkeeperID: idBookkeeper worldbaseID: idWorldbase   messengerID := idMessenger.   dispatcherID := idDispatcher.  bookkeeperID := idBookkeeper.   worldbaseID := idWorldbase.   "WARNING: I am not sure this is a good idea."  ontology ifNil: [self ontology: HumOntology baseOntology].   </pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; now</h3><pre>now   "What time is it in configured world (may be simulation)?"   ^ clock now.</pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; ontology</h3><pre>ontology   ^ ontology ifNil: [ Error signal: 'ontology is missing from configuration'].   "TODO: Perhaps we should return HumOntology baseOntology instead."</pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; ontology:</h3><pre>ontology: aHumOntology    ontology := aHumOntology.</pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; openWorldBase</h3><pre>openWorldBase   "Create world base instance and register with messenger."   | worldbaseInstance |   worldbaseInstance := HumWorldBase openWorldBase: (self worldbaseID).   (self messenger) registerActor: worldbaseInstance atURI: (worldbaseInstance uri).    ^worldbaseInstance.</pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; worldbaseID</h3><pre>worldbaseID   ^ worldbaseID</pre><h3>Hum-RunTime -- HumConfiguration &gt;&gt; worldbaseID:</h3><pre>worldbaseID: anObject   worldbaseID := anObject</pre><h3>Hum-RunTime -- HumCoordinator &gt;&gt; conditionIsSatisfied:</h3><pre>conditionIsSatisfied: precondition    "Note that condition is satisfied.   Then runnable frames may change.   If all conditions have been satisfied, the goal is achieved.   THINK: Should the goal itself be in remainingConditions collection?   "   | debug |   (debug := false) ifTrue: [Transcript cr; show: 'HumCoordinator conditionIsSatisfied: ', precondition asString. ].   self assert: ( precondition isKindOf: HumStatement ).      precondition isSatisfied: true.   (self remainingConditions)       remove: precondition       ifAbsent: [Error signal: 'absent condition: ', precondition "statement" source]</pre><h3>Hum-RunTime -- HumCoordinator &gt;&gt; context:</h3><pre>context: aHumActor   context := aHumActor.</pre><h3>Hum-RunTime -- HumCoordinator &gt;&gt; coordinatorID:uri:goal:dialog:configuration:</h3><pre>coordinatorID: anID uri: aURI goal: aGoalStatementString dialog: aHumDialogAgent configuration: aHumConfiguration   self configuration: aHumConfiguration.      self id: anID.   self uri: aURI.   self goal: aGoalStatementString.   self dialogAgent: aHumDialogAgent.         ^self.   </pre><h3>Hum-RunTime -- HumCoordinator &gt;&gt; dialogAgent:</h3><pre>dialogAgent: aHumDialogAgent    "Concept: The dialog agent provides noun values     as needed to populate plan and action statements."   self assert: ( aHumDialogAgent isKindOf: HumDialogAgent ).   dialogAgent := aHumDialogAgent.</pre><h3>Hum-RunTime -- HumCoordinator &gt;&gt; getActionSequence</h3><pre>getActionSequence   "Parse the job ticket to show the sequence of actions."   | listOfActions |   listOfActions := self jobTicket getActionSequence.   ^listOfActions.</pre><h3>Hum-RunTime -- HumCoordinator &gt;&gt; goal:</h3><pre>goal: aStatement   goal := nil.   (aStatement isKindOf: HumStatement ) ifTrue: [ goal := aStatement. ^self ].   ( aStatement isKindOf: String )      ifTrue: [ "Get the goal statement from the root frame."         | rootFrame statement |         rootFrame := (self ontology) getPlanFrameForGoal: aStatement.         statement := rootFrame goal.         self assert: (statement isKindOf: HumStatement).         goal := statement.         ^self.         ].   </pre><h3>Hum-RunTime -- HumCoordinator &gt;&gt; goalStatement</h3><pre>goalStatement   "Translate goal string to goal statement"   "TODO: THERE IS SOMETHING WRONG HERE."   | rootFrame statement |   rootFrame := ((self ontology) getPlanFrameForGoal: goal).   statement := rootFrame goal.   self assert: (statement isKindOf: HumStatement ).   ^ statement. </pre><h3>Hum-RunTime -- HumCoordinator &gt;&gt; isPlanFrameRunnable:</h3><pre>isPlanFrameRunnable: aHumFrame4Plan   "Determine if the given plan frame is runnable.   To be runnable, it`s preconditions must all be satisfied.   TODO: This implementation is only correct where the noun values do not affect.   WARNING: Assumes: All instances of the condition have the same noun values.   "    (aHumFrame4Plan preconditions)      do: [ :precondition |             ((self remainingConditions) includes: (precondition statement) )                  ifTrue: [^false]                  ].      ^true            </pre><h3>Hum-RunTime -- HumCoordinator &gt;&gt; jobTicket</h3><pre>jobTicket   ^ jobTicket ifNil: [ jobTicket := HumJobTicket title: goal ].</pre><h3>Hum-RunTime -- HumCoordinator &gt;&gt; planIsRunnable</h3><pre>planIsRunnable   "TODO: ADD NEEDED CHECKS TO THIS STUB."   | |   context := dialogAgent.   self assert: ( context isKindOf: HumDialogAgent ).   self assert: ( goal isKindOf: HumStatement ).   "      Additional Preconditions:   . All nouns in the goal statement have values on the dialog agent's' blackboard.   . The frame collection is complete.   . All the roles in the action statements are known (checked-in) to the Dispatcher.   . All action statements are defined in the ontology.   "   "TODO: DANGER -- THIS IS A STUB!!!"   ^true.</pre><h3>Hum-RunTime -- HumCoordinator &gt;&gt; remainingConditions</h3><pre>remainingConditions   ^ remainingConditions ifNil: [ remainingConditions := Set new.] .</pre><h3>Hum-RunTime -- HumCoordinator &gt;&gt; runAction:</h3><pre>runAction: anInstructionLine    "Run the given action statement."   | debug |   debug := false.    debug ifTrue: [ Transcript cr; show: 'HumCoordinator ',myID,' is running { ', anInstructionLine source, ' }'.].   "TODO: Track work-in-progress so that run-time instrumentation can view."   anInstructionLine jobTicket: (self jobTicket).   (self messenger) sendAction: anInstructionLine toID: (self configuration dispatcherID) fromID: myID.   </pre><h3>Hum-RunTime -- HumCoordinator &gt;&gt; runPlan</h3><pre>runPlan   "Run my plan.   "   |  result |   self runPlanSetup.   result := self runPlanFrameForCondition: goal.   result       ifFalse: [ Error signal: 'Attempt to run plan for goal: {',goal,'} has failed.'].</pre><h3>Hum-RunTime -- HumCoordinator &gt;&gt; runPlanFrameForCondition:</h3><pre>runPlanFrameForCondition: aGoalString   "This visits the subtree and runs each frame that is ready to run.   TODO: RUN ACTIONS IN PARALLEL.   TODO: Track work in progress.   TODO: Write several tests.   "   | rootFrame result |   "If the condition is already satisfied (not in remainingConditions set), we can skip and return immediately."   remainingConditions detect: [:condition | condition sameAs: aGoalString ] ifNone: [  ^true.].   "Get the root of this subtree."   rootFrame := (self ontology) getPlanFrameForGoal: aGoalString.   "REFACTOR: The rootFrame does not know if it is runnable. But the Coordinator knows."   ( self isPlanFrameRunnable: rootFrame )      ifTrue: ["Run its actions and then declare the goal satisfied"         "Run actions"         (rootFrame actionStatements)             do: [ :action | self runAction: action.  ].         "Declare goal satisfied"         self conditionIsSatisfied: rootFrame goal.         ^true.    "Indicates something was runnable. See check below."         ] "ifTrue"      ifFalse: [ "Try to satisfy the preconditions."         result := false.         ( rootFrame preconditions )               do: [ :precondition |                  | preconditionString stepResult |                  preconditionString := precondition statement source.                  "Call recursively on preconditions."                  stepResult := self runPlanFrameForCondition: preconditionString.                  result := result | stepResult.  "Boolean"                  ]. "do"               "Check post condition                -- At least one precondition in the tree should be runnable on each iteration."               result ifFalse: [ Error signal: 'Nothing in the subtree was runnable!']               ]."ifFalse"                  "Fall through to here when goal frame is not runnable and we ran preconditions.      Now try again."      ((self remainingConditions ) isEmpty)          ifTrue: [ Error signal: 'Remaining conditions should not be empty in this recursive loop.'.            "In this context,             the remaining conditions should include the original goal,              and therfore, not be empty yet."            ].      result := self runPlanFrameForCondition: aGoalString.      ^result.         </pre><h3>Hum-RunTime -- HumCoordinator &gt;&gt; runPlanSetup</h3><pre>runPlanSetup   "Setup to run a plan:   1. Assure plan is runnable.   2. Populate the remaining conditions collection. ()   3. Initialize the job ticket?   TODO: WATCH OUT: instance variables passed via the back-door    "   | |   self assert: (goal isKindOf: HumStatement ).   self planIsRunnable ifFalse: [ Error signal: 'Plan is not runnable for goal: ', goal ].   planFrames := self ontology collectPlanFramesForGoal: (self goalStatement).  "Populate the remaining conditions collection"   (self remainingConditions) add: goal.   jobTicket := HumJobTicket title: goal.   planFrames      do: [ :frame |            ( frame preconditions )                  do: [ :precondition |                        remainingConditions add: (precondition statement).                     ].         ].</pre><h3>Hum-RunTime -- HumDecimal &gt;&gt; fromString:</h3><pre>fromString: aString   "Count the digits in the string to estimate accuracy."   |  parser value  nDigits assumedMedian err  lowerBound upperBound aDistribution |   parser := HumNumberParser on: aString.   value := parser nextNumber.   nDigits := parser nDigits.   assumedMedian := value.   err := (10.0 raisedToInteger: (nDigits negated)) / 2.0.   lowerBound := assumedMedian - err.   upperBound :=  assumedMedian + err.   aDistribution := Dictionary new.   aDistribution      at: 0.50 put: assumedMedian;      at: 0.00 put: lowerBound;      at: 1.00 put: upperBound.   self distribution: aDistribution.   self nDecimal: nDigits.         </pre><h3>Hum-RunTime -- HumDecimal &gt;&gt; nDecimal</h3><pre>nDecimal   "How many decimal places should we display."   ^nDecimal ifNil: [ 0 ].</pre><h3>Hum-RunTime -- HumDecimal &gt;&gt; nDecimal:</h3><pre>nDecimal: anInteger    "How many decimal places should we display."   nDecimal := anInteger.</pre><h3>Hum-RunTime -- HumDecimal &gt;&gt; printOn:</h3><pre>printOn: aStream   super printOn: aStream.   distribution ifNil: [ ^self ].   aStream      nextPut: $(;      nextPutAll: (self median printShowingDecimalPlaces: self nDecimal );      nextPut: $).   </pre><h3>Hum-RunTime -- HumDialogAgent &gt;&gt; askView:</h3><pre>askView: aViewName   | ontology viewFrame |   ontology := self ontology.    viewFrame := ontology getViewFrame: aViewName.   "Delegate display to my scribe."   (self scribeProxy) askView: viewFrame withBlackBoard: (self blackboard).</pre><h3>Hum-RunTime -- HumDialogAgent &gt;&gt; buildDialogAgentOntology</h3><pre>buildDialogAgentOntology   "Return ontology with Dialog Agent actions defined and executable in Smalltalk."   | ontology pa |      pa := HumProgrammersAssistant new.   ontology := pa loadOntologyFromTextStream: (self dialogOntologySourceStream).   ^ontology. </pre><h3>Hum-RunTime -- HumDialogAgent &gt;&gt; clearEntity:</h3><pre>clearEntity: entityType   "Clear prior data in my blackboard for the given entity type."   "WARNING: Assumes dialogs vignettes only address one instance of an entity at a time."   "TODO: I think there is a UX problem here. This behavior may confuse users."   "PROBLE: It makes no sense to clear a real-world entity.                 This occurs in the context of a data-entry pane."   self blackboard clearEntity: entityType. </pre><h3>Hum-RunTime -- HumDialogAgent &gt;&gt; client:</h3><pre>client: aString    clientID := aString.   clientURI := 'URI:',aString. "STUB!"</pre><h3>Hum-RunTime -- HumDialogAgent &gt;&gt; clientSays:</h3><pre>clientSays: aString    "Match user utterance to vignette patterns in the ontology   and return the vignette frame with the best match.   "   | bestMatch |
   "We need a context stack to define the best match."   self assert: ( self contextStack isKindOf: Stack ).   self assert: ( self contextStack notEmpty ).   "Delegate the search to the ontology."   bestMatch := self ontology findBestMatchingVignetteForInput: aString inContextStack: (self contextStack).   "TODO: Now that I've got a vignette (or not), what do I do with it?"   self assert: ( bestMatch isKindOf: HumFrame4Vignette ).   (self stepLog) add: (clientID asString,': ', aString).   (self blackboard) businessEvent: (clientID asString,' says: ', aString).    "TODO: We need a stronger (W5: who, what, when, where, why) business-event representation."   "who = clientID, what = says: ___, when = date-stamp, where = dialog, why = vignette"   self interpretVignette: bestMatch withInput: aString.      "*** Return vignette for DEBUG? *** "   "TODO: THINK -- Should test cases examine my step log instead?"   ^ bestMatch.</pre><h3>Hum-RunTime -- HumDialogAgent &gt;&gt; contextStack</h3><pre>contextStack   ^ contextStack ifNil: [ contextStack := Stack new. self pushContext: 'Start.'. contextStack ].</pre><h3>Hum-RunTime -- HumDialogAgent &gt;&gt; dialogAgentOntology</h3><pre>dialogAgentOntology   "Return ontology with Dialog Agent actions defined and executable in Smalltalk."   ^ dialogAgentOntology ifNil: [dialogAgentOntology := self buildDialogAgentOntology].</pre><h3>Hum-RunTime -- HumDialogAgent &gt;&gt; dialogOntologySourceStream</h3><pre>dialogOntologySourceStream   "Return a stream of frames defining Dialog Agent actions."   | string stream peekCharacter |   string := '===Role: DialogAgent.Action: Ask view-name.. Get view-name from callers-ontology.. Translate view-name giving html-form-panel.. Scribe: Send html-form-panel to client-browser.. (DialogAgent black board will be updated.)To: Get view-name from callers-ontology..To: Translate view-name giving html-string..==='.   stream := ReadWriteStream with: string.   stream position: 0.   peekCharacter := stream peek.   self assert: (peekCharacter = $= ).   ^stream.</pre><h3>Hum-RunTime -- HumDialogAgent &gt;&gt; extractFieldValuesFromUserInput:pattern:</h3><pre>extractFieldValuesFromUserInput: inputString pattern: patternString    "Extract values from user input and post to my blackboard.    "   | inputTokens patternTokens xInput xPattern calc input pattern entityName attributeName attributeValue |      (patternString includes: $[ ) ifFalse: ["There is no slot in this pattern." ^self].      inputTokens := HumCalculator findTokensInString: inputString.   inputTokens := HumCalculator removeNoiseWordTokensFrom: inputTokens.       patternTokens := HumCalculator findTokensInString: patternString.   patternTokens := HumCalculator removeNoiseWordTokensFrom: patternTokens.      xInput := 1.   xPattern := 1.   calc := HumCalculator new.   [ (xInput &lt;= inputTokens size) and: [xPattern &lt;= patternTokens size] ]      whileTrue: [            input := inputTokens at: xInput.            pattern := patternTokens at: xPattern.            calc cases;               when: [ input sameAs: pattern]                   then: [ xInput := xInput + 1. xPattern := xPattern + 1.];               when: [ pattern = '[' ]                   then: [ "Extract input value and push into blackboard."                     entityName := patternTokens at: xPattern + 1.                     attributeName := patternTokens at: xPattern + 2.                     self assert: ( ']' = (patternTokens at: xPattern + 3)).                     xPattern := xPattern + 4.                      pattern := patternTokens at: xPattern.                     attributeValue := ''.                     [(xInput &lt;= inputTokens size) and: [input ~= pattern]]                         whileTrue: [attributeValue := attributeValue, ' ', input.                           xInput := xInput + 1.                           input := inputTokens at: xInput.                           ].                      self blackboard setEntityName: entityName                                           attribute: attributeName                                             toValue: (attributeValue trimBoth).                     ];               when: [ pattern = '*'] then: [self shouldBeImplemented];               otherwise: [Error signal: 'How did we get here?'].         ].   </pre><h3>Hum-RunTime -- HumDialogAgent &gt;&gt; fillInSlotIn:</h3><pre>fillInSlotIn: aMarkupString    " Fill-in first [entity attribute] dialog-response-slot with data from blackboard.     Dialog Agent (myself) will call me until all slots are filled.   "   | fieldName entityName attributeName fieldValue result before after |   fieldName := (HumCalculator given: aMarkupString extractBetween: '[' and: ']') withSeparatorsCompacted.   "Break the field name into entityName and attributeType."   self assert: (fieldName includes: $  ) description: 'In this context, the entity must always be named.'.   entityName := (HumCalculator given: fieldName extractUpto: ' ') trimBoth.   attributeName := (HumCalculator given: fieldName extractAfter: ' ') trimBoth.   fieldValue := self blackboard getEntityName: entityName attribute: attributeName.   "Insert field-value into markup string."   before := HumCalculator given: aMarkupString extractUpto: '['.   after  := HumCalculator given: aMarkupString extractAfter: ']'.   result := before, (fieldValue ifNil: ['*** Unknown ***']), after.   ^result.</pre><h3>Hum-RunTime -- HumDialogAgent &gt;&gt; interpretVignette:withInput:</h3><pre>interpretVignette: aHumFrame4Vignette withInput: aUserInput   "Send response lines. Execute response instructions."   | responseLines responseInstructions jobTicket calc |   responseLines := aHumFrame4Vignette responseLines.   self assert: (responseLines size &gt; 0).   responseInstructions := aHumFrame4Vignette instructionLines.   self assert: (responseInstructions size &gt;= 0).   "Extract any values in user input and update blackboard.   NOTE: The all patterns must have identical slots."   self extractFieldValuesFromUserInput: aUserInput pattern: (aHumFrame4Vignette patterns at: 1).   "Interpret the response lines (fill in any value slots as needed)."   responseLines       do: [ :responseLine |          "Interpret markup."         self sayToClient: responseLine. ].   "If there are no instructions in the response, we are done."      responseInstructions       ifEmpty: [^self].   "TODO: What is the rationale for job-ticket in this context?"      jobTicket := HumJobTicket title: 'jobTicket who:',clientID,' when:', (self clock asString),' why: ',#dialog.   "Interpret any instructions found in the response."   calc := HumCalculator new.   responseInstructions      do: [ :instructionLine |         | role |         role := instructionLine role.         calc cases;            when: [ role isNil ] "TODO: Using nil value as a signal is dangerous."               then: ["Dialog Agent instruction - I do it."                  Error signal: 'Why is this different from blank role?'.                  self runInstruction: instructionLine inRole: role onJob: jobTicket.];            when: [ role = '' ]                then: ["Dialog Agent instruction - I do it."                  self runAction: instructionLine inRole: 'DialogAgent' onJob: jobTicket.];            when: [ role sameAs: 'Goal' ]                then: ["Start a plan running"                  | coordinator |                  coordinator := HumActor                                              coordinatorID: myID,'-coordinator' "TODO: Distinguish multiple coordinators"                                             uri: myURI                                              goal: (instructionLine statement)                                              dialog: self                                              configuration: (self configuration).                  coordinator checkIn.                   coordinator runPlan. "TODO: [1] Fork this. [2] Figure out: What if the dialog agent goes down?"                        ];            when: [ role &gt; '' ]               then: ["Delegated instruction"                  self delegateAction: instructionLine toRole: role onJob: jobTicket.];           otherwise: [ Error signal: 'How did we get here?'].         ].</pre><h3>Hum-RunTime -- HumDialogAgent &gt;&gt; newEntity:</h3><pre>newEntity: anEntityType    "Create a new entity to be associated with the given entity-type/entity-name."   "TODO: If the blackboard already contains and entity of that type,             it should be saved before the new one is instantiated."   "TODO: Think about the interaction between business process roles, entity-type, and views."   | |   (self blackboard) makeEntityOfType: anEntityType.   "Advice: New business entities are created in the blackboard when a dialog requires them.   The blackboard (HumBlackBoard) will handle persistence by calling a World-Base.   Note: The world-base can be configured to purge data quickly. But why would you do that?   "   </pre><h3>Hum-RunTime -- HumDialogAgent &gt;&gt; pushContext:</h3><pre>pushContext: aString    ( self contextStack ) push: aString.</pre><h3>Hum-RunTime -- HumDialogAgent &gt;&gt; runAction:inRole:onJob:</h3><pre>runAction: anAction inRole: aRole onJob: aHumJobTicket   "Dialog Agent knows: 'Ask view', 'Show view', 'Push context ...'"    | calc source |   self assert: (aRole = 'DialogAgent').   (anAction isKindOf: String)       ifTrue: [source := anAction].   (anAction isKindOf: HumInstructionLine)      ifTrue: [source := anAction statement source].   self assert: (source isKindOf: String).   ( source trimBoth = '' ) ifTrue: [ ^self ].   self stepLog add: ('DialogAgent: {', myID,'} is doing: {',source,'}' ).   calc := HumCalculator new.   calc cases;      when: [source sameAs: '' ] then: ["Blank line or comment line."];      when: [source beginsWith: 'Ask ']         then: [ self askView: (calc given: source extractAfter: 'Ask ' ).];      when: [source beginsWith: 'Show ']         then: [ self showView: (calc given: source extractAfter: 'Show ' ).];      when: [source beginsWith: 'New ']         then: [ self newEntity: (calc given: source extractAfter: 'New ' ).];      "TODO: Give some thought to the interaction of business process roles and views."      when: [source beginsWith: 'Push context ']         then: [ self pushContext: (calc given: source extractAfter: 'Push context ' ).];      when: [source beginsWith: 'Push ']         then: [ self pushContext: (calc given: source extractAfter: 'Push ' ).];      otherwise: [Error signal: 'Action not recognized: {',source,'}'].            </pre><h3>Hum-RunTime -- HumDialogAgent &gt;&gt; sayToClient:</h3><pre>sayToClient: aHumMarkupLine    "Say something to the client.     Subtypes will override."   | systemResponse |   systemResponse := aHumMarkupLine source.    [systemResponse includes: $[ ]         whileTrue: [ systemResponse := self fillInSlotIn: systemResponse ].   self assert: (systemResponse includes: $[) not.   (self stepLog) add: ('S: ', systemResponse ).   "Delegate actual UI to my Scribe."   (self scribeProxy) systemSays: systemResponse.    </pre><h3>Hum-RunTime -- HumDialogAgent &gt;&gt; scribeProxy</h3><pre>scribeProxy   "Return an instance that understands #systemSays:   "   ^scribeProxy       ifNil: [ "TODO: When we have more than one kind of Scribe, this needs to be refactored."         scribeProxy := HumScribe dialogAgent: self.          ].</pre><h3>Hum-RunTime -- HumDialogAgent &gt;&gt; showView:</h3><pre>showView: aViewName   | ontology viewFrame |   ontology := self ontology.    viewFrame := ontology getViewFrame: aViewName.   "Delegate display to my scribe."   (self scribeProxy) showView: viewFrame withBlackBoard: (self blackboard).</pre><h3>Hum-RunTime -- HumDispatcher &gt;&gt; actor:completedAction:</h3><pre>actor: anActor completedAction: aHumStatement   "Dispatcher is informed that the actor completed the assigned action.   See: #assignRole: roleString action: actionStatement   "   | bookkeeperInstance |   (anActor sameAs: myID)      ifTrue: ["Dispatcher (self) cannot be busy and must always be available."]      ifFalse: [   "Actor is no longer busy."                     ( self busyActors ) remove: anActor.                     ( self availableActors ) add: anActor.                     ].   "Send charges to bookkeeper."   "For now, just call direct.   TODO: Make asynch call to bookkeeper.   "   bookkeeperInstance := (self messenger) getActorInstanceFromID: (self configuration bookkeeperID).   "TODO: Refactor this. It is by-passing the messenger."   bookkeeperInstance recordJobTicket: ( aHumStatement jobTicket ) .   </pre><h3>Hum-RunTime -- HumDispatcher &gt;&gt; assignAction:toRole:forJob:</h3><pre>assignAction: aHumInstructionLine toRole: aByteString forJob: aHumJobTicket    self shouldBeImplemented.</pre><h3>Hum-RunTime -- HumDispatcher &gt;&gt; assignRole:action:</h3><pre>assignRole: roleString action: actionInstruction    "Assign the given action to an actor advertising the given role."   | actor potentialActors assignableActors  |   self assert: ( roleString isKindOf: String ).   self assert: ( roleString notEmpty ).   self assert: ( actionInstruction isKindOf: HumInstructionLine ).   potentialActors := Set new.   "Find an actor that knows the role."   ( self roleActor )       do: [ :map |          map key = roleString asLowercase              ifTrue: [ potentialActors add: map value. ].         ].   "Filter potential actors to include only available actors."   assignableActors := potentialActors intersection: (self availableActors).   "Assign an actor at random."   assignableActors ifEmpty: [Error signal: 'Set of assignableActors is empty - Now what?'].   actor := assignableActors atRandom.   (actor sameAs: myID)      ifTrue: ["Manager (self) cannot be busy and must always be available."]      ifFalse: ["Mark actor busy and not available."                     (self busyActors) add: actor.                     (self availableActors) remove: actor.                     ].         "Send the action to the actor."   self sendMessage: actionInstruction to: actor.   "Simulating asynch:    . The completion comes back via callback #actor: anActor completedAction: aStatement"      </pre><h3>Hum-RunTime -- HumDispatcher &gt;&gt; availableActors</h3><pre>availableActors   ^ availableActors ifNil: [ availableActors := Set new. ].</pre><h3>Hum-RunTime -- HumDispatcher &gt;&gt; busyActors</h3><pre>busyActors   ^ busyActors ifNil: [ busyActors := Set new ].</pre><h3>Hum-RunTime -- HumDispatcher &gt;&gt; checkInActor:at:withRoles:</h3><pre>checkInActor: actorID at: aURI withRoles: actorKnowsRoles    "The Dispatcher should delegate finding the URI to messenger."   "For each actor role:    . Add the actor to those that know that role."   self assert: ( actorKnowsRoles isKindOf: Array ).   actorKnowsRoles do: [ :aRole |      ( self roleActor )  add: ( aRole -&gt; actorID ).      ( self availableActors ) add: actorID.      ].      </pre><h3>Hum-RunTime -- HumDispatcher &gt;&gt; checkOutActor:at:</h3><pre>checkOutActor: anActorID at: anActorURI    "Actor is no longer available for assignments."   | resultRoleActor |   "Remove the actor from role-&gt;actor map."   resultRoleActor := ( self roleActor ) copy.   ( self roleActor )        do: [:roleActorMap |          (roleActorMap value = anActorID)             ifTrue: [ resultRoleActor remove: roleActorMap ].         ].   roleActor := resultRoleActor.      "Remove the actor from the available actor list."   ( self availableActors ) remove: anActorID.   "Assume actor will not check-out with work in progress.   If they do, the remove: will trigger an exception.   TODO: In asynch environment, it is possible for assignment and check-out to cross.   "   ^self.</pre><h3>Hum-RunTime -- HumDispatcher &gt;&gt; roleActor</h3><pre>roleActor   "Return the role-&gt;actor map set."   ^ roleActor ifNil: [ roleActor := Set new. ].</pre><h3>Hum-RunTime -- HumDispatcher &gt;&gt; runAction:inRole:onJob:</h3><pre>runAction: anAction inRole: aRole onJob: aHumJobTicket   "Dispatch the action to an actor in the given role."    |  |   self assert: ( aRole isKindOf: String ).   self assert: ( aRole notEmpty ).   self assert: ( anAction isKindOf: HumInstructionLine ).   ( aRole = #dispatcher )      ifTrue: ["This action is for me as dispatcher."         self assert: (anAction statement translation notNil).         Compiler evaluate: (anAction statement translation) for: self logged: false.         ^self.         ].   "Otherwise: Assign action to an actor that has registered previously with that role."      anAction jobTicket: aHumJobTicket.   self assignRole: aRole action: anAction    </pre><h3>Hum-RunTime -- HumDispatcher &gt;&gt; sendMessage:to:</h3><pre>sendMessage: aMessageObject to: recipientID.   "TODO: HumActor does not need to know that delegating a statement is a message send.    Replace this with something like: self delegateAction: aStatement to: aRole.   "   "self checkID: recipientID."   self assert: (aMessageObject isKindOf: HumInstructionLine).    ( self messenger ) sendAction: aMessageObject toID: recipientID fromID: myID.      </pre><h3>Hum-RunTime -- HumEntity &gt;&gt; asString</h3><pre>asString   ^self title.</pre><h3>Hum-RunTime -- HumEntity &gt;&gt; debug</h3><pre>debug   "Am I in debug mode?"   ^ debug ifNil: [debug := false].</pre><h3>Hum-RunTime -- HumEntity &gt;&gt; id</h3><pre>id   "Return a unique identifier."   | context |   ^ id ifNil: [ Error signal: 'Entity ID should be set by Blackboard or DialogAgent.'.            context := 'Default ID for ' , (self class asString). "Convenient for DEBUG?"            id := HumIdentifier createUniqueIdentifierForEntityName: title inContext: context             ].</pre><h3>Hum-RunTime -- HumEntity &gt;&gt; id:</h3><pre>id: aString    "Set the entity`s identifier."   id := aString</pre><h3>Hum-RunTime -- HumEntity &gt;&gt; printOn:</h3><pre>printOn: aStream   | myClassName |   myClassName := self class name.   aStream nextPutAll: ( myClassName,'(',id asString,')' ).</pre><h3>Hum-RunTime -- HumEntity &gt;&gt; title</h3><pre>title   "a display string describing this entity"    ^ title ifNil: [title := 'Unknown Entity'].</pre><h3>Hum-RunTime -- HumEntity &gt;&gt; title:</h3><pre>title: aString   "a display string describing this entity"    title := aString asString.   self id: (HumIdentifier createUniqueIdentifierForEntityName: title inContext: title). "???"   self id.</pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; *</h3><pre>* aHumFuzzy    | times result |   times := #*.   result := self op: times with: aHumFuzzy.   ^result.</pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; +</h3><pre>+ aHumFuzzy    | plus result |   plus := #+.   result := self op: plus with: aHumFuzzy.   ^result.</pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; -</h3><pre>- aHumFuzzy    | minus result |   minus := #-.   result := self op: minus with: aHumFuzzy.   ^result.</pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; /</h3><pre>/ aHumFuzzy    | divide result |   divide := #/.   result := self op: divide with: aHumFuzzy.   ^result.</pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; asCrudeMorph</h3><pre>asCrudeMorph      | magnifyBy scaleX scaleY scalePt vMax extent priorPt canvas morph |   magnifyBy := 2.   scaleX := [:v | v*magnifyBy].   scaleY := [:p | (100 - (100*p))*magnifyBy ]. "Flip Y. Screen coordinates have Y pointing down."   scalePt := [:pt | (scaleX value: (pt x))@(scaleY value: (pt y)) ].   vMax := distribution at: 1.0.   extent := ( scalePt value: (vMax@0.0) )* 1.1.      priorPt := scalePt value: 0.0@0.0.   canvas := FormCanvas extent: extent depth: 32 origin: (10@10) clipRect: (Rectangle origin: 0@0 extent: extent).     canvas fillColor: Color blue muchLighter.      "verticle grid"      (0.0 to: vMax by: 100.0)         do: [:v | canvas line: (scalePt value: v@0.0) to: (scalePt value: v@1.0) width: 1 color: Color green].     "horizontal grid"      (0.0 to: 1.0 by: 0.1)         do:[:p | canvas line: (scalePt value: 0.0@p) to: (scalePt value: vMax@p) width: 1 color: Color green].      (0.0 to: 1.0 by: 0.5)         do:[:p | canvas line: (scalePt value: 0.0@p) to: (scalePt value: vMax@p) width: 2 color: Color green].      self distributionDo: [ :p :v |       | xy |       xy := scalePt value: v@p.      canvas line: priorPt to: xy width: 4 color: Color red.      priorPt := xy.      ].    morph := canvas form asMorph openInWorld.    "You can delete morph by double-clicking it."   morph on: #doubleClick send: #delete to: morph. </pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; asCrudeMorph2</h3><pre>asCrudeMorph2      |  scaleX scaleY scalePt vMax extent priorPt canvas morph pPixels vPixels vMin |   pPixels := 2.   vPixels := 2.   vMax := distribution at: 1.0.   vMin := distribution at: 0.0.   "Normalize v range to [0,100]."   scaleX := [:v | 100*(v-vMin)/(vMax-vMin)*vPixels ].   "Flip Y. Screen coordinates have Y pointing down."   scaleY := [:p | (100 - (100*p))*pPixels ].    scalePt := [:pt | (scaleX value: (pt x))@(scaleY value: (pt y)) ].      extent := ( scalePt value: (vMax@0.0) )* 1.1. "TODO: Enable caller to specify extent."         priorPt := scalePt value: 0.0@0.0.   canvas := FormCanvas extent: extent depth: 32 origin: (10@10) clipRect: (Rectangle origin: 0@0 extent: extent).   "Paint grid lines"     canvas fillColor: Color blue muchLighter.      "vertical grid"      (vMin to: vMax by: ((vMax-vMin)*0.1))         do: [:v | canvas line: (scalePt value: v@0.0) to: (scalePt value: v@1.0) width: 1 color: Color green].      (vMin to: vMax by: ((vMax-vMin)*0.5))         do: [:v | canvas line: (scalePt value: v@0.0) to: (scalePt value: v@1.0) width: 2 color: Color green].     "horizontal grid"      (0.0 to: 1.0 by: 0.1)         do:[:p | canvas line: (scalePt value: 0.0@p) to: (scalePt value: vMax@p) width: 1 color: Color green].      (0.0 to: 1.0 by: 0.5)         do:[:p | canvas line: (scalePt value: 0.0@p) to: (scalePt value: vMax@p) width: 2 color: Color green].      self distributionDo: [ :p :v |       | xy |       xy := scalePt value: v@p.      canvas line: priorPt to: xy width: 4 color: Color red.      priorPt := xy.      ].    morph := canvas form asMorph openInWorld.    "You can delete morph by double-clicking it."   morph on: #doubleClick send: #delete to: morph. </pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; asCrudeMorphInRectangle:</h3><pre>asCrudeMorphInRectangle: aRectangle   "Display a plot in a Morph with the origin and extent indicated by the given Rectangle."   |  scaleX scaleY scalePt vMax extent priorPt canvas morph pPixels vPixels vMin r |   vMax := distribution at: 1.0.   vMin := distribution at: 0.0.   "Pixels per normalized value unit."   extent := (aRectangle extent) - (10@10).    vPixels := (extent x) / 100.   pPixels := (extent y) / 100.   "Normalize v range to [0,100]."   scaleX := [:v | 100*(v-vMin)/(vMax-vMin)*vPixels ].   "Flip Y. Screen coordinates have Y pointing down."   scaleY := [:p | (100 - (100*p))*pPixels ].    scalePt := [:pt | (scaleX value: (pt x))@(scaleY value: (pt y)) ].      extent := ( scalePt value: (vMax@0.0) )* 1.1. "TODO: Enable caller to specify extent."         canvas := FormCanvas extent: extent depth: 32 origin: (10@10) clipRect: (Rectangle origin: 0@0 extent: extent).   "Paint grid lines"     canvas fillColor: Color blue muchLighter.      "vertical grid"      (vMin to: vMax by: ((vMax-vMin)*0.1))         do: [:v | canvas line: (scalePt value: v@0.0) to: (scalePt value: v@1.0) width: 1 color: Color green].      (vMin to: vMax by: ((vMax-vMin)*0.5))         do: [:v | canvas line: (scalePt value: v@0.0) to: (scalePt value: v@1.0) width: 2 color: Color green].     "horizontal grid"      (0.0 to: 1.0 by: 0.1)         do:[:p | canvas line: (scalePt value: 0.0@p) to: (scalePt value: vMax@p) width: 1 color: Color green].      (0.0 to: 1.0 by: 0.5)         do:[:p | canvas line: (scalePt value: 0.0@p) to: (scalePt value: vMax@p) width: 2 color: Color green].   priorPt := scalePt value: vMin@0.0.      self distributionDo: [ :p :v |       | xy |       xy := scalePt value: v@p.      canvas line: priorPt to: xy width: 4 color: Color red.      priorPt := xy.      ].    morph := canvas form asMorph bounds: aRectangle.   morph openInWorld.    "You can delete morph by double-clicking it."   morph on: #doubleClick send: #delete to: morph. </pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; atP:</h3><pre>atP: aFloat    "Return the appropriate value from the distribution.   Iterpolate when necessary.    This version uses linear interpolation.   Future versions might use a spline or something."   | result |   "Check that aFloat is between zero and one"   self assert: ( aFloat isKindOf: Float ).   self assert: ( aFloat &gt;= 0.0 ).   self assert: ( aFloat &lt;= 1.00).   "Look up value or interpolate to get a result."   result := distribution at: aFloat ifAbsent: [ self interpolate: aFloat ].   ^ result.</pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; correctInterceptInDistribution:</h3><pre>correctInterceptInDistribution: aDistribution   "-- Use slope-intercept to get a better estimate of the S-curve value at probability 0.   v(p) = a + b*p   v(0) = a.   v(p1) = a + b*p1.   v(p2) = a + b*p2.   v(p2) - v(p1) = b*(p2-p1).   b = ( v(p2) - v(p1) ) / (p2-p1).   extrapolate a = v(0) so that we get the same slope b.   b = ( v(p2) - v(0) ) / (p2 - 0).   b = ( v(p2) - a ) / p2.   b * p2 = v(p2) - a.   a = v(p2) - (b * p2).   "   | tick p1 p2 v1 v2 b a |    self assert: (aDistribution isKindOf: Dictionary).   tick := sampleSize / resultDivisions.  "This must be coordinated to match &gt;&gt;op:with:"   p1 := (tick/sampleSize) asFloat.   p2 := (tick * 2/sampleSize) asFloat.   v1 := aDistribution at: p1.   v2 := aDistribution at: p2.   b := (v2 - v1) / (p2 - p1).   a := v2 - ( b * p2 ).   aDistribution at: 0.0 put: a.   </pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; distribution:</h3><pre>distribution: aDictionary    "Distribution is an S-curve that maps probability to value.   Example: 'distribution at: 0.50 put: 12.'      means that sample values will be less than or equal to 12 for 50% of samples.   In other words, the median of the distribution is 12.   "   self assert: ( aDictionary isKindOf: Dictionary ).   distribution := aDictionary.</pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; distributionDo:</h3><pre>distributionDo: pvBlock   "Vist the key-&gt;value (probability-&gt;value) entries in the distribution."   | keys |   self assert: ( pvBlock isKindOf: BlockClosure ).   self assert: ( pvBlock argumentCount = 2 ).   self assert: ( distribution isKindOf: Dictionary ).   keys := distribution keysSortedSafely.   keys       do: [ :p |         | v |         v := distribution at: p.         pvBlock value: p value: v.         ].</pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; fromScaledDecimal:</h3><pre>fromScaledDecimal: aScaledDecimal   "Set the distribution from the given string.   Assume the string value is the median (50% point) of a distribution.   Assume the 0% and 100% value are the median plus or minus the scale (number of decimal places).   "   | scaledDecimal assumedMedian err assumedDistribution calc |   calc := HumCalculator new.   calc cases;      when: [ aScaledDecimal isKindOf: ScaledDecimal ]         then: [ scaledDecimal := aScaledDecimal ];      when: [ aScaledDecimal isKindOf: String ]         then: [ scaledDecimal := ScaledDecimal readFrom: aScaledDecimal ];      otherwise: [ Error signal: 'Expected ScaledDecimal or String. Got: ', (aScaledDecimal class) ].   assumedMedian := scaledDecimal asFloat.   err := 10.0 raisedToInteger: (scaledDecimal scale negated).   assumedDistribution := Dictionary new.   assumedDistribution      at: 0.50 put: assumedMedian;      at: 0.00 put: assumedMedian - err;      at: 1.00 put: assumedMedian + err.   self distribution: assumedDistribution.    </pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; fromString:</h3><pre>fromString: aString   "Set the distribution from the given string.   Assume the string value is the median (50% point) of a distribution.   Assume the 0% and 100% value are the median plus or minus the scale (number of decimal places).   "   | scaledDecimal assumedMedian err assumedDistribution |   scaledDecimal := ScaledDecimal readFrom: aString.   assumedMedian := scaledDecimal asFloat.   err := (10.0 raisedToInteger: (scaledDecimal scale negated))/2.0.   assumedDistribution := Dictionary new.   assumedDistribution      at: 0.50 put: assumedMedian;      at: 0.00 put: assumedMedian - err;      at: 1.00 put: assumedMedian + err.   self distribution: assumedDistribution.    </pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; initialize</h3><pre>initialize   self sampleSize: 1024*16 resultDivisions: 32.   </pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; interpolate:</h3><pre>interpolate: aProbability   "Return the predicted value at aProbability using linear interpolation."   | lowerP lowerF upperP upperF slope result |   self assert: (aProbability isKindOf: Float ).   "Following depends on Dictionary semantics"   self assert: ( distribution isKindOf: Dictionary ).   "Find the interval that brackets the requested point."   lowerP := 0.0.   lowerF := distribution at: lowerP.   upperP := 1.0.   upperF := distribution at: upperP.   distribution keysAndValuesDo: [ :k :v |      ( k &gt; lowerP and: [ k &lt; aProbability ] ) ifTrue: [ lowerP := k. lowerF := v. ].      ( k &lt; upperP and: [ k &gt; aProbability ] ) ifTrue: [ upperP := k. upperF := v. ].      ].   "Do simple linear interpolation."   slope :=  ( upperF - lowerF ) / ( upperP - lowerP ).   "Check: for an S-Curve the slope is always positive."   self assert: ( slope &gt; 0.0 ).      result := lowerF + ( (aProbability - lowerP) * ( slope) ).   "Check: the result must be between upper and lower function values"   self assert: ( result &gt; lowerF ).   self assert: ( result &lt; upperF ).   "TODO: If we need more accuracy, use two quadratic splines.   Currently, the data we have does not justify such accuracy,   so I decided to keep it simple.   "   ^result.</pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; mean</h3><pre>mean   | sum n result |   sum := 0.0.   n := 0.   self sampleWithBlock: [ :x | n := n + 1. sum := sum + x.].   result := sum / n.   ^result.</pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; median</h3><pre>median   "find the point that represents the median"   |  medianPoint |   "Distribution is list of f-&gt;p".   "Look for f@0.50"   medianPoint := self atP: 0.50.   ^medianPoint.</pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; op:with:</h3><pre>op: aSymbol with: aHumFuzzy "Add two fuzzy distibutions using Monte Carlo sampling"   | resultSet random  vC sortedSet distributionC tick count fuzzyC |   resultSet := Bag new.   random := Random new.   ( 1 to: sampleSize )      do: [ :i |         | rA rB vA vB |         rA := random next.         vA := self atP: rA.         rB := random next.         vB := aHumFuzzy atP: rB.         vC := vA perform: aSymbol with: vB.         resultSet add: vC.         ].   "Create a new distribution with points every 10%"   sortedSet := resultSet asSortedCollection.   self assert: ( sortedSet size = sampleSize ).   "Note: Assertion above occasionally fails due to accidental matches in set.   TODO: CONSIDER USING A BAG INSTEAD OF A SET."   distributionC := Dictionary new.   distributionC at: 0.0 put: ( sortedSet first ). "This is a placeholder."   tick := sampleSize / resultDivisions.   count := 0.   sortedSet      do: [ :x |             | modulo |            modulo := ( count \\ tick ).            ( modulo = 0 )               ifTrue: [ distributionC at: ( (count/sampleSize) asFloat )  put: x ].           count := count + 1.          ].   distributionC at: 1.0 put: (sortedSet last).   "self correctInterceptInDistribution: distributionC."   self assert: ( distributionC size = (resultDivisions + 1) ).   fuzzyC := self copy distribution: distributionC.   ^fuzzyC.      </pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; sampleSize:</h3><pre>sampleSize: anInteger   "Reset the sample size used in Monte Carlo sampling of input distributions.   Default value is preset in &gt;&gt;initialize method.   A value on the order of 10,000 produces good results.   The sampleSize must be a multiple of 10. (See &gt;&gt;op:with:)   "   sampleSize := anInteger.</pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; sampleSize:resultDivisions:</h3><pre>sampleSize: aSampleSize resultDivisions: aDivisionCount   "Reset the sample size used in Monte Carlo sampling of input distributions.   Default value is preset in &gt;&gt;initialize method.   A value on the order of 10,000 produces good results.   The sampleSize must be a multiple of aDivisionCount. (See &gt;&gt;op:with:)   "   self assert: (aSampleSize \\ aDivisionCount = 0).   "The Monte Carlo will randomly sample the inputs this many times."   sampleSize := aSampleSize.   "The resulting S-curve will have N+1 points selected from sampleSize points."   resultDivisions := aDivisionCount. </pre><h3>Hum-RunTime -- HumFuzzy &gt;&gt; sampleWithBlock:</h3><pre>sampleWithBlock: aBlock "Operate on fuzzy distibution using Monte Carlo sampling"   | resultSet random |   resultSet := Set new.   random := Random new.   ( 1 to: sampleSize )      do: [ :i |         | rA  vA  |         rA := random next.         vA := self atP: rA.         aBlock value: vA.         ].      </pre><h3>Hum-RunTime -- HumHttpRequest &gt;&gt; atField:put:</h3><pre>atField: aKey put: aValue   "The Http Request form included this input name:value pair."   (self fields) at: aKey put: aValue.</pre><h3>Hum-RunTime -- HumHttpRequest &gt;&gt; fields</h3><pre>fields   |  |   ^myFields ifNil: [myFields := Dictionary new.].</pre><h3>Hum-RunTime -- HumIdentifier &gt;&gt; <</h3><pre>&lt; aHumIdentifier    | result |   result := ( self asString &lt; aHumIdentifier asString ).   ^ result.</pre><h3>Hum-RunTime -- HumIdentifier &gt;&gt; <=</h3><pre>&lt;= aHumIdentifier    | result |   result := ( self asString &lt;= aHumIdentifier asString ).   ^ result.</pre><h3>Hum-RunTime -- HumIdentifier &gt;&gt; asString</h3><pre>asString      (bigNumber isKindOf: Integer )       ifFalse: [ Error signal: 'bigNumber should be an Integer'.         ^(entityName asString),':',(bigNumber asString)].   ^ (entityName asString),':',(bigNumber printStringHex).</pre><h3>Hum-RunTime -- HumIdentifier &gt;&gt; entityName</h3><pre>entityName   "Return entity name -- force nil to string if needed."   ^ entityName asString.</pre><h3>Hum-RunTime -- HumIdentifier &gt;&gt; generateForEntityName:inContext:</h3><pre>generateForEntityName: anEntityName inContext: aBusinessEvent   "Make self a unique identifier for given entity context."   | ticks days seconds nanos prior priorDays priorSeconds priorNanos priorBigNumber |   self assert: (anEntityName isKindOf: String).   self assert: (aBusinessEvent isKindOf: String).   self assert: (aBusinessEvent &gt; ' ').   "TODO: Think: Should the business context where the entity originates be embedded in the ID somehow ???"   entityName := anEntityName.   ticks := DateAndTime now asUTC ticks copy.   days := ticks at: 1.   seconds := ticks at: 2.   nanos := ticks at: 3.   "Singleton holds prior values."   prior := self class.   priorDays := prior days.   priorSeconds := prior seconds.   priorNanos := prior nanos.   ( days = priorDays and: [ seconds = priorSeconds and: [ nanos &lt;= priorNanos ] ] )      ifTrue: [ nanos := (prior nanos) + 1. ].   "Post Conditions:"      bigNumber := (((days * 86400) + seconds) * 1e9) + nanos.   priorBigNumber := ( ((priorDays * 86400) + priorSeconds) * 1e9) + priorNanos.   self assert: ( bigNumber &gt; priorBigNumber ).   "Set the singleton values."   prior days: days seconds: seconds nanos: nanos.   self uuid: self class uuid.   </pre><h3>Hum-RunTime -- HumIdentifier &gt;&gt; initialize</h3><pre>initialize   "This UUID represents the run-time.    TODO: THIS IS A STUB.    EVENTUALLY, THIS SHOULD BE SET FROM A CONFIGURATION FILE OR SOMETHING."   uuid := UUID new.</pre><h3>Hum-RunTime -- HumIdentifier &gt;&gt; printOn:</h3><pre>printOn: aStream   aStream nextPutAll: (self asString).</pre><h3>Hum-RunTime -- HumIdentifier &gt;&gt; uuid:</h3><pre>uuid: aUUID    uuid := aUUID</pre><h3>Hum-RunTime -- HumJobTicket &gt;&gt; appendCharge:forAction:byActor:inRole:onJob:</h3><pre>appendCharge: aHumMeasure forAction: action byActor: anID inRole: aRoleName onJob: aJobID    | charge debug |   "Use a dictionary to represent a charge."      charge := Dictionary new.   charge       at: 'measure' put: aHumMeasure "asString";      at: 'action'  put: action asString;      at: 'ID'      put: anID asString;      at: 'role'    put: aRoleName asString;      at: 'job'     put: aJobID asString.   debug := false.    debug       ifTrue: [          Transcript cr.         charge keysAndValuesDo: [:k :v | Transcript show: ' ',k,': ', v asString.]         ].         "Append this charge to ticket`s charges."   
  ( self charges ) add: charge.   </pre><h3>Hum-RunTime -- HumJobTicket &gt;&gt; charges</h3><pre>charges   ^charges ifNil: [ charges := OrderedCollection new.]</pre><h3>Hum-RunTime -- HumJobTicket &gt;&gt; getActionSequence</h3><pre>getActionSequence   "Parse the job ticket to show the sequence of actions."   | listOfActions |   listOfActions := OrderedCollection new.   self charges      do:[:charge |         listOfActions add: (charge at: 'action') source.         ].   ^listOfActions.</pre><h3>Hum-RunTime -- HumJobTicket &gt;&gt; printOn:</h3><pre>printOn: aStream   |  |      aStream nextPutAll: ( 'Job:(',title asString,')' ).</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; *</h3><pre>* multiplier    | result |   result := self deepCopy.   (multiplier isKindOf: Number)       ifTrue: [ result := self deepCopy.                      result quantity: (self quantity * multiplier).                     ^result.                     ].   (multiplier isKindOf: Duration)      ifTrue: [         | m |         m := HumMeasure quantity: (multiplier asSeconds) units: #second.         result := self * m.         ^result.         ].   result quantity: (self quantity) * (multiplier quantity).   (multiplier dimensions)      keysAndValuesDo: [ :unit :exponent |          "Increment and net-out the dimensions."         result incrementDimensionsAt: unit by: exponent.         ].   ^result.   </pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; +</h3><pre>+ operand    | result |   "The units of measure must be the same."   self assert: (operand dimensions) = (self dimensions).   "Make a deep copy to get fresh dimensions and quantity."   result := self deepCopy.   result quantity: (self quantity) + (operand quantity).   ^result.   </pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; -</h3><pre>- operand    | result |   self assert: (operand dimensions) = (self dimensions).   result := self deepCopy.   result quantity: (self quantity) - (operand quantity).   ^result.   </pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; /</h3><pre>/ aDivisor    | result divisor |      result := self deepCopy.   ( aDivisor isKindOf: HumMeasure )      ifTrue: [divisor := aDivisor].   ( aDivisor isKindOf: Duration )      ifTrue: [divisor := HumMeasure quantity: (aDivisor asSeconds) units: #second. ].   ( aDivisor isKindOf: Number )      ifTrue: [ result quantity: (self quantity / aDivisor). ^ result. ].      "If the dimensions match, the result is a ratio. But we keep it as a HumMeasure to enable cascade."   self assert: ( divisor isKindOf: HumMeasure ).      ( divisor dimensions = self dimensions )      ifTrue: [ result := HumMeasure new quantity: (self quantity) / (divisor quantity). ^result. ].         "Otherwise"         result quantity: (self quantity) / (divisor quantity).   (divisor dimensions)      keysAndValuesDo: [ :unit :exponent |         "Decrement and net-out the dimensions."         result incrementDimensionsAt: unit by: (exponent negated).         ].   ^result.   </pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; <</h3><pre>&lt; operand    | result |   "The units of measure must be the same."   ((operand dimensions) = (self dimensions)) ifFalse: [ Error signal: 'Given measures are not comparable.' ].      result := (self quantity) &lt; (operand quantity).   ^result.   </pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; =</h3><pre>= operand    | result calc q |   ( operand isKindOf: HumMeasure) ifFalse: [ ^false ].   "The units of measure must be the same."   ((operand dimensions) = (self dimensions)) ifFalse: [^false].   q := self quantity.   calc := HumCalculator new.   calc cases;       when: [ self units = 'radian' ] then: [ result := self compareAngle: operand ];      when: [ q isKindOf: Float ] then: [ result := q closeTo: (operand quantity) ];      when: [ q isKindOf: Integer ] then: [ result := (q asFloat) closeTo: (operand quantity) ];      when: [ q isKindOf: Array ]          then: [ result := true.             (1 to: q size)                   do: [ :i |                      ((q at: i) closeTo: ( operand quantity at: i ))                        ifFalse: [ ^false. ]                     ].             ];      otherwise: [ Error signal: 'quantity not of expected type.' ]   .   ^result.   </pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; ></h3><pre>&gt; operand    | result |   "The units of measure must be the same."   ((operand dimensions) = (self dimensions)) ifFalse: [^false].      result := (self quantity) &gt; (operand quantity).   ^result.   </pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; @</h3><pre>@ aHumMeasure    | point x y |   self assert: (self units = #px)  description: 'Operator only valid for pixels.'.   self assert: (aHumMeasure units = #px)  description: 'Operator only valid for pixels.'.   x := self quantity.   y := aHumMeasure quantity.   self assert: (x isKindOf: Integer).   self assert: (y isKindOf: Integer).   point := x@y.   ^point.   </pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; abs</h3><pre>abs   | measure |   measure := self copy.   measure quantity: (quantity abs).   ^measure.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; adaptToCollection:andSend:</h3><pre>adaptToCollection: aCollection andSend: aSymbol    | resultingCollection |   Error signal: 'How did we get here?'.   resultingCollection := OrderedCollection new.   aCollection do: [ :each | resultingCollection add: (each perform: aSymbol with: self) ].   ^resultingCollection.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; arcTan:</h3><pre>arcTan: aDenominator    "Return the arc-tangent (angle) for self divided by aDenominator"   | angle |   self assert: (aDenominator isKindOf: HumMeasure).   self assert: ( self units ) = ( aDenominator units ).      angle := ( self quantity ) arcTan: ( aDenominator quantity ).   ^angle.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; as:</h3><pre>as: aSymbol   "Convert to the unit of measure indicated by aSymbol, and renders as String"   | result qty divisor string displayUnits calc |   divisor := 1.0 perform: aSymbol.   self assert: (self dimensions) = (divisor dimensions).   result := self / divisor.   qty := result quantity.   displayUnits := aSymbol asString.   calc := HumCalculator new.   calc cases;      when: [(qty abs) between: 0.1 and: 99999.0 ] then: [  string := ( ( qty printShowingDecimalPlaces: 3), ' ', displayUnits ) ];      when: [(qty abs) between: 0.01 and: 0.1 ] then: [  string := ( ( qty printShowingDecimalPlaces: 4), ' ', displayUnits ) ];      otherwise: [ string := ( ( qty asString                    ), ' ', displayUnits )].   ^string.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; asFloat</h3><pre>asFloat   | q |   q := self quantity asFloat.   self assert: (q isKindOf: Float).   ^q.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; asMillimeter</h3><pre>asMillimeter   "Convert pixel dimensions to millimeter dimensions"   | px result debug |   (self units = 'meter') ifTrue: [ ^self ].   self assert: (self units = 'px') description: 'This method is dedicated to converting pixel dimensions into millimeters'.   px := (1.0 / (self class pxPerMillimeter)) millimeter.  "There are about 5 px per mm on my laptop."    "For convenience while debugging. Enlarge those pixels?"   (debug := true ) ifTrue: [ px := 1 millimeter.  ].   result := px * (self quantity).   self assert: ( result isKindOf: HumMeasure ).   ^result.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; asMillimeters</h3><pre>asMillimeters   ^self asMillimeter.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; asPercent</h3><pre>asPercent   | measure |   "This is valid only if given measure is dimensionless."   self assert: (self isDimensionless).   measure := HumMeasure quantity: (self quantity / 0.01) units: '%'.   "For this to be useful,    the caller needs to define what 100 percent means    with something like:   windowWidth := (1600 px)/(100 percent)."   "TODO: Consider simply returning a scalar: (^self * 0.01)"   ^measure.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; asString</h3><pre>asString   | result  |   result := self quantityAsString, ' ', self displayUnits.   ^result.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; compareAngle:</h3><pre>compareAngle: aRadianMeasure   "Handle special arithmetic for comparing angles."   | thisAngle thatAngle result |   thisAngle := self quantity.   thatAngle := aRadianMeasure quantity.   result := true.   ( (thisAngle sin) closeTo: (thatAngle sin) ) ifFalse: [ result := false ].      ( (thisAngle cos) closeTo: (thatAngle cos) ) ifFalse: [ result := false ].   ^result.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; cos</h3><pre>cos   self assert: (self isRadian).   ^ quantity cos.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; cubed</h3><pre>cubed   | x  result |   x := self.   result := x * x * x.   ^result.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; dimensions</h3><pre>dimensions   "Tracks units and powers of units -- "   ^ dimensions ifNil: [ dimensions := Dictionary new.]</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; dimensions:</h3><pre>dimensions: aDictionary    | calc |   calc := HumCalculator new.   calc cases;      when: [ aDictionary isKindOf: Dictionary ] then: [ dimensions := aDictionary copy ];      when: [ aDictionary isKindOf: Array ]          then: [ dimensions := Dictionary new.             aDictionary do: [ :map |                                  dimensions at: (map key asSymbol) put: (map value)               ].             ];      otherwise:   [ Error signal: 'dimensions should be dictionary-like' ].</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; displayUnits</h3><pre>displayUnits   | displayUnits |   displayUnits := (self units).   (self dimensions = (Dictionary newFrom: {'kilogram'-&gt;1. 'meter'-&gt;1. 'second'-&gt;(-2).}) )         ifTrue: [displayUnits := 'Newton'].   (self dimensions = (Dictionary newFrom: {'kilogram'-&gt;1. 'meter'-&gt;(-1). 'second'-&gt;(-2).}) )         ifTrue: [displayUnits := 'Pascal'].   (self dimensions = (Dictionary newFrom: {'kilogram'-&gt;1. 'meter'-&gt;2. 'second'-&gt;(-2).}) )      ifTrue: [displayUnits := 'Joule'].   (self dimensions = (Dictionary newFrom: {'kilogram'-&gt;1. 'meter'-&gt;2. 'second'-&gt;(-3).}) )      ifTrue: [displayUnits := 'Watt'].   (self dimensions = (Dictionary newFrom: {'pound'-&gt;1. 'foot'-&gt;1. 'second'-&gt;(-1).}) )      ifTrue: [displayUnits := 'foot pound per second'].   (self dimensions = (Dictionary newFrom: {'pound'-&gt;1. 'foot'-&gt;1.}) )      ifTrue: [displayUnits := 'foot pound'].   ^displayUnits.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; incrementDimensionsAt:by:</h3><pre>incrementDimensionsAt: aUnit by: anIncrement   "Increment / Decrement dimension exponent by given increment (negative when decrementing).   "   | x |   self assert: (anIncrement isKindOf: SmallInteger ).   x := (self dimensions) at: aUnit ifAbsent: [0].   "Remove zeroed dimensions."   "TODO: THINK: This discards potentially useful information."   " e.g. meter^0 indicates scale or stress or coeficient of expansion ... "    (( x + anIncrement ) = 0 )            ifTrue:  [ (self dimensions) removeKey: aUnit ]              ifFalse: [ (self dimensions) at: aUnit put: ( x + anIncrement )].               "TODO: When units cancel (e.g. length/length), find some way to preserve information.   Example: L^0 Degree^-1 should find L^1 Degree^1 in a multiplier.    Note: The result is the same either way.    On reflection, I probably allowed units to disappear    so that dimensions interpreted as Energy would be easier to recognize.   "   </pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; isDimensionless</h3><pre>isDimensionless   "Is the current measure dimensionless?"   | result |   result := self dimensions = (Dictionary new).</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; isPixels</h3><pre>isPixels   | result |   result := (self units) = 'px'.   ^result.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; isRadian</h3><pre>isRadian   | result |   result := (self units) = 'radian'.   ^result.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; negated</h3><pre>negated   | result |   result := self deepCopy.   result quantity: (self quantity) negated.   ^result.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; printOn:</h3><pre>printOn: aStream   "Append to the argument, aStream, a sequence of characters that     identifies the receiver."   | title |   title := self class name.   aStream      nextPutAll: title;      nextPutAll: ( '( ', (self asString), ' )' ).</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; quantity</h3><pre>quantity   "Return the quantity that was observed for this instance."   | |   "Raise an error if caller attempts to access without a previous set."   ^ quantity ifNil: [ Error signal: 'measure quantity not set.' ].</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; quantity:</h3><pre>quantity: aNumber    quantity := aNumber</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; quantity:per:</h3><pre>quantity: aNumber per: denominatorUnits   "Set instance denominator units.    Use this method when the quantity is something like coefficient of expansion.    coefficient := HumMeasure quantity: 6.5e-6 per: #degreeCentigrade.   "   | exponent standardName numeratorExponent |   quantity := aNumber.      exponent := -1.   (denominatorUnits beginsWith: 'square' ) ifTrue: [ exponent := -2 ].   (denominatorUnits beginsWith: 'cubic' ) ifTrue: [ exponent := -3 ].   standardName := self standardNameFor: denominatorUnits.   (self dimensions) at: standardName put: exponent.        </pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; quantity:units:</h3><pre>quantity: aNumber units: numeratorUnits    "Set instance numerator units   "   |  exponent |   quantity := aNumber.      ( numeratorUnits asString = 'none' ) ifTrue: [  ^self ]. "Dimensionless measure."      exponent := 1.   (numeratorUnits beginsWith: 'square' ) ifTrue: [ exponent := 2 ].   (numeratorUnits beginsWith: 'cubic' ) ifTrue: [ exponent := 3 ].   (self dimensions) at: (self standardNameFor: numeratorUnits ) put: ( exponent ).        </pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; quantity:units:per:</h3><pre>quantity: aNumber units: numeratorUnits per: denominatorUnits   "Set instance numerator and denominator units.   Example1:      milesPerHour := HumMeasure2 quantity: 65 units: 'miles' per: 'hour'.      feetPerMile := HumMeasure2 quantity: 5280 units: 'feet' per: 'mile'.      feetPerHour := milesPerHour * feetPerMile.       secondsPerHour := HumMeasure2 quantity: 3600 units: 'seconds' per: 'hour'.       feetPerSecond := feetPerHour / secondsPerHour.   "   | exponent standardName numeratorExponent |   quantity := aNumber.   exponent := 1.   (numeratorUnits beginsWith: 'square' ) ifTrue: [ exponent := 2 ].   (numeratorUnits beginsWith: 'cubic' ) ifTrue: [ exponent := 3 ].   (self dimensions) at: (self standardNameFor: numeratorUnits) put: ( exponent ).      exponent := -1.   (denominatorUnits beginsWith: 'square' ) ifTrue: [ exponent := -2 ].   (denominatorUnits beginsWith: 'cubic' ) ifTrue: [ exponent := -3 ].   standardName := self standardNameFor: denominatorUnits.   "Get matching numerator exponent, if any, so that we correctly handle ratios     such as 'length per length' and 'dollars per dollar' "   numeratorExponent := (self dimensions) at: standardName ifAbsent: [0].   (self dimensions) at: standardName put: ( numeratorExponent + exponent ).        </pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; quantityAsString</h3><pre>quantityAsString   "Return the quantity that was observed for this instance."   | result |   result := self quantityAsString: (self quantity).   ^result.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; quantityAsString:</h3><pre>quantityAsString: q   "Return the quantity that was observed for this instance."    | result |      self assert: (q isKindOf: Number).      ( q = (q truncated) )       ifTrue:[ result := ((q truncated) asString).                     ^result.                 ].   ((q abs) between: 0.001 and: 99999.0 )      ifTrue:  [ result := ( ( q printShowingDecimalPlaces: 3) )  ]      ifFalse: [ result := ( ( q asString                    ) )  ].   ^result.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; sin</h3><pre>sin   self assert: (self isRadian).   ^ quantity sin.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; sqrt</h3><pre>sqrt   | instance |   instance := HumMeasure new.   instance quantity: (self quantity sqrt).   (self dimensions)       keysAndValuesDo:  [ :dimension :exponent |          (instance dimensions) at: dimension put: (exponent/2).          ].   ^instance.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; standardNameFor:</h3><pre>standardNameFor: aString    "Fix up names of units to assure consistency."   | unitsString |   unitsString := aString asString trimBoth.   "Remove square- cubic-"   (unitsString beginsWith: 'square' ) ifTrue: [ unitsString := unitsString copyReplaceTokens: 'square' with: ''].   (unitsString beginsWith: 'cubic' ) ifTrue: [ unitsString := unitsString copyReplaceTokens: 'cubic' with: ''].   unitsString := unitsString trimBoth.   "Standardize terms"   unitsString := (self unitsSynonyms) at: unitsString ifAbsent: [ unitsString ].         self assert: ( unitsString endsWith: 's' ) not.   ^unitsString.</pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; units</h3><pre>units   "Render dimensions as a string"   | string append prefix  secondPassNeeded |   append := Dictionary new.   append       at: 2 put: 'square ';      at: 3 put: 'cubic '.   string := String new.   secondPassNeeded := false.   (self dimensions)      keysAndValuesDo: [ :unit :exponent |               ( exponent &gt; 0 )                   ifTrue: [                      prefix := append at: exponent ifAbsent: [''].                     string := string, prefix, unit, ' '.                           ]                  ifFalse: [ (exponent &lt; 0 ) ifTrue: [ secondPassNeeded := true ] ].               ].   secondPassNeeded       ifTrue: [          string := string, 'per '.         (self dimensions)            keysAndValuesDo: [ :unit :exponent |               ( exponent &lt; 0 )                   ifTrue: [                      prefix := append at: (exponent negated) ifAbsent: [''].                     string := string, prefix, unit, ' '.                           ]               ].         ].      ^string trimBoth.   </pre><h3>Hum-RunTime -- HumMeasure &gt;&gt; unitsSynonyms</h3><pre>unitsSynonyms   ^ self class unitsSynonyms</pre><h3>Hum-RunTime -- HumMessage &gt;&gt; nounValues:</h3><pre>nounValues: associations    "TODO: Consider: a HumStatement also has nounValues. Which noun values are which?"   nounValues := associations</pre><h3>Hum-RunTime -- HumMessage &gt;&gt; receiver:</h3><pre>receiver: aString    receiver := aString </pre><h3>Hum-RunTime -- HumMessage &gt;&gt; sender:</h3><pre>sender: aString    sender := aString.</pre><h3>Hum-RunTime -- HumMessage &gt;&gt; statement:</h3><pre>statement: aHumStatement    statement := aHumStatement </pre><h3>Hum-RunTime -- HumMessage &gt;&gt; whenSent:</h3><pre>whenSent: aTimeStamp    " "   self assert: (( aTimeStamp isKindOf: TimeStamp ) or: [ aTimeStamp isKindOf: Duration ]).   whenSent := aTimeStamp </pre><h3>Hum-RunTime -- HumMessenger &gt;&gt; getActorInstanceFromID:</h3><pre>getActorInstanceFromID: actorID   "*** Backdoor *** during debug to bypass the messenger"   | actorInstance someURI |   self assert: (actorID notNil).   someURI := (self nodeIDtoURI) at: actorID ifAbsent: [Error signal: 'Trouble getting actorURI for: ', actorID ].   actorInstance := (self network uriToNode) at: someURI ifAbsent: [Error signal: 'Trouble getting actorInstance for: ', actorID ].   ^actorInstance.</pre><h3>Hum-RunTime -- HumMessenger &gt;&gt; logInstruction:sentFrom:to:</h3><pre>logInstruction: aHumStatement sentFrom: senderURI to: recipientURI    | timeNow logEntry |   "Get the clock time - may be a simulator clock"   timeNow := ( self clock ) now.   logEntry := (self playbackLog) at: senderURI ifAbsent: [ logEntry := OrderedCollection new. ].   logEntry add: { senderURI.  recipientURI. aHumStatement. timeNow. }.   playbackLog at: senderURI put: logEntry.</pre><h3>Hum-RunTime -- HumMessenger &gt;&gt; network</h3><pre>network   "Return the chosen physical implementation of network service."   ^ network ifNil: [ network := HumNetwork new].</pre><h3>Hum-RunTime -- HumMessenger &gt;&gt; nodeIDtoURI</h3><pre>nodeIDtoURI   "actorURI contains (actor-&gt;URI) maps"   ^ nodeIDtoURI ifNil: [ nodeIDtoURI := Dictionary new ].</pre><h3>Hum-RunTime -- HumMessenger &gt;&gt; ping:</h3><pre>ping: aURI   "MOCK: Return the ID of the given URI"   ^ ( self uriToNodeID ) at: aURI ifAbsent: [ Error signal: 'Messenger has no ID entry for URI: ', aURI ].</pre><h3>Hum-RunTime -- HumMessenger &gt;&gt; playbackLog</h3><pre>playbackLog   ^playbackLog ifNil: [ playbackLog := Dictionary new].</pre><h3>Hum-RunTime -- HumMessenger &gt;&gt; playbackLogFromActor:</h3><pre>playbackLogFromActor: aHumActor    "Extract/Get log entries sent to/from a specific actor.   TODO: Should this be a URI instead of an Actor instance?"   | result |   (aHumActor isKindOf: HumActor)      ifTrue: [ result := self playbackLogFromURI: (aHumActor uri) ].   (aHumActor isKindOf: String )      ifTrue: [         (aHumActor beginsWith: 'URI:')             ifTrue: [ result := self playbackLogFromURI: aHumActor]             ifFalse:[               | actor |               actor := self getActorInstanceFromID: aHumActor.               result := (self playbackLog) at: (actor uri) ifAbsent: [ OrderedCollection new].               ].         ].   self assert: (result notNil).   (result isEmpty) ifTrue: [self halt.].   "TODO: Add timestamp feature.     Someday, we may want to roll-forward from a given timestamp.    Note: timestamps may be from simulated clock rather than system clock."   ^result.   </pre><h3>Hum-RunTime -- HumMessenger &gt;&gt; playbackLogFromURI:</h3><pre>playbackLogFromURI: aURI    "Extract/Get log entries sent to/from a specific actor.   TODO: Should this be a URI instead of an Actor instance?"   | result |   result := (self playbackLog) at: (aURI) ifAbsent: [ OrderedCollection new].   "TODO: Add timestamp feature.     Someday, we may want to roll-forward from a given timestamp.    Note: timestamps may be from simulated clock rather than system clock."   ^result.   </pre><h3>Hum-RunTime -- HumMessenger &gt;&gt; playbackLogToURI:</h3><pre>playbackLogToURI: aURI    "Extract/Get log entries sent to/from a specific actor.   TODO: Should this be a URI instead of an Actor instance?"   | result |   result := OrderedCollection new.   (self playbackLog)       keysAndValuesDo: [:key :value |         | actorLog |         actorLog := value.         actorLog do: [ :record |            | toURI |            toURI := record at: 2.            (toURI = aURI)               ifTrue: [ result add: record ].            ].         ].   "TODO: Add timestamp feature.     Someday, we may want to roll-forward from a given timestamp.    Note: timestamps may be from simulated clock rather than system clock."   ^result.   </pre><h3>Hum-RunTime -- HumMessenger &gt;&gt; registerActor:atURI:</h3><pre>registerActor: anActor atURI: aURI    "Track actor."   self assert: ( anActor isKindOf: HumActor ).   self assert: ( aURI isKindOf: String ).   "Track URI-&gt;actor association."   self registerNode: anActor atURI: aURI.</pre><h3>Hum-RunTime -- HumMessenger &gt;&gt; registerNode:atURI:</h3><pre>registerNode: aNode atURI: aURI    "Track actor."   self assert: ( aNode isKindOf: HumNode ).   self assert: ( aURI isKindOf: String ).   "Track URI-&gt;actor association."   (self network uriToNode) at: aURI put: aNode.   (self uriToNodeID) at: aURI put: (aNode id).   (self nodeIDtoURI) at: (aNode id) put: aURI.</pre><h3>Hum-RunTime -- HumMessenger &gt;&gt; sendAction:toID:fromID:</h3><pre>sendAction: anInstructionLine toID: recipientID fromID: senderID    "Transmit action request between actors."      | recipientURI senderURI|   self assert: (anInstructionLine isKindOf: HumInstructionLine).   self assert: (recipientID isKindOf:String).   self assert: (senderID isKindOf:String).      "Translate ID to URI."   recipientURI := ( self nodeIDtoURI ) at: recipientID                                           ifAbsent: [Error signal: 'Messenger has no URI for recipient ID: ', recipientID].                                       senderURI := ( self nodeIDtoURI ) at: senderID                                           ifAbsent: [Error signal: 'Messenger has no URI for sender ID: ', senderID].   "Send  . . ."   self sendAction: anInstructionLine toURI: recipientURI fromURI: senderURI.   </pre><h3>Hum-RunTime -- HumMessenger &gt;&gt; sendAction:toURI:fromURI:</h3><pre>sendAction: anInstruction toURI: recipientURI fromURI: senderURI    "Send the (action) statement to the given actor."   | |   self assert: (anInstruction isKindOf: HumInstructionLine).   self logInstruction: anInstruction sentFrom: senderURI to: recipientURI.    "Delegate implementation to HumNetwork"   self network sendAction: anInstruction toURI: recipientURI fromURI: senderURI.       </pre><h3>Hum-RunTime -- HumMessenger &gt;&gt; sendInstruction:toURI:fromURI:</h3><pre>sendInstruction: anInstruction toURI: recipientURI fromURI: senderURI   "Send the (action) statement to the given actor."   "TODO: REFACTOR so that this pushes to a network.    And so the network becomes the mock instead of the messenger.   This moves us toward using an actual network. (Likely a jabber network.)"   | actorInstance |   self assert: (anInstruction isKindOf: HumInstructionLine).   "Following only works when actor is local."   "TODO: Fix so that it works when actor is remote."   actorInstance := ( self uriToNode ) at: recipientURI                                  ifAbsent: [ Error signal: 'Messenger has no actor for URI: ', recipientURI ].   self logInstruction: anInstruction sentFrom: senderURI to: recipientURI.    actorInstance runInstruction: anInstruction inRole: (anInstruction role) onJob: (anInstruction jobTicket).   "TODO: Need a better simulation of async."   "========================================"      </pre><h3>Hum-RunTime -- HumMessenger &gt;&gt; uriToNodeID</h3><pre>uriToNodeID   "What actor ID is associated with URI?"   ^ uriToNodeID ifNil: [ uriToNodeID := Dictionary new]</pre><h3>Hum-RunTime -- HumNetwork &gt;&gt; sendAction:toURI:fromURI:</h3><pre>sendAction: anInstruction toURI: recipientURI fromURI: senderURI    "Send the (action) statement to the given actor."   | actorInstance calc |   self assert: (anInstruction isKindOf: HumInstructionLine).   "Following only works when actor is local."   "TODO: Fix so that it works when actor is remote."   calc := HumCalculator new.   calc cases;      when: [recipientURI beginsWith: 'http:'] then: [self shouldBeImplemented];      when: [recipientURI beginsWith: 'email:'] then: [self shouldBeImplemented];     otherwise: [   "Assume actor is local."         actorInstance := ( self uriToNode ) at: recipientURI                                  ifAbsent: [ Error signal: 'Network has no actor for URI: ', recipientURI ].         actorInstance runAction: anInstruction inRole: (anInstruction role) onJob: (anInstruction jobTicket).      ].      </pre><h3>Hum-RunTime -- HumNetwork &gt;&gt; uriToNode</h3><pre>uriToNode   "Return dictionary that maps a URI to an actual actor instance"   "NOTE: This should only be used in test/local mode.    (Mode where actors are running in same VM as the messenger.)"   ^ uriToNode ifNil: [ uriToNode := Dictionary new. ].</pre><h3>Hum-RunTime -- HumNode &gt;&gt; asString</h3><pre>asString   ^ self id ifNil: [ 'no ID'].</pre><h3>Hum-RunTime -- HumNode &gt;&gt; checkIn</h3><pre>checkIn   | |   "Check-in with the messenger."   ( self messenger ) registerActor: self atURI: (self uri).</pre><h3>Hum-RunTime -- HumNode &gt;&gt; clock</h3><pre>clock   ^ clock ifNil: [clock := DateAndTime "class singleton"].</pre><h3>Hum-RunTime -- HumNode &gt;&gt; clock:</h3><pre>clock: anObjectThatImplementsNow   clock := anObjectThatImplementsNow.   "WARNING: #clock also appears in HumConfiguration."</pre><h3>Hum-RunTime -- HumNode &gt;&gt; configuration</h3><pre>configuration   ^ configuration ifNil: [Error signal: 'Node has not been configured.'].</pre><h3>Hum-RunTime -- HumNode &gt;&gt; configuration:</h3><pre>configuration: aHumConfiguration    self assert: ( aHumConfiguration isKindOf: HumConfiguration ).   configuration := aHumConfiguration.</pre><h3>Hum-RunTime -- HumNode &gt;&gt; htmlAgent</h3><pre>htmlAgent   "Return http/html agent implementation.   If none has been set, use self as mock/dummy"   ^ htmlAgent ifNil: [ htmlAgent := self ].</pre><h3>Hum-RunTime -- HumNode &gt;&gt; id</h3><pre>id   ^myID</pre><h3>Hum-RunTime -- HumNode &gt;&gt; id:</h3><pre>id: aString    self assert: (aString isKindOf: String ).   myID := aString.</pre><h3>Hum-RunTime -- HumNode &gt;&gt; log</h3><pre>log   ^ log ifNil: [ log := OrderedCollection new ].</pre><h3>Hum-RunTime -- HumNode &gt;&gt; messenger</h3><pre>messenger   ^self configuration messenger.</pre><h3>Hum-RunTime -- HumNode &gt;&gt; printOn:</h3><pre>printOn: aStream   "Append to the argument, aStream, a sequence of characters that     identifies the receiver."   | title idString|   title := self class name.   idString := self asString.   aStream      nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);      nextPutAll: title;      nextPutAll: '(';      nextPutAll: idString;      nextPutAll: ')'.      </pre><h3>Hum-RunTime -- HumNode &gt;&gt; sendHTML:</h3><pre>sendHTML: htmlString    "This is a dummy/mock for testing."   self log add: 'sendHTML: {',htmlString,'}'.   self stepLog add: ('Actor: {', (myID ifNil: ['unknown']),'} is sending html {',htmlString withBlanksCondensed truncate,'}' ).</pre><h3>Hum-RunTime -- HumNode &gt;&gt; sendHTML:to:</h3><pre>sendHTML: htmlString to: aURL   "This is a dummy/mock for testing. TODO: Make this real."   self log add: 'sendHTML: {',htmlString,'}'.   self stepLog add: ('Actor: {', (myID ifNil: ['unknown']),'} is sending html {',(htmlString withBlanksCondensed truncateWithElipsisTo: 400),'}' ).</pre><h3>Hum-RunTime -- HumNode &gt;&gt; stepLog</h3><pre>stepLog   ^ stepLog ifNil: [ stepLog := OrderedCollection new.].</pre><h3>Hum-RunTime -- HumNode &gt;&gt; stepLogDisplay</h3><pre>stepLogDisplay   "Display the step log"   Transcript cr; show: 'Step log from actor: ', (self id asString);cr.   (self stepLog) do: [:s | Transcript show: '. ', s; cr.]</pre><h3>Hum-RunTime -- HumNode &gt;&gt; uri</h3><pre>uri   ^myURI.</pre><h3>Hum-RunTime -- HumNode &gt;&gt; uri:</h3><pre>uri: aURI   self assert: ( aURI isKindOf: String ).   myURI := aURI.   </pre><h3>Hum-RunTime -- HumNumberParser &gt;&gt; nDigits</h3><pre>nDigits   ^nDigits.</pre><h3>Hum-RunTime -- HumScribe &gt;&gt; about</h3><pre>about"See also: HumRunTimeTests&gt;&gt;testS100ScribeReadMe""Q: What is the relation between Sensor, Scribe, Widget, Canvas, Solid, ViewPort.A: The Scribe interprets inputs from the Sensor and updates a Widget.The Widget is drawn on a Canvas which is painted on a Surface.A Surface might be painted on a Solid within a Scene.Note: A Surface is not rendered if it is not visible to the Viewport`s Camera. The flow is Sensor &gt;&gt; Scribe &gt;&gt; Widget &gt;&gt; Canvas &gt;&gt; Surface &gt;&gt; ViewPort (Camera).""Q: What is the relationship between Sensor, Scribe, Widget, Blackboard, Dialog?A: The Scribe interprets Sensor inputs and updates both the view and the Dialog.The update of a Dialog might wait until form data is submitted.""THINK: Perhaps an Avatar is a type of widget. It is visible in the 3D view and may interact with the user.Hence it has behavior that is similar to a widget.However, it may be more convenient to treat an Avatar as a kind of role - a role to be assigned to an agent at run-time- an agent that happens to be active in a scene.""A Scene is mostly decoration, but it may also trigger interaction via proximity triggers.A proximity sensor is part of the scribe`s sensorium.Examples:U: User-Avatar enters the conference room.U: User-Avatar is facing the receptionist.""SUMMARY?A scribe has a sensorium.The sensorium includes . direct user-interface channels (keyboard, voice-to-text, pointer, touch, etc.). indirect user-interface widgets (widgets are probably provided by the visualization framework). scene-interface channels (proximity sensors, user-avatar location coordinates, inter-user text)"</pre><h3>Hum-RunTime -- HumScribe &gt;&gt; askView:withBlackBoard:</h3><pre>askView: viewFrame withBlackBoard: aBlackBoard   "Current implementation assumes user interface is a HTML browser."   "TODO: HTML stuff belongs in a subtype of Scribe."   |  htmlForm html |   self assert: (viewFrame isKindOf: HumFrame4View).   "Generate an HTML form for the view."   htmlForm := self ontology codeGenerator generateHTMLforViewFrame: viewFrame blackboard: aBlackBoard.   "Wrap the view with HTML prolog, navigation, epilog, etc."   html := self sendView: htmlForm.   "TODO: Associate an event with the ask-view data-entry."</pre><h3>Hum-RunTime -- HumScribe &gt;&gt; askViewCompleted</h3><pre>askViewCompleted   "Inform caller that the 'Ask viewName' task     that was delegated from dialog agent (caller)    to scribe (this instance) has been completed."   | |   "Skip this if there was no dialog caller."   instructionInProgress ifNil: [^self].   "Send results back to my Dialog Agent"   "TODO: ?? Do we return results in completion message ??      -OR- ?? Do we send a separate message ??      -OR- ??"   "Get current task context and send task complete message."   self completedInstruction: instructionInProgress inRole: 'Scribe' onJob: jobID.       </pre><h3>Hum-RunTime -- HumScribe &gt;&gt; blackboard</h3><pre>blackboard   "This instance variable should be set by the instance-creation logic. "   ^blackboard ifNil: [Error signal: 'Scribe blackboard should point to Dialog Agent blackboard.']</pre><h3>Hum-RunTime -- HumScribe &gt;&gt; client:</h3><pre>client: aClientConection    "synonym"   self clientConnection: aClientConection.</pre><h3>Hum-RunTime -- HumScribe &gt;&gt; clientConnection</h3><pre>clientConnection   ^ clientConnection ifNil:[ clientConnection := myURI ].</pre><h3>Hum-RunTime -- HumScribe &gt;&gt; clientConnection:</h3><pre>clientConnection: aConnectionOfSomeKind    "How does the Scribe connect to the user/client sensors?"   "TODO: THIS NEEDS DEEPER/MORE DETAILED THOUGHT."
   self assert: ( aConnectionOfSomeKind isKindOf: ZnUrl ).   clientConnection := aConnectionOfSomeKind </pre><h3>Hum-RunTime -- HumScribe &gt;&gt; clientSays:</h3><pre>clientSays: aString    "After a client sensor input is interpreted,    this method is called with the equivalent speech act input.   The Scribe (me) then passes this to the dialog agent to stimulate a system response.   "   | vignette  |   (self stepLog) add: ('U: ', aString).   "*** Following is here for DEBUG? -- Scribe need not be coupled to ontology."   vignette := self sendToDialogAgent: aString.   self assert: (vignette isKindOf: HumFrame4Vignette ).   (vignette responseLines)      do: [:line |         (self stepLog) add: 'S: ', line source.         ].   ^vignette.   </pre><h3>Hum-RunTime -- HumScribe &gt;&gt; dialogAgent</h3><pre>dialogAgent   "Returns the Dialog Agent that was attached to this Scribe when the Scribe was instantiated."   ^dialogAgent ifNil: [ Error signal: 'Scribe {',myID asString,'} has no dialog agent.']   </pre><h3>Hum-RunTime -- HumScribe &gt;&gt; dialogAgent:</h3><pre>dialogAgent: aHumDialogAgent   self assert: (aHumDialogAgent isKindOf: HumDialogAgent).   dialogAgent := aHumDialogAgent. </pre><h3>Hum-RunTime -- HumScribe &gt;&gt; dialogAgentURI</h3><pre>dialogAgentURI   "Returns an instance of HumDialogAgent."   ^dialogAgentURI</pre><h3>Hum-RunTime -- HumScribe &gt;&gt; dialogAgentURI:</h3><pre>dialogAgentURI: aHumDialogAgentURI    self assert: (aHumDialogAgentURI isKindOf: String).   dialogAgentURI := aHumDialogAgentURI.</pre><h3>Hum-RunTime -- HumScribe &gt;&gt; handleHttpPostRequest:</h3><pre>handleHttpPostRequest: aHumHttpRequest    "The scribe handles the post request by    . placing data on a HumDataFrame   . and returning the data frame as a completion of the 'Ask viewName' task.   TODO: Eventually, this should be in a subtype          because we will probably also have XMPP, and virtual world interfaces.   "   | calc |   calc := HumCalculator new.   self assert: (aHumHttpRequest isKindOf: HumHttpRequest).   "TODO: Should I clear the blackboard before placing these (new/replacement) values?    How do I know if they are new versus update?   "   aHumHttpRequest      fields          keysAndValuesDo: [:key :value |              | entityName attributeName |            entityName := calc given: key extractUpto: ':'.            attributeName := calc given: key extractAfter: ':'.            "Put the data on my blackboard.              It will be sent back to caller in job-completion message. "           (self blackboard) setEntityName: entityName attribute: attributeName toValue: value.           ].   "I am ready to send data back to the dialog agent     that delegated 'Ask viewName.' task to me."   self assert: (dialogAgent blackboard == self blackboard).   self askViewCompleted.     </pre><h3>Hum-RunTime -- HumScribe &gt;&gt; htmlStyle</h3><pre>htmlStyle   "Return CSS style element."   | styleElement calc cssString |   cssString := '      body {background: beige;}      '.   calc := HumCalculator new.   calc indentLevel: 1. "Zero is no indent."   styleElement := calc xml: 'style' with: [cssString].   ^styleElement.   </pre><h3>Hum-RunTime -- HumScribe &gt;&gt; initialize</h3><pre>initialize   "DEBUG Check: Scribe should be initialized with a dialogAgent at creation."   self dialogAgent ifNil: [Error signal: 'Scribe initiated without a Dialog Agent'].   self assert: ((self worldbase) = 'none').</pre><h3>Hum-RunTime -- HumScribe &gt;&gt; mockDataEntry:</h3><pre>mockDataEntry: userData    "Mock the user entering given data into view.   Use this for regression testing.   "   | httpRequest |   self assert: (userData isKindOf: Dictionary).   "HTML/HTTP magic places data into HTTP Request."   httpRequest := HumHttpRequest new.   userData      keysAndValuesDo: [:key :value |          httpRequest atField: key put: value.         ].   self handleHttpPostRequest: httpRequest. </pre><h3>Hum-RunTime -- HumScribe &gt;&gt; runAction:inRole:onJob:</h3><pre>runAction: anAction inRole: aRole onJob: aHumJobTicket   "Over-ride HumActor to handle Scribe actions."   self assert: ( aRole sameAs: 'scribe' ).   self runInstruction: anAction inRole: aRole onJob: aHumJobTicket.</pre><h3>Hum-RunTime -- HumScribe &gt;&gt; runInstruction:inRole:onJob:</h3><pre>runInstruction: anInstruction inRole: aRole onJob: aJobID   "Override the HumActor -- (Why?)"   | source debug |   "We cannot accept statement strings here because we need noun values."   self assert: ( anInstruction isKindOf: HumInstructionLine ).   debug := false.   debug      ifTrue: [ Transcript cr; show: 'Scribe {',myID,'} called with instruction: {',anInstruction source,'}'.].      instructionInProgress := anInstruction "statement".   jobID := aJobID.   "We are expecting 'Ask viewName.' or 'Show viewName.'"   source := instructionInProgress statement source.   ( source beginsWith: 'Ask ')       ifTrue: [ "Send an active form for the given view to the attached client interface."         |  viewFrame   |         viewFrame := self ontology getViewFrame: (HumCalculator given: source extractBetween: 'Ask ' and: '.' ).         self askView: viewFrame withBlackBoard: (self dialogAgent blackboard).         self askViewCompleted.         ].   ( source beginsWith: 'Ask: ')       ifTrue: [ "Send an active form for the given view to the attached client interface."         |  viewFrame   |         viewFrame := self ontology getViewFrame: (HumCalculator given: source extractBetween: 'Ask: ' and: '.' ).         self askView: viewFrame withBlackBoard: (self dialogAgent blackboard).         self askViewCompleted.         ].   ( source beginsWith: 'Show ') ifTrue: [ self shouldBeImplemented ].   ^self.               </pre><h3>Hum-RunTime -- HumScribe &gt;&gt; sendToDialogAgent:</h3><pre>sendToDialogAgent: aClientSpeechString    "Send the string to my Dialog Agent."   | myAgent vignette |   myAgent := self dialogAgent.   vignette := myAgent clientSays: aClientSpeechString.   ^vignette.            </pre><h3>Hum-RunTime -- HumScribe &gt;&gt; sendView:</h3><pre>sendView: htmlView   "Wrap the view element with HTML header, navigation, epilog, etc."    | head  body foot menu htmlResult calc |   "TODO: When we more than one kind of scribe, this method will be abstract."   self log add: 'sendView: {',htmlView,'}'.   calc := HumCalculator new.   head := calc xml: 'head' with: [ (calc xml: 'title' with: ['Hum Dialog']), (self htmlStyle)].   foot := calc xml: 'foot' with: [ 'Generated by Hum' ].   menu := calc xml: 'menu' with: [ calc xml: 'menuItem' list: {''.}].   body := calc xml: 'body' with: [ menu, htmlView, foot ].   htmlResult := calc xml: 'html' with: [ head, body ].   self htmlAgent sendHTML: htmlResult to: (self clientConnection).   ^htmlResult.</pre><h3>Hum-RunTime -- HumScribe &gt;&gt; systemSays:</h3><pre>systemSays: aString    "The Dialog Agent has responded with this String.   Implementations will display the response via the client/user interface. (e.g. chat diary)   But this (supertype) only logs the response for test-ability.   "   "*** Subtype implementations will override this method. ***"   (self stepLog) add: 'System: ', aString.</pre><h3>Hum-RunTime -- HumScribe &gt;&gt; zdialogAgent:</h3><pre>zdialogAgent: aHumDialogAgent    self assert: (aHumDialogAgent isKindOf: HumDialogAgent).   dialogAgent := aHumDialogAgent. </pre><h3>Hum-RunTime -- HumSimulator &gt;&gt; after:sendSpeech:from:</h3><pre>after: aDuration sendSpeech: aString from: aClientID    "Put this event into my queue."   | |   (self queue) add: { aDuration. #speech. aClientID. aString. }.   "TODO: Generalize to send string to specific actor, not just user dialog."   </pre><h3>Hum-RunTime -- HumSimulator &gt;&gt; buildDialogAgentNamed:</h3><pre>buildDialogAgentNamed: clientID   "Build a dialog agent configured for our simulation."   | clientAgent myURI clientURI aHumConfiguration |   myURI := 'URI:DialogAgent.', clientID.   clientURI := 'URI:client.', clientID.   clientAgent := HumActor dialogID: clientID uri: myURI client: clientURI configuration: self.   (self dialogAgents) at: clientID put: clientAgent.   "Check-in with Messenger to enable communication with Dispatcher and WorldBase."   clientAgent checkIn.   ^clientAgent. </pre><h3>Hum-RunTime -- HumSimulator &gt;&gt; clientScribes</h3><pre>clientScribes   ^clientScribes ifNil: [ clientScribes := Dictionary new.]</pre><h3>Hum-RunTime -- HumSimulator &gt;&gt; dialogAgents</h3><pre>dialogAgents   ^ dialogAgents ifNil: [ dialogAgents := Dictionary new ].</pre><h3>Hum-RunTime -- HumSimulator &gt;&gt; dialogSequence:</h3><pre>dialogSequence: anArrayOfString    "Identify the sequence of dialog responses to be sent during this simulation."   self assert: (anArrayOfString isKindOf: SequenceableCollection ).   dialogSequence := anArrayOfString </pre><h3>Hum-RunTime -- HumSimulator &gt;&gt; getDialogAgentNamed:</h3><pre>getDialogAgentNamed: aClientID    | clientAgent |   self assert: ( aClientID isKindOf: String ).   clientAgent := (self dialogAgents) at: aClientID ifAbsent: [self buildDialogAgentNamed: aClientID ].   ^clientAgent.</pre><h3>Hum-RunTime -- HumSimulator &gt;&gt; getScribeForClient:</h3><pre>getScribeForClient: aClientID    "Get the Scribe instance corresponding to the client ID."   | scribe dialogAgent |   scribe :=   (self clientScribes) at: aClientID                               ifAbsent: [ dialogAgent := HumDialogAgent dialogID: aClientID uri: (aClientID,'URI') client: 'clientURI' configuration: self.                                           scribe := HumScribe dialogAgent: dialogAgent.                                           scribe id: aClientID.                                           (self clientScribes) at: aClientID put: scribe. ].   ^scribe</pre><h3>Hum-RunTime -- HumSimulator &gt;&gt; initialize</h3><pre>initialize   | messenger |   messenger := HumMessenger new.   messenger clock: self.   self messenger: messenger.   "Use factory methods to build singleton accomplices"   self messengerID: 'SimMessenger' dispatcherID: 'SimDispatcher' bookkeeperID: 'SimBookkeeper' worldbaseID: 'SimWorldBase'.   "self dispatcher: (HumActor dispatcherID: 'SimDispatcherID' uri: 'SimDispatcherURI' configuration: self)."  self dispatcherID: 'SimDispatcherID'.     "self bookkeeper: (HumActor bookkeeperID: 'SimBookkeeperID' uri: 'SimBookkeeperURI' configuration: self)."   self bookkeeperID: 'SimBookkeeperID'.   "self worldBase: (HumWorldBase openWorldBase: 'SimWorldBase')."   self worldbaseID: 'SimWorldBaseID'.</pre><h3>Hum-RunTime -- HumSimulator &gt;&gt; log4Dialog</h3><pre>log4Dialog   ^ log4Dialog ifNil: [ log4Dialog := OrderedCollection new. ].</pre><h3>Hum-RunTime -- HumSimulator &gt;&gt; logDialogWhen:who:why:what:</h3><pre>logDialogWhen: aDuration who: aClientID why: clientSaid what: systemSaid   (self log4Dialog) add: { aDuration. aClientID. clientSaid. systemSaid. }.</pre><h3>Hum-RunTime -- HumSimulator &gt;&gt; now</h3><pre>now   ^ self simulatedClockSecond.</pre><h3>Hum-RunTime -- HumSimulator &gt;&gt; now:</h3><pre>now: aDuration    simulatedClockSecond := aDuration</pre><h3>Hum-RunTime -- HumSimulator &gt;&gt; numberOfDialogs:</h3><pre>numberOfDialogs: aSmallInteger    "How many dialogs are to be run simulataneously?"   numberOfDialogs := aSmallInteger    </pre><h3>Hum-RunTime -- HumSimulator &gt;&gt; queue</h3><pre>queue   ^ queue          ifNil: [ queue := SortedCollection sortBlock: [:a :b | (a at: 1) &lt; (b at: 1)] ].</pre><h3>Hum-RunTime -- HumSimulator &gt;&gt; randomStartingIntervals:</h3><pre>randomStartingIntervals: aDistribution      "Express the distribution as an S-curve in seconds."      self assert: (aDistribution isKindOf: Dictionary).      startingIntervalDistribution := aDistribution.      </pre><h3>Hum-RunTime -- HumSimulator &gt;&gt; simulatedClockSecond</h3><pre>simulatedClockSecond   ^ simulatedClockSecond ifNil: [simulatedClockSecond := 0 seconds].</pre><h3>Hum-RunTime -- HumSimulator &gt;&gt; step</h3><pre>step   "Send all events with timing that matches the top event."   | readyEvents remainingEvents whenNow  |   "If the queue is empty, do nothing.    (Prevent problem when manually stepping. See: stepUntilDone)"   ( self queue size = 0 ) ifTrue: [ ^self ].   "Update my clock."   whenNow := (self queue at: 1) at: 1.   self now: whenNow.   "Pull the events for this clock-time from the queue."   readyEvents       := (self queue) select: [:event | (event at: 1) = whenNow ].   remainingEvents := (self queue) reject: [:event | (event at: 1) = whenNow ].   queue := remainingEvents.   "Send those events"   readyEvents do: [:event | "For each event scheduled at this time."    | eventType clientID speechString dialogAgent  |      eventType := event at: 2.  clientID := event at: 3.  speechString := event at: 4.      "Someday we might do more than one type of event. But, currently, we just do speech events."      "The *fundamental* idea is that user-gestures are translated to speech-acts       (represented as a String or HumStatement) before they arrive here."      "TODO: Generalize to send event to specific actor, not just the user dialog."      self assert: (eventType = #speech ).      dialogAgent := self getDialogAgentNamed: clientID.      dialogAgent clientSays: speechString.      "The dialog agent may, in turn, trigger self-actions, plans, and/or actions. "      ].   </pre><h3>Hum-RunTime -- HumSimulator &gt;&gt; stepUntilDone</h3><pre>stepUntilDone   [ self queue notEmpty ]      whileTrue: [ self step. ]</pre><h3>Hum-RunTime -- HumText &gt;&gt; =</h3><pre>= anotherHumText   "Does this text have same content as the other"   | isSame |   isSame := (self name) = (anotherHumText name).   ^isSame.</pre><h3>Hum-RunTime -- HumTextLine &gt;&gt; copy</h3><pre>copy   | newInstance |   newInstance := self class new.   newInstance      indentLevel: (self indentLevel copy);      string: (self string copy).   ^newInstance.</pre><h3>Hum-RunTime -- HumTextLine &gt;&gt; indentLevel</h3><pre>indentLevel   "The indent level indicates the level of indentation,     but not the rendering of the indentation."   ^ indentLevel ifNil: [ indentLevel := 0 ].</pre><h3>Hum-RunTime -- HumTextLine &gt;&gt; indentLevel:</h3><pre>indentLevel: aSmallInteger   indentLevel := aSmallInteger.</pre><h3>Hum-RunTime -- HumTextLine &gt;&gt; size</h3><pre>size   ^ self string size</pre><h3>Hum-RunTime -- HumTextLine &gt;&gt; string</h3><pre>string   string ifNil: [ string := String new. ].   ^string.</pre><h3>Hum-RunTime -- HumTextLine &gt;&gt; string:</h3><pre>string: aByteString    string := aByteString</pre><h3>Hum-RunTime -- HumText &gt;&gt; addLine:</h3><pre>addLine: aString    "Append given line at bottom of text."   | newLine  tempLines |   self assert: ( aString isKindOf: String ).   newLine := HumTextLine new.   newLine string: aString.      tempLines := self lines.   ((tempLines size = 1) and: [( tempLines at: 1) string isEmpty])      ifTrue: [tempLines := OrderedCollection new. ].   tempLines add: newLine.   self lines: tempLines.      self changed.</pre><h3>Hum-RunTime -- HumText &gt;&gt; copy</h3><pre>copy   | newInstance newLines|   newInstance := self class new.   newLines := self lines class new.   self lines do: [:line | newLines add: (line copy) ].   newInstance lines: newLines.   ^newInstance.</pre><h3>Hum-RunTime -- HumText &gt;&gt; insertEmptyLineAfter:</h3><pre>insertEmptyLineAfter: lineIndex    | currentLines tempLines |   currentLines := self lines.   tempLines := currentLines copyFrom: 1 to: lineIndex.   tempLines add: ( HumTextLine new).   (lineIndex &lt; currentLines size )      ifTrue: [ tempLines addAll: ( currentLines copyFrom: ( lineIndex + 1 ) to:  currentLines size ). ].   "Note: Following will call self changed."      self lines: tempLines.</pre><h3>Hum-RunTime -- HumText &gt;&gt; lines</h3><pre>lines   "Return the HumText list of HumTextLine instances"   lines       ifNil: [ "initialize the list"         lines := OrderedCollection new.          lines add: ( HumTextLine new ). "NOTE: never empty"         ].   ^lines. </pre><h3>Hum-RunTime -- HumText &gt;&gt; lines:</h3><pre>lines: anOrderedCollection    ( anOrderedCollection isKindOf:  OrderedCollection )      ifFalse: [ Error signal: 'Bad value sent to HumText&gt;&gt;lines: _']      ifTrue: [ |firstElement| firstElement := anOrderedCollection at: 1.         (firstElement isKindOf: HumTextLine)          ifFalse: [ Error signal: 'First line should be a HumTextLine']          ].   lines := anOrderedCollection.   self changed.</pre><h3>Hum-RunTime -- HumText &gt;&gt; printOn:</h3><pre>printOn: aStream   "Append to the argument, aStream, a sequence of characters that     identifies the receiver."   | title s |   title := self class name.   s := title, ':'.   lines do: [ :line | s := s, line string, '/'.].   aStream      nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);      nextPutAll: s</pre><h3>Hum-RunTime -- HumText &gt;&gt; string</h3><pre>string   "Return self as a string. (Lines with CR inserted as needed.)"   | result |   result := String new.   ( self lines )      do: [ :line |         result := result, line string, String cr.         ].   ^result.</pre><h3>Hum-RunTime -- HumVMInstruction &gt;&gt; opCodeName</h3><pre>opCodeName   | name |   name := ( HumVMInstruction codeNames ) at: (self operation) ifAbsent: ['Unknown'].   ^name.</pre><h3>Hum-RunTime -- HumVMInstruction &gt;&gt; operand</h3><pre>operand   ^ operand ifNil: [ Error signal: 'operand not set in HumInstruction'.  operand := 000].</pre><h3>Hum-RunTime -- HumVMInstruction &gt;&gt; operand:</h3><pre>operand: objectIndex    operand := objectIndex</pre><h3>Hum-RunTime -- HumVMInstruction &gt;&gt; operation</h3><pre>operation   ^ operation ifNil: [ Error signal: 'op code not set in HumInstruction'.  operation := 000].</pre><h3>Hum-RunTime -- HumVMInstruction &gt;&gt; operation:</h3><pre>operation: opCode    self assert: ( opCode &lt; 256 ).   self assert: ( opCode &gt;= 0 ).   operation := opCode.</pre><h3>Hum-RunTime -- HumVMInstruction &gt;&gt; slotName</h3><pre>slotName   ( (self operand) = 000 ) ifTrue: [^ 'None' ].   Error signal: 'Instruction slot name is not defined.'.   ^'Undefined.'</pre><h3>Hum-RunTime -- HumVM &gt;&gt; measureRegister</h3><pre>measureRegister   ^ measure ifNil: [ measure := HumMeasure new. ].</pre><h3>Hum-RunTime -- HumVM &gt;&gt; runInstruction:</h3><pre>runInstruction: aHumInstruction    | microCode |   "Get the microCode. (a block)"   microCode := ( self transferVector ) at: (aHumInstruction operation)                                  ifAbsent: [ Error signal: 'No such opCode: ', (aHumInstruction operation)].   "Run the microCode. (a block)"   microCode value: ( self slots at: (aHumInstruction operand)).   "Assure cascade."   ^self. </pre><h3>Hum-RunTime -- HumVM &gt;&gt; setSlot:to:</h3><pre>setSlot: slotIndex to: aHumObject    "The slots allow objects to be referenced by byte-code indices."      (self slots) at: slotIndex put: aHumObject.   "Slots are used like registers in this VM thought-experiment. "</pre><h3>Hum-RunTime -- HumVM &gt;&gt; slots</h3><pre>slots   "slots allow objects to be referenced by byte-code indices."   ^ slots ifNil: [slots := Dictionary new. ].</pre><h3>Hum-RunTime -- HumVM &gt;&gt; transferVector</h3><pre>transferVector   transferVector ifNil: [ transferVector := Dictionary new.      transferVector          at: 001 put: [ :x | measure := x  ];         at: 002 put: [ :x | measure := measure + x ];         at: 003 put: [ :x | measure := measure - x ];         at: 000 put: [ :x | self halt ].      ].   ^transferVector.</pre><h3>Hum-RunTime -- HumVector &gt;&gt; asString</h3><pre>asString   "render my value as a string"   | result |   self assert: (quantity isKindOf: Array).   result := self quantityAsString.   result := result, ' ', self units.   ^result.</pre><h3>Hum-RunTime -- HumVector &gt;&gt; at:</h3><pre>at: index   | v |   self assert: (self quantity isKindOf: Array).   v := HumMeasure new.    v quantity: (quantity at: index); dimensions: (self dimensions).   ^v.</pre><h3>Hum-RunTime -- HumVector &gt;&gt; at:put:</h3><pre>at: k put:  aValue   quantity ifNil: [ quantity := Array new: 3. ].   self assert: (quantity isKindOf: Array).   (aValue isKindOf: HumMeasure)       ifTrue: [quantity at: k put: aValue. self dimensions: aValue]      ifFalse: [ Error signal: 'What?' ].</pre><h3>Hum-RunTime -- HumVector &gt;&gt; cross:</h3><pre>cross: anotherHumVector   "Return the 3-dimensional vector cross product U x V   where U is self and V is the argument.   The three scalar components       of the vector s=s1i+s2j+s3k = uv       are:         s1 = u2*v3 - u3*v2         s2 = u3*v1 - u1*v3         s3 = u1*v2 - u2*v1   "   | u   ux uy uz     v  vx vy vz   s sx sy sz   |   u := self.   v := anotherHumVector.   self assert: ( v isKindOf: HumVector ).   self assert: ( self quantity size = 3 ).   self assert: (     v quantity size = 3 ).   ux := u x.  uy := u y.  uz := u z.   vx := v x.  vy := v y.  vz := v z.   sx := (uy * vz) - (uz * vy).   sy := (uz * vx) - (ux * vz).   sz := (ux * vy) - (uy * vx).   s := HumVector newFrom: { sx. sy. sz. }.   ^s.      </pre><h3>Hum-RunTime -- HumVector &gt;&gt; dot:</h3><pre>dot: aHumVector   |  sum  |   sum :=       ( self x * aHumVector x )             + ( self y * aHumVector y )            + ( self z * aHumVector z ).   ^sum.</pre><h3>Hum-RunTime -- HumVector &gt;&gt; length</h3><pre>length   | s length vx vy vz |   vx := self x.   vy := self y.   vz := self z.   s := (vx*vx) + (vy*vy) + (vz*vz).   length := s sqrt.   ^length.</pre><h3>Hum-RunTime -- HumVector &gt;&gt; lengthSquared</h3><pre>lengthSquared   | s vx vy vz |   vx := self x.   vy := self y.   vz := self z.   s := (vx*vx) + (vy*vy) + (vz*vz).   "length := s sqrt."   ^s.</pre><h3>Hum-RunTime -- HumVector &gt;&gt; pitch:</h3><pre>pitch: anAngleInRadians   "Transform receiver by a rotation about x (East pointing) axis."   | vector |   vector := self pitch: anAngleInRadians aboutPivot: ( HumVector zeroVector: #meter ).   ^vector.</pre><h3>Hum-RunTime -- HumVector &gt;&gt; pitch:aboutPivot:</h3><pre>pitch: anAngleInRadians aboutPivot: pivot   "Transform receiver by a rotation about X (side pointing) axis."   | xx yy zz r alpha vector cx cy cz dx dy dz |   "The effect is to move the effective origin."   ( anAngleInRadians quantity closeTo: 0.0 ) ifTrue: [ ^self ].   cx := pivot x.   cy := pivot y.   cz := pivot z.   dx := (self x) - cx.   dy := (self y) - cy.   dz := (self z) - cz.   r := ((dy * dy) + (dz * dz)) sqrt. "Note: x and y are measures"   alpha := (dz arcTan: dy) radian.   "co-tangent Float"   xx := cx + dx.   yy := cy + ( r * ( ( alpha + anAngleInRadians ) cos ) ).   zz := cz + ( r * ( ( alpha + anAngleInRadians ) sin ) ).   "Restore the coordinate origin."   vector := HumVector newFrom: { xx. yy. zz. }.   "Post condition: The length of the vector should not change"   self assert: ((self lengthSquared) = (vector lengthSquared)).   "TODO: Write a test-suite for yaw, pitch, roll."   ^vector.</pre><h3>Hum-RunTime -- HumVector &gt;&gt; quantityAsString</h3><pre>quantityAsString   | s |   self assert: (quantity isKindOf: Array).   s := '( '.   quantity do: [ :each |  s := s, (self quantityAsString: each), ' '. ].   s := s, ')'.   ^s.</pre><h3>Hum-RunTime -- HumVector &gt;&gt; roll:</h3><pre>roll: anAngleInRadians   "Transform receiver by a rotation about y (North pointing) axis."   | vector |   vector := self roll: anAngleInRadians aboutPivot: ( HumVector zeroVector: #meter ).   ^vector.</pre><h3>Hum-RunTime -- HumVector &gt;&gt; roll:aboutPivot:</h3><pre>roll: anAngleInRadians aboutPivot: pivot   "Transform receiver by a rotation about Y (forward pointing) axis."   | xx yy zz r alpha vector cx cy cz dx dy dz |   "Arithmetic is all via HumMeasure"   "The effect is to move the effective origin."   ( anAngleInRadians quantity = 0.0 ) ifTrue: [ ^self ].   cx := pivot x.   cy := pivot y.   cz := pivot z.   dx := (self x) - cx.   dy := (self y) - cy.   dz := (self z) - cz.   r := ((dx * dx) + (dz * dz)) sqrt.    alpha := (dz arcTan: dx) radian.   "co-tangent Float"   xx := cx + ( r * ( ( alpha + anAngleInRadians ) cos ) ).   yy := cy + dy.   zz := cz + ( r * ( ( alpha + anAngleInRadians ) sin ) ).   "Restore the coordinate origin."   vector := HumVector newFrom: { xx. yy. zz. }.      "Post condition: The length of the vector should not change"   self assert: ((self lengthSquared) = (vector lengthSquared)).   ^vector.</pre><h3>Hum-RunTime -- HumVector &gt;&gt; size</h3><pre>size   "compatibility"   ( quantity isKindOf: Array ) ifTrue: [ ^quantity size ].   Error signal: 'Why are we here?'.</pre><h3>Hum-RunTime -- HumVector &gt;&gt; x</h3><pre>x   ^(self at: 1).</pre><h3>Hum-RunTime -- HumVector &gt;&gt; x:y:z:</h3><pre>x: xValue y: yValue z: zValue   "Hum coordinates are plan-view. x points East. y North. z Up."   (xValue isKindOf: HumMeasure)      ifTrue: [          x := xValue.          y := yValue.          z := zValue.          ]      ifFalse: [ self assert: (xValue isKindOf: Number).          x := HumMeasure quantity: xValue units: #meter.         y := HumMeasure quantity: yValue units: #meter.         z := HumMeasure quantity: zValue units: #meter.         ].   "Create array and store as quantity."   self quantity:( { x. y. z. } collect: [:each | each quantity] ).   "Assume all elements have same unit of measure (by definition)."   self dimensions: (x dimensions).</pre><h3>Hum-RunTime -- HumVector &gt;&gt; y</h3><pre>y   ^self at: 2.</pre><h3>Hum-RunTime -- HumVector &gt;&gt; yaw:</h3><pre>yaw: anAngleInRadians   "Transform receiver by a rotation about z (Up pointing) axis."   | vector |   vector := self yaw: anAngleInRadians aboutPivot: ( HumVector zeroVector: #meter ).   ^vector.</pre><h3>Hum-RunTime -- HumVector &gt;&gt; yaw:aboutPivot:</h3><pre>yaw: anAngleInRadians aboutPivot: pivot   "Transform receiver by a rotation about Z (Up pointing) axis."   | xx yy zz r alpha vector cx cy cz dx dy dz |   "The effect is to move the effective origin."   ( anAngleInRadians quantity = 0.0 ) ifTrue: [ ^self ].   cx := pivot x.   cy := pivot y.   cz := pivot z.   dx := (self x) - cx.   dy := (self y) - cy.   dz := (self z) - cz.   r := ((dx * dx) + (dy * dy)) sqrt. "Note: x and y are measures"   alpha := (dy arcTan: dx) radian.   "co-tangent Float"   xx := cx + ( r * ( ( alpha + anAngleInRadians ) cos ) ).   yy := cy + ( r * ( ( alpha + anAngleInRadians ) sin ) ).   zz := cz + dz.   "Restore the coordinate origin."   vector := HumVector newFrom: { xx. yy. zz. }.   "Post condition: The length of the vector should not change"   self assert: ((self lengthSquared) = (vector lengthSquared)).   ^vector.</pre><h3>Hum-RunTime -- HumVector &gt;&gt; z</h3><pre>z   ^z := self at: 3.</pre><h3>Hum-RunTime -- HumWorldBase &gt;&gt; checkTau:</h3><pre>checkTau: aTau    self assert: (aTau isKindOf: DateAndTime ).</pre><h3>Hum-RunTime -- HumWorldBase &gt;&gt; getEntityID:attribute:</h3><pre>getEntityID: entityID attribute: attributeType    " Get requested value (if any) from the world base instance "   | valueAndTau value tau |   self assert: (entityID isKindOf: HumIdentifier ).   self assert: (attributeType asSymbol isKindOf: Symbol ).      valueAndTau := (self quads ) at: ( entityID -&gt; attributeType ) ifAbsent: [ ^nil ].   value := valueAndTau at: 1.   tau := valueAndTau at: 2.   ^ value.</pre><h3>Hum-RunTime -- HumWorldBase &gt;&gt; history</h3><pre>history   ^ history ifNil: [ history := Dictionary new. ].</pre><h3>Hum-RunTime -- HumWorldBase &gt;&gt; initialize</h3><pre>initialize   priorID := #( 0 0 0 ).</pre><h3>Hum-RunTime -- HumWorldBase &gt;&gt; quads</h3><pre>quads   "For quad internal structure see    self setEntityID: entityID attribute: attributeType toValue: aValue"   ^ quads ifNil: [ quads := Dictionary new. ].</pre><h3>Hum-RunTime -- HumWorldBase &gt;&gt; setEntityID:attribute:toValue:</h3><pre>setEntityID: entityID attribute: attributeType toValue: aValue   "Put attribute-value (if any) into the world base instance. "   | tau priorValueTau |   self assert: (entityID isKindOf: HumIdentifier ).   self assert: (attributeType asSymbol isKindOf: String ).   self assert: ( aValue notNil ).   tau := (self clock) now. "seconds since 00:00 on 1 Jan 1901"   "TODO: Tau should refer to a business event."   "If there is a different prior value, archive in history."   priorValueTau := ( self quads ) at: ( entityID -&gt; attributeType ) ifAbsent: [].   (( priorValueTau notNil ) and: [ ((priorValueTau at: 1) = aValue) not ] )      ifTrue: [ | historyKey |         historyKey :=   { entityID. attributeType. (priorValueTau at: 2). tau }.         (self history) at: historyKey put: (priorValueTau at: 1).         ].   "Put value of entity attribute and the timestamp."   ( self quads ) at: ( entityID -&gt; attributeType ) put: { aValue. tau. }.   "TODO: For large scale applications,    . persist the entity-attribute-value on an external store.   SUGGEST: An Erlang-compatible non-SQL database. See: RIAK.   "   "TODO: Should (other) blackboards holding the same entityID be notified of the change? If so, how?"</pre><h3>Hum-RunTime -- HumWorldBase &gt;&gt; title</h3><pre>title   ^ title ifNil: [ Error signal: 'A world base instance must have a title.'].</pre><h3>Hum-RunTime -- HumWorldBase &gt;&gt; title:</h3><pre>title: aWorldBaseName    self assert: ( aWorldBaseName isKindOf: String ).   title := aWorldBaseName.</pre><h3>Hum-RunTime -- HumWorldBase &gt;&gt; whereAttribute:satisfies:</h3><pre>whereAttribute: attributeType satisfies: aBlockClosure   "Return a set of entity identifiers where the attribute value satisfies the block"   | identifierSet  |   identifierSet := Set new.   (self quads)      keysAndValuesDo: [ :quadKey :quadValue |             | entityID attrType attrValue tau |            entityID := quadKey key.             attrType := quadKey value.             attrValue := quadValue at: 1.             tau       := quadValue at: 2.            ( ( attrType sameAs: attributeType ) and: [ aBlockClosure value: attrValue ] )               ifTrue: [ identifierSet add: entityID.                  self checkTau: tau.                   "Tau (timestamp) is not really used. I've included it for clarity and debug."                  ].         ].   ^identifierSet.</pre><h3>Hum-Seaside -- HumApplication &gt;&gt; bookkeeper:</h3><pre>bookkeeper: aHumBookkeeper   "This application instance will be served by this bookkeeper instance."   bookkeeper := aHumBookkeeper</pre><h3>Hum-Seaside -- HumApplication &gt;&gt; dispatcher:</h3><pre>dispatcher: aHumResourceManager   "This application instance will be served by this Dispatcher instance."   resourceManager := aHumResourceManager</pre><h3>Hum-Seaside -- HumApplication &gt;&gt; messenger:</h3><pre>messenger: aHumMessenger   "This application instance will be served by this messenger instance."   messenger := aHumMessenger.</pre><h3>Hum-Seaside -- HumApplication &gt;&gt; ontology:</h3><pre>ontology: aHumOntology   "This application a run-time manifestation of that ontology."   ontology := aHumOntology</pre><h3>Hum-Seaside -- HumApplication &gt;&gt; worldBase:</h3><pre>worldBase: aHumWorldBase   "This application instance will be served by this world-base instance."   worldBase := aHumWorldBase.</pre><h3>Hum-Seaside -- HumBrowserEditFrame &gt;&gt; critic</h3><pre>critic   ^ critic ifNil: [ critic := '*** No frame critique yet ***' ].</pre><h3>Hum-Seaside -- HumBrowserEditFrame &gt;&gt; critic:</h3><pre>critic: aTextString   "This is a dummy to accomodate a side-effect of using a TextArea to display the critique.   A client or internal that wants to reset the critic should call #setCritique: instead.   "   |  |      "self trace: 'critc called with: ', aTextString. "   self setCritique: aTextString.</pre><h3>Hum-Seaside -- HumBrowserEditFrame &gt;&gt; fetchCodeForTitle:</h3><pre>fetchCodeForTitle: aString   | cr indent |   cr := String cr.   indent := '. ', cr.   self frameCode: 'Goal: ', aString, cr, 'Preconditions: ', cr, indent, indent, indent, 'Action: ', cr, indent.   self shouldBeImplemented.</pre><h3>Hum-Seaside -- HumBrowserEditFrame &gt;&gt; firstLine</h3><pre>firstLine   | result |   result := (self frameCode) copyUpTo: (Character cr).   ^ result.   </pre><h3>Hum-Seaside -- HumBrowserEditFrame &gt;&gt; frameCode</h3><pre>frameCode   ^ frameCode ifNil: [ frameCode := '*** No frame code yet. ***']</pre><h3>Hum-Seaside -- HumBrowserEditFrame &gt;&gt; frameCode:</h3><pre>frameCode: aTextString   | border |   border := String cr, '---', String cr.   self assert: (aTextString isKindOf: String).   frameCode := aTextString.   self trace: 'frameCode reset to: ', border, frameCode, border.   self runCritic.</pre><h3>Hum-Seaside -- HumBrowserEditFrame &gt;&gt; initialize</h3><pre>initialize   | |   super initialize.   self trace: 'edit frame initialized.'</pre><h3>Hum-Seaside -- HumBrowserEditFrame &gt;&gt; lastSaved</h3><pre>lastSaved   ^ lastSaved ifNil: [ lastSaved := '*** NOT SAVED YET ***' ].</pre><h3>Hum-Seaside -- HumBrowserEditFrame &gt;&gt; lastSaved:</h3><pre>lastSaved:  anObject   (anObject isKindOf: String )       ifTrue: [ lastSaved := anObject ]      ifFalse: [ lastSaved := anObject asString ].   </pre><h3>Hum-Seaside -- HumBrowserEditFrame &gt;&gt; layoutFrameAsColumnsOnCanvas:</h3><pre>layoutFrameAsColumnsOnCanvas: aWAHtmlCanvas   "Generate the column style layout"   | canvas |   canvas := aWAHtmlCanvas.   canvas div          class: 'EditorPane';          with: [            canvas form with: [               canvas label: ' Frame: '.               canvas textInput "readonly: False;" size: ( 5+ (self  title size ) ); on: #title of: (self ).               canvas label: ' Last Saved: '.               canvas textInput  readonly: True; size: 35; on: #lastSaved of: (self ).               canvas submitButton callback: [ self  lastSaved: (TimeStamp now asString). ]; value: ' Save '.               canvas table with: [ "Rows for editor and critc."                  canvas tableRow                  with: [ canvas tableData                         attributeAt: 'valign' put: 'TOP';                        with: [ canvas textArea rows: 40; columns: 80;                                            on: #frameCode of: (self ).                              ] . "tableData"                  ]. "tableRow"               canvas tableRow                  with: [ canvas tableData                         attributeAt: 'valign' put: 'TOP';                        with: [ canvas textArea rows: 10; columns: 80; readonly: True;                                             on: #critic of: (self)  .                            ]. "tableData"                      ].   "tableRow"                  ]. "table"            ]. "form"         ]. "div"   </pre><h3>Hum-Seaside -- HumBrowserEditFrame &gt;&gt; layoutFrameAsRowsOnCanvas:</h3><pre>layoutFrameAsRowsOnCanvas: aWAHtmlCanvas   "Generate the row style layout."   | canvas |   canvas := aWAHtmlCanvas.   canvas div       class: 'EditorPane';       with: [         canvas form with:             [            canvas label: ' Frame: '.            canvas textInput                "readonly: False; "                size: ( 5+ (self title size ) );                on: #title of: (self).            canvas label: ' Last Saved: '.            canvas textInput                 readonly: True; size: 35;                on: #lastSaved of: (self).            canvas submitButton                callback: [ self lastSaved: (TimeStamp now asString). ];                value: ' Save '.            canvas table with: [ "Rows for editor and critic."               canvas tableRow               with: [ "Editor pane contains two columns with editor on left and critic on right."                     canvas tableData                         attributeAt: 'valign' put: 'TOP';                        with: [ canvas textArea rows: 25; columns: 80;                                         on: #frameCode of: (self).                                        ] . "tableData"                     canvas tableData                         attributeAt: 'valign' put: 'TOP';                        with: [ canvas textArea rows: 25; columns: 40; readonly: True;                                        on: #critic of: (self)  .                                        ]. "tableData"                      ].   "end row"                        ]. "end table"             ] .  "end form"         ] "end div"</pre><h3>Hum-Seaside -- HumBrowserEditFrame &gt;&gt; renderContentOn:</h3><pre>renderContentOn: html   ( self parent layout = #columns )       ifTrue:  [ self layoutFrameAsColumnsOnCanvas: html.]      ifFalse: [ self layoutFrameAsRowsOnCanvas: html].   </pre><h3>Hum-Seaside -- HumBrowserEditFrame &gt;&gt; runCritic</h3><pre>runCritic   "Run the ontology critic that is appropriate to this type of frame."   self critic: ('Critic does not know how to critique: ', (self firstLine) ).</pre><h3>Hum-Seaside -- HumBrowserEditFrame &gt;&gt; setCritique:</h3><pre>setCritique: aTextString   "Set the critique value.   "   critic := aTextString.   self trace: 'critique reset to: ', critic .</pre><h3>Hum-Seaside -- HumBrowserEditFrame &gt;&gt; title</h3><pre>title   ^ title ifNil: [ title := 'TBD']</pre><h3>Hum-Seaside -- HumBrowserEditFrame &gt;&gt; title:</h3><pre>title: aString   | oldTitle cr indent |   oldTitle := (self title).   ( aString = oldTitle ) ifTrue: [^self].   self halt.   self trace: 'title reset to: ', aString.   "Otherwise -- fetch the code for the new title."   self fetchCodeForTitle: aString.</pre><h3>Hum-Seaside -- HumBrowserEditFrame &gt;&gt; trace:</h3><pre>trace: aString   Transcript show: 'HumBrowereEditFrame - trace: ', aString; cr.</pre><h3>Hum-Seaside -- HumBrowserSession &gt;&gt; currentFrame</h3><pre>currentFrame   "What frame is currently being editted?"   ^ currentFrame ifNil: [ currentFrame :=  HumBrowserEditFrame new. ].</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; blackboard</h3><pre>blackboard   ^ blackboard ifNil: [blackboard := HumBlackBoard worldbase: 'none'.]</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; clearOntology</h3><pre>clearOntology   self logUserAction: 'Clear ontology: ', (self ontology title).</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; contextDiagram</h3><pre>contextDiagram   ^ contextDiagram ifNil: [ contextDiagram := HumDiagram new title: 'Context Diagram '].</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; currentFrame</h3><pre>currentFrame   "What frame is currently being editted?"   ^ self session currentFrame.</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; dialog</h3><pre>dialog   ^ dialog ifNil: [ dialog := HumSeasideComponentThingy new. ].</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; editActionFrame:forRole:</h3><pre>editActionFrame: aTitleString forRole: aRoleString   "Create / View / Edit the frame with the given title."   self logUserAction: 'Edit action frame: {', aRoleString, ':', aTitleString,'}'.</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; editDialogFrame:</h3><pre>editDialogFrame: aString    "Create / View / Edit the frame with the given title."   |   |   self logUserAction: 'Edit dialog frame: ', aString.</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; editDictionaryFrame:</h3><pre>editDictionaryFrame: aString    "Create / View / Edit the frame with the given title."   |   |      self logUserAction: 'Edit dictionary frame: ', aString.</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; editPlanFrame:</h3><pre>editPlanFrame: aString    "Create / View / Edit the frame with the given title. (Use goal statement as title.)"   |  result |   self currentFrame title: 'Enter the goal statement for the frame.'</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; editViewFrame:</h3><pre>editViewFrame: aString    "Create / View / Edit the frame with the given title."   |   |      self logUserAction: 'Edit View Frame: ', aString.</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; hideDiagrams</h3><pre>hideDiagrams   ^ hideDiagrams ifNil: [ hideDiagrams = False ].</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; hideDiagrams:</h3><pre>hideDiagrams: aBoolean   ^ hideDiagrams := aBoolean.</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; initialize</h3><pre>initialize   super initialize.</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; layout</h3><pre>layout   "What style of browser layout (#rows or #columns)?   #rows ==&gt; Diagrams, if present, are in a row.              Editor panes are in a row.   #columns ==&gt; Diagrams, if present, are in a column.                 Editor panes are in a column.    "   ^ layout ifNil: [ layout = #rows ].</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; layout:</h3><pre>layout: aSymbol   "What style of browser layout (#rows or #columns)?   #rows ==&gt; Diagrams, if present, are in a row.              Editor panes are in a row.   #columns ==&gt; Diagrams, if present, are in a column.                 Editor panes are in a column.    "   ^ layout := aSymbol.</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; layoutDiagramsAsColumnOnCanvas:</h3><pre>layoutDiagramsAsColumnOnCanvas: aWAHtmlhtml   | html |   html := aWAHtmlhtml.   ^ html div      class: 'DiagramColumn';      with: [                "html label: 'Diagram Column'.         html break."               html table                  with: [                      | diagramWidth "Table with one column and four rows. Each row has a diagram" diagramHeight |                     diagramWidth := 400.                     diagramHeight := 160.                        "Draw plan diagram on this html."                     { self planDiagram. self roleDiagram. self nounDiagram. self contextDiagram.}                        do: [ :diagram | "For each diagram:"                              html tableRow "&lt;tr&gt;"                                           with: [ html tableData "&lt;td&gt;"                                                               with: [ diagram asSVGonHtmlCanvas: html                                                                                                         width: diagramWidth                                                                                                       height: diagramHeight ]                                                             ]. "tableData"                                                   ]. "tableRow"                     ]. "table"                  ]. "div"</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; layoutDiagramsAsRowOnCanvas:</h3><pre>layoutDiagramsAsRowOnCanvas: aWAHtmlCanvas   | html |   html := aWAHtmlCanvas.   html div          class: 'DiagramRow';          with: [            "html label: 'Diagram Row'.            html break."            html table with: [ "Table with one Row and four rows. Each row has a diagram"               | diagramWidth diagramHeight |               diagramWidth := 320.               diagramHeight := 320.                              html tableRow with: [ "&lt;tr&gt;"                  { self planDiagram. self roleDiagram. self nounDiagram. self contextDiagram. }                     do: [ :diagram | "For each diagram:"                        html tableData "&lt;td&gt;"                                 with: [ self planDiagram asSVGonHtmlCanvas: html                                                                                            width: diagramWidth                                                                                           height: diagramHeight.                                              ]. "end tableData"                        ]. "end do"                  ].  "end table row"               ].  "end table"            ]. "end with"</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; layoutMenuActionsAsColumnOnCanvas:</h3><pre>layoutMenuActionsAsColumnOnCanvas: html   "Identify the actions that the user may invoke via menu navigation."   | mainMenu ontologyMenu editMenu layoutMenu force combinedMenu verb |   "A menu is a sequence of name -&gt; action pairs.   We will store each menu in a Smalltalk OrderedCollection"   mainMenu := OrderedCollection new.   ontologyMenu := OrderedCollection new.   editMenu  := OrderedCollection new.   layoutMenu := OrderedCollection new.   "   The main menu simply provides a way to navigate to each sub-menu.   In main menu might be displayed on a top-navigation menu bar or on a (left) side navigation stub.   "   mainMenu       add: 'Ontology' -&gt; [ self showSubMenu: ontologyMenu title: 'Ontology' onCanvas: html ];      add: 'Edit'     -&gt; [ self showSubMenu: editMenu     title: 'Edit'     onCanvas: html ];      add: 'Layout'   -&gt; [ self showSubMenu: layoutMenu   title: 'Layout'   onCanvas: html ].   "   The ontology menu provides actions affecting the ontology that is currently the subject/context of the Browser instance.   Content in parentheses below may be displayed or reserved as 'help hints'. (That could be a user preference option.)   Navigation via keyboard may follow the convention that the first letter of each menu entry is the key.   If the first letter of the first word is not unique, the first letter of the second word may be used.   Conventionally, the navigation letter may be indicated by underlining it in the menu list.   "   ontologyMenu      add: 'New Ontology (Start a new ontology.)'                -&gt; [ self clearOntology.  self ontology title: (self dialog ask: 'What is the new ontology`s name?' ) ];      add: 'Open Ontology (Open an existing ontology.)'                -&gt; [ self clearOntology.  self loadOntologyFile: (self dialog askFile: 'Where (what file/URI) is the ontology?')];      add: 'Save Ontology (Save the current state of this ontology.)'                -&gt; [ self saveOntology. ];       "* Save will overwrite an existing file without asking.          If file is not known, it will dialog for a file name.          (Relatively harmless if we have infinite undo.)"      add: 'Save As . . .  (Save this ontology in a specific file.)'                -&gt; [ self ontology file: ( self dialog askFile: 'What file?')];      "* I expect Save-As to be used like it is in Smalltalk             - as a kind of poor-man's source code label mechanism."      add: '---' -&gt; [];      add: 'Render as . . . (Document the ontology in PDF or HTML? )'                -&gt; [ self ontology renderAs: ( self dialog ask: 'Document the ontology in PDF or HTML format?'                                                                         choice: #( #PDF #HTML )  )  ].      "   The edit menu provides a way to open the editor on new frames.   The edit menu provides an additional way to navigate to existing frames.   The general idea is that the programmer identifies the type of frame   and then the resulting dialog identifies the particular frame.   "   editMenu      add: 'Plan (Edit a plan frame.)'                -&gt; [self editPlanFrame: ( self dialog ask: #Plan) ];      add: 'Action (Edit a role-action frame.)'                -&gt; [self editActionFrame: ( self dialog ask: #( #Role  #Action )  ) ];      add: 'Dictionary (Edit a dictionary frame.)'                -&gt; [ self editDictionaryFrame: ( self dialog ask: #Dictionary ).];      add: 'Dialog Context (Edit a dialog-context frame.)'                -&gt; [self editDialogFrame: ( self dialog ask: #( #Dialog #Context ) )];      add: 'View Pane (Edit a view-pane frame.)'                -&gt; [self editViewFrame: ( self dialog ask: #Pane )  ].   "   The layout menu provides the means for the user to change the layout of the browser window.   The user may switch between column and row layouts. (See: #layoutWindowAsColumns and #layoutWindowAsRows. )   The user may toggle to and from a full-screen for the browser window itself.   In some situations, the user may wish to hide/suppress the diagrams.   "   "Hide or UnHide"   ( self hideDiagrams )       ifTrue: [  verb := 'Show ' ]       ifFalse: [ verb := 'Hide '].   layoutMenu       add: 'Full Screen (Toggle this browser window to/from full-sceen.)'                -&gt; [ self toggleFullScreen ];      add: 'Transpose Layout (Tranpose the browser layout between row mode and column mode.)'                -&gt; [ self transposeLayout ];            add: (verb, ' Diagrams (Hide or Un-hide the diagram panes.)')                -&gt; [ self toggleDiagramView ].    "Render the main menu"      html div       class: 'MenuColumn';       style: 'background: LightYellow; padding: 1em;';      with: [      html strong: 'Menu'.      self showSubMenu: ontologyMenu    title: 'Ontology'    onCanvas: html.      self showSubMenu: editMenu          title: 'Edit'          onCanvas: html.      self showSubMenu: layoutMenu       title: 'Layout'       onCanvas: html.      ].</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; layoutWindowAsColumns</h3><pre>layoutWindowAsColumns   "*** This is a design document defining layout in Hum markup. ***   This layout is visually two columns with editor on left and diagrams on right."   | layoutWindow layoutEditorColumn layoutDiagramColumn layoutStatusBar layoutMenuBar |   "Hum view mark-up for the window layout.   This is like the traditional Smalltalk browser,    but with a navigation column on left instead of a navigation row on top.   Since Hum relationships are not necessarily hierarchies,    the navigation diagrams are not simple trees.   "   layoutWindow := '---View: Browser Window.. table|  [pane: Menu Bar]                                  |. table|  [pane: Editor Column]  |  [pane: Diagram Column]  |. table|  [pane: Status Bar]                                |'.   "The Source Frame Tabs are similar to Eclipse source code navigation.   The Frame Editor provides a syntax-aware and ontology-aware editor.   Syntax-aware means that it knows how to pretty-priint.   Ontology-aware means that it knows   - which words are nouns,   - which sentences have definitions (filled-in frames)    - which views (panes) have definitions.   The Source Frame Critic identifies syntax and semantic problems   that are related to the current frame.   "   layoutEditorColumn := '[pane: Source Frame Tabs][pane: Source Frame Editor][pane: Source Frame Critic]'.   "The Diagram Column shows a set of diagram viewers.   A diagram can be brought full-screen (How? TBD).   Clicking on a diagram node causes the corresponding definition frame to be brought into the editor.   The Plan Tree diagram is like a precedence diagram. (It is not, strictly speaking, a tree but tends to have a similar branching structure.)   The Role Dependencies diagram has arrows showing which roles delegate actions to other roles.   The Noun Releations diagram arrows showing supertype, synonym, and attribute relations between nouns.   The Dialog Relations diagram arrows indicate when one dialog context raises another context.   (Dialogs have a context 'stack' that prioritizes pattern matching.    A dialog may tell the dialog interpreter to raise another context to the top of the stack.)   "   layoutDiagramColumn := '[canvas: Plan Tree][canvas: Role Dependencies][canvas: Noun Relations][canvas: Dialog Relations]'.   "The menu bar is a row of tabs identical to common desktop window menus in operation.   See: #menuActions method for further definition and documentation."   layoutMenuBar := '[menu: Ontology]  [menu: edit]  [menu: view]  [menu: tools]  [menu: simulator]'.   "What does the user/programmer need in the status bar?   I am just guessing that we should answer:   - What ontology is being edited?  (name + file)   - What is the current status of the ontology?  (Is the ontology fully defined? )   - What hint/suggestion might we provide to the programmer? (But, what is the question?)   "   layoutStatusBar := 'Ontology: [ontology name] File: [ontology file] State: [ontology state] [IDE hint]'.</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; layoutWindowAsColumnsOnCanvas:</h3><pre>layoutWindowAsColumnsOnCanvas: aWAHtmlCanvas   "This layout is visually two columns with editor on left and diagrams on right."   | layoutWindow layoutEditorColumn layoutDiagramColumn layoutStatusBar layoutMenuBar html  htmlStatusBar |   "Layout the Window as a table with three rows."   html := aWAHtmlCanvas.   htmlStatusBar := [ :canvas |    canvas div      class: 'StatusBar';      with: 'Ontology title: " ' , self ontology title , ' " file: ' , self ontology file ].      "Finally we generate the window contents by calling the functions [blocks] that we defined above."      "html render: [ htmlMenuBar value: html ].   html break."   html table      with: [          html tableRow            with: [                "Editor Column and Diagram Column"               html tableData                  attributeAt: 'valign' put: 'TOP';                  with: [ self layoutMenuActionsAsColumnOnCanvas: html ].               html tableData                  attributeAt: 'valign' put: 'TOP';                  with: [                            htmlStatusBar value: html.                           html break.                           self currentFrame layoutFrameAsColumnsOnCanvas: html ].               self hideDiagrams                  ifFalse: [                      html tableData                        attributeAt: 'valign' put: 'TOP';                        with: [ self layoutDiagramsAsColumnOnCanvas: html ] ] ] ]</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; layoutWindowAsRows</h3><pre>layoutWindowAsRows   "This layout is visually two rows with editor on bottom row and diagrams on top row."   | layoutWindow layoutEditorRow layoutDiagramRow layoutStatusBar layoutMenuBar |   "Hum view mark-up for the window layout.   This is like the traditional Smalltalk browser,     with a navigation row on top and a editor row on bottom.   Since Hum relationships are not necessarily hierarchies,    the navigation diagrams are not simple trees.   "   layoutWindow := '[pane: Menu Bar][pane: Diagram Row][pane: Status Bar][pane: Editor Row]'.   "The Source Frame Tabs are similar to Eclipse source code navigation.   But in this case, the module names appear as a list on the left.   The Frame Editor provides a syntax-aware and ontology-aware editor.   Syntax-aware means that it knows how to pretty-priint.   Ontology-aware means that it knows   - which words are nouns,   - which sentences have definitions (filled-in frames)    - which views (panes) have definitions.   The Source Frame Critic identifies syntax and semantic problems   that are related to the current frame.   "   layoutEditorRow := '[pane: Source Frame Tabs]  [pane: Source Frame Editor]  [pane: Source Frame Critic]'.   "The Diagram Row shows a set of diagram viewers.   A diagram can be brought full-screen (How? TBD).   Clicking on a diagram node causes the corresponding definition frame to be brought into the editor.   The Plan Tree diagram is like a precedence diagram. (It is not, strictly speaking, a tree but tends to have a similar branching structure.)   The Role Dependencies diagram has arrows showing which roles delegate actions to other roles.   The Noun Releations diagram arrows showing supertype, synonym, and attribute relations between nouns.   The Dialog Relations diagram arrows indicate when one dialog context raises another context.   (Dialogs have a context 'stack' that prioritizes pattern matching.    A dialog may tell the dialog interpreter to raise another context to the top of the stack.)   "   layoutDiagramRow := '[canvas: Plan Tree]  [canvas: Role Dependencies]  [canvas: Noun Relations]  [canvas: Dialog Relations]'.   "The menu bar is a row of tabs identical to common desktop window menus in operation.   See: #menuActions method for further definition and documentation."   layoutMenuBar := '[menu: Ontology]  [menu: edit]  [menu: view]  [menu: tools]  [menu: simulator]'.   "What does the user/programmer need in the status bar?   I am just guessing that we should answer:   - What ontology is being edited?  (name + file)   - What is the current status of the ontology?  (Is the ontology fully defined? )   - What hint/suggestion might we provide to the programmer? (But, what is the question?)   "   layoutStatusBar := 'Ontology: [ontology name] File: [ontology file] State: [ontology state] [IDE hint]'.</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; layoutWindowAsRowsOnCanvas:</h3><pre>layoutWindowAsRowsOnCanvas: aWAHtmlCanvas   "This layout is visually two Rows with diagrams in top row and editor in lower row."   | layoutWindow layoutEditorPane layoutDiagramRow  layoutMenuBar      html    htmlOntologyLabel  cr  |   "Layout the Window as a table with three rows."   cr := String cr.   html := aWAHtmlCanvas.      htmlOntologyLabel := [ :canvas |        canvas div class: 'OntologyLabel';          with: ('Ontology title: " ', self ontology title, ' " file: ', (self ontology file) )].      "Finally we generate the window contents by calling the functions [blocks] that we defined above."   "html render: [ htmlMenuBar value: html ].   html break."   html table       with: [          self hideDiagrams             ifFalse: [html tableRow with: [ html tableData attributeAt: 'valign' put: 'TOP'; with: [ self layoutDiagramsAsRowOnCanvas: html ].].].                  html tableRow             with: [ "Editor Pane and Diagram Row"               html table with: [                html tableRow               with: [                  html tableData                     attributeAt: 'valign' put: 'TOP';                     with: [ self layoutMenuActionsAsColumnOnCanvas: html ].                     html tableData                       attributeAt: 'valign' put: 'TOP';                     with: [ htmlOntologyLabel value: html.                        html break.                        self currentFrame layoutFrameAsRowsOnCanvas: html ]. "tableData with"                  ]. "inner tableRow"                ]. "inner table"            ].   "outer tableRow"            ]. "outer table"      </pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; loadOntologyFile:</h3><pre>loadOntologyFile: aFileSpec    self logUserAction: 'Load ontology from file: ', aFileSpec.   "To be consistent with Hum design ideas, we will use a WorldBase instead of local file."   self delegated.</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; loadOntologyInstance:</h3><pre>loadOntologyInstance: ontologyTitle    |   |   self logUserAction: 'Load ontology instance: ', ontologyTitle.   "Initialize / Replace my ontology instance."   (self blackboard) businessEvent: ('loadOntologyInstance: ', ontologyTitle ).   ontology := (self blackboard ) getEntityName: ontologyTitle attribute: #ontology.   (ontology isNil)      ifTrue: [ontology := HumOntology new.            ontology title: ontologyTitle.             (self blackboard)                businessEvent: 'loadOntologyInstance: ',ontologyTitle;               setEntityName: ontologyTitle attribute: #ontology toValue: ontology.            ].   ^ontology.</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; log:</h3><pre>log: aString   "Use #logUserAction instead."   self shouldNotImplement.</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; logUserAction:</h3><pre>logUserAction: aString   "Log the user action for potential analysis / diagnosis."   (self userActions) add: aString.</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; menuActions</h3><pre>menuActions   "Identify the actions that the user may invoke via menu navigation."   | mainMenu ontologyMenu editMenu layoutMenu force combinedMenu |   "A menu is a sequence of name -&gt; action pairs.   We will store each menu in a Smalltalk OrderedCollection"   mainMenu := OrderedCollection new.   ontologyMenu := OrderedCollection new.   editMenu  := OrderedCollection new.   layoutMenu := OrderedCollection new.   "   The main menu simply provides a way to navigate to each sub-menu.   In main menu might be displayed on a top-navigation menu bar or on a (left) side navigation stub.   "   mainMenu       add: 'Ontology' -&gt;  [ self showSubMenu: ontologyMenu ];      add: 'Edit' -&gt; [ self showSubMenu: editMenu ];      add: 'Layout' -&gt; [ self showSubMenu: layoutMenu ].   "   The ontology menu provides actions affecting the ontology that is currently the subject/context of the Browser instance.   Content in parentheses below may be displayed or reserved as 'help hints'. (That could be a user preference option.)   Navigation via keyboard may follow the convention that the first letter of each menu entry is the key.   If the first letter of the first word is not unique, the first letter of the second word may be used.   Conventionally, the navigation letter may be indicated by underlining it in the menu list.   "   ontologyMenu      add: 'New Ontology (Start a new ontology.)' -&gt; [ self clearOntology.  self ontology title: (self dialog ask: 'What is the new ontology`s name?' ) ];      add: 'Open Ontology (Open an existing ontology.)' -&gt; [ self clearOntology.  self loadOntologyFile: (self dialog askFile: 'Where (what file/URI) is the ontology?')];      add: 'Save Ontology (Save the current state of this ontology.)' -&gt; [ self saveOntology. ];       "* Save will overwrite an existing file without asking If file is not known, it will dialog for a file name. (Relatively harmless if we have infinite undo.)"      add: 'Save As . . .  (Save this ontology in a specific file.)' -&gt; [ self ontology file: ( self dialog askFile: 'What file?')];      "* I expect Save-As to be used like it is in Smalltalk - as a kind of poor-man's source code label mechanism."      add: '---' -&gt; [];      add: 'Render as . . . (Document the ontology in PDF or HTML? )' -&gt; [ self ontology renderAs: ( self dialog ask: 'Document the ontology in PDF or HTML format?' choice: #( #PDF #HTML )  )  ].      "   The edit menu provides a way to open the editor on new frames.   The edit menu provides an additional way to navigate to existing frames.   The general idea is that the programmer identifies the type of frame   and then the resulting dialog identifies the particular frame.   "   editMenu      add: 'Plan (Edit a plan frame.)' -&gt; [self editPlanFrame: ( self dialog ask: #Plan) ];      add: 'Action (Edit a role-action frame.)' -&gt; [self dialog ask: #( #Role #Action ).                                        self editActionFrame: (self dialog valueOfAttribute: #Action) forRole: (self dialog valueOfAttribute: #Role) ];      add: 'Dictionary (Edit a dictionary frame.)' -&gt; [ self editDictionaryFrame: ( self dialog ask: #Dictionary ).];      add: 'Dialog Context (Edit a dialog-context frame.)' -&gt; [self editDialogFrame: ( self dialog ask: #( #Dialog #Context ) )];      add: 'View Pane (Edit a view-pane frame.)' -&gt; [self editViewFrame: ( self dialog ask: #Pane )  ].   "   The layout menu provides the means for the user to change the layout of the browser window.   The user may switch between column and row layouts. (See: #layoutWindowAsColumns and #layoutWindowAsRows. )   The user may toggle to and from a full-screen for the browser window itself.   In some situations, the user may wish to hide/suppress the diagrams.   "   layoutMenu       add: 'Full Screen (Toggle this browser window to/from full-sceen.)' -&gt; [ self toggleFullScreen ];      add: 'Transpose Layout (Tranpose the browser layout between row mode and column mode.)' -&gt; [ self transposeLayout ];      add: 'Hide Diagrams (Hide or Un-hide the diagram panes.)' -&gt; [ self toggleDiagramView ].    "The following will force each menu action to be defined, if not implemented."   force := [ :menu |       menu do: [ :menuItem |          | action |         action := menuItem value.         "Evaluate the block to force the selectors it references to be created."         action value.         ]      ].   "force value: ontologyMenu."   combinedMenu := ( ontologyMenu, editMenu, layoutMenu ).   ^ combinedMenu.</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; newOntology</h3><pre>newOntology   "Start with a fresh new ontology and clear any related views."   self logUserAction: 'New ontology'.   self ontology: ( HumOntology new ).</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; nounDiagram</h3><pre>nounDiagram   ^ nounDiagram ifNil: [ nounDiagram := HumDiagram new title: 'Noun Diagram '].</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; ontology</h3><pre>ontology   ^ ontology ifNil: [ ontology := HumOntology new. ].</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; openOntology</h3><pre>openOntology   "Clear all views and load an ontology from a save file."   | fileName |   self logUserAction: 'Open ontology'.   fileName := self openOntologyDialog.</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; openOntologyDialog</h3><pre>openOntologyDialog   self shouldBeImplemented.</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; planDiagram</h3><pre>planDiagram   ^ planDiagram ifNil: [ planDiagram := HumDiagram new title: 'Plan Diagram '].</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; printOntology</h3><pre>printOntology   "Document the current ontology in a HTML document"   self logUserAction: 'Print ontology'.</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; programmersAssistant</h3><pre>programmersAssistant   ^ programmersAssistant ifNil: [ programmersAssistant := HumProgrammersAssistant new ].</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; renderContentOn:</h3><pre>renderContentOn: html   ( self layout = #columns )       ifTrue:  [ self layoutWindowAsColumnsOnCanvas: html.]      ifFalse: [ self layoutWindowAsRowsOnCanvas: html].   </pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; roleDiagram</h3><pre>roleDiagram   ^ roleDiagram ifNil: [ roleDiagram := HumDiagram new title: 'Role Diagram '].</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; saveOntology</h3><pre>saveOntology   "Write the current ontology into a save file."   self logUserAction: 'Save ontology'.   ( self programmersAssistant ) saveOntologyOnFileNamed: ( self ontology file ).</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; showSubMenu:title:onCanvas:</h3><pre>showSubMenu: aMenu title: aString onCanvas: html   "aMenu is an OrderedCollection of ( name -&gt; action ).   To display it we need only show the list of names.   The question is where and how do we show the list?   "   html break; break; emphasis: aString.   aMenu do: [ :menuItem | "Make an anchor for each menu item."            | x commandWithHelp command action |      commandWithHelp := menuItem key.      action := menuItem value.      x := commandWithHelp indexOf: $(.      ( x &gt; 0 )         ifTrue: [            command := commandWithHelp copyFrom: 1 to: (x - 1).            html break.  html anchor class: 'menu'; callback: action; with: command.             ]         ifFalse: ["Assume its a separator"            html break; text: '---'.            ].      ].</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; toggleDiagramView</h3><pre>toggleDiagramView   self logUserAction: 'Toggle Diagrams (Hide / Un-Hide)'.   self hideDiagrams: ( self hideDiagrams not ).</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; toggleFullScreen</h3><pre>toggleFullScreen   self logUserAction: 'Toggle full screen.'</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; transposeLayout</h3><pre>transposeLayout   self logUserAction: 'Transpose browser layout'.   (self layout = #rows )       ifTrue: [ self layout: #columns]       ifFalse: [self layout: #rows ].</pre><h3>Hum-Seaside -- HumBrowser &gt;&gt; userActions</h3><pre>userActions   ^ userActions ifNil: [ userActions := OrderedCollection new.].</pre><h3>Hum-Seaside -- HumSeasideComponentThingy &gt;&gt; ask:</h3><pre>ask: aSymbol    "Ask, set, and return the requested attrbute."   | result |   "STUB"   ^ 'HERE IS STUB ANSWER'   </pre><h3>Hum-Seaside -- HumSeasideComponentThingy &gt;&gt; ask:choice:</h3><pre>ask: aString choice: anArrayOfSymbol   "The array of symbols liimits the user's choices"   self logDialogAction: 'Ask user to choose between: ', ( anArrayOfSymbol asString).   "*** THIS IS A STUB ***"   ^ (anArrayOfSymbol at: 1).</pre><h3>Hum-Seaside -- HumSeasideComponentThingy &gt;&gt; askFile:</h3><pre>askFile: aString    "Initiate a file spec dialog."   | result |   self logDialogAction: 'Ask filename: ', aString.   result := self ask: #File.   ^result.</pre><h3>Hum-Seaside -- HumSeasideComponentThingy &gt;&gt; askV00:</h3><pre>askV00: aSymbol    "Ask, set, and return the requested attrbute."   | result |   "*** THIS IS A MOCK ***"   result := aSymbol asString, ' - value'.   self attributes at: aSymbol put: result.   ^result.</pre><h3>Hum-Seaside -- HumSeasideComponentThingy &gt;&gt; attributes</h3><pre>attributes   ^ attributes ifNil: [ attributes := Dictionary new. ].</pre><h3>Hum-Seaside -- HumSeasideComponentThingy &gt;&gt; logDialogAction:</h3><pre>logDialogAction: aString    Transcript show: 'Dialog: ', aString; cr.</pre><h3>Hum-Seaside -- HumSeasideComponentThingy &gt;&gt; renderView:onCanvas:</h3><pre>renderView: anEntityID onCanvas: html   "**** Check generated code by pasting it below. ****"   self halt.      html form with: [       html break.       html heading level: 2; with: '!! Recipe'.      html break.       html textInput                   callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #name toValue: datum ];                   value: 'name'.      html break.       html textInput                   callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #description toValue: datum ];                   value: 'description'.      html break.       html textInput                   callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #ingredients toValue: datum ];                   value: 'ingredients'.      html break.       html textInput                   callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #steps toValue: datum ];                   value: 'steps'.      ].  "form with:"   </pre><h3>Hum-Seaside -- HumSeasideComponentThingy &gt;&gt; valueOfAttribute:</h3><pre>valueOfAttribute: aSymbol    "Return the requested attrbute."   | result |   result :=  self attributes at: aSymbol.   ^result.</pre><h3>Hum-Tests -- GivenWhenThen4Seaside &gt;&gt; assert:match:</h3><pre>assert: aBlock match: aPatternString    "This is a utility function to improve readability."   | html |   html := self builder render: aBlock.   self      assert: ( aPatternString match: html )      description:   'Expected: ', ( aPatternString printString ), ', Actual: ', ( html printString )      resumable: true.      </pre><h3>Hum-Tests -- GivenWhenThen4Seaside &gt;&gt; assert:matches:</h3><pre>assert: aBlock matches: aPatternString    "This is a utility function to improve readability."   | html |   html := self builder render: aBlock.   self      assert: ( aPatternString matches: html )      description:   'Expected: ', ( aPatternString printString ), ', Actual: ', ( html printString )      resumable: true.      </pre><h3>Hum-Tests -- GivenWhenThen4Seaside &gt;&gt; assertString:includesSubstring:</h3><pre>assertString: stringA includesSubstring: stringB    " stringB should be a substring in stringA "   | quote x |   quote := $' asString.   x := stringA findString: stringB.   self assert: (x &gt; 0) description: 'Expecting ', quote, stringA, quote, ' contains ', quote, stringB, quote.</pre><h3>Hum-Tests -- GivenWhenThen4Seaside &gt;&gt; expect:actual:</h3><pre>expect: expectedValue actual: actualValue    self assert: (expectedValue = actualValue)        description: ( 'Expected: ', expectedValue asString,' actual: ', actualValue asString ).</pre><h3>Hum-Tests -- GivenWhenThen4Seaside &gt;&gt; given:code:</h3><pre>given: aDescriptionString code: aBlock   "Given in a given-when-then triplet    -- use to setup test context (initial state).   The code may contain asserts to self-check.   "   self log:  ( String cr, 'Given: ', aDescriptionString ).   "Save the block so that multiple *when* can restore initial state before running."   givenBlock := aBlock.   ^self.   </pre><h3>Hum-Tests -- GivenWhenThen4Seaside &gt;&gt; givenWhenThenComment</h3><pre>givenWhenThenComment   "The #given:code: and #when:code: and #then:code: methods are designed to be cascaded.   Note that #when:code: runs the block provided in the call to #given:code: to set-up initial condition.   That enables multiple *when-then* sequences to run even if they might interfere with each other.   However, you still need to be careful of side-effects.   "   ^ 'The #given:code: and #when:code: and #then:code: methods are designed to be cascaded.   Note that #when:code: runs the block provided in the call to #given:code: to set-up initial condition.   That enables multiple *when-then* sequences to run even if they might interfere with each other.   However, you still need to be careful of side-effects.'</pre><h3>Hum-Tests -- GivenWhenThen4Seaside &gt;&gt; log</h3><pre>log   ^ log ifNil: [ log := OrderedCollection new. ].</pre><h3>Hum-Tests -- GivenWhenThen4Seaside &gt;&gt; log:</h3><pre>log: aString   | entry |   "Prepend a CR to make inspection more readable."   ( aString beginsWith: (String cr) )      ifTrue: [ entry := aString ] ifFalse: [ entry := String cr, aString ].   ( self log ) add: aString.</pre><h3>Hum-Tests -- GivenWhenThen4Seaside &gt;&gt; test105GivenWhenThenSuccess</h3><pre>test105GivenWhenThenSuccess   "Test the test utility - In this situation the test assertion is true."   | test x y z |   test := self class basicNew.   "A typical test looks like this."      test      given: 'given description' code: [ x:= 'given set'];      when: 'when description'  code: [ y := 'when set'];      then: 'then description' code: [ z := 'then set'. self assert: (true) ].   "Blocks should have executed."   self assert: ( x sameAs: 'given set' ).   self assert: ( y sameAs: 'when set' ).   self assert: ( z sameAs: 'then set' ).      </pre><h3>Hum-Tests -- GivenWhenThen4Seaside &gt;&gt; test106GivenWhenThenFail</h3><pre>test106GivenWhenThenFail   "Test the test utility - In this situation the test assertion is true."   | test x y z |   test := self class basicNew.   "Normally, this test is not needed."   false ifFalse: [^self].   test := self class basicNew.      "A typical test looks like this."      test      given: 'given description' code: [ x:= 'given set'];      when: 'when description'  code: [ y := 'when set'];      "Following should show assertion fails."      then: 'then description'          code: [ z := 'then set'.                      self assert: (false).                      ].   self should: [test then: 'should fail' code: [ self assert: false ] ] raise: AssertionFailure.      </pre><h3>Hum-Tests -- GivenWhenThen4Seaside &gt;&gt; test110BasicLog</h3><pre>test110BasicLog   "Test the testcase`s own log"   | test |   test := HumSeasideTests new.   test log: 'This is only a test'.   self assert: ( (test log at: 1 ) sameAs: 'This is only a test' ).</pre><h3>Hum-Tests -- GivenWhenThen4Seaside &gt;&gt; test120GivenWhenThenLogging</h3><pre>test120GivenWhenThenLogging   "Test the testcase`s own log"   | test x y z |   test := self class basicNew.   "A typical test looks like this."      test      given: 'given description' code: [ x:= 'given set'];      when: 'when description'  code: [ y := 'when set'];      then: 'then description' code: [ z := 'then set'. self assert: (true) ].   "The log should contain the descriptions."   self assertString: ( test log at: 1 ) includesSubstring: 'given description'.      self assertString: ( test log at: 2 ) includesSubstring: 'when description'.      self assertString: ( test log at: 3 ) includesSubstring: 'then description'.         </pre><h3>Hum-Tests -- GivenWhenThen4Seaside &gt;&gt; then:code:</h3><pre>then: aDescriptionString code: aBlock   "*Then* in a given-when-then triplet    -- Use to test post-condition after the given and then have run.   The code may contain asserts to self-check.   "   self log:  ( 'Then: ', aDescriptionString ).   "Run my assertions."   aBlock value.   ^self.   </pre><h3>Hum-Tests -- GivenWhenThen4Seaside &gt;&gt; when:code:</h3><pre>when: aDescriptionString code: whenBlock   "*When* in a given-when-then triplet    -- Use to trigger events or add to state.   The code may contain asserts to self-check.   "   "Run the given block to reset to initial state.   This enables a sequence such as: Given, When, Then, When, Then.   It allows the When blocks to create contradicting states.   "   givenBlock value.   "Now run my block"   self log:  ( 'When: ', aDescriptionString, String cr ).   whenBlock value.   ^self.   </pre><h3>Hum-Tests -- GivenWhenThen &gt;&gt; assertString:includesSubstring:</h3><pre>assertString: stringA includesSubstring: stringB    " stringB should be a substring in stringA "   | quote x |   quote := $' asString.   x := stringA findString: stringB.   self assert: (x &gt; 0) description: 'Expecting ', quote, stringA, quote, ' contains ', quote, stringB, quote.</pre><h3>Hum-Tests -- GivenWhenThen &gt;&gt; given:code:</h3><pre>given: aDescriptionString code: aBlock   "Given in a given-when-then triplet    -- use to setup test context (initial state).   The code may contain asserts to self-check.   "   self log:  ( String cr, 'Given: ', aDescriptionString ).   "Save the block so that multiple *when* can restore initial state before running."   givenBlock := aBlock.   ^self.   </pre><h3>Hum-Tests -- GivenWhenThen &gt;&gt; givenWhenThenComment</h3><pre>givenWhenThenComment   "The #given:code: and #when:code: and #then:code: methods are designed to be cascaded.   Note that #when:code: runs the block provided in the call to #given:code: to set-up initial condition.   That enables multiple *when-then* sequences to run even if they might interfere with each other.   However, you still need to be careful of side-effects.   "   ^ 'The #given:code: and #when:code: and #then:code: methods are designed to be cascaded.   Note that #when:code: runs the block provided in the call to #given:code: to set-up initial condition.   That enables multiple *when-then* sequences to run even if they might interfere with each other.   However, you still need to be careful of side-effects.'</pre><h3>Hum-Tests -- GivenWhenThen &gt;&gt; log</h3><pre>log   ^ log ifNil: [ log := OrderedCollection new. ].</pre><h3>Hum-Tests -- GivenWhenThen &gt;&gt; log:</h3><pre>log: aString   | entry |   "Prepend a CR to make inspection more readable."   ( aString beginsWith: (String cr) )      ifTrue: [ entry := aString ] ifFalse: [ entry := String cr, aString ].   ( self log ) add: aString.</pre><h3>Hum-Tests -- GivenWhenThen &gt;&gt; test105GivenWhenThenSuccess</h3><pre>test105GivenWhenThenSuccess   "Test the test utility - In this situation the test assertion is true."   | test x y z |   test := self class basicNew.   "A typical test looks like this."      test      given: 'given description' code: [ x:= 'given set'];      when: 'when description'  code: [ y := 'when set'];      then: 'then description' code: [ z := 'then set'. self assert: (true) ].   "Blocks should have executed."   self assert: ( x sameAs: 'given set' ).   self assert: ( y sameAs: 'when set' ).   self assert: ( z sameAs: 'then set' ).      </pre><h3>Hum-Tests -- GivenWhenThen &gt;&gt; test106GivenWhenThenFail</h3><pre>test106GivenWhenThenFail   "Test the test utility - In this situation the test assertion is true."   | test x y z |   test := self class basicNew.   "Normally, this test is not needed."   false ifFalse: [^self].   test := self class basicNew.      "A typical test looks like this."      test      given: 'given description' code: [ x:= 'given set'];      when: 'when description'  code: [ y := 'when set'];      "Following should show assertion fails."      then: 'then description'          code: [ z := 'then set'.                      self assert: (false).                      ].      </pre><h3>Hum-Tests -- GivenWhenThen &gt;&gt; test110BasicLog</h3><pre>test110BasicLog   "Test the testcase`s own log"   | test |   test := HumSeasideTests new.   test log: 'This is only a test'.   self assert: ( (test log at: 1 ) sameAs: 'This is only a test' ).</pre><h3>Hum-Tests -- GivenWhenThen &gt;&gt; test120GivenWhenThenLogging</h3><pre>test120GivenWhenThenLogging   "Test the testcase`s own log"   | test x y z |   test := self class basicNew.   "A typical test looks like this."      test      given: 'given description' code: [ x:= 'given set'];      when: 'when description'  code: [ y := 'when set'];      then: 'then description' code: [ z := 'then set'. self assert: (true) ].   "The log should contain the descriptions."   self assertString: ( test log at: 1 ) includesSubstring: 'given description'.      self assertString: ( test log at: 2 ) includesSubstring: 'when description'.      self assertString: ( test log at: 3 ) includesSubstring: 'then description'.         </pre><h3>Hum-Tests -- GivenWhenThen &gt;&gt; then:code:</h3><pre>then: aDescriptionString code: aBlock   "*Then* in a given-when-then triplet    -- Use to test post-condition after the given and then have run.   The code may contain asserts to self-check.   "   self log:  ( 'Then: ', aDescriptionString ).   "Run my assertions."   aBlock value.   ^self.   </pre><h3>Hum-Tests -- GivenWhenThen &gt;&gt; when:code:</h3><pre>when: aDescriptionString code: whenBlock   "*When* in a given-when-then triplet    -- Use to trigger events or add to state.   The code may contain asserts to self-check.   "   "Run the given block to reset to initial state.   This enables a sequence such as: Given, When, Then, When, Then.   It allows the When blocks to create contradicting states.   "   givenBlock value.   "Now run my block"   self log:  ( 'When: ', aDescriptionString, String cr ).   whenBlock value.   ^self.   </pre><h3>Hum-Tests -- Hum000RefactoringTests &gt;&gt; givenOntology</h3><pre>givenOntology   | ontology planFrame1 planFrame2 planFrame3 frameUpdater |      ontology := HumOntology new.   ontology title: 'givenOntology'.         planFrame1 := HumFrame4Plan ontology: ontology goal: 'Bake a cake per recipe.'.   planFrame1 appendPrecondition: 'Oven is preheated per recipe.'.      planFrame1 appendPrecondition: 'Batter is in bake-pan per recipe.'.   planFrame1 appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.   ontology storeFrame: planFrame1.         planFrame2 := HumFrame4Plan ontology: ontology goal: 'Oven is preheated per recipe.'.   planFrame2 appendPrecondition: 'Oven is cleared out.'.   planFrame2 appendPrecondition: 'Oven is on.'.   planFrame2 appendPrecondition: 'Oven temperature is set per recipe.'.   planFrame2 appendRole: 'Timer' action: 'Wait 5 minutes.'.   ontology storeFrame: planFrame2.      planFrame3 := HumFrame4Plan ontology: ontology goal: 'Batter is in bake-pan per recipe.'.   planFrame3 appendPrecondition: 'Batter fully mixed per recipe.'.   planFrame3 appendPrecondition: 'Bake-pan is greased per recipe.'.   planFrame3 appendRole: 'Baker' action: 'Pour batter into bake-pan per recipe.'.   ontology storeFrame: planFrame3.      "Create an Action Frame."   frameUpdater := HumFrameUpdater ontology: ontology                                        role: 'baker'                                                    action: 'Bake the pan in the oven for the time given in the recipe.'.   frameUpdater appendInstructionStatement: 'Open the oven door.'.   frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.   frameUpdater appendInstructionStatement: 'Close the oven door.'.   frameUpdater appendInstructionRole: 'Oven' statement: 'Bake for the baking-time given in the recipe.' comment: 'We have a smart oven.'.      ontology storeFrame: ( frameUpdater frame ).      "Create a Dictionary Frame."   frameUpdater := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.   frameUpdater addDictionaryLine: 'Recipe attributes include recipe-name, description, ingredients, steps.'.   frameUpdater addDictionaryLine: 'Recipe includes a list of ingredients.'.   frameUpdater addDictionaryLine: 'Recipe includes a list of steps.'.   frameUpdater addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.   frameUpdater addDictionaryLine: 'Step attributes include step-number, step-description'.   frameUpdater addDictionaryLine: 'Bakery attributes include oven, mixer, counter.'.   frameUpdater addDictionaryLine: 'Recipe attributes include baking-time.'.   ontology storeFrame: ( frameUpdater frame ).   "Create a View Frame."   frameUpdater := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.   frameUpdater addMarkUp: '!! Recipe'.   frameUpdater addMarkUp: ' recipe-name: [name]'.   frameUpdater addMarkUp: '   description: [description 5]'.   frameUpdater addMarkUp: '   ingredients: [ingredients]'.   frameUpdater addMarkUp: '  Do _not_ forget to ~preheat~ the *oven*.'.  "Test emphasis."   frameUpdater addMarkUp: '            steps: [steps]'.   ontology storeFrame: ( frameUpdater frame ).      "Frames must be compiled if nouns are to be marked."   ontology compileAllFrames.      ^ontology</pre><h3>Hum-Tests -- Hum000RefactoringTests &gt;&gt; humClassResponsiblityCollaboration</h3><pre>humClassResponsiblityCollaboration^'Collaborative Roles and ResponsibilitiesTODO: Does this "Purpose:" hierarchy has a place in Hum Action Frames?Top-Level Roles===============Role: Ontology.   Purpose: Maintain and access frames.        Action: Add frame.        (Other tests will also cover.)      Action: Add frame-line.   (Depends on the kind of frame. Other tests will cover as by-product.)      Action: Get frame where . . .  (tests12x ... 13x )      Action: . . . where goal is planned.      Action: . . . where action is defined.      Action: . . . where view is defined.      Action: Get frames where . . .      Action: . . . where precondition is used. (A goal-frame has a set of preconditions.)      Action: . . . where action is invoked.    (Actions may be invoked in goal, action, and vignette frames.)      Action: . . . where view is invoked.      (A view may be invoked in view and vignette frames.)      Action: . . . where context is defined.    (Each context vignette is a frame.)      Action: . . . where context is invoked.     (Scan the vignette instructions at compile time?)   Purpose: Maintain and access noun relationships. (These are covered in old HumOntologyTests)      Action: Add noun attributes.      Action: Note noun supertype.      Action: Get all supertypes for noun.      Action: Get all subtypes for noun.      Action: Get frame-lines where noun is used.  (Skipped -- 12 Feb 2014)   Role: Ontology Viewer. (subtype Ontology   *** REFACTORING ***)   Purpose: Provide visualizations of the ontology.      Action: Pretty-print ontology via HTML markup.      Action: Translate ontology relationships to graph. (UI may render graph as SVG).      Action: . . . goal dependencies . . .      Action: . . . noun dependencies . . .      Action: . . . role dependencies . . .      Action: . . . dialog context paths . . .      Action: . . . view hierarchy . . .      Role: Ontology Translator (subtype Ontology  *** REFACTORING ***)   Purpose: Translate ontology into other programming languages.      Action: Translate ontology role to Erlang process.      Action: Translate ontology goal-frame to Erlang FSM.      Action: Translate ontology role to Java interface and class files.      Action: Translate Hum view to Smalltalk Seaside (+ Hum Run-Time).      Futures?      Action: Translate ontology role to Python class.      Action: Translate ontology role to Javascript class. (prototype)      Role: Programmers Assistant. (subtype Dialog)   Purpose: Display and update ontology frames and diagrams.      Action: Respond to user gestures by invoking ontology and user-interface actions.      Action: Layout IDE view frames.      Action: Parse frame-line source code.   Purpose: Identify potential problems, missing code. (Code Critic)      Action: Statement has no known nouns.  (Implies that the only parameter is the job.)      Action: Noun lacks antecedent.         (There is no way to populate it at run-time.)      Action: Spellcheck frame-line.         (Words should be in natural dictionary or local jargon.)      Action: Identify undefined preconditions as pending.      Action: Identify undefined actions as pending.       Action: Identify noun-graph cycles as warning.      Action: Identify precondition-graph cycles as error.      Action: Identify action-graph cycles as warning.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Run-Time Layer==============Role: Run-Time.   Purpose: Operate plans, views, and dialogs.   (Ontology is active on the run-time layer.)      * Coordinator: Operate plans.      * User-Interface: Operate views.      * Dialog-Agent: Operate dialogs.      * Messenger: Provide agent-to-agent communication infrastructure.      * Resource-Manager: Assign agents to tasks. (actions on jobs)      * Bookkeeper: Record resource utilization.      * Calculator: Implement traditional data-processing operations.      * World-Base: Implement temporal database.Role: Run-Time User-Interface. (Hum-UI package)   Purpose: Translate to/from user-interface framework (e.g. HTML browser)      Action: Capture and forward view update event data. (to Scribe / Blackboard ???)      * Dialog: Operate Hum dialog.      * Dialog: Operate Hum view.      * Dialog: Ask client for data needed to operate plan.      Action: Track 2-D surface coordinates.      * Painter: Render surfaces as SVG.      Action: Draw diagram from graph-data.      * Painter: Render diagram as SVG.        (TODO: Should HumGraph or Painter position the nodes in virtual space?)       (TODO: Use an external product for dynamic interactive positioning.)      Action: Track 3-D solid coordinates.      * Sculptor: Render 3-D solid assembly as SVG/JavaScript. (Use WebGL wrapper)Role: Run-Time Calculator.  (HumCalculator class)   Purpose: VM provides data processing services, operates on datatype primitives.      (Measure Operations)      Action: Add/Subtract/Multiply/Divide measure-A with measure-B giving measure-C.      Action: Add/Subtract/Multiply/Divide distribution-A and distribution-B giving distribution-C.      (Distribution Operations)      Action: From distribution select value at Z. (Z between 0.0 and 1.0. Interpolating to give value.)      Action: From collection analyze attribute frequency giving distribution.      (String Operations)      Action: Extract substring from string-A . . . giving string-B.      Action: Insert  substring into string-A . . . giving string-B.      Action: Format xml with . . . giving xml-string.      Action: Fill in template from dictionary.      Action: Match pattern to string giving dictionary.      (Date  Operations)      Action: Compare date-A with date-B giving duration.      Action: Add duration to date-A giving date-B.      (Collection Operations)      Action: In collection-A return entities where &lt;boolean expression&gt; giving collection-B.      Action: From collection return size (count).      (Persistence Operations)      Action: Save/Restore actor`s state {blackboard, IP, job-ticket}. (On call to another actor)      Action: Notify World-Base when blackboard changes.      Action: Populate blackboard from action-call {requester, action, noun-values, job-ticket}.      Action: Forward action-call to Messenger.       (String, Date, Collection, Persistence support bootstrap and user extensions.)- - - - - - - - - - - - - - - - - - -. . . Run-Time Work-Flow Roles . . .- - - - - - - - - - - - - - - - - - -Role: Coordinator.   Purpose: Operate plans.      Action: Populate plan with data from blackboard.      * Dialog: Ask for data needed to operate plan.      Action: Evaluate preconditions and invoke actions that are ready.      Action: Assert precondition. (when action completes)      Action: Notify client and bookkeeper when plan is complete.      * Role: Dispatcher.   Purpose: Manage actors.      * Dispatcher: Assign actor to perform role action on job.      * Bookkeeper: Tally resource usage for job.      * Intervener: Handle problem reported by actor performing action for job.      * Monitor: Identify over-long action-duration.Role: Bookkeeper.   Purpose: Track resource utilization.   (Bookkeeper does not monetize utilization or inventory. See Accounting role for that.)      Action: Record resource-utilized by actor performing action on job.      Action: Sum/Select resource-utilized by actor/job/client/action/resource-type/inventory.   (12 slightly different actions)Role: Messenger.   Purpose: Deliver messages. Provide log, audit-trail, replay, security services.       Action: Deliver message from sender to receiver.      Action: Remember actor is at address.      Action: Replay messages to/from actor since date-time.      Action: Record each action-type in audit-trail.      Action: Remember/Forget that action-type requires privilege-type.Role: World-Base.   Purpose: Remember what happened and why.   (Corporate long-term memory.)      Action: Record event. (Event &lt;==&gt; Timestamp.)      Action: Record entity attribute-values due to event.      Action: Fetch current state.      Action: Fetch entity event-history.      Action: Fetch state at time-T.   Purpose: Forget what happened and why.    (Reduce short-term memory burden.)      Action: Purge data in category-C prior to time-T.      Action: . . . event records . . .      Action: . . . entity values . . .%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Shown to clarify separation of responsibility)======================Role: Accountant.      Purpose: Maintain monetary accounts.         (Traditional accounting functions go here.)      * Costing: Assign costs to resources.      * Pricing: Assign prices to products.      * Ledger: Categorize expenses, revenues, assets, liabilities, cash-flows.      * Accounts: Track counter-party obligations.      * Receivables: Track customer obligations.   (Send invoices and statements to customers.)      * Purchasing: Purchase resources as needed.      * Payables: Track supplier obligations.   (Pay suppliers for resources delivered.)      * Taxables: Track tax authority obligations.      * Banking: Track actual receipts, payments, balances.Role: Relations.    Purpose: Track who-we-know and why.       Action: Track counter-party roles.    (customers, suppliers, workers, governments)      Action: Track knowledge/capability.   (knowledge management ???)      Action: Track contracts.               (promises, pricing, future dates)      Action: Follow-up intent/obligation/claim.      (campaign, promise, agenda, order, claim)      Action: Notify counter-party of relevant events.       * Coordinator: Operate order-fulfillment plans.      * Dialog: Initiate order-fulfillment plans from sales-orders.      * Dialog: Operate automated correspondence.    (via post, e-mail, Messenger, . . .)      * Archive: Record correspondence.Role: Archive. (These functions may use the WorldBase but are not implemented there.)   Purpose: Manage enterprise documents / files.      Action: Record correspondence.        (Correspondence is also Dialog and World-Base Event)      Action: Archive product brochures, catalogs, manuals.  (Products and Documents are World-Base entities)      Action: Manage engineering documents.     (Versions, reviews, approvals, releases are also World-Base Events)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Run-Time Implementations:   Erlang:      Advantages:         Erlang OTP is a robust and mature actor framework.         ==&gt; Hum translates nicely to OTP distributed actors.         ==&gt; Hum world-base translates nicely to Erlang databases. (e.g. Riak)         May Enable a large audience for Erlang OTP.    &lt;&lt;&lt; Open OTP to enterprise audience? &lt;&lt;&lt;      Disadvantages:         Some host limitations.         Different Paradigm ==&gt; Smaller audience.  (But it might be a thought-leader audience.)   JVM ==&gt; Java/Scala/Groovy:      Advantages:         Runs almost everywhere.         Large audience.      Disadvantages:         Immature actor framework. (But I am told Scala OTP is okay.)   ECMAscript / JavaScript:      Advantages:         Runs in web browsers.         Large audience.         Enables a large web-oriented constituency.     &lt;&lt;&lt; This could be a GAME-CHANGER. &lt;&lt;&lt;&lt;         Includes strong 3D support via webGL.      Disadvantages:         NO MATURE ACTOR FRAMEWORK.         JavaScript frameworks are very diverse and not well documented.         WebGL wrappers are immature. (But that might not be a problem by the time I get to doing 3D.)   '.</pre><h3>Hum-Tests -- Hum000RefactoringTests &gt;&gt; strategyForSeaside</h3><pre>strategyForSeaside^'TBD -- Currently considering subtyping HumWidgets as WAComponentsSee: WAInputElementContainer for some code examples.See: WAInputGetFunctionalTestSee: WAModelFunctionalTestsee: WAHtml5InputTestsee: '</pre><h3>Hum-Tests -- Hum000RefactoringTests &gt;&gt; test110addFrame</h3><pre>test110addFrame   "Add frame to ontology"   | planFrame ontology |      ontology := HumOntology new.   "A plan frame should have a goal and at least two preconditions."      planFrame := HumFrame4Plan  ontology: ontology goal: 'Bake a cake per recipe'.   planFrame appendPrecondition: 'Oven is preheated per recipe.'.      planFrame appendPrecondition: 'Batter is in bake-pan per recipe.'.   planFrame appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.      ontology storeFrame: planFrame.      self assert: (ontology frames size) = 1.      self assert: (ontology framesByIdentifier size) = 1.      self assert: (ontology framesByName size) = 1.</pre><h3>Hum-Tests -- Hum000RefactoringTests &gt;&gt; test121getFrameForGoal</h3><pre>test121getFrameForGoal   "Get the plan frame that defines a goal."   | planFrame ontology result |      ontology := HumOntology new.   "A plan frame should have a goal and at least two preconditions."      planFrame := HumFrame4Plan  ontology: ontology goal: 'Bake a cake per recipe.'.   planFrame appendPrecondition: 'Oven is preheated per recipe.'.      planFrame appendPrecondition: 'Batter is in bake-pan per recipe.'.   planFrame appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.      ontology storeFrame: planFrame.      result := ontology getPlanFrameForGoal: 'Bake a cake per recipe.'.      self assert: planFrame equals: result.</pre><h3>Hum-Tests -- Hum000RefactoringTests &gt;&gt; test122getFrameForAction</h3><pre>test122getFrameForAction   "Get frame where action statement is defined."   | ontology frameUpdater result |      ontology := HumOntology new.      "Initialize for an Action Frame."   frameUpdater := HumFrameUpdater ontology: ontology                                        role: 'Baker'                                     action: 'Bake the pan in the oven for the time given in the recipe.'.   frameUpdater appendInstructionStatement: 'Open the oven door.'.   frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.   frameUpdater appendInstructionStatement: 'Close the oven door.'.   frameUpdater appendInstructionRole: 'Oven'                         statement: 'Bake for the baking-time given in the recipe.'                           comment: 'We have a smart oven.'.      ontology storeFrame: ( frameUpdater frame ).      result := ontology getFrameForRole: 'Baker' action: 'Bake the pan in the oven for the time given in the recipe.'.      self expect: ( frameUpdater frame ) actual: result.</pre><h3>Hum-Tests -- Hum000RefactoringTests &gt;&gt; test123getFrameForView</h3><pre>test123getFrameForView   "Get frame where view is defined."   | frame result ontology |   ontology := HumOntology new.   frame := HumFrame4View ontology: ontology viewEntity: 'Street-Address'.   self assert: (frame isKindOf: HumFrame4View ).      frame addMarkUp: '! This is a 1sd level title.'.   frame addMarkUp: '!! This is a 2nd level title.'.   frame addMarkUp: '!!! This is a 3rd level title.'.      ontology storeFrame: frame.      result := ontology getViewFrame: 'Street-Address'.      self assert: frame equals: result.   </pre><h3>Hum-Tests -- Hum000RefactoringTests &gt;&gt; test131getFramesInvokingPrecondition</h3><pre>test131getFramesInvokingPrecondition   "Get the goal frames that invoke a given precondition."   | frames ontology planFrameA planFrameB |   ontology := HumOntology new.      planFrameA := HumFrame4Plan  ontology: ontology goal: 'Bake a cake per recipe.'.   planFrameA appendPrecondition: 'Oven is preheated per recipe.'.      planFrameA appendPrecondition: 'Batter is prepared per recipe.'.   "Redundant. See below."   planFrameA appendPrecondition: 'Batter is in bake-pan per recipe.'.   planFrameA appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.   ontology storeFrame: planFrameA.      planFrameB := HumFrame4Plan ontology: ontology goal: 'Batter is in bake-pan per recipe.'.   planFrameB appendPrecondition: 'Batter is prepared per recipe.'.   planFrameB appendPrecondition: 'Cake-pan is prepared per recipe.'.   "Is it greased?"   planFrameB appendRole: 'Mixer' action: 'Pour batter into cake-pan.'.   ontology storeFrame: planFrameB.      ontology compileAllFrames. "Compile creates index as a by-product."      frames := ontology getFramesThatInvokePrecondition: 'Batter is prepared per recipe.'.         self assert: (frames size) equals: 2.</pre><h3>Hum-Tests -- Hum000RefactoringTests &gt;&gt; test132getFramesInvokingAction</h3><pre>test132getFramesInvokingAction   "Get the frames that invoke a given action."   | frames ontology goalFrame actionFrame vignetteFrame instruction |   ontology := HumOntology new.   "Actions may be invoked in goal-frames, action-frames, and vignettes."      "Create a goal frame. "   goalFrame := HumFrame4Plan ontology: ontology goal: 'Dishes are clean and dry.'.   goalFrame appendRole: 'Dishwasher' action: 'Clean and dry the dishes.'.   ontology storeFrame: goalFrame.      "Create an action frame."   actionFrame := HumFrame4Action ontology: ontology role: 'Chef' action: 'Boss KP.'.   actionFrame appendInstructionRole: 'Dishwasher' statement: 'Clean and dry the dishes.'.   ontology storeFrame: actionFrame.      "Create a vignette."   vignetteFrame := HumFrame4Vignette ontology: ontology vignetteContext: 'KP' pattern: '* allowance *'.   vignetteFrame addVignetteResponse: 'Okay. I will load the dishwasher.'.   instruction := (HumInstructionLine role: 'Dishwasher' statement: 'Clean and dry the dishes.').   vignetteFrame addVignetteInstruction: instruction.   ontology storeFrame: vignetteFrame.      ontology compileAllFrames. "Compile creates index as a by-product."      frames := ontology getFramesThatInvokeAction: 'Dishwasher: Clean and dry the dishes.'.      self expect: 3 actual: (frames size) description: 'Goal frame, action frame, and vignette all invoke instruction.'.</pre><h3>Hum-Tests -- Hum000RefactoringTests &gt;&gt; test133getFramesInvokingView</h3><pre>test133getFramesInvokingView   "Get views frames and vignettes that invoke a view."   | ontology  viewFrame  vignette resultSet |      "Create an ontology"   ontology := HumOntology new.      "Create a view that invokes another view."   viewFrame := HumFrame4View ontology: ontology viewEntity: 'Party'.    viewFrame addMarkUp: '!! Party'.   viewFrame addMarkUp: ' name: [name]'.   viewFrame addMarkUp: ' address: [pane: Address]'.   ontology storeFrame: viewFrame.      "Create a vignette that invokes a view."   vignette := HumFrame4Vignette ontology: ontology vignetteContext: 'Order Entry' pattern: '* delivered *'.   vignette addVignetteResponse: 'Where do you want it delivered?'.   vignette addVignetteInstruction: 'Ask Address.'.   ontology storeFrame: vignette.      ontology compileAllFrames. "Create indexes."      resultSet := ontology getFramesThatInvokeView: 'Address'.      self assert: ( resultSet size ) equals: 2.   </pre><h3>Hum-Tests -- Hum000RefactoringTests &gt;&gt; test134getFramesDefiningContext</h3><pre>test134getFramesDefiningContext   "Get vignettes that define a context."   | ontology  vignetteA vignetteB resultSet |      "Create an ontology"   ontology := HumOntology new.         "Create a vignette that defines part of a context."   vignetteA := HumFrame4Vignette ontology: ontology vignetteContext: 'Order-Entry' pattern: '* delivered *'.   vignetteA addVignetteResponse: 'Where do you want it delivered?'.   vignetteA addVignetteInstruction: 'Ask Address.'.   ontology storeFrame: vignetteA.      "Create another vignette in the same context."   vignetteB := HumFrame4Vignette ontology: ontology vignetteContext: 'Order-Entry' pattern: '* pick up *'.   vignetteB addVignetteResponse: 'When do you expect to pick up?'.   vignetteB addVignetteInstruction: 'Push context pick-up-time.'.   ontology storeFrame: vignetteB.      ontology compileAllFrames. "Create indexes."   "Test: Make this not case-sensitive."   resultSet := ontology getFramesThatDefineContext: 'order-entry'.      self assert: ( resultSet size ) equals: 2.   </pre><h3>Hum-Tests -- Hum000RefactoringTests &gt;&gt; test135getFramesInvokingContext</h3><pre>test135getFramesInvokingContext   "Get vignettes that define a context."   | ontology  vignetteA vignetteB resultSet |      "Create an ontology"   ontology := HumOntology new.         "Create a vignette that defines part of a context."   vignetteA := HumFrame4Vignette ontology: ontology vignetteContext: 'Order-Entry' pattern: '* delivered *'.   vignetteA addVignetteResponse: 'Where do you want it delivered?'.   vignetteA addVignetteInstruction: 'Ask Address.'.   ontology storeFrame: vignetteA.      "Create another vignette in the same context."   vignetteB := HumFrame4Vignette ontology: ontology vignetteContext: 'Order-Entry' pattern: '* pick up *'.   vignetteB addVignetteResponse: 'When do you expect to pick up?'.   vignetteB addVignetteInstruction: 'Push context pick-up-time.'.   ontology storeFrame: vignetteB.      ontology compileAllFrames. "Create indexes."   "Test: Make this not case-sensitive."   resultSet := ontology getFramesThatInvokeContext: 'pick-up-time'.      self assert: ( resultSet size ) equals: 1.   </pre><h3>Hum-Tests -- Hum000RefactoringTests &gt;&gt; test210prettyPrintOntologyAsHTML</h3><pre>test210prettyPrintOntologyAsHTML   "Refactor so that this function is view OntologyViewer"   | html ontology |   ontology := self givenOntology.   "Call via a OntologyViewer instance."   html := ontology view asHTML5.   </pre><h3>Hum-Tests -- Hum000RefactoringTests &gt;&gt; test211prettyPrintOntologyAsHTMLonFile</h3><pre>test211prettyPrintOntologyAsHTMLonFile   "Pretty print the given ontology on an HTML file."   | html ontology |   ontology := self givenOntology.   "Call via a OntologyViewer instance."   html := ontology view renderAsHTMLonFileNamed: 'test211.html'.   </pre><h3>Hum-Tests -- Hum000RefactoringTests &gt;&gt; test220renderCollectionAsHtmlTable</h3><pre>test220renderCollectionAsHtmlTable   "A plural noun indicates a collection.   When a view contains a plural attribute: '[ingredients]' ... '[steps]',   it should be rendered as a table of ingredients.   "   | html ontology |   ontology := self givenOntology.   "Call via a OntologyViewer instance."   html := ontology view asHTML5.   "Should see two tables"   self assert: ( '*&lt;table*&lt;/table&gt;*&lt;table*&lt;/table&gt;*' match: html ).   "Should see attributes of steps."   self assert: ( '*&lt;th&gt;*step-*&lt;/th&gt;*' match: html ).   "Should see attributes of ingredients."   self assert: ( '*&lt;th&gt;*ingredient-name*&lt;/th&gt;*' match: html ).   "html inspect."   </pre><h3>Hum-Tests -- Hum000RefactoringTests &gt;&gt; test221renderCollectionAsHtmlTableOnFile</h3><pre>test221renderCollectionAsHtmlTableOnFile   "A plural noun indicates a collection.   When a view contains a plural attribute: '[ingredients]' ... '[steps]',   it should be rendered as a table of ingredients.   "   | html ontology |   ontology := self givenOntology.   "Call via a OntologyViewer instance."   html := ontology view renderAsHTMLonFileNamed: 'test221.html'.   "Should see two tables"   self assert: ( '*&lt;table*&lt;/table&gt;*&lt;table*&lt;/table&gt;*' match: html ).   "Should see attributes of steps."   self assert: ( '*&lt;th&gt;*step-*&lt;/th&gt;*' match: html ).   "Should see attributes of ingredients."   self assert: ( '*&lt;th&gt;*ingredient-name*&lt;/th&gt;*' match: html ).      </pre><h3>Hum-Tests -- Hum000RefactoringTests &gt;&gt; test230renderEmphasisAsHTML</h3><pre>test230renderEmphasisAsHTML   "Render emphasis in the markup as underscore, italic, bold.      'Do _not_ forget to ~preheat~ the *oven*.''   "   | html ontology frameUpdater |   ontology := HumOntology new.      "Create a View Frame."   frameUpdater := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.   frameUpdater addMarkUp: '!! Heading 2'.   frameUpdater addMarkUp: '- List1'.   frameUpdater addMarkUp: '-- List2'.   frameUpdater addMarkUp: '  Do _not_ forget to ~preheat~ the *oven*.'.  "Test emphasis."   ontology storeFrame: ( frameUpdater frame ).      "Frames must be compiled if nouns are to be marked."   ontology compileAllFrames.   "Call via a OntologyViewer instance."   html := ontology view renderAsHTMLonFileNamed: 'test230.html'.   "Expect _not_ to become &lt;u&gt;not&lt;/u&gt; "   self assert: ('*&lt;u&gt;not&lt;/u&gt;*' match: html).   "Expect ~preheat~ to become &lt;i&gt;preheat&lt;/i&gt; "   self assert: ('*&lt;i&gt;preheat&lt;/i&gt;*' match: html).   "Expect *oven* to become &lt;b&gt;oven&lt;/b&gt; "   "Note: Might also see noun &lt;n&gt; tags."   self assert: ('*&lt;b&gt;*oven*&lt;/b&gt;*' match: html).      </pre><h3>Hum-Tests -- Hum000TestPlanOverview &gt;&gt; aReadMe</h3><pre>aReadMe   "See the class description for the intended (future) tests."   ^'See the class description for the intended (future) tests.'   </pre><h3>Hum-Tests -- Hum000TestPlanOverview &gt;&gt; givenWhenThenInHTML</h3><pre>givenWhenThenInHTML   "HTML GivenWhenThen frames."^'&lt;html&gt;&lt;head&gt;   &lt;title&gt;Hum PA Given-When-Then&lt;/title&gt;   &lt;style type="text/css"&gt;      pre.Reqt {font-size: Larger}      pre.Design {font-size: Smaller}   &lt;/style&gt;&lt;/head&gt;&lt;body&gt;   &lt;h1&gt;   &lt;center&gt;      Web       &lt;br/&gt;Programmers Assistant      &lt;br/&gt;Given When Then   &lt;/center&gt;&lt;/h1&gt;&lt;h2&gt;   &lt;center&gt;      The Programmers Assistant       &lt;br/&gt;User Interface behavior       &lt;br/&gt;is defined       &lt;br/&gt;via Given-When-Then story cards.   &lt;/center&gt;&lt;/h2&gt;&lt;table border=1 cellpadding=6&gt;&lt;tr&gt; &lt;th&gt;GIVEN WHEN THEN&lt;/th&gt; &lt;th&gt;ARCHITECTURE CONSEQUENCE&lt;/th&gt; &lt;/tr&gt;&lt;/pre&gt;&lt;!-- =============== --&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre class="Reqt"&gt;&lt;b&gt;Given:&lt;/b&gt; User is editing a frame.&lt;b&gt;When:&lt;/b&gt; Text cursor moves off current line        (key return, up, down, mouse click).&lt;b&gt;Then:&lt;/b&gt; Current line is pretty-printed.&lt;b&gt;Then:&lt;/b&gt; (also)  Current frame is critiqued.&lt;td&gt;&lt;pre class="Design"&gt;Either use (CodeMirrror.js)   or stick with making one line at a time   using &lt;input&gt; text or test-area.Comment: CodeMirror is probably the ideal solution. However, it may require a lot of work to get CodeMirror   to signal the Web-PA properly   and for the WebPA to interact with the code mirror.&lt;/pre&gt;&lt;/td&gt;&lt;/pre&gt;&lt;!-- =============== --&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre class="Reqt"&gt;&lt;b&gt;Given:&lt;/b&gt; User has navigated to a frame opening dialog.&lt;b&gt;When:&lt;/b&gt; User is entering the frame title statement.&lt;b&gt;Then:&lt;/b&gt;  Auto-completion is offered for title statements.&lt;b&gt;When:&lt;/b&gt; User has completed entering the frame title statement.&lt;b&gt;Then:&lt;/b&gt;  The code text is appropriately initialized      (and made visible), depending on the type of frame.    -- Empty frame may be a template.    -- Code frame is pretty-printed.    -- The first line is given focus (and/or highlighted).&lt;td&gt;&lt;pre class="Design"&gt;Use JQuery auto-completion facility.Looks easy enough.Open a new tab-pane with the code text.&lt;/pre&gt;&lt;/td&gt;&lt;/pre&gt;&lt;!-- =============== --&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre class="Reqt"&gt;&lt;b&gt;Given:&lt;/b&gt; User is entering an instruction.&lt;b&gt;When:&lt;/b&gt; User enters a delegated instruction.&lt;b&gt;Then:&lt;/b&gt;  Auto-Completion is offered for the given role name`s public actions.(A role`s public actions are those preceded with the label "Action:")&lt;td&gt;&lt;pre class="Design"&gt;Use JQuery auto-completion.PA (model of PA) should implement the query as a method.&lt;/pre&gt;&lt;/td&gt;&lt;/pre&gt;&lt;!-- =============== --&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre class="Reqt"&gt;&lt;b&gt;Given:&lt;/b&gt; User is inserting a delegated instruction into some frame.&lt;b&gt;When:&lt;/b&gt; The statement is a not one of that role`s current public actions.&lt;b&gt;Then:&lt;/b&gt;  Action (empty frame) is added     -- after user confirms intent to add a new action.&lt;b&gt;When:&lt;/b&gt; The statement currently references a private (To:) procedure.&lt;b&gt;Then:&lt;/b&gt; The procedure is converted to a public"Action:" procedure    -- after user confirms intent to convert.&lt;td&gt;&lt;pre class="Design"&gt;Use Seaside dialog to confirm user intent.PA modifies underlying code.If a converted "To:" statement is currently displayed or diagrammed,some means is needed to signal that it has changed from "To:" to "Action:".(Brute force, we could simply tell every display to update from the model.)&lt;/pre&gt;&lt;/td&gt;&lt;/pre&gt;&lt;!-- =============== --&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre class="Reqt"&gt;&lt;b&gt;Given:&lt;/b&gt; User is editing a frame`s code.&lt;b&gt;When:&lt;/b&gt; User moves text cursor to a new line . . .&lt;b&gt;Then:&lt;/b&gt; New line is highlighted.&lt;b&gt;Then:&lt;/b&gt; (also)  Old line is not.&lt;td&gt;&lt;pre class="Design"&gt;This assumes we are &lt;u&gt;not&lt;/u&gt; using CodeMirror.js.It is a work-around.&lt;/pre&gt;&lt;/td&gt;&lt;/pre&gt;&lt;!-- =============== --&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre class="Reqt"&gt;&lt;b&gt;Given:&lt;/b&gt; User is editing a frame`s code.&lt;b&gt;When:&lt;/b&gt; User presses something other than a line-selector key [up/down] . . .&lt;b&gt;Then:&lt;/b&gt; The line under the text cursor is put into edit mode.&lt;b&gt;When:&lt;/b&gt; User presses enter or return.&lt;b&gt;Then:&lt;/b&gt;  An empty line is inserted with appropriate indentation.&lt;td&gt;&lt;pre class="Design"&gt;This assumes we are &lt;u&gt;not&lt;/u&gt; using CodeMirror.js.Otherwise CodeMirror`s normal behavior should be adequate.&lt;/pre&gt;&lt;/td&gt;&lt;/pre&gt;&lt;!-- =============== --&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre class="Reqt"&gt;&lt;b&gt;Given:&lt;/b&gt; User is editing a plan frame.&lt;b&gt;When:&lt;/b&gt; User enters a precondition statement.&lt;b&gt;Then:&lt;/b&gt; Auto-completion is offered  (sourced from known conditions.)&lt;td&gt;&lt;pre class="Design"&gt;Use JQuery auto-completion. PA will provide a suitable collection (of strings) via a method.&lt;/pre&gt;&lt;/td&gt;&lt;/pre&gt;&lt;!-- =============== --&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre class="Reqt"&gt;&lt;b&gt;Given:&lt;/b&gt; User is editing a plan frame.&lt;b&gt;When:&lt;/b&gt;  User enters new precondition       (one that does not match a known condition)&lt;b&gt;Then:&lt;/b&gt; Condition is added to conditions collection    unless the annotation says "[assumed]."&lt;b&gt;When:&lt;/b&gt; Condition is added . . .&lt;b&gt;Then:&lt;/b&gt; an empty frame is inserted into frames.    -- (This empty frame simplifies some things.)&lt;td&gt;&lt;pre class="Design"&gt;Q: What happens when/if the user deletes the only reference later?A: Will think about it.  (TBD)The UI simply tells PA&gt;&gt;addLine: aPlanFrameLine.The PA then performs the rest.&lt;/pre&gt;&lt;/td&gt;&lt;/pre&gt;&lt;!-- =============== --&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;pre class="Reqt"&gt;&lt;b&gt;Given:&lt;/b&gt; Statement is in a displayed view.&lt;b&gt;When:&lt;/b&gt; Statement has no known nouns.    -- because it is entered before nouns are defined.    -- because (last) noun became undefined.&lt;b&gt;Then:&lt;/b&gt; Statement is highlighted with an"error" color.    -- background / foreground is TBD&lt;b&gt;Then:&lt;/b&gt; Critique says ". . . no known nouns"&lt;td&gt;&lt;pre class="Design"&gt;Since the set of diagrams displays all of the statements,  at least implicitly,   it appears that PA needs to scan all statements in the ontology   and update the known nouns attribute.The WebPA may then update each display   that is affected by statement qualities.This looks like a job for "Announcements" (Pharo publish/subscribe).&lt;/pre&gt;&lt;/td&gt;&lt;/pre&gt;&lt;!-- =============== --&gt;&lt;/td&gt;&lt;/tr&gt;&lt;table&gt;'.</pre><h3>Hum-Tests -- Hum000TestPlanOverview &gt;&gt; progress</h3><pre>progress   ^ '    01-Jan-2012:  33 test  65 implementation methods completed.   02-Jan-2012:  37 test  76 implementation methods completed.   03-Jan-2012:  38 test  91 implementation methods completed. -- 1079+788+188 = 2055 Lines in ST (file-out) files.   04-Jan-2012:  39 test 111 implementation methods completed -- 1088+825+152 = 2065 Lines ( after refactoring ).   ---- Start counting assert: as indicator of number of tests instead. ---   06-Jan-2012:   90 asserts 155 implementation methods completed -- 1189+1034+158  = 2381 Lines    09-Jan-2012: 101 asserts 146 implementation methods completed -- 1224+1114+162 =  2500 Lines (at 3:20 pm)   12-Jan-2012: 164 asserts 169 implementation methods completed -- 1617+1364+169+54 = 3204 Lines (at 3:30 pm)   15-Jan-2012: 211 asserts 186 implementation methods completed -- 1850+1518+208+54 = 3630 Lines (at 9:15 pm)   18-Jan-2012: 247 asserts 208 implementation methods completed -- 2113+1709+230+54 = 4106 Lines (at 1:50 pm)   --- Started work on UI ----   20-Jan-2012: 305 asserts 259 implementation methods completed -- 2314+1722+230+54+430 = 4750 Lines (at 5:05 pm)    06-Feb-2012: 363 asserts 345 implementation methods completed -- 2742+1919+253+596+547 = 6057 Lines ==&gt; ~ 5274 LoC   28-Mar-2012: 534 asserts 402 implementation methods completed -- 254+2388+804+3892+804 = 8142 Lines ==&gt; ~ 6500 LoC   10-Apr-2012: 615 asserts 419 implementation methods completed -- 254+2700+804+4406+870 = 9034 Lines ==&gt; ~ 7200 LoC    29-May-2012: Basically got lost trying to find ways to do 3D modeling and also surveying free design tools.   24-July-2012: Got distracted learning Python and using Visual Python (VPython) and using it to model trailer and to visualize Game Of Life in 3D.   28-September-2012: Got around to learning Seaside and starting to implement the IDE.               I have a site initiated at Seaside hosting.               Took a look at Magritte -- Decided to not use it in the browser.                   (too many layers and dependencies, not enough comments in the code).               I also toyed with Pier (a content management system based on Seaside and Magritte)                -- It has still another wiki-mark-up.               Pier might be worth adopting later as a wiki and book generator.                I am not convinced yet,                  but (notably) some of the Pharo/Seaside/Pier books seem to be produced via Pier.   28-September-2012: Made sure that all of my classes have comments.                      (Pet peeve about others code -- must comply myself.)   28-September-2012: 795 asserts 533 implementation methods completed -- 12592 ==&gt; ~ 10,000 LoC.   17-October-2012:   658 asserts -- I removed a large number of redundant tests that had been cut and pasted into HumSeasideTests.   17-October-2012:   658 asserts, 553 implementation methods completed-- 12173 ==&gt; still roughly 10,000 LoC.   *** ~5 months without a report -- Mostly working on HumSeaside but distracted with Python/Javascript. ***   11-March-2013:     704 asserts, 584 implementation methods completed -- 13,716 * (10/12) ==&gt; 11,430 LoC.   *** Implementing HumDiagram, HumFuzzy, HumMeasure.   25-April-2013:     785 asserts, 630 implementation methods completed -- 16,824 * (10/12) ==&gt; 14,020 LoC.   *** Miscelaneous refactoring and tinkering ***   05-February-2014: 1033 asserts 1030 implementation methods completed -- 19,888 * (10/12) ==&gt; 16,573 LoC.   10-September-2014: 1181 asserts, 1163 implementation methods completed -- 28,142 * (10/12) ==&gt; 23,451 LoC   '</pre><h3>Hum-Tests -- HumBaseTest &gt;&gt; test110putGetValue</h3><pre>test110putGetValue   "Save entity-attribute-value and fetch."   |  id type event value wb n |   n := 9.   wb := HumBase new.   ( 1 to: n )      do: [ :i |         id := i.         type := #entityType.         event := i * 11.         value := i * 111.         wb entityID: id entityType: type attribute: #attributeType value: value event: event.         ].      self expect: n actual: (wb entitiesOfType at: type) size.   self expect: 0 actual: (wb entitiesOfType at: #noneSuch ifAbsent: [Set new]) size.      ( 1 to: n )      do: [ :j |         self expect: 1 actual: ( wb entitiesWithValue at: { #attributeType. j*111. } ) size.         self expect: {{ j*111. j*11. } } actual: ( wb entityAttributeValue at: { j. #attributeType. } ) asArray.         ].      ( 1 to: n )      do: [ :k |         self expect: k*111 actual: ( wb getEntityID: k attribute: #attributeType ).         self expect: { k. } actual: ( wb findEntitiesWhereAttribute: #attributeType satisfies: [:x | x = (k * 111)]) asArray.         ].   </pre><h3>Hum-Tests -- HumBaseTest &gt;&gt; test120updateGetValue</h3><pre>test120updateGetValue   "Save entity-attribute-value and fetch."   |  id type event value wb n |   n := 9.   wb := HumBase new.   "Set initial value"   ( 1 to: n )      do: [ :i |         id := i.         type := #entityType.         event := i * 11.         value := i * 111.         wb entityID: id entityType: type attribute: #attributeType value: value event: event.         ].   "Update value"   ( 1 to: n )      do: [ :i |         id := i.         type := #entityType.         event := i * 111.         value := i * 1111.         wb entityID: id entityType: type attribute: #attributeType value: value event: event.         ].      self expect: n actual: (wb entitiesOfType at: type) size.   self expect: 0 actual: (wb entitiesOfType at: #noneSuch ifAbsent: [Set new]) size.   self expect: n actual: ( wb findEntitiesOfType: type ) size.   self expect: 0 actual: ( wb findEntitiesOfType: #noneSuch ) size.      ( 1 to: n )      do: [ :j |         self expect: 0 actual: ( wb entitiesWithValue at: { #attributeType. j*111. } ) size.         self expect: { j*1111. j*111. } actual: ( wb entityAttributeValue at: { j. #attributeType. } ) top.         ].      ( 1 to: n )      do: [ :k |         self expect: k*1111 actual: ( wb getEntityID: k attribute: #attributeType ).         self expect: { k. }               actual: ( wb findEntitiesWhereAttribute: #attributeType satisfies: [:x | x = ( k * 1111)] ) asArray.         ].   </pre><h3>Hum-Tests -- HumBaseTest &gt;&gt; test130putGetEvent</h3><pre>test130putGetEvent   "put get event"   | wb eventID |   wb := HumBase new.   eventID := wb eventWho: 'who' what: 'what' where: 'where' why: 'why not'.   self assert: (eventID isKindOf: LargePositiveInteger ).</pre><h3>Hum-Tests -- HumByteCodeTests &gt;&gt; setUp</h3><pre>setUp   "For convenience, create a Hum VM instance for all of the tests to use."      humVM := HumVM new.</pre><h3>Hum-Tests -- HumByteCodeTests &gt;&gt; test110EachInstructionHasTwoBytes</h3><pre>test110EachInstructionHasTwoBytes   "A Hum byte code instruction has two bytes -- one for operation and one for operand."   | instruction |   instruction := HumVMInstruction new.   instruction operation: 255.   instruction operand: 254.   self assert: 255 equals: ( instruction operation).   self assert: 254 equals: ( instruction operand).   </pre><h3>Hum-Tests -- HumByteCodeTests &gt;&gt; test120OpCode000IsHalt</h3><pre>test120OpCode000IsHalt   "An opCode of 000 is a halt instruction. (operand is ignored)"   | instruction |   instruction := HumVMInstruction opCode: 000 value: 000.   self assert: 'Halt' equals: ( instruction opCodeName ).</pre><h3>Hum-Tests -- HumByteCodeTests &gt;&gt; test130Operand000IsNone</h3><pre>test130Operand000IsNone   "An operand index of zero is treated as None.   (For some operators, this will be nonsence and should not compile.)"   | instruction |   instruction := HumVMInstruction opCode: 000 value: 000.   self assert: 'None' equals: instruction slotName. </pre><h3>Hum-Tests -- HumByteCodeTests &gt;&gt; test210MeasureLoad</h3><pre>test210MeasureLoad   "Load measure into measure-arithmetic register."   | instruction measure |   measure := (HumMeasure quantity: 210 units: 'meter').   humVM setSlot: 001 to: measure.   instruction := HumVMInstruction opCode: 001 value: 001.   humVM runInstruction: instruction.   self assert: ( humVM measureRegister ) equals: measure.</pre><h3>Hum-Tests -- HumByteCodeTests &gt;&gt; test220MeasureAdd</h3><pre>test220MeasureAdd   "Add measure into measure-arithmetic register."   | instruction measureA measureB measureC |      "First load a measure into the register."   measureA := HumMeasure quantity: 220 units: 'meter'.   humVM setSlot: 001 to: measureA.   instruction := HumVMInstruction opCode: 001 value: 001.   humVM runInstruction: instruction.   self assert: ( humVM measureRegister ) equals: measureA.      "Add another measure into the register."   measureB := HumMeasure quantity: 330 units: 'meter'.   humVM setSlot: 002 to: measureB.   instruction := HumVMInstruction opCode: 002 value: 002.   humVM runInstruction: instruction.      measureC := HumMeasure quantity: 550 units: 'meter'.   self assert: ( humVM measureRegister ) equals: measureC.   </pre><h3>Hum-Tests -- HumByteCodeTests &gt;&gt; test230MeasureMinus</h3><pre>test230MeasureMinus   "Add measure into measure-arithmetic register."   | instructionA instructionB measureA measureB measureC |      "First load a measure into the register."   measureA := HumMeasure quantity: 330 units: 'meter'.   humVM setSlot: 001 to: measureA.   instructionA := HumVMInstruction opCode: 001 value: 001.   humVM runInstruction: instructionA.   self assert: ( humVM measureRegister ) equals: measureA.      "Subtract another measure from the register."   measureB := HumMeasure quantity: 220 units: 'meter'.   humVM setSlot: 002 to: measureB.   instructionB := HumVMInstruction opCode: 003 value: 002.   humVM runInstruction: instructionB.      measureC := HumMeasure quantity: 110 units: 'meter'.   self assert: ( humVM measureRegister ) equals: measureC.   </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test110substringAfter</h3><pre>test110substringAfter   "Test helper method that finds a substring between two given substrings."   | stringIn stringOut calc|   stringIn := 'This is just the begining. We are expecting content after this colon: And this is it.'.   stringOut := HumCalculator given: stringIn extractAfter: ':'.   self assert: ( stringOut sameAs: ' And this is it.' ).      stringIn := 'This is just the begining. We are expecting content after this operator := Right hand side.'.   stringOut := HumCalculator given: stringIn extractAfter: ':='.   self assert: ( stringOut sameAs: ' Right hand side.' ).   </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test115substringBefore</h3><pre>test115substringBefore   "Test helper method that finds a substring between two given substrings."   | stringIn stringOut |   stringIn := 'We are expecting content before this colon: And this is it.'.   stringOut := HumCalculator given: stringIn extractUpto: ':'.   self assert: ( stringOut sameAs: 'We are expecting content before this colon' ). </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test120substringBetween</h3><pre>test120substringBetween   "Test helper method that finds a substring between two given substrings."   | stringIn stringOut calc |   stringIn := 'This is just the begining. We are expecting the stuff between [ and ].'.   stringOut := HumCalculator given: stringIn extractBetween: '[' and: ']'.   self assert: ( stringOut sameAs: ' and ' ).      stringIn := 'This is just the begining. We are expecting the stuff between [[button]].'.   stringOut := HumCalculator given: stringIn extractBetween: '[[' and: ']]'.   self assert: ( stringOut sameAs: 'button' ).      calc := HumCalculator new.   self assert: (calc given: 'lunch snacks dinner' extractBetween: 'lunch' and: 'dinner') = ' snacks '.</pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test130substringBetweenBrackets</h3><pre>test130substringBetweenBrackets   "Test helper method that finds a substring between a pair of brackets or similar pairs."   | stringIn stringOut |   stringIn := 'We are expecting the stuff between [[ and ]], including the brackets, but nothing else.'.   stringOut := HumCalculator given: stringIn extractIncludingMatching: '[]'.   self assert: ( stringOut sameAs: '[[ and ]]' ).      stringOut := HumCalculator given: 'Sometimes (parends (may be nested)).' extractIncludingMatching: '()'.   self assert: (stringOut = '(parends (may be nested))').         stringOut := HumCalculator given: 'Note (parends (may be (deeply) nested)).' extractIncludingMatching: '()'.   self assert: (stringOut = '(parends (may be (deeply) nested))').</pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test210templateFill</h3><pre>test210templateFill   | template parameters expect result calc|   template := '     &lt;div id="@id" class="@class"&gt;        @body     &lt;/div&gt;     '.   parameters := Dictionary new.   parameters      at: 'id' put: 'identifier';     at: 'class' put: 'HighClass';     at: 'body' put: 'Torso'.   calc := HumCalculator new.   result := calc fillTemplate: template fromDictionary: parameters.   expect := '     &lt;div id="identifier" class="HighClass"&gt;        Torso     &lt;/div&gt;     '.   self assert: expect equals: result.   </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test305parse</h3><pre>test305parse   "Test the simple parser."   | string calc tokens n |   string := 'Example: This is a sentence. This is a question?'.   calc := HumCalculator new.   tokens := calc parse: string.   n := tokens size.   self expect: 20 actual: n.   "Parse produces a collection of tuples: { token. type. start. stop. }"   self expect: {'Example'. #word. 1. 7. } actual: (tokens at: 1).   self expect: {':'. #separator. 8. 8. } actual: (tokens at: 2).   self expect: {' '. #whitespace. 9. 9. } actual: ( tokens at: 3).   self expect: 48 actual: (string size).   self expect: {'?'. #separator. 48. 48. } actual: (tokens at: n).   </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test310parse</h3><pre>test310parse   "calc parse: s - recognizes quoted strings as single tokens."   | string calc tokens n |   string := 'This is a "quoted text"?'.   calc := HumCalculator new.   tokens := calc parse: string.   n := tokens size.   self expect: 8 actual: n.   self expect: {'This'. #word. 1. 4. } actual: (tokens at: 1).   self expect: {' '. #whitespace. 5. 5. } actual: ( tokens at: 2).   self expect: {'?'. #separator. 24. 24. } actual: (tokens at: n).   self expect: {'"quoted text"'. #string. 11. 23. } actual: (tokens at: (n-1)).   self expect: {' '. #whitespace. 10. 10. } actual: (tokens at: (n-2)).   </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test311parse</h3><pre>test311parse   "What if string ends with quoted text?"   | string calc tokens n |   string := 'This is a "quoted text"'.   calc := HumCalculator new.   tokens := calc parse: string.   n := tokens size.   self expect: 7 actual: n.   self expect: {'This'. #word. 1. 4. } actual: (tokens at: 1).   self expect: {' '. #whitespace. 5. 5. } actual: ( tokens at: 2).   self expect: {'"quoted text"'. #string. 11. 23. } actual: (tokens at: (n)).   self expect: {' '. #whitespace. 10. 10. } actual: (tokens at: (n-1)).   </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test312parse</h3><pre>test312parse   "Test parse with quote within string."   | string calc tokens quote |   quote := $' asString.   string := 'Parse a "internal quote (',quote,')"'.   calc := HumCalculator new.   tokens := calc parse: string.   self expect: 5 actual: (tokens size).   self expect: { '"internal quote (',quote,')"'. #string. 9. 28.} actual: tokens last.</pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test313parse</h3><pre>test313parse   "calc parse: s - recognizes quoted strings as single tokens."   | string calc tokens n quote |   quote := $' asString.   string := 'This is a ',quote,'quoted text',quote,'?'.   calc := HumCalculator new.   tokens := calc parse: string.   n := tokens size.   self expect: 8 actual: n.   self expect: {'This'. #word. 1. 4. } actual: (tokens at: 1).   self expect: {' '. #whitespace. 5. 5. } actual: ( tokens at: 2).   self expect: {'?'. #separator. 24. 24. } actual: (tokens at: n).   self expect: {'''quoted text'''. #string. 11. 23. } actual: (tokens at: (n-1)).   self expect: {' '. #whitespace. 10. 10. } actual: (tokens at: (n-2)).   </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test314parse</h3><pre>test314parse   "Test parse with quote within string."   | string calc tokens quote |   quote := $" asString.   string := 'Parse a ''internal quote (',quote,')'''.   calc := HumCalculator new.   tokens := calc parse: string.   self expect: 5 actual: (tokens size).   self expect: { '''internal quote (',quote,')'''. #string. 9. 28.} actual: tokens last.   "TODO: Think about following convention where doubled quote within a string is treated as embedded quote."   "TODO: Think about following convention where special characters are preceded with back-slash (\)."</pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test510measurePlusSameUnits</h3><pre>test510measurePlusSameUnits   "Measures may be added if same units."   | m1 m2 m3 |   m1 := HumMeasure quantity: 10 units: #meter.   m2 := HumMeasure quantity: 20 units: #meter.   m3 := m1 + m2.   self expect: m3 quantity actual: 30.   self expect: m3 units actual: #meter.   </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test520measureMinusSameUnits</h3><pre>test520measureMinusSameUnits   "Measures may be added if same units."   | m1 m2 m3 |   m1 := HumMeasure quantity: 10 units: #meter.   m2 := HumMeasure quantity: 25 units: #meter.   m3 :=  m2 - m1.   self expect: m3 quantity actual: 15.   self expect: m3 units actual: #meter.</pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test540CommonUnits</h3><pre>test540CommonUnits   | v d t a |   "Test that these do not crash"   v := 10 kps.                 "kilometers per second = approximate escape velocity (10.735 going East at equator)"   self assert: (10*1000) equals: (v quantity).       a := 20 mps / (1 second).    "meters per second per second = approximately 2 G acceleration"   self assert: (20) equals: (a quantity).   self assert: ( Dictionary newFrom: { 'meter'-&gt;1. 'second'-&gt;(-2). } ) equals: (a dimensions).   self assert: 'meter per square second' equals: ( a units ).      t := v / a.                  "How many seconds to reach escape velocity?"   self assert: (10*1000/20) equals: (t quantity).   self assert: ( Dictionary newFrom: { 'second'-&gt;1. } ) equals: ( t dimensions ).   self assert: 'second' equals: ( t units ).      d := ( a / 2 ) * ( t * t ) . "How much distance covered in that amount of time?"   self assert: ((20/2)* (10*1000/20) * (10*1000/20)) equals: ( d quantity ).   "Transcript cr; show: 'test540CommonUnits d = '; show: d asString."      </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test542UnitsShouldCancel</h3><pre>test542UnitsShouldCancel   | v d t a m kineticEnergy |   "Test that these do not crash"   v := 10 kps.   self assert: ( Dictionary newFrom: { 'meter'-&gt;1. 'second'-&gt;(-1). } ) equals: ( v dimensions ).      a := 2 gravity.   self assert: ( Dictionary newFrom: { 'meter'-&gt;1. 'second'-&gt;(-2). } ) equals: ( a dimensions ).      t := v / a.   self assert: ( Dictionary newFrom: { 'second'-&gt;(1). } ) equals: ( t dimensions ).      d := a * t * t / 2.   self assert: ( Dictionary newFrom: { 'meter'-&gt;1. } ) equals: ( d dimensions ).      m := 1 tonne. "metric ton"   self assert: ( Dictionary newFrom: { 'kilogram'-&gt;1. } ) equals: ( m dimensions ).   kineticEnergy := m * v * v / 2.   self assert: ( Dictionary newFrom: { 'kilogram'-&gt;1. 'meter'-&gt;2. 'second'-&gt;(-2). } ) equals: ( kineticEnergy dimensions ).      </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test545Conversions</h3><pre>test545Conversions   | v vDisplay d dDisplay t a aDisplay e |   "Test that these do not crash"   v := 10 kps.                 "kilometers per second = approximate escape velocity (10.735 going East at equator)"   self expect: (10*1000) actual: (v quantity).    vDisplay := v as: #mph.   self assert: '22369.382 mph' equals: vDisplay.      a := 20 mps / (1 second).    "meters per second per second = approximately 2 G acceleration"   self expect: (20) actual: (a quantity).   self expect: ( Dictionary newFrom: { 'meter'-&gt;1. 'second'-&gt;(-2). } ) actual: (a dimensions).   self expect: 'meter per square second' actual: ( a units ).   aDisplay := a as: #gravity.   self pattern: '2.*gravity' matches: aDisplay .      t := v / a.                  "How many seconds to reach escape velocity?"   self expect: (10*1000/20) actual: (t quantity).   self expect: ( Dictionary newFrom: { 'second'-&gt;(1). } ) actual: ( t dimensions ).   self expect: 'second' actual: ( t units ).   self expect: (HumMeasure quantity: 500 units: #second) actual: t.      d := ( a / 2 ) * ( t * t ) . "How much distance covered in that amount of time?"   self expect: ((20/2) * (10*1000/20) * (10*1000/20)) actual: ( d quantity ).   dDisplay := d as: #miles.   self expect: '1553.429 miles' actual: dDisplay.      e := (1 kilogram) * (v * v) / 2.0. "energy per kilogram"   self expect: '5.0e7 joule' actual: (e as: #joule).      self expect:  (100 kilowatt)  actual: (e / t)  . "Average power requirement?"      </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test546ConvertVolumeMeasures</h3><pre>test546ConvertVolumeMeasures   | s a volume cubicInch displacement asLitre |   s := 1 inch.   a := s * s.   volume := a * s.    cubicInch := volume.   displacement := cubicInch * 400.    self expect: ( HumMeasure quantity: 0.0065548256 units: 'cubic meter') actual: (displacement).      asLitre := displacement as: #litre.    self expect: '6.555 litre' actual: asLitre.</pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test550CasualMeasures</h3><pre>test550CasualMeasures   "Work with non-KMS measures. Develop HumMeasure2"   | milesPerHour feetPerMile feetPerHour secondsPerHour feetPerSecond pixelWidth |   milesPerHour := HumMeasure quantity: 60 units: 'mile' per: 'hour'.   self assert: ((milesPerHour dimensions) at: 'mile') = 1.   self assert: ((milesPerHour dimensions) at: 'hour') = -1.      feetPerMile := HumMeasure quantity: 5280 units: 'foot' per: 'mile'.   self assert: ((feetPerMile dimensions) at: 'foot') = 1.   self assert: ((feetPerMile dimensions) at: 'mile') = -1.         feetPerHour := milesPerHour * feetPerMile.   self assert: ((feetPerHour dimensions) at: 'foot') = 1.   self assert: ((feetPerHour dimensions) at: 'hour') = -1.      secondsPerHour := HumMeasure quantity: 3600 units: 'second' per: 'hour'.   self assert: ((secondsPerHour dimensions) at: 'second') = 1.   self assert: ((secondsPerHour dimensions) at: 'hour') = -1.      feetPerSecond := feetPerHour / secondsPerHour.   self assert: ((feetPerSecond dimensions) at: 'foot') = 1.   self assert: ((feetPerSecond dimensions) at: 'second') = -1.   self assert: (60*5280/3600) equals: (feetPerSecond quantity).      pixelWidth := (1.0/96.0) inch. "Convert to KMS units"   self expect: (0.000264583333) actual: ( pixelWidth quantity ). "about 265 micrometre (micron) per pixel at 96 DPI"      </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test552CasualMeasuresAdd</h3><pre>test552CasualMeasuresAdd   "Work with non-KMS measures. Develop HumMeasure2"   | pretax taxRate tax total |   pretax := HumMeasure quantity: 100.0 units: 'dollar'.   taxRate := HumMeasure quantity: 0.06 units: 'dollar' per: 'dollar'.   tax := pretax * taxRate.   total := pretax + tax.      self assert: (total quantity) = 106.00.</pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test553CasualMeasuresSubtract</h3><pre>test553CasualMeasuresSubtract   "Work with non-KMS measures. Develop HumMeasure2"   | prediscount discountRate discount total |   prediscount := HumMeasure quantity: 100.0 units: 'dollar'.   discountRate := HumMeasure quantity: 0.05 units: 'dollar' per: 'dollar'.   discount := prediscount * discountRate.   total := prediscount - discount.      self assert: (total quantity) = 95.00.</pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test554AsPercent</h3><pre>test554AsPercent   "Work with non-KMS measures. Develop HumMeasure2"   | prediscount discountRate discount total |   prediscount := HumMeasure quantity: 100.0 units: 'dollar'.   discountRate := HumMeasure quantity: 0.05 units: 'dollar' per: 'dollar'.   discount := prediscount * discountRate.   total := prediscount - discount.      self assert: (total quantity) = 95.00.</pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test555CasualMeasuresAsString</h3><pre>test555CasualMeasuresAsString   "Test asString"   | force distance work time power length width area height volume|   force := HumMeasure quantity: 550 units: 'pound'.   self assert: (force asString) = '550 pound'.   distance := HumMeasure quantity: 1 units: 'foot'.   self assert: (distance asString) = '1 foot'.   work := force * distance.   self assert: '550 foot pound' equals: (work asString).   time := HumMeasure quantity: 1 units: 'second'.   "check ' per '"   power := work / time.   self assert: '550 foot pound per second' equals: (power asString).   "Check square"   length := HumMeasure quantity: 10 units: 'feet'.   width  := HumMeasure quantity: 20 units: 'feet'.   area := length * width.   self assert: ('200 square foot') equals: (area asString).   "Check cubic"   height := HumMeasure quantity: 8 units: 'feet'.   volume := area * height.   self assert: ('1600 cubic foot') equals: (volume asString).         </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test556CasualMeasuresSquares</h3><pre>test556CasualMeasuresSquares   "Test asString"   | squareFeet squareYard squareFeetPerSquareYard |      squareFeet := HumMeasure quantity: 900 units: 'square feet'.   squareFeetPerSquareYard := HumMeasure quantity: 9 units: 'square feet' per: 'square yard'.   squareYard := squareFeet / squareFeetPerSquareYard.   self assert: '100 square yard' equals: ( squareYard asString ).   </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test557CasualMeasuresCubics</h3><pre>test557CasualMeasuresCubics   "Test asString"   | cubicFeet cubicYard cubicFeetPercubicYard |      cubicFeet := HumMeasure quantity: 2700 units: 'cubic feet'.   cubicFeetPercubicYard := HumMeasure quantity: 27 units: 'cubic feet' per: 'cubic yard'.   cubicYard := cubicFeet / cubicFeetPercubicYard.   self assert: '100 cubic yard' equals: ( cubicYard asString ).   </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test560coefficientOfExpansion</h3><pre>test560coefficientOfExpansion   "Sometimes the exponents are all negative."   | coefficient |   "coefficient of expansion for aluminum   See: http://www.engineeringtoolbox.com/linear-expansion-coefficients-d_95.html"   coefficient := HumMeasure quantity: 22.2e-6 per: #degreeKelvin.   self assert: ( Dictionary newFrom: { 'degreeKelvin' -&gt; (-1). } ) equals: ( coefficient dimensions ).   </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test570CreateMeasureFromString</h3><pre>test570CreateMeasureFromString   "Create a measure from a sting of the form: -999 units"   | string expect result |   string := '-123 meter'.   result := HumMeasure fromString: string.   expect := HumMeasure quantity: -123 units: #meter.   self assert: expect equals: result.   </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test580exampleBussardRamJet</h3><pre>test580exampleBussardRamJet   | pi area speed z beta gamma volume density energy energyPerHydrogen ePerSecond |   pi := Float pi.   area :=  (1 km) * (1 km) * pi. "Assume the ram scoop is a circle."   speed := 0.1 lightSpeed.      "Is relatvity relevant at this speed?"   z := 0.1 * 0.1.      "v squared over c squared"   beta := (1 - z) sqrt.   gamma := 1.0 / beta.    self assert: (gamma &lt; 1.06 )."~ 1.05 :: Ignored because smaller than other engineering uncertainties. "      "The interstellar medium within the Local Bubble has a density of about 0.07 atoms/cm3"   density := (HumMeasure quantity: 0.07 units: #HydrogenAtom)/(1 cubicCentimeter).   energy := (26.7 mev)/ 4. "CNO fusion energy per hydrogen atom"   energyPerHydrogen := energy / (HumMeasure quantity: 1 units: #HydrogenAtom).      "How much power does the CNO fusion provide?"   volume := area * speed. "volume per second"   ePerSecond := volume * density * energyPerHydrogen.   self expect: (HumMeasure watt: 7.05e6 )   "7 megawatts"           actual: (ePerSecond).   "Seems way too small to power, let alone move, a structure 1 km in radius."       </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test581megaWattToAcceleration</h3><pre>test581megaWattToAcceleration   "What kind of acceleration does a megaWatt per tonne give?"   | power mass vSquared energy deltaVqty deltaV acceleration |   power := 1 megaWatt.   mass := 1 tonne.   energy := power * (1 second) .      "kinetic energy KE = mass * v * v / 2.    ==&gt; v := sqrt{ 2 * KE / mass }   "   vSquared := (( energy / mass ) * 2.0).   deltaVqty := (vSquared quantity ) sqrt.   deltaV := deltaVqty meterPerSecond.   self expect: '44.721 meterPerSecond' actual: (deltaV as: #meterPerSecond).   acceleration := deltaV / (1 second).   self expect: '4.560 gravity' actual: ( acceleration as: #gravity ).   "1 kilowatt per kilogram ==&gt; high acceleration (assuming perfect energy conversion)"   </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test582exampleBussardRamJet</h3><pre>test582exampleBussardRamJet   | pi area speed z beta gamma volume density energy energyPerHydrogen ePerSecond |   pi := Float pi.   area :=  (1 km) * (1 km) * pi. "Assume the ram scoop is a circle."   speed := 0.2 lightSpeed.      "Is relatvity relevant at this speed?"   z := 0.2 * 0.2.      "v squared over c squared"   beta := (1 - z) sqrt.   gamma := 1.0 / beta.    self assert: (gamma &lt; 1.06 )."~ 1.05 :: Ignored because smaller than other engineering uncertainties. "      "The interstellar medium within the Local Bubble has a density of about 0.07 atoms/cm3"   density := (HumMeasure quantity: 0.07 units: #HydrogenAtom)/(1 cubicCentimeter).   "density = HumMeasure( 70000 HydrogenAtom per cubic meter )"   energy := (26.7 mev)/ 4. "CNO fusion energy per hydrogen atom"   energyPerHydrogen := energy / (HumMeasure quantity: 1 units: #HydrogenAtom).      "How much power does the CNO fusion provide?"   volume := area * speed. "volume per second"   ePerSecond := volume * density * energyPerHydrogen.   self expect: (HumMeasure watt: 14.1e6 )   "14 megawatts"           actual: (ePerSecond).   "Still seems way too small to power, let alone move, a structure 1 km in radius."       </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test582megaWattToAcceleration</h3><pre>test582megaWattToAcceleration   "What level of acceleration does a megaWatt give to 100 tonnes of ship mass?"   | power mass vSquared energy deltaVqty deltaV acceleration |   power := 1 megaWatt.   mass := 100 tonne.   energy := power * (1 second) .      "kinetic energy KE = mass * v * v / 2.    ==&gt; v := sqrt{ 2 * KE / mass }   "   vSquared := (( energy / mass ) * 2.0).   deltaVqty := (vSquared quantity ) sqrt.   deltaV := deltaVqty meterPerSecond.   self expect: '4.472 meterPerSecond' actual: (deltaV as: #meterPerSecond).   acceleration := deltaV / (1 second).   self expect: '0.456 gravity' actual: ( acceleration as: #gravity ).   "Lower limit for one megawatt of energy production and conversion is probably about 10 tonne.     So we might have 90 tonne of payload."   </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; test590examples</h3><pre>test590examples   "Class-side examples should not fail"   HumMeasure exampleOrbitTable.   HumMeasure exampleStarVoyage.   HumMeasure exampleWateringHighPlains.   HumMeasure exampleSlingShotToOrbit. </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; testV110VectorCrossProduct</h3><pre>testV110VectorCrossProduct   "Check the vector cross product"   | u v s |   u := HumVector newFrom: #( 1.0 0.0 0.0 ). "Default unit of measure is 'meter'."   v := HumVector newFrom: #( 0.0 1.0 0.0 ).      s := u cross: v.   self expect: 'square meter' actual: s units. "Thus cross product has units of 'square meter'."      self expect: 0.0 actual: ( s at: 1 ) quantity.   self expect: 0.0 actual: ( s at: 2 ) quantity .   self expect: 1.0 actual: ( s at: 3 ) quantity.      </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; testV111VectorCrossProduct</h3><pre>testV111VectorCrossProduct   "Check the vector cross product"   | u v s |   u := HumVector newFrom: #( 0.0 0.0 1.0 ).   v := HumVector newFrom: #( 0.0 1.0 0.0 ).      s := u cross: v.   self expect: 'square meter' actual: s units.   self assert: ( s at: 1 ) quantity = -1.0.   self assert: ( s at: 2 ) quantity =  0.0.   self assert: ( s at: 3 ) quantity =  0.0.      </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; testV112VectorCrossProduct</h3><pre>testV112VectorCrossProduct   "Check the vector cross product"   | u v s |   u := HumVector newFrom: #( 0.0 1.0 0.0 ).   v := HumVector newFrom: #( 0.0 0.0 1.0 ).      s := u cross: v.   self expect: 'square meter' actual: s units.   self assert: ( s at: 1 ) quantity =  1.0.   self assert: ( s at: 2 ) quantity =  0.0.   self assert: ( s at: 3 ) quantity =  0.0.      </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; testV113VectorCrossProduct</h3><pre>testV113VectorCrossProduct   "Check the vector cross product"   | u v s |   u := HumVector newFrom: #( 0.0 1.0 0.0 ).   v := HumVector newFrom: #( 1.0 0.0 0.0 ).      s := u cross: v.   self expect: 'square meter' actual: s units.   self assert: ( s at: 1 ) quantity =  0.0.   self assert: ( s at: 2 ) quantity =  0.0.   self assert: ( s at: 3 ) quantity = -1.0.      </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; testV115VectorCrossProduct</h3><pre>testV115VectorCrossProduct   "Check the vector cross product"   | u v s |   u := HumVector newFrom: #( 5.0 0.0 0.0 ).   v := HumVector newFrom: #( 0.0 5.0 0.0 ).      s := u cross: v.   self expect: 'square meter' actual: s units.   self assert: ( s at: 1 ) quantity = 0.0.   self assert: ( s at: 2 ) quantity = 0.0.   self assert: ( s at: 3 ) quantity = 25.0.      </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; testV117VectorCrossProduct</h3><pre>testV117VectorCrossProduct   "Check the vector cross product"   | u v s |   u := HumVector newFrom: #( 5.0 2.0 0.0 ).   v := HumVector newFrom: #( 2.0 5.0 0.0 ).      s := u cross: v.   self expect: 'square meter' actual: s units.   self assert: ( s at: 1 ) quantity = 0.0.   self assert: ( s at: 2 ) quantity = 0.0.   self assert: ( s at: 3 ) quantity = 21.0.      </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; testV210IdentityVector</h3><pre>testV210IdentityVector   "Creat a identity vector I * V = V.   u * v = v.   "   | i  v |   i := HumVector identityVector.   self assert: (i dimensions size = 0). "Identity vector should be dimensionless"      v := HumVector newFrom: #( 1.1 2.2 3.3 ). "Note: Default unit of measure is 'meter'."   "Multiplication by unit vector should return same."   self expect: v actual: ( i * v ).   self expect: v actual: ( v* i ).   "Dot product should produce sum of elements."   self expect: (6.6 meter) actual: ( i dot: v ).   "Crossed with itself."   self expect: ( HumVector newFrom: #(0.0 0.0 0.0) units: #none ) actual: ( i cross: i ) .   "Dot with itself."   self expect: ( HumMeasure quantity: 3 units: #none ) actual: ( i dot: i ).               </pre><h3>Hum-Tests -- HumCalculatorTests &gt;&gt; ztest530measureTimesPercent</h3><pre>ztest530measureTimesPercent   "Percent times percent produces percent"   | m1 m2 m3 |   m1 := HumMeasure percent: 10.   m2 := HumMeasure percent: 25.   m3 :=  m2 * m1.   self expect: m3 quantity is: (0.10 * 0.25 * 100).   self expect: m3 units is: #percent.    </pre><h3>Hum-Tests -- HumCodeBaseTests &gt;&gt; test110MyPackages</h3><pre>test110MyPackages   | packageList |   packageList := HumCodeBase myPackages.   self assert: (packageList size &lt; 20).   self assert: (packageList includes: 'Hum-X').      Transcript cr; show: 'Hum package count = ', (packageList size asString).</pre><h3>Hum-Tests -- HumCodeBaseTests &gt;&gt; test120MyClasses</h3><pre>test120MyClasses   | packageList classList |   packageList := HumCodeBase myPackages.   self assert: (packageList includes: 'Hum-X').   classList := OrderedCollection new.   packageList       do: [ :package |         classList addAllLast: (HumCodeBase classesInPackage: package).         ].   self assert: ( classList size &lt;  160 ).   Transcript cr; show: 'Hum class count = ', (classList size asString).</pre><h3>Hum-Tests -- HumCodeBaseTests &gt;&gt; test130GetPackageClassTuples</h3><pre>test130GetPackageClassTuples   | packageClassTree |   packageClassTree := HumCodeBase getPackageClassTuples.   self assert: ( packageClassTree size &lt; 160 ).   self assert: ( packageClassTree anySatisfy: [ :tuple | (tuple at: 2) = (self class)] ).      Transcript cr; show: 'Hum package-class-tree count = ', (packageClassTree size asString).   "packageClassTree inspect."</pre><h3>Hum-Tests -- HumCodeBaseTests &gt;&gt; test140GetPackageClassMethodTuples</h3><pre>test140GetPackageClassMethodTuples   | packageClassMethodTree |   packageClassMethodTree := HumCodeBase getPackageClassMethodTuples.   self assert: ( packageClassMethodTree size &lt; 2400 ).   self assert: ( packageClassMethodTree anySatisfy: [ :tuple | (tuple at: 2) = (self class)] ).      self assert: ( packageClassMethodTree anySatisfy: [ :tuple | ((tuple at: 3) class )= (CompiledMethod)] ).      Transcript cr; show: 'Hum package-Class-Method count = ', ( packageClassMethodTree size asString ).</pre><h3>Hum-Tests -- HumCodeBaseTests &gt;&gt; test146CountTestModules</h3><pre>test146CountTestModules   |  nTestModules |   nTestModules := HumCodeBase countTestModules.    Transcript cr; show: 'Hum test-method count = ',  nTestModules asString.</pre><h3>Hum-Tests -- HumCodeBaseTests &gt;&gt; test147CountLongModules</h3><pre>test147CountLongModules   |  nLongModules |   nLongModules := HumCodeBase countLongModules.    Transcript cr; show: 'Hum long method count = ',  nLongModules asString, ' with more than 20 lines of code'."1 --- Twenty lines is roughly the maximum amount of code 2 ---- that can be viewed without scrolling in typical browser.34567891012345678920"</pre><h3>Hum-Tests -- HumCodeBaseTests &gt;&gt; test148CountLongModules</h3><pre>test148CountLongModules   "Count modules whose listing will exceed one page. "   |  nLongModules lineLimit |   lineLimit := 50. "one page of code"   nLongModules := HumCodeBase countLongModules: lineLimit.    Transcript cr; show: 'Hum long method count = ',  nLongModules asString, ' with more than ', lineLimit asString,' lines of code'.</pre><h3>Hum-Tests -- HumCodeBaseTests &gt;&gt; test150gatherSources</h3><pre>test150gatherSources   | packageClassMethodCode |   packageClassMethodCode := HumCodeBase getPackageClassMethodCode.   self assert: ( packageClassMethodCode size &gt; 2300 ).   self assert: ( packageClassMethodCode size &lt; 2400 ).   self assert: ( packageClassMethodCode anySatisfy: [ :tuple | (tuple at: 2) isKindOf: String ] ).      self assert: ( packageClassMethodCode anySatisfy: [ :tuple | (tuple at: 3) isKindOf: String ] ).      self assert: ( packageClassMethodCode anySatisfy: [ :tuple | (tuple at: 4) isKindOf: String ] ).</pre><h3>Hum-Tests -- HumCodeBaseTests &gt;&gt; test160LinesOfCode</h3><pre>test160LinesOfCode   | linesOfCode |   linesOfCode := HumCodeBase countLinesOfCode.   self assert: ( linesOfCode &gt;  29000 ).   self assert: ( linesOfCode &lt; 32999 ).   Transcript cr; show: 'Hum lines of code = ', (linesOfCode asString).</pre><h3>Hum-Tests -- HumCodeBaseTests &gt;&gt; test161LinesOfCodePerModule</h3><pre>test161LinesOfCodePerModule   | linesOfCode nMethods |   linesOfCode := HumCodeBase countLinesOfCode.   nMethods := (HumCodeBase getPackageClassMethodTuples) size.   Transcript cr; show: 'Average method length = ', (1.0 * linesOfCode / nMethods) rounded asString.</pre><h3>Hum-Tests -- HumCodeBaseTests &gt;&gt; test170FindToDoLines</h3><pre>test170FindToDoLines   | toDoLines |   toDoLines := HumCodeBase findToDoLines.   self assert: ( toDoLines size &gt; 300 ).   self assert: ( toDoLines size &lt; 350 ).   Transcript cr; show: 'Hum TODO lines count = ', (toDoLines size asString).</pre><h3>Hum-Tests -- HumCodeBaseTests &gt;&gt; test171FindCommentLines</h3><pre>test171FindCommentLines   | commentLines n |   commentLines := HumCodeBase findCommentLines.   n := commentLines size.   self assert: ( n &gt; 5000 ).   self assert: ( n &lt; 6000 ).   Transcript cr; show: 'Hum comment lines count = ', ( n asString ).</pre><h3>Hum-Tests -- HumCodeBaseTests &gt;&gt; test175FindAssertLines</h3><pre>test175FindAssertLines   | assertLines n |   assertLines := HumCodeBase findAssertLines.   n := assertLines size.   self assert: ( n &gt; 2400 ).   self assert: ( n &lt; 2700 ).         Transcript cr; show: 'Hum assert lines count = ', (assertLines size asString).</pre><h3>Hum-Tests -- HumCodeBaseTests &gt;&gt; test180listOnHTML</h3><pre>test180listOnHTML   | html file |   html := HumCodeBase listOnHTML.   file := FileStream forceNewFileNamed: 'HumCodeBaseListing.html'.   file nextPutAll: (html contents).   file close.</pre><h3>Hum-Tests -- HumCodeBaseTests &gt;&gt; test182listOnHTML2Lines</h3><pre>test182listOnHTML2Lines   | html file |   html := HumCodeBase listOnHTML2Lines.   file := FileStream forceNewFileNamed: 'HumCodeBaseShortListing.html'.   file nextPutAll: (html contents).   file close.</pre><h3>Hum-Tests -- HumCodeBaseTests &gt;&gt; test183listOnHTMLcomments</h3><pre>test183listOnHTMLcomments   | html file |   html := HumCodeBase listOnHTMLcomments.   file := FileStream forceNewFileNamed: 'HumCodeBaseComments.html'.   file nextPutAll: (html contents).   file close.</pre><h3>Hum-Tests -- HumFuzzyTests &gt;&gt; testF100FuzzyArithmeticReadMe</h3><pre>testF100FuzzyArithmeticReadMe   "   Spurious precision is a form of disinformation because it hides the uncertainty in the result.   Hum`s fuzzy arithmetic feature provides facilities to calculate and present the uncertainty     that is inherent in all real-world situations.      Real-world numbers represent observations.   An observation is a measurement taken at a point in time using a specific method and set of calibrated sensors.   Measurements always have limited precision and accuracy.   That means that each measurement is associated with a distribution curve. (Typically a 'bell' curve of some kind.)      The goal of Hum`s fuzzy arithmetic is to correctly represent the uncertainty involved     so that results may be stated with appropriate confidence intervals or probability curves (S-curves).   Use Cases:   . Software effort estimates tend to have distributions with long tails.   . Many measurements cannot be negative, and therefore, do not have symetric distributions.   . Simulations involve many estimates for inputs and process parameters.   . . Thus any 'result' can only be a probability distribution.    . . . Otherwise, spurious precision is a form of disinformation.   . Engineering calculations are estimates that involve many sources of uncertainty and approximation.   . . Fuzzy arithmetic provides a way of representing those spreads in the results.   . . In effect, the fuzzy arithmetic automatically provides a sensitivity analysis.   "</pre><h3>Hum-Tests -- HumFuzzyTests &gt;&gt; testF110CreateFuzzyWithDistribution</h3><pre>testF110CreateFuzzyWithDistribution   "Create a fuzzy quantity from a given distribution."   | distribution median fuzzy |   "A distribution is a Dictionary of f-&gt;p points   where p is the probability that observations will be less than or equal to f.   When the distribution is plotted mapping (f,p) to (x,y) you get an S-Curve."   distribution := Dictionary new.   distribution      at: 0.00 put: 0;      at: 0.20 put: 50;      at: 0.50 put: 100;      at: 0.80 put: 200;      at: 1.00 put: 400.   fuzzy := HumFuzzy distribution: distribution.      self assert: 100 equals: ( fuzzy median ).</pre><h3>Hum-Tests -- HumFuzzyTests &gt;&gt; testF112CheckEdgeCases</h3><pre>testF112CheckEdgeCases   "Create a fuzzy quantity from a given distribution."   | distribution median fuzzy |   "A distribution is a Dictionary of f-&gt;p points   where p is the probability that observations will be less than or equal to f.   When the distribution is plotted mapping (f,p) to (x,y) you get an S-Curve."   distribution := Dictionary new.   distribution      at: 0.00 put: 0;      at: 0.50 put: 100;      at: 0.20 put: 50;      at: 0.80 put: 200;      at: 1.00 put: 400.   fuzzy := HumFuzzy distribution: distribution.      self assert: 100 equals: ( fuzzy median ).   self assert: 0 equals: ( fuzzy atP: 0.0 ).   self assert: 400 equals: ( fuzzy atP: 1.00 ).</pre><h3>Hum-Tests -- HumFuzzyTests &gt;&gt; testF120Interpolation</h3><pre>testF120Interpolation   "Create a fuzzy quantity from a given distribution."   | distribution median fuzzy |   "A distribution is a Dictionary of p-&gt;f points   where p is the probability that observations will be less than or equal to f.   When the distribution is plotted     by mapping p-&gt;f to (f,p) = (x,y),    you get an S-Curve."   distribution := Dictionary new.   distribution      at: 0.50 put: 100;  "Estimate 100 hours"      at: 0.00 put: 0;    "Cannot be less than zero"        at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."      at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."      at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."   fuzzy := HumFuzzy distribution: distribution.      self assert: 100 equals: ( fuzzy median ).   "Should be able to return given point value."   self assert: 100 equals: ( fuzzy atP: 0.50 ).     "Force interpolation"   self assert: ( ( fuzzy atP: 0.70 ) closeTo: 150.0 ).   self assert: ( ( fuzzy atP: 0.05 ) closeTo:  25.0 ).   self assert: ( ( fuzzy atP: 0.95 ) closeTo: 300.0 ).      </pre><h3>Hum-Tests -- HumFuzzyTests &gt;&gt; testF125Mean</h3><pre>testF125Mean   "Create a fuzzy quantity from a given distribution."   | distribution median fuzzy average |   "A distribution is a Dictionary of p-&gt;f points   where p is the probability that observations will be less than or equal to f.   When the distribution is plotted     by mapping p-&gt;f to (f,p) = (x,y),    you get an S-Curve."   distribution := Dictionary new.   distribution      at: 0.50 put: 100;  "Estimate 100 hours"      at: 0.00 put: 0;    "Cannot be less than zero"        at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."      at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."      at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."   fuzzy := HumFuzzy distribution: distribution.      self assert: 100 equals: ( fuzzy median ).   "Calculate mean"   average := fuzzy mean.   "the mean will be higher than the median because of long tail"   self assert: ( average &gt; ( fuzzy median ) ).         </pre><h3>Hum-Tests -- HumFuzzyTests &gt;&gt; testF130Plus</h3><pre>testF130Plus   "Add fuzzy distributions.   NOTE: The test assertions will fail occasionally. "   | distributionA distributionB median fuzzyA fuzzyB fuzzyC resultMedian expectedMedian  expectedMean actualMean diffMean diffMedian |   "A distribution is a Dictionary of p-&gt;f points   where p is the probability that observations will be less than or equal to f.   When the distribution is plotted     by mapping p-&gt;f to (f,p) = (x,y),    you get an S-Curve."   distributionA := Dictionary new.   distributionA      at: 0.50 put: 100;  "Estimate 100 hours"      at: 0.00 put: 0;    "Cannot be less than zero"        at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."      at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."      at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."   distributionB := distributionA.   fuzzyA := HumFuzzy distribution: distributionA.   fuzzyB := HumFuzzy distribution: distributionB.   fuzzyC := fuzzyA + fuzzyB.      resultMedian := fuzzyC median.   " Niave median is just . . . "   expectedMedian := (( fuzzyA median) + fuzzyB median).    " But, because there is a long tail . . . "   self assert: ( resultMedian &gt; expectedMedian ).   diffMedian := ( resultMedian - expectedMedian ) abs.   self assert:( diffMedian &gt; ((expectedMedian) * 0.10) ).      "Examine expectedMean"   actualMean := fuzzyC mean.   expectedMean := ( fuzzyA mean ) + ( fuzzyB mean ).   diffMean := 1.00 - (( expectedMean / actualMean ) abs).   "Expect some difference due to long tail."   self assert: ( diffMean closeTo: 0.0 ) not.    "The difference is typically about 3 to 4%; but is occasionally greater than 5%."   self assert: ( diffMean &lt;  0.05 ).   "Transcript cr; show: 'testF130Plus diffMean = ', ( diffMean asString)."         </pre><h3>Hum-Tests -- HumFuzzyTests &gt;&gt; testF140Op</h3><pre>testF140Op   "Test op:with:"   | distributionA distributionB median fuzzyA fuzzyB fuzzyC resultMedian expectedMedian diff plus |   "A distribution is a Dictionary of p-&gt;f points   where p is the probability that observations will be less than or equal to f.   When the distribution is plotted     by mapping p-&gt;f to (f,p) = (x,y),    you get an S-Curve."   distributionA := Dictionary new.   distributionA      at: 0.50 put: 100;  "Estimate 100 hours"      at: 0.00 put: 0;    "Cannot be less than zero"        at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."      at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."      at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."   distributionB := distributionA.   fuzzyA := HumFuzzy distribution: distributionA.   fuzzyB := HumFuzzy distribution: distributionB.   plus := #+.   fuzzyC := fuzzyA op: plus with: fuzzyB.      resultMedian := fuzzyC median.   " Niave median is just . . . "   expectedMedian := (( fuzzyA median) + fuzzyB median).    " But, because there is a long tail . . . "   self assert: ( resultMedian &gt; expectedMedian ).   diff := ( resultMedian - expectedMedian ) abs.   self assert:( diff &gt; ((expectedMedian) * 0.10) ).   </pre><h3>Hum-Tests -- HumFuzzyTests &gt;&gt; testF150MinusOp</h3><pre>testF150MinusOp   "Subtract fuzzy distributions."   | distributionA distributionB median fuzzyA fuzzyB fuzzyC resultMedian expectedMedian diff  minus |   "A distribution is a Dictionary of p-&gt;f points   where p is the probability that observations will be less than or equal to f.   When the distribution is plotted     by mapping p-&gt;f to (f,p) = (x,y),    you get an S-Curve."   distributionA := Dictionary new.   distributionB := Dictionary new.   distributionA      at: 0.50 put: 200;  "Estimate 200 hours"      at: 0.00 put: 0;    "Cannot be less than zero"        at: 0.10 put: 100;   "Will come at less than half the estimate no more than 10% of time."      at: 0.90 put: 400;  "Will come at upto double the estimate no more than 90% of time."      at: 1.00 put: 800.  "At worst, the actual will be 4 times the estimate."   distributionB      at: 0.50 put: 100;  "Estimate 100 hours"      at: 0.00 put: 0;    "Cannot be less than zero"        at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."      at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."      at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."   fuzzyA := HumFuzzy distribution: distributionA.   fuzzyB := HumFuzzy distribution: distributionB.   minus := #-.   fuzzyC := fuzzyA op: minus with: fuzzyB.      resultMedian := fuzzyC median.   " Niave median is just . . . "   expectedMedian := (( fuzzyB median) - fuzzyA median).    " But, because there is a long tail . . . "   self assert: ( resultMedian &gt; expectedMedian ).   diff := ( resultMedian - expectedMedian ) abs.   self assert:( diff &gt; ((expectedMedian) * 0.10) ).   </pre><h3>Hum-Tests -- HumFuzzyTests &gt;&gt; testF155Minus</h3><pre>testF155Minus   "Subtract fuzzy distributions."   | distributionA distributionB median fuzzyA fuzzyB fuzzyC resultMedian expectedMedian diffMedian  minus actualMean expectedMean diffMean |   "A distribution is a Dictionary of p-&gt;f points   where p is the probability that observations will be less than or equal to f.   When the distribution is plotted     by mapping p-&gt;f to (f,p) = (x,y),    you get an S-Curve."   distributionA := Dictionary new.   distributionB := Dictionary new.   distributionA      at: 0.50 put: 200;  "Estimate 200 hours"      at: 0.00 put: 0;    "Cannot be less than zero"        at: 0.10 put: 100;   "Will come at less than half the estimate no more than 10% of time."      at: 0.90 put: 400;  "Will come at upto double the estimate no more than 90% of time."      at: 1.00 put: 800.  "At worst, the actual will be 4 times the estimate."   distributionB      at: 0.50 put: 100;  "Estimate 100 hours"      at: 0.00 put: 0;    "Cannot be less than zero"        at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."      at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."      at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."   fuzzyA := HumFuzzy distribution: distributionA.   fuzzyB := HumFuzzy distribution: distributionB.   minus := #-.   fuzzyC := fuzzyA - fuzzyB.      resultMedian := fuzzyC median.   " Niave median is just . . . "   expectedMedian := (( fuzzyA median) - (fuzzyB median) ).    " But, because there is a long tail . . . "   diffMedian := ( resultMedian - expectedMedian ) abs.   "NOTE: Following will fail occasionally."   self assert: ( diffMedian closeTo: 0.0 ) not.         "Examine expectedMean"   actualMean := fuzzyC mean.   expectedMean := ( fuzzyA mean ) - ( fuzzyB mean ).   diffMean := ( expectedMean - actualMean ) abs.   "The difference will typically be on the order of 5-15%"   "It could be close to zero, but that will be a rare event."   self assert: ( diffMean closeTo: 0.0 ) not.       </pre><h3>Hum-Tests -- HumFuzzyTests &gt;&gt; testF160Division</h3><pre>testF160Division   "Divide fuzzy distributions."   | distributionA distributionB median fuzzyA fuzzyB fuzzyC resultMedian expectedMedian diff   diffMedian actualMean expectedMean diffMean |   "A distribution is a Dictionary of p-&gt;f points   where p is the probability that observations will be less than or equal to f.   When the distribution is plotted     by mapping p-&gt;f to (f,p) = (x,y),    you get an S-Curve."   distributionA := Dictionary new.   distributionB := Dictionary new.   distributionA      at: 0.50 put: 200;  "Estimate 200 hours"      at: 0.00 put: 0;    "Cannot be less than zero"        at: 0.10 put: 100;   "Will come at less than half the estimate no more than 10% of time."      at: 0.90 put: 400;  "Will come at upto double the estimate no more than 90% of time."      at: 1.00 put: 800.  "At worst, the actual will be 4 times the estimate."   distributionB      at: 0.50 put: 100;  "Estimate 100 hours"      at: 0.00 put: 0;    "Cannot be less than zero"        at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."      at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."      at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."   fuzzyA := HumFuzzy distribution: distributionA.   fuzzyB := HumFuzzy distribution: distributionB.   fuzzyC := fuzzyA / fuzzyB.      resultMedian := fuzzyC median.   " Niave median is just . . . "   expectedMedian := (( fuzzyA median) / (fuzzyB median) ).    " But, because there is a long tail . . . "   diffMedian := ( resultMedian - expectedMedian ) abs.   "NOTE: Following will fail occasionally."   self assert: ( diffMedian closeTo: 0.0 ) not.         "Examine expectedMean"   actualMean := fuzzyC mean.   expectedMean := ( fuzzyA mean ) / ( fuzzyB mean ).   diffMean := ( expectedMean - actualMean ) abs.   "The difference will typically be on the order of 5-15%"   "It could be close to zero, but that will be a rare event."   self assert: ( diffMean closeTo: 0.0 ) not. </pre><h3>Hum-Tests -- HumFuzzyTests &gt;&gt; testF170Product</h3><pre>testF170Product   "Multiply fuzzy distributions."   | distributionA distributionB  fuzzyA fuzzyB fuzzyC resultMedian expectedMedian    diffMedian actualMean expectedMean diffMean |   "A distribution is a Dictionary of p-&gt;f points   where p is the probability that observations will be less than or equal to f.   When the distribution is plotted     by mapping p-&gt;f to (f,p) = (x,y),    you get an S-Curve."   distributionA := Dictionary new.   distributionB := Dictionary new.   distributionA      at: 0.50 put: 200;  "Estimate 200 hours"      at: 0.00 put: 0;    "Cannot be less than zero"        at: 0.10 put: 100;   "Will come at less than half the estimate no more than 10% of time."      at: 0.90 put: 400;  "Will come at upto double the estimate no more than 90% of time."      at: 1.00 put: 800.  "At worst, the actual will be 4 times the estimate."   distributionB      at: 0.50 put: 100;  "Estimate 100 hours"      at: 0.00 put: 0;    "Cannot be less than zero"        at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."      at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."      at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."   fuzzyA := HumFuzzy distribution: distributionA.   fuzzyB := HumFuzzy distribution: distributionB.   fuzzyC := fuzzyA * fuzzyB.         resultMedian := fuzzyC median.   " Niave median is just . . . "   expectedMedian := (( fuzzyA median) * (fuzzyB median) ).    " But, because there is a long tail . . . "   diffMedian := ( resultMedian - expectedMedian ) abs.   "NOTE: Following will fail occasionally."   self assert: ( diffMedian closeTo: 0.0 ) not.         "Examine expectedMean"   actualMean := fuzzyC mean.   expectedMean := ( fuzzyA mean ) * ( fuzzyB mean ).   diffMean := 1.00 - (( expectedMean - actualMean ) abs).   "The difference will typically be less than 3%"   "It could be close to zero, but that will be a rare event."   self assert: ( diffMean closeTo: 0.0 ) not.    self assert: ( diffMean &lt; 0.03 ).   </pre><h3>Hum-Tests -- HumFuzzyTests &gt;&gt; testF210PlusOrMinus</h3><pre>testF210PlusOrMinus   "A measure stated as plus-or-minus     is assumed to exclude cases outside the limits."   | measure sampleMean sampleMedian |   measure := HumFuzzy quantity: 100 plusOrMinus: 1.   "Use Float #closeto: "   sampleMean := measure mean.   sampleMedian := measure median.   "Note: Following will fail occasionally."   self assert: ( sampleMean closeTo: 100.0 ) description: 'This sampleMean value will deviate now and then'.    self assert: ( sampleMedian closeTo: 100.0 ) description: 'This sampleMedian value will deviate now and then'.      </pre><h3>Hum-Tests -- HumFuzzyTests &gt;&gt; testF230Plus</h3><pre>testF230Plus   "Add fuzzy distributions."   |    fuzzyA fuzzyB fuzzyC resultMedian expectedMedian  expectedMean actualMean diffMean diffMedian |   "A distribution is a Dictionary of p-&gt;f points   where p is the probability that observations will be less than or equal to f.   When the distribution is plotted     by mapping p-&gt;f to (f,p) = (x,y),    you get an S-Curve."   fuzzyA := HumFuzzy quantity: 100.0 plusOrMinus: 1.0.   fuzzyB := HumFuzzy quantity: 100.0 plusOrMinus: 1.0.   fuzzyC := fuzzyA + fuzzyB.      resultMedian := fuzzyC median.   " Niave median is just . . . "   expectedMedian := (( fuzzyA median) + fuzzyB median).    " In this case, the tail is not long. "   diffMedian := 1.00 - ( resultMedian / expectedMedian ) abs.   self assert:( diffMedian &lt; 0.01 ).      "Examine expectedMean"   actualMean := fuzzyC mean.   expectedMean := ( fuzzyA mean ) + ( fuzzyB mean ).   diffMean := 1.00 - (( expectedMean / actualMean ) abs).   "The difference is typically less than 1% "   self assert: ( diffMean &lt;  0.01 ).   "Transcript cr; show: 'testF230Plus diffMean = ', ( diffMean asString)."         </pre><h3>Hum-Tests -- HumFuzzyTests &gt;&gt; testF310Mode</h3><pre>testF310Mode   "Estimate the mode of a distribution by calculating expected value."   | mode distribution fuzzy sum mean expected |   distribution := Dictionary new.   distribution      at: 0.00 put: 0;      at: 0.20 put: 50;      at: 0.50 put: 100;      at: 0.80 put: 200;      at: 1.00 put: 400.   fuzzy := HumFuzzy distribution: distribution.   sum := 0.   fuzzy distributionDo: [:p :v | sum := sum + (p*v)].   mode := sum.   expected := ((20*50)+(50*100)+(80*200)+(100*400))/100.    self expect: expected actual: mode.   </pre><h3>Hum-Tests -- HumFuzzyTests &gt;&gt; testF410Plot</h3><pre>testF410Plot   "Estimate the mode of a distribution by calculating expected value."   | distribution fuzzy   canvas scaleX scaleY extent magnifyBy scalePt priorPt vMax |   distribution := Dictionary new.   distribution      at: 0.00 put: 0;      at: 0.20 put: 50;      at: 0.50 put: 100;      at: 0.80 put: 200;      at: 1.00 put: 400.   fuzzy := HumFuzzy distribution: distribution.   false ifTrue: [ fuzzy asCrudeMorph ].   </pre><h3>Hum-Tests -- HumFuzzyTests &gt;&gt; testF430PlotPlus</h3><pre>testF430PlotPlus   "Add fuzzy distributions.   NOTE: The test assertions will fail occasionally. "   | distributionA distributionB  fuzzyA fuzzyB fuzzyC  |   "A distribution is a Dictionary of p-&gt;f points   where p is the probability that observations will be less than or equal to f.   When the distribution is plotted     by mapping p-&gt;f to (f,p) = (x,y),    you get an S-Curve."   distributionA := Dictionary new.   distributionA      at: 0.50 put: 100;  "Estimate 100 hours"      at: 0.00 put: 0;    "Cannot be less than zero"        at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."      at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."      at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."   distributionB := distributionA.   fuzzyA := HumFuzzy distribution: distributionA.   fuzzyB := HumFuzzy distribution: distributionB.   fuzzyC := fuzzyA + fuzzyB.   false ifTrue: [ fuzzyC asCrudeMorph2 ].            </pre><h3>Hum-Tests -- HumFuzzyTests &gt;&gt; testF431PlotPlus</h3><pre>testF431PlotPlus   "Add fuzzy distributions.   NOTE: The test assertions will fail occasionally. "   | distributionA distributionB fuzzyA fuzzyB fuzzyC  |   "A distribution is a Dictionary of p-&gt;f points   where p is the probability that observations will be less than or equal to f.   When the distribution is plotted     by mapping p-&gt;f to (f,p) = (x,y),    you get an S-Curve."   distributionA := Dictionary new.   distributionA      at: 0.50 put: 100;  "Estimate 100 hours"      at: 0.00 put: 0;    "Cannot be less than zero"        at: 0.10 put: 50;   "Will come at less than half the estimate no more than 10% of time."      at: 0.90 put: 200;  "Will come at upto double the estimate no more than 90% of time."      at: 1.00 put: 400.  "At worst, the actual will be 4 times the estimate."   distributionB := distributionA.   fuzzyA := HumFuzzy distribution: distributionA.   fuzzyB := HumFuzzy distribution: distributionB.   fuzzyC := fuzzyA + fuzzyB.   false ifTrue: [ fuzzyC asCrudeMorphInRectangle: (Rectangle origin: 111@222 extent: 500@500) ]               </pre><h3>Hum-Tests -- HumFuzzyTests &gt;&gt; ztestF410LearnToPlot</h3><pre>ztestF410LearnToPlot   "Estimate the mode of a distribution by calculating expected value."   | distribution fuzzy   canvas scaleX scaleY extent magnifyBy scalePt priorPt vMax |   distribution := Dictionary new.   distribution      at: 0.00 put: 0;      at: 0.20 put: 50;      at: 0.50 put: 100;      at: 0.80 put: 200;      at: 1.00 put: 400.   fuzzy := HumFuzzy distribution: distribution.      magnifyBy := 2.   scaleX := [:v | v*magnifyBy].   scaleY := [:p | (100 - (100*p))*magnifyBy ]. "Flip Y. Screen coordinates have Y pointing down."   scalePt := [:pt | (scaleX value: (pt x))@(scaleY value: (pt y)) ].   vMax := distribution at: 1.0.   extent := ( scalePt value: (vMax@0.0) )* 1.1.      priorPt := scalePt value: 0.0@0.0.   canvas := FormCanvas extent: extent depth: 32 origin: (10@10) clipRect: (Rectangle origin: 0@0 extent: extent).     canvas fillColor: Color blue muchLighter.      "verticle grid"      (0.0 to: vMax by: 100.0)         do: [:v | canvas line: (scalePt value: v@0.0) to: (scalePt value: v@1.0) width: 1 color: Color green].     "horizontal grid"      (0.0 to: 1.0 by: 0.1)         do:[:p | canvas line: (scalePt value: 0.0@p) to: (scalePt value: vMax@p) width: 1 color: Color green].      (0.0 to: 1.0 by: 0.5)         do:[:p | canvas line: (scalePt value: 0.0@p) to: (scalePt value: vMax@p) width: 2 color: Color green].      fuzzy distributionDo:       [:p :v |       | xy |       xy := scalePt value: v@p.      canvas line: priorPt to: xy width: 4 color: Color red.      priorPt := xy.      ].   "Should we display the canvas?"   false ifTrue: [| morph |       morph := canvas form asMorph openInWorld.       "You can delete morph by double-clicking it."      morph on: #doubleClick send: #delete to: morph.       ].   </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test001newOntology</h3><pre>test001newOntology   "create a new Ontology"   | ontology |   ontology := HumOntology new.   self assert: ( ontology nouns) isEmpty.   self assert: ( ontology roles) isEmpty.      </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test100nounTypes</h3><pre>test100nounTypes   "An entity noun will have attributes."   "A category noun will have categories."   "An entity noun may have supertypes and/or subtypes."   "A plural noun indicates a list or set or bag collection. By default, it indicates a set."   "A noun may have a synonym. "   self skip.</pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test102addOneNoun</h3><pre>test102addOneNoun   "Add one noun to current set."   | ontology |   ontology := HumOntology new.   ontology addNoun: 'location'.   self assert: ( (ontology nouns) includes: 'location' ).</pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test103addTwoNouns</h3><pre>test103addTwoNouns   "Add two nouns to current set."   | ontology |   ontology := HumOntology new.   "Add first noun."   ontology addNoun: 'location'.   self assert: ( (ontology nouns) includes: 'location' ).   "Add second noun."   ontology addNoun: 'place'.   self assert: ( (ontology nouns) includes: 'place' ).   "Make sure we did not overlay original"   self assert: ( (ontology nouns) includes: 'location' ).  </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test104addArrayOfNouns</h3><pre>test104addArrayOfNouns   "Add array of nouns to current set."   | ontology nounSet |   ontology := HumOntology new.   "Add one noun."   ontology addNoun: 'location'.   self assert: ( (ontology nouns) includes: 'location' ).      "Add from array."   ontology addNouns: #( 'place-1' 'place-2' 'place-3' ).   self assert: ( (ontology nouns) includes: 'place-3').   self assert: ( (ontology nouns) includes: 'location'). "Make sure we did not overlay original"   "Add from set."   nounSet := Set new.   nounSet add: 'first-location'.   nounSet add: 'second-location'.   nounSet add: 'third-location'.   ontology addNouns: nounSet.   self assert: ( (ontology nouns) includes: 'third-location').   self assert: ( (ontology nouns) includes: 'location').   "Make sure we did not overlay original"   </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test110addEntityAttribute</h3><pre>test110addEntityAttribute   "Add an entity-attribute relation."   | ontology  attributes |   ontology := HumOntology new.   "Add noun."   ontology addNoun: 'location'.   self assert: ( (ontology nouns) includes: 'location' ).   "Add entity-attribute relation."   ontology addEntity: 'location' attribute: 'GPS'.   "Test"   attributes := ontology immediateAttributesOfEntity: 'location'.   self assert: ( attributes include: 'GPS' asLowercase ).         "Add a second entity-attribute relation."   ontology addEntity: 'location' attribute: 'location-name'.   "Test"   attributes := ontology immediateAttributesOfEntity: 'location'.   self assert: ( attributes include: 'location-name' ).   self assert: ( attributes include: 'GPS' asLowercase ).      </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test111getAllAttributesOfNoun</h3><pre>test111getAllAttributesOfNoun   "Add an is-A relation."   | ontology allAttributes |   ontology := HumOntology new.   "Define a few relations."   ontology addEntity: 'party' attributes: #(  'name' 'alphabetized-name' 'address'  ).   ontology addEntity: 'address' attributes: #( 'street-direction' 'street-number' 'street-name' 'postal-code' ).   ontology addEntity: 'postal-code' attributes: #( 'city' 'state-province' 'nation' ).   ontology addNoun: 'person' isA: 'party'.   ontology addEntity: 'person' attributes: #( 'primary-phone-number'   ).   ontology addNoun: 'contact' isA: 'person'.   ontology addNoun: 'organization' isA: 'party'.      "The attrbutes include both the supertypes and the attributes of the supertypes."   "THINK -- Is this what we want?  What will we do with the supertypes?"   allAttributes := ontology allAttributesOfEntity: 'contact'.   self assert: ( allAttributes size ) = 11.   "   Transcript cr; show: 'test111getAllAttributesOfNoun -- Attributes of contact:'; cr; show: allAttributes; cr.   "               </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test120addSubtype</h3><pre>test120addSubtype   "Add an is-A relation."   | ontology subtypes |   ontology := HumOntology new.   "Add noun."   ontology addNoun: 'location'.   self assert: ( (ontology nouns) includes: 'location' ).   "Add is-A relation."   ontology addNoun: 'residence' isA: 'location'.   "Test isKindOf"   self assert: ( ontology yesNoun: 'residence' isAKindOf: 'location').   "Test subtypes"   subtypes := ontology immediateSubtypesOf: 'location'.   self assert: ( subtypes isKindOf: Set).   self assert: ( ( ontology immediateSubtypesOf: 'location') includes: 'residence').</pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test121automaticSubtype</h3><pre>test121automaticSubtype   "Add an is-A relation."   | ontology |   ontology := HumOntology new.   "Add noun."   ontology addEntity: 'location' attributes: #('latitude' 'longitude').   self assert: ( (ontology nouns) includes: 'location' ).   "Add an automatic subtype."   ontology addNoun: 'store-location'.   "Test isKindOf"   self assert: ( ontology yesNoun: 'store-location' isAKindOf: 'location').   "Test subtypes"   self assert: ( ( ontology immediateSubtypesOf: 'location') includes: 'store-location').</pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test122getAllSubtypesOfNoun</h3><pre>test122getAllSubtypesOfNoun   "Get all subtypes of a noun -- Use at run-time for polymorphism."   | ontology immediateSubtypes allSubtypes |   ontology := HumOntology new.   "Add a few subtype-supertype relations."   ontology addNoun: 'person' isA: 'party'.   ontology addNoun: 'organization' isA: 'party'.   ontology addNoun: 'worker' isA: 'person'.      ontology addNoun: 'employee' isA: 'worker'.   ontology addNoun: 'contractor' isA: 'worker'.   ontology addNoun: 'consultant' isA: 'worker'.      ontology addNoun: 'vendor' isA: 'organization'.   ontology addNoun: 'supplier' isA: 'vendor'.      immediateSubtypes := ontology immediateSubtypesOf: 'party'.   "Party has two subtypes (person, organization)."   self assert: ( immediateSubtypes size ) = 2.      "Party has 8 subtypes in the whole subtype tree. "   allSubtypes := ontology allSubtypesOf: 'party'.   self assert: ( allSubtypes size ) = 8.   "Transcript show: allSubtypes asSortedCollection; cr."               </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test123getImmediateSupertypesOfNoun</h3><pre>test123getImmediateSupertypesOfNoun   "Get immediate super types of a noun -- Use when translating to another language ."   | ontology immediateSupertypes |   ontology := HumOntology new.   "Add a few subtype-supertype relations."   ontology addNoun: 'person' isA: 'party'.   ontology addNoun: 'organization' isA: 'party'.   ontology addNoun: 'worker' isA: 'person'.      ontology addNoun: 'employee' isA: 'worker'.   ontology addNoun: 'contractor' isA: 'worker'.      ontology addNoun: 'self-employed-consultant' isA: 'worker'.   ontology addNoun: 'self-employed-consultant' isA: 'vendor'.  "Test multiple inheritance case."      ontology addNoun: 'vendor' isA: 'organization'.   ontology addNoun: 'supplier' isA: 'vendor'.      immediateSupertypes := ontology immediateSupertypesOf:  'vendor'.   "Vendor has one immediate supertype: Vendor is an organization."   self assert: ( immediateSupertypes size ) = 1.      immediateSupertypes := ontology immediateSupertypesOf:  'supplier'.   "Supplier has one immediate supertype: Supplier is a vendor."   self assert: ( immediateSupertypes size ) = 1.      immediateSupertypes := ontology immediateSupertypesOf:  'employee'.   "Employee has one immediate supertype: Employee is a worker.."   self assert: ( immediateSupertypes size ) = 1.      immediateSupertypes := ontology immediateSupertypesOf:  'worker'.   "Worker has one immediate supertype: Worker is a party."   self assert: ( immediateSupertypes size ) = 1.      immediateSupertypes := ontology immediateSupertypesOf:  'person'.   "Party has two subtypes (person, organization)."   self assert: ( immediateSupertypes size ) = 1.      immediateSupertypes := ontology immediateSupertypesOf:  'party'.   "Party has no supertypes in this ontology."   self assert: ( immediateSupertypes size ) = 0.      immediateSupertypes := ontology immediateSupertypesOf:  'self-employed-consultant'.   "Self-employed-constulant has two immediate supertypes:    Self-employed-consultant is a worker, and also a vendor."   self assert: ( immediateSupertypes size ) = 2.                  </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test124getAllSupertypesOfNoun</h3><pre>test124getAllSupertypesOfNoun   "Get immediate super types of a noun -- Use when translating to another language ."   | ontology immediateSupertypes allSupertypes |   ontology := HumOntology new.   "Add a few subtype-supertype relations."   ontology addNoun: 'person' isA: 'party'.   ontology addNoun: 'organization' isA: 'party'.   ontology addNoun: 'worker' isA: 'person'.      ontology addNoun: 'employee' isA: 'worker'.   ontology addNoun: 'contractor' isA: 'worker'.      ontology addNoun: 'self-employed-consultant' isA: 'worker'.   ontology addNoun: 'self-employed-consultant' isA: 'vendor'.  "Test multiple inheritance case."      ontology addNoun: 'vendor' isA: 'organization'.   ontology addNoun: 'supplier' isA: 'vendor'.      immediateSupertypes := ontology immediateSupertypesOf:  'vendor'.   "Vendor has one immediate supertype: Vendor is an organization."   self assert: ( immediateSupertypes size ) = 1.      immediateSupertypes := ontology immediateSupertypesOf:  'supplier'.   "Supplier has one immediate supertype: Supplier is a vendor."   self assert: ( immediateSupertypes size ) = 1.      immediateSupertypes := ontology immediateSupertypesOf:  'employee'.   "Employee has one immediate supertype: Employee is a worker.."   self assert: ( immediateSupertypes size ) = 1.      immediateSupertypes := ontology immediateSupertypesOf:  'worker'.   "Worker has one immediate supertype: Worker is a party."   self assert: ( immediateSupertypes size ) = 1.      immediateSupertypes := ontology immediateSupertypesOf:  'person'.   "Party has two subtypes (person, organization)."   self assert: ( immediateSupertypes size ) = 1.      immediateSupertypes := ontology immediateSupertypesOf:  'party'.   "Party has no supertypes in this ontology."   self assert: ( immediateSupertypes size ) = 0.      immediateSupertypes := ontology immediateSupertypesOf:  'self-employed-consultant'.   "Self-employed-constulant has two immediate supertypes:    Self-employed-consultant is a worker, and also a vendor."   self assert: ( immediateSupertypes size ) = 2.      allSupertypes := ontology allSupertypesOf: 'self-employed-consultant'.   "consultant &gt; worker &gt; person &gt; party; also: consultant &gt; vendor &gt; organization &gt; party"   self assert: ( allSupertypes size ) equals: 5.                  </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test130getSingularFormOfPluralNoun</h3><pre>test130getSingularFormOfPluralNoun   "Return the singular form of a plural noun."   | nouns ontology |   ontology := HumOntology new.   nouns := #( 'regions' 'territories' 'monkeys' 'dresses' 'trees' 'commodores' 'flakes' 'cases' ).   ontology addNouns: nouns.   nouns do: [ :plural |      | singular |      singular := ontology singularFormOfNoun: plural.      self deny: ( singular = plural ).       ].   self expect: 'region' actual: (ontology singularFormOfNoun: 'regions').   self expect: 'territory' actual: (ontology singularFormOfNoun: 'territories').   self expect: 'monkey' actual: (ontology singularFormOfNoun: 'monkeys').   self expect: 'dress' actual: (ontology singularFormOfNoun: 'dresses').   self expect: 'commodore' actual: (ontology singularFormOfNoun: 'commodores').   self expect: 'tree' actual: (ontology singularFormOfNoun: 'trees').   self expect: 'flake' actual: (ontology singularFormOfNoun: 'flakes').   self expect: 'case' actual: (ontology singularFormOfNoun: 'cases').   self expect: 'toe' actual: (ontology singularFormOfNoun: 'toes').   self expect: 'house' actual: (ontology singularFormOfNoun: 'houses').   "If the plural is the same as the singular form, there is no problem - We luck out."   self expect: 'deer' actual: (ontology singularFormOfNoun: 'deer').   self expect: 'moose' actual: (ontology singularFormOfNoun: 'moose').   self expect: 'sheep' actual: (ontology singularFormOfNoun: 'sheep').   "Currently there is no way to declare irregular nouns in Hum."   self deny: ('goose' = (ontology singularFormOfNoun: 'geese') ).   self deny: ('mouse' = (ontology singularFormOfNoun: 'mice') ).            "Special cases that currently fail:"      </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test220addOneRole</h3><pre>test220addOneRole   "Add one role to current set."   | ontology |   ontology := HumOntology new.   ontology addRole: 'Mover'.   self assert: ( (ontology roles) includes: 'Mover' ).</pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test230addTwoRoles</h3><pre>test230addTwoRoles   "Add two roles  to current set."   | ontology |   ontology := HumOntology new.   "Add first role."   ontology addRole: 'Mover'.   self assert: ( (ontology roles) includes: 'Mover' ).   "Add second role."   ontology addRole: 'Shaker'.   self assert: ( (ontology roles) includes: 'Shaker' ).   "Make sure we did not overlay original"   self assert: ( (ontology roles) includes: 'Mover' ).  </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test310statementTokens</h3><pre>test310statementTokens   "A statement is made up of tokens."   | tokens statement |   "Make a statement and get its tokens."   statement := HumStatement from: 'Now, this is the time for all good men to come to the aid of their country.'.   tokens := statement tokens.   "Tokens are in an ordered collection (array-like)."   self assert: ( tokens at: 6 ) = 'time'.    "Tokens are converted to lower case."   self assert: ( tokens includes: 'now' ).    "Tokens include punctuation."   self assert: ( tokens includes: ',' ).   self assert: ( tokens includes: '.' ).      </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test320statementEndsWithPeriodOrColon</h3><pre>test320statementEndsWithPeriodOrColon   "A statement must end with a period or a colon."   | statement |   statement := HumStatement new.      "A statement ending in a period should not raise an error."   statement source: 'This ends with a period.'.   self assert: ( statement errors ) isEmpty.       "A statement ending in a colon should not raise an error."   statement source: 'For each token in statement tokens:'.
   self assert: ( statement errors ) isEmpty.       "A statement not ending in a colon or period should raise an error."   statement source: 'This source statement is missing an ending period'.   self assert: ( statement errors ) isEmpty not.   "Transcript show: statement errors; cr."   </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test330statementHasNouns</h3><pre>test330statementHasNouns   "A statement has nouns."   | statement role ontology statementNouns |   ontology := HumOntology new.   statement := HumStatement from: 'Move thing from current-location to new-location.'.   role := 'Mover'.   ontology indexRole: role action: statement.      "The nouns might be defined after the statement is defined. "   ontology addNouns: #( 'thing' 'location' 'current-location' 'new-location' ).      "(Nouns are not completely bound until compile time.)"   statementNouns := ontology nounsInStatement: statement.   self assert: (statementNouns include: 'thing').   self assert: (statementNouns include: 'current-location').   self assert: (statementNouns include: 'new-location').   self expect: 3 actual: (statementNouns size).         </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test340statementParsing</h3><pre>test340statementParsing   "The parser recognizes that tokens are nouns, punctuation, keywords, or just words."   | statement role ontology statementNouns tokenTypes |   ontology := HumOntology new.   statement := HumStatement from: 'Add incoming-count to stock-count, giving updated-stock-count.'.   role := 'Calc'.   ontology indexRole: role action: statement.      "The nouns might be defined after the statement is defined. "   ontology addNouns: #( 'count' 'incoming-count' 'stock-count' 'updated-stock-count' ).      "(Nouns are not completely bound until compile time.)"   statementNouns := ontology nounsInStatement: statement.   self assert: (statementNouns include: 'incoming-count').   self assert: (statementNouns include: 'stock-count').   self assert: (statementNouns include: 'updated-stock-count').      "Get tokenTypes."   tokenTypes := ontology parseStatement: statement triggerWords: #( 'if' 'else' 'giving' 'for-each' ) keywords: #( 'each' 'giving' ).   "Check nouns."   self assert: ( tokenTypes include: ( 'incoming-count' -&gt; #noun ) ).   self assert: ( tokenTypes include: ( 'stock-count' -&gt; #noun ) ).   self assert: ( tokenTypes include: ( 'updated-stock-count' -&gt; #noun ) ).   "Check keywords."   self assert: ( tokenTypes include: ( 'giving' -&gt; #keyword ) ).   "Check punctuation."   self assert: ( tokenTypes include: ( ',' -&gt; #punctuation ) ).   "Add is only another word.  -- Verbs are not special."   self assert: ( tokenTypes include: ( 'Add' -&gt; #word ) ).   "The word 'to' is only another word. -- Prepositions are not special."   self assert: ( tokenTypes include: ( 'to' -&gt; #word ) ).         </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test342statementParsingConsolidatesStrings</h3><pre>test342statementParsingConsolidatesStrings   "A string is delimited by double quotes."   |   |    Transcript show: 'TODO: test342statementParsingConsolidatesStrings has not been implemented yet.'; cr.</pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test350frameLineSeparateLabelStatementCommentAnnotation</h3><pre>test350frameLineSeparateLabelStatementCommentAnnotation   "Generic frameline = ( indent ) ( label : ) ( statement '.' ) ( '(' comment ')' ) ( '[' annotation ']' )   where label = word ':'   "</pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test351frameLineParsingRemovesComments</h3><pre>test351frameLineParsingRemovesComments   "The parser recognizes that tokens are nouns, punctuation, keywords, or just words."   |   |   Transcript show: 'TODO: test351frameLineParsingRemovesComments has not been implemented yet.'; cr.       </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test353frameLineParsingSeparatesAnnotation</h3><pre>test353frameLineParsingSeparatesAnnotation   "The parser recognizes that tokens are nouns, punctuation, keywords, or just words."   |  |   Transcript show: 'TODO: test353frameLineParsingSeparatesAnnotation has not been implemented yet.'; cr.</pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test360statementMatchesPatternForEach</h3><pre>test360statementMatchesPatternForEach   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "   | statement pattern result |   true ifFalse: [ Transcript cr; show: 'test360statementMatchesPattern skipped'; cr.  ^self ].   "Match for each"   pattern := 'For each 1 in 2:'.   statement := HumStatement from: 'For each item in order:'.   result := 'No match'.   statement onMatch: pattern do: [ :item :order | result := 'Item=',item,' and ','order=',order ].   self assert: ( result sameAs: 'No match' ) not.   self assert: ( result sameAs: 'item=item and order=order' ).      </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test361statementMatchesPatternForEachInThe</h3><pre>test361statementMatchesPatternForEachInThe   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "   | statement pattern result |   true ifFalse: [ Transcript cr; show: 'test361statementMatchesPatternForEachInThe skipped'; cr.  ^self ].   "Match for each"   pattern := 'For each 1 in the 2:'.   statement := HumStatement from: 'For each item in order:'.   "Preset 'No match' -- to fail fast if the pattern match does not work as expected.'"   result := 'No match'.   statement onMatch: pattern do: [ :item :order | result := 'Item=',item,' and ','order=',order ].   "Fail fast if the result was not reset."   self assert: ( result sameAs: 'No match' ) not.   "This is the result we are expecting."   self assert: ( result sameAs: 'item=item and order=order' ).      </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test362statementMatchesPatternIsA</h3><pre>test362statementMatchesPatternIsA   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "   | statement pattern result |   true ifFalse: [ Transcript cr; show: 'test362statementMatchesPatternIsA skipped'; cr.  ^self ].   "Match ___  is a ___"   pattern := 'A 1 is a 2 .' .   statement := HumStatement from: 'A menu is a bill-of-material.'.      "Preset 'No match' -- to fail fast if the pattern match does not work as expected.'"   result := 'No match'.   statement onMatch: pattern do: [ :menu :billOfMaterial | result := 'menu=',menu, ' and ', 'bill-of-material=',billOfMaterial ].   "Fail fast if the result was not reset."   self assert: ( result sameAs: 'No match' ) not.   "This is the result we are expecting."   self assert: ( result sameAs: 'menu=menu and bill-of-material=bill-of-material' ).      </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test363statementMatchesElse</h3><pre>test363statementMatchesElse   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "   | statement pattern result |   true ifFalse: [ Transcript cr; show: 'test363statementMatchesElse skipped'; cr.  ^self ].   "Match 'Else:'"   pattern := 'Else:' .   statement := HumStatement from: 'Else:'.   "Fail fast if there is no match."   result := 'No match'.   "The following will fail if the parser thinks there are nouns."   statement onMatch: pattern do: [ result := 'Else has no arguments.' ].   "Test for no match."   self assert: ( result sameAs: 'No match' ) not.   "This is the result we are expecting."   self assert: ( result sameAs: 'Else has no arguments.' ).      </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test364statementMatchesCategories</h3><pre>test364statementMatchesCategories   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "   | statement pattern result |   true ifFalse: [ Transcript cr; show: 'test364statementMatchesCategories skipped'; cr.  ^self ].   ". . . categories include blah, blah, blah."   pattern := '1 categories include * . ' .   statement := HumStatement from: 'Color categories include red, green, blue. '.   result := 'No match'.   statement onMatch: pattern do: [:color :list | result := 'color=', color, ' and ', 'list=', list asString. ].   self assert: ( result sameAs: 'No match' ) not.   self assert: ( result sameAs: 'color=color and list=an OrderedCollection(''red'' ''green'' ''blue'')' ).      </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test365statementMatchesCategoriesAnd</h3><pre>test365statementMatchesCategoriesAnd   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "   | statement pattern result |   true ifFalse: [ Transcript cr; show: 'test365statementMatchesCategoriesAnd skipped'; cr.  ^self ].   ". . . categories include blah, blah, AND blah.'"   pattern := '1 categories include * . ' .   "The word 'and' should be allowed in a list without confusion."   statement := HumStatement from: 'Color categories include red, green, and blue. '.   result := 'No match'.   statement onMatch: pattern do: [:color :list | result := 'color=', color, ' and ', 'list=', list asString. ].   self assert: ( result sameAs: 'No match' ) not.   self assert: ( result sameAs: 'color=color and list=an OrderedCollection(''red'' ''green'' ''blue'')' ).      </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test366statementMatchesAttributes</h3><pre>test366statementMatchesAttributes   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "   | statement pattern result |   true ifFalse: [ Transcript cr; show: 'test366statementMatchesAttributes skipped'; cr.  ^self ].   ". . .  attributes include blah, blah, blah."   pattern := '1 attributes include * . ' .   statement := HumStatement from: 'Party attributes include name, address, phone-number. '.   result := 'No match'.   statement onMatch: pattern do: [:party :list | result := 'party=', party, ' and ', 'list=', list asString. ].   self assert: ( result sameAs: 'No match' ) not.   self assert: ( result sameAs: 'party=party and list=an OrderedCollection(''name'' ''address'' ''phone-number'')' ).      </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test367statementMatchesAttributesAnd</h3><pre>test367statementMatchesAttributesAnd   "Test HumStatement&gt;&gt;onMatch: aPattern do: aBlock "   | statement pattern result |   true ifFalse: [ Transcript cr; show: 'test367statementMatchesAttributesAnd skipped'; cr.  ^self ].   ". . . attributes include . . . blah, blah, AND blah "   pattern := '1 attributes include * . ' .   statement := HumStatement from: 'Party attributes include name, address, and phone-number. '.   result := 'No match'.   statement onMatch: pattern do: [:party :list | result := 'party=', party, ' and ', 'list=', list asString. ].   self assert: ( result sameAs: 'No match' ) not.   self assert: ( result sameAs: 'party=party and list=an OrderedCollection(''name'' ''address'' ''phone-number'')' ).      </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test410addOneAction</h3><pre>test410addOneAction   "An action belongs to a role."      | ontology source statement |      "Set up"   ontology := HumOntology new.      "Add role."   ontology addRole: 'Mover'.   self assert: ( ( ontology roles ) includes: 'Mover' ).      "An action is identified by a statement."   source := 'Move portable-object from current-location to new-location.'.   statement := HumStatement from: source.      "Add action to the role's set of actions."   ontology indexRole: 'Mover' action: statement.   self assert: ( ontology yesRole: 'Mover' hasAction: source ).   </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test420actionInstructions</h3><pre>test420actionInstructions   "An action statement is defined by a sequence of instructions."      | ontology role action instruction1 instruction2 instructionSequence |      "Set up"   ontology := HumOntology new.      "Add action to the role's set of actions."   role := 'Cook'.   action := 'Bake a cake per recipe.'.   ontology indexRole: role action:  ( HumStatement from: action ).   self assert: ( ontology yesRole: role hasAction: action ).      "Create an instruction."   " -- Instructions elements are all optional and include role, statement, comment, annotaion, translation."   instruction1 := HumInstructionLine new.   instruction1 statement: 'Preheat oven to recipe`s oven-temperature.'; role: 'Oven'.                         "Append instruction to sequence of instructions."   ontology appendInstruction: instruction1 toRole: role action: action.   "test"   instructionSequence := ( ontology instructionsForRole: role action: action ).   self assert: ( instructionSequence includes: instruction1).      "Create another instruction."   instruction2 := HumInstructionLine new.   instruction2 statement: 'Mix batter per recipe.'; role: 'Mixer'; annotation: 'duration: 5 minutes'.   self assert: ( instructionSequence size) = 1.   self assert: ( instructionSequence last = instruction1).      "Append second instruction to sequence of instructions."   ontology appendInstruction: instruction2 toRole: role action: action.   "test"   instructionSequence := ( ontology instructionsForRole: role action: action ).   self assert: ( instructionSequence size) = 2.   self assert: ( instructionSequence last = instruction2).   </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test430createInstructionsInline</h3><pre>test430createInstructionsInline   "Create instructions in-line using Class methods"   | ontology role action |      "Set up"   ontology := HumOntology new.      "Add action to the role's set of actions."   role := 'Cook'.   action := 'Bake a cake per recipe.'.   ontology indexRole: role action: (HumStatement from: action).      "Append first instruction to sequence of instructions."   ontology appendInstruction: 'Preheat oven to recipe`s oven-temperature.' toRole: role action: action.   "Append second instruction."   ontology appendInstruction: 'Mix batter per recipe.' toRole: role action: action.   self assert: ( ( ontology instructionsForRole: role action: action) size) = 2.   self assert: ( ( ontology instructionsForRole: role action: action) includes:  'Mix batter per recipe.' ).            </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test440getRoleActionStatement</h3><pre>test440getRoleActionStatement   "An action belongs to a role."      | ontology source actionStatement |      "Set up"   ontology := HumOntology new.         "Add action to the role's set of actions."   source :=  'Bake a cake per recipe.'.   ontology indexRole: 'Baker' action:  (HumStatement from: source ).   self assert: ( ontology yesRole: 'Baker' hasAction: source ).      "Get back the action statement. "   actionStatement := ontology getRole: 'Baker' action: source.   self assert: ( actionStatement isKindOf: HumStatement ).      "It should, of course, match."   self assert: ( actionStatement matchesCandidateStatement: source inOntology: ontology).   </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test441matchActionStatementAgainstCandidate</h3><pre>test441matchActionStatementAgainstCandidate   "Retrieve statement object from ontology when given a similar string."      | ontology source actionStatement candidate|      "Set up"   ontology := HumOntology new.         "Add action to the role's set of actions."   source := 'Bake a cake per recipe.'.   ontology indexRole: 'Baker' action:  (HumStatement from: source ).   candidate :=  'Bake a cake per recipe.'.   "Check that String&gt;&gt;sameAs: means what we expect."   self assert: ( candidate sameAs: source ).   self assert: ( source sameAs: candidate ).   "Should be able to retrieve with string that matches our source."   self assert: ( ontology yesRole: 'Baker' hasAction: candidate ).      "Get back the action statement. "   actionStatement := ontology getRole: 'Baker' action: candidate.   self assert: ( actionStatement isKindOf: HumStatement ).      "Candidate should match when it is word for word the same."   self assert: ( actionStatement matchesCandidateStatement: candidate inOntology: ontology).   "Candidate should also match if the articles are dropped or different."   candidate :=  'Bake the cake per the recipe.'.   self assert: ( actionStatement matchesCandidateStatement: candidate inOntology: ontology).   candidate :=  'Bake cake per recipe.'.   self assert: ( actionStatement matchesCandidateStatement: candidate inOntology: ontology).      </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test442matchActionStatementPolymorphic</h3><pre>test442matchActionStatementPolymorphic   "Retrieve appropriate statement with supertype     when invoking sentence has a subtype."      | ontology source actionStatement candidate|      "Set up"   ontology := HumOntology new.   "Define subtypes"   ontology addNoun: 'cake' isA: 'bake-product'.   ontology addNoun: 'pie' isA: 'bake-product'.         "Add action to the role's set of actions."   source := 'Bake a bake-product per recipe.'.   ontology indexRole: 'Baker' action:  (HumStatement from: source ).   candidate :=  'Bake a bake-product per recipe.'.   "Check that String&gt;&gt;sameAs: means what we expect."   self assert: ( candidate sameAs: source ).   self assert: ( source sameAs: candidate ).   "Should be able to retrieve with string that matches our source."   self assert: ( ontology yesRole: 'Baker' hasAction: candidate ).      "Get back the action statement. "   actionStatement := ontology getRole: 'Baker' action: candidate.   self assert: ( actionStatement isKindOf: HumStatement ).      "Candidate should match when it is word for word the same."   self assert: ( actionStatement matchesCandidateStatement: candidate inOntology: ontology).   "Candidate should also match if the articles are dropped or different."   candidate :=  'Bake the bake-product per the recipe.'.   self assert: ( actionStatement matchesCandidateStatement: candidate inOntology: ontology).   candidate :=  'Bake bake-product per recipe.'.   self assert: ( actionStatement matchesCandidateStatement: candidate inOntology: ontology).      "Now prove polymorphism works."   candidate :=  'Bake a cake per recipe.'.   self assert: ( actionStatement matchesCandidateStatement: candidate inOntology: ontology).   candidate :=  'Bake a pie per recipe.'.   self assert: ( actionStatement matchesCandidateStatement: candidate inOntology: ontology).   "But cookie-batch is not defined as a subtype in this ontology.   (Check for false positive.)"   candidate :=  'Bake a cookie-batch per recipe.'.   self assert: ( actionStatement matchesCandidateStatement: candidate inOntology: ontology) not.               </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test450instructionNounAntecedents</h3><pre>test450instructionNounAntecedents   "Nouns in instructions should have antecedants in the action statement.   (Test the code critic)"   | ontology role action critique |      "Set up"   ontology := HumOntology new.      "Add action to the role's set of actions."   role := 'Cook'.   action := 'Bake a cake per recipe.'.   ontology indexRole: role action: (HumStatement from: action).      "Append first instruction to sequence of instructions."   ontology appendInstruction: 'Preheat oven to recipe`s oven-temperature.' toRole: role action: action.   "Append second instruction."   ontology appendInstruction: 'Mix batter per recipe.' toRole: role action: action.      self assert:  (( ontology instructionsForRole: role action: action ) size) = 2.      ontology addNouns: #( 'recipe' 'oven' 'batter' ).   "In the given instruction sequence, the nouns 'oven' and 'batter' were not seen in the action statement."      critique := ontology critiqueRole: role action: action.   self assert: ( critique size &gt; 0 ).   self assert: ( ( critique at: 1 ) beginsWith: 'Some nouns lack antecedants').   self assert: ( ( critique at: 1 ) endsWith: 'Preheat oven to recipe`s oven-temperature.' ).   self assert: ( ( critique at: 2 ) beginsWith: 'Some nouns lack antecedants').   self assert: ( ( critique at: 2 ) endsWith: 'Mix batter per recipe.' ).   </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test461Frame4ActionCrossReferences</h3><pre>test461Frame4ActionCrossReferences   "Given: An action instruction delegates to another role (or same role).   When: The action frame is compiled.   Then: The ontology tracks where (which role-action frame) the action statement is invoked.   "   | frameUpdater frameUpdater2 ontology actionTitle1 actionTitle2  relations item actionStatement |   ontology := HumOntology new.      "Initialize for an Action Frame."   frameUpdater := HumFrameUpdater ontology: ontology                                        role: 'Baker'                                     action: 'Bake the pan in the oven for the time given in the recipe.'.   frameUpdater appendInstructionStatement: 'Open the oven door.'.   frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.   frameUpdater appendInstructionStatement: 'Close the oven door.'.   frameUpdater appendInstructionRole: 'Oven'                         statement: 'Bake for the baking-time given in the recipe.'                           comment: 'We have a smart oven.'.      ontology storeFrame: ( frameUpdater frame ).   actionTitle1 := frameUpdater frame title.      frameUpdater2 := HumFrameUpdater ontology: ontology                                                     role: 'Oven'                                                   action: 'Bake for the baking-time given in the recipe.'.   ontology storeFrame: ( frameUpdater2 frame ).   actionTitle2 := frameUpdater2 frame title.         "Frames must be compiled if nouns are to be flagged"   ontology addNouns: #( 'recipe' 'oven' 'baking-time').     "When: The action frame is compiled."   ontology compileAllFrames.   "Then: The ontology tracks where (which role-action frame) the action statement is invoked."   "*** Look under the covers to check expectations. TODO: REFACTOR THIS. *** "   relations := ontology frameRelationsWhere: [ :a :r :b | r = #invokesAction ].   self expect: 1 actual: ( relations size ) description: 'At this time, only action to action is indexed'.   item := relations asArray at: 1.   self expect: actionTitle1 actual: (item at: 1).   actionStatement := HumInstructionLine role: 'Oven' statement: 'Bake for the baking-time given in the recipe.'.    self expect: ( actionStatement title asLowercase ) actual: ( item at: 3 ).      </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test510CreatePlanFrame</h3><pre>test510CreatePlanFrame   "Make one plan frame. (TDD to drive basic parts)"   | planFrame preconditions actionSet ontology |      ontology := HumOntology new.   "A plan frame has a goal. (post condition)"   planFrame := HumFrame4Plan ontology: ontology goal: 'Bake a cake per recipe.'.   self assert: (( planFrame goal ) matchesCandidateStatement: 'Bake a cake per recipe.' inOntology: ontology).      "A plan frame has a collection of preconditions."   preconditions := planFrame preconditions.   self assert: ( preconditions isKindOf: Collection ).      planFrame appendPrecondition: 'Oven is preheated per recipe.'.   self assert: ( preconditions size ) = 1.      planFrame appendPrecondition: 'Batter is mixed per recipe ingredients.'.   self assert: ( preconditions size ) = 2.   planFrame appendPrecondition: 'Batter is in cake-pan per recipe pan-size.'.   self assert: ( preconditions size ) = 3.   "A plan frame has a set of zero or more actions    that move the state    from the preconditions    to the post condition (goal)."   actionSet := planFrame planActions.   self assert: ( actionSet isKindOf: Collection ).      planFrame appendRole: 'Baker' action: 'Bake the cake-pan per recipe baking-time.' comment: ''.   self assert: ( actionSet size ) = 1.         </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test520CheckPlanFrame</h3><pre>test520CheckPlanFrame   "A plan frame SHOULD have a goal and at least two preconditions.    -- Perhaps this rule is a 'should' rather than a 'must'.   -- The plan would still work,        but a plan with a large number of frames with just one precondition        seems a bit odd.   -- A better check would detect a string of such plan frames.    "    | planFrame problems  ontology |      ontology := HumOntology new.         planFrame := HumFrame4Plan new.   problems := planFrame check.   self assert: ( problems include: 'A plan frame must have a goal.' ).      "Fix that problem."   planFrame ontology: ontology; goal: 'Bake a cake per recipe'.      "A plan frame SHOULD have at least two preconditions."   "If there is only one, the business process should be stated as a procedure."   self assert: ( ( planFrame check) include:  'A plan frame should have at least two preconditions.' ).      "Half fix that problem."   planFrame appendPrecondition: 'Oven is preheated per recipe.'.         self assert: (  ( planFrame check)  include:  'A plan frame should have at least two preconditions.' ).      "Fully fix that problem."   planFrame appendPrecondition: 'Batter is in bake-pan per recipe.'.      self assert: (  ( planFrame check)  isEmpty ).            </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test530AddPlanFrame</h3><pre>test530AddPlanFrame   "Make one plan frame. (TDD to drive basic parts)"   | planFrame ontology |      ontology := HumOntology new.   "A plan frame should have a goal and at least two preconditions."      planFrame := HumFrame4Plan  ontology: ontology goal: 'Bake a cake per recipe'.   planFrame appendPrecondition: 'Oven is preheated per recipe.'.      planFrame appendPrecondition: 'Batter is in bake-pan per recipe.'.   planFrame appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.      ontology storeFrame: planFrame.      "===   Goal: Bake a cake per recipe.   Preconditions:   . Oven is preheated per recipe.   . Batter is in bake-pan per recipe.   Action:   . Baker: Bake bake-pan in the oven per recipe.   ===   "      </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test540GetPlanTree</h3><pre>test540GetPlanTree   "Make several plan frames. Get the resulting plan tree."   | planFrame1 planFrame2 planFrame3 ontology planTree |      ontology := HumOntology new.   "A plan frame must have a goal and at should have at least two preconditions."      planFrame1 := HumFrame4Plan ontology: ontology goal: 'Bake a cake per recipe.'.   planFrame1 appendPrecondition: 'Oven is preheated per recipe.'.      planFrame1 appendPrecondition: 'Batter is in bake-pan per recipe.'.   planFrame1 appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.   ontology storeFrame: planFrame1.         planFrame2 := HumFrame4Plan ontology: ontology goal: 'Oven is preheated per recipe.'.   planFrame2 appendPrecondition: 'Oven is cleared out.'.   planFrame2 appendPrecondition: 'Oven is on.'.   planFrame2 appendPrecondition: 'Oven temperature is set per recipe.'.   planFrame2 appendRole: 'Timer' action: 'Wait 5 minutes.'.   ontology storeFrame: planFrame2.      planFrame3 := HumFrame4Plan ontology: ontology goal: 'Batter is in bake-pan per recipe.'.   planFrame3 appendPrecondition: 'Batter fully mixed per recipe.'.   planFrame3 appendPrecondition: 'Bake-pan is greased per recipe.'.   planFrame3 appendRole: 'Baker' action: 'Pour batter into bake-pan per recipe.'.   ontology storeFrame: planFrame3.      "TODO: The plan tree is incomplete at this point           and the following call to {buildPlanTreeForGoal:} should fail."   planTree := ontology buildPlanTreeForGoal:  'Bake a cake per recipe.' indent: 0.   self assert: ( planTree size ) = 7.      "ontology showPlanTree: planTree."      "TODO: IS THIS CORRECT? THIS TEST DOES NOT COUNT THE GOAL AT THE ROOT AS PART OF THE PLAN TREE."   self assert: ( planTree anySatisfy: [:assoc |       ((assoc value) at: 2) = (HumStatement source: 'Batter is in bake-pan per recipe.')       ]).    
    </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test545DrawPlanTree</h3><pre>test545DrawPlanTree   "Make several plan frames. Get the resulting plan tree."   | planFrame1 planFrame2 planFrame3 ontology planTreeView |      ontology := HumOntology new.   "A plan frame must have a goal and at should have at least two preconditions."      planFrame1 := HumFrame4Plan ontology: ontology goal: 'Bake a cake per recipe.'.   planFrame1 appendPrecondition: 'Oven is preheated per recipe.'.      planFrame1 appendPrecondition: 'Batter is in bake-pan per recipe.'.   planFrame1 appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.   ontology storeFrame: planFrame1.         planFrame2 := HumFrame4Plan ontology: ontology goal: 'Oven is preheated per recipe.'.   planFrame2 appendPrecondition: 'Oven is cleared out.'.   planFrame2 appendPrecondition: 'Oven is on.'.   planFrame2 appendPrecondition: 'Oven temperature is set per recipe.'.   planFrame2 appendRole: 'Timer' action: 'Wait 5 minutes.'.   ontology storeFrame: planFrame2.      planFrame3 := HumFrame4Plan ontology: ontology goal: 'Batter is in bake-pan per recipe.'.   planFrame3 appendPrecondition: 'Batter fully mixed per recipe.'.   planFrame3 appendPrecondition: 'Bake-pan is greased per recipe.'.   planFrame3 appendRole: 'Baker' action: 'Pour batter into bake-pan per recipe.'.   ontology storeFrame: planFrame3.      "TODO: The plan tree is incomplete at this point           and the following call to {buildPlanTreeForGoal:} should fail."   planTreeView := ontology view showPlanTreeForGoal: 'Bake a cake per recipe.'.      "Transcript cr; show: 'test545DrawPlanTree'; show: planTreeView; cr."
    </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test550CheckPlanTree</h3><pre>test550CheckPlanTree   "Check for an incomplete plan."   | planFrame1 planFrame2 planFrame3 ontology planTreeProblems |      ontology := HumOntology new.   "A plan frame must have a goal and should have at least two preconditions."      planFrame1 := HumFrame4Plan ontology: ontology goal: 'Bake a cake per recipe.'.   planFrame1 appendPrecondition: 'Oven is preheated per recipe.'.      planFrame1 appendPrecondition: 'Batter is in bake-pan per recipe.'.   planFrame1 appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.   ontology storeFrame: planFrame1.         planFrame2 := HumFrame4Plan ontology: ontology goal: 'Oven is preheated per recipe.'.   planFrame2 appendPrecondition: 'Oven is cleared out.'.   planFrame2 appendPrecondition: 'Oven is on.'.   planFrame2 appendPrecondition: 'Oven temperature is set per recipe.'.   planFrame2 appendRole: 'Timer' action: 'Wait 5 minutes.'.   ontology storeFrame: planFrame2.      planFrame3 := HumFrame4Plan ontology: ontology goal: 'Batter is in bake-pan per recipe.'.   planFrame3 appendPrecondition: 'Batter fully mixed per recipe.'.   planFrame3 appendPrecondition: 'Bake-pan is greased per recipe.'.   planFrame3 appendRole: 'Baker' action: 'Pour batter into bake-pan per recipe.'.   ontology storeFrame: planFrame3.      planTreeProblems := ontology checkPlanTreeForGoal:  'Bake a cake per recipe.'.   self assert: ( planTreeProblems size ) = 5.   "   Transcript cr; show: 'Plan Tree Problems:'.   planTreeProblems do: [ :problem | Transcript cr; show: problem. ].   "   </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test610renderStatementAsHTML</h3><pre>test610renderStatementAsHTML   "In the HTML rendering, statement nouns are enclosed in &lt;n&gt;...&lt;/n&gt; to enable style sheet rendering."   | statement role ontology html |   ontology := HumOntology new.   statement := HumStatement from: 'Add incoming-count to stock-count, giving updated-stock-count.'.   role := 'Calc'.   ontology indexRole: role action: statement.      "The nouns might be defined after the statement is defined. "   ontology addNouns: #( 'count' 'incoming-count' 'stock-count' 'updated-stock-count' ).      html := ontology view renderStatement: statement triggerWords: #('if' 'else' 'for-each') keywords: #( 'giving' 'if' 'then' 'each' ).   self assert: ( '*Add *' match: html ).   self assert: ( '*giving*' match: html ).   self assert: ( '*&lt;k&gt;giving&lt;/k&gt;*' match: html ).   self assert: ( '*&lt;n&gt;stock-count&lt;/n&gt;*' match: html ).   self assert: ( '*&lt;n&gt;stock-count&lt;/n&gt;,*' match: html ).   self assert: ( '*&lt;n&gt;updated-stock-count&lt;/n&gt;.*' match: html ).</pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test611renderInstructionLines</h3><pre>test611renderInstructionLines   "Create instructions in-line using Class methods"   | ontology role action preheatInstruction mixInstruction frameEditor html |      "Set up"   ontology := HumOntology new.      "Add action to the role's set of actions."   role := 'Cook'.   action := 'Bake a cake per recipe.'.   ontology indexRole: role action: (HumStatement from: action).      "Append first instruction to sequence of instructions."   preheatInstruction := HumInstructionLine  statement: 'Preheat oven to recipe`s oven-temperature.'.   ontology appendInstruction: preheatInstruction toRole: role action: action.      "Append second instruction."   mixInstruction := HumInstructionLine  statement: 'Mix batter per recipe.'.   ontology appendInstruction: mixInstruction toRole: role action: action.      "Initialize for a Dictionary Frame."   frameEditor := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.   frameEditor addDictionaryLine: 'Recipe attributes include product-name, oven-temperature.'.  ontology storeFrame: ( frameEditor frame ).   "Frames must be compiled before rendering if nouns are to be flagged."   ontology compileAllFrames.   html := ontology view renderInstruction: preheatInstruction.   self assert: ( '*Preheat oven*' match: html ).   self assert: ( '*oven-temperature*' match: html ).   self assert: ( '*&lt;n&gt;*&lt;/n&gt;*' match: html ).   self assert: ( '*&lt;n&gt;oven-temperature&lt;/n&gt;*' match: html ).   </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test620renderFrame4PlanAsHTML</h3><pre>test620renderFrame4PlanAsHTML   "The frame editor instance knows what kind of frame it is editing.   "   | frameEditor ontology html thisFrame |   ontology := HumOntology new.      "Initialize for a Plan Frame."   frameEditor := HumFrameUpdater ontology: ontology goal: 'Cake is baked according to recipe..'.   frameEditor appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.   frameEditor appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.   frameEditor appendRole: 'Timer' action: 'Bake the pan in the oven for the time given in the recipe.' .      thisFrame :=  ( frameEditor frame ).   ontology storeFrame: thisFrame.      "Frames must be compiled before rendering if nouns are to be flagged."   ontology addNouns: #( 'recipe' ).   ontology compileAllFrames.   html := ontology view asHTML5 .   "Test:  Is the goal-statement included in the HTML ?"   self pattern:  '*according*to*' matches: html.      "Test: Are each of the preconditions included ?"      self pattern:  '*preheated*' matches: html .   self pattern:  '*batter*'  matches: html .   "Test: Is the action instruction role and statment included ?"   self pattern:  '*Timer*'  matches: html.   self pattern:  '*time given*'  matches: html.      "HTML should include a 'Preconditions' subheading."   self pattern:  '*Preconditions*' matches: html.      "HTML should include a 'Actions' subheading."   self pattern: '*Actions*' matches: html.      "HTML should include nouns flags"   self pattern: '*&lt;n&gt;*&lt;/n&gt;*' matches: html.   self pattern:  '*&lt;n&gt;recipe&lt;/n&gt;*' matches: html.   "Preconditions should have nouns marked"   self pattern:  '*temperature given in the &lt;n&gt;recipe&lt;/n&gt;*' matches: html.   "Actions should have nouns marked."   self pattern:  '*time given in the &lt;n&gt;recipe&lt;/n&gt;*' matches: html.   "Goal should have nouns marked."   self pattern:  '*according to &lt;n&gt;recipe&lt;/n&gt;*' matches: html.</pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test625renderPlanTreeAsHTML</h3><pre>test625renderPlanTreeAsHTML   "Make several plan frames. Get the resulting plan tree."   | planFrame1 planFrame2 planFrame3 ontology planTreeView frameEditor |      ontology := HumOntology new.   "A plan frame must have a goal and at should have at least two preconditions."      planFrame1 := HumFrame4Plan ontology: ontology goal: 'Bake a cake per recipe.'.   planFrame1 appendPrecondition: 'Oven is preheated per recipe.'.      planFrame1 appendPrecondition: 'Batter is in bake-pan per recipe.'.   planFrame1 appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.   ontology storeFrame: planFrame1.         planFrame2 := HumFrame4Plan ontology: ontology goal: 'Oven is preheated per recipe.'.   planFrame2 appendPrecondition: 'Oven is cleared out.'.   planFrame2 appendPrecondition: 'Oven is on.'.   planFrame2 appendPrecondition: 'Oven temperature is set per recipe.'.   planFrame2 appendRole: 'Timer' action: 'Wait 5 minutes.'.   ontology storeFrame: planFrame2.      planFrame3 := HumFrame4Plan ontology: ontology goal: 'Batter is in bake-pan per recipe.'.   planFrame3 appendPrecondition: 'Batter fully mixed per recipe.'.   planFrame3 appendPrecondition: 'Bake-pan is greased per recipe.'.   planFrame3 appendRole: 'Baker' action: 'Pour batter into bake-pan per recipe.'.   ontology storeFrame: planFrame3.         "Create a Dictionary Frame."   frameEditor := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.   frameEditor addDictionaryLine: 'Recipe attributes include recipe-name, description, ingredients, steps.'.   frameEditor addDictionaryLine: 'Recipe includes a list of ingredients.'.   frameEditor addDictionaryLine: 'Recipe includes a list of steps.'.   frameEditor addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.   frameEditor addDictionaryLine: 'Step attributes include step-number, step-description'.   frameEditor addDictionaryLine: 'Bakery attributes include oven, mixer, counter.'.   frameEditor addDictionaryLine: 'Recipe attributes include baking-time.'.   ontology storeFrame: ( frameEditor frame ).   ontology compileAllFrames.      planTreeView := ontology view renderPlanTreeForGoal: 'Bake a cake per recipe.'.      self expect: 'Plan Tree:   Bake a cake per &lt;n&gt;recipe&lt;/n&gt;.   |-&gt;  &lt;n&gt;Oven&lt;/n&gt; is preheated per &lt;n&gt;recipe&lt;/n&gt;.        |-&gt;  &lt;n&gt;Oven&lt;/n&gt; is cleared out.        |-&gt;  &lt;n&gt;Oven&lt;/n&gt; is on.        |-&gt;  &lt;n&gt;Oven&lt;/n&gt; temperature is set per &lt;n&gt;recipe&lt;/n&gt;.   |-&gt;  Batter is in bake-pan per &lt;n&gt;recipe&lt;/n&gt;.        |-&gt;  Batter fully mixed per &lt;n&gt;recipe&lt;/n&gt;.        |-&gt;  Bake-pan is greased per &lt;n&gt;recipe&lt;/n&gt;.'      actual: planTreeView.
    </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test626renderNounTreeAsHTML</h3><pre>test626renderNounTreeAsHTML   "Define a dictionary with more than one level. Render as a noun tree."   | ontology nounTreeView frameEditor html expected |      ontology := HumOntology new.      "Create a Dictionary Frame."   frameEditor := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.   frameEditor addDictionaryLine: 'Recipe attributes include recipe-name, description, ingredients, steps.'.   frameEditor addDictionaryLine: 'Recipe includes a list of ingredients.'.   frameEditor addDictionaryLine: 'Recipe includes a list of steps.'.   frameEditor addDictionaryLine: 'Measure attributes include quantity, units.'.   frameEditor addDictionaryLine: 'Ingredient attributes include ingredient-name, ingredient-measure, substitute.'.   frameEditor addDictionaryLine: 'Step attributes include step-number, step-description'.   frameEditor addDictionaryLine: 'Bakery attributes include oven, mixer, counter.'.   frameEditor addDictionaryLine: 'Recipe attributes include bake-time, bake-temperature.'.   ontology storeFrame: ( frameEditor frame ).   ontology compileAllFrames.      nounTreeView := ontology view renderNounTreeForNoun: 'recipe'.      self expect: 'Noun Tree:   recipe    |-&gt; bake-temperature    |-&gt; bake-time    |-&gt; description    |-&gt; ingredients         |-&gt; ingredient-measure              |=&gt; measure                   |-&gt; quantity                   |-&gt; units         |-&gt; ingredient-name         |-&gt; substitute    |-&gt; recipe-name    |-&gt; steps         |-&gt; step-description         |-&gt; step-number'      actual: nounTreeView.
 "TODO: HumCalculator translates &lt;&gt; to &lt; &gt;"   expected := HumCalculator given: nounTreeView replaceAll: '&gt;'  with: '&gt;'.   html := ontology view renderNounTreeForNounAsHTML: 'recipe'.   self expect: expected actual: html.   </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test630renderFrame4ActionAsHTML</h3><pre>test630renderFrame4ActionAsHTML   "Given: The frame editor contains a role-action frame.    When: Rendering a role-action frame as HTML.    Then: The HTML identifies the nouns. (see test610renderStatementAsHTML)    Then: The HTML indents instructions.    Then: The HTML includes the heading.    Then: The HTML includes each comment.    Note: CSS boiler-plate (generated elsewhere) will handle the color-coding.   "   | frameEditor ontology html |   ontology := HumOntology new.      "Initialize for an Action Frame."   frameEditor := HumFrameUpdater ontology: ontology                                        role: 'Baker'                                     action: 'Bake the pan in the oven for the time given in the recipe.'.   frameEditor appendInstructionStatement: 'Open the oven door.'.   frameEditor appendInstructionStatement: 'Place the pan in the oven.'.   frameEditor appendInstructionStatement: 'Close the oven door.'.   frameEditor appendInstructionRole: 'Oven' statement: 'Bake for the baking-time given in the recipe.' comment: 'We have a smart oven.'.      ontology storeFrame: ( frameEditor frame ).      "Frames must be compiled if nouns are to be flagged"   ontology addNouns: #( 'recipe' 'oven' 'baking-time').   ontology compileAllFrames.   html := ontology view asHTML5.      "Test: Title line is rendered."   self pattern:  '*time given*' matches: html.   "First instruction is rendered."   self pattern:  '*Open the*' matches: html.      "2nd instruction is rendered."   self pattern:  '*pan in the*' matches: html.   "3rd instruction is rendered."   self pattern:  '*Close the*' matches: html.   "4th inststruction statement is rendered"   self pattern:  '*Bake for the*' matches: html.   "Comment is rendered"   self pattern:  '*smart oven*' matches: html.   "Role is rendered."   self pattern:  '*&lt;role&gt;*Oven*' matches: html.   "HTML should include 'Action:' label."   self pattern:  '*Action:*' matches: html.   "Avoid double-space bug"   self assert:(  '*&lt;br/&gt;&lt;br/&gt;&lt;InstructionLine&gt;*' match: html ) not.         "html inspect."      </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test640renderFrame4ViewAsHTML</h3><pre>test640renderFrame4ViewAsHTML   "Given: The frame editor instance knows what kind of frame it is editing.    When: The frame is a view and we render it as HTML for viewing the ontology source.    Then: The rendering shows a reasonable facsimile of the corresponding HTML form,           but with source navigation.   "   | frameEditor ontology html |   ontology := HumOntology new.      "Initialize for a View Frame."   frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe.'.   frameEditor addMarkUp: '!! Recipe'.   frameEditor addMarkUp: ' recipe-name: [name]'.   frameEditor addMarkUp: '   description: [description 5]'.   frameEditor addMarkUp: '   ingredients: [ingredients]'.   frameEditor addMarkUp: '           steps: [steps]'.   self assert: ( frameEditor notNil ).      ontology storeFrame: ( frameEditor frame ).   ontology compileAllFrames.   html := ontology view asHTML5.   "Test that labels are present in the rendering."   "Title line"   self pattern: '*Recipe*' matches: html.   "1st markup line"   self pattern: '*recipe-name: *' matches: html.   "2nd markup line"   self pattern: '*description: *' matches: html.   "3rd markup line"   self pattern: '*ingredients: *' matches: html.   "4th (last) marup line"   self pattern: '*steps: *' matches: html.      "Test that widgets are present in the rendering."   "1st markup line"   self assert: ( ( html match:  '*[name]*'  ) not )         description: 'Hum widget should be replaced by HTML element'.   self pattern: '*recipe-name: &lt;input name="*"*/&gt;*' matches: html.   "2nd markup line -- TODO: Should be multi-line box."   self assert: ( ( '*[description 5]*' match: html ) not )         description: 'Hum widget should be replaced by HTML element'.   self pattern: '*description: &lt;textarea name="*"*/&gt;*' matches: html.   "3rd markup line -- TODO: Should be input-table.  (HOW?) "   self pattern: '*ingredients: &lt;table name="*"*/&gt;*' matches: html.   "4th markup line -- TODO: Should be input-table.  (HOW?) "   self pattern: '*steps: &lt;table name="*"*/&gt;*' matches: html.      "TODO: WIDGETS NEED TO BE ARTICULATED BY TYPE."   "Inspect -- paste result into HTML tool/file."   "html inspect."</pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test641renderRadioButtonAsHTML</h3><pre>test641renderRadioButtonAsHTML   "Given: The frame editor instance knows what kind of frame it is editing.    When: The frame is a view and we render it as HTML for viewing the ontology source.    Then: The rendering shows a reasonable facsimile of the corresponding HTML form,           but with source navigation.   "   | frameEditor ontology html |   ontology := HumOntology new.      "Initialize for a View Frame."   frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'pizza-order.'.   frameEditor addMarkUp: '!! Pizza Order'.   frameEditor addMarkUp: '!!! Size'.   frameEditor addMarkUp: '  (S) Small  (M) Medium  (L) Large'.   self assert: ( frameEditor notNil ).      ontology storeFrame: ( frameEditor frame ).   ontology compileAllFrames.   html := ontology view asHTML5.   "Test that labels are present in the rendering."   "Title lines"   self pattern: '*Pizza Order*' matches: html.   self assert: ('*Size*' match: html).   "Are radio widgets rendered?"   self assert: ('*(#)*' match: html ) not description: 'Hum widget should be replaced by HTML element'.   "Expect radio button"   self assert: ('*radio*' match: html) description: 'Expecting a radio button.'.   "Inspect -- paste result into HTML tool/file."   "html inspect."         </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test642renderCheckBoxAsHTML</h3><pre>test642renderCheckBoxAsHTML   "Given: The frame editor instance knows what kind of frame it is editing.    When: The frame is a view and we render it as HTML for viewing the ontology source.    Then: The rendering shows a reasonable facsimile of the corresponding HTML form,           but with source navigation.   "   | frameEditor ontology html |   ontology := HumOntology new.      "Initialize for a View Frame."   frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'pizza-order.'.   frameEditor addMarkUp: '!! Pizza Order'.   frameEditor addMarkUp: '!!! Toppings'.   frameEditor addMarkUp: ' [P] Pepperoni  [S] Sausage  [H] Ham'.   self assert: ( frameEditor notNil ).      ontology storeFrame: ( frameEditor frame ).   ontology compileAllFrames.   html := ontology view asHTML5.   "Test that labels are present in the rendering."   "Title lines"   self pattern: '*Pizza Order*' matches: html.   self pattern: '*Toppings*' matches: html.   "Are widgets rendered?"   self assert: ('*[*]*' match: html ) not description: 'Hum widgets should be replaced by HTML element.'.   "Expect radio button"   self assert: ('*checkbox*' match: html) description: 'Expecting a checkbox.'.   "Watch for bug"   self pattern: '*&lt;input name="H" type="checkbox"/&gt; Ham*' matches: html.   self pattern: '*&lt;input name="S" type="checkbox"/&gt; Sausage*' matches: html.   self pattern: '*&lt;input name="P" type="checkbox"/&gt; Pepperoni*' matches: html.   "Inspect -- paste result into HTML tool/file."   "html inspect."         </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test643renderTextAsHTML</h3><pre>test643renderTextAsHTML   "Given: The frame editor instance knows what kind of frame it is editing.    When: The frame is a view and we render it as HTML for viewing the ontology source.    Then: The rendering shows a reasonable facsimile of the corresponding HTML form,           but with source navigation.   "   | frameEditor ontology html |   ontology := HumOntology new.      "Initialize for a View Frame."   frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'Who'.   frameEditor addMarkUp: '!! Who Are You?'.   frameEditor addMarkUp: 'Please describe yourself for our members.'.   frameEditor addMarkUp: 'Description: [whoami 8]'.   self assert: ( frameEditor notNil ).      ontology storeFrame: ( frameEditor frame ).      ontology compileAllFrames.   html := ontology view asHTML5.   "Test that labels are present in the rendering."   "Title lines"   self pattern: '*Who Are You?*' matches: html.   "Are widgets rendered?"   self assert: ('*[*]*' match: html ) not         description: 'Hum widget should be replaced by HTML element.'.   "Check textarea tag attributes."  self assert: ('*&lt;textarea*' match: html) description: 'Expecting a textarea tag.'.   self pattern: '*rows=8*' matches: html.   self pattern: '*name="whoami"*' matches: html.   "Inspect -- paste result into HTML tool/file."   "html inspect."         </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test650renderFrame4DictionaryAsHTML</h3><pre>test650renderFrame4DictionaryAsHTML   "The frame editor instance knows what kind of frame it is editing.   "   | frameEditor ontology html |   ontology := HumOntology new.         "Initialize for a Dictionary Frame."   frameEditor := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.   frameEditor addDictionaryLine: 'Recipe attributes include recipe-name, description, ingredients, steps.'.   frameEditor addDictionaryLine: 'Recipe includes a list of ingredients. (Does sequence matter for ingredients?)'.     frameEditor addDictionaryLine: 'Recipe includes a list of steps.  (Sequence is essential for steps.)'.    frameEditor addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.   frameEditor addDictionaryLine: 'Step attributes include step-number, step-description'.         self assert: ( frameEditor notNil ).      ontology storeFrame: ( frameEditor frame ).   html := ontology view asHTML5.      self pattern:  '*vocabulary*' matches: html.   self pattern: '*recipe-name*' matches: html.   self pattern: '*&lt;k&gt;list&lt;/k&gt; of ingredients*' matches: html.   self pattern: '*step-number*' matches: html.   self pattern: '*Ingredient*&lt;k&gt;attributes&lt;/k&gt;*' matches: html.   self pattern: '*Step*&lt;k&gt;attributes&lt;/k&gt;*' matches: html.      "Note: String&gt;&gt;match: is not case sensitive.   So following checks that capitalization is maintained."   self assert: ( (html findString: 'Step &lt;k&gt;attributes&lt;/k&gt;') &gt; 0 ).   self assert: ( (html findString: 'sequence') &gt; 0 ).   "html inspect."         </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test680renderOntologyAsHTML</h3><pre>test680renderOntologyAsHTML   "Render an ontology object in HTML and store on given filename."   | ontology frameEditor html |      ontology := HumOntology new.      "Create a Plan Frame."   frameEditor := HumFrameUpdater ontology: ontology goal: 'Cake is baked according to recipe..'.   frameEditor appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.   frameEditor appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.   frameEditor appendRole: 'Timer' action: 'Bake the pan in the oven for the time given in the recipe.' .   ontology storeFrame: ( frameEditor frame ).      "Create an Action Frame."   frameEditor := HumFrameUpdater ontology: ontology                                        role: 'baker'                                                    action: 'Bake the pan in the oven for the time given in the recipe.'.   frameEditor appendInstructionStatement: 'Open the oven door.'.   frameEditor appendInstructionStatement: 'Place the pan in the oven.'.   frameEditor appendInstructionStatement: 'Close the oven door.'.   frameEditor appendInstructionRole: 'Oven' statement: 'Bake for the time given.' comment: 'We have a smart oven.'.      ontology storeFrame: ( frameEditor frame ).      "Create a Dictionary Frame."   frameEditor := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.   frameEditor addDictionaryLine: 'Recipe attributes include recipe-name, description, ingredients, steps.'.   frameEditor addDictionaryLine: 'Recipe includes a list of ingredients.'.   frameEditor addDictionaryLine: 'Recipe includes a list of steps.'.   frameEditor addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.   frameEditor addDictionaryLine: 'Step attributes include step-number, step-description'.   frameEditor addDictionaryLine: 'Bakery attributes include oven, mixer, counter.'.   frameEditor addDictionaryLine: 'Recipe attributes include baking-time.'.   ontology storeFrame: ( frameEditor frame ).   "Create a View Frame."   frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe.'.   frameEditor addMarkUp: '!! Recipe'.   frameEditor addMarkUp: ' recipe-name: [name]'.   frameEditor addMarkUp: '   description: [description 5]'.   frameEditor addMarkUp: '   ingredients: [ingredients]'.   frameEditor addMarkUp: '            steps: [steps]'.   ontology storeFrame: ( frameEditor frame ).      "Frames must be compiled if nouns are to be marked."   ontology compileAllFrames.   html := ontology view asHTML5.   self assert: ( html size &gt; 1000 ).      "Frames should be have horizontal lines between."   self pattern:  '*&lt;hr/&gt;*&lt;HumFrame&gt;*' matches: html.      "Should see some nouns flagged."   self pattern:  '*&lt;n&gt;*&lt;/n&gt;*' matches: html.   self pattern:  '*&lt;n&gt;oven&lt;/n&gt;*' matches: html.   self pattern:  '*&lt;n&gt;recipe&lt;/n&gt;*' matches: html.                     </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test690renderOntologyAsHTMLonFile</h3><pre>test690renderOntologyAsHTMLonFile   "Render an ontology object in HTML and store on given filename."   | ontology frameEditor html planFrame1 planFrame2 planFrame3 |      ontology := HumOntology new.   ontology title: 'test690renderOntologyAsHTMLonFile'.         planFrame1 := HumFrame4Plan ontology: ontology goal: 'Bake a cake per recipe.'.   planFrame1 appendPrecondition: 'Oven is preheated per recipe.'.      planFrame1 appendPrecondition: 'Batter is in bake-pan per recipe.'.   planFrame1 appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.   ontology storeFrame: planFrame1.         planFrame2 := HumFrame4Plan ontology: ontology goal: 'Oven is preheated per recipe.'.   planFrame2 appendPrecondition: 'Oven is cleared out.'.   planFrame2 appendPrecondition: 'Oven is on.'.   planFrame2 appendPrecondition: 'Oven temperature is set per recipe.'.   planFrame2 appendRole: 'Timer' action: 'Wait 5 minutes.'.   ontology storeFrame: planFrame2.      planFrame3 := HumFrame4Plan ontology: ontology goal: 'Batter is in bake-pan per recipe.'.   planFrame3 appendPrecondition: 'Batter fully mixed per recipe.'.   planFrame3 appendPrecondition: 'Bake-pan is greased per recipe.'.   planFrame3 appendRole: 'Baker' action: 'Pour batter into bake-pan per recipe.'.   ontology storeFrame: planFrame3.      "Create an Action Frame."   frameEditor := HumFrameUpdater ontology: ontology                                        role: 'baker'                                                    action: 'Bake the pan in the oven for the time given in the recipe.'.   frameEditor appendInstructionStatement: 'Open the oven door.'.   frameEditor appendInstructionStatement: 'Place the pan in the oven.'.   frameEditor appendInstructionStatement: 'Close the oven door.'.   frameEditor appendInstructionRole: 'Oven' statement: 'Bake for the baking-time given in the recipe.' comment: 'We have a smart oven.'.      ontology storeFrame: ( frameEditor frame ).      "Create a Dictionary Frame."   frameEditor := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.   frameEditor addDictionaryLine: 'Recipe attributes include recipe-name, description, ingredients, steps.'.   frameEditor addDictionaryLine: 'Recipe includes a list of ingredients.'.   frameEditor addDictionaryLine: 'Recipe includes a list of steps.'.   frameEditor addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.   frameEditor addDictionaryLine: 'Step attributes include step-number, step-description'.   frameEditor addDictionaryLine: 'Bakery attributes include oven, mixer, counter.'.   frameEditor addDictionaryLine: 'Recipe attributes include baking-time.'.   ontology storeFrame: ( frameEditor frame ).   "Create a View Frame."   frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.   frameEditor addMarkUp: '!! Recipe'.   frameEditor addMarkUp: ' recipe-name: [name]'.   frameEditor addMarkUp: '   description: [description 5]'.   frameEditor addMarkUp: '   ingredients: [ingredients]'.   frameEditor addMarkUp: '            steps: [steps]'.   ontology storeFrame: ( frameEditor frame ).      "Frames must be compiled if nouns are to be marked."   ontology compileAllFrames.   html := ontology view asHTML5.   self assert: ( html size &gt; 1000 ).      "Write on a file."   ontology view renderAsHTMLonFileNamed: 'test690renderOntologyAsHTMLonFile.html'.         </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test900checkUsability</h3><pre>test900checkUsability   "Test the pattern matching.   When the current line contains the pattern,    Then the match is true.   "   | frameLine pattern template  cr code |   "Test using a dictionary statement pattern."   pattern := '1 has a list of 2'.   "Create a frame line that will match the pattern."   frameLine := HumFrameLine new.   frameLine source: 'Frame has a list of frameLines. '.   "Should match"   self assert: (frameLine matchesPattern: pattern ).   "Generate some code"   "Check usability -- What if we wanted to generate Smalltalk?"   cr := String cr.   template := 'ontology addEntity: ''1'' attribute: ''2''.', cr, 'ontology addNoun: ''2'' isA: ''list''.'.   "Check usability -- What if we wanted to generate Java?     In this situation, we need the singular form of the noun.
   So we will extend the template notation . . .   (2~ indicates the singular form of noun 2)"   template := 'private List&lt;2~&gt; 2;', cr, '1.attribute( 2 );'.   "Check usability -- What if we wanted to generate JavaScript?"   template := 'var 2 = [];  1["2"] = 2;'.      "Check usability -- What if we wanted to generate Erlang?   We will use an ets to represent an entity in Erlang.   (An Erlang record would probably be a better representation but it is not very dynamic.).   Anyway, this is mainly for testing    Note: 2 must be a good-enough Erlang atom.   All of these languages will require that Hum nouns such as billing-address be translated to camelCase.   "   template := 'ets:new( 1, [ ordered_set, named_table ] ),', cr, 'ets:insert( 1, { 2, [] } ),'.      "Check usability -- What if we wanted to generate Python?    We will represent entities using a dictionary in Python."   template := '1 = dict()', cr, '1.setdefault( "2", [ ] )'.        "Generate arbitrary code"   code := frameLine onMatch: pattern generate: template.      </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test910lineMatchesPattern</h3><pre>test910lineMatchesPattern   "Test the pattern matching.   When the current line contains the pattern,    Then the match is true.   "   | frameLine pattern template arguments cr |   "Test using a dictionary statement pattern."   pattern := '1 has a list of 2'.   "Create a frame line that will match the pattern."   frameLine := HumFrameLine new.   frameLine source: 'Frame has a list of frameLines. '.   "Should match"   self assert: (frameLine matchesPattern: pattern ).   </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test911lineDoesNotMatchPattern</h3><pre>test911lineDoesNotMatchPattern   "Test the pattern matching.   When the current line contains the pattern,    Then the match is true.   "   | frameLine pattern template arguments cr |   "Test using a dictionary statement pattern."   pattern := '1 has a list of 2'.   "Create a frame line that will match the pattern."   frameLine := HumFrameLine new.   frameLine source: 'Frame has a set of frameLines. '.   "Should not match"   self assert: (frameLine matchesPattern: pattern ) not.   </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test912lineMatchesFloatingPattern</h3><pre>test912lineMatchesFloatingPattern   "Test the pattern matching.   When the current line contains the pattern,    Then the match is true.   "   | frameLine pattern template arguments cr |   "Test using a dictionary statement pattern."   pattern := '[1]'.   "Create a frame line that will match the pattern."   frameLine := HumFrameLine new.   frameLine source: ' blah blah label: [attribute] blah blah '.   "Should match"   self assert: (frameLine matchesPattern: pattern ).   </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test913lineMatchesFloatingPattern</h3><pre>test913lineMatchesFloatingPattern   "Test the pattern matching.   When the current line contains the pattern,    Then the match is true.   "   | frameLine pattern template arguments cr |   "Test using a dictionary statement pattern."   pattern := '[1 2]'.   "Create a frame line that will match the pattern."   frameLine := HumFrameLine new.   frameLine source: ' blah blah label: [entity attribute] blah blah '.   "Should match"   self assert: (frameLine matchesPattern: pattern ).   </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test914lineMatchesFloatingPattern</h3><pre>test914lineMatchesFloatingPattern   "Test the pattern matching.   When the current line contains the pattern,    Then the match is true.   "   | frameLine pattern template arguments cr |   "Test using a dictionary statement pattern."   pattern := '[1: 2]'.   "Create a frame line that will match the pattern."   frameLine := HumFrameLine new.   frameLine source: ' blah blah label: [pane: view] blah blah '.   "Should match"   self assert: (frameLine matchesPattern: pattern ).   </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test915lineFailsFloatingPattern</h3><pre>test915lineFailsFloatingPattern   "Test the pattern matching.   When the current line contains the pattern,    Then the match is true.   "   | frameLine pattern template arguments cr |   "Test using a dictionary statement pattern."   pattern := '(1)'.   "Create a frame line that will match the pattern."   frameLine := HumFrameLine new.   frameLine source: ' blah blah label: [pane: view] blah blah '.   "Should match"   self assert: (frameLine matchesPattern: pattern ) not.   </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test920lineMatchesPatternParameters</h3><pre>test920lineMatchesPatternParameters   "Test the pattern matching.   When the current line contains the pattern,    Then the match is true.   "   | frameLine pattern template parameters cr |   "Test using a dictionary statement pattern."   pattern := '1 has a list of 2'.   "Create a frame line that will match the pattern."   frameLine := HumFrameLine new.   frameLine source: 'Frame has a list of frameLines. '.   "Should match"   self assert: (frameLine matchesPattern: pattern ).   "Get parameters"   parameters := frameLine extractPatternParameters: pattern.   self assert: ( parameters at: 1 ) = 'frame'.      self assert: ( parameters at: 2 ) = 'framelines'.   </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test922lineMatchesFloatingPatternParameters</h3><pre>test922lineMatchesFloatingPatternParameters   "Test the pattern matching.   When the current line contains the pattern,    Then the match is true.   "   | frameLine pattern template parameters cr |   "Test using a dictionary statement pattern."   pattern := '[1]'.   "Create a frame line that will match the pattern."   frameLine := HumFrameLine new.   frameLine source: ' blah blah label: [attribute] blah blah '.   "Should match"   self assert: (frameLine matchesPattern: pattern ).   "Get parameters"   parameters := frameLine extractPatternParameters: pattern.   self assert: ( parameters at: 1 ) = 'attribute'.      </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test923lineMatchesFloatingPatternParameters</h3><pre>test923lineMatchesFloatingPatternParameters   "Test the pattern matching.   When the current line contains the pattern,    Then the match is true.   "   | frameLine pattern template parameters cr |   "Test using a dictionary statement pattern."   pattern := '[1 2]'.   "Create a frame line that will match the pattern."   frameLine := HumFrameLine new.   frameLine source: ' blah blah label: [entity attribute] blah blah '.   "Should match"   self assert: (frameLine matchesPattern: pattern ).      "Get parameters"   parameters := frameLine extractPatternParameters: pattern.   self assert: ( parameters at: 1 ) = 'entity'.      self assert: ( parameters at: 2 ) = 'attribute'.   </pre><h3>Hum-Tests -- HumOntologyTests &gt;&gt; test930generateCode</h3><pre>test930generateCode   "Generate some code that does not require that we find a singular noun.   "   | frameLine pattern template  cr code |   "Test using a dictionary statement pattern."   pattern := '1 has a list of 2'.   "Create a frame line that will match the pattern."   frameLine := HumFrameLine new.   frameLine source: 'Frame has a list of frameLines. '.   "Should match"   self assert: (frameLine matchesPattern: pattern ).   "Generate some code"   "Check usability -- What if we wanted to generate JavaScript?"   template := 'var 2 = [];  1["2"] = 2;'.      "Generate arbitrary code"   code := frameLine onMatch: pattern generate: template.      self assert: ( code sameAs: 'var framelines = [];  frame["framelines"] = framelines;' ).      </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; assertExpectedTokensIn:matchesTokensIn:</h3><pre>assertExpectedTokensIn: expected matchesTokensIn: actual   "Compare the two strings as a stream of tokens.   If they are the same,    . return self.   If they are not the same,    . signal failure and show where match fails.   This is patterned after TestCase&gt;&gt;assert:equals:   "   | whitespace specials delimiters expectedTokens actualTokens |   self assert: ( expected isKindOf: String ).   self assert: ( actual isKindOf: String ).   whitespace := String space, String tab, String crlf.   specials := '~!@#$%^&*()_+`-={}|[]\:";''&lt;&gt;?,./'.   delimiters := whitespace, specials.   expectedTokens := ( expected withBlanksCondensed ) findTokens: delimiters keep: specials.   actualTokens   := (   actual withBlanksCondensed ) findTokens: delimiters keep: specials.      ( 1 to: expectedTokens size )      do: [ :i |         | expectedToken actualToken |         expectedToken := expectedTokens at: i.         actualToken := actualTokens at: i.         self assert: ( expectedToken = actualToken ) description: 'expected: "',expectedToken,'" at: ',i asString,' actual: "', actualToken,'"'.         "Note failing this assert will halt the loop."         ].   ^ self      assert: ( expectedTokens = actualTokens )      description: 'tokens do not match '.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; bakeThePanInTheOvenForTheTimeGivenInTheRecipeQpan:oven:time:recipe:</h3><pre>bakeThePanInTheOvenForTheTimeGivenInTheRecipeQpan: aPan oven: aOven time: aTime recipe: aRecipe     | aDoor |   "Open the oven door. "   self openTheOvenDoorQoven: aOven door: aDoor .    "Place the pan in the oven. "    self placeThePanInTheOvenQpan: aPan oven: aOven .    "Close the oven door. "    self closeTheOvenDoorQoven: aOven door: aDoor .    "Oven: Heat for the time given in the recipe.We have a smart oven."    aOven heatForTheTimeGivenInTheRecipeQtime: aTime recipe: aRecipe . "We have a smart oven."</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; fulfillOrderQorder:</h3><pre>fulfillOrderQorder: aOrder    "For each order-item in the order: "   ( self blackboard entity: 'order' attribute: 'orderItem' ) do: [ :orderItem |      | aOrderItem |     aOrderItem := orderItem.      "Pull order-item from stock and place on cart. "       self pullOrderItemFromStockAndPlaceOnCartQorderItem: aOrderItem .       ].   "Ship the order to the order-address. "    self shipTheOrderToTheOrderAddressQorder: aOrder . </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; test010AssertExpectedTokensInAMatchesTokensInB</h3><pre>test010AssertExpectedTokensInAMatchesTokensInB   "Test the utility with the cases that matter to me."   | failcase |      "Two cases that differ only in white space will match"   self assertExpectedTokensIn: '  (  { } )' matchesTokensIn: '({})'.   "Two cases that differ in substance will fail"   failcase := [self assertExpectedTokensIn: '( { } )' matchesTokensIn: '( { somethingdifferent } )'].   self should: failcase raise: TestFailure.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; test110AttachMethodToClass</h3><pre>test110AttachMethodToClass   "Attach a method to a class."   | translator aMethodName aClassName aSource |   translator := HumOntologyTranslator new.   "Example in Java syntax with Hum accounting"   aSource := '         /** Move portable-object to location. */      public Expense movePortableObjectToLocation( PortableObject portableObject, Location location ) {         // TBD - The body of the method goes here.         Timer timer = new Timer.start();         timer.tick( self.randomDuration() );  // Fuzzy number for simulation.         return new Expense( self.class(), self.id(), timer.stop() );      }                  '.   aMethodName := 'Move portable-object to location.'.   aClassName := 'MaterialTransporter'.   translator attachAction: aMethodName toActorClass: aClassName fromSource: aSource.      "TODO: Need some asserts."   self assert: ( translator methodsForClasses isEmpty) not.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; test111GetMethodsForClass</h3><pre>test111GetMethodsForClass   "Attach a method and get it back."   | translator aMethodName aClassName aSource methods source |   translator := HumOntologyTranslator new.   "Example in Java syntax with Hum accounting"   aSource := '         /** Move portable-object to location. */      public Expense movePortableObjectToLocation( Entity portableObject, Entity location ) {         // TBD - The body of the method goes here.         Timer timer = new Timer.start();         timer.tick( self.averageDuration() );  // Use average duration for fairness.         return new Expense( self.class(), self.id(), timer.stop() );      }                  '.   aMethodName := 'Move portable-object to location.'.   aClassName  := 'MaterialTransporter'.   translator attachAction: aMethodName toActorClass: aClassName fromSource: aSource.      "Now get it back."   methods := translator getMethodsForClass: aClassName.   self assert: ( methods size = 1 ).   source := methods at: aMethodName.   self assert: aSource equals: source.   </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; test120AttachClassPrologue</h3><pre>test120AttachClassPrologue   "Attach prologue source lines to an actor class.   Language-specific translators will generate prologue code.   The prologue will contain boiler-plate and infrastructure.   "   | translator  aClassName aSource |   translator := HumOntologyTranslator new.   aClassName := 'MaterialTransporter'.      "Example in Java syntax with Hum accounting.   Eventually, the Ontology Translator will generate the prologue."   aSource := '// Hum Actor: ', aClassName,'.// Actor supertype implements BlackBoard and Messenger interfaces.include hum.actor.Actor;  // On receipt of a message, the supertype copies data into local blackBoard and jobTicket variables.include hum.actor.BlackBoard;include hum.actor.JobTicket;// Many nouns are of these datatypes: include hum.datatypes.Measure;include hum.datatypes.TimeStamp;      public class ',aClassName,' extends Actor {   private BlackBoard blackBoard;   private JobTicket jobTicket;'.   translator attachPrologToActorClass: aClassName fromSource: aSource.      self assert: ( translator prologues isEmpty ) not.   "An Actor`s implementation in Java or Erlang must reside in a file of the same name.   We can adopt the same convention for JavaScript and Smalltalk implementations.   "   </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; test370forStatementAsSmalltalk</h3><pre>test370forStatementAsSmalltalk   "Translate for . . .    to Smalltalk"   |     forStatement   smalltalkCode ontology |   true ifFalse: [ Transcript cr; show: 'test370forStatementAsSmalltalk skipped'; cr. ^self.].   "---   Dictionary: Order.   An order has a list of order-items.   ---   "   ontology := HumOntology new.   "Add entity-attribute relation."   ontology addEntity: 'order' attribute: 'order-items'.   "Translate the Hum 'For . . . '   statement into Smalltalk."   forStatement := HumStatement source: 'For each order-item in the order:'.   "smalltalkCode := forStatement asSmalltalkWithOntology: ontology."  smalltalkCode := ontology codeGenerator generateSmalltalkForStatement: forStatement.   "Expect:    ( blackboard entity: order attribute: 'orderItems' ) do: [ :orderItem |   "   self pattern: '*do:*' matches: smalltalkCode.   self pattern: '*self blackboard entity: ''order'' attribute: ''orderItem''*' matches: smalltalkCode.   self pattern: '*:orderItem |*' matches: smalltalkCode.   self assert: ( '*self ( self*' match: smalltalkCode ) not.   "   Transcript cr; show: 'from test370forStatementAsSmalltalk: ';               cr; show: smalltalkCode; cr.   "         </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; test380ifStatementAsSmalltalk</h3><pre>test380ifStatementAsSmalltalk   "Translate if . . .   to  Smalltalk"   | ifStatement     ifSmalltalk     ontology |   true ifFalse: [ Transcript cr; show: 'test380ifStatementAsSmalltalk skipped'; cr. ^self.].   ifStatement := HumStatement from: 'If account balance is greater than account last-invoice-total :'.   ontology := HumOntology new.   ontology addNouns: #( 'account' 'balance' 'last-invoice-total').   ifSmalltalk := ontology codeGenerator generateSmalltalkForStatement: ifStatement.   self expect:  '(  ( blackboard entity: ''account'' attribute: ''balance'' ) &gt; ( blackboard entity: ''account'' attribute: ''lastInvoiceTotal'' ) )  ifTrue: [' actual: ifSmalltalk .         </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; test381ifStatementAsSmalltalk</h3><pre>test381ifStatementAsSmalltalk   "Translate if . . .   to  Smalltalk"   | ifStatement     ifSmalltalk     ontology |   true ifFalse: [ Transcript cr; show: 'test381ifStatementAsSmalltalk skipped'; cr. ^self.].   ifStatement := HumStatement from: 'If account balance &gt; account last-invoice-total :'.   ontology := HumOntology new.   ontology addNouns: #( 'account' 'balance' 'last-invoice-total').   ifSmalltalk := ontology codeGenerator generateSmalltalkIfFor: ifStatement.   self expect: '(  ( blackboard entity: ''account'' attribute: ''balance'' ) &gt; ( blackboard entity: ''account'' attribute: ''lastInvoiceTotal'' ) )  ifTrue: [' actual: ifSmalltalk .         </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; test382ifStatementAsSmalltalk</h3><pre>test382ifStatementAsSmalltalk   "Translate if . . .   to  Smalltalk"   | ifStatement     ifSmalltalk     ontology |   true ifFalse: [ Transcript cr; show: 'test382ifStatementAsSmalltalk skipped'; cr. ^self.].   ifStatement := HumStatement from: 'If account balance = account last-invoice-total :'.   ontology := HumOntology new.   ontology addNouns: #( 'account' 'balance' 'last-invoice-total').   ifSmalltalk := ontology codeGenerator generateSmalltalkIfFor: ifStatement.   self expect: '(  ( blackboard entity: ''account'' attribute: ''balance'' ) = ( blackboard entity: ''account'' attribute: ''lastInvoiceTotal'' ) )  ifTrue: [' actual: ifSmalltalk.         </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; test383ifStatementAsSmalltalk</h3><pre>test383ifStatementAsSmalltalk   "Translate if . . .   to  Smalltalk"   | ifStatement     ifSmalltalk     ontology |   true ifFalse: [ Transcript cr; show: 'test381ifStatementAsSmalltalk skipped'; cr. ^self.].   ifStatement := HumStatement from: 'If account balance is equal to account last-invoice-total :'.   ontology := HumOntology new.   ontology addNouns: #( 'account' 'balance' 'last-invoice-total').   ifSmalltalk := ontology codeGenerator generateSmalltalkIfFor: ifStatement.   self expect: '(  ( blackboard entity: ''account'' attribute: ''balance'' ) = ( blackboard entity: ''account'' attribute: ''lastInvoiceTotal'' ) )  ifTrue: [' actual: ifSmalltalk.         </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; test384ifStatementAsSmalltalk</h3><pre>test384ifStatementAsSmalltalk   "Translate if . . .   to  Smalltalk"   | ifStatement     ifSmalltalk     ontology |   true ifFalse: [ Transcript cr; show: 'test384ifStatementAsSmalltalk skipped'; cr. ^self.].   ifStatement := HumStatement from: 'If account last-invoice-total is less than  account balance :'.   ontology := HumOntology new.   ontology addNouns: #( 'account' 'balance' 'last-invoice-total').   ifSmalltalk := ontology codeGenerator generateSmalltalkIfFor: ifStatement.   self expect:  '(  ( blackboard entity: ''account'' attribute: ''lastInvoiceTotal'' ) &lt; ( blackboard entity: ''account'' attribute: ''balance'' ) )  ifTrue: [' actual: ifSmalltalk .         </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; test385ifStatementAsSmalltalk</h3><pre>test385ifStatementAsSmalltalk   "Translate if . . .   to  Smalltalk"   | ifStatement     ifSmalltalk     ontology |   true ifFalse: [ Transcript cr; show: 'test385ifStatementAsSmalltalk skipped'; cr. ^self.].   ifStatement := HumStatement from: 'If account last-invoice-total &lt; account balance :'.   ontology := HumOntology new.   ontology addNouns: #( 'account' 'balance' 'last-invoice-total').   ifSmalltalk := ontology codeGenerator generateSmalltalkIfFor: ifStatement.   self expect:  '(  ( blackboard entity: ''account'' attribute: ''lastInvoiceTotal'' ) &lt; ( blackboard entity: ''account'' attribute: ''balance'' ) )  ifTrue: [' actual: ifSmalltalk.         </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; test390elseStatementAsSmalltalk</h3><pre>test390elseStatementAsSmalltalk   "Translate if . . .  else . . .  to Smalltalk"   | ifStatement elseStatement   ifSmalltalk elseSmalltalk  ontology |      false ifFalse: [ Transcript cr; show: '*** test390elseStatementAsSmalltalk is INCOMPLETE ***'; cr. ^self.].      ifStatement := ''.   elseStatement := ''.   ontology := HumOntology new.   ontology addNouns: #().   ifSmalltalk := ifStatement asSmalltalkWithOntology: ontology.   elseSmalltalk := elseStatement asSmalltalkWithOntology: ontology.   "TODO: Figure out how to translate 'Else:' from Hum to Smalltalk."   self shouldBeImplemented.   self assert: ( '**' match: ifSmalltalk ).   self assert: ( '**' match: elseSmalltalk ).         </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; test710translateFrame4ActionToSmalltalk</h3><pre>test710translateFrame4ActionToSmalltalk   "Given: a Hum action frame.   When: translated to Smalltalk   Then: the resulting code is usable.   "   | frameEditor ontology code |   ontology := HumOntology new.      "Initialize for an Action Frame."   frameEditor := HumFrameUpdater ontology: ontology                                       role: 'Cook'                                    action: 'Bake the pan in the oven for the time given in the recipe.'.   frameEditor appendInstructionStatement: 'Open the oven door.'.   frameEditor appendInstructionStatement: 'Place the pan in the oven.'.   frameEditor appendInstructionStatement: 'Close the oven door.'.   frameEditor appendInstructionRole: 'Oven'                         statement: 'Heat for the time given in the recipe.'                           comment: 'We have a smart oven.'.      ontology storeFrame: ( frameEditor frame ).   ontology addNouns: #( 'pan' 'oven' 'recipe' 'time' 'door' ).   code := ontology codeGenerator generateSmalltalk.      "Test: Title line is rendered."   self assert: ( '*bakePanInOvenForTimeGivenInRecipeQpan: aPan oven: aOven time: aTime recipe: aRecipe*' match: code ).      "First instruction is rendered."   self assert: ( '*openOvenDoorQoven: aOven door: aDoor*' match: code ).      "2nd instruction is rendered."   self assert: ( '*placePanInOvenQpan: aPan oven: aOven*' match: code ).   "3rd instruction is rendered."   self assert: ( '*closeOvenDoorQoven: aOven door: aDoor*' match: code ).   "4th (delegated) inststruction is rendered"   self assert: ( '*heatForTimeGivenInRecipeQtime: aTime recipe: aRecipe*' match: code ).   "Comment is rendered"   self assert: ( '*smart oven*' match: code ).   "Role is rendered."   self assert: ( '*Oven:*' match: code ).      "Transcript cr; show: 'Generated Smalltalk:'; cr; show: code; cr."      "TODO: Review the translation methods to assure consistency in how nouns are handled.   Question: Is the blackboard used in a consistent way?    *** blackboard is not used above, but is seen in Java translation. ***   "   "code inspect."   </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; test720translateFrame4ActionToSmalltalk</h3><pre>test720translateFrame4ActionToSmalltalk   "Given: a Hum action frame.   When: translated to Smalltalk   Then: the resulting code is usable.   (This test is like the last test (test710) but 'door' is not in the list of nouns,    and we get a slightly different result.)   "   | frameEditor ontology code |   ontology := HumOntology new.      "Initialize for an Action Frame."   frameEditor := HumFrameUpdater ontology: ontology                                                    role: 'Cook' action: 'Bake the pan in the oven for the time given in the recipe.'.   frameEditor appendInstructionStatement: 'Open the oven door.'.   frameEditor appendInstructionStatement: 'Place the pan in the oven.'.   frameEditor appendInstructionStatement: 'Close the oven door.'.   frameEditor appendInstructionRole: 'Oven'                                        statement: 'Heat for the time given in the recipe.'                                           comment: 'We have a smart oven.'.      ontology storeFrame: ( frameEditor frame ).   ontology addNouns: #( 'pan' 'oven' 'recipe' 'time' ).   code := ontology codeGenerator generateSmalltalk.   "Transcript cr; show: 'Generated Smalltalk:'; cr; show: code; cr."      "Test: Title line is rendered."   self assert: ( '*bakePanInOvenForTimeGivenInRecipeQpan: aPan oven: aOven time: aTime recipe: aRecipe*' match: code ).      "First instruction is rendered."   self assert: ( '*openOvenDoorQoven: aOven*' match: code ).      "2nd instruction is rendered."   self assert: ( '*placePanInOvenQpan: aPan oven: aOven*' match: code ).   "3rd instruction is rendered."   self assert: ( '*closeOvenDoorQoven: aOven*' match: code ).   "4th (delegated) inststruction is rendered"   self assert: ( '*aOven heatForTimeGivenInRecipeQtime: aTime recipe: aRecipe*' match: code ).   "Comment is rendered"   self assert: ( '*smart oven*' match: code ).   "Role is rendered."   self assert: ( '*Oven:*' match: code ).         </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; test730translateFrame4ActionToSmalltalkExdentToBlockEnd</h3><pre>test730translateFrame4ActionToSmalltalkExdentToBlockEnd   "Given: a Hum action frame.   When: translated to Smalltalk   Then: the resulting code reflects the block structure as indicated by indentation.   "   | frameEditor ontology code |      true ifFalse: [ Transcript cr; show: 'test730translateFrame4ActionToSmalltalkExdentToBlockEnd is turned off'; cr. ].   ontology := HumOntology new.      "Initialize for an Action Frame."   frameEditor := HumFrameUpdater ontology: ontology                                                    role: 'Cook' action: 'Fulfill order.'.   "Enter an iteration statement."   frameEditor appendInstructionStatement: '. For each order-item in the order: '.   "Enter some inside the loop. (It should be indented when rendered.)"   "THINK: Should we require indentation here."   frameEditor appendInstructionStatement: '. . Pull order-item from stock and place on cart.'.   "Next statement has no indent. That signals end of the iteration block."   frameEditor appendInstructionStatement: '. Ship the order to the order-address.'.         ontology storeFrame: ( frameEditor frame ).   ontology addEntity: 'order' attributes: #(  'order-items' 'order-address' customer ).   ontology addEntity: 'order-item' attributes: #( 'catalog-id' 'product-label' 'quantity' 'unit-price'  ).   ontology addNoun: 'quantity' isA: 'measure'.   ontology addEntity: 'address' attributes: #( 'street-line1' 'street-line2' 'postal-code' ).   ontology addEntity: 'postal-code' attributes: #( 'code-string' 'city' ).   ontology addEntity: 'city' attributes: #( 'city-name' 'province' 'state' 'nation' ).   ontology addNouns: #( 'order' 'order-item' 'order-address'  ).      code := ontology codeGenerator generateSmalltalk.   "   Transcript cr;       show: 'test730translateFrame4ActionToSmalltalkExdentToBlockEnd';       cr; show:' Generated Smalltalk:';       cr; show: code; cr.   "   "Test: Title line is rendered."   self assert: ( '*fulfillOrderQorder: aOrder*' match: code ).   "For is implemented by do:"   self assert: ( '*do:*' match: code ).   self assert: ( '*:orderItem*' match: code ).   self assert: ( '*aOrderItem := orderItem*' match: code).   self assert: ( '*Item: aOrderItem*' match: code).   self assert: ( '*blackboard entity: ''order'' attribute: ''orderItem''*' match: code ).   "Look for opening and closing ']' on the block."   self assert: ('*[*' match: code ).   "Watch for proper close on the do: []. "   self assert: ('*].*' match: code ).   "Watch for proper position for closing ']'"   self assert: ( code trimBoth endsWith: ']' ) not.   self assert: ( code trimBoth endsWith: '].' ) not.   self assert: ( '*self ( self*' match: code ) not.      "code inspect."               </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testE210translateActionHeaderToErlang</h3><pre>testE210translateActionHeaderToErlang   "Translate Hum action header to Erlang do pattern.   An actor (role) is implemented as an Erlang process. (?)   When the Dispatcher assigns a task,     it will send a message of the form { role, ActionStatement, NounValues }     to the assigned actor (process).   The actor will implement a mailbox dispatcher      that invokes 'do( {ActionStatement, NounValues} )'   and a do() method that matches the specific action statement.   "   |  ontology humSource actionStatement erlangSource expectedSource quote |   actionStatement := 'Move portable-object from this-location to that-location.'.   humSource := 'Action: ', actionStatement.   "Our strategy involves a generic do( ... ) pattern that receives the message."   "Given: ontology knows which words are nouns"   ontology := HumOntology new.   ontology addNouns: #('portable-object' 'this-location' 'that-location').   "When: Action header is translated to Erlang do header"   erlangSource := ontology codeGenerator generateErlangForActionHeader: humSource.   "Then: The do header looks like 'do( { action-statement, noun-values } )' "   quote := $' asString.   expectedSource := 'do( { ', quote, actionStatement, quote, ',*[*]*} ) -&gt;'.   self assertPattern: ( '*', expectedSource, '*' ) matches: erlangSource.      "TODO: The Erlang boiler plate must assure that the do() will be invoked     for the message { ActionStatement, NounValues}"   </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testE220translateActionCallToErlang</h3><pre>testE220translateActionCallToErlang   "Translate a Hum action call to an Erlang call."   |  ontology humSource actionStatement erlangSource expectedMessage expectedSource quote |   actionStatement := 'Move portable-object from this-location to that-location.'.   humSource := 'Mover: ', actionStatement.   "Our strategy involves a generic calling pattern that sends the message."   "Given: The ontology knows which words are nouns"   ontology := HumOntology new.   ontology addNouns: #('portable-object' 'this-location' 'that-location').   "When: Action call is translated to Erlang call"   erlangSource := ontology codeGenerator generateErlangForActionCall: humSource.   "Then: The message passed to the Dispatcher looks like { roleAtom, ActionStatement, NounValues }."   quote := $' asString.   expectedMessage := 'mover,', quote, actionStatement, quote, ',*[*]*'.   "Note: The role is translated to an Erlang atom."   "self assert: (( '*', expectedMessage, '*' ) match: erlangSource )."   "Then: The call looks like '?CALL({Role,Action,NounValues}).'"   "?CALL is an Erlang macro that will probably become 'gen_supervisor:call( dispatcher, '     -- which invokes an OTP gen_supervisor method"   expectedSource := '?CALL( mover,', quote, actionStatement, quote, ',*[*]* ),'.   "Transcript cr; show: 'in test220translateActionCallToErlang';              cr; show: 'expected: ',expectedSource;              cr; show: ' getting: ',erlangSource; cr."   self assertPattern: ( '*', expectedSource, '*' ) matches: erlangSource.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testE230translateInstructionToErlang</h3><pre>testE230translateInstructionToErlang   "Translate Hum instruction (invoke) to Erlang do()."   |  ontology humSource actionStatement erlangSource   |   actionStatement := 'Move portable-object from this-location to that-location.'.   humSource := '. ', actionStatement.   "Our strategy involves a generic calling pattern that sends the message."   "Given: ontology knows which words are nouns."   "TODO: In the actual instruction the nouns may be replaced by subtypes.    TODO: Some process is needed to match the instruction instance to the appropriate action header.    TODO: Could that process be outside the pure 'translate to Erlang' ?    TODO: This is also where polymorphism comes into the picture.   "   ontology := HumOntology new.   ontology addNouns: #('portable-object' 'this-location' 'that-location').   "When: Action call is translated to Erlang call"   erlangSource := ontology codeGenerator generateErlangForSelfCall: humSource.   self assertPattern: ( '*do( { ''Move portable-object from this-location to that-location.'',*[*]*}*),' ) matches: erlangSource.   </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testE310translatePlanFramesToErlang</h3><pre>testE310translatePlanFramesToErlang   "TODO: Decide how to do this.   Alternative-A:   1. The plan is data.       It can be represented as a dictionary/table in ETS.   2. The plan`s run-time state includes       conditions that have been asserted,      actions currently in-progress,      current job-ticket charges,      and the plan`s blackboard.   3. The Coordinator has actions/methods:      - Assert condition. (Update state and trigger actions.)      - What is current state? (Return run-time state. See #2 above.)      - Cancel goal. (Send cancels to Dispatcher.)   ---   Alternative-B:   1. Each plan-frame is a finite-state-machine (FSM).      The state includes a list of unsatisfied preconditions      which is set via init()      A private performActions method sends {action, Role, Statement, Nouns } to Dispatcher.      The performActions method code (containing those sends) is generated.    2. When a condition is satisfed, an event is broadcast to the set of FSM.       Each frame FSM removes matched preconditions from the list of unsatisfied preconditions.      If there are no more unsatisfied preconditions, the FSM calls its own private performActions method.   Alternative-C:   - Same as B, but there is a single frame module that is data-driven with no frame-specific code.     It is given the list of preconditions and list of action messages via the initialization process     by a higher level process translated from the whole plan.   Discussion:   - I like C best because    (1) It places the entire plan in a single, reasonably readable place.   (2) Debug should be easier.   (3) There is less code (at most one module) to generate.       In fact, the plan-level module can be data-driven.        We only need to generate a data packet in Erlang format.   "   "*** TODO: Write the HumCoordinator agent in Erlang. *** (Confirm that Alternative-C is workable.)"   "*** See: HumCoordinator&gt;&gt;runPlanFrameForCondition: aGoalString ***"   </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testE311translatePreconditionsToErlangList</h3><pre>testE311translatePreconditionsToErlangList   "Translate a plan-frame`s preconditions to an Erlang list.   A Hum coordinator instance (an Erlang FSM?) will match notifications of conditions asserted   against its list of preconditions   and when all of the precondiditions have been asserted will run the action statement.   When the action completes, the coordinator asserts its goal and terminates itself.   "   | erlangCode expected preconditionA preconditionB planFrame  ontology |      ontology := HumOntology new.   "A plan frame should have a goal and at least two preconditions."      planFrame := HumFrame4Plan  ontology: ontology goal: 'Bake a cake per recipe'.   preconditionA := 'Oven is preheated per recipe.'.   planFrame appendPrecondition: preconditionA.   preconditionB := 'Batter is in bake-pan per recipe.'.   planFrame appendPrecondition: preconditionB.   planFrame appendRole: 'Baker' action: 'Bake bake-pan in the oven per recipe.'.      ontology storeFrame: planFrame.   expected := '[',preconditionA quoted,',',preconditionB quoted,']'.    erlangCode := ontology codeGenerator generateErlangForPlanFrame: planFrame.   self assert: ( erlangCode isKindOf: String ).   self assert: ( erlangCode size &gt; 1 ).   self assert: ( '*{*[*]*,*[*]*}*' match: erlangCode ).   self assert: ( ('*',preconditionA,'*') match: erlangCode ).   self assert: ( ('*',preconditionB,'*') match: erlangCode ).   "erlangCode inspect."   </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testE400ReadMe</h3><pre>testE400ReadMe   self skip.   "Thinking Out Loud:   Entities are translated to Erlang records.   Entity values are passed as Erlang data structures.   By implication, this means that attributes are passed by value.   But how should we handle supertypes and attributes that are also entities?   If we pass them by reference (passing a primary-key identifier),       the recieving entity will have to fetch them from World Base.   But, otherwise the caller may have to fill-in (and perhaps fetch).   Alternative-B:   - Perhaps I would just forget about Erlang records and just pass a subset of the BlackBoard.   - Example: [ { noun, noun-value },  { noun, noun-value } ]   Alternative-C:   - The Blackboard is also an Erlang process (or could be).  And we pass its process-ID with statement.   - If we do that, the BlackBoard will become responsible for deciding what data to provide the delegate.      DECIDED (2015-06-25) -- Alternative-B is appropriate solution.   Rationale: What was I thinking when I started on Erlang records?    I've originally intended to pass noun-value pairs in the calling message block.   There is no reason to do that differently in Erlang.   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   The Run-Time will generate calling message structure appropriate to Erlang.   Look for a test in the run-time.    Implementation will probably be responsibility of HumMessage.   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   "</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testE410translateEntityToErlang</h3><pre>testE410translateEntityToErlang   "An entity is translated into an Erlang record structure.   -record( entity, { attribute, attribute, etc })."   |  erlangCode ontology |   self skip. "I've decided that this idea is not a correct design. See testE400ReadMe."   "I will keep this code around for a little while."   ontology := HumOntology new.   ontology addEntity: 'party' attributes: #(  'party-name' 'alphabetized-name' 'address'  ).   ontology addEntity: 'address' attributes: #( 'street-direction' 'street-number' 'street-name' 'postal-code' ).   ontology addEntity: 'postal-code' attributes: #( 'city' 'state-province' 'nation' ).   ontology addNoun: 'person' isA: 'party'.   ontology addEntity: 'person' attributes: #( 'primary-phone-number'   ).   erlangCode := ontology codeGenerator generateErlangForEntity: 'person'.      self assert: ('-record(*person,*{*}*).' match: erlangCode ).      self assert: ('-record(*person,*{*primaryPhoneNumber*}*).' match: erlangCode ) description: 'expect immediate atttribute'.   self assert: ('-record(*person,*{*party*}*).' match: erlangCode ) description: 'expect super-type attribute'.   "Note: This implies that we have records nested in records.    TODO: Decide if we nest records or refer to the inner supertype entity via an identifier."      erlangCode := ontology codeGenerator generateErlangForEntity: 'party'.   self assert: ('-record(*party,*{*partyName*}*).' match: erlangCode ) description: 'expect immediate attribute'.   self assert: ('-record(*party,*{*address*}*).' match: erlangCode ) description: 'expect attribute that is also an entity'.   "TODO: Decide if we nest records or refer to the inner attribute entity via an identifier."   "TODO: . . . If so, it means that every entity has a hidden attribute . . . &lt;entity name&gt;-identifier."   "TODO: Decide how to pass attribute values. -- That will partially resolve the question above."   "TODO: Current implementation does not order the attributes."   "erlangCode inspect."   </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testE500RoleReadMe</h3><pre>testE500RoleReadMe   "Strategy: Each each role becomes an Erlang module."   self skip.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testE510RoleModuleHeader</h3><pre>testE510RoleModuleHeader   "A role becomes a module. Here we check the module declaration."   | erlangCode ontology generator updater instruction01 |   "Create a role-action frame in an ontology."   ontology := HumOntology new.   updater := HumFrameUpdater ontology: ontology  role: 'cook' action: 'Bake a cake per recipe.'.      "Instruction for self."   instruction01 := 'Place cake-pan in oven.'.   updater addActionLine: instruction01.   "Delegated instruction."   updater addActionLine: 'Oven: Bake for bake-time.'.   ontology addNouns: #('cake' 'recipe' 'cake-pan' 'bake-time').   "Define subtype supertype relation."   ontology addNoun: 'bake-time' isA: 'measure'.   updater storeFrameInOntology.   generator := ontology codeGenerator.   self expect: (HumOntologyTranslator) actual: generator class.   erlangCode := generator generateErlangForRole: 'cook'.   self assert: (erlangCode beginsWith: '-module(cook).').   </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testE520RoleModuleHeaderExport</h3><pre>testE520RoleModuleHeaderExport   "A role becomes a module. Here we check the module header export declarations."   | erlangCode ontology generator updater instruction01 |   "Create a role-action frame in an ontology."   ontology := HumOntology new.   updater := HumFrameUpdater ontology: ontology  role: 'cook' action: 'Bake a cake per recipe.'.   "Instruction for self."   instruction01 := 'Place cake-pan in oven.'.   updater addActionLine: instruction01.   "Delegated instruction."   updater addActionLine: 'Oven: Bake for bake-time.'.   ontology addNouns: #('cake' 'recipe' 'cake-pan' 'bake-time').   "Define subtype supertype relation."   ontology addNoun: 'bake-time' isA: 'measure'.   updater storeFrameInOntology.   generator := ontology codeGenerator.   self expect: (HumOntologyTranslator) actual: generator class.   erlangCode := generator generateErlangForRole: 'cook'.   self assert: (erlangCode beginsWith: '-module(cook).').   "Erlang action calls invoke do( {  statementString, NounValues } )."   self pattern: '*-export([do/1]).*' matches: erlangCode.    "TODO: Confirm OTP exports if OTP is used."   </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testE525RoleModuleHeaderMacros</h3><pre>testE525RoleModuleHeaderMacros   "When a role delegates an action, a ?CALL macro is invoked. "   | erlangCode ontology generator updater instruction01 |   "Create a role-action frame in an ontology."   ontology := HumOntology new.   updater := HumFrameUpdater ontology: ontology  role: 'cook' action: 'Bake a cake per recipe.'.   "Instruction for self."   instruction01 := 'Place cake-pan in oven.'.   updater addActionLine: instruction01.   "Delegated instruction."   updater addActionLine: 'Oven: Bake for bake-time.'.   ontology addNouns: #('cake' 'recipe' 'cake-pan' 'bake-time').   "Define subtype supertype relation."   ontology addNoun: 'bake-time' isA: 'measure'.   updater storeFrameInOntology.   generator := ontology codeGenerator.   self expect: (HumOntologyTranslator) actual: generator class.   erlangCode := generator generateErlangForRole: 'cook'.   self assert: (erlangCode beginsWith: '-module(cook).').   "Erlang action calls invoke do( {  statementString, NounValues } )."   self pattern: '*-export([do/1]).*' matches: erlangCode.    "TODO: Confirm OTP exports if OTP is used."   "Check for CALL macro define."   self pattern: '*-define( CALL(*,*,*),*(*,*,*)*)*' matches: erlangCode.   "-define( CALL( Role, Statement, NounValues ), ?TBD( Role, Statement, NounValues )."   "Call is routed to a role-qualified actor via Hum Dispatcher and Hum Messenger."   </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testE530RoleModuleActionFrames</h3><pre>testE530RoleModuleActionFrames   "A role becomes a module. Here we check the module header export declarations."   | erlangCode ontology generator updater quote statementAtom actionString instruction01 instruction02 statement02 |   "Create a role-action frame in an ontology."   ontology := HumOntology new.   actionString :=  'Bake a cake per recipe.'.   updater := HumFrameUpdater ontology: ontology  role: 'cook' action: actionString.   "Instruction for self."   instruction01 := 'Place cake-pan in oven.'.   updater addActionLine: instruction01.   "Delegated instruction."   statement02 := 'Bake for recipe`s bake-time.'.   instruction02 := 'Oven: ', statement02.   updater addActionLine: instruction02.   ontology addNouns: #('cake' 'recipe' 'cake-pan' 'bake-time').   "Define subtype supertype relation."   ontology addNoun: 'bake-time' isA: 'measure'.   "TODO: Noun bake-time is attribute of recipe."   ontology addEntity: 'recipe' attribute: 'bake-time'.   updater storeFrameInOntology.   generator := ontology codeGenerator.   self expect: (HumOntologyTranslator) actual: generator class.   erlangCode := generator generateErlangForRole: 'cook'.   self assert: (erlangCode beginsWith: '-module(cook).').   "Erlang action calls invoke do( {  statementStringAtom, NounValues } )."   self pattern: '*-export([do/1]).*' matches: erlangCode.    "Expect to see function definition corresponding to action statement."   quote := $' asString.   statementAtom := quote, actionString, quote.   self pattern: '*do( { ', statementAtom, ', [*] } ) -&gt;*' matches: erlangCode.   "NounValues become: [ {'cake', Cake}, {'recipe', Recipe} ] -- Note: single-quotes are doubled here."   self pattern: '*do( { ', statementAtom, ', [ {''cake'', Cake}, {''recipe'', Recipe} ] } ) -&gt;*' matches: erlangCode.   "Expect to see self-call corresponding to instruction."   self pattern: '*do( { ', quote, instruction01, quote, ', [*] } ),*' matches: erlangCode.   "NounValues become: [ {'cake-pan', CakePan} ]"   self pattern: '*do( { ', quote, instruction01, quote, ', [ {''cake-pan'', CakePan} ] } ),*' matches: erlangCode.   "Expect to see delegated call via macro."   statementAtom := quote, statement02, quote.   self pattern: '*?CALL( oven,', statementAtom, ', [*] ),*' matches: erlangCode.   "NounValues becomes: [ {'recipe bake-time', BakeTime} ] -- NOTE: Noun bake-time is attribute of recipe."   self pattern: '*?CALL( oven,', statementAtom, ', [ {''*bake-time'', * BakeTime} ] ),*' matches: erlangCode.   "Entity attribute needs a slightly different noun-value key."   self pattern: '*?CALL( oven,', statementAtom, ', [ {''recipe bake-time'', Recipe BakeTime} ] ),*' matches: erlangCode.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH110tranlateEmphasis</h3><pre>testH110tranlateEmphasis   "*text* becomes bold, ~text~ becomes italic, _text_ becomes underline, ^text^ becomes superscript"   | ontology aBlackBoard aMarkupString result code |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard new.   aMarkupString := 'This text is *bold*. This is ~italic~. This will be _underlined_. And this will be ^superscript^. '.   result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.   self expect: '' actual: result.   code := ontology codeGenerator html contents.   self expect: 'This text is &lt;b&gt;bold&lt;/b&gt;. This is &lt;i&gt;italic&lt;/i&gt;. This will be &lt;u&gt;underlined&lt;/u&gt;. And this will be &lt;sup&gt;superscript&lt;/sup&gt;. '       actual: code.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH115tranlateEmphasisAtEnd</h3><pre>testH115tranlateEmphasisAtEnd   "*text* becomes bold, ~text~ becomes italic, _text_ becomes underline, ^text^ becomes superscript"   | ontology aBlackBoard aMarkupString result code |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard new.   aMarkupString := '*To boldly go all the way to the end of line.*'.   result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.   self expect: '' actual: result.   code := ontology codeGenerator html contents.   self expect: '&lt;b&gt;To boldly go all the way to the end of line.&lt;/b&gt;'       actual: code.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH120tranlatePageWidget</h3><pre>testH120tranlatePageWidget   "Translate [page:text] into HTML anchor element"   | ontology aBlackBoard aMarkupString result code |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard new.   aMarkupString := 'To learn more, go to [page:This is only a test].'.   result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.   self expect: '' actual: result.   code := ontology codeGenerator html contents.   self expect: 'To learn more, go to &lt;a href="ThisIsOnlyATest.html"&gt;This is only a test&lt;/a&gt;.'       actual: code.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH125tranlatePageWidgetAtEnd</h3><pre>testH125tranlatePageWidgetAtEnd   "Translate [page:text] into HTML anchor element - test for bug when widget is at line end."   | ontology aBlackBoard aMarkupString result code |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard new.   aMarkupString := '[page: menu item ]'.   result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.   self expect: '' actual: result.   code := ontology codeGenerator html contents.   self expect: '&lt;a href="MenuItem.html"&gt; menu item &lt;/a&gt;'      actual: code.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH130tranlateLinkWidget</h3><pre>testH130tranlateLinkWidget   "Translate [link: text | URL ] into HTML anchor element"   | ontology aBlackBoard aMarkupString result code |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard new.   aMarkupString := 'To learn more, go to [link: Test Driven Development | http://c2.com/cgi/wiki?TestDrivenDevelopment].'.   result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.   self expect: '' actual: result.   code := ontology codeGenerator html contents.   self expect: 'To learn more, go to &lt;a href="http://c2.com/cgi/wiki?TestDrivenDevelopment"&gt;Test Driven Development&lt;/a&gt;.'      actual: code.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH140tranlateImageWidget</h3><pre>testH140tranlateImageWidget   "Translate [link: text | URL ] into HTML anchor element"   | ontology aBlackBoard aMarkupString result code |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard new.   aMarkupString := 'Here is a pretty picture: [image: Pretty Picture | images/PrettyPicture.bmp ].'.   result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.   self expect: '' actual: result.   code := ontology codeGenerator html contents.   self expect: 'Here is a pretty picture: &lt;img src="images/PrettyPicture.bmp" alt="Pretty Picture"/&gt;.'      actual: code.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH210tranlateButtonWidget</h3><pre>testH210tranlateButtonWidget   "Translate [[label]] into HTML button element"   | ontology aBlackBoard aMarkupString result code |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard new.   aMarkupString := '[[Submit]] [[Reset]] [[Preview]] '. "&lt;&lt;&lt;&lt; space at end allows defect to proceed"   result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.   self expect: '' actual: result.   code := ontology codeGenerator html contents.   self expect: '&lt;button name="Submit" type="submit"&gt;Submit&lt;/button&gt; &lt;button name="Reset" type="reset"&gt;Reset&lt;/button&gt; &lt;button name="Preview" type="button"&gt;Preview&lt;/button&gt; '      actual: code.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH215tranlateButtonWidgetAtLineEnd</h3><pre>testH215tranlateButtonWidgetAtLineEnd   "Translate [[label]] into HTML button element -- Test for bug when widget is at end of line."   | ontology aBlackBoard aMarkupString result code |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard new.   aMarkupString := 'some preceeding content and then [[Preview]]'.    result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.   self expect: '' actual: result.   code := ontology codeGenerator html contents.   self expect: 'some preceeding content and then &lt;button name="Preview" type="button"&gt;Preview&lt;/button&gt;'      actual: code.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH216tranlateButtonWidgetAtLineEnd</h3><pre>testH216tranlateButtonWidgetAtLineEnd   "Translate [[label]] into HTML button element -- Test for bug when widget is at end of line."   | ontology aBlackBoard aMarkupString result code |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard new.   aMarkupString := 'some [[Middle Button]] and then [[Edge Button]]'.    result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.   self expect: '' actual: result.   code := ontology codeGenerator html contents.   self deny: ('*[[*]]*' match: code).   self expect: 'some &lt;button name="Middle Button" type="button"&gt;Middle Button&lt;/button&gt; and then &lt;button name="Edge Button" type="button"&gt;Edge Button&lt;/button&gt;'      actual: code.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH220tranlateCheckBox</h3><pre>testH220tranlateCheckBox   "Translate [z] into HTML checkbox element."   | ontology aBlackBoard aMarkupString result code |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard new.   aMarkupString := '[a] Yes, I am lonely. Send me spam.'.    result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.   self expect: '' actual: result.   code := ontology codeGenerator html contents.   self deny: ('*[*]*' match: code).   self expect: '&lt;input type="checkbox" name="a"/&gt; Yes, I am lonely. Send me spam.'      actual: code.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH230tranlateRadioButtons</h3><pre>testH230tranlateRadioButtons   "Translate (a) into HTML radio-button element."   | ontology aBlackBoard aMarkupString result code |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard new.   aMarkupString := 'Are you a member?  (y) Yes.  (n) No.  (d) Not sure.'.    result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.   self expect: '' actual: result.   code := ontology codeGenerator html contents.   self deny: ('*(*)*' match: code).   self expect: 'Are you a member?  &lt;input name="y" type="radio"/&gt; Yes.  &lt;input name="n" type="radio"/&gt; No.  &lt;input name="d" type="radio"/&gt; Not sure.'      actual: code."TODO: FIGURE OUT HOW TO GROUP RADIO BUTTONS."</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH310tranlateTableRow</h3><pre>testH310tranlateTableRow   "Translate | ... | ... | into table elements."   | ontology aBlackBoard aMarkupString  code  viewFrame |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard new.   viewFrame := HumFrame4View new.   aMarkupString := '| column one | column two |'.    viewFrame addMarkUp: aMarkupString.   code := ontology codeGenerator generateHTMLforMarkupLines: viewFrame frameLines blackboard: aBlackBoard.   self deny: ('*|*' match: code).   self expect: '&lt;tr&gt;&lt;td&gt; column one &lt;/td&gt;&lt;td&gt; column two &lt;/td&gt;&lt;/tr&gt;'      actual: code.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH320tranlateTableRowWithEmphasis</h3><pre>testH320tranlateTableRowWithEmphasis   "Translate | ... | ... | into table elements."   | ontology aBlackBoard aMarkupString code  viewFrame |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard new.   viewFrame := HumFrame4View new.   aMarkupString := '| *Product* | *Description* |'.    viewFrame addMarkUp: aMarkupString.   code := ontology codeGenerator generateHTMLforMarkupLines: viewFrame frameLines blackboard: aBlackBoard.   self deny: ('*|*' match: code).   self expect: '&lt;tr&gt;&lt;td&gt; &lt;b&gt;Product&lt;/b&gt; &lt;/td&gt;&lt;td&gt; &lt;b&gt;Description&lt;/b&gt; &lt;/td&gt;&lt;/tr&gt;'      actual: code.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH330tranlateHeading</h3><pre>testH330tranlateHeading   "Translate !!! into HTML heading"   | ontology aBlackBoard aMarkupString code  viewFrame |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard new.   viewFrame := HumFrame4View new.   aMarkupString := '!!! Heading Level 3'.    viewFrame addMarkUp: aMarkupString.   code := ontology codeGenerator generateHTMLforMarkupLines: viewFrame frameLines blackboard: aBlackBoard.   self deny: ('*!*' match: code).   self assert: ('*&lt;h3&gt;*Heading*&lt;/h3&gt;*' match: code).   self expect: '&lt;h3&gt; Heading Level 3&lt;/h3&gt;' trimBoth      actual: code trimBoth.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH340tranlateHeadingWithEmphasis</h3><pre>testH340tranlateHeadingWithEmphasis   "Translate !!! into HTML heading"   | ontology aBlackBoard aMarkupString code  viewFrame |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard new.   viewFrame := HumFrame4View new.   aMarkupString := '!!! Heading Level _3_'.    viewFrame addMarkUp: aMarkupString.   code := ontology codeGenerator generateHTMLforMarkupLines: viewFrame frameLines blackboard: aBlackBoard.   self deny: ('*!*' match: code).   self assert: ('*&lt;h3&gt;*Heading*&lt;u&gt;3&lt;/u&gt;*&lt;/h3&gt;*' match: code).   self expect: '&lt;h3&gt; Heading Level &lt;u&gt;3&lt;/u&gt;&lt;/h3&gt;' trimBoth      actual: code trimBoth.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH350tranlateListItem</h3><pre>testH350tranlateListItem   "Translate !!! into HTML heading"   | ontology aBlackBoard aMarkupString code  viewFrame |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard new.   viewFrame := HumFrame4View new.   aMarkupString := '--- Item at indent level 3'.    viewFrame addMarkUp: aMarkupString.   code := ontology codeGenerator generateHTMLforMarkupLines: viewFrame frameLines blackboard: aBlackBoard.   self deny: ('*!*' match: code).   self assert: ('*&lt;item3&gt;*Item*&lt;/item3&gt;*' match: code).   self expect: '&lt;item3&gt; &bull;  Item at indent level 3&lt;/item3&gt;'      actual: code.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH360tranlateListItemWithEmphasis</h3><pre>testH360tranlateListItemWithEmphasis   "Translate !!! into HTML heading"   | ontology aBlackBoard aMarkupString code  viewFrame |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard new.   viewFrame := HumFrame4View new.   aMarkupString := '--- Item at indent level _3_.'.    viewFrame addMarkUp: aMarkupString.   code := ontology codeGenerator generateHTMLforMarkupLines: viewFrame frameLines blackboard: aBlackBoard.   self deny: ('*!*' match: code).   self assert: ('*&lt;item3&gt;*Item*&lt;u&gt;3&lt;/u&gt;*&lt;/item3&gt;*' match: code).   self expect: '&lt;item3&gt; &bull;  Item at indent level &lt;u&gt;3&lt;/u&gt;.&lt;/item3&gt;'       actual: code.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH410tranlateAttributeWidget</h3><pre>testH410tranlateAttributeWidget   "Translate [attribute] into input tag."   | ontology aBlackBoard aMarkupString code  result |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard worldbase: 'none'.   aBlackBoard businessEvent: 'testH410tranlateAttributeWidget'.   aMarkupString := ' name: [user-name]'.    ontology addEntity: 'user' attribute: 'user-name'.   aBlackBoard setEntityName: 'user' attribute: 'user-name' toValue: 'Billy Buyer'.   ontology codeGenerator contextEntity: 'user'.   result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.   code := ontology codeGenerator html contents.   self assert: ( '*name:*&lt;input*' match: code ).   self expect: ' name: &lt;input type="text" name="user:user-name" value="Billy Buyer"/&gt;'      actual: code.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH420tranlateTextAreaWidget</h3><pre>testH420tranlateTextAreaWidget   "Translate [attribute 9] into textarea tag."   | ontology aBlackBoard aMarkupString code  result |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard worldbase: 'none'.   aBlackBoard businessEvent: 'testH420tranlateTextAreaWidget'.   aMarkupString := ' description: [description 5]'.    ontology addEntity: 'user' attribute: 'description'.   aBlackBoard setEntityName: 'user' attribute: 'description' toValue: 'This text   has more than one line.   It could go on for many lines.   But five lines should be enough most of the time.   '.   ontology codeGenerator contextEntity: 'user'.   result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.   code := ontology codeGenerator html contents.   self assert: ( '*description:*&lt;textarea*rows="5"*' match: code ).   self expect: ' description: &lt;textarea type="text" name="description" rows="5"&gt;This text   has more than one line.   It could go on for many lines.   But five lines should be enough most of the time.   &lt;/textarea&gt;'      actual: code.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testH430tranlateEntityAttributeWidget</h3><pre>testH430tranlateEntityAttributeWidget   "Translate [entity`s attribute] into input tag."   | ontology aBlackBoard aMarkupString code  result |   ontology := HumOntology new.   aBlackBoard := HumBlackBoard worldbase: 'none'.   aBlackBoard businessEvent: 'testH430tranlateEntityAttributeWidget'.   aMarkupString := ' name: [user`s name]'.    ontology addEntity: 'user' attribute: 'name'.   aBlackBoard setEntityName: 'user' attribute: 'name' toValue: 'Billy Buyer'.   ontology codeGenerator contextEntity: 'user'.   result := ontology codeGenerator generateHTMLforMarkupString: aMarkupString blackboard: aBlackBoard.   code := ontology codeGenerator html contents.   self assert: ( '*name:*&lt;input*' match: code ).   self expect: ' name: &lt;input type="text" name="user:name" value="Billy Buyer"/&gt;'      actual: code.</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testJ805translateStatementToCamelcase</h3><pre>testJ805translateStatementToCamelcase   "A statement is translated directly to CamelCase."   | ontology statement s |   ontology := HumOntology new.   statement := HumStatement from: 'Add incoming-count to stock-count, giving updated-stock-count.'.   ontology addNouns: #( 'incoming-count' 'stock-count' 'updated-stock-count' ).   s := statement asCamelCaseWithOntology: ontology.   self assert: ( s = 'addIncomingCountToStockCountGivingUpdatedStockCount' ).</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testJ806translateStatementToCamelcase</h3><pre>testJ806translateStatementToCamelcase   "A statement is translated directly to CamelCase, but articles are dropped."   | ontology statement s |   ontology := HumOntology new.   statement := HumStatement from: 'Add the incoming-count to the stock-count, giving the updated-stock-count.'.   ontology addNouns: #( 'incoming-count' 'stock-count' 'updated-stock-count' ).   s := statement asCamelCaseWithOntology: ontology.   self assert: ( s = 'addIncomingCountToStockCountGivingUpdatedStockCount' ).</pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testJ810translateFrame4ActionToJava</h3><pre>testJ810translateFrame4ActionToJava   "Given: a Hum action frame.   When: translated to Java   Then: the resulting code is usable.   "   | frameEditor ontology code |   ontology := HumOntology new.      "Initialize for an Action Frame."   frameEditor := HumFrameUpdater ontology: ontology                                       role: 'Cook'                         action: 'Bake the pan in the oven for the time given in the recipe.'.   frameEditor appendInstructionStatement: 'Open the oven door.'.   frameEditor appendInstructionStatement: 'Place the pan in the oven.'.   frameEditor appendInstructionStatement: 'Close the oven door.'.   frameEditor appendInstructionRole: 'Oven'                         statement: 'Heat for the time given in the recipe.'                           comment: 'We have a smart oven.'.      ontology storeFrame: ( frameEditor frame ).   ontology addNouns: #( 'pan' 'oven' 'recipe' 'time' 'door' ).   ontology compileAllFrames.   code := ontology codeGenerator asJava.      "Transcript cr; show: 'test810translateFrame4ActionToJava Generated Java'; cr; show: code; cr."         "Test: Title line is rendered."   self assert: ( '*bakePanInOvenForTimeGivenInRecipe( Pan aPan, Oven aOven, Time aTime, Recipe aRecipe ) {*' match: code ).      "TODO: The generated Java code (see below) will not compile because 'aDoor' is not defined."   "QUESTION: Is 'aDoor' a noise-word in this context? Do we really need it?"   "QUESTION: Should we/Could we fix the problem by adding a local variable declaration where needed?"      "First instruction is rendered."   self assert: ( '*this.openOvenDoor( aOven, aDoor );*' match: code ).      "2nd instruction is rendered."   self assert: ( '*this.placePanInOven( aPan, aOven );*' match: code ).   "3rd instruction is rendered."   self assert: ( '*this.closeOvenDoor( aOven, aDoor );*' match: code ).   "4th (delegated) inststruction is rendered"   self assert: ( '*aOven.heatForTimeGivenInRecipe( aTime, aRecipe ); *' match: code ).   "Comment is rendered"   self assert: ( '*smart oven*' match: code ).   "Code ends with a bracket"   self assert: ( code endsWith: ( '} // Actor: Cook', String cr ) ).   "Code should not contain doubled semi-colon.  (Test for bug)"   self assert: ( '*;   ;*' match: code ) not.      "code inspect."            </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testJ811translateFrame4ActionToJava</h3><pre>testJ811translateFrame4ActionToJava   "Given: a Hum action frame with a hyphenated noun.   When: translated to Java   Then: the resulting code is usable.   "   | frameEditor ontology code |   ontology := HumOntology new.      "Initialize for an Action Frame."   frameEditor := HumFrameUpdater ontology: ontology                                       role: 'Cook'                         action: 'Bake the cake-pan in the oven for the time given in the recipe.'.   frameEditor appendInstructionStatement: 'Open the oven door.'.   frameEditor appendInstructionStatement: 'Place the cake-pan in the oven.'.   frameEditor appendInstructionStatement: 'Close the oven door.'.   frameEditor appendInstructionRole: 'Oven'                                     statement: 'Heat for the time given in the recipe.'                                       comment: 'We have a smart oven.'.      ontology storeFrame: ( frameEditor frame ).   ontology addNouns: #( 'cake-pan' 'oven' 'recipe' 'time' 'door' ).   code := ontology codeGenerator asJava.      "Transcript cr; show: 'testJ811translateFrame4ActionToJava Generated Java'; cr; show: code; cr."         "Test: Title line is rendered."   self assert: ( '*bakeCakePanInOvenForTimeGivenInRecipe( CakePan aCakePan, Oven aOven, Time aTime, Recipe aRecipe ) {*' match: code ).      "TODO: The generated Java code (see below) will not compile because 'aDoor' is not defined."      "First instruction is rendered."   self assert: ( '*this.openOvenDoor( aOven, aDoor );*' match: code ).      "2nd instruction is rendered."   self assert: ( '*this.placeCakePanInOven( aCakePan, aOven );*' match: code ).   "3rd instruction is rendered."   self assert: ( '*this.closeOvenDoor( aOven, aDoor );*' match: code ).   "4th (delegated) inststruction is rendered"   self assert: ( '*aOven.heatForTimeGivenInRecipe( aTime, aRecipe ); *' match: code ).   "Comment is rendered"   self assert: ( '*smart oven*' match: code ).   "Code ends with a bracket"   self assert: ( code endsWith: ( '} // Actor: Cook', String cr ) ).   "Code should not contain doubled semi-colon.  (Test for bug)"   self assert: ( '*;   ;*' match: code ) not.      "TODO: Test for case where noun is a hyphenated term."   "code inspect."         </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testJ820translateDictionaryToJava</h3><pre>testJ820translateDictionaryToJava   "Entity becomes class. Attribute becomes String, Category, ..."   | ontology code |   ontology := HumOntology new.   "Define a few relations."   ontology addEntity: 'party' attributes: #(  'party-name' 'alphabetized-name' 'address'  ).   ontology addEntity: 'address' attributes: #( 'street-direction' 'street-number' 'street-name' 'postal-code' ).   ontology addEntity: 'postal-code' attributes: #( 'city' 'state-province' 'nation' ).   ontology addNoun: 'person' isA: 'party'.   ontology addEntity: 'person' attributes: #( 'primary-phone-number'   ).   ontology addNoun: 'organization' isA: 'party'.   ontology addEntity: 'organization' attributes: #('organization-type').   ontology categoriesOf: 'organization-type' include: #('internal' 'external').   ontology addNoun: 'contact' isA: 'person'.   ontology addEntity: 'contact' attributes: #( 'process-role' 'represents-organization' ).      code := ontology codeGenerator asJava.   "Transcript cr; show: 'test820translateDictionaryToJava'; cr; show: code; cr; show: '%%%%%%%%%%'; cr."         "Expect each entity to become a class declaration."   self assert: ( '*class Party*' match: code ).   self assert: ( '*class Address*' match: code ).   self assert: ( '*class PostalCode*' match: code ).   self assert: ( '*class Person*' match: code ).      "Entities extend their Hum supertype."   self assert: ( '*Person extends Party*' match: code ).   self assert: ( '*PostalCode extends Entity*' match: code ).   self assert: ( '*Address extends Entity*' match: code ).      "Attributes with no supertype are Strings by default"   self assert: ( '*public String streetDirection*' match: code).   self assert: ( '*public String streetNumber*' match: code).   self assert: ( '*public String stateProvince*' match: code).   self assert: ( '*public String nation*' match: code).   self assert: ( '*public String city*' match: code).   self assert: ( '*public String primaryPhoneNumber*' match: code).      "Attributes with supertypes declare accordingly"   self assert: ( '*public PostalCode postalCode*' match: code).   self assert: ( '*public Address address*' match: code).   self assert: ( '*public Organization representsOrganization;*' match: code).       "Classes have closing brace."   self assert: ( '*} // Entity: Party*' match: code).      "Expect 'extends' clauses for subtypes."   self assert: ( '*class Contact*' match: code ) .    self assert: ( '*class Organization*' match: code ) .   self assert: ( '*Contact extends Person*' match: code ) .   self assert: ( '*Organization extends Party*' match: code ) .      "Expect 'category' to be detected."   self assert: ('*public Category organizationType;*' match: code).      "Check for bug:"   self assert: ('*String ,;*' match: code) not.      "code inspect."                           </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testJ825translateCollectionNounToJava</h3><pre>testJ825translateCollectionNounToJava   "Test a more complicated dictionary with a collection and recursive structure."   | ontology code |   ontology := HumOntology new.   "Define a few relations."   ontology addEntity: 'location' attributes: #( 'latitude' 'longitude' ).   ontology addEntity: 'route' attributes: #('route-name' 'from-location' 'to-location' 'route-segments').   ontology addNoun: 'route-segment' isA: 'route'.  "RECURSIVE !!!"   ontology addEntity: 'route-segment' attributes: #('segment-name' 'segment-length').   ontology addNoun: 'segment-length' isA: 'measure'.   "Translate to Java"      code := ontology codeGenerator asJava.   "Expect each entity to become a class declaration."   self assert: ( '*class Route*' match: code ).   self assert: ( '*class RouteSegment*' match: code ).      "Entities extend their Hum supertype."   self assert: ( '*RouteSegment extends Route*' match: code ).      "Attributes with no supertype are Strings by default"   self assert: ( '*public Measure segmentLength*' match: code).      "Attributes with supertypes declare accordingly"   self assert: ( '*public Location fromLocation*' match: code).      "Classes have closing brace."   self assert: ( '*} // Entity: Route*' match: code).      "TODO: By default a collection is a Bag&lt;Entity&gt;.     TODO: It might work better if Hum run-time handles the collection."   self assert: ( '*public Bag&lt;RouteSegment&gt; routeSegments;*' match: code ) description: 'Collection not handled'.         "code  inspect."                           </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testJ830translateFrame4ActionToJavaExdentToBlockEnd</h3><pre>testJ830translateFrame4ActionToJavaExdentToBlockEnd   "Given: a Hum action frame.   When: translated to Java   Then: the resulting code is usable.   Then: the resulting code reflects the block structure as indicated by indentation.   "   | frameEditor ontology code tab |      true ifFalse: [ Transcript cr; show: 'test830translateFrame4ActionToJavaExdentToBlockEnd is turned off'; cr. ].   ontology := HumOntology new.      "Initialize for an Action Frame."   frameEditor := HumFrameUpdater ontology: ontology role: 'Cook' action: 'Fulfill order.'.   "Enter an iteration statement."   frameEditor appendInstructionStatement: '. For each order-item in the order: '.   "Enter some inside the loop. (It should be indented when rendered.)"   "THINK: Should we require indentation here."   frameEditor appendInstructionStatement: '. . Pull order-item quantity from stock and place on cart.'.   "Next statement has no indent. That signals end of the iteration block."   frameEditor appendInstructionStatement: '. Ship the order to the order-address.'.         ontology storeFrame: ( frameEditor frame ).   ontology addEntity: 'order' attributes: #(  'order-items' 'order-address' customer ).   ontology addEntity: 'order-item' attributes: #( 'catalog-id' 'product-label' 'quantity' 'unit-price'  ).   ontology addNoun: 'quantity' isA: 'measure'.   ontology addEntity: 'address' attributes: #( 'street-line1' 'street-line2' 'postal-code' ).   ontology addEntity: 'code' attributes: #( key value ).   ontology addEntity: 'postal-code' attributes: #( city ).   ontology addEntity: 'city' attributes: #( name province state nation ).   ontology addNouns: #( 'order' 'order-item' 'order-address'  ).      code := ontology codeGenerator asJava.   "   Transcript cr;       show: 'test830translateFrame4ActionToJavaExdentToBlockEnd';       cr; show:' Generated Java:';       cr; show: code; cr."      "Test: Title line is rendered."   self assert: ( '*fulfillOrder( Order aOrder ) {*' match: code ).      "Test: 'For each order-item in the order:' "   self assert: ( '*for (*:*)*' match: code ).   self assert: ( '*aOrderItem*' match: code).   self assert: ( '*OrderItem orderItem*' match: code ).   self assert: ( '*for ( OrderItem orderItem : order.orderItems )*' match: code ).                                   "Look for opening and closing '} // for' on the block."   self assert: ('*{*' match: code ).   tab := String tab.   self assert: ('*',tab,'}*' match: code ).      "code inspect."                     </pre><h3>Hum-Tests -- HumOntologyTranslatorTests &gt;&gt; testJ840translatePlanFrameToJava</h3><pre>testJ840translatePlanFrameToJava   "The plan is data, so translation involves translating each goal frame into a series of Java setters.   /* prologue */   public HumPlan plan = new HumPlan();   public HumPlanFrame frame = new HumPlanFrame();   /* for each goal frame in the ontology */   frame.setGoal('...')      .addPrecondition('...')      .addPrecondition('...')      .addAction('...');   plan.addGoalFrame(frame);      "   | ontology planFrame javaCode |   ontology := HumOntology new.   planFrame := HumFrame4Plan ontology: ontology goal: 'Bake a cake per recipe.'.   planFrame       appendPrecondition: 'Oven is preheated per recipe.';         appendPrecondition: 'Batter is mixed per recipe ingredients.';      appendPrecondition: 'Batter is in cake-pan per recipe pan-size.';      appendRole: 'Baker' action: 'Bake the cake-pan per recipe baking-time.' comment: ''.   ontology addPlanFrame: planFrame ForGoal: 'Bake a cake per recipe.'.      javaCode := ontology codeGenerator generateJavaForPlanFrame: planFrame.      self assert: ( javaCode isKindOf: String ).   self assert: ( '*planFrame.setGoal("Bake a cake per recipe.")*' match: javaCode ).   self assert: ( '*planFrame*.addPrecondition("Oven is preheated per recipe.")*' match: javaCode ).   self assert: ( '*planFrame*.addPrecondition("Batter is mixed per recipe ingredients.")*' match: javaCode ).   self assert: ( '*planFrame*.addPrecondition("Batter is in cake-pan per recipe pan-size.")*' match: javaCode ).   self assert: ( '*planFrame*.addAction("Baker: Bake the cake-pan per recipe baking-time.")*' match: javaCode ).   "javaCode inspect."               </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; aReadMe</h3><pre>aReadMe   "See the class description for the intended (future) tests."   ^'See the class description for the intended (future) tests.'   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; storeInOntology:fromFrameUpdater:</h3><pre>storeInOntology: aHumOntology fromFrameUpdater: frameUpdater1   | frame1 identifier frameUpdater2 frame2 frameUpdater3 frame3 |   "The frame editor receives the command to store the frame from the user interface (Scribe)."   frameUpdater1 storeFrameInOntology.      "The frame will now have a uniqueIdentifier."   frame1 := frameUpdater1 frame.   self assert: ( frame1 isKindOf: HumFrame ).   identifier := frame1 uniqueIdentifier.   self assert: ( identifier isKindOf: HumIdentifier ).      "We can use the identifier to fetch the frame into another frameUpdater."   frameUpdater2 := HumFrameUpdater ontology: aHumOntology loadFrameByIdentifier: identifier.   self assert: (frameUpdater2 isKindOf: HumFrameUpdater ).      "Check the content."   frame2 := frameUpdater2 frame.   self assert: ( frame2 isKindOf:  (frame1 class) ).   self assert: ( frame1 titleLine = frame2 titleLine ).   self assert: ( frame1 titleLine sameAs: frame2 titleLine ).   self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).   self assert: ( frame1 frameLines at: 1) = ( frame2 frameLines at: 1 ).   self assert: (( frame1 frameLines at: 1) sameAs: ( frame2 frameLines at: 1 )).      frameUpdater3 := HumFrameUpdater ontology: aHumOntology loadFrameByName: (frame1 frameName).   self assert: (frameUpdater2 isKindOf: HumFrameUpdater ).      "Check the content."   frame3 := frameUpdater3 frame.   self assert: ( frame3 isKindOf:  (frame1 class) ).   self assert: ( frame1 titleLine = frame3 titleLine ).   self assert: ( frame1 titleLine sameAs: frame3 titleLine ).   self assert: ( frame1 frameLines size ) = ( frame3 frameLines size ).   self assert: ( frame1 frameLines at: 1) = ( frame3 frameLines at: 1 ).   self assert: (( frame1 frameLines at: 1) sameAs: ( frame3 frameLines at: 1 )).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test110newOntology</h3><pre>test110newOntology   "PA initializes (re-initializes) to an empty ontology."   | zPA |   zPA := HumProgrammersAssistant new.   zPA clearOntology.   self assert: (zPA ontology nouns isEmpty).</pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test120saveOntology</h3><pre>test120saveOntology   "PA saves (writes) the ontology to a file."   | zPA |   false ifFalse: [ Transcript cr; show: 'test120saveOntology turned off - No way to save an ontology!'. ^self ].   zPA  := HumProgrammersAssistant new.   zPA clearOntology.   zPA saveOntologyOnFileNamed: 'HumPA-test.ontology'.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test130loadOntology</h3><pre>test130loadOntology   "PA loads (reads) the ontology fram a file where it was saved previously."   | zPA |   false ifFalse: [ Transcript cr; show: 'test130loadOntology turned off - No way to save an ontology!'. ^self ].   zPA := HumProgrammersAssistant new.   zPA clearOntology.   zPA saveOntologyOnFileNamed: 'HumPA-test.ontology'.   zPA loadOntologyFromSavedFileNamed: 'HumPA-test.ontology'.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test200createFrame</h3><pre>test200createFrame   "There are seven types of frame: (See HumFrame hierarchy)   . plan frame   . action frame   . dictionary frame   . view frame   . vignette frame   . comment frame   . data frame   Each type of frame should have suitable constructors.   "   self skip.</pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test220createFrame4Plan</h3><pre>test220createFrame4Plan   "Test a plan frame (goal frame).   ---   Goal: Cake is baked according to recipe.   Preconditions:   . Oven is preheated to the temperature given in the recipe.   . The recipe`s batter is in a prepared cake pan.   Action:   . Oven: Bake the pan in the oven for the time given in the recipe.   ---   "   | frameUpdater ontology |   ontology := HumOntology new.      "Initialize for a Plan Frame."   frameUpdater := HumFrameUpdater ontology: ontology goal: 'Cake is baked according to recipe.'.      "Append precondition lines."   frameUpdater appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.   frameUpdater appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.   "Finish with action statement."   frameUpdater appendRole: 'Oven' action: 'Bake the pan in the oven for the time given in the recipe.' .      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Plan ).   self assert: ( frameUpdater frame frameLines size = 3 ).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test230createFrame4Action</h3><pre>test230createFrame4Action   "The frame editor instance knows what kind of frame it is editing.   "   | frameUpdater ontology |   ontology := HumOntology new.      "Initialize for an Action Frame."   frameUpdater := HumFrameUpdater ontology: ontology                                       role: 'Role'                                                 action: 'Bake the pan in the oven for the time given in the recipe.'.   "Append instruction lines."   frameUpdater appendInstructionStatement: 'Open the oven door.'.   frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.   frameUpdater appendInstructionStatement: 'Close the oven door.'.      "Append an instruction that is delegated"   frameUpdater appendInstructionRole: 'Oven' statement: 'Bake for the time given.'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Action ).      self assert: ( frameUpdater frame frameLines size = 4 ).      </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test231formatFrame4Action</h3><pre>test231formatFrame4Action  "The frame editor instance knows what kind of frame it is editing.  "  | frameUpdater ontology prettyPrint q ideal |  ontology := HumOntology new.    "Initialize for an Action Frame."  frameUpdater := HumFrameUpdater ontology: ontology                                      role: 'Baker'                                 action: 'Bake the pan in the oven for the time given in the recipe.'.  "Append instruction lines."  frameUpdater appendInstructionStatement: 'Open the oven door.'.  frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.  frameUpdater appendInstructionStatement: 'Close the oven door.'.    "Append an instruction that is delegated"  frameUpdater appendInstructionRole: 'Oven' statement: 'Bake for the time given.'.    self assert: ( frameUpdater notNil ).  self assert: ( frameUpdater frame isMemberOf: HumFrame4Action ).    self assert: ( frameUpdater frame frameLines size = 4 ).    prettyPrint := frameUpdater prettyPrint.  ideal := '&lt;hr/&gt;      &lt;HumFrame&gt;         &lt;ActionFrame&gt;            &lt;frameTitle&gt;               Role: Baker -- Bake the pan in the oven for the time given in the recipe.            &lt;/frameTitle&gt;            &lt;br/&gt;&lt;b&gt;Role: &lt;/b&gt;            &lt;role&gt;Baker.&lt;/role&gt;            &lt;br/&gt;&lt;b&gt;Action: &lt;/b&gt;            &lt;action&gt;Bake the pan in the oven for the time given in the recipe.&lt;/action&gt;            &lt;br/&gt;            &lt;InstructionLine class="indent1" &gt;               &lt;statement&gt;                  Open the oven door.               &lt;/statement&gt;            &lt;/InstructionLine&gt;            &lt;br/&gt;            &lt;InstructionLine class="indent1" &gt;               &lt;statement&gt;                  Place the pan in the oven.               &lt;/statement&gt;            &lt;/InstructionLine&gt;            &lt;br/&gt;            &lt;InstructionLine class="indent1" &gt;               &lt;statement&gt;                  Close the oven door.               &lt;/statement&gt;            &lt;/InstructionLine&gt;            &lt;br/&gt;            &lt;InstructionLine class="indent1" &gt;               &lt;role&gt;Oven&lt;/role&gt;               :               &lt;statement&gt;                  Bake for the time given.               &lt;/statement&gt;            &lt;/InstructionLine&gt;         &lt;/ActionFrame&gt;      &lt;/HumFrame&gt;'.  q := HumCalculator string: prettyPrint isLike: ideal.  self assert: q description: 'Expecting prettyPrint to match ideal'    </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test240createFrame4View</h3><pre>test240createFrame4View   "The frame editor instance knows what kind of frame it is editing.   "   | frameUpdater ontology |   ontology := HumOntology new.      "Initialize for a View Frame."   frameUpdater := HumFrameUpdater ontology: ontology viewEntity: 'recipe.'.      "Add markup lines."   frameUpdater addMarkUp: '!! Recipe'.   frameUpdater addMarkUp: ' recipe-name: [name]'.   frameUpdater addMarkUp: '   description: [description 5]'.   frameUpdater addMarkUp: '   ingredients: [ingredients]'.   frameUpdater addMarkUp: '            steps: [steps]'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4View ).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test250createFrame4Dictionary</h3><pre>test250createFrame4Dictionary   "The frame editor instance knows what kind of frame it is editing.   "   | frameUpdater ontology |   ontology := HumOntology new.         "Initialize for a Dictionary Frame."   frameUpdater := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.      "Add dictionary lines."   "attributes"   frameUpdater addDictionaryLine: 'Recipe attributes include recipe-name, description, ingrediants steps.'.   "set collection"   frameUpdater addDictionaryLine: 'Recipe includes a set of ingrediants.'.   "list collection"   frameUpdater addDictionaryLine: 'Recipe includes a list of steps.'.   "Attribute used in  set above is an entity with its own attributes. Entities are members of set."   frameUpdater addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.   "Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"   frameUpdater addDictionaryLine: 'Step attributes include step-number, step-description'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Dictionary ).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test260createFrame4Vignette</h3><pre>test260createFrame4Vignette   "Create a dialog vignette..   "   | frameUpdater ontology |   ontology := HumOntology new.         "Initialize for a Dictionary Frame."   frameUpdater := HumFrameUpdater ontology: ontology vignetteContext: 'hello' pattern: 'Knock, knock.'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Vignette ).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test261updateFrame4Vignette</h3><pre>test261updateFrame4Vignette   "Create a dialog vignette.   "   | frameUpdater ontology |   ontology := HumOntology new.         "Initialize for a Dialog Frame."   frameUpdater := HumFrameUpdater ontology: ontology vignetteContext: 'Expecting Hello.' pattern: 'Knock, knock.'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Vignette ).      "Add response lines."   "There are two kinds of resonse, verbal responses and actions."   frameUpdater addVignetteResponse: 'Who is there?'.   frameUpdater addVignetteInstruction: 'Next context "Expecting who.".'.      self assert: ( ( frameUpdater frame frameLines at: 1 )                            sameAs:  ( HumVignetteResponseLine source: 'S: Who is there?' ) ).   self assert: ( ( frameUpdater frame frameLines at: 2 )                            sameAs:  ( HumInstructionLine statement: 'Next context "Expecting who.".' ) ).   self assert: ( ( frameUpdater frame responseLines at: 1 )                            sameAs:  ( HumMarkupLine source: 'Who is there?' ) ).   self assert: ( ( frameUpdater frame instructionLines at: 1 )                            sameAs:  ( HumInstructionLine statement: 'Next context "Expecting who.".' ) ).                     </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test270createFrame4Comment</h3><pre>test270createFrame4Comment   "Create with a comment frame..   "   | frameUpdater ontology |   ontology := HumOntology new.         "Initialize for a Comment Frame."   frameUpdater := HumFrameUpdater ontology: ontology commentTitle: 'This is only a test.' .   frameUpdater appendFrameLine: 'See test270createFrame4Comment.'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Comment ).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test300codeCriticFeatures</h3><pre>test300codeCriticFeatures   "The code critic generates errors and warnings for each type of frame."      "General syntax in most frames:   . Error: Statement should end with a period. (Instruction/Precondition/Action/Dictionary)   . Error: Statement should end with a colon.  (If/Else/For)   . Error: Response should end with period or question-mark. (vignette response)   . Error: Parenthesis is not closed.    . Error: Bracket is not closed.   . Error: Unknown frame-type. (Expecting Comment/Goal/Role/View/Context/Dictionary/Data)   "   "For statements in any frame:   . Warning: Statement has no known nouns.   . Warning: Noun '___' has no antecedent.   . Warning: Statement is currently undefined.    . Warning: Role '____' is undefined.   "   "For plan frames:   . Warning: Precondition is currently undefined.    . . (It is not marked [Assumed] and there is no goal-frame defining it.)   . Warning: This goal is not invoked anywhere yet.   . . (No vignette or precondition invokes it.)   . Warning: This action is currently undefined.   . Error: Action statements must have role prefix.   . Error: There is a loop in the plan tree.   "   "For dictionary frames:   . Error: Statement is not recognized.    . . (It does not match the Hum Dictionary DSL.)   . Error: Entity '____' cannot be its own attribute.    . . (There is a cycle in the noun graph from this entity back to itself.)   . Warning: Noun '____' has no known source.   . . (The noun is not seen in any vignette-pattern, view, or giving-statement.)    "   "For vignette frames:   . Warning: Context '____' has no content yet.   . Warning: Goal '____' is currently undefined.   . Warning: View '____' is currently undefined.   "   "For widgets:   . Error: Widget '[___]' is not recognized.    . . (The widget content does not match the Hum Widget DSL.)   . Warning: Noun '____' is not defined.   . . (The noun named in a widget does not appear in any dictionary statement.)   "   "For text markup in view and vignette:   . Error: Bolding started with '*' is not closed.   . Error: Italics started with '~' is not closed.   . Error: Underline started with '_' is not closed.   "      </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test320critiqueFrame4Plan</h3><pre>test320critiqueFrame4Plan   "Check plan frame - no known nouns - no plans   "   | frameUpdater ontology errors |   ontology := HumOntology new.   "Initialize for a Plan Frame."   frameUpdater := HumFrameUpdater ontology: ontology goal: 'Cake is baked according to recipe..'.      "Append precondition lines."   frameUpdater appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.   frameUpdater appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.      "Finish with action statement."   frameUpdater appendRole: 'Oven' action: 'Bake the pan in the oven for the time given in the recipe.' .      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Plan ).      "Expect complaints about no nouns."   errors := frameUpdater checkFrameSyntax.   self assert: ( errors isEmpty not ).   self assert: ( errors anySatisfy: [ :error | '*no known nouns*' match: error ] ).      "Expect complaints about preconditions with no plans."   self assert: ( errors anySatisfy: [ :error | '*no plan*' match: error ] ).      "Transcript cr; show: 'test320critiqueFrame4Plan Errors: ', errors asString; cr."   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test321critiqueFrame4Plan</h3><pre>test321critiqueFrame4Plan   "Detect: Every precondition has a noun that traces back to the goal statement.   "   | frameUpdater ontology errors |   ontology := HumOntology new.   "Initialize for a Plan Frame."   frameUpdater := HumFrameUpdater ontology: ontology goal: 'Cake is baked according to recipe..'.      "Append precondition lines."   frameUpdater appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.   frameUpdater appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.      "Finish with action statement."   frameUpdater appendRole: 'Oven' action: 'Bake the pan in the oven for the time given in the recipe.' .      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Plan ).      "Every line has recipe as a noun."   ontology addNouns: #( 'recipe' ).      "Expect no complaints about no nouns. "   errors := frameUpdater checkFrameSyntax.   self assert: ( errors count: [ :error | '*no nouns*' match: error ]  ) = 0.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test322critiqueFrame4PlanMissingAntecedant</h3><pre>test322critiqueFrame4PlanMissingAntecedant   "Detect: One or more preconditions have a noun with no antecedant in the goal statement.   "   | frameUpdater ontology errors |   ontology := HumOntology new.   "Initialize for a Plan Frame."   frameUpdater := HumFrameUpdater ontology: ontology goal: 'Cake is baked according to recipe..'.      "Append precondition lines."   frameUpdater appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.   frameUpdater appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.      "Finish with action statement."   frameUpdater appendRole: 'Oven' action: 'Bake the pan in the oven for the time given in the recipe.' .      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Plan ).      "Every line has recipe as a noun."   ontology addNouns: #( 'recipe' 'pan' ).      "Expect 'no antecedant' complaints "   errors := frameUpdater checkFrameSyntax.   self assert: ( errors count: [ :error | '*no antecedant*' match: error ]  ) &gt; 0.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test330critiqueFrame4Action</h3><pre>test330critiqueFrame4Action   "Detect: No known nouns.   "   | frameUpdater ontology errors |   ontology := HumOntology new.      "Initialize for an Action Frame."   frameUpdater := HumFrameUpdater ontology: ontology                                       role: 'Role'                                                 action: 'Bake the pan in the oven for the time given in the recipe.'.   "Append instruction lines."   frameUpdater appendInstructionStatement: 'Open the oven door.'.   frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.   frameUpdater appendInstructionStatement: 'Close the oven door.'.      "Append an instruction that is delegated"   frameUpdater appendInstructionRole: 'Oven' statement: 'Bake for the time given in the recipe.'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Action ).      self assert: ( frameUpdater frame frameLines size = 4 ).         "Expect  complaints about no nouns on every line because the ontology has not been informed."   errors := frameUpdater checkFrameSyntax.      "Check the simple instructions."   self assert: (errors includes: 'Statement: {Open the oven door.} has no known nouns!' ).   self assert: (errors includes: 'Statement: {Place the pan in the oven.} has no known nouns!').   self assert: (errors includes: 'Statement: {Close the oven door.} has no known nouns!' ).      "Check the last one - It is delegated."   self assert: (errors includes: 'Statement: {Bake for the time given in the recipe.} has no known nouns!' ).      "The action line should have nouns too."   self assert: (errors includes: 'Action statement {Bake the pan in the oven for the time given in the recipe.} has no known nouns!' ).         self assert: ( errors count: [ :error | '*no known nouns*' match: error] ) = 5.      </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test331critiqueFrame4Action</h3><pre>test331critiqueFrame4Action   "Detect: Some nouns, but still not enough.   "   | frameUpdater ontology errors |   ontology := HumOntology new.      "Initialize for an Action Frame."   frameUpdater := HumFrameUpdater ontology: ontology                                       role: 'Role'                                                 action: 'Bake the pan in the oven for the time given in the recipe.'.   "Append instruction lines."   frameUpdater appendInstructionStatement: 'Open the oven door.'.   frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.   frameUpdater appendInstructionStatement: 'Close the oven door.'.      "Append an instruction that is delegated"   frameUpdater appendInstructionRole: 'Oven' statement: 'Bake for the time given.'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Action ).      ontology addNouns: #( 'recipe' 'oven').      "Still expect one complaints about no nouns on the last line."   errors := frameUpdater checkFrameSyntax.   self assert: ( errors count: [ :error | '*no known nouns*' match: error ] ) = 1.</pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test332critiqueFrame4ActionForAntecedants</h3><pre>test332critiqueFrame4ActionForAntecedants   "Detect: 'No known noun' and/or  'no antecedant'   "   | frameUpdater ontology errors |   ontology := HumOntology new.      "Initialize for an Action Frame."   frameUpdater := HumFrameUpdater ontology: ontology                                       role: 'Role'                                                 action: 'Bake the pan in the oven for the time given in the recipe.'.   "Append instruction lines."   frameUpdater appendInstructionStatement: 'Open the oven door.'.   frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.   frameUpdater appendInstructionStatement: 'Close the oven door.'.      "Append an instruction that is delegated"   frameUpdater appendInstructionRole: 'Oven' statement: 'Bake for the time given.'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Action ).      ontology addNouns: #( 'recipe' 'oven' ).      "Still expect one complaints about no nouns on the last line."   errors := frameUpdater checkFrameSyntax.   self assert: ( errors count: [ :error | '*no known nouns*' match: error ] ) = 1.      "Check for antecedants - Happy path: 'door' is not a noun and needs no antecedant."   self assert: ( errors count: [: error | '*no antecedant*' match: error ] ) = 0.      "But if we make door a noun, it will now lack an antecedant."   ontology addNoun: 'door'.   errors := frameUpdater checkFrameSyntax.   self assert: ( errors count: [: error | '*no antecedant*' match: error ] ) = 2.         </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test345critiqueFrame4View</h3><pre>test345critiqueFrame4View   "Detect: No nouns in a view frame.   "   | frameUpdater ontology errors testMe |      "Turn this on/off for now."   testMe := true.   testMe ifFalse: [ Transcript cr; show: 'test345critiqueFrame4View is turned off.'; cr. ^self].      ontology := HumOntology new.      "Initialize for a View Frame."   frameUpdater := HumFrameUpdater ontology: ontology viewEntity: 'recipe.'.   "Add markup lines.   These widgets should reference nouns.   "   frameUpdater addMarkUp: '!! Recipe'.   frameUpdater addMarkUp: ' recipe-name: [name]'.   frameUpdater addMarkUp: '   description: [description 5]'.   frameUpdater addMarkUp: '   ingredients: [ingredients]'.   frameUpdater addMarkUp: '            steps: [steps]'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4View ).         "Expect complaints about no nouns."   errors := frameUpdater checkFrameSyntax.   self assert: ( errors isEmpty not ).      self assert: (errors size = 4 ).      "Transcript show: errors; cr."   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test346critiqueFrame4View</h3><pre>test346critiqueFrame4View   "When the nouns are defined, there are no complaints. s   "   | frameUpdater ontology errors testMe |      testMe := true.   testMe ifFalse: [ Transcript cr; show: 'test345critiqueFrame4View is turned off.'; cr. ^self].      ontology := HumOntology new.      "Initialize for a View Frame."   frameUpdater := HumFrameUpdater ontology: ontology viewEntity: 'recipe.'.   "Add markup lines."   frameUpdater addMarkUp: '!! Recipe'.   frameUpdater addMarkUp: ' recipe-name: [name]'.   frameUpdater addMarkUp: '   description: [description 5]'.   frameUpdater addMarkUp: '   ingredients: [ingredients]'.   frameUpdater addMarkUp: '            steps: [steps]'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4View ).      ontology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).         "Expect no complaints about no nouns."   errors := frameUpdater checkFrameSyntax.   self assert: ( errors isEmpty  ).      "Transcript show: 'test346critiqueFrame4View errors:'; cr; show: errors; cr."   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test350critiqueFrame4Dictionary</h3><pre>test350critiqueFrame4Dictionary   "Critique a dictionary frame.   Before the frame is compiled, the nouns are not recognized.   This might not be what we want, but it is consistent with other frames.   Consequences: Nouns will not be rendered (color/underline)                  until the frame is compiled (submitted).   "   | frameUpdater ontology errors |   ontology := HumOntology new.         "Initialize for a Dictionary Frame."   frameUpdater := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.   "Add dictionary lines."   "attributes"   frameUpdater addDictionaryLine: 'Recipe attributes include recipe-name, description, ingrediants steps.'.   "set collection"   frameUpdater addDictionaryLine: 'Recipe includes a set of ingrediants.'.   "list collection"   frameUpdater addDictionaryLine: 'Recipe includes a list of steps.'.   "Attribute used in  set above is an entity with its own attributes. Entities are members of set."   frameUpdater addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.   "Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"   frameUpdater addDictionaryLine: 'Step attributes include step-number, step-description'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Dictionary ).   "Until the frame is compiled, the nouns are not recognized.   TODO: IS THIS WHAT WE WANT?   "   errors := frameUpdater checkFrameSyntax.   self assert: ( errors isEmpty not ).   self assert: ( errors size = 5 ).      "Transcript  cr; show: 'test350critiqueFrame4Dictionary'; cr; show: errors; cr."  errors do: [:error | '*has no known nouns*' match: error. ]   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test351critiqueFrame4Dictionary</h3><pre>test351critiqueFrame4Dictionary   "Critique a dictionary frame.   After a dictionary frame is 'compiled', the nouns are recognized.   "   | frameUpdater ontology errors |   ontology := HumOntology title: 'test351critiqueFrame4Dictionary'.         "Initialize for a Dictionary Frame."   frameUpdater := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.   "Add dictionary lines."   "attributes"   frameUpdater addDictionaryLine: 'Recipe attributes include recipe-name, description, ingredients, steps.'.   "set collection"   frameUpdater addDictionaryLine: 'Recipe includes a set of ingrediants.'.   "list collection"   frameUpdater addDictionaryLine: 'Recipe includes a list of steps.'.   "Attribute used in  set above is an entity with its own attributes. Entities are members of set."   frameUpdater addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.   "Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"   frameUpdater addDictionaryLine: 'Step attributes include step-number, step-description'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Dictionary ).      "ontology addNouns: #( 'recipe' 'name' 'description' 'ingredient' 'step' )."   frameUpdater compileToOntology: ontology. "Nouns are now added to ontology."            "Expect no complaints about no nouns."   errors := frameUpdater checkFrameSyntax .   self assert: ( errors isEmpty  ).   self assert: ( errors size = 0 ).      "Transcript  cr; show: 'test351critiqueFrame4Dictionary'; cr; show: errors; cr."   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test361critiqueFrame4Vignette</h3><pre>test361critiqueFrame4Vignette   "Critique a dialog vignette.   "   | frameUpdater1 frameUpdater2 frameUpdater3 ontology errors1 errors2 errors3 |   ontology := HumOntology new.         "Initialize for a Dialog Frame."   frameUpdater1 := HumFrameUpdater ontology: ontology                                        vignetteContext: 'Expecting Hello.'                                                    pattern: 'Knock, knock.'.   frameUpdater1 addVignetteResponse: 'Who is there?'.   frameUpdater1 nextVignetteContext: 'Expecting first name.'.   errors1 := frameUpdater1 checkFrameSyntax.   self assert: (errors1 isEmpty ) not.       frameUpdater2 := HumFrameUpdater ontology: ontology                                        vignetteContext: 'Expecting first name.'                                                    pattern: '[first-name]'.   frameUpdater2 addVignetteResponse: '[first-name] who?'.   frameUpdater2 nextVignetteContext: 'Expecting whole-name.'.   errors2 := frameUpdater2 checkFrameSyntax.   self assert: (errors2 isEmpty ) not.         frameUpdater3 :=  HumFrameUpdater ontology: ontology                                        vignetteContext: 'Expecting whole-name.'                                                    pattern: '[first-name] [last-name]'.   frameUpdater3 addVignetteResponse: 'Hello [first-name] [last-name]. What do you want to do?'.   frameUpdater3 addVignetteInstruction: 'Ask menu.'.   errors3 := frameUpdater3 checkFrameSyntax.   self assert: (errors3 isEmpty ) not.      ontology addNouns: #( 'name' 'first-name' 'last-name' 'menu' ).      frameUpdater1 compileToOntology: ontology.   frameUpdater2 compileToOntology: ontology.   frameUpdater3 compileToOntology: ontology.      errors1 := frameUpdater1 checkFrameSyntax.   self assert: ( errors1 isEmpty ).      errors2 := frameUpdater2 checkFrameSyntax.   self assert: ( errors2 isEmpty ).      errors3 := frameUpdater3 checkFrameSyntax.   "{Ask menu.} is not defined in this ontology."   self assert: ( errors3 at: 1 ) = 'Action: {Ask menu.} has not been defined.'.                                    </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test421compileFrame4Plan</h3><pre>test421compileFrame4Plan   "In this context, 'compile' means that the plan frame is inserted into the ontology,     and the frame is checked for problems that would prevent the plan from executing.   "   | frameUpdater ontology errors goalSourceString frameIn frameOut  |   ontology := HumOntology new.   "Initialize for a Plan Frame."   goalSourceString := 'Cake is baked according to recipe.'.   frameUpdater := HumFrameUpdater ontology: ontology goal: goalSourceString.   "Append precondition lines."   frameUpdater appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.   frameUpdater appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.   "Finish with action statement."   frameUpdater appendRole: 'Oven' action: 'Bake the pan in the oven for the time given in the recipe.' .      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Plan ).      "Every line has recipe as a noun."   ontology addNouns: #( 'recipe' ).      "Expect no complaints about no nouns. "   errors := frameUpdater checkFrameSyntax.   self expect: 0 actual: ( errors count: [ :error | '*no nouns*' match: error ]  ).      errors := frameUpdater compileToOntology: ontology.      self expect: 4 actual: ( errors asSet size ).      "Now we should see frame in the ontology."   frameIn := frameUpdater frame.   frameOut := ontology getPlanFrameForGoal: goalSourceString.    self assert: ( frameOut = frameIn ).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test431compileFrame4Action</h3><pre>test431compileFrame4Action   "In this case, 'compile' means adding the frame to the ontology,     and the syntax checks for problems that would prevent the frame from executing.    "   | actionSourceString frameUpdater ontology errors instructionSequence |   ontology := HumOntology new.      "Initialize for an Action Frame."   actionSourceString :=  'Bake the pan in the oven for the time given in the recipe.'.   frameUpdater := HumFrameUpdater ontology: ontology role: 'Baker' action:  actionSourceString.   "Append instruction lines."   frameUpdater appendInstructionStatement: 'Open the oven door.'.   frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.   frameUpdater appendInstructionStatement: 'Close the oven door.'.   frameUpdater appendInstructionStatement: 'Set the oven-temperature per recipe.'.      "Append an instruction that is delegated"   frameUpdater appendInstructionRole: 'Oven' statement: 'Bake for the baking-time given in the recipe.'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Action ).   self expect: 5 actual: ( frameUpdater frame frameLines size ) description: '5 lines expected'.      ontology addNouns: #( 'recipe' 'oven' 'pan' 'baking-time' 'oven-temperature' ).      errors := frameUpdater checkFrameSyntax.   self assert: ( errors count: [ :error | '*no known nouns*' match: error ] ) = 0.      errors := frameUpdater compileToOntology: ontology.   self expect: 5 actual: ( frameUpdater frame frameLines size ) description: 'should still be 5 lines'.      self assert: (errors size) = 7.      "Now we can get the action from the ontology"   self assert: ( ( ontology getRole: 'Baker'  action:  actionSourceString ) isKindOf: HumStatement ).         "Now we can also get the instruction sequence "   instructionSequence := ( ontology instructionsForRole: 'Baker' action: actionSourceString ).   self assert: ( instructionSequence isKindOf: OrderedCollection ).   self expect: 5 actual: ( instructionSequence size ).   self assert:( ( instructionSequence at: 1) isKindOf: HumInstructionLine ).      "And the role`s actions includes "   self assert: (( ontology actionsOf: 'Baker' ) include: actionSourceString ).      </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test446compileFrame4View</h3><pre>test446compileFrame4View   "Compile a view frame.   "   | frameUpdater ontology errors testMe |      testMe := true.   testMe ifFalse: [ Transcript cr; show: 'test446compileFrame4View is turned off.'; cr. ^self].      ontology := HumOntology new.      "Initialize for a View Frame."   frameUpdater := HumFrameUpdater ontology: ontology viewEntity: 'recipe.'.   "Add markup lines."   frameUpdater addMarkUp: '!! Recipe'.   frameUpdater addMarkUp: ' recipe-name: [name]'.   frameUpdater addMarkUp: '   description: [description 5]'.   frameUpdater addMarkUp: '   ingredients: [ingredients]'.   frameUpdater addMarkUp: '            steps: [steps]'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4View ).      ontology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).         "Expect no complaints about no nouns."   errors := frameUpdater compileToOntology: ontology.   self assert: ( errors isEmpty  ).      </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test450compileFrame4Dictionary</h3><pre>test450compileFrame4Dictionary   "In this context,    'compile' means that the ontology will be updated with nouns and their supertypes.   "   | frameUpdater ontology errors nounSubtypes zNouns |   ontology := HumOntology new.         "Initialize for a Dictionary Frame."   frameUpdater := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.   "Add dictionary lines."   "supertype"   frameUpdater addDictionaryLine: 'Description is a text.'.   "attributes"   frameUpdater addDictionaryLine: 'Recipe attributes include recipe-name, recipe-description, ingredients, steps.'.   "set collection"   frameUpdater addDictionaryLine: 'Recipe includes a set of ingredients.'.   "list collection"   frameUpdater addDictionaryLine: 'Recipe includes a list of steps.'.   "Attribute used in  set above is an entity with its own attributes. Entities are members of set."   frameUpdater addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, substitute.'.   "Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"   frameUpdater addDictionaryLine: 'Step attributes include step-number, step-description'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Dictionary ).      errors := frameUpdater compileToOntology: ontology.   self expect: 1 actual: (ontology frames size).   "There are no syntax errors."   self assert: ( errors isEmpty ).      ontology compileAllFrames.    self expect: 1 actual: (ontology frames size).      "Check that ontology has all that stuff."   zNouns := ontology nouns.   self expect: 14 actual: (zNouns size) description: 'Expecting over ten nouns'.   self assert: ( zNouns includesAllOf: #( 'recipe' 'recipe-name' 'description' 'ingredient' 'step' 'ingredient-name' 'quantity' 'substitute' 'step-number' 'step-description' )).      "Check that the supertypes are recorded also."   nounSubtypes := ontology nounSubtypes.   self expect: {('text'-&gt;'description'). ('set'-&gt;'ingredients'). ('list'-&gt;'steps')}         actual: nounSubtypes asArray.      </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test461compileFrame4Vignette</h3><pre>test461compileFrame4Vignette   "Compile a dialog vignette.   "   | frameUpdater1 frameUpdater2 frameUpdater3 ontology frame1 frame2 frame3 |   ontology := HumOntology new.         "Initialize a Vignette Frame."   frameUpdater1 := HumFrameUpdater ontology: ontology                                     vignetteContext: 'Expecting Hello.'                                                 pattern: 'Knock, knock.'.   frameUpdater1 addVignetteResponse: 'Who is there?'.   frameUpdater1 nextVignetteContext: 'Expecting first name'.   frameUpdater1 compileToOntology: ontology.       frameUpdater2 := HumFrameUpdater ontology: ontology                                        vignetteContext: 'Expecting first name.'                                                    pattern: '[first-name]'.   frameUpdater2 addVignetteResponse: '[first-name] who?'.   frameUpdater2 nextVignetteContext: 'Expecting whole-name'.   frameUpdater2 compileToOntology: ontology.      frameUpdater3 :=  HumFrameUpdater ontology: ontology                                        vignetteContext: 'Expecting whole-name.'                                                    pattern: '[first-name] [last-name]'.   frameUpdater3 addVignetteResponse: 'Hello [first-name] [last-name]. What do you want to do?'.   frameUpdater3 addVignetteInstruction: 'Ask menu.'.   frameUpdater3 compileToOntology: ontology.      "The ontology should have these frames."   frame1 := frameUpdater1 frame.   frame2 := frameUpdater2 frame.   frame3 := frameUpdater3 frame.   self assert: ( frame1 uniqueIdentifier &lt; frame2 uniqueIdentifier).   self assert: ( frame2 uniqueIdentifier &lt; frame3 uniqueIdentifier ).   self assert: ( ( ontology fetchFrameByIdentifier: ( frame1 uniqueIdentifier  )) = frame1 ).   self assert: ( ( ontology fetchFrameByIdentifier: ( frame2 uniqueIdentifier  )) = frame2 ).   self assert: ( ( ontology fetchFrameByIdentifier: ( frame3 uniqueIdentifier  )) = frame3 ).      ""                     </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test510storeFrame</h3><pre>test510storeFrame   "Store the frame in the given ontology.   The frame may be stored even if it has errors.   "   | frameUpdater ontology |   ontology := HumOntology new.         "Initialize for a Dictionary Frame."   frameUpdater := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.   "Add dictionary lines."   "supertype"   frameUpdater addDictionaryLine: 'Description is a text.'.   "attributes"   frameUpdater addDictionaryLine: 'Recipe attributes include recipe-name, recipe-description, ingredients, steps.'.   "set collection"   frameUpdater addDictionaryLine: 'Recipe includes a set of ingredients.'.   "list collection"   frameUpdater addDictionaryLine: 'Recipe includes a list of steps.'.   "Attribute used in  set above is an entity with its own attributes. Entities are members of set."   frameUpdater addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.   "Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"   frameUpdater addDictionaryLine: 'Step attributes include step-number, step-description'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Dictionary ).      "The frame editor receives the command to store the frame from the user interface (Scribe)."   frameUpdater storeFrameInOntology.      </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test520fetchFrameByID</h3><pre>test520fetchFrameByID   "Store a dictionary frame and then get it back using its uniqueIdentifier.   "   | frameUpdater1 ontology identifier frameUpdater2 frame1 frame2 |   ontology := HumOntology new.         "Initialize for a Dictionary Frame."   frameUpdater1 := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.   "Add dictionary lines."   "supertype"   frameUpdater1 addDictionaryLine: 'Description is a text.'.   "attributes"   frameUpdater1 addDictionaryLine: 'Recipe attributes include recipe-name, recipe-description, ingredients, steps.'.   "set collection"   frameUpdater1 addDictionaryLine: 'Recipe includes a set of ingredients.'.   "list collection"   frameUpdater1 addDictionaryLine: 'Recipe includes a list of steps.'.   "Attribute used in  set above is an entity with its own attributes. Entities are members of set."   frameUpdater1 addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.   "Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"   frameUpdater1 addDictionaryLine: 'Step attributes include step-number, step-description'.      self assert: ( frameUpdater1 notNil ).   self assert: ( frameUpdater1 frame isMemberOf: HumFrame4Dictionary ).      "The frame editor receives the command to store the frame from the user interface (Scribe)."   frameUpdater1 storeFrameInOntology.   "The frame will now have a uniqueIdentifier."   frame1 := frameUpdater1 frame.   self assert: ( frame1 isKindOf: HumFrame4Dictionary ).   identifier := frame1 uniqueIdentifier.   self assert: ( identifier isKindOf: HumIdentifier ).   "We can use the identifier to fetch the frame into another frameUpdater."   frameUpdater2 := HumFrameUpdater ontology: ontology loadFrameByIdentifier: identifier.   self assert: (frameUpdater2 isKindOf: HumFrameUpdater ).   "Check the content."   frame2 := frameUpdater2 frame.   self assert: ( frame2 isKindOf: HumFrame4Dictionary ).   self assert: ( frame1 titleLine = frame2 titleLine ).   self assert: ( frame1 titleLine sameAs: frame2 titleLine ).   self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).   self assert: ( frame1 frameLines at: 1) = ( frame2 frameLines at: 1 ).   self assert: (( frame1 frameLines at: 1) sameAs: ( frame2 frameLines at: 1 )).      </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test531fetchFrame4PlanByID</h3><pre>test531fetchFrame4PlanByID   "Create a plan frame in editor; store it; get it back via its ID.   "   | frameUpdater1 frameUpdater2 ontology errors frame1 frame2 identifier |   ontology := HumOntology new.   "Initialize for a Plan Frame."   frameUpdater1 := HumFrameUpdater ontology: ontology goal: 'Cake is baked according to recipe..'.   "Append precondition lines."   frameUpdater1 appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.   frameUpdater1 appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.   "Finish with action statement."   frameUpdater1 appendRole: 'Oven' action: 'Bake the pan in the oven for the time given in the recipe.' .      self assert: ( frameUpdater1 notNil ).   self assert: ( frameUpdater1 frame isMemberOf: HumFrame4Plan ).      "Every line has recipe as a noun."   ontology addNouns: #( 'recipe' ).      "Expect no complaints about no nouns. "   errors := frameUpdater1 checkFrameSyntax.   self assert: ( errors count: [ :error | '*no known nouns*' match: error]  ) = 0.            self assert: ( frameUpdater1 notNil ).   self assert: ( frameUpdater1 frame isMemberOf: HumFrame4Plan ).      "The frame editor receives the command to store the frame from the user interface (Scribe)."   frameUpdater1 storeFrameInOntology.   "The frame will now have a uniqueIdentifier."   frame1 := frameUpdater1 frame.   self assert: ( frame1 isKindOf: HumFrame4Plan ).   identifier := frame1 uniqueIdentifier.   self assert: ( identifier isKindOf: HumIdentifier ).   "We can use the identifier to fetch the frame into another frameUpdater."   frameUpdater2 := HumFrameUpdater ontology: ontology loadFrameByIdentifier: identifier.   self assert: (frameUpdater2 isKindOf: HumFrameUpdater ).   "Check the content."   frame2 := frameUpdater2 frame.   self assert: ( frame2 isKindOf: HumFrame4Plan ).   self assert: ( frame1 titleLine = frame2 titleLine ).   self assert: ( frame1 titleLine sameAs: frame2 titleLine ).   self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).   self assert: ( frame1 frameLines at: 1) = ( frame2 frameLines at: 1 ).   self assert: (( frame1 frameLines at: 1) sameAs: ( frame2 frameLines at: 1 )).         </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test532fetchFrame4PlanByTitle</h3><pre>test532fetchFrame4PlanByTitle   "Create a plan frame in editor; store it; get it back via its title.   "   | frameUpdater1 frameUpdater2 frameUpdater3 frameUpdater4 ontology errors frame1 frame2  frame4 name |   ontology := HumOntology new.   "Initialize for a Plan Frame."   frameUpdater1 := HumFrameUpdater ontology: ontology goal: 'Cake is baked according to recipe.'.   "Append precondition lines."   frameUpdater1 appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.   frameUpdater1 appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.   "Finish with action statement."   frameUpdater1 appendRole: 'Oven' action: 'Bake the pan in the oven for the time given in the recipe.' .      self assert: ( frameUpdater1 notNil ).   self assert: ( frameUpdater1 frame isMemberOf: HumFrame4Plan ).      "Every line has recipe as a noun."   ontology addNouns: #( 'recipe' ).      "Expect no complaints about no nouns. "   errors := frameUpdater1 checkFrameSyntax.   self assert: ( errors count: [ :error | '*no known nouns*' match: error] ) = 0.      self assert: ( frameUpdater1 notNil ).   self assert: ( frameUpdater1 frame isMemberOf: HumFrame4Plan ).      "The frame editor receives the command to store the frame from the user interface (Scribe)."   frameUpdater1 storeFrameInOntology.   "The frame will now have a uniqueIdentifier."   frame1 := frameUpdater1 frame.   self assert: ( frame1 isKindOf: HumFrame4Plan ).   name := frame1 frameName.   self assert: ( name isKindOf: String ).   "We can use the identifier to fetch the frame into another frameUpdater."   frameUpdater2 := HumFrameUpdater ontology: ontology fetchFrameByName: name.   self assert: ( frameUpdater2 isKindOf: HumFrameUpdater ).   "Check the content."   frame2 := frameUpdater2 frame.   self assert: ( frame2 isKindOf: HumFrame4Plan ).   self assert: ( frame1 titleLine = frame2 titleLine ).   self assert: ( frame1 titleLine sameAs: frame2 titleLine ).   self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).   self assert: ( frame1 frameLines at: 1 ) = ( frame2 frameLines at: 1 ).   self assert: (( frame1 frameLines at: 1 ) sameAs: ( frame2 frameLines at: 1 )).      "Make sure it still works when there is more than one plan frame."      frameUpdater3 := HumFrameUpdater ontology: ontology                                        goal: 'Oven is preheated to the temperature given in the recipe.'.   frameUpdater3 storeFrameInOntology.   frameUpdater4 := HumFrameUpdater ontology: ontology fetchFrameByName: name.   self assert: ( frameUpdater2 isKindOf: HumFrameUpdater ).   "Check the content."   frame4 := frameUpdater2 frame.   self assert: ( frame4 isKindOf: HumFrame4Plan ).   self assert: ( frame1 titleLine = frame2 titleLine ).   self assert: ( frame1 titleLine sameAs: frame4 titleLine ).   self assert: ( frame1 frameLines size ) = ( frame4 frameLines size ).   self assert: ( frame1 frameLines at: 1 ) = ( frame4 frameLines at: 1 ).   self assert: (( frame1 frameLines at: 1 ) sameAs: ( frame4 frameLines at: 1 )).</pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test540fetchFrame4DictionaryByID</h3><pre>test540fetchFrame4DictionaryByID   | frameUpdater1 frameUpdater2 ontology identifier frame1 frame2 |      "Initialize for a Dictionary Frame."   ontology := HumOntology new.   frameUpdater1 := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.      "Add dictionary lines."   "attributes"   frameUpdater1 addDictionaryLine: 'Recipe attributes include recipe-name, description, ingrediants steps.'.   "set collection"   frameUpdater1 addDictionaryLine: 'Recipe includes a set of ingrediants.'.   "list collection"   frameUpdater1 addDictionaryLine: 'Recipe includes a list of steps.'.   "Attribute used in  set above is an entity with its own attributes. Entities are members of set."   frameUpdater1 addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.   "Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"   frameUpdater1 addDictionaryLine: 'Step attributes include step-number, step-description'.      self assert: ( frameUpdater1 notNil ).   self assert: ( frameUpdater1 frame isMemberOf: HumFrame4Dictionary ).         "The frame editor receives the command to store the frame from the user interface (Scribe)."   frameUpdater1 storeFrameInOntology.   "The frame will now have a uniqueIdentifier."   frame1 := frameUpdater1 frame.   self assert: ( frame1 isKindOf: HumFrame4Dictionary ).   identifier := frame1 uniqueIdentifier.   self assert: ( identifier isKindOf: HumIdentifier ).   "We can use the identifier to fetch the frame into another frameUpdater1."   frameUpdater2 := HumFrameUpdater ontology: ontology loadFrameByIdentifier: identifier.   self assert: (frameUpdater2 isKindOf: HumFrameUpdater ).   "Check the content."   frame2 := frameUpdater2 frame.   self assert: ( frame2 isKindOf: HumFrame4Dictionary ).   self assert: ( frame1 titleLine = frame2 titleLine ).   self assert: ( frame1 titleLine sameAs: frame2 titleLine ).   self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).   self assert: ( frame1 frameLines at: 1) = ( frame2 frameLines at: 1 ).   self assert: (( frame1 frameLines at: 1) sameAs: ( frame2 frameLines at: 1 )).      </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test541fetchFrame4DictionaryByTitle</h3><pre>test541fetchFrame4DictionaryByTitle   "Ontology will fetch a dictionary frame given its title."   | frameUpdater1 frameUpdater2 ontology name frame1 frame2 |      "Given: Ontology has several dictionary frames."   "When: Caller (PA) requests a dictionary frame by its title."   "Then: Ontology returns the matching frame."   "--- Otherwise ---"   "The caller may request a ranked list of nearest matches. (test542 ?)"   "Initialize for a Dictionary Frame."   ontology := HumOntology new.   frameUpdater1 := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.      "Add dictionary lines."   "attributes"   frameUpdater1 addDictionaryLine: 'Recipe attributes include recipe-name, description, ingrediants steps.'.   "set collection"   frameUpdater1 addDictionaryLine: 'Recipe includes a set of ingrediants.'.   "list collection"   frameUpdater1 addDictionaryLine: 'Recipe includes a list of steps.'.   "Attribute used in  set above is an entity with its own attributes. Entities are members of set."   frameUpdater1 addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, alternate-ingredient.'.   "Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"   frameUpdater1 addDictionaryLine: 'Step attributes include step-number, step-description'.      self assert: ( frameUpdater1 notNil ).   self assert: ( frameUpdater1 frame isMemberOf: HumFrame4Dictionary ).         "The frame editor receives the command to store the frame from the user interface (Scribe)."   frameUpdater1 storeFrameInOntology.   "The frame will now have a uniqueIdentifier."   frame1 := frameUpdater1 frame.   self assert: ( frame1 isKindOf: HumFrame4Dictionary ).   name := frame1 frameName.   self assert: ( name isKindOf: String ).   "We can use the identifier to fetch the frame into another frameUpdater."   frameUpdater2 := HumFrameUpdater ontology: ontology fetchFrameByName: name.   self assert: (frameUpdater2 isKindOf: HumFrameUpdater ).   "Check the content."   frame2 := frameUpdater2 frame.   self assert: ( frame2 isKindOf: HumFrame4Dictionary ).   self assert: ( frame1 titleLine = frame2 titleLine ).   self assert: ( frame1 titleLine sameAs: frame2 titleLine ).   self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).   self assert: ( frame1 frameLines at: 1) = ( frame2 frameLines at: 1 ).   self assert: (( frame1 frameLines at: 1) sameAs: ( frame2 frameLines at: 1 )).      </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test551fetchFrame4ActionByTitle</h3><pre>test551fetchFrame4ActionByTitle   "The title of an action includes the role and the statement."      | frameUpdater1 frameUpdater2 ontology frame1 frame2 name |   "Given: Ontology contains several action frames."   "When: Caller (PA) requests the action frame with role and statement-string."   "Then: Ontology returns the matching action frame.          Otherwise: The PA may ask the ontology for a ranked list of nearest matches. (test552 ?)"   ontology := HumOntology new.      "Initialize for an Action Frame."   frameUpdater1 := HumFrameUpdater ontology: ontology                                       role: 'Role'                                                 action: 'Bake the pan in the oven for the time given in the recipe.'.   "Append instruction lines."   frameUpdater1 appendInstructionStatement: 'Open the oven door.'.   frameUpdater1 appendInstructionStatement: 'Place the pan in the oven.'.   frameUpdater1 appendInstructionStatement: 'Close the oven door.'.      "Append an instruction that is delegated"   frameUpdater1 appendInstructionRole: 'Oven' statement: 'Bake for the time given.'.      self assert: ( frameUpdater1 notNil ).   self assert: ( frameUpdater1 frame isMemberOf: HumFrame4Action ).      self assert: ( frameUpdater1 frame frameLines size = 4 ).      frame1 := frameUpdater1 frame.   self assert: ( frame1 isKindOf: HumFrame4Action ).   name := frame1 frameName.   self assert: ( name isKindOf: String ).   "We can use the identifier to fetch the frame into another frameUpdater."   frameUpdater1 storeFrameInOntology.   frameUpdater2 := HumFrameUpdater ontology: ontology fetchFrameByName: name.   self assert: (frameUpdater2 isKindOf: HumFrameUpdater ).   "Check the content."   frame2 := frameUpdater2 frame.   self assert: ( frame2 isKindOf: HumFrame4Action ).   self assert: ( frame1 titleLine = frame2 titleLine ).   self assert: ( frame1 titleLine sameAs: frame2 titleLine ).   self expect: ( frame1 frameLines size ) actual: ( frame2 frameLines size ).   self expect: ( frame1 frameLines at: 1)  actual: ( frame2 frameLines at: 1 ).   self expect: ( frame1 frameLines at: 1) actual: ( frame2 frameLines at: 1 ).      </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test561fetchFrame4ViewByTitle</h3><pre>test561fetchFrame4ViewByTitle   "This should be easy."   | frameUpdater1 frameUpdater2 ontology name frame1 frame2 |   "Given: PA or run-time has ontology open with several view frames."   "When: PA or run-time correctly requests a view by name."   "Then: Ontology returns the frame containing that view."   "--- Following can go into another test: ---"   "When: The name does not match any view,"   "Then: The PA can ask the ontology for a ranked list of view names. (best match)"      ontology := HumOntology new.      "Initialize for a View Frame."   frameUpdater1 := HumFrameUpdater ontology: ontology viewEntity: 'recipe.'.      "Add markup lines."   frameUpdater1 addMarkUp: '!! Recipe'.   frameUpdater1 addMarkUp: ' recipe-name: [name]'.   frameUpdater1 addMarkUp: '   description: [description 5]'.   frameUpdater1 addMarkUp: '   ingredients: [ingredients]'.   frameUpdater1 addMarkUp: '            steps: [steps]'.      self assert: ( frameUpdater1 notNil ).   self assert: ( frameUpdater1 frame isMemberOf: HumFrame4View ).      frame1 := frameUpdater1 frame.   self assert: ( frame1 isKindOf: HumFrame4View ).   name := frame1 frameName.   self assert: ( name isKindOf: String ).   "We can use the identifier to fetch the frame into another frameUpdater."   frameUpdater1 storeFrameInOntology.   frameUpdater2 := HumFrameUpdater ontology: ontology fetchFrameByName: name.   self assert: (frameUpdater2 isKindOf: HumFrameUpdater ).   "Check the content."   frame2 := frameUpdater2 frame.   self assert: ( frame2 isKindOf: HumFrame4View ).   self assert: ( frame1 titleLine = frame2 titleLine ).   self assert: ( frame1 titleLine sameAs: frame2 titleLine ).   self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).   self assert: ( frame1 frameLines at: 1) = ( frame2 frameLines at: 1 ).   self assert: (( frame1 frameLines at: 1) sameAs: ( frame2 frameLines at: 1 )).</pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test571fetchFrame4VignetteByTitle</h3><pre>test571fetchFrame4VignetteByTitle   "TODO: Think about how vignettes would be identified to users.   The current design treats vignettes as modules.   It might make more sense to treat contexts as modules   because the rule is that the vignettes in a context are tried in the order given.   If that were the case,      the modules would tend to have too many lines of code,      but they would be easily named.   Idea: Name the vignette by context plus the first pattern.   Problem: That does not deal with the ordering of vignettes within a context.   Question: Is the ordering of vignettes really necessary?             In other words, should we demand greater specificity from users?   Decision: Discard the idea that vignettes are tried in some order and see what happens.   "   | frameUpdater1 frameUpdater2 ontology name frame1 frame2 |   "Given: A context is active."   "When: Scribe delivers a pattern and run-time looks it up."   "Then: If the pattern matches one of the vignette`s in the active context,           . Ontology returns that vignette.          Otherwise:          . Ontology returns nil. (Perhaps we should return a default 'do not understand' vignette.)"      "Create a dialog vignette.   "   ontology := HumOntology new.         "Initialize for a Dialog Frame."   frameUpdater1 := HumFrameUpdater ontology: ontology vignetteContext: 'Expecting Hello.' pattern: 'Knock, knock.'.      self assert: ( frameUpdater1 notNil ).   self assert: ( frameUpdater1 frame isMemberOf: HumFrame4Vignette ).      "Add response lines."   "There are two kinds of resonse, verbal responses and actions."   frameUpdater1 addVignetteResponse: 'Who is there?'.   frameUpdater1 addVignetteInstruction: 'Next context "Expecting who.".'.      self assert: ( ( frameUpdater1 frame frameLines at: 1 )                            sameAs:  ( HumVignetteResponseLine source: 'S: Who is there?' ) ).   self assert: ( ( frameUpdater1 frame frameLines at: 2 )                            sameAs:  ( HumInstructionLine statement: 'Next context "Expecting who.".' ) ).   self assert: ( ( frameUpdater1 frame responseLines at: 1 )                            sameAs:  ( HumMarkupLine source: 'Who is there?' ) ).   self assert: ( ( frameUpdater1 frame instructionLines at: 1 )                            sameAs:  ( HumInstructionLine statement: 'Next context "Expecting who.".' ) ).         frame1 := frameUpdater1 frame.   self assert: ( frame1 isKindOf: HumFrame4Vignette ).   name := frame1 frameName.   self assert: ( name isKindOf: String ).   "We can use the identifier to fetch the frame into another frameUpdater."   frameUpdater1 storeFrameInOntology.   frameUpdater2 := HumFrameUpdater ontology: ontology fetchFrameByName: name.   self assert: (frameUpdater2 isKindOf: HumFrameUpdater ).   "Check the content."   frame2 := frameUpdater2 frame.   self assert: ( frame2 isKindOf: HumFrame4Vignette ).   self assert: ( frame1 titleLine = frame2 titleLine ).   self assert: ( frame1 titleLine sameAs: frame2 titleLine ).   self assert: ( frame1 frameLines size ) = ( frame2 frameLines size ).   self assert: ( frame1 frameLines at: 1) = ( frame2 frameLines at: 1 ).   self assert: (( frame1 frameLines at: 1) sameAs: ( frame2 frameLines at: 1 )).                  </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test620storeFrame4Plan</h3><pre>test620storeFrame4Plan   "Store plan frame.   "   | frameUpdater ontology |   ontology := HumOntology new.      "Initialize for a Plan Frame."   frameUpdater := HumFrameUpdater ontology: ontology goal: 'Cake is baked according to recipe..'.   "Append precondition lines."   frameUpdater appendPrecondition: 'Oven is preheated to the temperature given in the recipe.'.   frameUpdater appendPrecondition: 'The recipe`s batter is in a prepared cake pan.'.   "Finish with action statement."   frameUpdater appendRole: 'Oven' action: 'Bake the pan in the oven for the time given in the recipe.' .      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Plan ).      self assert: (frameUpdater frame frameLines size = 3 ).      "Run store and fetch test routine"   self storeInOntology: ontology fromFrameUpdater: frameUpdater.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test630storeFrame4Action</h3><pre>test630storeFrame4Action   "Store an action frame.   "   | frameUpdater ontology |   ontology := HumOntology new.      "Initialize for an Action Frame."   frameUpdater := HumFrameUpdater ontology: ontology                                                    role: 'Role' action: 'Bake the pan in the oven for the time given in the recipe.'.   "Append instruction lines."   frameUpdater appendInstructionStatement: 'Open the oven door.'.   frameUpdater appendInstructionStatement: 'Place the pan in the oven.'.   frameUpdater appendInstructionStatement: 'Close the oven door.'.   "Append an instruction that is delegated"   frameUpdater appendInstructionRole: 'Oven' statement: 'Bake for the time given.'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Action ).         self assert: ( frameUpdater frame frameLines size = 4 ).      "Run store and fetch test routine"   self storeInOntology: ontology fromFrameUpdater: frameUpdater.      </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test640storeFrame4View</h3><pre>test640storeFrame4View   "Store a view frame.   "   | frameUpdater ontology |   ontology := HumOntology new.      "Initialize for a View Frame."   frameUpdater := HumFrameUpdater ontology: ontology viewEntity: 'recipe.'.   "Add markup lines."   frameUpdater addMarkUp: '!! Recipe'.   frameUpdater addMarkUp: ' recipe-name: [name]'.   frameUpdater addMarkUp: '   description: [description 5]'.   frameUpdater addMarkUp: '   ingredients: [ingredients]'.   frameUpdater addMarkUp: '            steps: [steps]'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4View ).         "Run store and fetch test routine"   self storeInOntology: ontology fromFrameUpdater: frameUpdater.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test650storeFrame4Dictionary</h3><pre>test650storeFrame4Dictionary   "Store a dictionary frame.   "   | frameUpdater ontology |   ontology := HumOntology new.         "Initialize for a Dictionary Frame."   frameUpdater := HumFrameUpdater ontology: ontology dictionaryTitle: 'Recipe vocabulary.'.   "Add dictionary lines."   "attributes"   frameUpdater addDictionaryLine: 'Recipe attributes include recipe-name, description, ingrediants steps.'.   "set collection"   frameUpdater addDictionaryLine: 'Recipe includes a set of ingrediants.'.   "Attribute used in  set above is an entity with its own attributes. Entities are members of set."   frameUpdater addDictionaryLine: 'Ingredient attributes include ingredient-name, quantity, ingredient-type, alternate-ingredient.'.   "categories"   frameUpdater addDictionaryLine: 'Ingredient-type categories include wet, dry.'.   "list collection"   frameUpdater addDictionaryLine: 'Recipe includes a list of steps.'.   "Attribute used in list above is an entity. Entity instances are in a list. (OrderedCollection)"   frameUpdater addDictionaryLine: 'Step attributes include step-number, step-description'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Dictionary ).            "Run store and fetch test routine"   self storeInOntology: ontology fromFrameUpdater: frameUpdater.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test660storeFrame4Vignette</h3><pre>test660storeFrame4Vignette   "Store a dictionary frame.   "   | frameUpdater ontology |   ontology := HumOntology new.            ontology := HumOntology new.         "Initialize for a Dialog Frame."   frameUpdater := HumFrameUpdater ontology: ontology vignetteContext: 'Expecting Hello.' pattern: 'Knock, knock.'.      self assert: ( frameUpdater notNil ).   self assert: ( frameUpdater frame isMemberOf: HumFrame4Vignette ).      "Add response lines."   "There are two kinds of resonse, verbal responses and actions."   frameUpdater addVignetteResponse: 'Who is there?'.   frameUpdater addVignetteInstruction: 'Next context "Expecting who.".'.   "Run store and fetch test routine"   self storeInOntology: ontology fromFrameUpdater: frameUpdater.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test700parseSourceLineReadMe</h3><pre>test700parseSourceLineReadMe   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"   "The role prefix is optional - It only appears when one role is delegating to another."   "Comments and annotation are optional."   self skip.</pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test701parseInstructionLine</h3><pre>test701parseInstructionLine   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"   "The role prefix is optional - It only appears when one role is delegating to another."   "Comments and annotation are optional."   | pa ontology sourceLine tokenPairs |   sourceLine := 'Cook: Place cake in pre-heated oven.'.    ontology := HumOntology new.   ontology addNoun: 'cake'.   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseInstructionSource: sourceLine keywords: #().   self expect: {         'Cook'-&gt;#role.          ':'-&gt;#punctuation.          'Place'-&gt;#word.          'cake'-&gt;#noun.          'in'-&gt;#word.          'pre-heated'-&gt;#word.          'oven'-&gt;#word.          '.'-&gt;#punctuation.         }       actual: tokenPairs asArray.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test702parseInstructionLineWithComment</h3><pre>test702parseInstructionLineWithComment   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"   "The role prefix is optional - It only appears when one role is delegating to another."   "Comments and annotation are optional."   | pa ontology sourceLine tokenPairs |   sourceLine := 'Cook: Place cake in pre-heated oven. (Note: pre-heat)'.    ontology := HumOntology new.   ontology addNoun: 'cake'.   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseInstructionSource: sourceLine keywords: #().   self expect: {         'Cook'-&gt;#role.          ':'-&gt;#punctuation.          'Place'-&gt;#word.          'cake'-&gt;#noun.          'in'-&gt;#word.          'pre-heated'-&gt;#word.          'oven'-&gt;#word.          '.'-&gt;#punctuation.         '(Note: pre-heat)' -&gt; #comment.         }       actual: tokenPairs asArray.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test703parseInstructionLineWithString</h3><pre>test703parseInstructionLineWithString   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"   "The role prefix is optional - It only appears when one role is delegating to another."   "Comments and annotation are optional."   | pa ontology sourceLine tokenPairs |   sourceLine := 'Avatar: Sing "Tally Ho!"'.    ontology := HumOntology new.   ontology addNoun: 'cake'.   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseInstructionSource: sourceLine keywords: #().   self expect: {'Avatar'-&gt;#role. ':'-&gt;#punctuation. 'Sing'-&gt;#word. '"Tally Ho!"'-&gt;#string}      actual: tokenPairs asArray.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test704parseInstructionLineWithTwoComments</h3><pre>test704parseInstructionLineWithTwoComments   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"   "The role prefix is optional - It only appears when one role is delegating to another."   "Comments and annotation are optional."   | pa ontology sourceLine tokenPairs |   sourceLine := 'Cook: Place cake (pan) in pre-heated oven. (Note: pre-heat)'.    ontology := HumOntology new.   ontology addNoun: 'cake'.   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseInstructionSource: sourceLine keywords: #().   self expect: {         'Cook'-&gt;#role.          ':'-&gt;#punctuation.          'Place'-&gt;#word.          'cake'-&gt;#noun.          '(pan)'-&gt;#comment.          'in'-&gt;#word.          'pre-heated'-&gt;#word.          'oven'-&gt;#word.          '.'-&gt;#punctuation.          '(Note: pre-heat)'-&gt;#comment.         }      actual: tokenPairs asArray.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test705parseActionLine</h3><pre>test705parseActionLine   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"   "The role prefix is optional - It only appears when one role is delegating to another."   "Comments and annotation are optional."   | pa ontology sourceLine tokenPairs |   sourceLine := 'Action: Place cake in pre-heated oven.'.    ontology := HumOntology new.   ontology addNoun: 'cake'.   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseActionLine: sourceLine.   self expect: {         'Action'-&gt;#keyword.          ':'-&gt;#punctuation.          'Place'-&gt;#word.          'cake'-&gt;#noun.          'in'-&gt;#word.          'pre-heated'-&gt;#word.          'oven'-&gt;#word.          '.'-&gt;#punctuation.         }       actual: tokenPairs asArray.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test706parseActionLineWithComment</h3><pre>test706parseActionLineWithComment   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"   "The role prefix is optional - It only appears when one role is delegating to another."   "Comments and annotation are optional."   | pa ontology sourceLine tokenPairs |   sourceLine := 'Action: Place cake in pre-heated oven. (Note: pre-heat)'.    ontology := HumOntology new.   ontology addNoun: 'cake'.   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseActionLine: sourceLine.   self expect: {         'Action'-&gt;#keyword.          ':'-&gt;#punctuation.          'Place'-&gt;#word.          'cake'-&gt;#noun.          'in'-&gt;#word.          'pre-heated'-&gt;#word.          'oven'-&gt;#word.          '.'-&gt;#punctuation.         '(Note: pre-heat)'-&gt;#comment.         }       actual: tokenPairs asArray.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test707parseActionLineWithAnnotation</h3><pre>test707parseActionLineWithAnnotation   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"   "The role prefix is optional - It only appears when one role is delegating to another."   "Comments and annotation are optional."   | pa ontology sourceLine tokenPairs |   sourceLine := 'Action: Pre-heat to temperature. [native]'.    ontology := HumOntology new.   ontology addNoun: 'temperature'.   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseActionLine: sourceLine.   self expect: {         'Action'-&gt;#keyword.          ':'-&gt;#punctuation.          'Pre-heat'-&gt;#word.          'to'-&gt;#word.          'temperature'-&gt;#noun.          '.'-&gt;#punctuation.                   '[native]'-&gt;#annotation.                        }       actual: tokenPairs asArray.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test708parseActionLineWithCommentAndAnnotation</h3><pre>test708parseActionLineWithCommentAndAnnotation   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"   "The role prefix is optional - It only appears when one role is delegating to another."   "Comments and annotation are optional."   | pa ontology sourceLine tokenPairs |   sourceLine := 'Action: Pre-heat to temperature (in degrees Fahrenheit). [native]'.    ontology := HumOntology new.   ontology addNoun: 'temperature'.   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseActionLine: sourceLine.   self expect: {         'Action'-&gt;#keyword.          ':'-&gt;#punctuation.          'Pre-heat'-&gt;#word.          'to'-&gt;#word.          'temperature'-&gt;#noun.          '(in degrees Fahrenheit)'-&gt;#comment.          '.'-&gt;#punctuation.          '[native]'-&gt;#annotation         }      actual: tokenPairs asArray.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test710getLabel</h3><pre>test710getLabel   "Some framelines have labels. Some don't."   | pa source label remainder |   pa := HumProgrammersAssistant new.   source := 'Action: Bake a cake per recipe.'.   label := pa getLabelFromSource: source.   self assert: 'Action' equals: label.   remainder := pa removeLabelFromSource: source.   self assert: 'Bake a cake per recipe.' equals: remainder.</pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test711parseDictionaryLine</h3><pre>test711parseDictionaryLine   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"   "The role prefix is optional - It only appears when one role is delegating to another."   "Comments and annotation are optional."   | pa ontology sourceLine tokenPairs |   sourceLine := 'Role attributes include role-name, actions, assigned-actors.'.    ontology := HumOntology new.   ontology addNouns: #( 'role' 'role-name' 'action' 'assigned-actor' ).   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseInstructionSource: sourceLine keywords: #('attributes' 'include' 'is' 'a' 'an').   self expect: {      'Role'-&gt;#noun.       'attributes'-&gt;#keyword.       'include'-&gt;#keyword.       'role-name'-&gt;#noun.       ','-&gt;#punctuation.       'actions'-&gt;#noun.       ','-&gt;#punctuation.       'assigned-actors'-&gt;#noun.       '.'-&gt;#punctuation.      }               actual: tokenPairs asArray.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test712parseDictionaryLineWithComment</h3><pre>test712parseDictionaryLineWithComment   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"   "The role prefix is optional - It only appears when one role is delegating to another."   "Comments and annotation are optional."   | pa ontology sourceLine tokenPairs |   sourceLine := 'Role attributes include role-name, actions, assigned-actors. (assigned-actors is a run-time attribute)'.    ontology := HumOntology new.   ontology addNouns: #( 'role' 'role-name' 'action' 'assigned-actor' ).   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseInstructionSource: sourceLine keywords: #('attributes' 'include' 'is' 'a' 'an').   self expect: {      'Role'-&gt;#noun.       'attributes'-&gt;#keyword.       'include'-&gt;#keyword.       'role-name'-&gt;#noun.       ','-&gt;#punctuation.       'actions'-&gt;#noun.       ','-&gt;#punctuation.       'assigned-actors'-&gt;#noun.       '.'-&gt;#punctuation.      '(assigned-actors is a run-time attribute)'-&gt;#comment      }               actual: tokenPairs asArray.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test713parseDictionaryCategoriesLine</h3><pre>test713parseDictionaryCategoriesLine   "An instruction looks like: &lt;role&gt; : &lt;statement&gt; . (comment) [annotation]"   "The role prefix is optional - It only appears when one role is delegating to another."   "Comments and annotation are optional."   | pa ontology sourceLine tokenPairs |   sourceLine := 'Frame-type categories include goal-frame, role-frame, context-frame, view-frame.'.    ontology := HumOntology new.   ontology addNouns: #( 'frame-type' 'goal-frame' 'role-frame' 'context-frame' 'view-frame'  ).   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseInstructionSource: sourceLine keywords: #('attributes'  'categories' 'include' 'is' 'a' 'an' ).   self expect: {      'Frame-type'-&gt;#noun.       'categories'-&gt;#keyword.       'include'-&gt;#keyword.       'goal-frame'-&gt;#noun.       ','-&gt;#punctuation.       'role-frame'-&gt;#noun.       ','-&gt;#punctuation.       'context-frame'-&gt;#noun.       ','-&gt;#punctuation.       'view-frame'-&gt;#noun.       '.'-&gt;#punctuation.      }      actual: tokenPairs asArray.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test720getComment</h3><pre>test720getComment   "Some framelines have comments. Some don't."   | pa source comment remainder |   pa := HumProgrammersAssistant new.   source := 'Action: Bake a cake per recipe. (Recipe is a noun.)'.   "Note: Following assumes there is just one comment in the source.   If there is more than one comment, only the first one is returned."   comment := pa getCommentFromSource: source.   self assert: '(Recipe is a noun.)' equals: comment.   remainder := pa removeCommentFromSource: source.   self assert: 'Action: Bake a cake per recipe.' equals: remainder.</pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test725noComment</h3><pre>test725noComment   "Some framelines have comments. Some don't."   | pa source comment remainder |   pa := HumProgrammersAssistant new.   source := 'Action: Bake a cake per recipe. '.   comment := pa getCommentFromSource: source.   self expect: nil actual: comment.   remainder := pa removeCommentFromSource: source.   self expect: source trimBoth actual: remainder.</pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test730getAnnotation</h3><pre>test730getAnnotation   "Some framelines have annotations. Some don't."   | pa source annotation remainder |   pa := HumProgrammersAssistant new.   source := 'Equipment is washed and ready. [Assumed.]'.   annotation := pa getAnnotationFromSource: source.   self expect: '[Assumed.]' actual: annotation.   remainder := pa removeAnnotationFromSource: source.   self expect: 'Equipment is washed and ready.' actual: remainder.</pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test735noAnnotation</h3><pre>test735noAnnotation   "Some framelines have annotations. Some don't."   | pa source annotation remainder |   pa := HumProgrammersAssistant new.   source := 'Equipment is washed and ready. (There is no annotation here.)'.   annotation := pa getAnnotationFromSource: source.   self expect: nil actual: annotation.   remainder := pa removeAnnotationFromSource: source.   self expect: source actual: remainder.</pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test741getOneWidget</h3><pre>test741getOneWidget   "Markup-line class includes own parser.     TODO: Maybe there should be just one parser."   |  markupLine widgets |   markupLine :=  HumMarkupLine source: 'This string contains a widget between brackets: [widget-content]'.   widgets := markupLine widgets.      self assert: ( widgets includes: '[widget-content]')      </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test742getTwoWidgets</h3><pre>test742getTwoWidgets   "Markup-line includes a parser."   | markupLine widgets |   markupLine :=  HumMarkupLine                   source: 'This string contains two widgets: [widget-content-1] and also [widget-content-2]'.   widgets := markupLine widgets.      self assert: ( widgets includes: '[widget-content-1]').   self assert: ( widgets includes: '[widget-content-2]').   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test743getTwoWidgetsAndButton</h3><pre>test743getTwoWidgetsAndButton   "Markup-line includes a parser."   | markupLine widgets |   markupLine :=  HumMarkupLine                   source: 'This string contains two widgets: [widget-content-1] and also [widget-content-2] and [[button]]'.   widgets := markupLine widgets.      self assert: ( widgets includes: '[widget-content-1]').   self assert: ( widgets includes: '[widget-content-2]').   self assert: ( widgets includes: '[[button]]').   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test751parseOneWidget</h3><pre>test751parseOneWidget   "Parse a markup-line containing a widget."   |   ontology pa sourceLine tokenPairs |   sourceLine :=  'This string contains a widget between brackets:  [widget-content]'.   ontology := HumOntology new.   ontology addNoun: 'cake'.   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseMarkupSource: sourceLine.   self expect:{         'This'-&gt;#word.          ' '-&gt;#whitespace.          'string'-&gt;#word.          ' '-&gt;#whitespace.          'contains'-&gt;#word.          ' '-&gt;#whitespace.          'a'-&gt;#word.          ' '-&gt;#whitespace.          'widget'-&gt;#word.          ' '-&gt;#whitespace.          'between'-&gt;#word.          ' '-&gt;#whitespace.          'brackets'-&gt;#word.          ':'-&gt;#punctuation.          ' '-&gt;#whitespace.          ' '-&gt;#whitespace.          '[widget-content]'-&gt;#widget         }      actual: tokenPairs asArray.         </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test752parseMultipleWidgets</h3><pre>test752parseMultipleWidgets   "Parse a markup line containing multiple widgets."   |   ontology pa sourceLine tokenPairs |   sourceLine :=  '[city], [state] [postal-code]'.   ontology := HumOntology new.   ontology addNouns: #('city' 'state' 'postal-code').   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseMarkupSource: sourceLine.   self expect: {            '[city]'-&gt;#widget.             ','-&gt;#punctuation.             ' '-&gt;#whitespace.             '[state]'-&gt;#widget.             ' '-&gt;#whitespace.             '[postal-code]'-&gt;#widget            }      actual: tokenPairs asArray.         </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test753parseRadioButtons</h3><pre>test753parseRadioButtons   "Parse a line containing radio button widgets."   |   ontology pa sourceLine tokenPairs |   sourceLine :=  '(y) Yes  (n) No'.   ontology := HumOntology new.   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseMarkupSource: sourceLine.   self expect: {            '(y)'-&gt;#widget.             ' '-&gt;#whitespace.             'Yes'-&gt;#word.             ' '-&gt;#whitespace.             ' '-&gt;#whitespace.             '(n)'-&gt;#widget.             ' '-&gt;#whitespace.             'No'-&gt;#word.            }      actual: tokenPairs asArray.         </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test754parseActionButton</h3><pre>test754parseActionButton   "Parse a line containing an action button."   |   ontology pa sourceLine tokenPairs |   sourceLine :=  '[[submit]]'.   ontology := HumOntology new.   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseMarkupSource: sourceLine.   self expect: { '[[submit]]'-&gt;#widget. }            actual: tokenPairs asArray.         </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test755parseLinkWidget</h3><pre>test755parseLinkWidget   "Parse a mark-up line with a link widget."   |   ontology pa sourceLine tokenPairs |   sourceLine :=  'More info [link: here | http:xxx.org ]'.   ontology := HumOntology new.   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseMarkupSource: sourceLine.   self expect: {         'More'-&gt;#word.          ' '-&gt;#whitespace.          'info'-&gt;#word.          ' '-&gt;#whitespace.          '[link: here | http:xxx.org ]'-&gt;#widget.         }      actual: tokenPairs asArray.         </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test760parseEmphasisMarkup</h3><pre>test760parseEmphasisMarkup   "Parse a mark-up line with emphasis markup."   |   ontology pa sourceLine tokenPairs |   sourceLine :=  'Emphasis *bold* ~italic~ _underline_ ^superscript^.'.   ontology := HumOntology new.   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseMarkupSource: sourceLine.   self expect: {         'Emphasis'-&gt;#word.          ' '-&gt;#whitespace.          '*'-&gt;#markup.          'bold'-&gt;#word.          '*'-&gt;#markup.          ' '-&gt;#whitespace.          '~'-&gt;#markup.          'italic'-&gt;#word.          '~'-&gt;#markup.          ' '-&gt;#whitespace.          '_'-&gt;#markup.          'underline'-&gt;#word.          '_'-&gt;#markup.          ' '-&gt;#whitespace.          '^'-&gt;#markup.          'superscript'-&gt;#word.          '^'-&gt;#markup.          '.'-&gt;#punctuation         }      actual: tokenPairs asArray.         </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test770parseHeadingMarkup</h3><pre>test770parseHeadingMarkup   "Parse a mark-up line with emphasis markup."   |   ontology pa sourceLine tokenPairs |   sourceLine :=  '!!!This is a level 3 heading.'.   ontology := HumOntology new.   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseMarkupSource: sourceLine.   self expect: {         '!!!'-&gt;#markup.          'This'-&gt;#word.          ' '-&gt;#whitespace.          'is'-&gt;#word.          ' '-&gt;#whitespace.          'a'-&gt;#word.          ' '-&gt;#whitespace.          'level'-&gt;#word.          ' '-&gt;#whitespace.          '3'-&gt;#word.          ' '-&gt;#whitespace.          'heading'-&gt;#word.          '.'-&gt;#punctuation.         }      actual: tokenPairs asArray.         </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test772parseBulletListMarkup</h3><pre>test772parseBulletListMarkup   "Parse a mark-up line with bullet list markup."   |   ontology pa sourceLine tokenPairs |   sourceLine :=  '---This is a level 3 list outline.'.   ontology := HumOntology new.   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseMarkupSource: sourceLine.   self expect: {         '---'-&gt;#markup.          'This'-&gt;#word.          ' '-&gt;#whitespace.          'is'-&gt;#word.          ' '-&gt;#whitespace.          'a'-&gt;#word.          ' '-&gt;#whitespace.          'level'-&gt;#word.          ' '-&gt;#whitespace.          '3'-&gt;#word.          ' '-&gt;#whitespace.          'list'-&gt;#word.          ' '-&gt;#whitespace.          'outline'-&gt;#word.          '.'-&gt;#punctuation.         }      actual: tokenPairs asArray.         </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test773parseNumberListMarkup</h3><pre>test773parseNumberListMarkup   "Parse a mark-up line with emphasis markup."   |   ontology pa sourceLine tokenPairs |   sourceLine :=  '###This is a level 3 number list outline.'.   ontology := HumOntology new.   pa := HumProgrammersAssistant new.   pa ontology: ontology.   tokenPairs := pa parseMarkupSource: sourceLine.   self expect: {         '###'-&gt;#markup.          'This'-&gt;#word.          ' '-&gt;#whitespace.          'is'-&gt;#word.          ' '-&gt;#whitespace.          'a'-&gt;#word.          ' '-&gt;#whitespace.          'level'-&gt;#word.          ' '-&gt;#whitespace.          '3'-&gt;#word.          ' '-&gt;#whitespace.          'number'-&gt;#word.          ' '-&gt;#whitespace.          'list'-&gt;#word.          ' '-&gt;#whitespace.          'outline'-&gt;#word.          '.'-&gt;#punctuation         }      actual: tokenPairs asArray.         </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test800LoadFileReadMe</h3><pre>test800LoadFileReadMe   "The Programmers Assistant may load and parse a text file.   1. The framing-convention is that frames are separated by ===.   The older versions of Hum/Simple English used --- as a frame-delimiter.   But this version also uses lines beginning with '---' in the mark-up notation.   2. All frames should begin with a title line       so that the type of frame can be quickly recognized by humans and the PA-Loader.   3. For convenience, empty frames should be tolerated (but not stored).   4. For convenience, the file may begin with a frame-delimiter (===).   5. For convenience, the file may end with an end-of-file (missing frame-delimiter).   "      "Frames are separated by lines beginning with ===.   Comment: Additional content may follow a leading === - but that content will be ignored.   Authors may delimit frames by =============================== if they like.   Authors may delimit groups of frames with banners.   ==================================   ===== Views Collected Below ======   ==================================   "</pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test810FramesAreSeparatedByFrameDelimiter</h3><pre>test810FramesAreSeparatedByFrameDelimiter   "Frames are separated by lines beginning with ===.   Comment: Additional content may follow a leading === - but that content will be ignored.   Authors may delimit frames by =============================== if they like.   Authors may delimit groups of frames with banners.   ==================================   ===== Views Collected Below ======   ==================================   "   | stream pa |   stream := ReadWriteStream on: ''.   stream basicNextPutAll: 'View: Standard Footer.   Copyright 2014 RichardAlexanderGreen.==='.   stream position: 0.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextStream: stream.   self expect: 1 actual: ( pa ontology frames size ).   self expect: 1 actual: ( pa ontology frames count: [:frame | frame isKindOf: HumFrame4View ]).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test811StreamStartsWithFrameDelimiter</h3><pre>test811StreamStartsWithFrameDelimiter   "Test where file starts with a frame-delimiter."   | stream pa |   stream := ReadWriteStream on: ''.   "Test where file starts with a frame-delimiter."   stream basicNextPutAll: '========= First Line ============View: Standard Footer.   Copyright 2014 RichardAlexanderGreen.==='.   stream position: 0.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextStream: stream.   self expect: 1 actual: ( pa ontology frames size ).   self expect: 1 actual: ( pa ontology frames count: [:frame | frame isKindOf: HumFrame4View ]).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test812StreamEndsWithEndOfFile</h3><pre>test812StreamEndsWithEndOfFile   "Test where frame ends on end-of-file"   | stream pa |   stream := ReadWriteStream on: ''.   "Test where frame ends on end-of-file"   stream basicNextPutAll: 'View: Standard Footer.   Copyright 2014 RichardAlexanderGreen.'.   stream position: 0.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextStream: stream.   self expect: 1 actual: ( pa ontology frames size ).   self expect: 1 actual: ( pa ontology frames count: [:frame | frame isKindOf: HumFrame4View ]).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test813StreamStartsWithFrameDelimiterEndsWithEOF</h3><pre>test813StreamStartsWithFrameDelimiterEndsWithEOF   "Test where file starts with a frame-delimiter and ends on end-of-file."   | stream pa |   stream := ReadWriteStream on: ''.   "Test where file starts with a frame-delimiter and ends on end-of-file."   stream basicNextPutAll: '========= First Line ============View: Standard Footer.   Copyright 2014 RichardAlexanderGreen.'.   stream position: 0.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextStream: stream.   self expect: 1 actual: ( pa ontology frames size ).   self expect: 1 actual: ( pa ontology frames count: [:frame | frame isKindOf: HumFrame4View ]).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test814StreamHasViewAndDictionaryFrames</h3><pre>test814StreamHasViewAndDictionaryFrames   "Load two frames: a view frame and a dictionary frame."   | stream pa |   stream := ReadWriteStream on: ''.   "Load two frames."   stream basicNextPutAll: '========= First Line ============View: Standard Footer.   Copyright 2014 RichardAlexanderGreen.===Dictionary: User/Client Attributes.   User attributes include name, email, passwordHash.==='.   stream position: 0.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextStream: stream.   self expect: 2 actual: ( pa ontology frames size ).   self expect: 1 actual: ( pa ontology frames count: [:frame | frame isKindOf: HumFrame4Dictionary ] ).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test815StreamHasViewDictionaryAndPlanFrame</h3><pre>test815StreamHasViewDictionaryAndPlanFrame   "Load three frames: a view, a dictionary, and a plan frame."   | stream pa frames planFrames planLines |   stream := ReadWriteStream on: ''.   "Load three frames."   stream basicNextPutAll: '========= This is only a test ===============View: Standard Footer.   Copyright 2014 RichardAlexanderGreen.===Dictionary: User/Client Attributes.   User attributes include name, email, password-hash.===Goal: Bake a cake per recipe.Preconditions:   Oven is preheated per recipe`s oven-temperature.   Batter is prepared per recipe.   Batter is in cake-pan prepared per recipe.Action:   Arm: Place cake-pan in oven.   Timer: Wait for recipe`s bake-time.==='.   stream position: 0.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextStream: stream.   frames := pa ontology frames.   self expect: 3 actual: (frames size).   self expect: 1 actual: ( frames count: [:frame | frame isKindOf: HumFrame4Plan ] ).   self expect: 1 actual: ( frames count: [:frame | frame isKindOf: HumFrame4View ] ).   self expect: 1 actual: ( frames count: [:frame | frame isKindOf: HumFrame4Dictionary ] ).      "Test for correct number of plan lines. (Remove defect where block labels are of wrong type.)"   planFrames := ( frames select: [:frame | frame isKindOf: HumFrame4Plan ] ) asOrderedCollection.   planLines := ( planFrames at: 1 ) frameLines.   self expect: 3 actual: ( planLines count: [:frameLine | frameLine isKindOf: HumConditionLine ] ).   self expect: 2 actual: ( planLines count: [:frameLine | frameLine isKindOf: HumInstructionLine ] ).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test816StreamHasViewDictionaryPlanAndCommentFrames</h3><pre>test816StreamHasViewDictionaryPlanAndCommentFrames   "Load four frames: a view, a dictionary, a plan, and a comment frame."   | stream pa |   stream := ReadWriteStream on: ''.   "Load four frames."   stream basicNextPutAll: '========= This is only a test ===============View: Standard Footer.   Copyright 2014 RichardAlexanderGreen.===Dictionary: User/Client Attributes.   User attributes include name, email, password-hash.===Goal: Bake a cake per recipe.Preconditions:   Oven is preheated per recipe`s oven-temperature.   Batter is prepared per recipe.   Batter is in cake-pan prepared per recipe.Action:   Arm: Place cake-pan in oven.   Timer: Wait for recipe`s bake-time.===Comment: Some nouns may not need to be identified.   It may or may not be necessary to identify some nouns in the domain.   Nouns like oven and cake-pan (above) might not have variable values at run-time.==='.   stream position: 0.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextStream: stream.   self expect: 4 actual: ( pa ontology frames size ).   self expect: 1 actual: ( pa ontology frames count: [:frame | frame isKindOf: HumFrame4Comment ] ).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test817StreamHasViewDictionaryPlanAndActionFrames</h3><pre>test817StreamHasViewDictionaryPlanAndActionFrames   "Load four frames: a view, a dictionary, a plan, and an action frame."   | stream pa frames |   stream := ReadWriteStream on: ''.   "Load four frames."   stream basicNextPutAll: '========= This is only a test ===============View: Standard Footer.   Copyright 2014 RichardAlexanderGreen.===Dictionary: User/Client Attributes.   User attributes include name, email, password-hash.===Goal: Bake a cake per recipe.Preconditions:   Oven is preheated per recipe`s oven-temperature.   Batter is prepared per recipe.   Batter is in cake-pan prepared per recipe.Action:   Arm: Place cake-pan in oven.   Timer: Wait for recipe`s bake-time.===Role: Arm.Action: Place cake-pan in oven.   Open oven door.   Pick-up cake-pan.   Place cake-pan inside oven.To: Open oven door.   Position carriage in front of oven.   Grab door handle.   Pull door handle to open position.==='.   stream position: 0.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextStream: stream.   frames := pa ontology frames.   self expect: 5 actual: frames size.   self expect: 2 actual: ( frames count: [:frame | frame isKindOf: HumFrame4Action ] ).   self expect: 1 actual: ( frames count: [:frame | frame isKindOf: HumFrame4Plan ] ).   self expect: 1 actual: ( frames count: [:frame | frame isKindOf: HumFrame4Dictionary ] ).   self expect: 1 actual: ( frames count: [:frame | frame isKindOf: HumFrame4View ] ).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test820StreamHasVignettes</h3><pre>test820StreamHasVignettes   "Test that vignettes are properly parsed, loaded, and indexed."   | stream pa frames |      stream := ReadWriteStream on: ''.   "Load these frames."   stream basicNextPutAll:'===Context: Start.U: Enter.S: Club Mech is a test bed for Hum dialogs.U: My name is [user-name].U: Authenticated as [user-name].S: Hello [user-name].   Please select an activity.. Push context "Select an activity.".U: I am a member.S: What is your name?U: *.S: Welcome to Club Mech.   Are you a member? ===Context: Select an activity.U: Propose a topic.U: Suggest a topic.U: Recommend a topic.U: Introduce a topic.U: Enter a topic.S: Please enter a description of the talk you are offering.. Ask topic.U: Vote *.S: Here is the current ballot.. Ask voter-ballot.. (Assumes a ballot is available / usable.)U: * scoreboard.S: Here is the scoreboard for the current ballot.. Show scoreboard.. (Also assumes a ballot is available / usable.)==='.   stream position: 0.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextStream: stream.   frames := pa ontology frames.   self expect: 7 actual: frames size description: 'Expecting one frame per vignette.'.   self expect: 7 actual: ( frames count: [:frame | frame isKindOf: HumFrame4Vignette ] ).   self expect: 7 actual: (pa ontology contextVignettes size ).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test830LoadActionFrame</h3><pre>test830LoadActionFrame   "Load, parse, and render a slightly tricky action frame."   | stream pa frames html ideal |   stream := ReadWriteStream on: ''.   stream basicNextPutAll:'Role: Order-Checker. Action: Give carriers to the customer. . Match carrier to order. . Move matched carrier to scale. . (This catches most errors with carrier sequencing.) . If scale weight matches order`s expected weight: . . Release carriers to customer.[ native] . Else : . . (Most likely error is that carrier is out of sequence.)  . . Check for carrier-sequence-error. . . (Now what?)'.   stream position: 0.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextStream: stream.   frames := pa ontology frames asOrderedCollection.   self expect: 1 actual: (frames size).   self expect: 1 actual: (frames count: [:frame | frame isKindOf: HumFrame4Action ]).   "actionFrame := frames at: 1."   html := pa ontology view renderAsHTMLonFileNamed: 'test830LoadActionFrame..html'.   self assert: ('*Role:*' match: html).   self assert: ('*Action:*' match: html).   self assert: ('*class="indent2"*class="indent1"*class="indent2"*' match: html)          description: 'Should see indent pattern.'.   self assert: ('*&lt;k&gt;*&lt;/k&gt;*&lt;k&gt;*&lt;/k&gt;*' match: html) description: 'Should see 2 keyword markers.'.    "   HumCalculator writeString: ideal toFileNamed: 'test930LoadActionFrameIdeal.html'.    HumCalculator writeString: html toFileNamed: 'test930LoadActionFrameActual.html'.   "   ideal := self text930expected.      HumCalculator diffCandidate: html againstIdeal: ideal showing: 3.            </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test910LoadFromTextFile</h3><pre>test910LoadFromTextFile   "Load from pizza-ontology.txt"   |  pa fileName |   fileName := 'pizza-ontology.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   self assert: ( pa ontology frames anySatisfy: [:frame | frame isKindOf: HumFrame4Vignette ]).   self expect: 49 actual: ( pa ontology frames size ).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test912LoadDonutShop</h3><pre>test912LoadDonutShop   "Load from pizza-ontology.txt"   |  pa fileName frames |   fileName := 'DonutShopV05.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   frames := pa ontology frames.   self expect: 105 actual: ( frames size ). "Includes base-ontology."   self assert: ( frames anySatisfy: [:frame | frame isKindOf: HumFrame4Vignette ]).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test913LoadBarista</h3><pre>test913LoadBarista   "Load from pizza-ontology.txt"   |  pa fileName frames |   fileName := 'Barista.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   frames := pa ontology frames.   self expect: 38 actual: ( frames size ) description: 'Was text file changed?'.   "We want at least one of each type of frame."   self assert: ( frames anySatisfy: [:frame | frame isKindOf: HumFrame4Dictionary ]).   self assert: ( frames anySatisfy: [:frame | frame isKindOf: HumFrame4Vignette ]).   self assert: ( frames anySatisfy: [:frame | frame isKindOf: HumFrame4Comment ]).   self assert: ( frames anySatisfy: [:frame | frame isKindOf: HumFrame4Action ]).   self assert: ( frames anySatisfy: [:frame | frame isKindOf: HumFrame4View ]).   self assert: ( frames anySatisfy: [:frame | frame isKindOf: HumFrame4Plan ]).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test914LoadClubMech</h3><pre>test914LoadClubMech   "Load from pizza-ontology.txt"   |  pa fileName frames |   "Transcript cr; show: 'test914LoadClubMech begins'."   fileName := 'ClubMechV02.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   frames := pa ontology frames.   self assert: (pa ontology contextVignettes size &gt; 0).   "Transcript cr; show: 'test914LoadClubMech ends'."   self expect: 47 actual: ( frames size ).   self assert: ( frames anySatisfy: [:frame | frame isKindOf: HumFrame4Vignette ]).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test920LoadFromTextFileAndRenderAsHTML</h3><pre>test920LoadFromTextFileAndRenderAsHTML   "Load from pizza-ontology.txt"   | fileName pa |   fileName := 'Pizza-Ontology.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   pa ontology compileAllFrames.   pa ontology view renderAsHTMLonFileNamed: 'Pizza-Ontology.html'.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test922LoadDonutShopAndRenderAsHTML</h3><pre>test922LoadDonutShopAndRenderAsHTML   "Load from some-ontology.txt"   | fileName pa |   fileName := 'DonutShopV05.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   pa ontology compileAllFrames.   pa ontology view renderAsHTMLonFileNamed: 'DonutShopV05.html'.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test923LoadBaristaAndRenderAsHTML</h3><pre>test923LoadBaristaAndRenderAsHTML   "Load from some-ontology.txt"   | fileName pa |   fileName := 'Barista.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   pa ontology compileAllFrames.   pa ontology view renderAsHTMLonFileNamed: 'Barista.html'.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test924LoadClubMechAndRenderAsHTML</h3><pre>test924LoadClubMechAndRenderAsHTML   "Load from some-ontology.txt"   | fileName pa html |   fileName := 'ClubMechV02.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   pa ontology compileAllFrames.   self assert: ( pa ontology frames anySatisfy: [:frame | frame title beginsWith: 'Context:']).
   html := pa ontology view renderAsHTMLonFileNamed: 'test924LoadClubMechAndRenderAsHTML.html'.   self assert: ('*Context:*' match: html).   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test925LoadClubMechAndRenderAsHTMLwithCritique</h3><pre>test925LoadClubMechAndRenderAsHTMLwithCritique   "Load from some-ontology.txt"   | fileName pa html problems n |   fileName := 'ClubMechV02.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   problems := pa ontology compileAllFrames.   self assert: ( pa ontology frames anySatisfy: [:frame | frame title beginsWith: 'Context:']).
   html := pa ontology view renderAsHTMLwithCritiqueOnFileNamed: 'test925LoadClubMechAndRenderAsHTMLwithCritique.html'.   self assert: ('*Context:*' match: html).   n := problems size.   self expect: 0 actual: n description: ('There are', ( n asString ),' problems in {', fileName, '}').   self deny: ('*not been defined*' match: html ) description: 'Some actions have not been defined.'.   self log: 'Needs work connecting Dialog-Agent *Show* and *Push* and *Ask* with internal frames/sub-frames.'   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test926LoadDonutShopAndRenderAsHTMLwithCritique</h3><pre>test926LoadDonutShopAndRenderAsHTMLwithCritique   "Load from some-ontology.txt"   | fileName pa html problems n |   fileName := 'DonutShopV06.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   problems := pa ontology compileAllFrames.   self assert: ( pa ontology frames anySatisfy: [:frame | frame title beginsWith: 'Context:']).
   html := pa ontology view renderAsHTMLwithCritiqueOnFileNamed: 'test926LoadDonutShopAndRenderAsHTMLwithCritique.html'.   self assert: ('*Context:*' match: html).   self deny: ('*not been defined*' match: html ) description: 'Some actions are not defined.'.   n := problems size.   self expect: 0 actual: n description: 'We do expect problems in this Ontology.'.   self log: 'This ontology uses a number of advanced features that are not implemented yet.'.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test927LoadBaseOntologyAndRenderAsHTMLwithCritique</h3><pre>test927LoadBaseOntologyAndRenderAsHTMLwithCritique   "Load from some-ontology.txt"   | fileName pa html problems |   fileName := 'BaseOntology.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   problems := pa ontology compileAllFrames. "HumOntology"   self assert: ( pa ontology frames anySatisfy: [:frame | frame title beginsWith: 'Comment:']).
   html := pa ontology view renderAsHTMLwithCritique: true withBase: true onFileNamed: 'test927LoadBaseOntologyAndRenderAsHTMLwithCritique.html'.   self assert: ('*Base Ontology*' match: html).   self assert: (problems isEmpty) description: 'There should be no problems in Base Ontology.'.   self deny: ('*not been defined*' match: html ) description: 'Some actions have not been defined.'.   self log: 'Think about how Bookkeeper actions get associated with business events.'.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test928LoadVROntologyAndRenderAsHTMLwithCritique</h3><pre>test928LoadVROntologyAndRenderAsHTMLwithCritique   "Load from some-ontology.txt"   | fileName pa html problems n |   fileName := 'VR-Ontology.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   problems := pa ontology compileAllFrames. "HumOntology"      self assert: ( pa ontology frames anySatisfy: [:frame | frame title beginsWith: 'Comment:']).      html := pa ontology view renderAsHTMLwithCritiqueOnFileNamed: 'test928LoadVROntologyAndRenderAsHTMLwithCritique.html'.   self assert: ('*VR-Ontology*' match: html).   n := problems size.   self expect: 0 actual: n description: 'VR Ontology has ', (n asString),' problems.'.   self deny: ('*not been defined*' match: html ) description: 'Some actions have not been defined.'.   self log: 'Think about how Bookkeeper actions get associated with business events.'.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test929LoadMarkupViewAndRenderAsHTMLwithCritique</h3><pre>test929LoadMarkupViewAndRenderAsHTMLwithCritique   "Load from some-ontology.txt"   | fileName pa html problems |   fileName := 'DemoTestMarkup.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   problems := pa ontology compileAllFrames. "HumOntology"   self assert: ( pa ontology frames anySatisfy: [:frame | frame title beginsWith: 'Comment:']).
   html := pa ontology view renderAsHTMLwithCritiqueOnFileNamed: 'test929LoadMarkupViewAndRenderAsHTMLwithCritique.html'.   self assert: ('*Header 1*' match: html).   self assert: (problems size = 0) description: 'There should be no problems in Markup Test.'.
   "TODO: RESULTING RENDERING HAS ERRORS. THIS TEST NEEDS MORE ASSERTIONS."   self deny: ('*not been defined*' match: html ) description: 'Some actions have not been defined.'.   self log:'Think about how Bookkeeper actions get associated with business events.'.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test930LoadToDoListAndRenderAsHTMLwithCritique</h3><pre>test930LoadToDoListAndRenderAsHTMLwithCritique   "Load from some-ontology.txt"   | fileName pa html problems |   fileName := 'ToDoList-Ontology.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName. "Note: Base ontology will be included first."   problems := pa ontology compileAllFrames. "HumOntology"      self assert: ( pa ontology frames anySatisfy: [:frame | frame title beginsWith: 'Comment:']).   html := pa ontology view renderAsHTMLwithCritiqueOnFileNamed: 'test930LoadToDoListAndRenderAsHTMLwithCritique.html'.      </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test931LoadBootStrapOntologyAndRenderAsHTMLwithCritique</h3><pre>test931LoadBootStrapOntologyAndRenderAsHTMLwithCritique   "Load from some-ontology.txt"   | fileName pa html problems |   fileName := 'BootStrap-Ontology.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName. "Note: Base ontology will be included first."   problems := pa ontology compileAllFrames. "HumOntology"   self assert: ( pa ontology frames anySatisfy: [:frame | frame title beginsWith: 'Comment:']).
   html := pa ontology view renderAsHTMLwithCritiqueOnFileNamed: 'test931LoadBootStrapOntologyAndRenderAsHTMLwithCritique.html'.
   self assert: ( '*frame-line*attributes*' match: html ).      </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test944LoadClubMechSaveReload</h3><pre>test944LoadClubMechSaveReload   "Load from some-ontology.txt, save it, reload it."   |  pa fileName frames saveFileName |   "Transcript cr; show: 'test914LoadClubMech begins'."   fileName := 'ClubMechV02.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   frames := pa ontology frames.   self expect: 47 actual: ( frames size ) description: 'Base or Club Mech frame-count changed'.   self expect: 11 actual: ( pa ontology contextVignettes size ) description: 'Base or Club Mech vignettes changed'..   self expect: 11 actual: ( frames count: [:frame | frame isKindOf: HumFrame4Vignette ]).      "Save it to another file and reload it from the saved file."   saveFileName := 'test944LoadClubMechSaveReload.txt'.   pa writeOntologyOnTextFileNamed: saveFileName.   "Load it back - should get same result as before."   pa := HumProgrammersAssistant new.   pa loadOntologyFromSaveFileNamed: saveFileName.   frames := pa ontology frames.   self expect: 47 actual: ( frames size ) description: 'Reloaded file should match original.'.   self assert: (pa ontology contextVignettes size &gt; 0).   self expect: 11 actual: ( frames count: [:frame | frame isKindOf: HumFrame4Vignette ]).         </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test945LoadDonutShopSaveReload</h3><pre>test945LoadDonutShopSaveReload   "Load from some-ontology.txt, save it, reload it."   |  pa fileName zFrames saveFileName ontologyA ontologyB |   fileName := 'DonutShopV06.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   ontologyA := pa ontology.    zFrames := pa ontology frames select: [ :frame | frame origin = 'DonutShopV06.txt' ].   self expect: 78 actual: ( zFrames size ) description: 'Watch for changes'.   self expect: 50 actual: ( zFrames count: [:frame | frame isKindOf: HumFrame4Action ]).   self expect: 0 actual: ( zFrames count: [:frame | frame isKindOf: HumFrame4Comment ]).   self expect: 0 actual: ( zFrames count: [:frame | frame isKindOf: HumFrame4Data ]).   self expect: 11 actual: ( zFrames count: [:frame | frame isKindOf: HumFrame4Dictionary ]).   self expect: 3 actual: ( zFrames count: [:frame | frame isKindOf: HumFrame4Plan ]).   self expect: 5 actual: ( zFrames count: [:frame | frame isKindOf: HumFrame4View ]).   self expect: 9 actual: ( zFrames count: [:frame | frame isKindOf: HumFrame4Vignette ]).      "Save it to another file and reload it from the saved file."   saveFileName := 'test945LoadDonutShopSaveReload.txt'.   pa writeOntologyOnTextFileNamed: saveFileName.   "Load it back - should get same result as before."   pa := HumProgrammersAssistant new.   pa loadOntologyFromSaveFileNamed: saveFileName.   ontologyB := pa ontology.   zFrames := pa ontology frames select: [ :frame | frame origin = 'test945LoadDonutShopSaveReload.txt' ].   "Counts should be same as above."   self expect: 102 actual: ( pa ontology frames size ) description: 'Watch for BaseOntology loaded twice.'.   "TODO: We lost the origin of the frames when we wrote them out."   self expect: 102 actual: ( zFrames size ) description: 'Watch for changes'.            </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test954LoadClubMechSaveReload</h3><pre>test954LoadClubMechSaveReload   "Load from some-ontology.txt, save it, reload it."   |  pa fileName frames saveFileName |   "Transcript cr; show: 'test914LoadClubMech begins'."   fileName := 'ClubMechV02.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   frames := pa ontology frames.   self assert: (pa ontology contextVignettes size &gt; 0).   self expect: 47 actual: ( frames size ) description: 'Watch for changes in test data.'.   self expect: 11 actual: ( frames count: [:frame | frame isKindOf: HumFrame4Vignette ]).      "Save it to another file and reload it from the saved file."   saveFileName := 'test954LoadClubMechSaveReload.txt'.   pa writeOntologyOnTextFileNamed: saveFileName.   "Load it back - should get same result as before."   pa := HumProgrammersAssistant new.   pa loadOntologyFromSaveFileNamed: saveFileName.   frames := pa ontology frames.   self assert: (pa ontology contextVignettes size &gt; 0).   self expect: 47 actual: ( frames size ) description: 'Number of frames should be preserved.'.   self expect: 11 actual: ( frames count: [:frame | frame isKindOf: HumFrame4Vignette ]).         </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; test971CreateNounTreeGraph</h3><pre>test971CreateNounTreeGraph   "Create a graph of the base ontology noun tree."   | fileName pa  problems diagram ontology |   fileName := 'BaseOntology.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   problems := pa ontology compileAllFrames.    self expect: 0 actual: (problems size) description: 'Run this test with no problems.'.   "Assign creation of the noun tree to Ontology (HumOntology).     Assign rendering to Ontology-Viewer (HumOntologyViewer)."   diagram := HumDiagram new.   ontology := pa ontology.   ontology view buildDiagramForNoun: 'employee' onDiagram: diagram.    self expect: 11 actual: diagram nodes size.   </pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; testU000UserInitiatedEvents</h3><pre>testU000UserInitiatedEvents"Plan for user-initiated events.""KeyboardEvents:calc switch: keyCharacter;   on: { space. period. return.  } do: [ self parseCurrentLine; analyzeCurrentLine; highlightCurrentLine ];   on: { up. } do: [ self highlightCurrentLine; bumpCursor: (0@-1). ];   on: { down. } do: [ self highlightCurrentLine; bumpCursor: (0@+1). ];   on: { $( } do: [ self insert: $); bumpCursor: (-1@0). ];   on: { $[ } do: [ self insert: $]; bumpCursor: (-1@0). ];   on: { quote.  } do: [ self insert: quote; bumpCursor: (-1@0). ];   on: { doubleQuote.  } do: [ self insert: doubleQuote; bumpCursor: (-1@0). ];   onOtherValuesDo: [ self insert: keyCharacter ].""OntologyUpdateEvents:- In addition to updating the ontology, update theses diagrams ==&gt; (triggering view updates where view is active).calc switch: ontologyEvent;   on: { #newEntityType. #newEntityAttributeSet. #newCategorySet }                                 do: [ self updateNounGraph. ];   on: { #newPrecondition }   do: [ self updatePlanGraph ];   on: { #newDelegation }      do: [ self updateRoleDependencyGraph ];   on: { #newPushContext }   do: [ self updateContextFlowGraph ];   ""RenameEvents:When an ontology noun or statement definition is replaced in editor, we need to ask: Should it be replaced everywhere?- Entity replaced in dictionary statement. (entity renamed)- Attribute replaced in dictionary statement. (attribute renamed)- Category replaced in dictionary statement. (category renamed)- Statement replaced in 'Action: . . .' (action renamed)- Statement replaced in 'Goal: . . .' (goal renamed)- View-frame renamed. (view renamed)- Context-frame renamed. (context renamed)"</pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; testU100KeyBoardEvents</h3><pre>testU100KeyBoardEvents"KeyboardEvents:Given: EditFrame is active.When: User presses key.Then: Editor notified.Then: Editor responds . . .calc switch: keyCharacter;   on: { space. period. return.  } do: [ self parseCurrentLine; analyzeCurrentLine; highlightCurrentLine ];   on: { up. } do: [ self highlightCurrentLine; bumpCursor: (0@-1). ];   on: { down. } do: [ self highlightCurrentLine; bumpCursor: (0@+1). ];   on: { $( } do: [ self insert: $); bumpCursor: (-1@0). ];   on: { $[ } do: [ self insert: $]; bumpCursor: (-1@0). ];   on: { quote.  } do: [ self insert: quote; bumpCursor: (-1@0). ];   on: { doubleQuote.  } do: [ self insert: doubleQuote; bumpCursor: (-1@0). ];   onOtherValuesDo: [ self insert: keyCharacter ].""===Context: Edit-Frame Active.U: space.U: period.U: return.. Edit-Frame: Parse current line.. Edit-Frame: Analyze current line.. Edit-Frame: Highlight current line.U: up.. Edit-Frame: Highlight current line.. Cursor: Move up one line.U: down.. Edit-Frame: Highlight current line.. Cursor: Move down one line.U: subtext-start.. Edit-Frame: Insert subtext-end. (Start key is passed how?). Cursor: Move back one column.==="</pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; testU200NewRelationEvents</h3><pre>testU200NewRelationEvents"NewRelationEvents:- In addition to updating the ontology, update theses diagrams ==&gt; (triggering view updates where view is active).calc switch: ontologyEvent;   on: { #newEntityType. #newEntityAttributeSet. #newCategorySet }                                 do: [ self updateNounGraph. ];   on: { #newPrecondition }   do: [ self updatePlanGraph ];   on: { #newDelegation }      do: [ self updateRoleDependencyGraph ];   on: { #newPushContext }   do: [ self updateContextFlowGraph ];   "</pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; testU300RenameEvents</h3><pre>testU300RenameEvents"RenameEvents:When an ontology noun or statement definition is replaced in editor, we need to ask: Should it be replaced everywhere?- Entity replaced in dictionary statement. (entity renamed)- Attribute replaced in dictionary statement. (attribute renamed)- Category replaced in dictionary statement. (category renamed)- Statement replaced in 'Action: . . .' (action renamed)- Statement replaced in 'Goal: . . .' (goal renamed)- View-frame renamed. (view renamed)- Context-frame renamed. (context renamed)"</pre><h3>Hum-Tests -- HumProgrammersAssistantTests &gt;&gt; text930expected</h3><pre>text930expected   ^'&lt;html&gt;   &lt;head&gt;      &lt;title&gt;         (untitled) -- No title yet.      &lt;/title&gt;      &lt;style&gt;                body {font-family: MONOSPACE;}            heading {font-size: X-LARGE; }                     title1, title2, title3, title4, title5 {font-weight: BOLD;}            title1 {font-size: 200%;}            title2 {font-size: 150%;}            title3 {font-size: 125%;}            title4 {font-size: 100%;}            frameTitle {color: BLUE; font-size: LARGER; font-weight: BOLD;}                        n, noun {color: PURPLE;}            k, keyword {font-weight: BOLD;}            r, role {font-style: ITALIC;font-weight: BOLD;}                        statement {color: BLUE;}            c, comment {color: GREEN;}            annotation {}                        pattern {}            markup {font-family: MONOSPACE;}            widget {color: RED;}                                    HumFrame {}            frameLine, CommentLine, DictionaryLine, PreconditionLine  {margin-left: 1em;}            InstructionLine {margin-left: 1em; color: BLUE;}               InstructionLine.indent1 {margin-left: 1em;}                  InstructionLine.indent2 {margin-left: 2em;}                  InstructionLine.indent3 {margin-left: 3em;}                  InstructionLine.indent4 {margin-left: 4em;}                                 textarea {vertical-align: top;}               form {border-style: outset; padding: 1em;}            table {}            th {background: CYAN;}            td {background: LIGHTGREY;}            errorNote { color: DARKRED; }            critiqueLine { color: DARKRED; margin-left: 1em; }            commentLine { color: DARKGREEN; margin-left: 1em; }      &lt;/style&gt;   &lt;/head&gt;   &lt;body&gt;      &lt;heading&gt;         Ontology: (untitled) -- No title yet.      &lt;/heading&gt;      &lt;hr/&gt;      &lt;HumFrame&gt;         &lt;ActionFrame&gt;         &lt;frameTitle&gt;            Role: Order-Checker -- Give carriers to the customer.         &lt;/frameTitle&gt;         &lt;br/&gt;&lt;b&gt;Role: &lt;/b&gt;         &lt;role&gt;            Order-Checker.         &lt;/role&gt;         &lt;br/&gt;&lt;b&gt;Action: &lt;/b&gt;         &lt;action&gt;            Give carriers to the customer.         &lt;/action&gt;         &lt;br/&gt;         &lt;InstructionLine class="indent1" &gt;            &lt;statement&gt;               Match carrier to order.            &lt;/statement&gt;         &lt;/InstructionLine&gt;         &lt;br/&gt;         &lt;InstructionLine class="indent1" &gt;            &lt;statement&gt;               Move matched carrier to scale.            &lt;/statement&gt;         &lt;/InstructionLine&gt;         &lt;br/&gt;         &lt;InstructionLine class="indent1" &gt;            &lt;comment&gt;               (This catches most errors with carrier sequencing.)            &lt;/comment&gt;         &lt;/InstructionLine&gt;         &lt;br/&gt;         &lt;InstructionLine class="indent1" &gt;            &lt;statement&gt;               &lt;k&gt;If&lt;/k&gt; scale weight               matches order` s expected weight:            &lt;/statement&gt;         &lt;/InstructionLine&gt;         &lt;br/&gt;         &lt;InstructionLine class="indent2" &gt;            &lt;statement&gt;               Release carriers to customer.[ native]            &lt;/statement&gt;         &lt;/InstructionLine&gt;         &lt;br/&gt;         &lt;InstructionLine class="indent1" &gt;            &lt;statement&gt;               &lt;k&gt;Else&lt;/k&gt;:            &lt;/statement&gt;         &lt;/InstructionLine&gt;         &lt;br/&gt;         &lt;InstructionLine class="indent2" &gt;            &lt;comment&gt;               (Most likely error is that carrier is out of sequence.)            &lt;/comment&gt;         &lt;/InstructionLine&gt;         &lt;br/&gt;         &lt;InstructionLine class="indent2" &gt;            &lt;statement&gt;               Check for carrier-sequence-error.            &lt;/statement&gt;         &lt;/InstructionLine&gt;         &lt;br/&gt;         &lt;InstructionLine class="indent2" &gt;            &lt;comment&gt;               (Now what?)            &lt;/comment&gt;         &lt;/InstructionLine&gt;         &lt;/ActionFrame&gt;      &lt;/HumFrame&gt;      &lt;hr/&gt;   &lt;/body&gt;&lt;/html&gt;'.</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; aReadMe</h3><pre>aReadMe   "See the class description for the intended (future) tests."   ^'See the class description for the intended (future) tests.'   </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; expect:is:</h3><pre>expect: actualValue is: expectedValue    ""   ^ self      assert: (expectedValue = actualValue)      description: ( self comparingStringBetween: expectedValue and: actualValue ).</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; expected:actual:</h3><pre>expected:  expectedValue actual: actualValue    ""   ^ self      assert: (expectedValue = actualValue)      description: ( self comparingStringBetween: expectedValue and: actualValue ).</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; setUp</h3><pre>setUp   "This setup is used by many run-time tests.    It initializes: setupConfiguration setupMessenger setupDispatcher setupBookkeeper setupWorker "   | |   "Set the ID"   "Define a Hum configuration."   setupConfiguration := HumConfiguration messengerID: 'mock messenger ID'                                             dispatcherID: 'mock Dispatcher ID'                                          bookkeeperID: 'mock bookkeeper ID'                                         worldbaseID: 'mock worldbase ID'. "Mentioned but not instantiated?"   "Attach local messenger (Mock)".   setupMessenger := HumMessenger new.   setupMessenger id: 'mock messenger ID';                        uri: 'mock messenger URI'.      setupConfiguration messenger: setupMessenger.   "Create worldbase instance and check-in."   setupConfiguration openWorldBase.   "A resource Dispatcher must know a messenger and a bookkeeper."   setupDispatcher := HumActor dispatcherID: 'mock Dispatcher ID'                                          uri: 'mock Dispatcher URI'                                configuration: setupConfiguration.                     "A bookkeeper must know a messenger and a world base."                  setupBookkeeper := HumActor bookkeeperID: 'mock bookkeeper ID'                                       uri: 'mock bookkeeper URI'                              configuration: setupConfiguration.      "A worker must know a messenger and a Dispatcher and some roles"   setupWorker := HumActor workerID: 'test workerID'                                uri: 'mock worker URI'                             roles: #( 'serf' 'cook' 'singer' 'composer')                       configuration: setupConfiguration.      "Messenger needs to know bookkeeper and Dispatcher"   setupMessenger registerActor: setupBookkeeper atURI: setupBookkeeper uri.    setupMessenger registerActor: setupDispatcher atURI: setupDispatcher uri.   "Check in."   setupWorker checkIn.</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; setUpKnockKnockOnOntology:</h3><pre>setUpKnockKnockOnOntology: anOntology   | viewFrame dictionaryFrame |   self assert: (anOntology isKindOf: HumOntology ).   "Provide a view frame."   viewFrame := HumFrame4View ontology: anOntology viewEntity: 'Knock'.   viewFrame addMarkUp: '!!Knock, knock, who`s there?'.   viewFrame addMarkUp: '  Please enter first name: [first-name]'.   "Provide a dictionary frame."   dictionaryFrame := HumFrame4Dictionary ontology: anOntology title: 'Knock attributes'.   dictionaryFrame addDictionaryLine: 'Knock attributes include first-name.'.      dictionaryFrame compileToOntology: anOntology .   viewFrame       compileToOntology: anOntology.</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; tearDown</h3><pre>tearDown   "Transcript cr; show: 'completed: ', (testSelector asString)."</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test000ApplicationConfigurationReadMe</h3><pre>test000ApplicationConfigurationReadMe   "An application has a run-time configuration."   | |   "System   /Application Configuration:   A typical system will include these 'singleton' components:    . Messenger: Assure messages are received and logged.   . Dispatcher: Assign actions to actors. (Tracks current system work-in-progress at actor level. )   . Bookkeeper: Record resource utilization as tasks complete.   . WorldBase: Record events, maintain entity state data.    An active user / client session will also include session-bound instances of a:   . Dialog Agent: Conduct dialog with user / client actor.    . Scribe: Mediate between Dialog and User Interface technology.    . Ontology: A Dialog Agent interprets dialog vignettes found in a specific ontology.   Each running plan will also include an instance of a:   . Coordinator: Coordinate plan execution. (Tracks work-in-progress at plan level.)   . Ontology: An ontology must be present at the time the plan is built.Actor Configuration:   An Actor`s (minimal) configuration includes a Messenger and a Dispatcher.      During execution, most Actors have a BlackBoard where run-time data is persisted.   The BlackBoard may require the services of a WorldBase when the Actor`s actions affect the World. (typical)   "</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test005ApplicationConfigurationSetup</h3><pre>test005ApplicationConfigurationSetup   "This setup is used by several tests. "   "Define a Hum configuration."   | |   "#setUp creates a shared configuration."   self assert: ( setupMessenger uri  sameAs: 'mock messenger URI' ).   self assert: ( setupConfiguration messenger == setupMessenger ).   self assert: ( setupDispatcher isKindOf: HumDispatcher ).   self assert: ( setupDispatcher id sameAs: 'mock Dispatcher ID' ).   self assert: ( setupDispatcher uri sameAs: 'mock Dispatcher URI'  ).   self assert: ( setupBookkeeper isKindOf: HumBookkeeper ).   self assert: ( setupBookkeeper id sameAs: 'mock bookkeeper ID' ).   self assert: ( setupBookkeeper uri sameAs: 'mock bookkeeper URI'  ).    self assert: ( setupWorker isKindOf: HumActor ).   self assert: ( setupWorker uri sameAs:  'mock worker URI'  ).   self assert: ( setupWorker id  sameAs: 'test workerID').   self assert: ( setupWorker roles = ( #('serf' 'cook' 'singer' 'composer')  )   ).   self assert: ( setupMessenger isKindOf: HumMessenger ).   self assert: ( setupMessenger ping: 'mock Dispatcher URI' ) == setupDispatcher id.   self assert: ( setupMessenger ping: 'mock bookkeeper URI' ) == setupBookkeeper id.   self assert: ( setupMessenger ping: 'mock worker URI' ) == setupWorker id.</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test100ActorReadMe</h3><pre>test100ActorReadMe   "Jobs and Tasks:      An Hum Actor executes action statements assigned by the Resource Dispatcher.   Action assignments include a JobTicket to which resources are added as used, including the actor`s time.   A JobTicket is started when a Plan is started. It is associated with the plan goal (instance).Messenger:   Actors communicate via the Messenger which provides a wrapper around some communication technology.   The Messenger also logs messages for diagnosis and replay purposes. 
  (The actor need not bother with that level of logging.)Roles:      Action Statements procedures are defined in Ontology Action Frames that are collected under a Role.   When an Actor 'checks-in' with its Resource Dispatcher, it claims to 'know' one or more Roles.   The Resource Dispatcher may then assign an Action to an Actor that knows the associated Role.   Delegation:   An Actor may delegate an instruction`s action to another Role.   While the other role is executing, the current execution is suspended.    When the other role 'returns',    . the message-receiver interface restores state (via BlackBoard)    . and resumes execution.   Actor Configuration:   The Actor`s (minimal) configuration includes a Messenger and a Resource Dispatcher.      During execution, most Actors have a BlackBoard where run-time data is persisted.   The BlackBoard typically requires the services of a WorldBase:   . when Actor delegates an instruction (action) to another role (because current state must be peristed)   . when the Actor`s actions affect the World.    . . (WorldBase retention rules define what is remembered, what is forgotten.)   System   /Application Configuration:   A typical system will include these 'singleton' components:    . Messenger: Assure messages are received and logged.   . Resource Dispatcher: Assign actions to actors. (Tracks current system work-in-progress at actor level. )   . Bookkeeper: Record resource utilization as tasks complete.   . WorldBase: Record events, maintain entity state data.    An active user / client session will also include session-bound instances of a:   . Dialog Agent: Conduct dialog with user / client actor.    . Scribe: Mediate between Dialog and User Interface technology.    . Ontology: A Dialog Agent interprets dialog vignettes found in a specific ontology.   Each running plan will also include an instance of a:   . Coordinator: Coordinate plan execution. (Tracks work-in-progress at plan level.)   . Ontolog: An ontology must be present at the time the plan is built.   "</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test100ReadMe</h3><pre>test100ReadMe   "Network is a wrapper on whatever technology is used to communicate between Actors."   |    |   self skip."Features:"   "The Network sends/receives messages (wrapping the communication technology)."      "The Network component provides serialization and de-serialization of Message instances (see HumMessage)."   "Design Note: The serialization strategy assumes 'payload' is not sensitive to communication stack."      "TBD: Consider Erlang strategy and interface. Assume most tests will be on the Erlang side."</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test105actorConfiguration</h3><pre>test105actorConfiguration   "A Hum Actor is configured with the address of a messenger node.   Actors communicate by sending predefined message types via the messenger.   "   |   messenger worker dispatcher   bookkeeper |   true ifFalse: [ Transcript cr; show: 'test105actorConfiguration is TURNED OFF'; cr. ^self].   "Create the (mock) messenger service"   messenger := HumMessenger uri: 'mock messenger URI'.   self assert: ( messenger uri  sameAs: 'mock messenger URI' ).      "A resource dispatcher must know a messenger and a bookkeeper."   dispatcher := HumActor dispatcherID: 'test dispatcher'                             uri: 'mock dispatcher URI'                  configuration: setupConfiguration.   self assert: ( dispatcher isKindOf: HumDispatcher ).   self assert:  dispatcher uri sameAs: 'mock dispatcher URI'.      "A bookkeeper must know a messenger and a world base."                  bookkeeper := HumActor bookkeeperID: 'test bookkeeper'                                   uri: 'mock bookkeeper URI'                        configuration: setupConfiguration.   self assert: bookkeeper uri sameAs: 'mock bookkeeper URI'.                           "A worker must know a messenger and a dispatcher and some roles"   worker := HumActor workerID: 'test cook ID' uri: 'test cook URI' roles: #( 'cook' 'bottle-washer' 'bar-tender' 'psych' ) configuration: setupConfiguration.    self assert: worker uri sameAs:  'test cook URI'.            </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test110workerChecksIn</h3><pre>test110workerChecksIn   "Worker checks-in, announcing roles."   "The check-in protocol has the worker-side and the resource dispatcher side."   "Worker says:   . dispatcher: Check-in worker W with roles R.   The dispatcher adds the worker to its (role -&gt; worker) knowledge."   |  worker dispatcher |      "Get the worker from the setup."   worker := setupWorker.   self assert: ( worker isKindOf: HumActor ).   self assert: ( worker roles include: 'serf' ).      "Get the resource dispatcher from the setup."   dispatcher := setupDispatcher.   self assert: ( dispatcher isKindOf: HumDispatcher ).      "Execute the check-in directly."   dispatcher checkInActor: 'worker id' at: 'worker uri' withRoles: worker roles.      "dispatcher now includes worker in set of those who know that role."   self assert: ( dispatcher roleActor includes: ( 'serf' -&gt; 'worker id' ) ).         </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test120workerCheckInMessage</h3><pre>test120workerCheckInMessage   "Worker checks-in, announcing roles."   "The check-in protocol has the worker-side and the resource dispatcher side."   "Worker says:   . dispatcher: Check-in worker W with roles R.   The dispatcher adds the worker to its (role -&gt; worker) knowledge."   |  worker dispatcher message |      "Get the worker from the setup."   worker := setupWorker.   self assert: ( worker isKindOf: HumActor ).   self assert: ( worker roles include: 'serf' ).      "Get the resource dispatcher from the setup."   dispatcher := setupDispatcher.   self assert: ( dispatcher isKindOf: HumDispatcher ).   "Use a Smalltalk coded message to tell dispatcher."   "To: Execute the check-in directly, we would say:"   "dispatcher checkInActor: worker name at: 'worker uri' withRoles: worker roles."      message := 'self checkInActor: ', ('worker id') quoted, ' at: ', ('worker uri') quoted, ' withRoles: #(', ('cook') quoted, ').'.   Compiler evaluate: message for: dispatcher logged: false.      "dispatcher now includes worker in set of those who know that role."   self assert: ( dispatcher roleActor includes: ( 'cook' -&gt; 'worker id' ) ).   </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test130workerChecksInViaMessenger</h3><pre>test130workerChecksInViaMessenger   "Worker checks-in, announcing roles."   "The check-in protocol has the worker-side and the resource dispatcher side."   "Worker says:   . dispatcher: Check-in worker W with roles R.   The dispatcher adds the worker to its (role -&gt; worker) knowledge."   |  worker dispatcher |      "Get the worker from the setup."   worker := setupWorker.      "Get the resource dispatcher from the setup."   dispatcher := setupDispatcher.   self assert: ( dispatcher isKindOf: HumDispatcher ).   "Tell the worker to check-in."   worker checkIn.      "dispatcher now includes worker in set of those who know that role."   self assert: ( dispatcher roleActor includes: ( 'serf' -&gt; worker id ) ).   </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test135workerChecksOutViaMessenger</h3><pre>test135workerChecksOutViaMessenger   "Worker checks-in, announcing roles."   "The check-in protocol has the worker-side and the resource dispatcher side."   "Worker says:   . dispatcher: Check-in worker W with roles R.   The dispatcher adds the worker to its (role -&gt; worker) knowledge."   |  worker dispatcher |      "Get the worker from the setup."   worker := setupWorker.      "Get the resource dispatcher from the setup."   dispatcher := setupDispatcher.   self assert: ( dispatcher isKindOf: HumDispatcher ).   "Tell the worker to check-in."   worker checkIn.      "dispatcher now includes worker in set of those who know that role."   self assert: ( dispatcher roleActor includes: ( 'serf' -&gt; worker id ) ).      "Tell the worker to check-out."   worker checkOut.   self assert: ( dispatcher roleActor includes: ( 'serf' -&gt; worker id ) ) not.   </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test200DispatcherReadMe</h3><pre>test200DispatcherReadMe"The Dispatcher (RM) - assigns tasks to actors.   1. Actor checks-in (announces availability to perform specific roles).   2. Assign task (action-statement) to actor.      a) Job-ticket contains action-statement, noun-values,             request context (requesting actor, and instruction-pointer).      b) The RM assigns an available actor.      c) The RM sends the job-ticket to the assigned actor.             (via Messenger)   3. Actor has completed task.      a) The resources consumed (actors time, etc) are recorded on the job ticket.      b) Any computed results are added to the job-ticket.            (Convention: Actions with results have a 'giving' clause.)      c) RM sends resource consumption data to Bookkeeper.      d) Task complete notice (with job-ticket) is sent to requester.            (The requester resumes execution of the plan.)   4. Delegate task.         (The current actor has delegated a task to another role.)      a) Send delegated task to Dispatcher. (RM)         (The RM will assign the task to an available actor.)       b) If an actor delegates to a role which it also knows,            the delegated action is assigned to the same actor.      c) Persist actor state during a delegation         (Since delegations may be long-running,           we need a way to persist actor state during a delegation.)               Q: Where is the push-down stack in this context? Does the RM maintain it? (A: Basically, yes.)               Q: Does the actor persist its own state while suspended or does the RM maintain it? (A: Actor via BB)               Solution-1: If the target framework (e.g. Erlang OTP) maintains state, we do not need to.               Solution-2: Perhaps, the RM should maintain caller`s state during a delegation.                Solution-2.1: This has the advantage of being able to survey the complete application state in one place.               Solution-2.2: But we could also do that by querying the WorldBase or active actors. (See solution-3 next.)               Solution-3: The Hum persistence framework (BlackBoard plus WorldBase) persists the actor`s state.    &lt;&lt;&lt;               Solution-3.1: State is in the actor`s BlackBoard (BB), and the BB implements a 'resume' capability.  &lt;&lt;&lt;               Solution-3.2: This implies: RM sees delegate return ==&gt; sends resume to actor ==&gt; BB is persistent.  &lt;&lt;&lt;               Solution-3.3: BB saves/fetches (snapshots) to/from WorldBase (WB). ==&gt; Lots of eggs in WB !!!!               solution-3.4: The actor supertype message-receive interface will activate the BB, et cetera.   5. Resume suspended action.         When a instruction is delegated to another role, the current task execution is suspended.         When the delegation (call) completes, the requestor resumes execution.   6. Maintain model of all the known actors` assignment-state.          Actors may be idle, engaged, suspended.          (Note: Actor instances are 'single-threaded' but may delegate instructions to self.)         . Idle: No action assigned. (Actor is available for suitable assignments.)         . Engaged: An action is assigned but not yet completed. (Action is in-progress)         . Suspended: An action instruction has been delegated to another actor. (This actor is waiting for other actor.)         "</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test210DispatcherAssignsAction</h3><pre>test210DispatcherAssignsAction   "Some actor delegates a task to a role.   The Dispatcher assigns the task to an actor that advertises that role   and sends the task (work order) to the assigned actor.   "   | baker  bookkeeper oven ontology frameEditor jobTicket actionInstruction dispatcher frameEditor2 |   true ifFalse: [ Transcript cr; show: 'test210DispatcherAssignsAction turned off'; cr. ^self].      "Get the Dispatcher from the setup."   dispatcher := setupDispatcher.   self assert: ( dispatcher isKindOf: HumDispatcher ).   "Create a baker worker"   baker := HumActor workerID: 'bakerId' uri: 'bakerURI' roles: #('baker') configuration: setupConfiguration.   self assert: (baker uri sameAs: 'bakerURI').   "Create another actor to be oven. "    oven := HumActor workerID: 'ovenID' uri: 'ovenURI' roles: #( 'oven' ) configuration: setupConfiguration.   self assert: (oven uri sameAs:  'ovenURI' ).   "Tell the actors to check-in."   baker checkIn.   oven checkIn.      "======= Set up the action frame  =========="   ontology := setupConfiguration ontology.      "Initialize for an Action Frame."   frameEditor := HumFrameUpdater ontology: ontology                                        role: 'Baker'                                     action: 'Bake the pan in the oven for the time given in the recipe.'.   "Append an instruction that is delegated"   frameEditor          appendInstructionRole: 'Oven' statement: 'Bake for the time given in recipe.';          storeFrameInOntology .   "We need at least one noun."   ontology addNoun: 'recipe'.      frameEditor2 := HumFrameUpdater ontology: ontology                                                       role: 'Oven'                                                      action: 'Bake for the time given in recipe.'.   frameEditor2         appendInstructionStatement: ' Set oven timer to the time given in recipe.';         appendInstructionStatement: ' Set oven temperature to the temperature given in recipe.';         appendInstructionStatement: ' Start.';         storeFrameInOntology.            "============== ================="   "We will pretend to be Coordinator running a plan.   There will be a Job Ticket for the plan.   The Coordinator will ask the Dispatcher to assign an actor to run the action.   "   jobTicket := HumJobTicket title: 'test210DispatcherAssignsAction'.   self assert: ( jobTicket isKindOf: HumEntity ).   actionInstruction := HumInstructionLine role: 'Baker' statement: 'Bake the pan in the oven for the time given in the recipe.'.     actionInstruction statement noun: 'recipe' value: 'white cake'.   actionInstruction jobTicket: jobTicket.   dispatcher assignRole: 'Baker' action: actionInstruction.   "After the task is done, a resource usage entry will be sent to the bookkeeper."   bookkeeper := setupBookkeeper.   self assert: ( bookkeeper isKindOf: HumBookkeeper ).   self assert: ( bookkeeper jobTickets size &gt; 0 ).   "See also: Bookkeeper tests."   </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test300CoordinatorReadMe</h3><pre>test300CoordinatorReadMe"Coordinator - controls execution of plans and dialogs.   1. Execute Plans.         a) When a plan is evaluated,             the coordinator scans plan frames to find those whose actions are executable.         b) When a plan frame is executable, its action instructions are executed. (Sent to Dispatcher)         c) After the last plan action is executed, the plan frame`s post condition is asserted.         d) If an post-condition is the plan`s goal, we are done.         e) Iterate.            2. Provide a viewable model showing the execution state of each (every) plan frame in a running plan.         The State of plan frame may be pending / executing / suspended / fulfilled.         . Pending: The pre-conditions have not been satisfied.         . Executing: The plan actions statement/s are executing.         . Suspended: The execution of the action statements has been extended (Some business exception occurred.).         . Fulfilled: The post-condition has been asserted.                        "</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test310coordinatorRunsPlan</h3><pre>test310coordinatorRunsPlan   "Dialog:    . Coordinator to Dispatcher: Run action A for job J.    . Dispatcher to Coordinator: Action A completed on job J.   "   | ontology planFrame dictionaryFrame  actionFrame coordinator dialogAgent |         true ifFalse: [ Transcript cr; show: 'test310coordinatorRunsPlan turned off'; cr. ^self].   "Create an ontology."   ontology := setupConfiguration ontology.   "Define a few nouns."   dictionaryFrame := HumFrame4Dictionary ontology: ontology title: 'Song vocabulary'.   dictionaryFrame addDictionaryLine: 'Song attributes include title, lyrics, melody-notes.'.   "Compile it"   dictionaryFrame compileToOntology: ontology.   "Define a simple plan."   setupConfiguration ontology: ontology.   planFrame := HumFrame4Plan ontology: ontology goal: 'Plan has one frame with no preconditions.'.   planFrame appendRole: 'cook' action: 'Sing song called title.'.      "Create the corresponding action frame."   actionFrame := HumFrame4Action ontology: ontology role: 'cook' action: 'Sing song called title.'.   actionFrame          appendInstructionStatement: ' Open music book to given song title.';         appendInstructionStatement: ' Read song melody-notes and lyrics.';         appendInstructionStatement: ' Sing song melody-notes and lyrics.'.            "Store it in the ontology."   ontology storeFrame: planFrame.   ontology storeFrame: actionFrame.      "Compile it."   planFrame compileToOntology: ontology.   actionFrame compileToOntology: ontology.   ""   dialogAgent := HumActor dialogID: 'test dialog ID'                               uri: 'test dialog URL'                            client: 'client ID'                     configuration: setupConfiguration.   dialogAgent checkIn.      "Create a running instance of the plan and a coordinator to run it."   coordinator := HumActor coordinatorID: 'test coordinator ID'                                  uri: 'test coordinator URL'                                 goal: 'Plan has one frame with no preconditions.'                                    dialog: dialogAgent                       configuration: setupConfiguration.   self assert: (coordinator isKindOf: HumCoordinator ).            coordinator checkIn.         "Run the plan."   coordinator runPlan.         "After that plan has run. The goal will be fulfilled."    self assert: ( coordinator remainingConditions isEmpty ).   "Now there should be at least one change on the job ticket."   self assert: ( coordinator jobTicket charges notEmpty ) description: 'Job Ticket should not be empty'.    </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test320coordinatorInvokesAction</h3><pre>test320coordinatorInvokesAction   "Goal: Plan has one frame with no preconditions.    Action:    . Cook: Sing song called title.   "   | ontology planFrame dictionaryFrame  actionFrame coordinator dialogAgent charges |   true ifFalse: [ Transcript cr; show: 'test320coordinatorInvokesAction turned off'; cr. ^self].   ontology := HumOntology new.      "Define a few nouns."   dictionaryFrame := HumFrame4Dictionary ontology: ontology title: 'Song vocabulary'.   dictionaryFrame addDictionaryLine: 'Song attributes include title, lyrics, melody-notes.'.   "Compile it"   dictionaryFrame compileToOntology: ontology.   "Define a simple plan."   setupConfiguration ontology: ontology.   planFrame := HumFrame4Plan ontology: ontology goal: 'Plan has one frame with no preconditions.'.   planFrame appendRole: 'cook' action: 'Sing song called title.'.      "Create the corresponding action frame."   actionFrame := HumFrame4Action ontology: ontology role: 'cook' action: 'Sing song called title.'.   actionFrame          appendInstructionStatement: ' Open music book to given song title.';         appendInstructionStatement: ' Read song melody-notes and lyrics.';         appendInstructionStatement: ' Sing song melody-notes and lyrics.'.   "Store it in the ontology."   ontology storeFrame: planFrame.   ontology storeFrame: actionFrame.      "Compile it."   planFrame compileToOntology: ontology.   actionFrame compileToOntology: ontology.   ""   dialogAgent := HumActor dialogID: 'test dialog ID'                               uri: 'test dialog URL'                            client: 'client ID'                     configuration: setupConfiguration.   "Create a running instance of the plan and a coordinator to run it."   setupConfiguration ontology: ontology.   coordinator := HumActor coordinatorID: 'test coordinator ID'                                  uri: 'test coordinator URL'                                 goal: 'Plan has one frame with no preconditions.'                                    dialog: dialogAgent                       configuration: setupConfiguration.   self assert: (coordinator isKindOf: HumCoordinator ).            coordinator checkIn.         "Run the plan."   coordinator runPlan.         "After that plan has run. The goal will be fulfilled."    self assert: ( coordinator remainingConditions isEmpty ).   "Now there should be at least one change on the job ticket."   charges := coordinator jobTicket charges.   self expect: 3 actual: ( charges size ) description: 'Expecting 3 charges.'          </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test330twoPlanFrames</h3><pre>test330twoPlanFrames   "Test with two plan frames.   "   | coordinator ontology  planFrameA planFrameB dictionaryFrame actionFrameA actionFrameB charges |   ontology := HumOntology new.   "Root frame has one prereq and one action"   planFrameA := HumFrame4Plan ontology: ontology goal: 'Complete the whole plan.'.   planFrameA          appendPrecondition: 'Have song with title.';          appendRole: 'Singer' action: 'Sing song with title.';                 compileToOntology: ontology.   "Create the corresponding action frame."   actionFrameA := HumFrame4Action ontology: ontology role: 'Singer' action: 'Sing song with title.'.   actionFrameA          appendInstructionStatement: ' Open music book to given song title.';         appendInstructionStatement: ' Read song melody-notes and lyrics.';         appendInstructionStatement: ' Sing song melody-notes and lyrics.';         compileToOntology: ontology.      "Second level frame with no prereq and one action"      planFrameB := HumFrame4Plan ontology: ontology goal: 'Have song with title.'.   planFrameB          appendRole: 'Composer' action: 'Compose song with title.';          compileToOntology: ontology.      "Create the corresponding action frame."   actionFrameB := HumFrame4Action ontology: ontology role: 'Composer' action: 'Compose song with title.'.   actionFrameB          appendInstructionStatement: ' Publish music book with given song title.';         compileToOntology: ontology.      "We need at least one noun."   dictionaryFrame := HumFrame4Dictionary ontology: ontology title: 'Song has title, composer, et cetera'.   dictionaryFrame          addDictionaryLine: 'Song attributes include title, composer, melody.';          compileToOntology: ontology.         setupConfiguration ontology: ontology.   coordinator := HumCoordinator coordinatorID: 'coordinator ID'                                                       uri: 'myURI'                                                       goal: 'Complete the whole plan.'                                                       dialog: (HumDialogAgent new)                                                       configuration: setupConfiguration.                                                       coordinator checkIn.   coordinator runPlan.      self assert: (coordinator jobTicket notNil ).   charges := coordinator jobTicket charges.   self expect: 4 actual: ( charges size )description: 'Expecting N charges.'.</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test340planTreeBranches</h3><pre>test340planTreeBranches   "Test a plan tree with several levels and significant branching.   "   | coordinator ontology  planFrameA planFrameB1 planFrameB2 planFrameB3 planFrameC dictionaryFrame baker mixer oven actionFrameA actionFrameB1 actionFrameB2 actionFrameB3 actionFrameC |   ontology := HumOntology new.   "The root frame of this plan tree has several preconditions."   planFrameA := HumFrame4Plan ontology: ontology goal: 'Cake is baked per recipe.'.   planFrameA       appendPrecondition: 'Oven is preheated per recipe.';       appendPrecondition: 'Cake batter is mixed per recipe.';       appendPrecondition: 'Cake-pan is greased.';       appendRole: 'baker' action: 'Bake cake batter in cake pan for recipe time.';       compileToOntology: ontology.   "Corresponding action frame:"   actionFrameA := HumFrame4Action ontology: ontology role: 'baker' action: 'Bake cake batter in cake pan for recipe time.'.   actionFrameA       appendInstructionStatement: 'Dummy statement.';       compileToOntology: ontology.   "Second level frame -- This frame has a precondition, therefore a third level will be needed."   planFrameB1 := HumFrame4Plan ontology: ontology goal: 'Cake batter is mixed per recipe.'.   planFrameB1 appendPrecondition: 'Cake ingredients, per recipe, are assembled on mixing counter.'.   planFrameB1 appendRole: 'mixer' action: 'Mix ingredients per recipe.'.      planFrameB1 compileToOntology: ontology.   "Corresponding action frame:"   actionFrameB1 := HumFrame4Action ontology: ontology role: 'mixer' action: 'Mix ingredients per recipe.'.   actionFrameB1       appendInstructionStatement: 'Dummy statement.';       compileToOntology: ontology.      "Another second level frame - has no precondtions at this time."   planFrameB2 := HumFrame4Plan ontology: ontology goal: 'Oven is preheated per recipe.'.   planFrameB2 appendRole: 'oven' action: 'Preheat to temperature given by recipe.'.   planFrameB2 compileToOntology: ontology.   "Corresponding action frame:"   actionFrameB2 := HumFrame4Action ontology: ontology role: 'oven' action: 'Preheat to temperature given by recipe.'.   actionFrameB2       appendInstructionStatement: 'Dummy statement.';       compileToOntology: ontology.      "Still another second level frame - has no preconditions at this time."   planFrameB3 := HumFrame4Plan ontology: ontology goal: 'Cake-pan is greased.'.   planFrameB3 appendRole: 'mixer' action: 'Grease a cake-pan.'.   planFrameB3 compileToOntology: ontology.   "Corresponding action frame:"   actionFrameB3 := HumFrame4Action ontology: ontology role: 'mixer' action: 'Grease a cake-pan.'.   actionFrameB3       appendInstructionStatement: 'Dummy statement.';       compileToOntology: ontology.      "Third level frame - has no preconditions at this time."   planFrameC := HumFrame4Plan ontology: ontology                                    goal: 'Cake ingredients, per recipe, are assembled on mixing counter.'.   planFrameC appendRole: 'mixer' action: 'Assemble cake ingredients per recipe on mixing counter.'.   planFrameC compileToOntology: ontology.   "Corresponding action frame:"   actionFrameC := HumFrame4Action ontology: ontology role: 'mixer' action: 'Assemble cake ingredients per recipe on mixing counter.'.   actionFrameC       appendInstructionStatement: 'Dummy statement.';       compileToOntology: ontology.      "We need at least one noun."   dictionaryFrame := HumFrame4Dictionary ontology: ontology title: 'Cake recipe vocabulary'.   dictionaryFrame addDictionaryLine: 'Recipe attributes include title, ingredients, steps.'.   dictionaryFrame addDictionaryLine: 'Cake-Recipe attributes include oven-temperature, oven-time.'.   dictionaryFrame addDictionaryLine: 'A pan is a container.'.   dictionaryFrame addDictionaryLine: 'A bowl is a container.'.   dictionaryFrame addDictionaryLine: 'A cake-pan is a baking-pan.'.   dictionaryFrame compileToOntology: ontology.         setupConfiguration ontology: ontology.   coordinator := HumCoordinator coordinatorID: 'coordinator ID'                                                       uri: 'myURI'                                                       goal: 'Cake is baked per recipe.'                                                       dialog: (HumDialogAgent new)                                                       configuration: setupConfiguration.   coordinator checkIn.      baker := HumActor workerID: 'bakerID' uri: 'bakerURI' roles: #('baker') configuration: setupConfiguration.   baker checkIn.   mixer := HumActor workerID: 'mixerID' uri: 'mixerURI' roles: #('mixer') configuration: setupConfiguration.   mixer checkIn.   oven := HumActor workerID: 'ovenID' uri: 'ovenURI' roles: #('oven') configuration: setupConfiguration.   oven checkIn.      coordinator runPlan.      self assert: (coordinator jobTicket notNil ).   self assert: (coordinator jobTicket charges notEmpty ) description: 'Job ticket should show charges.'.   self assert: (coordinator jobTicket charges size = 5 ).   "   Transcript cr; show: 'test340planTreeBranches'.   coordinator getActionSequence do: [:action | Transcript cr; show: action ].   Transcript cr.   "</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test400BookkeeperReadMe</h3><pre>test400BookkeeperReadMe   "A Bookkeeper tracks resource utilization.   It maintains resource utilization accounts, but at a fundamental level,    those accounts are denominated in resource measures, not monetary measures.   This enables detailed cost accounting.    However, most industries and companies have their own unique monetization rules;   so, we do not attempt to build those into the Bookkeeper.   But the Bookkeeper can be extended to include monetization rules.    TODO: Experiment with a subtype that prices the resource utilization.   "</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test410BookkeeperRecordsJobTickets</h3><pre>test410BookkeeperRecordsJobTickets   "If we ask the bookkeeper to 'run' a jobTicket, it stores it in its jobTickets collection.'"   | ticket bookie |   ticket := HumJobTicket title: 'test410BookkeeperRecordsJobTickets'.   bookie := setupBookkeeper.   bookie recordJobTicket: ticket.   self assert: ( bookie jobTickets includes: ticket ) .</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test420BookkeeperSums</h3><pre>test420BookkeeperSums   "The bookkeeper tracks utilization of an actor by action, actor, role, job.   "   | ticket bookie action  aJobID |      ticket := HumJobTicket title: 'test420BookkeeperSums'.   action := 'This is only a test of the bookkeeper.'.   aJobID := UUID new.      "Measures are tracked by action, role, actor, and job."   #( 1 3 5 )       do: [ :q |          | m anID aRoleName |         m := HumMeasure quantity: q units: #step.         anID := 'test actor ID', q asString.         aRoleName := 'tester', q asString.         ticket appendCharge: m forAction: action byActor: anID inRole: aRoleName onJob: aJobID .          m := HumMeasure quantity: q*10 units: #kilometer.         ticket appendCharge: m forAction: action byActor: anID inRole: aRoleName onJob: aJobID .          ].    "Send to bookkeeper."   bookie := setupBookkeeper.   bookie recordJobTicket: ticket.   self assert: ( bookie jobTickets includes: ticket ) .      "Bookkeeper tracks utilization by Action."   self assert: ( bookie chargesByAction size = 2).   "Bookkeeper tracks utilization by Actor."   self assert: ( bookie chargesByActor size = 6).   "Bookkeeper tracks utilization by Role."   self assert: ( bookie chargesByRole size = 6).   "Bookkeeper tracks utilization by Job."   self assert: ( bookie chargesByJob size = 2).   "Sum by metric (calls, steps, gross counts)"   self assert: ( bookie chargesByMetric size = 2).   self assert: ( bookie chargesByMetric at: 'total:step') = (HumMeasure quantity: 9 units: #step).   self assert: ( bookie chargesByMetric at: 'total:kilometer') = (HumMeasure quantity: 90 units: #kilometer).      false ifTrue: [ "Inspect result"      | sums |      sums := bookie chargesByRole.      sums inspect.      ].   </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test600WorldBaseReadMe</h3><pre>test600WorldBaseReadMe   "   A WorldBase implements the 'corporate memory' of an enterprise.   It is a kind of temporal database     which means each record is related to a business (world) event.      BlackBoards provide fast-memory persistence for Actors.   The WorldBase provides fail-back memory for BlackBoards.   The WorldBase implements an Entity-Attribute model of the world.   Entities have Attributes. Attributes have values which are time-stamped.   The time-stamps are associated with world events. (as observed by Hum Actors)      The basic persistence strategy is 'Remember everything short-term, forget some things later.'   (Short-form: 'Persist now, purge later.')      Retention rules are defined in terms of how-long (minutes, days, years) old attribute values are retained.   Many corporate legal departments prefer that old data be 'purged' to reduce 'discovery' costs and risks.   To be 'purged' means the data is erased from main repositories and archives.   The implementation of retention rules is currently low-priority. (We have to remember before we can forget.)   "</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test610CreateWorldBaseInstance</h3><pre>test610CreateWorldBaseInstance   "Create an instance of a Hum World Base (a database to be shared by multiple actors)."   | worldBase |   worldBase := HumWorldBase openWorldBase: 'test610CreateWorldBaseInstance'.   self assert: worldBase notNil.   self assert: ( worldBase title = 'test610CreateWorldBaseInstance' ).</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test615CreateUniqueIdentifier</h3><pre>test615CreateUniqueIdentifier   "Create an instance of a Hum World Base (a database to be shared by multiple actors)."   |  id |   id := HumIdentifier createUniqueIdentifierForEntityName: 'test615' inContext: 'test615CreateUniqueIdentifier'.   self assert: (id isKindOf: HumIdentifier).      </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test616CreateUniqueIdentifierDoesNotBreak</h3><pre>test616CreateUniqueIdentifierDoesNotBreak   "Create an instance of a Hum World Base (a database to be shared by multiple actors)."   |  id newerID nTrial |   id := HumIdentifier createUniqueIdentifierForEntityName: 'test616CreateUniqueIdentifierDoesNotBreak' inContext: 'test616CreateUniqueIdentifierDoesNotBreak'.   self assert: (id isKindOf: HumIdentifier).      "Make sure it can handle high rate."   nTrial := 1000.   newerID := Array new: nTrial.   ( 1 to: nTrial )       do: [:i | newerID at: i put: ( HumIdentifier createUniqueIdentifierForEntityName: ('try:',(nTrial asString) ) inContext: ('try:',(nTrial asString) ) ).].      self assert: (( id = (newerID at: nTrial) ) not).</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test620setAndGet</h3><pre>test620setAndGet   "set entity-attribute value"   | worldBase entity value |   worldBase := HumWorldBase openWorldBase: 'WorldBase for test620setAndGet'.   self assert: worldBase notNil.   self assert: ( worldBase title = 'WorldBase for test620setAndGet' ).      entity := HumEntity title: 'Entity for test620setAndGet'.   worldBase setEntityID: (entity id) attribute: #description toValue: 'This is only a test.'.   value := worldBase getEntityID: (entity id) attribute: #description.   self assert: ( value == 'This is only a test.').</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test630setGetReplace</h3><pre>test630setGetReplace   "set entity-attribute value"   | worldBase entity value |   worldBase := HumWorldBase openWorldBase: 'test630setGetReplace'.   self assert: worldBase notNil.   self assert: ( worldBase title = 'test630setGetReplace' ).      entity := HumEntity title: 'Entity for test630setGetReplace'.   worldBase setEntityID: (entity id) attribute: #description toValue: 'This is only a test.'.   value := worldBase getEntityID: (entity id) attribute: #description.   self assert: ( value == 'This is only a test.').      worldBase setEntityID: (entity id) attribute: #description toValue: 'This WAS only a test.'.   value := worldBase getEntityID: (entity id) attribute: #description.   self assert: ( value == 'This is only a test.') not.   self assert: ( value == 'This WAS only a test.').      </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test640FindWhere</h3><pre>test640FindWhere   "set entity-attribute value"   | worldBase entityA entityB entitySet |   worldBase := HumWorldBase openWorldBase: 'test640FindWhere'.   self assert: worldBase notNil.   self assert: ( worldBase title = 'test640FindWhere' ).      "Insert two entity instances with attribute vlaues."   entityA := HumIdentifier createUniqueIdentifierForEntityName: 'Person:A' inContext: 'test640FindWhere'.   worldBase setEntityID: entityA attribute: 'first-name' toValue: 'Tessie'.      worldBase setEntityID: entityA attribute: 'last-name'  toValue: 'Tester'.         entityB := HumIdentifier createUniqueIdentifierForEntityName: 'Person:B' inContext: 'test640FindWhere'.   worldBase setEntityID: entityB attribute: 'first-name' toValue: 'Terry'.      worldBase setEntityID: entityB attribute: 'last-name'  toValue: 'Terrence'.         "Return a set of entity identifiers satisfying my criteria."   entitySet := worldBase whereAttribute: 'first-name' satisfies: [:name | name beginsWith: 'T'].   self expect: 2 actual: (entitySet size).      "entitySet sorted asArray inspect."      "TODO: Decide: EntityType is innate. EntityType is an attribute."      </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test700BlackBoardReadMe</h3><pre>test700BlackBoardReadMe   "   Each active actor records its state on a BlackBoard instance.   The BlackBoard instance may persist its data on a WorldBase singleton.   "   "   Hum BlackBoard client situations (use cases):   A Coordinator is operating a plan. The plan has context and state.   A Dispatcher tracks a number of Actors, their Roles, and their execution state.   A Dialog Agent may have a long-running Dialog with associated data.   A Messenger must remember the URI (network addresses) associated with actor IDs.   When an actor delegates an instruction to another actor, (like RMI)     the 'caller' must persist its state until the delegation 'returns'      so that the caller can resume execution with saved state and instruction-pointer.     Note: The saved state may be 'updated/amended' if the delegation has a 'giving' clause.   "</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test710setAndGet</h3><pre>test710setAndGet   "set entity-attribute value"   | blackboard entity value |   blackboard := HumBlackBoard new.   blackboard worldbase: ( HumWorldBase new ).   blackboard businessEvent: 'test710setAndGet'.   entity := HumEntity title: 'Entity for test710setAndGet'.   "Set entity-attribute value."   blackboard setEntityID: (entity id) attribute: #description toValue: 'This is only a test.'.   value := blackboard getEntityID: (entity id) attribute: #description.   self assert: ( value == 'This is only a test.').</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test720setGetReplace</h3><pre>test720setGetReplace   "Update entity-attribute value"   | blackboard entity value |   blackboard := HumBlackBoard new.   blackboard worldbase: ( HumWorldBase new ).   blackboard businessEvent: 'test720setGetReplace'.   entity := HumEntity title: 'Entity for test720setGetReplace'.   blackboard setEntityID: (entity id) attribute: #description toValue: 'This is only a test.'.   value := blackboard getEntityID: (entity id) attribute: #description.   self assert: ( value == 'This is only a test.').      blackboard setEntityID: (entity id) attribute: #description toValue: 'This WAS only a test.'.   value := blackboard getEntityID: (entity id) attribute: #description.   self assert: ( value == 'This is only a test.') not.   self assert: ( value == 'This WAS only a test.').</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test730clearEntity</h3><pre>test730clearEntity   "Update entity-attribute value"   | blackboard value worldbase |      self skip. "Why would we need to clear a real-world entity`s attribute values? "      blackboard := HumBlackBoard new.   worldbase := HumWorldBase openWorldBase: 'worldbase for test730clearEntity'.   blackboard worldbase: worldbase.   blackboard businessEvent: 'test730clearEntity'.      blackboard setEntityName: 'Tester' attribute: #description toValue: 'This is only a test.'.   value := blackboard getEntityName: 'Tester' attribute: #description.   self assert: ( value == 'This is only a test.').   blackboard clearEntity: 'Tester'.      self expect: 0 actual: (blackboard entityIdentifiers size).   self expect: 0 actual: (blackboard quads size).   self expect: 1 actual: (worldbase quads size).   self expect: 0 actual: (worldbase history size).      blackboard setEntityName: 'Tester' attribute: #description toValue: 'This WAS only a test.'.   self expect: 1 actual: (blackboard entityIdentifiers size).   self expect: 1 actual: (blackboard quads size).   self expect: 2 actual: (worldbase quads size).   self expect: 0 actual: (worldbase history size).      value := blackboard getEntityName: 'Tester' attribute: #description.   self assert: ( value == 'This is only a test.') not.   self assert: ( value == 'This WAS only a test.').</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test800DialogAgentReadMe</h3><pre>test800DialogAgentReadMe   "Dialogs:   A Dialog Agent instance is associated with each active dialog.
  Active dialogs are long-running;    so the state of the dialog must be persisted indefinitely.Session:   A session is defined by a connection to some client/user interface (UI) technology.   Between sessions, the state of the dialog is persisted.   When a new session begins,     the state is restored to assure continuity in the conversation.   (The user should feel that we remember them and what was said in the prior session.)Scribes:   When a dialog session is initiated, a Scribe is already present.   The Scribe mediates between the Dialog (Dialog Agent) and the user interface.   The Scribe translates user gestures into dialog vignette 'speech' inputs.   See: The Scribe ReadMe for more detail about the scribe.Clients:   It is generally assumed that the client actor will be human user.   However, dialogs may also be written for automated actors.   "</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test810createSimpleVignette</h3><pre>test810createSimpleVignette   "Create a vignette frame."   | vignetteFrame ontology pattern response |   ontology := HumOntology new.   setupConfiguration ontology: ontology.   pattern := 'Hello *.'.   vignetteFrame := HumFrame4Vignette                                  ontology: ontology                                  vignetteContext: 'Start.'                                  pattern: pattern.    response := 'Hello yourself.'.   vignetteFrame addVignetteResponse: response.   vignetteFrame compileToOntology: ontology. </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test820createDialogAgent</h3><pre>test820createDialogAgent   "Create a dialog agent."   | dialogAgent |   dialogAgent := HumDialogAgent                               dialogID: 'Dialog Agent ID'                               uri: 'Dialog Agent URI'                               client: 'clientURI'                               configuration: setupConfiguration.</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test825DialogAgentHasScribe</h3><pre>test825DialogAgentHasScribe   "When a dialog agent is activated, a Scribe is already present."   | dialogAgent |   "How is the scribe`s presence evidenced?   This constructor assumes that a Scribe mediates the URI.   We can assume that the Scribe is calling the constructor?General dataflow / workflow:   User authenticates via web application.   Web Application: ( Inform scribe that user connected.)   ==&gt; Scribe: ( Identify on-going dialog, if any. Set context. Operate vignette. )Thinking out loud:   Using a URI to identify the client makes several assumptions about the environment.   Q: Should this be a client ID instead? That would be more consistent with other constructors.   "   dialogAgent := HumDialogAgent                               dialogID: 'Dialog Agent ID'                               uri: 'Dialog Agent URI'                               client: 'clientURI'                               configuration: setupConfiguration.   self assert: (dialogAgent scribeProxy isKindOf: HumScribe ).</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test830dialogAgentMatchesInputToVignette</h3><pre>test830dialogAgentMatchesInputToVignette   "Pattern 'Hello *.' matches 'Hello.'.    Given: a set of vignettes (in an ontology)    When: Scribe sends a user statement - clientSays: 'Hello.'    Then: Dialog Agent matches user statement to available vignette patterns.   "   | vignetteFrame ontology pattern response dialogAgent  match |   ontology := HumOntology new.   setupConfiguration ontology: ontology.   pattern := 'Hello *.'.   vignetteFrame := HumFrame4Vignette                                  ontology: ontology                                  vignetteContext: 'Start.'                                  pattern: pattern.    response := 'Hello yourself.'.   vignetteFrame addVignetteResponse: response.   vignetteFrame compileToOntology: ontology.      dialogAgent := HumDialogAgent                               dialogID: 'Dialog Agent ID'                               uri: 'Dialog Agent URI'                               client: 'clientURI'                               configuration: setupConfiguration.   "Simulate call from Scribe."   match := dialogAgent clientSays: 'Hello.'.   self assert: ( match isKindOf: HumFrame4Vignette ).   self assert: ( match responseLines notEmpty ).   self assert: (( match responseLines at: 1 ) sameAs: 'Hello yourself.').</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test832dialogAgentMatchesInputToVignette2</h3><pre>test832dialogAgentMatchesInputToVignette2   "Pattern 'Hello *.' matches 'Hello Ms. Robot.'    Given: a set of vignettes (in an ontology)    When: Scribe sends a user statement -- clientSays: 'Hello Ms. Robot.'.    Then: Dialog Agent matches user statement to vignette with wildcard. -- pattern := 'Hello *.'.   "   | vignetteFrame ontology pattern response dialogAgent  match responseLines |   ontology := HumOntology new.   setupConfiguration ontology: ontology.   pattern := 'Hello *.'.   vignetteFrame := HumFrame4Vignette                                  ontology: ontology                                  vignetteContext: 'Start.'                                  pattern: pattern.    response := 'Hello yourself.'.   vignetteFrame addVignetteResponse: response.   vignetteFrame compileToOntology: ontology.      dialogAgent := HumDialogAgent                               dialogID: 'Dialog Agent ID'                               uri: 'Dialog Agent URI'                               client: 'clientURI'                               configuration: setupConfiguration.   "Simulate call from Scribe."   match := dialogAgent clientSays: 'Hello Ms. Robot.'.   self assert: ( match isKindOf: HumFrame4Vignette ).   responseLines := match responseLines.   self expect: 1 actual: ( responseLines size ).   self expect: 'Hello yourself.' actual: ( responseLines at: 1 ) source.</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test833dialogAgentMatchesInputToVignette3</h3><pre>test833dialogAgentMatchesInputToVignette3   "Pattern ('Hello *.' 'Hi *.') matches 'Hi there.'.    Given: a set of vignettes (in an ontology)    When: Scribe sends a user statement    Then: Dialog Agent matches user statement to available vignette patterns.   "   | vignetteFrame ontology pattern response dialogAgent  match |   ontology := HumOntology new.   setupConfiguration ontology: ontology.   pattern := 'Hello *.'.   vignetteFrame := HumFrame4Vignette                                  ontology: ontology                                  vignetteContext: 'Start.'                                  pattern: pattern.    vignetteFrame addPattern: 'Hi *.'.                                 response := 'Welcome.'.   vignetteFrame addVignetteResponse: response.   vignetteFrame compileToOntology: ontology.      dialogAgent := HumDialogAgent                               dialogID: 'Dialog Agent ID'                               uri: 'Dialog Agent URI'                               client: 'clientURI'                               configuration: setupConfiguration.   "Simulate call from Scribe."   match := dialogAgent clientSays: 'Hi there.'.   self assert: ( match isKindOf: HumFrame4Vignette ).   self assert: ( match responseLines notEmpty ).   self assert: (( match responseLines at: 1 ) source) equals: response.</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test834dialogAgentMatchesInputWithAlternatePunctuations</h3><pre>test834dialogAgentMatchesInputWithAlternatePunctuations   "Pattern ('Hello *.' 'Hi *.' 'Hi *!' 'Hello * ?') matches 'Hi there.'.    Given: a set of vignettes (in an ontology)    When: Scribe sends a user statement    Then: Dialog Agent matches user statement to available vignette patterns.   "   | vignetteFrame ontology pattern response dialogAgent  match |   ontology := HumOntology new.   setupConfiguration ontology: ontology.   pattern := 'Hello *.'.   vignetteFrame := HumFrame4Vignette                                  ontology: ontology                                  vignetteContext: 'Start.'                                  pattern: pattern.    vignetteFrame addPattern: 'Hi *.'.   vignetteFrame addPattern: 'Hi *!'.   vignetteFrame addPattern: 'Hello * ?'.                                       response := 'Welcome.'.   vignetteFrame addVignetteResponse: response.   vignetteFrame compileToOntology: ontology.      dialogAgent := HumDialogAgent                               dialogID: 'Dialog Agent ID'                               uri: 'Dialog Agent URI'                               client: 'clientURI'                               configuration: setupConfiguration.   "Simulate call from Scribe."   match := dialogAgent clientSays: 'Hi there.'.   self assert: ( match isKindOf: HumFrame4Vignette ).   self assert: ( match responseLines notEmpty ).   self assert: (( match responseLines at: 1 ) source) equals: response.</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test840dialogAgentSorry</h3><pre>test840dialogAgentSorry   "Stimulus 'Help' returns 'Sorry ...'    Given: a set of vignettes (in an ontology)    When: Scribe sends a user statement      Then: Dialog Agent attempts to match user statement to available vignette patterns.    When: There is no match      Then: The agent returns a 'sorry . . .' response   "   | vignetteFrame ontology pattern response dialogAgent  match |   ontology := HumOntology new.   setupConfiguration ontology: ontology.   pattern := 'Hello *.'.   vignetteFrame := HumFrame4Vignette                                  ontology: ontology                                  vignetteContext: 'Start.'                                  pattern: pattern.    response := 'Hello yourself.'.   vignetteFrame addVignetteResponse: response.   vignetteFrame compileToOntology: ontology.      dialogAgent := HumDialogAgent                               dialogID: 'Dialog Agent ID'                               uri: 'Dialog Agent URI'                               client: 'clientURI'                               configuration: setupConfiguration.   "Simulate call from Scribe."   match := dialogAgent clientSays: 'Help.'.   self assert: ( match isKindOf: HumFrame4Vignette ).   self assert: ( match responseLines notEmpty ).   self assert: (( match responseLines at: 1 ) sameAs: 'Hello yourself.') not.   self assert: (( match responseLines at: 1 ) source beginsWith: 'Sorry').   self assert: (( match responseLines at: 1 ) source sameAs: 'Sorry, { Help.} is not understood.').   </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test850dialogAgentMatchesInputWithAlternatePunctuations</h3><pre>test850dialogAgentMatchesInputWithAlternatePunctuations   "Pattern ('Hello *.' 'Hi *.') matches 'Hi!'.    Given: a set of vignettes (in an ontology)    When: Scribe sends a user statement    Then: Dialog Agent matches user statement to available vignette patterns.   "   | vignetteFrame ontology pattern response dialogAgent  match responseLines |   ontology := HumOntology new.   setupConfiguration ontology: ontology.   pattern := 'Hello *.'.   vignetteFrame := HumFrame4Vignette                                  ontology: ontology                                  vignetteContext: 'Start.'                                  pattern: pattern.    vignetteFrame addPattern: 'Hi *.'.                                    response := 'Welcome.'.   vignetteFrame addVignetteResponse: response.   vignetteFrame compileToOntology: ontology.      dialogAgent := HumDialogAgent                               dialogID: 'Dialog Agent ID'                               uri: 'Dialog Agent URI'                               client: 'clientURI'                               configuration: setupConfiguration.   "Simulate call from Scribe."   match := dialogAgent clientSays: 'Hi!'.   self assert: ( match isKindOf: HumFrame4Vignette ).   responseLines := match responseLines.    self expect: 1 actual: ( responseLines size ).   self expect: response actual: (( responseLines at: 1 ) source ).</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; test860dialogAgentMatchesInputWithNounSlot</h3><pre>test860dialogAgentMatchesInputWithNounSlot   "Pattern ('My name is [full-name].') matches 'My name is Tessie Tester.'.    Given: a set of vignettes (in an ontology)    When: Scribe sends a user statement    Then: Dialog Agent matches user statement to available vignette patterns.   "   | vignetteFrame ontology pattern response dialogAgent  match responseLines stepLog |   ontology := HumOntology new.   ontology addEntity: 'user' attribute: 'name'.     setupConfiguration ontology: ontology.   pattern := 'My name is [user name].'.   vignetteFrame := HumFrame4Vignette                                  ontology: ontology                                  vignetteContext: 'Start.'                                  pattern: pattern.                                     response := 'Welcome [user name].'.   vignetteFrame addVignetteResponse: response.   vignetteFrame compileToOntology: ontology.      dialogAgent := HumDialogAgent                               dialogID: 'Dialog Agent ID'                               uri: 'Dialog Agent URI'                               client: 'clientURI'                               configuration: setupConfiguration.   "Simulate call from Scribe."   match := dialogAgent clientSays: 'My name is Tessie Tester.'.   self assert: ( match isKindOf: HumFrame4Vignette ).   responseLines := match responseLines.    self expect: 1 actual: ( responseLines size ).   self assert: ('*Sorry*' match: ( responseLines at: 1 ) source) not description: 'Don`t be sorry.'.   self expect: 'Welcome [user name].' actual: (( responseLines at: 1 ) source ).   "Was slot filled-in?"   stepLog := dialogAgent stepLog.   self expect: 'S: Welcome Tessie Tester.' actual: (stepLog at: 2).</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; testM110MessengerRemembersActors</h3><pre>testM110MessengerRemembersActors   | messenger cook server |   "Create an actor -- The actor automatically registers itself with the messenger in its configuration."   cook := HumActor workerID: 'cook ID' uri: 'mock cook URI' roles: #('cook')  configuration: setupConfiguration.   cook checkIn.   messenger := setupConfiguration messenger.   self assert: ( messenger ping: 'mock cook URI' ) equals: cook id.   "One more should make no problem."   server := HumActor workerID: 'server ID' uri: 'server URI' roles: #('server') configuration: setupConfiguration.   server checkIn.   self assert: ( messenger ping: 'server URI' )= server id.   self assert: ( messenger ping: 'mock cook URI' ) == cook id.   </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; testM120MessageAttributes</h3><pre>testM120MessageAttributes   "The components of a message include sender, receiver, when sent, statement, and noun-values. "   | message |   message := HumMessage title: 'message in testM120MessageAttributes'.   message sender: 'sender ID';           receiver: 'receiver ID';           whenSent: (Duration seconds: 120);           statement: (HumStatement source: 'Bake a cake per recipe.');           nounValues: #( 'recipe'-&gt;'Recipe M120' ).</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; testS100ScribeReadMe</h3><pre>testS100ScribeReadMe   "These Scribe tests generally involve a Scribe that is independent of Seaside.   If the client is running in HTML context, the HTML scribe will be invoked.   If the client is running in a VR context, the appropriate VR scribe will be invoked.   See: HumScribe&gt;&gt;about for more detail about Scribe interactions.   "   | |   "   When a dialog session is initiated, a Scribe is already present.   The Scribe mediates between the Dialog Agent and the user interface.   The Scribe translates user gestures into dialog vignette 'speech' inputs.   The user/client interface may be one of many technologies including:    HTML forms,    HTTP / AJAX / XMPP,     software embedded with hardware sensors,    voice recognition,    hand-gesture / body-language interpreters,    virtual reality sensors,    an automated agent message framework,    or an internal unit-test user-simulator.   The first UI-connected Scribe will be built around HTML forms    as that is a popular technology at this time (June 2014)."      "A Scribe is a HumActor that interprets user gestures seen by some set of sensors."   "In this set of tests, the Scribe interprets HTTP requests."      "General dataflow / workflow:   User authenticates via web application.   Web Application: ( Inform scribe that user connected.)   ****   ==&gt; Dialog Agent: ( Identify on-going dialog, if any. Initialize context stack. Operate 'Hello' vignette. )   ****   ==&gt; Vignette: (Ask viewName)    ==&gt; Dialog Agent: ( Delegate view operation to Scribe.)   ==&gt; Scribe: ( Translate view to HTML page. )    ==&gt; Scribe: ( Send HTML page to web browser.)   ==&gt; Browser: ( User fills in blanks and presses [[Submi`t Button]].)   ==&gt; Scribe: ( Captures data from Http Response and returns data to Dialog Agent in task-completion message. )   ==&gt; Dialog Agent: ( Registers data on blackboard and completes current vignette.)   "   "TODO: How does the Dispatcher know what kind of Scribe to delegate 'Ask viewName.' ???"   "Thinking Out Loud:   . Scribe is wrapper around a suite of sensors.   . That means it is determined by the user`s UI context.    . . HTML: If Scribe is resident on Browser, it can be associated directly with HTML user/client.   . . HTML: If Scribe is server-side, it is associated with a session, and thus with an HTML client.   . . XMPP: If client is communicating via XMPP, Scribe can be an XMPP receiver.   . . Virtual World: Scribe must reside in the virtual world ??   . The Scribe and the user/client are indistinguishable from the PoV of other actors.   * Therefore:    * . *** The Scribe must start the session and configure the Dialog Agent.***   * . The Dialog Agent must override or finess the Dispatcher to assign the correct Scribe instance.   * . . Perhaps we should think of the Dispatcher as part of a session configuration   * . . . and the session configuration includes the right kind of Scribe.   * . Alternate: Add suitable 'back-door' methods to the Dispatcher. (JobTicket not relevant to Scribe.)   * . Alternate: The Dialog Agent by-passes the Dispatcher and delegates to Scribe actor directly.  * . .    '( self messenger ) sendStatement: aMessageObject toID: recipientID fromID: myID.'   * . Alternate: Scribe instance role-name is unique. (Works if Dispatcher does not check against Ontology.)   "      "Summary - Restatement:   - When a session is instantiated BUT client is UNKNOWN, (anonymous/guest client)    . . a Scribe and a Dialog Agent MAY be instantiated,    . . BUT the Dialog  will have no history and a temporary context stack.   - When a session is instantiated AND the client is identified,   . . a Scribe and a Dialog Agent will be instantiated,    . . AND the Dialog will have history and context stack fetched from ??? WorldBase ???.   - Assuming the Dialog Agent is server-side,   . . we will instatiate it on the same server as the Dispatcher.   . . (In Erlang OTP, it will be ??? )   . . (In Java web server, it will be attached to the session.)    . . (In Seaside web server, session (WASession subtype) will delegate to Dialog Agent.)   . . (In Smalltalk without Seaside, a response handler (HTTP/XMPP) will delegate to Dialog Agent.)   "</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; testS110SetupScribe</h3><pre>testS110SetupScribe   "A scribe is attached to a dialogAgent Agent.   The dialogAgent Agent is configured with a Blackboard.   "   | dialogAgent configuration scribe |   configuration := HumConfiguration messengerID: 'IDMessenger'                                     dispatcherID: 'IDDispatcher'                                     bookkeeperID: 'IDBookkeeper'                                      worldbaseID: 'IDWorldbase'.    configuration messenger: HumMessenger new.   configuration openWorldBase.   dialogAgent := HumDialogAgent dialogID: 'dialogID' uri: 'dialogURI' client: 'clientURI' configuration: configuration.   scribe := HumScribe dialogAgent: dialogAgent.    "Scribe is attached to a Dialog Agent."   self expect: HumDialogAgent actual: (scribe dialogAgent class).   "The Dialog Agent has a Blackboard."   self expect: HumBlackBoard  actual: (scribe dialogAgent blackboard class).</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; testS131ScribeHandlesHttpPostRequest</h3><pre>testS131ScribeHandlesHttpPostRequest   "Scribe: Captures data from Http Response and returns data to Dialog Agent in task-completion message. "   | scribe request dialogAgent  |   "Setup the Dialog actor and the Scribe actor."   dialogAgent := HumDialogAgent            dialogID: 'dialogID'            uri: 'dialogURI'            client: 'clientURI'            configuration: setupConfiguration.   dialogAgent blackboard businessEvent: 'testS131ScribeHandlesHttpPostRequest'.      scribe := HumScribe dialogAgent: dialogAgent.   request := HumHttpRequest new.   "Set Http Request form to include this input - name:value pair."   request atField: 'entityName:attributeName' put: 'test value'.      "Ask Scribe to handle the request."   scribe handleHttpPostRequest: request.      "We should see data in Scribe`s Blackboard and a change in scribe state."   self expected: 'test value' actual: ( scribe blackboard getEntityName: 'entityName' attribute: 'attributeName').      "We should also see data in the Dialog Agent`s blackboard"   self expected: 'test value' actual: ( dialogAgent blackboard getEntityName: 'entityName' attribute: 'attributeName').   </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; testS132ScribeHandlesViewReturn</h3><pre>testS132ScribeHandlesViewReturn   "Scribe: Captures data from Http Response and returns data to Dialog Agent in task-completion message. "   | baseOntology dialogAgent scribe viewFrame |   "Scenario:   1. Dialog matches vignette.   2. Vignette response contains 'Ask viewname.'   3. Dialog gets ViewFrame from Ontology.   4. Dialog delegates 'Ask' to Scribe.   5. HTML-Scribe generates HTML page/frame with needed HTML form elements.   6. HTML-Scribe sends HTML page/frame via a Session?   7. HTML-Scribe receives HTML-response from Session.   8. HTML-Scribe parses HTML-response and populates Dialog blackboard.   9. *** Form return is a Dialog Pattern???? ***"   true ifFalse: [Transcript cr; show: 'testS132ScribeHandlesViewReturn is turned off.'. ^self skip].      "Dialog delegates 'Ask' to Scribe"   baseOntology := HumOntology baseOntology.   self setUpKnockKnockOnOntology: baseOntology.   dialogAgent := HumDialogAgent dialogID: 'dialogID'                                       uri: 'dialogURI'                                    client: 'clientURI'                             configuration: setupConfiguration.   scribe := HumScribe dialogAgent: dialogAgent.   viewFrame := baseOntology getViewFrame: 'Knock'.   dialogAgent blackboard businessEvent: 'Ask Knock'.   scribe askView: viewFrame withBlackBoard: (dialogAgent blackboard).       self expect: 'sendView: {   &lt;form action="View: Knock." class="Ask" enctype="application/x-www-form-urlencoded" id="View: Knock." method="POST" &gt;   &lt;h2&gt;Knock, knock, who`s there?&lt;/h2&gt;  Please enter first name: &lt;input type="text" name="Knock:first-name" value=""/&gt; &lt;input type="submit" value="Go!"   style="color:WHITE; background:GREEN"/&gt; &lt;input type="submit" value="NoGo!" style="color:WHITE; background:RED"/&gt;   &lt;/form&gt;}'         actual: (scribe log at: 1 ifAbsent: ['']).   "htmlSent := scribe log at: 2.    htmlSent inspect."      </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; testS134ScribeMocksViewDataEntry</h3><pre>testS134ScribeMocksViewDataEntry   "Scribe: Captures data from Http Response and returns data to Dialog Agent in task-completion message. "   | baseOntology dialogAgent scribe viewFrame userEntries blackboard |   true ifFalse: [Transcript cr; show: 'testS134ScribeMocksViewDataEntry is turned off.'. ^self skip].      "Dialog delegates 'Ask' to Scribe"   dialogAgent := HumDialogAgent dialogID: 'dialogID'                                       uri: 'dialogURI'                                    client: 'clientURI'                             configuration: setupConfiguration.  dialogAgent blackboard businessEvent: 'testS133ScribeMocksViewDataEntry'.   scribe := HumScribe dialogAgent: dialogAgent.   userEntries := Dictionary new.   userEntries      at: 'knock:first-name' put: 'Testy'.   scribe mockDataEntry: userEntries.   "The blackboard should now match data entered."   blackboard := dialogAgent blackboard.   self expect: 'Testy' actual: (blackboard getEntityName: 'knock' attribute: 'first-name').   "And the worldbase has also been updated"   self expect: 1 actual: (blackboard worldbase quads size).      </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; testV100ReadMe</h3><pre>testV100ReadMe   "Test HumVector - which is a subclass of FloatArray"   "Test vector arithmetic v + v, v - v, v dot: v, v cross: v. v * scalar. v / scalar."   | v |   v := HumVector newFrom: { 1. 2. 3. }.   self expect: HumVector actual: (v class).   self assert: (v isKindOf: HumMeasure).</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; testV105GetPutXYZ</h3><pre>testV105GetPutXYZ   "Test HumVector - which is a subclass of HumMeasure"   "Test vector arithmetic v + v, v - v, v dot: v, v cross: v. v * scalar. v / scalar."   | v |   v := HumVector newFrom: { 1. 2. 3. }.   self expect: HumVector actual: (v class).   self assert: (v isKindOf: HumMeasure).      self expect: 1.0 meter actual: (v x).      self expect: 2.0 meter actual: (v y).      self expect: 3.0 meter actual: (v z).</pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; testV110TestVplusV</h3><pre>testV110TestVplusV   "Test HumVector - which is a subclass of . . ."   "Test vector arithmetic v + v, v - v, v dot: v, v cross: v. v * scalar. v / scalar."    | a b c |   a := HumVector newFrom: { 1. 2. 3. }.   b := HumVector newFrom: { 5. 7. 11. }.   c := a + b.   self expect: (HumVector newFrom: {  6. 9. 14. } ) actual: c.   </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; testV120TestVminusV</h3><pre>testV120TestVminusV   "Test HumVector - which is a subclass of . . ."   "Test vector arithmetic v + v, v - v, v dot: v, v cross: v. v * scalar. v / scalar."    | a b c |   a := HumVector newFrom: { 1. 2. 3. }.   b := HumVector newFrom: { 5. 7. 11. }.   c := b - a.   self expect: (HumVector newFrom: {  4. 5. 8. } ) actual: c.   </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; testV130TestVdotV</h3><pre>testV130TestVdotV   "Test HumVector - which is a subclass of . . ."   "Test vector arithmetic v + v, v - v, v dot: v, v cross: v. v * scalar. v / scalar."    | a b c |   a := HumVector newFrom: { 1. 2. 3. }.   b := HumVector newFrom: { 5. 7. 11. }.   c := b dot: a.   self expect: ( HumMeasure quantity: (5.0 + 14.0 + 33.0)  units: 'square meter' ) actual: c.   </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; testV140TestVcrossV</h3><pre>testV140TestVcrossV   "Test HumVector - which is a subclass of . . ."   "Test vector arithmetic v + v, v - v, v dot: v, v cross: v. v * scalar. v / scalar."    | a b c |   "Test with unit vectors."   a := HumVector newFrom: { 1. 0. 0. }.   b := HumVector newFrom: { 0. 1. 0. }.   c := a cross: b.   self expect: (HumVector newFrom: {  0. 0. 1. } units: 'square meter') actual: c.      c := b cross: a.   self expect: (HumVector newFrom: {  0. 0. -1. } units: 'square meter') actual: c.            "Text with some numbers."   a := HumVector newFrom: { 3. 0. 0. }.   b := HumVector newFrom: { 0. 5. 0. }.   c := a cross: b.   self expect: (HumVector newFrom: {  0. 0. 15. } units: 'square meter' ) actual: c.      c := b cross: a.   self expect: (HumVector newFrom: {  0. 0. -15. } units: 'square meter' ) actual: c.            </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; testV150TestVtimesScalar</h3><pre>testV150TestVtimesScalar   "Test HumVector - which is a subclass of . . ."   "Test vector arithmetic v + v, v - v, v dot: v, v cross: v. v * scalar. v / scalar."    | a scalar c |   a := HumVector newFrom: { 1. 2. 3. }.   scalar := 5.   c := a * scalar.   self expect: (HumVector newFrom: {  5. 10. 15. } ) actual: c.   </pre><h3>Hum-Tests -- HumRunTimeTests &gt;&gt; testV160TestVdividedByScalar</h3><pre>testV160TestVdividedByScalar   "Test HumVector - which is a subclass of . . ."   "Test vector arithmetic v + v, v - v, v dot: v, v cross: v. v * scalar. v / scalar."    | a scalar c |   a := HumVector newFrom: { 1. 2. 3. }.   scalar := 4.   c := a / scalar.   self expect: (HumVector newFrom: {  0.25. 0.50. 0.75. } ) actual: c.   </pre><h3>Hum-Tests -- HumSeasideProgrammersAssistantTests &gt;&gt; aReadMe</h3><pre>aReadMe   "   These HumSeasideTests are adapted from HumProgrammerAssistantTests.   The Programmers Assistant provides a technology-free model of the UI.   The Hum Seaside classes provide a UI in Seaside.   "   ^'See the class description for the intended (future) tests.'   </pre><h3>Hum-Tests -- HumSeasideProgrammersAssistantTests &gt;&gt; test110newOntology</h3><pre>test110newOntology   "Browser initializes (re-initializes) to an empty ontology."   | browser |   browser := HumBrowser new.   browser clearOntology.   self assert: (browser ontology nouns isEmpty).</pre><h3>Hum-Tests -- HumSeasideProgrammersAssistantTests &gt;&gt; test121loadOntologyInstance</h3><pre>test121loadOntologyInstance   "Browser saves (writes) the ontology to a file."   | browser ontology |   browser := HumBrowser new.   browser loadOntologyInstance: 'Hum Seaside Test Ontology'.   self assert: browser ontology notNil.   browser saveOntology.   </pre><h3>Hum-Tests -- HumSeasideProgrammersAssistantTests &gt;&gt; test130saveOntology</h3><pre>test130saveOntology   "Browser saves (writes) the ontology to a file."   | browser |   browser := HumBrowser new.   browser clearOntology.   browser saveOntology.   </pre><h3>Hum-Tests -- HumSeasideProgrammersAssistantTests &gt;&gt; test222OpenOntologyInstance</h3><pre>test222OpenOntologyInstance   "Test the dialog that asks the user for the file name."   | browser fileName |   "   Given: User has invokes 'Open ontology' in the browser menu.   When: User enters an existing (test) filename . . .   Then: The ontology attached to the browser matches the content of the test file.   "   browser := HumBrowser new.   browser loadOntologyInstance: 'Hum Seaside Test Ontology'.   self assert: (browser ontology isKindOf: HumOntology).   self assert: browser ontology title = 'Hum Seaside Test Ontology'.   </pre><h3>Hum-Tests -- HumSeasideUserInterfaceTests &gt;&gt; checkGeneratedCode</h3><pre>checkGeneratedCode   "This is a place to see if generated code will compile."</pre><h3>Hum-Tests -- HumSeasideUserInterfaceTests &gt;&gt; setUpViewFrameInOntology:</h3><pre>setUpViewFrameInOntology: aHumOntology   "Generate a view frame and dictionary entries for several tests.   ---   !! Recipe   recipe-name: [name]     description: [description]     ingredients: [ingredients]           steps: [steps]   ---   Dictionary: Recipe attributes.   . Recipe attributes include recipe-line, description, ingredients, steps.   . Description is a text.   . Recipe has a set of ingredients.   . Recipe has a list of steps.   ---   "   | frameEditor errors |   "Create a view frame."   frameEditor := HumFrameUpdater ontology: aHumOntology viewEntity: 'recipe'.   "Add markup lines."   frameEditor addMarkUp: '!! Recipe'.   frameEditor addMarkUp: ' recipe-name: [name]'.   frameEditor addMarkUp: '   description: [description]'.   frameEditor addMarkUp: '   ingredients: [ingredients]'.   frameEditor addMarkUp: '         steps: [steps]'.   aHumOntology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).   errors := frameEditor compileToOntology: aHumOntology.   self assert: ( errors isEmpty  ).      "TODO: Make this smarter.    - At the very least, description, ingredients, and steps could be of type text.   - (and rendered using textarea tag).   "      "Create a dictionary frame."   frameEditor := HumFrameUpdater ontology: aHumOntology dictionaryTitle: 'Recipe attributes.'.   frameEditor addDictionaryLine: 'Recipe attributes include recipe-line, description, ingredients, steps.'.   frameEditor addDictionaryLine: 'Description is a text.'.   "TODO: Should render description as a text area."   frameEditor addDictionaryLine: 'Recipe has a set of ingredients.'.   "TODO: Should render ingredients as an unordered list."   frameEditor addDictionaryLine: 'Recipe has a list of steps.'.   "TODO: Should render steps as an ordered list."   errors := frameEditor compileToOntology: aHumOntology.   self assert: ( errors isEmpty  ).             </pre><h3>Hum-Tests -- HumSeasideUserInterfaceTests &gt;&gt; test310ViewBecomesForm</h3><pre>test310ViewBecomesForm   "A Hum view frame is rendered as a Seaside Form.   TODO: Figure out how to handle read-only form later.   "   | ontology  viewFrame frameCode |   ontology := HumOntology new.      "Initialize the View Frame for this test."     self setUpViewFrameInOntology: ontology.   "There is only one frame in this ontology."   viewFrame :=  ontology fetchFrameByName: 'View: recipe.'.   self assert: viewFrame notNil.    "Generate Seaside code for the view frame."   frameCode := ontology codeGenerator generateSeasideForView: viewFrame.      self assert: ( frameCode isKindOf: String ).   self assert: ( frameCode findString: 'html form')  &gt; 1.</pre><h3>Hum-Tests -- HumSeasideUserInterfaceTests &gt;&gt; test311ViewHasMultipleLines</h3><pre>test311ViewHasMultipleLines   "A Hum view frame is rendered as a Seaside Form.   TODO: Figure out how to handle read-only form later.   "   | ontology  viewFrame frameCode |   ontology := HumOntology new.      "Initialize the View Frame for this test."     self setUpViewFrameInOntology: ontology.   "There is only one frame in this ontology."   viewFrame :=  ontology fetchFrameByName: 'View: recipe.'.   self assert: viewFrame notNil.    "Generate Seaside code for the view frame."   frameCode := ontology codeGenerator generateSeasideForView: viewFrame.   self assert: ( frameCode includesSubString: 'html form' ).   self assert: ( frameCode includesSubString: 'html break' ).</pre><h3>Hum-Tests -- HumSeasideUserInterfaceTests &gt;&gt; test312ViewHeader</h3><pre>test312ViewHeader   "A Hum view frame is rendered as a Seaside Form.   TODO: Figure out how to handle read-only form later.   "   | ontology  viewFrame frameCode |   ontology := HumOntology new.      "Initialize the View Frame for this test."     self setUpViewFrameInOntology: ontology.   "There is only one frame in this ontology."   viewFrame :=  ontology fetchFrameByName: 'View: recipe.'.   self assert: viewFrame notNil.    "Generate Seaside code for the view frame."   frameCode := ontology codeGenerator generateSeasideForView: viewFrame..   self assert: ( frameCode isKindOf: String ).   self assert: ( frameCode includesSubString: 'html form' ).   self assert: ( frameCode includesSubString: 'html break' ).   self assert: ( frameCode includesSubString: 'html heading level: 2' ).   self assert: ( frameCode includesSubString: 'Recipe').   </pre><h3>Hum-Tests -- HumSeasideUserInterfaceTests &gt;&gt; test313ViewField</h3><pre>test313ViewField   "A Hum view frame is rendered as a Seaside Form.   TODO: Figure out how to handle read-only form later.   "   | ontology  viewFrame frameCode |   ontology := HumOntology new.      "Initialize the View Frame for this test."     self setUpViewFrameInOntology: ontology.   "There is only one frame in this ontology."   viewFrame :=  ontology fetchFrameByName: 'View: recipe.'.   self assert: viewFrame notNil.    "Generate Seaside code for the view frame."   frameCode := ontology codeGenerator generateSeasideForView: viewFrame..   self assert: ( frameCode isKindOf: String ).   self assert: ( frameCode includesSubString: 'html form' ).   self assert: ( frameCode includesSubString: 'html break' ).   self assert: ( frameCode includesSubString: 'html heading level: 2' ).   self assert: ( frameCode includesSubString: 'html textInput callback: [').         self assert: ( frameCode includesSubString: 'setEntityID:').   self assert: ( frameCode includesSubString: 'toValue:').   self assert: ( frameCode includesSubString: '#name').         self assert: ( frameCode includesSubString: 'ingredients' ).      "See if the resulting code will compile in the context of a HumDialogAgent."      (Parser new) parse: ('checkRenderOn: html', String cr, frameCode) class: HumView.      "Transcript show: '*** test313ViewField frameCode: ***'; cr; show: frameCode; cr."   </pre><h3>Hum-Tests -- HumSeasideUserInterfaceTests &gt;&gt; test314CheckGeneratedCode</h3><pre>test314CheckGeneratedCode   "This is a place to see if generated code will compile and run."   | result anEntityID |      result := self builder render: [ :html |    anEntityID := 'TestThisRecipe'.   "Following is pasted from test313ViewField Transcript show:    TODO: Find a way to put in an actual method.   "   html form with: [       html break. html heading level: 2; with: ' Recipe'.      html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #name toValue: datum ]; name: 'name'; value: 'name'.      html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #description toValue: datum ]; name: 'description'; value: 'description'.      html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #ingredients toValue: datum ]; name: 'ingredients'; value: 'ingredients'.      html break. html textInput callback: [:datum | self blackBoard setEntityID: anEntityID attribute: #steps toValue: datum ]; name: 'steps'; value: 'steps'.      ].   ].   "Expect the HTML output to look like this."   "Compare strings ignoring differences in white space."   self assert: ( HumCalculator string: result isLike: '   &lt;form accept-charset="utf-8" method="post" action="/"&gt;     &lt;br/&gt;     &lt;h2&gt;Recipe&lt;/h2&gt;     &lt;br/&gt;&lt;input name="name" value="name" type="text" class="text"/&gt;     &lt;br/&gt;&lt;input name="description" value="description" type="text" class="text"/&gt;     &lt;br/&gt;&lt;input name="ingredients" value="ingredients" type="text" class="text"/&gt;     &lt;br/&gt;&lt;input name="steps" value="steps" type="text" class="text"/&gt;   &lt;/form&gt;' ).   "      TODO: THIS IS JUST A CRUDE FIRST APPROXIMATION.    It does not take data-types into account when selecting the rendering mode.   LONGER TERM:    - Description should be a textarea with rows and columns.   - Ingredients and steps could be a table/list with some way to edit the entries.   - Ingredients (set) could be rendered as an unordered list.   - Steps (list) could be rendered as an ordered list.    "   </pre><h3>Hum-Tests -- HumSeasideWidgetTests &gt;&gt; setUpViewFrameInOntology:</h3><pre>setUpViewFrameInOntology: aHumOntology   "Generate a view frame and dictionary entries for several tests.   ---   !! Recipe   recipe-name: [name]     description: [description]     ingredients: [ingredients]           steps: [steps]   ---   Dictionary: Recipe attributes.   . Recipe attributes include recipe-line, description, ingredients, steps.   . Description is a text.   . Recipe has a set of ingredients.   . Recipe has a list of steps.   ---   "   | frameEditor errors |   "Create a view frame."   frameEditor := HumFrameUpdater ontology: aHumOntology viewEntity: 'recipe'.   "Add markup lines."   frameEditor addMarkUp: '!! Recipe'.   frameEditor addMarkUp: ' recipe-name: [name]'.   frameEditor addMarkUp: '   description: [description]'.   frameEditor addMarkUp: '   ingredients: [ingredients]'.   frameEditor addMarkUp: '         steps: [steps]'.   aHumOntology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).   errors := frameEditor compileToOntology: aHumOntology.   self assert: ( errors isEmpty  ).      "TODO: Make this smarter.    - At the very least, description, ingredients, and steps could be of type text.   - (and rendered using textarea tag).   "      "Create a dictionary frame."   frameEditor := HumFrameUpdater ontology: aHumOntology dictionaryTitle: 'Recipe attributes.'.   frameEditor addDictionaryLine: 'Recipe attributes include recipe-line, description, ingredients, steps.'.   frameEditor addDictionaryLine: 'Description is a text.'.   "TODO: Should render description as a text area."   frameEditor addDictionaryLine: 'Recipe has a set of ingredients.'.   "TODO: Should render ingredients as an unordered list."   frameEditor addDictionaryLine: 'Recipe has a list of steps.'.   "TODO: Should render steps as an ordered list."   errors := frameEditor compileToOntology: aHumOntology.   self assert: ( errors isEmpty  ).             </pre><h3>Hum-Tests -- HumSeasideWidgetTests &gt;&gt; test010GivenWhenThen</h3><pre>test010GivenWhenThen   "Test the test frame"   self given: '' code: [].   self when: '' code: [].   self then: '' code: [ self assert: true.]</pre><h3>Hum-Tests -- HumSeasideWidgetTests &gt;&gt; test011GivenWhenThenFail</h3><pre>test011GivenWhenThenFail   "Dry test the test frame"   self given: '' code: [].   self when: '' code: [].   self then: '' code: [ self assert: true "false".].   </pre><h3>Hum-Tests -- HumSeasideWidgetTests &gt;&gt; test100BasicWiring</h3><pre>test100BasicWiring   "A Hum view frame is rendered as a Seaside Form."   | ontology    humView |   ontology := HumOntology new.      "Initialize the View Frame for this test."   self setUpViewFrameInOntology: ontology.   "Create HumView as interface between Ontology and Seaside"   humView := HumView new.   humView      ontology: ontology;      view: 'recipe';      blackboard: (HumBlackBoard new).         "Generate Seaside code for the view frame."         self assert: humView gives: 'a HumView'.      </pre><h3>Hum-Tests -- HumSeasideWidgetTests &gt;&gt; test102BasicWiring2</h3><pre>test102BasicWiring2   "A Hum view frame is rendered as a Seaside Form."   | ontology    humView frameEditor errors |   ontology := HumOntology new.      "Initialize the View Frame for this test."   frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.   "Add markup lines."   frameEditor addMarkUp: '!! Recipe'.   errors := frameEditor compileToOntology: ontology.   self assert: ( errors isEmpty  ).   "Create HumView as interface between Ontology and Seaside"   humView := HumView new.   humView      ontology: ontology;      view: 'recipe';      blackboard: (HumBlackBoard new).         "Generate Seaside code for the view frame."         self assert: (humView asWidget) matches: '&lt;view id="recipe"&gt;*&lt;/view&gt;'.      </pre><h3>Hum-Tests -- HumSeasideWidgetTests &gt;&gt; test105BindWidgetToBlackboard</h3><pre>test105BindWidgetToBlackboard   "A widget may be bound to blackboard"   |  widget blackboard value entityName attributeName |   "wire it up -- No worldbase for this test."   blackboard := HumBlackBoard worldbase: 'none'.   blackboard businessEvent: 'test105BindWidgetToBlackboard'.   entityName := 'test105'.   attributeName := 'some-attribute'.   widget := HumWidget onEntity: entityName attribute: attributeName blackboard: blackboard.   "Test flow: widget ==&gt; blackboard ==&gt; world base"   value := 'aValue'.    widget store: value.   self expect: value  actual: widget attributeValue.   self expect: value  actual: (blackboard getEntityName: entityName attribute: attributeName).                  </pre><h3>Hum-Tests -- HumSeasideWidgetTests &gt;&gt; test107BindWidgetToCategory</h3><pre>test107BindWidgetToCategory   "A widget may be bound to blackboard"   |  widget blackboard value entityName attributeName |   "wire it up"   blackboard := HumBlackBoard worldbase: 'none'.   blackboard businessEvent: 'test107BindWidgetToCategory'.   entityName := 'test107'.   attributeName := 'some-attribute'.   widget := HumCategoryWidget onEntity: entityName attribute: attributeName blackboard: blackboard.   widget categories: #( 'red' 'green' 'blue' 'yellow' 'orange' 'purple' ).   "Test flow: widget ==&gt; blackboard ==&gt; world base"   value := 'red'.    widget store: value.   self expect: value actual: widget attributeValue.   self expect: value actual: (blackboard getEntityName: entityName attribute: attributeName).                  </pre><h3>Hum-Tests -- HumSeasideWidgetTests &gt;&gt; test110ViewHasViewTag</h3><pre>test110ViewHasViewTag   "A Hum view frame is rendered as a Seaside Form.   "   | ontology    humView frameEditor errors |   ontology := HumOntology new.      "Initialize the View Frame for this test."   frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.   "Add markup lines."   frameEditor addMarkUp: '!! Recipe'.   errors := frameEditor compileToOntology: ontology.   self assert: ( errors isEmpty  ).      "Create HumView as interface between Ontology and Seaside"   humView := HumView new.   humView      ontology: ontology;      view: 'recipe';      blackboard: (HumBlackBoard new).         "Generate Seaside code for the view frame."         self assert: [ :html | humView asWidget renderOn: html ] matches: '&lt;view id="recipe"&gt;*&lt;/view&gt;'.      </pre><h3>Hum-Tests -- HumSeasideWidgetTests &gt;&gt; test120ViewHasFormTag</h3><pre>test120ViewHasFormTag   "A Hum view frame is rendered as a Seaside Form.   "   | ontology    humView frameEditor errors |   ontology := HumOntology new.      "Initialize the View Frame for this test."   frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.   "Add markup lines."   frameEditor addMarkUp: '!! Recipe'.   errors := frameEditor compileToOntology: ontology.   self assert: ( errors isEmpty  ).   "Create HumView as interface between Ontology and Seaside"   humView := HumView new.   humView      ontology: ontology;      view: 'recipe';      blackboard: (HumBlackBoard new).         "Generate Seaside code for the view frame."         self assert: [ :html | humView asWidget renderOn: html ] matches: '*&lt;form *id="recipe"*&gt;*&lt;/form&gt;*'.      </pre><h3>Hum-Tests -- HumSeasideWidgetTests &gt;&gt; test130ViewHasMarkupLines</h3><pre>test130ViewHasMarkupLines   "A Hum view frame is rendered as a Seaside Form ...   Expect multiple lines within the form   "   | ontology    humView frameEditor errors |   ontology := HumOntology new.      "Initialize the View Frame for this test."   frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.   "Add markup lines."   frameEditor addMarkUp: '!! Recipe'.   "   frameEditor addMarkUp: ' recipe-name: [name]'.   frameEditor addMarkUp: '   description: [description]'.   frameEditor addMarkUp: '   ingredients: [ingredients]'.   frameEditor addMarkUp: '         steps: [steps]'.   "   ontology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).   errors := frameEditor compileToOntology: ontology.   self assert: ( errors isEmpty  ).   "Create HumView as interface between Ontology and Seaside"   humView := HumView new.   humView      ontology: ontology;      view: 'recipe';      blackboard: (HumBlackBoard new).         "Generate Seaside code for the view frame."      "Expect break within the form."   self assert: [ :html | humView asWidget renderOn: html ] matches: '*&lt;form*&lt;br/&gt;*&lt;/form&gt;*'.         </pre><h3>Hum-Tests -- HumSeasideWidgetTests &gt;&gt; test132ViewHasHeadingLine</h3><pre>test132ViewHasHeadingLine   "A Hum view frame is rendered as a Seaside Form ...   Render Hum Heading Markup as HTML heading.   "   | ontology frameEditor errors  humView |   ontology := HumOntology new.      "Initialize the View Frame for this test."   frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.   "Add markup lines."   frameEditor addMarkUp: '!! Recipe'.   errors := frameEditor compileToOntology: ontology.   self assert: ( errors isEmpty  ).   "Create HumView as interface between Ontology and Seaside"   humView := HumView new.   humView      ontology: ontology;      view: 'recipe';      blackboard: (HumBlackBoard new).         "Generate Seaside code for the view frame."      "Expect heading within the form."   self assert: [ :html | humView asWidget renderOn: html ] matches: '*&lt;h2&gt;*&lt;/h2&gt;*'.   self assert: [ :html | humView asWidget renderOn: html ] matches: '*&lt;form*&lt;br/&gt;*&lt;h2&gt;*&lt;/h2&gt;*&lt;/form&gt;*'.         </pre><h3>Hum-Tests -- HumSeasideWidgetTests &gt;&gt; test134ViewHasStringWidget</h3><pre>test134ViewHasStringWidget   "A Hum view frame is rendered as a Seaside Form ...   Render '[attribute name]' ...   "   | ontology frameEditor errors  humView |   ontology := HumOntology new.      "Initialize the View Frame for this test."   frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.   "Add markup lines."   "frameEditor addMarkUp: '!! Recipe'."   frameEditor addMarkUp: ' recipe-name: [name]'.   "   frameEditor addMarkUp: '   description: [description 5]'.   frameEditor addMarkUp: '   ingredients: [ingredients]'.   frameEditor addMarkUp: '         steps: [steps]'.   "   ontology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).   errors := frameEditor compileToOntology: ontology.   self assert: ( errors isEmpty  ).   "Create HumView as interface between Ontology and Seaside"   humView := HumView new.   humView      ontology: ontology;      view: 'recipe';      blackboard: (HumBlackBoard new).   humView blackboard businessEvent: 'test134ViewHasStringWidget'.   "Generate Seaside code for the view frame."      "Expect input within the form."   self assert: [ :html | humView asWidget renderOn: html ] matches: '*&lt;input*'.         </pre><h3>Hum-Tests -- HumSeasideWidgetTests &gt;&gt; test135ViewUptoWidget</h3><pre>test135ViewUptoWidget   "A Hum view frame is rendered as a Seaside Form ...   Render '[attribute name]' ...   "   | ontology frameEditor errors  humView |   ontology := HumOntology new.      "Initialize the View Frame for this test."   frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.   "Add markup lines."   "frameEditor addMarkUp: '!! Recipe'."   frameEditor addMarkUp: ' recipe-name: [name]'.   "   frameEditor addMarkUp: '   description: [description 5]'.   frameEditor addMarkUp: '   ingredients: [ingredients]'.   frameEditor addMarkUp: '         steps: [steps]'.   "   ontology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).   errors := frameEditor compileToOntology: ontology.   self assert: ( errors isEmpty  ).   "Create HumView as interface between Ontology and Seaside"   humView := HumView new.   humView      ontology: ontology;      view: 'recipe';      blackboard: (HumBlackBoard new).   humView blackboard businessEvent: 'test135'.      "Generate Seaside code for the view frame."      "Expect input within the form."   self assert: [ :html | humView asWidget renderOn: html ] matches: '*recipe-name*&lt;input*'.         </pre><h3>Hum-Tests -- HumSeasideWidgetTests &gt;&gt; test136ViewHasTextWidget</h3><pre>test136ViewHasTextWidget   "A Hum view frame is rendered as a Seaside Form ...   Render '[attribute name]' ...   "   | ontology frameEditor errors  humView |   ontology := HumOntology new.      "Initialize the View Frame for this test."   frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'recipe'.   "Add markup lines."   "frameEditor addMarkUp: '!! Recipe'.   frameEditor addMarkUp: ' recipe-name: [name]'.   "   frameEditor addMarkUp: '   description: [description 5]'.   "   frameEditor addMarkUp: '   ingredients: [ingredients]'.   frameEditor addMarkUp: '         steps: [steps]'.   "   ontology addNouns: #( 'recipe' 'name' 'description' 'ingredients' 'steps' ).   errors := frameEditor compileToOntology: ontology.   self assert: ( errors isEmpty  ).   "Create HumView as interface between Ontology and Seaside"   humView := HumView new.   humView      ontology: ontology;      view: 'recipe';      blackboard: (HumBlackBoard new).   humView blackboard businessEvent: 'test136'.      "Generate Seaside code for the view frame."      "Expect test area within the form."   self assert: [ :html | humView asWidget renderOn: html ] matches: '*&lt;textarea*'.   self assert: [ :html | humView asWidget renderOn: html ] matches: '*rows="5"*'.         </pre><h3>Hum-Tests -- HumSeasideWidgetTests &gt;&gt; test138ViewHasDateWidget</h3><pre>test138ViewHasDateWidget   "A Hum view frame is rendered as a Seaside Form ...   Render '[attribute name]' ...   "   | ontology frameEditor errors  humView |   ontology := HumOntology new.      "Initialize the View Frame for this test."   frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'reservation'.   "Add markup lines."   frameEditor addMarkUp: '   arrival date: [arrival-date]'.   ontology addNoun: 'arrival-date' isA: 'date'.   errors := frameEditor compileToOntology: ontology.   self assert: ( errors isEmpty  ).   "Create HumView as interface between Ontology and Seaside"   humView := HumView new.   humView      ontology: ontology;      view: 'reservation';      blackboard: (HumBlackBoard new).   humView blackboard businessEvent: 'test138'.      "Generate Seaside code for the view frame."      "Expect date input within the form."   self assert: [ :html | humView asWidget renderOn: html ] matches: '*&lt;input*type="date"*'.         </pre><h3>Hum-Tests -- HumSeasideWidgetTests &gt;&gt; test139ViewHasCategoryWidget</h3><pre>test139ViewHasCategoryWidget   "A Hum view frame is rendered as a Seaside Form ...   Render '[category-name]' ...   "   | ontology frameEditor errors  humView |   ontology := HumOntology new.      "Initialize the View Frame for this test."   frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'reservation'.   "Add markup lines."   frameEditor addMarkUp: '   class of room: [room-class]'.   ontology categoriesOf: 'room-class' include: #( 'King' 'Double Queen' 'Suite' ) .   errors := frameEditor compileToOntology: ontology.   self assert: ( errors isEmpty  ).   "Create HumView as interface between Ontology and Seaside"   humView := HumView new.   humView      ontology: ontology;      view: 'reservation';      blackboard: (HumBlackBoard new).   humView blackboard businessEvent: 'test139'.      "Generate Seaside code for the view frame."      "Expect date input within the form."   self assert: [ :html | humView asWidget renderOn: html ] matches: '*&lt;select*&lt;option*Suite*'.         </pre><h3>Hum-Tests -- HumSeasideWidgetTests &gt;&gt; test140ViewHasMeasureWidget</h3><pre>test140ViewHasMeasureWidget   "A Hum view frame is rendered as a Seaside Form ...   Render '[category-name]' ...   "   | ontology frameEditor errors  humView |   ontology := HumOntology new.      "Initialize the View Frame for this test."   frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'reservation'.   "Add markup lines."   frameEditor addMarkUp: '   number of adults: [adult-count]'.   ontology addNoun: 'adult-count' isA: 'Measure'.   errors := frameEditor compileToOntology: ontology.   self assert: ( errors isEmpty  ).   "Create HumView as interface between Ontology and Seaside"   humView := HumView new.   humView      ontology: ontology;      view: 'reservation';      blackboard: (HumBlackBoard new).   humView blackboard businessEvent: 'test140'.      "Generate Seaside code for the view frame."      "Expect date input within the form."   self assert: [ :html | humView asWidget renderOn: html ] matches: '*&lt;input*type="number"*'.         </pre><h3>Hum-Tests -- HumSeasideWidgetTests &gt;&gt; test150ViewLineHasSeveralWidgets</h3><pre>test150ViewLineHasSeveralWidgets   "A Hum view frame is rendered as a Seaside Form ...   Render '[category-name]' ...   "   | ontology frameEditor errors  humView |   ontology := HumOntology new.      "Initialize the View Frame for this test."   frameEditor := HumFrameUpdater ontology: ontology viewEntity: 'who'.   "Add markup lines."   frameEditor addMarkUp: '   prefix: [prefix] first: [first-name] middle: [middle-name] last: [last-name] suffix: [suffix]'.   ontology addNouns: #( 'prefix' 'first-name' 'middle-name' 'last-name' 'suffix' ).   errors := frameEditor compileToOntology: ontology.   self assert: ( errors isEmpty  ).   "Create HumView as interface between Ontology and Seaside"   humView := HumView new.   humView      ontology: ontology;      view: 'who';      blackboard: (HumBlackBoard new).   humView blackboard businessEvent: 'test150'.      "Generate Seaside code for the view frame."      "Expect date input within the form."   self assert: [ :html | humView asWidget renderOn: html ] matches: '*prefix:*id="prefix"*'.   self assert: [ :html | humView asWidget renderOn: html ] matches: '*suffix:*id="suffix"*'.         </pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; aDesignNoteEventQueue</h3><pre>aDesignNoteEventQueue   "The Simulator provides the means for 'regression testing'.   Hum dialogs / protocols may be exercised by sending a series of messages to one or more Dialog Agents.   Hum plans are initiated via such dialogs.   Evidence of successful execution may be found via the Bookkeeper.   The Simulator simulates steps a simulated clock.   Simulations 'load' the system under test by sending dialog sequences    . at random intervals as seen by the simulated clock.   The simulator emulates a human response rate    . of approximating 1 keystroke (or button press) per second of simulated clock time.   . Since Hum is not currently intended for embedded systems,    . . faster sensor rates are not needed at this time.   The simulated clock runs at some convenient multiple of real-time. 
  . This multiple is a configuration option.    . 'Convenience' may be a combination of    . . what the run-time can produce, and    . . what the user wishes to monitor.   "   "Design Analysis:   Typically, one of two mechanisms are used to simulate clock-time:   a. The simulation loads 'events' into a time-sorted queue and sends the events asynchronously.   . . . Agent/Actors respond to events by adding events of their own to the queue.   b. The simulation 'steps' a simulated clock    . . . and sends 'step' messages with a simulated clock timestamp to all actors simultaneously.   . . . Actor/Agents respond make some 'move' when each 'step' message arrives.   . . . The 'move' may be 'do nothing' if the agent is simulating an idle state, wait time, or task duration.   "   "When events are sparse, or the actual system response time is highly variable, method 'a' is preferred.   However, a human monitor may perceive the simulation as 'jerky'.    But where simulation results are primarily examined after the 'run', the 'jerks' are not irrelevant.   Method 'a' can also be used when agents are scripted to perform certain actions at certain times of day.   The dialog stimulus may be a time-of-day notice in that case.    "   "Method 'b' is typically more convenient for animations where the concept of frame-rate applies.   Note that method 'a' can also be applied to real-time animation      by sending a 'frame' event triggered by the real-time clock.   A recorded animation where the rendering work-flow time is relatively long, can also be driven by method 'a'.   "   "On the whole, method 'a' appears to be more flexible. So that is what we will implement.   Consequence: This requires that the timestamps in the Messenger may be over-ridden by simulated timestamps.   "</pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; setUpBasicConfigurationOn:</h3><pre>setUpBasicConfigurationOn: aHumSimulator    | configuration actors dispatcher messenger bookkeeper worldBase setup  |   configuration := aHumSimulator.   messenger := (HumMessenger uri: 'messengerURI').   messenger clock: aHumSimulator.   configuration messenger: messenger.   configuration messengerID: 'messengerID' dispatcherID: 'dispatcherID' bookkeeperID: 'bookkeeperID' worldbaseID: 'worldbaseID'.    dispatcher := HumActor dispatcherID: 'dispatcherID' uri: 'dispatcherURI' configuration: configuration.   bookkeeper := HumActor bookkeeperID: 'bookkeeperID' uri: 'bookkeeperURI' configuration: configuration.   worldBase := HumWorldBase openWorldBase: 'worldbase for HumSimulatorTests'.   worldBase id: 'worldbaseID'; uri: 'worldbaseURI'; configuration: configuration; clock: aHumSimulator.   actors := { dispatcher. bookkeeper. worldBase. }.   actors do: [ :actor | actor checkIn. ].   setup := Dictionary new.   setup      at: 'worldbase' put: worldBase;      at: 'bookkeeper' put: bookkeeper;      at: 'dispatcher' put: dispatcher;      at: 'messenger' put: messenger.   ^setup. "Return dictionary of actors to simplify test and debug."      </pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; setUpDogAndPonyConfigurationOn:</h3><pre>setUpDogAndPonyConfigurationOn: aHumSimulator    | configuration actors dispatcher messenger bookkeeper worldBase dog pony band myActors |   "Attach the configuration to the Simulator. "   configuration := aHumSimulator.   "Instantiate the infrastructure agents."   messenger := (HumMessenger uri: 'messengerURI').   messenger clock: aHumSimulator.  "Use the simulated clock in place of the system clock."   configuration messenger: messenger.   configuration messengerID: 'messengerID' dispatcherID: 'dispatcherID' bookkeeperID: 'bookkeeperID' worldbaseID: 'worldbaseID'.    dispatcher := HumActor dispatcherID: 'dispatcherID' uri: 'dispatcherURI' configuration: configuration.   bookkeeper := HumActor bookkeeperID: 'bookkeeperID' uri: 'bookkeeperURI' configuration: configuration.   worldBase := HumWorldBase openWorldBase: 'HumRunTimeTests:setUpDogAndPonyConfigurationOn'.   worldBase       id: 'worldbaseID';       uri: 'worldbaseURI';      configuration: configuration;      clock: aHumSimulator.   "Instantiate the worker agents."   dog  := HumActor workerID: 'dogID' uri: 'dogURI' roles: #('dog') configuration: configuration.   pony := HumActor workerID: 'ponyID' uri: 'ponyURI' roles: #('pony') configuration: configuration.   band := HumActor workerID: 'bandID' uri: 'bandURI' roles: #('band') configuration: configuration.      actors := { dispatcher. bookkeeper. worldBase. dog. pony. band. }.   actors do: [ :actor | actor checkIn. ].      "Return a dictionary of actors for test convenience."   myActors := Dictionary new.   myActors      at: 'bookkeeper' put: bookkeeper;      at: 'dog' put: dog;      at: 'pony' put: pony;      at: 'band' put: band.   ^myActors.   </pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; setUpDogAndPonyOntology</h3><pre>setUpDogAndPonyOntology   "When this ontology runs,    the vignette triggers the goal, and    the plan should guides the sequence."   | testOntology frame4Plan planFrame2 planFrame3 actionFrame1 actionFrame2 actionFrame3 vignette1 |   testOntology := HumOntology new.   ""   vignette1 := HumFrame4Vignette ontology: testOntology vignetteContext: 'Start.' pattern: 'Hello *.'.   vignette1 addVignettePattern: '* Hi*.'.   vignette1 addVignettePattern: '* Eh? *.'.      vignette1 addVignetteResponse: 'For your entertainment! Doggy Dog and Prancing Pony!'.    vignette1 addVignetteInstruction: 'Goal: Run dog and pony show.'.   testOntology addVignette: vignette1 toContext: (vignette1 vignetteContext).    "Root of plan"   frame4Plan := HumFrame4Plan ontology: testOntology goal: 'Run dog and pony show.'.   frame4Plan appendPrecondition: 'Dog is on pony`s back.'.   frame4Plan appendPrecondition: 'Pony is running in circle.'.   frame4Plan appendRole: 'Band' action: 'Play show music.'.   ""   planFrame2 := HumFrame4Plan ontology: testOntology goal: 'Dog is on pony`s back.'.   planFrame2 appendPrecondition: 'Pony is running in circle.'.   planFrame2 appendRole: 'Dog' action: 'Jump on pony`s back.'.   ""   planFrame3 := HumFrame4Plan ontology: testOntology goal: 'Pony is running in circle.'.   "planFrame3 addPrecondition: 'Pony is in the ring.' annotation: 'assumed'."   planFrame3 appendRole: 'Pony' action: 'Run in circle.'.   ""   actionFrame1 := HumFrame4Action ontology: testOntology role: 'Band' action: 'Play show music.'.   actionFrame1         appendInstructionStatement: 'For each note in music:';         appendInstructionStatement: '   Read note.';          appendInstructionStatement: '   Play note.'.   ""   actionFrame2 := HumFrame4Action ontology: testOntology role: 'Dog' action: 'Jump on pony`s back.'.   actionFrame2          appendInstructionStatement: 'Bark twice. (to warn the pony)';         appendInstructionStatement: 'Jump and balance on pony`s back.'.   ""   actionFrame3 := HumFrame4Action ontology: testOntology role: 'Pony' action: 'Run in circle.'.   actionFrame3         appendInstructionStatement: 'Enter ring.';         appendInstructionStatement: 'Run in circles until dog jumps off.'.   { frame4Plan. planFrame2. planFrame3. actionFrame1. actionFrame2. actionFrame3.}          do: [:frame | frame compileToOntology: testOntology.].   testOntology compileAllFrames.   "testOntology inspect.   self halt."   ^testOntology.         </pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; setUpHotelOntology</h3><pre>setUpHotelOntology   | testOntology vignette1 vignette2 vignette3 view1 |   "Provide a set of vignettes."   testOntology := HumOntology baseOntology.   vignette1 := HumFrame4Vignette ontology: testOntology vignetteContext: 'Start.' pattern: 'Hello *.'.   vignette1 addVignettePattern: '* Hi *.'.   vignette1 addVignetteResponse: 'Welcome to the Hotel California.'.    testOntology addVignette: vignette1 toContext: (vignette1 vignetteContext).    vignette2 := HumFrame4Vignette ontology: testOntology vignetteContext: 'Start.' pattern: '* reservation *.'.   vignette2 addVignettePattern: '* check in *.'.   vignette2 addVignetteResponse: 'Everyone has a reservation here. Please check-in.'.   vignette2 addVignetteInstruction: 'Ask Guest.' .    testOntology addVignette: vignette2 toContext: (vignette2 vignetteContext).    vignette3 := HumFrame4Vignette ontology: testOntology vignetteContext: 'Start.' pattern: '* check-out *.'.   vignette3 addVignettePattern: '* check out *.'.   vignette3 addVignettePattern: '* check-out *.'.   vignette3 addVignettePattern: '* checkout *.'.   vignette3 addVignetteResponse: 'You can check-out anytime. But you can never leave.'.   testOntology addVignette: vignette3 toContext: (vignette3 vignetteContext).       view1 := HumFrame4View ontology: testOntology viewEntity: 'Guest'.   view1 addMarkUp: '! Guest Registry'.   view1 addMarkUp: ' name: [name]'.   testOntology addViewFrame: view1.      testOntology addNoun: 'guest' isA: 'person'.      ^testOntology.   </pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; setUpKnockKnockOnOntology:</h3><pre>setUpKnockKnockOnOntology: anOntology   | viewFrame dictionaryFrame |   "Provide a view frame."   viewFrame := HumFrame4View ontology: anOntology viewEntity: 'Knock'.   viewFrame addMarkUp: '!!Knock, knock, who`s there?'.   viewFrame addMarkUp: '  Please enter first name: [first-name]'.   "Provide a dictionary frame."   dictionaryFrame := HumFrame4Dictionary ontology: anOntology title: 'Knock attributes'.   dictionaryFrame addDictionaryLine: 'Knock attributes include first-name.'.      dictionaryFrame compileToOntology: anOntology .   viewFrame       compileToOntology: anOntology.</pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; testX100SimulatorReadMe</h3><pre>testX100SimulatorReadMe   "The Simulator provides the means for 'regression testing'.   Hum dialogs / protocols may be exercised by sending a series of messages to one or more Dialog Agents.   Hum plans are initiated via such dialogs.   Evidence of execution may be found via the Bookkeeper, Messenger logs, and Agent logs.   "   "Simulations 'load' the system under test by starting dialog sequences    . at random intervals as seen by the simulated clock.   ==&gt; We need a way to represent dialog sequences.   ==&gt; We need a way to represent random intervals.   ==&gt; We need a way to identify the number of dialogs to be run simultaneously.   ==&gt; Ideally, we will run the dialogs in independent threads.   "   "The simulator (Scribe?) emulates a human response rate    . of approximating 1 keystroke (or button press) per second of simulated clock time.   . It is not necessary to simulate the sensor, just the time between vignette inputs.   "   "A simulation loads 'events' into a time-sorted queue and sends the events asynchronously.   . Agent/Actors respond to events by adding events of their own to the queue.    . The timestamp on each event indicates its order,    . . but does not determine the real-time duration of the simulation.   . There is no need to create real-time wait-times during the simulation.   "   self skip.   </pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; testX101RepresentDialogSequence</h3><pre>testX101RepresentDialogSequence   "Simulations 'load' the system under test by starting dialog sequences    . at random intervals as seen by the simulated clock.   ==&gt; We need a way to represent dialog sequences."   | simulator |   simulator := HumSimulator ontology: (HumOntology new).   "Represent a dialog sequence as an sequencable collection or array."   simulator dialogSequence: #( 'Hello.' 'Goodbye.').   </pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; testX102RepresentRandomIntervals</h3><pre>testX102RepresentRandomIntervals   "Simulations 'load' the system under test by starting dialog sequences    . at random intervals as seen by the simulated clock.   ==&gt; We need a way to represent random intervals.   "   | simulator distribution |   "Express the distribution as an S-curve in seconds."   distribution := Dictionary new.   distribution      at: 0.0 put: 100.0;      at: 50.0 put: 1000.0;      at: 100.0 put: 8000.0.   simulator := HumSimulator new.   simulator randomStartingIntervals: distribution.   "TODO: This random execution concept has not been implemented yet."</pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; testX103RepresentNumberOfDialogs</h3><pre>testX103RepresentNumberOfDialogs   "Simulations 'load' the system under test by starting dialog sequences    . at random intervals as seen by the simulated clock.   ==&gt; We need a way to identify the number of dialogs to be run simultaneously.   "   | simulator |   simulator := HumSimulator new.   simulator numberOfDialogs: 3.   "TODO: This parallel execution concept has not been implemented yet."</pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; testX110AddEventToQueue</h3><pre>testX110AddEventToQueue   "A simulation loads client speech-acts into a queue with a specified delay.   . Each speech-act is sent to the dialog-agent that is attached to the simulator.    . The timestamp on each event indicates its order,    . . but does not determine the real-time duration of the simulation.   . The speech-act is sent when the simulation clock reaches the time indicated by the given delay.   "   | simulator anActor statement |   simulator := HumSimulator new.   "Speech acts are interpreted by dialog vignettes in an ontology."   simulator ontology: (self setUpHotelOntology).   simulator after: (30 seconds) sendSpeech: 'Hello.' from: 'client A'.   self assert: ( simulator queue size = 1 ).   self assert: ( ( simulator queue at: 1 ) isKindOf: Array).   self expect: { Duration seconds: 30.  #speech. 'client A'. 'Hello.'.} actual: ( simulator queue at: 1 ).   </pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; testX112AddTwoEventsToQueue</h3><pre>testX112AddTwoEventsToQueue   "A simulation loads client speech-acts into a queue with a specified delay.   . Each speech-act is sent to the dialog-agent that is attached to the simulator.    . The timestamp on each event indicates its order,    . . but does not determine the real-time duration of the simulation.   . The speech-act is sent when the simulation clock reaches the time indicated by the given delay.   "   | simulator anActor statement |   simulator := HumSimulator new.   "Speech acts are interpreted by dialog vignettes in an ontology."   simulator ontology: (self setUpHotelOntology).   simulator after: (10 seconds) sendSpeech: 'Hello there.' from: 'client A'.   simulator after: (20 seconds) sendSpeech: 'Hi there.' from: 'client B'.   self assert: ( simulator queue size = 2 ).   self expect: { Duration seconds: 10.  #speech. 'client A'. 'Hello there.'.} actual: ( simulator queue at: 1 ).   self expect: { Duration seconds: 20.  #speech. 'client B'. 'Hi there.'.} actual: ( simulator queue at: 2 ).   </pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; testX120Step</h3><pre>testX120Step   "A simulation loads client speech-acts into a queue with a specified delay.   . Each speech-act is sent to the dialog-agent that is attached to the simulator.    . The timestamp on each event indicates its order,    . . but does not determine the real-time duration of the simulation.   . The speech-act is sent when the simulation clock reaches the time indicated by the given delay.   "   | simulator ontology  dialogAgent stepLog |   "set up"   ontology := self setUpHotelOntology.   simulator := HumSimulator new.   simulator ontology: (ontology).   self setUpBasicConfigurationOn: simulator.      "Speech acts are interpreted by dialog vignettes in an ontology."   simulator after: (30 seconds) sendSpeech: 'Hello.' from: 'client A'.   self assert: ( simulator queue size = 1 ).   self assert: ( ( simulator queue at: 1 ) isKindOf: Array).   self expect: { Duration seconds: 30.  #speech. 'client A'. 'Hello.'.} actual: ( simulator queue at: 1 ).   simulator step.   self assert: ( simulator queue size = 0 ).      "Examine log for expected event and values."   dialogAgent := simulator getDialogAgentNamed: 'client A'.    stepLog := dialogAgent stepLog.   self expect: 2 actual: stepLog size.   self expect: #('client A: Hello.' 'S: Welcome to the Hotel California.') actual: stepLog asArray.   </pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; testX122StepStep</h3><pre>testX122StepStep   "A simulation loads client speech-acts into a queue with a specified delay.   . Each speech-act is sent to the dialog-agent that is attached to the simulator.    . The timestamp on each event indicates its order,    . . but does not determine the real-time duration of the simulation.   . The speech-act is sent when the simulation clock reaches the time indicated by the given delay.   "   | simulator ontology dialogAgent stepLog scribe scribeLog |   "set up"   ontology := self setUpHotelOntology.   simulator := HumSimulator new.   simulator ontology: (ontology).   self setUpBasicConfigurationOn: simulator.   "Speech acts are interpreted by dialog vignettes in an ontology."   simulator after: (10 seconds) sendSpeech: 'Hello there.' from: 'client A'.   simulator after: (20 seconds) sendSpeech: 'I would like to check in.' from: 'client A'.   self assert: ( simulator queue size = 2 ).   self expect: { Duration seconds: 10.  #speech. 'client A'. 'Hello there.'.} actual: ( simulator queue at: 1 ).   self expect: { Duration seconds: 20.  #speech. 'client A'. 'I would like to check in.'.} actual: ( simulator queue at: 2 ).   simulator step.   self assert: ( simulator queue size = 1 ).   self expect: { Duration seconds: 20.  #speech. 'client A'. 'I would like to check in.'.} actual: ( simulator queue at: 1 ).   simulator step.   self assert: ( simulator queue size = 0 ).   "Examine logs for expected event and values."   dialogAgent := simulator getDialogAgentNamed: 'client A'. 
  scribe := dialogAgent scribeProxy.   scribeLog := scribe log.   self assert: ( '*&lt;input type="text" name="Guest:name" value=""/&gt;*' match: (scribeLog at: 1)).   stepLog := dialogAgent stepLog.   self expect: #(      'client A: Hello there.'       'S: Welcome to the Hotel California.'       'client A: I would like to check in.'       'S: Everyone has a reservation here. Please check-in.'       'DialogAgent: {client A} is doing: {Ask Guest.}'      )       actual: stepLog asArray.</pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; testX124StepUntilDone</h3><pre>testX124StepUntilDone   "A simulation loads client speech-acts into a queue with a specified delay.   . Each speech-act is sent to the dialog-agent that is attached to the simulator.    . The timestamp on each event indicates its order,    . . but does not determine the real-time duration of the simulation.   . The speech-act is sent when the simulation clock reaches the time indicated by the given delay.   "   | simulator ontology dialogAgent stepLog |   "Given: set up"   ontology := self setUpHotelOntology.   simulator := HumSimulator new.   simulator ontology: (ontology).   self setUpBasicConfigurationOn: simulator.   "Speech acts are interpreted by dialog vignettes in an ontology."   simulator after: (10 seconds) sendSpeech: 'Hello there.' from: 'client A'.   simulator after: (20 seconds) sendSpeech: 'I would like to check in.' from: 'client A'.   simulator after: (30 seconds) sendSpeech: 'When is check-out?' from: 'client A'.   simulator stepUntilDone.   self assert: ( simulator queue size = 0 ).   "simulator log4Dialog inspect."   "Examine logs for expected event and values."   dialogAgent := simulator getDialogAgentNamed: 'client A'.    stepLog := dialogAgent stepLog.   self expect: #(      'client A: Hello there.'       'S: Welcome to the Hotel California.'       'client A: I would like to check in.'       'S: Everyone has a reservation here. Please check-in.'       'DialogAgent: {client A} is doing: {Ask Guest.}'        'client A: When is check-out?'       'S: You can check-out anytime. But you can never leave.'      )       actual: stepLog asArray.</pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; testX130DialogUsesScribe</h3><pre>testX130DialogUsesScribe   "There should be a Scribe in the chain.   A Dialog Agent does not connect directly to a UI framework.   A Dialog Agent uses a Scribe as an intermediary.   Simulator ==&gt; Dialog Agent ==&gt; Scribe.   Q: Where/When/How is the connection between Dialog Agent and Scribe instantiated ?   "   | simulator ontology dialogAgent stepLog scribe stepLog2 |   "setup"   ontology := self setUpHotelOntology.   simulator := HumSimulator new.   simulator ontology: (ontology).   self setUpBasicConfigurationOn: simulator.   "Speech acts are interpreted by dialog vignettes in an ontology."   simulator after: (30 seconds) sendSpeech: 'Hello.' from: 'client A'.   self assert: ( simulator queue size = 1 ).   self assert: ( ( simulator queue at: 1 ) isKindOf: Array).   self expect: { Duration seconds: 30.  #speech. 'client A'. 'Hello.'.} actual: ( simulator queue at: 1 ).   simulator step.   self assert: ( simulator queue size = 0 ).      "Examine log for expected event and values."   dialogAgent := simulator getDialogAgentNamed: 'client A'.    stepLog := dialogAgent stepLog.   self expect: #('client A: Hello.' 'S: Welcome to the Hotel California.') actual: stepLog asArray.      "Verify that a Scribe is involved."   scribe := dialogAgent scribeProxy.   stepLog2 := scribe stepLog.   self expect: #('System: Welcome to the Hotel California.') actual: stepLog2 asArray.   </pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; testX140VignetteTriggersGoal</h3><pre>testX140VignetteTriggersGoal   "A vignette may trigger a goal."   | ontology simulator messenger playback |   "setup"   ontology := self setUpDogAndPonyOntology.   simulator := HumSimulator new.   simulator ontology: (ontology).   self setUpDogAndPonyConfigurationOn: simulator.   "Speech acts are interpreted by dialog vignettes in an ontology."   simulator after: (10 seconds) sendSpeech: 'Eh?.' from: 'client A'.   simulator step.   simulator stepUntilDone.   ( 1 to: 3 ) do: [:i | (Delay forMilliseconds: 1) wait.].  "Give forked processes some time to run."   "Verify that expected messages were sent."   messenger := simulator messenger.   playback := messenger playbackLog.   self assert: (playback size &gt; 0).   "Expect logs for coordinator dispatcher bookkeeper worldbase dog pony band."   self expect: 7 actual: (playback size)         description: 'Expect logs for dispatcher bookkeeper worldbase coordinator dog pony band'.    self expect: 9 actual: ( messenger playbackLogToURI: 'dispatcherURI' ) size         description: 'Expect 6 check-ins and 3 assignments.'.   self expect: 1 actual: ( messenger playbackLogToURI: 'dogURI' ) size   description: 'dispatcher assigns to dog'.   self expect: 1 actual: ( messenger playbackLogToURI: 'ponyURI' ) size  description: 'dispatcher assigns to pony'.   self expect: 1 actual: ( messenger playbackLogToURI: 'bandURI' ) size  description: 'dispatcher assigns to band'.   </pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; testX142RunClubMech</h3><pre>testX142RunClubMech   "A vignette may trigger a goal."   | ontology simulator messenger playback fileName pa dialogAgent stepLog scribe request worldbase request2 blackboard setup |   "set up"   fileName := 'ClubMechV02.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   ontology := pa ontology.   ontology compileAllFrames.   simulator := HumSimulator new.   simulator ontology: (ontology).   setup := self setUpBasicConfigurationOn: simulator.   messenger := simulator messenger.   worldbase := messenger getActorInstanceFromID: (simulator worldbaseID).   worldbase clock: (simulator).   self assert: ( worldbase isKindOf: HumWorldBase ).   self expect: ( setup at: 'worldbase') actual: worldbase.      "Speech acts are interpreted by dialog vignettes in an ontology."   simulator after: ( 1 second ) sendSpeech: 'My name is Testy Tester.' from: 'client A'.   simulator after: (10 seconds) sendSpeech: 'Enter a topic.' from: 'client A'.   simulator step.   simulator stepUntilDone.      "Verify that expected messages were sent."   playback := messenger playbackLog.   self expect: 3 actual: (playback size) description: 'Check-in client-A bookkeeper worldbase ???'.   dialogAgent := simulator getDialogAgentNamed: 'client A'.    blackboard := dialogAgent blackboard.   self expect: 'Testy Tester' actual: (blackboard getEntityName: 'user' attribute: 'name').   stepLog := dialogAgent stepLog.   self expect: 8 actual: (stepLog size) description: '???'.   self expect: #(   'client A: My name is Testy Tester.'    'S:  Hello Testy Tester.'    'S:    Please select an activity.'    'DialogAgent: {client A} is doing: {Push context "Select an activity.".}'    'client A: Enter a topic.'    'S:  Please enter a description of the talk you are offering.'    'DialogAgent: {client A} is doing: {New topic.}'    'DialogAgent: {client A} is doing: {Ask topic.}'   )            actual: stepLog asArray.   "WHEN: Client enters data (speaker, title, description) and presses [Go!] button ... "   "THEN: WorldBase should have a topic entity with attribute values for speaker, title, description. "   scribe := dialogAgent scribeProxy.   request := HumHttpRequest new.   request       atField: 'topic:speaker' put: 'I.M. Speaker';      atField: 'topic:title' put: 'This is only a test.';      atField: 'topic:description' put: 'This is line one.',String cr,'This is line two'.   scribe handleHttpPostRequest: request.   "WorldBase should contain user`s name, topic`s speaker, title, description"   self expect: (setup at: 'worldbase') actual: worldbase.   self expect: 4 actual: ( worldbase quads size ).    self expect: 0 actual: ( worldbase history size ).   "Enter a second topic. Result should be a second topic instance, not an updated version of first topic."   simulator after: (20 seconds) sendSpeech: 'Enter another topic.' from: 'client A'.   simulator step.   simulator stepUntilDone.   "At this point, 'Clear topic' instruction should have cleared topic entries from blackboard."   self expect: 3 actual: (blackboard entityIdentifiers size) description:  'Expect identifiers for user, topic, speaker'.   self expect: 4 actual: (blackboard quads size) description: 'Prior topic attributes are still in blackboard, but only accessible by ID'.   request2 := HumHttpRequest new.   request2       atField: 'topic:speaker' put: 'I.M. Speaker Too';      atField: 'topic:title' put: 'This is a second topic.';      atField: 'topic:description' put: 'This is line one of the second topic.',String cr,'This is line two of it.'.   scribe handleHttpPostRequest: request2.      self expect: 0 actual: ( worldbase history size ) description: 'Creating a new topic, so history should be empty'.     self expect: 7 actual: ( worldbase quads size ) description: 'We expect two topic instances and one user instance'.   </pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; testX143RunBarista</h3><pre>testX143RunBarista   "A vignette may trigger a goal."   | ontology simulator messenger playback fileName pa dialogAgent stepLog worker |   "set up"   fileName := 'Barista.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   ontology := pa ontology.   ontology compileAllFrames.   simulator := HumSimulator new.   simulator ontology: (ontology).   self setUpBasicConfigurationOn: simulator.      worker := HumActor workerID: 'Bobbi' uri: 'URI:Bobbi' roles: #('barista' 'server') configuration: simulator.   worker checkIn.      "Speech acts are interpreted by dialog vignettes in an ontology."   simulator after: ( 1 second ) sendSpeech: 'Authenticated 1234567890.' from: 'client A'.
  "2015-01-22: Data is not being passed from order to worker. "   "TODO: Simulate form fill-in."  "2015-01-22: Fails because polymorphism is not implemented."   "TODO: Implement polymorphism."   simulator step.   simulator stepUntilDone.   ( 1 to: 3 ) do: [ :i | (Delay forMilliseconds: 9) wait.].  "Give forked processes some time to run."      "Verify that expected messages were sent."   messenger := simulator messenger.   playback := messenger playbackLog.   self expect: 5 actual: (playback size) description: 'Check-in client-A bookkeeper worldbase Bobbi'.   dialogAgent := simulator getDialogAgentNamed: 'client A'.    stepLog := dialogAgent stepLog.   self assert: ( ('*Sorry*' match: (stepLog at: 2)) not )       description: 'Should not get: "', (stepLog at:2),'" '.   self expect: #(      'client A: Authenticated 1234567890.'       'S:  Welcome *** Unknown ***.'       'S:    Please enter your order.'       'DialogAgent: {client A} is doing: {Ask order.}'      )         actual: stepLog asArray.</pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; testX144RunDonutShop</h3><pre>testX144RunDonutShop   "A vignette may trigger a goal."   | ontology simulator messenger playback fileName pa dialogAgent stepLog |   false ifFalse: [Transcript cr; show: 'testX144RunDonutShop turned off.'. ^self skip].   "set up"   fileName := 'DonutShopV05.txt'.   pa := HumProgrammersAssistant new.   pa loadOntologyFromTextFileNamed: fileName.   ontology := pa ontology.   ontology compileAllFrames.   simulator := HumSimulator new.   simulator ontology: (ontology).   self setUpBasicConfigurationOn: simulator.      "Speech acts are interpreted by dialog vignettes in an ontology."   simulator after: ( 1 second ) sendSpeech: 'Customer presents order.' from: 'client A'.   simulator step.   simulator stepUntilDone.   ( 1 to: 3 ) do: [ :i | (Delay forMilliseconds: 9) wait.].  "Give forked processes some time to run."      "Verify that expected messages were sent."   messenger := simulator messenger.   playback := messenger playbackLog.   self expect: 3 actual: (playback size) description: 'Check-in client-A bookkeeper worldbase ???'.   dialogAgent := simulator getDialogAgentNamed: 'client A'.    stepLog := dialogAgent stepLog.   self assert: ( ('*Sorry*' match: (stepLog at: 2)) not )       description: 'Sorry -- {', (stepLog at:2),'}'.   self expect: #(      )         actual: stepLog asArray.</pre><h3>Hum-Tests -- HumSimulatorTests &gt;&gt; testX150RunParallel</h3><pre>testX150RunParallel   "A vignette may trigger a goal."   | ontology simulator messenger playback myActors myBookkeeper |   ontology := self setUpDogAndPonyOntology.   simulator := HumSimulator new.   "Speech acts are interpreted by dialog vignettes in an ontology."   myActors := self setUpDogAndPonyConfigurationOn: simulator.   simulator ontology: (ontology).   simulator after: (10 seconds) sendSpeech: 'Eh?.' from: 'client A'.   simulator after: (20 seconds) sendSpeech: 'Eh?.' from: 'client B'.   simulator after: (30 seconds) sendSpeech: 'Eh?.' from: 'client C'.      simulator step.   simulator stepUntilDone.   ( 1 to: 7 ) do: [:i | (Delay forMilliseconds: 1) wait.]. "Give forked processes some time to run."   "Verify that expected messages were sent."   messenger := simulator messenger.   playback := messenger playbackLog.   self assert: (playback size &gt; 0) description: 'Messenger play-back-log should not be empty.'.   "Verify that expected messages were sent."   "Expect logs for coordinator dispatcher bookkeeper worldbase dog pony band."   self expect: 9 actual: (playback size)       description: 'Expect logs for dispatcher bookkeeper worldbase dog pony band client-A client-B client-C'.    self expect: 17          actual: ( messenger playbackLogToURI: 'dispatcherURI' ) size      description: 'Expect 8 check-ins and 9 assignments.'.   self expect: 3 actual: ( messenger playbackLogToURI: 'dogURI'  ) size  description: 'dispatcher assigns to dog'.   self expect: 3 actual: ( messenger playbackLogToURI: 'ponyURI' ) size  description: 'dispatcher assigns to pony'.   self expect: 3 actual: ( messenger playbackLogToURI: 'bandURI' ) size  description: 'dispatcher assigns to band'.         myBookkeeper := myActors at: 'bookkeeper'.   self expect: (HumMeasure quantity: 27 units: #step)         actual: (myBookkeeper chargesByRole at: 'Band:step').       </pre><h3>Hum-Tests -- HumTestCase &gt;&gt; assert:sameAs:</h3><pre>assert: stringA sameAs: stringB    self assert: (stringA sameAs: stringB)        description: ( 'Expecting: ', stringA ,' sameAs: ', stringB ).</pre><h3>Hum-Tests -- HumTestCase &gt;&gt; assertPattern:matches:</h3><pre>assertPattern: stringPattern matches: string    self assert: ( stringPattern match: string )       description: ( 'Result should match pattern: {',stringPattern,'}').      </pre><h3>Hum-Tests -- HumTestCase &gt;&gt; ensure</h3><pre>ensure   "I think this belongs under HClientServerTests"   ensureBlock ifNotNil: [ ensureBlock value ].</pre><h3>Hum-Tests -- HumTestCase &gt;&gt; ensureBlock:</h3><pre>ensureBlock: aBlock   "I think this belongs under HClientServerTests"      ensureBlock := aBlock.</pre><h3>Hum-Tests -- HumTestCase &gt;&gt; eventSeen</h3><pre>eventSeen   ^ eventSeen ifNil: [ eventSeen := 'No value was preset.' ]</pre><h3>Hum-Tests -- HumTestCase &gt;&gt; eventSeen:</h3><pre>eventSeen: anObject    "Set my one-shot memory of the last event seen."   eventSeen := anObject.</pre><h3>Hum-Tests -- HumTestCase &gt;&gt; expect:actual:</h3><pre>expect: expectedValue actual: actualValue    (expectedValue isKindOf: Float)      ifTrue: [ ^self assert: (expectedValue closeTo: actualValue)          description: ( 'Expected: ', expectedValue asString,' actual: ', actualValue asString ).          ].   (expectedValue isKindOf: String)      ifTrue: [  | expected actual |         expected := expectedValue trimBoth.         actual := actualValue asString trimBoth.         ^self assert: (( expected compare: actual caseSensitive: true ) = 2)                 description: ( 'Expected: ', expected ,' actual: ', actual  ).         ].   ((expectedValue isKindOf: Array) and: [ (expectedValue size &gt; 0) and: [ (expectedValue at: 1) isKindOf: Association] ])      ifTrue: [ "If expected value is an array of associations, compare as sets"         ^self assert: (expectedValue asSet) = (actualValue asSet)            description: 'Expecting arrays to match as sets'.          ].   ( expectedValue isKindOf: Point )      ifTrue: [  "Relax equality slightly"         ^self assert: ( ( (expectedValue x) closeTo: (actualValue x) ) and: [ ( (expectedValue y) closeTo: (actualValue y) )] )                  description: 'Expecting points to coincide'.         ].   self assert: ( expectedValue = actualValue  )        description: ( 'Expected: ', expectedValue asString,' actual: ', actualValue asString ).</pre><h3>Hum-Tests -- HumTestCase &gt;&gt; expect:actual:description:</h3><pre>expect: expectedValue actual: actualValue description: aDescription    (expectedValue isKindOf: Float)      ifTrue: [ ^self assert: (expectedValue closeTo: actualValue)          description: ( 'Expected: ', expectedValue asString,' close to actual: ', actualValue asString, ' - ', aDescription ).         ].   self assert: (expectedValue = actualValue)        description: ( 'Expected: ', expectedValue asString,' actual: ', actualValue asString, ' - ', aDescription ).   </pre><h3>Hum-Tests -- HumTestCase &gt;&gt; pattern:matches:</h3><pre>pattern: stringPattern matches: string    self assert: ( stringPattern match: string )       description: ( 'Result should match pattern: {',stringPattern,'}').      </pre><h3>Hum-Tests -- HumTestCase &gt;&gt; signal</h3><pre>signal   "I think method this belongs under HClientServerTests"   self ensure.   super signal.</pre><h3>Hum-Tests -- HumTestCase &gt;&gt; update:</h3><pre>update: anObject   "This is called by event handler."   self eventSeen: anObject</pre><h3>Hum-Tests -- HumTextEditorTests &gt;&gt; test110ArrowKeys</h3><pre>test110ArrowKeys   | editor |   editor := HumTextEditor new.      editor keyStroke: Character arrowDown.   self expect: 2@1 actual: editor cursorPosition.         editor keyStroke: Character arrowUp.   self expect: 1@1 actual: editor cursorPosition.      editor keyStroke: Character arrowUp.   self expect: 1@1 actual: editor cursorPosition description: 'Row does not go below one.'.   editor keyStroke: Character arrowRight.   self expect: 1@2 actual: editor cursorPosition.      editor keyStroke: Character arrowLeft.   self expect: 1@1 actual: editor cursorPosition.      editor keyStroke: Character arrowLeft.   self expect: 1@1 actual: editor cursorPosition description: 'Column does not go below one.'.      self assert: ( editor hasNewContent ) = false description: 'Moving cursor does not change content.'.</pre><h3>Hum-Tests -- HumTextEditorTests &gt;&gt; test120NormalKeys</h3><pre>test120NormalKeys   | editor |   editor := HumTextEditor new.      editor keyStroke: Character arrowDown.   self expect: 2@1 actual: editor cursorPosition.      editor keyStroke: $k.   self expect: 'k' actual: (editor lineAt: 2).   self expect: 2@2 actual: editor cursorPosition.   self expect: '' actual: (editor lineAt: 1).      self assert: editor hasNewContent description: 'New content inserted'.       editor keyStroke:  Character arrowLeft.   self expect: 2@1 actual: editor cursorPosition.   editor keyStroke: $O.   self expect: 'Ok' actual: (editor lineAt: 2).   self expect: 2@2 actual: editor cursorPosition.      editor keyStroke: Character arrowRight.   self expect: 2@3 actual: editor cursorPosition.            editor keyStroke: Character arrowRight.   self expect: 2@4 actual: editor cursorPosition description: 'Cursor is not limited by currentLine string length'.      editor keyStroke: $!.   self expect: 'Ok !' actual: (editor lineAt: 2) description: 'Current line may be padded to cursor location on an insert'.   self expect: 2@5 actual: editor cursorPosition.   </pre><h3>Hum-Tests -- HumTextEditorTests &gt;&gt; test130BreakLine</h3><pre>test130BreakLine   | editor |   editor := HumTextEditor new.      editor currentLine: 'Now is the time for all good men'.   editor column: ('Now is the time' size + 1).   editor keyStroke: Character cr.   self expect: 'Now is the time' actual: (editor lineAt: 1).   self expect: ' for all good men' actual: (editor lineAt: 2).   self expect: 2@1 actual: editor cursorPosition.   self assert: editor hasNewContent description: 'Content changed'.   </pre><h3>Hum-Tests -- HumTextEditorTests &gt;&gt; test140DeleteKey</h3><pre>test140DeleteKey   "If cursor column &gt; 1, delete character to the left of cursor and decrement column position."   | editor |   editor := HumTextEditor new.   "Set up"   editor currentLine: 'abc'.   editor bumpRow: 1.   editor currentLine: 'xyz'.   editor column: 2.   self expect: 2@2 actual: editor cursorPosition.      "Delete one character"   editor keyStroke: Character delete.   self expect: 'yz' actual: (editor lineAt: 2).      </pre><h3>Hum-Tests -- HumTextEditorTests &gt;&gt; test150DeleteLine</h3><pre>test150DeleteLine   "If cursor column = 1, append current line to prior line and move remaining lines up."   | editor |   editor := HumTextEditor new.   "Set up three lines"   editor currentLine: 'abc'.   editor bumpRow: 1.   editor currentLine: 'xyz'.   editor bumpRow: 1.   editor currentLine: '123'.   "Move cursor to start of second line."   editor row: 2; column: 1.   self expect: 2@1 actual: editor cursorPosition.      "Delete one character"   editor keyStroke: Character delete.   self expect: 'abcxyz' actual: (editor lineAt: 1) description: 'Expect line 2 appended to line 1.'.   self expect: '123' actual: (editor lineAt: 2) description: 'Expect line 3 moved up to line 2.'.   self expect: 1@4 actual: editor cursorPosition.   self assert: (editor hasNewContent) description: 'Should signal new content.'      </pre><h3>Hum-Tests -- HumTextEditorTests &gt;&gt; test208CharacterizeStringDraw</h3><pre>test208CharacterizeStringDraw   "Tinker until we learn what we need to know about canvas, form, font integration."   |  form canvas font  em lineHeight |    form := Form extent: (700@70) depth: 32.   canvas := BalloonCanvas on: form.    font := TextStyle defaultFont.   em := font linearWidthOf: $m.   lineHeight := font height.   canvas       drawString: 'The quick brown fox jumps over the lazy dog.'       at: em@lineHeight font: font color: (Color black).   canvas       drawString: 'Now is the time for all good men to come to the aid of their country.'       at: em@(lineHeight * 2) font: font color: (Color blue).   "Option to display the form"   "This canvas has no background, so it will be tranparent when displayed."   false ifTrue: [form displayOn: Display at: (100@100).].         </pre><h3>Hum-Tests -- HumTextEditorTests &gt;&gt; test209CharacterizeStringDraw</h3><pre>test209CharacterizeStringDraw   "Tinker until we learn what we need to know about canvas, form, font integration."   |  form canvas font  em lineHeight |    form := Form extent: (700@100) depth: 32.   canvas := BalloonCanvas on: form.    font := TextStyle defaultFont.   em := font linearWidthOf: $m.   lineHeight := font height.   "Paint background and border."   canvas       frameAndFillRectangle: form       boundingBox fillColor: Color white       borderWidth: 2       borderColor: Color blue.   canvas       drawString: 'The quick brown fox jumps over the lazy dog.'       at: em@lineHeight font: font color: (Color black).   canvas       drawString: 'Now is the time for all good men to come to the aid of their country.'       at: em@(lineHeight * 2) font: font color: (Color blue).   "Option to display the form"   false ifTrue: [form displayOn: Display at: (100@100).].         </pre><h3>Hum-Tests -- HumTextEditorTests &gt;&gt; test226DrawSeveralTextLinesOnPane</h3><pre>test226DrawSeveralTextLinesOnPane   "TextEditor draws its lines on a HumPane -- ???"   |    font em lineHeight editor pane |   "TODO: To be internally consistent,    TextEditor should display in a HumPane.   Low level objects such as Form should be hidden.   "   font := TextStyle defaultFont.   em := font linearWidthOf: $m.   lineHeight := font height.   editor := HumTextEditor new.   editor       currentLine: 'Now is the time';      bumpRow: 1;      currentLine: ' for all good men';      bumpRow: 1;      currentLine: ' to come to the aid';      bumpRow: 1;      currentLine: ' of their party.';      bumpRow: 1.   pane := HumPane new.   editor drawTextOnPane: pane font: font.      "Option to display the pane"   false ifTrue: [|morph| morph := pane asMorph. morph openInWorld.].         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; aReadMe</h3><pre>aReadMe   "See the class description for the intended (future) tests."   ^'See the class description for the intended (future) tests.'   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; aReadMe2</h3><pre>aReadMe2"At this time (2-15-08-20), there are two user-interface strategies in progress and sometimes causing cognitive dissonance.One strategy is a rather traditional and simplistic contextwhere the interaction is driven by stimulus-response vignettes in dialog frames.Data comes from user dialog entries or view-frame (form-like) data-slot entries.The user interface is intended to be generic but allows for talking headsand user gestures mediated by a technology-specific Scribe.A second strategy attempts to expand the context to a virtual reality (VR)partially inspired by the Croquet project (see also Cobalt).In this expansion, the I am providing 3D components (but not yet a landscape notation)that can be used to build a 3D landscape - with the initial emphasis to be simple rooms.I have been experimenting with landscape building notations (mostly action statement scripts)in the 'Thinking Out Loud' directory under the 'SimpleEnglish' directory.In the virtual reality (VR) context, the Scribe will also interpret user-avatar movementswithin the landscape. To bring the system up to current user expectations, the dialog vignettes need to be expanded to associate system responses with VR objects - especially scene avatars.Goals:- At this time I do not even want to think about games. They are simply too demanding.The immediate goal for 3D is to learn by experiment what is needed to enable simple (potentially simplistic) programs in Hum that display and navigate simple landscapes (rooms).I am motivated by the rather overwhelming, indirect, and esoteric code that I see in current 3D notations.I believe 'There has to be a simpler way' to do this kind of thing."   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; aReadMe3</h3><pre>aReadMe3^'In Virtual Reality, we need to rethink sensor to display path.Sensor &gt;&gt; headOrientation: aVector position: aVector         "Advise subscribers that head has moved. (Consider: sampling rate)"UserAvatar &gt;&gt; headOrientation: aVector position: aVector      "Reset head`s parameters, change affected solids."UserCamera &gt;&gt; orientation: aVector position: aVector         "Update camera position and orientation."Scene &gt;&gt; changed                                                "Some object in the scene is changed."Scene &gt;&gt; iterateSolids: [ :solid | solid redraw (via OpenGL/WebGL) ]  Solid &gt;&gt; generate triangles, costume/texture                   "Generate triangles, costume/texture from parameters."WebGL/OpenGL &gt;&gt; receive  triangles, costume/texture         "Operate GPU.""*** Learn how GL connects to viewports. ***"','Sensor &gt;&gt; handMoved: yikes      "Hand is complicated - Ultimately, there are 5 fingers - Each finger has 3 segments ==&gt; 15 bones."Scene &gt;&gt; handMoved: yikes      "Update avatar fingers"Scribe &gt;&gt; handMoved: yikes      "Scribe interprets hand gesture (if any) using conventions and Scene collisions (if any)."Dialog &gt;&gt; userSays: (Scribe`s interpretation of hand gesture).(Objects [solids] in Scene may respond to user/avatar and be driven by Dialog and/or ???)','*** CONSIDER: Each active object has its own pseudo-sensors ***.Sensor &gt;&gt; (collision detected) &gt;&gt; object-specific physics (button push, avatar alert, bounce, damage, momentum transfer)object &gt;&gt; announce eventScribe &gt;&gt; interpret event for Dialog.Dialog (any "actor" could have Dialog logic, not just User/Client) &gt;&gt; "Actor see/say/feel/detect"'</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; aReadMe4</h3><pre>aReadMe4^'Test Driven Design       (Decide if the following cascade makes sense.)===============External Input ==&gt; "pointer" "stick" "keyboard" "voice-to-text" "network message" "acceleration" "GPS" - How is the Sensor attached to a Scene or Scene object?  . . Sensors may be attached to the Scene or a HumBox. (configuration: initial conditions or dyanmic). . . Sensors attached to the Scene will typically be interpreted as user gestures.. . . Sensors attached to a HumBox may include virtual sensors such as proximity detectors.. . . Sensors attached to a HumBox may include external sensors such as acceleration, GPS, avatar echoes.. . (TDD will require minor expansion of the HumSimulator to send events to actors other than the user`s Dialog.)- External sensors may be ignored when VR viewer loses focus. (Assumes there is no need to integrate over time.)HumSensor(related to Scene) &gt;&gt;publish: aHumStatement (This is an event.)HumScene &gt;&gt; step.   "Process events in the scene`s event queue.". HumScribe (Attached to Scene) &gt;&gt; respondTo: aHumStatement from: aHumSensor. . HumDialog (attached to Scene) &gt;&gt; respondTo: aHumStatement  &gt;&gt;  (execute matching Vignette). . . HumCoordinator &gt;&gt; (Start Plan associated with HumStatement) "Example: Button push in scene invokes asynch goal.". . . ( Plans might be used to direct robot moves - But that is outside scope of this ReadMe.). . . HumControl (attached to a HumBox) &gt;&gt; respondTo: HumStatement . . . (HumControl looks like a Role/Actor in this behavior).. . . . HumBox . . . Change position / Change texture (Croquet calls it Costume). . . . . HumScene &gt;&gt; changed     "Box&gt;&gt;Changed --&gt; Scene&gt;&gt;changed" &gt;&gt; step.',' It looks like a lot of the above can be boot-strapped using Hum itself.The common thread is all the above is a series of HumStatements down to HumScene&gt;&gt;step.',' *VPython* render and sensor loop:  (Uses *Python* DSL as intermediate)HumScene &gt;&gt; step.. HumBox (object in Scene) &gt;&gt; Re-gen my triangles and texture, if needed. . HumBox &gt;&gt; renderAsVPython (Generate VPython code fragment which is assembled by Scene and sent to Viewer connection.). Viewer runs interpreter on code fragments to update scene objects.. Viewer captures sensor inputs and informs HumScene via a connection. (Connection is persistent - protocol is TBD)NEXT STEPS:. Decide if the API is single-threaded. ( Q: Is OpenGL/CUDA single-threaded?  Q: Is Visual Basic single-threaded? ). . Comment: We can design an asynch API but implement via a single-thread queue for test-ability and/or implementation constraint.. Design the VR API. (As HumStatements) -- Behavior-driven design and TFD.. Design Python scene DSL. (Design to be Python programmer-friendly) -- Behavior-driven design. Implement Hum to Python translator. (enable Python-based actor actions.). Implement generic Python actor wrapper (message interface).',' *WebBrowser* render and sensor loop: (Uses *JavaScript* (or Json or X3D) DSL as intermediate)HumScene &gt;&gt; step.. HumBox (object in Scene) &gt;&gt; Re-gen my triangles and texture, if needed. . HumBox &gt;&gt; renderAsJavaScript (ThreeJS ?) or Json or X3D(Generate JavaScript code fragment which is assembled by Scene and sent to Viewer AJAX ?? TBD.). Viewer runs interpreter on code fragments to update scene objects.. Viewer captures sensor inputs and informs HumScene via a connection.NEXT STEPS: *** DON`T DO IT *** . This sort of environment will end up being the tail that wags the dog.. To prevent the tech from leaking into the design, wait until after the Python implementation and then translate to JavaScript.','The VPython and WebBrowser-JavaScript strategies are nearly identicle because both languages are interpreted.'.</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; assert:equals:or:</h3><pre>assert: x equals: a or: b   self assert: (( x = a ) or: [x = b]).</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; buildAvatar</h3><pre>buildAvatar   "Create example to indicate development idea/s."   | avatar head torso upperArmLeft upperArmRight hips wheelLeft wheelRight |   head := HumElipsoid id: 'head' type: #box height: 0.3 width: 0.2 depth: 0.2.   torso := HumSolid id: 'torso' type: #box height: 1.5 width: 0.5 depth: 0.25.   upperArmLeft := HumSolid id: 'left arm' type: #box height: 1.0 width: 0.1 depth: 0.1.      upperArmRight := HumSolid id: 'right arm' type: #box height: 1.0 width: 0.1 depth: 0.1.   hips := HumSolid id: 'hips' type: #box height: 0.25 width: 0.6 depth: 0.4.   wheelLeft := HumElipsoid id: 'left wheel' type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.   wheelRight := HumElipsoid id: 'right wheel' type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.      "Color"   head color: ( Color yellow lighter lighter ).   torso color: ( Color pink ).   upperArmLeft color: ( Color red lighter ).      upperArmRight color: ( Color green lighter ).   hips color: ( Color brown ).   wheelLeft color: ( Color blue ).   wheelRight color: ( Color blue ).   "Assemble."   avatar := HumAssembly id: 'avatar'.   avatar center: head onTopOf: torso.   avatar center: upperArmLeft eastOf: torso. "Assume avatar is facing us."   avatar position: upperArmLeft below: head.   avatar center: upperArmRight westOf: torso. "Assume avatar is facing us."   avatar position: upperArmRight below: head.   avatar center: hips below: torso.   avatar center: wheelLeft eastOf: hips.   avatar center: wheelRight westOf: hips.   ^avatar.   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; buildTrailerAssembly</h3><pre>buildTrailerAssembly   "Build trailer - to be used in other tests."   | trailer deckLayer wallLayer interiorLayer      interiorLength interiorWidth interiorHeight       deck  deckThickness     wallThickness wallHeight eastWall westWall northWall southWall      bed bedClearance bedWalkSpace      centerAisle eastCloset westCloset closetDepth      bulkheadWidth bulkheadThickness topSpace     toilet handSink bathLength shower     galleyBulkhead shoulderWidth galleyLength galley galleyTable   |   trailer := (HumAssembly new) id: 'trailer'.   deckLayer := (HumLayer new) id: 'deck layer'.   wallLayer := (HumLayer new) id: 'wall layer'.   interiorLayer := (HumLayer new) id: 'interior layer'.      "deck"   deckThickness   := 0.20 meters.   interiorLength  := 6.00 meters.   interiorWidth   := 2.00 meters.   interiorHeight  := 2.00 meters.      deck :=  HumSolid id: 'deck' type: #box height: deckThickness width: interiorWidth length: interiorLength.   deckLayer addPart: deck.  "walls"   wallThickness := 0.10 meters.   wallHeight    := 1.00 meters.   northWall := HumSolid id: 'northWall' type: #box height: wallHeight width: interiorWidth length: wallThickness.   southWall := HumSolid id: 'southWall' type: #box height: wallHeight width: interiorWidth length: wallThickness.   eastWall := HumSolid id: 'eastWall' type: #box height: wallHeight width: wallThickness length: interiorLength.   westWall := HumSolid id: 'westWall' type: #box height: wallHeight width: wallThickness length: interiorLength.   "Assembly deck and walls"   trailer position: northWall northOf: deck.   trailer position: southWall southOf: deck.   trailer position: eastWall eastOf: deck.   trailer position: westWall westOf: deck.   wallLayer addParts: { northWall. southWall. eastWall. westWall. }.   "======= bed room ========"   bed := HumSolid id: 'bed' type: #box height: (0.5 meters) width: (1.2 meters) length: (2.0 meters).   trailer position: bed northOf: southWall.   trailer position: bed onTopOf: deck.   bedClearance := 0.50 meters.   bedWalkSpace := HumSpace id: 'bedWalkSpace' height: interiorHeight width: interiorWidth length: bedClearance .   "closets"   closetDepth   := 0.50 meters.   bulkheadWidth := 0.70 meters.  eastCloset := HumSolid   id: 'eastCloset' type: #box height: interiorHeight width: bulkheadWidth length: closetDepth.   westCloset := HumSolid   id: 'westCloset' type: #box height: interiorHeight width: bulkheadWidth length: closetDepth.   centerAisle := HumSpace id: 'centerAisle' height: interiorHeight width: (interiorWidth - (bulkheadWidth*2.0)) length: interiorLength.   trailer center: centerAisle onTopOf: deck.  trailer position: bedWalkSpace northOf: bed.   trailer position: eastCloset eastOf: centerAisle.   trailer position: eastCloset northOf: bedWalkSpace.   trailer position: westCloset westOf: centerAisle.   trailer position: westCloset northOf: bedWalkSpace.   interiorLayer addParts: { bed. bedWalkSpace. eastCloset. westCloset. centerAisle. }. "bed room parts"   "======= bath room ==========="   bathLength := 1.0 meter.   toilet := HumSolid id: 'toilet' type: #box height: (0.40 meters) width: (0.20 meters) length: bathLength.   trailer position: toilet onTopOf: deck.   trailer position: toilet northOf: westCloset.   trailer position: toilet eastOf: westWall.   "Postion hand sink above toilet but below topSpace - top will be ~ 1 meter ~ 40 inches above floor"   handSink := HumSolid id: 'hand sink' type: #box height: (0.20 meters) width: (0.20 meters) length: bathLength.   topSpace := HumSpace id: 'top space' height: (interiorHeight / 2.0) width: interiorWidth length: interiorLength.   trailer center: topSpace over: deck.   trailer position: topSpace over: westWall.   trailer center: handSink above: toilet.   trailer position: handSink below: topSpace.   "Position shower by East wall (east of center aisle in bath roos)"   shower := HumSpace id: 'shower'  height: interiorHeight width: bulkheadWidth length: bathLength.    trailer position: shower onTopOf: deck.   trailer position: shower westOf: eastWall.   trailer position: shower northOf: eastCloset.   interiorLayer addParts: { toilet. handSink. shower. }.      "======== galley =========="   bulkheadThickness := (0.04 meter).   galleyBulkhead := HumSolid id: 'galleyBulkhead' type: #box                               height: interiorHeight width: bulkheadWidth length: bulkheadThickness.   galleyLength := (0.50 meters) "space for 3-burner stove"                 + (1.20 meters) "space for kichen sink and food prep".   "Assure shoulder room at table"    shoulderWidth := (0.80 meters).   ( galleyLength &lt; ( shoulderWidth * 2.0)  ) ifTrue: [ galleyLength := ( shoulderWidth * 2.0) ].   galleyTable := HumSolid id: 'galleyTable' type: #box                           height: (0.02 meters) width: (0.6 meter) length: galleyLength.   galley := HumSolid id: 'galley' type: #box                            height: (1 meter) width: (0.4 meters) length: galleyLength.   trailer position: galleyBulkhead above: deck.   trailer position: galleyBulkhead northOf: shower.   trailer position: galley above: deck.   trailer position: galley northOf: galleyBulkhead.   trailer position: galleyTable northOf: galleyBulkhead.   trailer position: galleyTable below: topSpace.      interiorLayer addParts: { galleyBulkhead. galley. galleyTable. }.      "Reset interior length"   interiorLength := bed length + bedWalkSpace length + eastCloset length                    + shower length                    + galleyBulkhead length + galley length.   "Transcript cr; show: 'buildTrailer'; cr; show: 'corrected interior length = ', interiorLength asString; cr."   self assert: (interiorLength &gt;= (2.0 + 0.5 + 0.5 + 0.8 + (2*0.8) ) meters ).   "Correct south wall position"   deck length: interiorLength.   eastWall length: interiorLength.   westWall length: interiorLength.   trailer position: northWall northOf: deck.   
   ^trailer.         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; buildTrailerNoseCurve</h3><pre>buildTrailerNoseCurve   "Return curve of #(x y) where x = 0 is front-most point, y is offset from centerline"   | yOffset xOffset f curve|   yOffset := -1.0.   xOffset := -2.0.   f := 1.0 / (xOffset * xOffset).   curve := OrderedCollection new.   "Transcript cr; show: '========='."   (0.0 to: 1.0 by: 0.05 )        do: [ :p |       |x y x2 y2|         x := p * 2.         x2 := (p*2) + xOffset.         y2 := ( f * (x2*x2) ).         y := (y2 + yOffset) negated.         "Transcript cr; show: (x printShowingDecimalPlaces:2),'==&gt;',(y printShowingDecimalPlaces:2)."         curve add: ( x@y ).         ].   ^curve </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; buildTrailerScene</h3><pre>buildTrailerScene   "Build trailer scene - to be used in other tests."   |  trailer deckLayer wallLayer interiorLayer scene      interiorLength interiorWidth interiorHeight       deck  deckThickness     wallThickness wallHeight eastWall westWall northWall southWall      bed bedClearance bedWalkSpace      centerAisle eastCloset westCloset closetDepth      bulkheadWidth bulkheadThickness topSpace     toilet handSink bathLength shower     galleyBulkhead shoulderWidth galleyLength galley galleyTable   |   trailer := (HumAssembly new) id: 'trailer'.   deckLayer := (HumLayer new) id: 'deck layer'.   wallLayer := (HumLayer new) id: 'wall layer'.   interiorLayer := (HumLayer new) id: 'interior layer'.      "deck"   deckThickness   := 0.20 meters.   interiorLength  := 6.00 meters.   interiorWidth   := 2.00 meters.   interiorHeight  := 2.00 meters.      deck :=  HumSolid id: 'deck' type: #box height: deckThickness width: interiorWidth length: interiorLength.   deckLayer addPart: deck.  "walls"   wallThickness := 0.10 meters.   wallHeight    := 1.00 meters.   northWall := HumSolid id: 'northWall' type: #box height: wallHeight width: interiorWidth length: wallThickness.   southWall := HumSolid id: 'southWall' type: #box height: wallHeight width: interiorWidth length: wallThickness.   eastWall := HumSolid id: 'eastWall' type: #box height: wallHeight width: wallThickness length: interiorLength.   westWall := HumSolid id: 'westWall' type: #box height: wallHeight width: wallThickness length: interiorLength.   "Assembly deck and walls"   trailer position: northWall northOf: deck.   trailer position: southWall southOf: deck.   trailer position: eastWall eastOf: deck.   trailer position: westWall westOf: deck.   wallLayer addParts: { northWall. southWall. eastWall. westWall. }.   "======= bed room ========"   bed := HumSolid id: 'bed' type: #box height: (0.5 meters) width: (1.2 meters) length: (2.0 meters).   trailer position: bed northOf: southWall.   trailer position: bed onTopOf: deck.   bedClearance := 0.50 meters.   bedWalkSpace := HumSpace id: 'bedWalkSpace' height: interiorHeight width: interiorWidth length: bedClearance .   "closets"   closetDepth   := 0.50 meters.   bulkheadWidth := 0.70 meters.  eastCloset := HumSolid   id: 'eastCloset' type: #box height: interiorHeight width: bulkheadWidth length: closetDepth.   westCloset := HumSolid   id: 'westCloset' type: #box height: interiorHeight width: bulkheadWidth length: closetDepth.   centerAisle := HumSpace id: 'centerAisle' height: interiorHeight width: (interiorWidth - (bulkheadWidth*2.0)) length: interiorLength.   trailer center: centerAisle onTopOf: deck.  trailer position: bedWalkSpace northOf: bed.   trailer position: eastCloset eastOf: centerAisle.   trailer position: eastCloset northOf: bedWalkSpace.   trailer position: westCloset westOf: centerAisle.   trailer position: westCloset northOf: bedWalkSpace.   interiorLayer addParts: { bed. bedWalkSpace. eastCloset. westCloset. centerAisle. }. "bed room parts"   "======= bath room ==========="   bathLength := 1.0 meter.   toilet := HumSolid id: 'toilet' type: #box height: (0.40 meters) width: (0.20 meters) length: bathLength.   trailer position: toilet onTopOf: deck.   trailer position: toilet northOf: westCloset.   trailer position: toilet eastOf: westWall.   "Postion hand sink above toilet but below topSpace - top will be ~ 1 meter ~ 40 inches above floor"   handSink := HumSolid id: 'hand sink' type: #box height: (0.20 meters) width: (0.20 meters) length: bathLength.   topSpace := HumSpace id: 'top space' height: (interiorHeight / 2.0) width: interiorWidth length: interiorLength.   trailer center: topSpace over: deck.   trailer position: topSpace over: westWall.   trailer center: handSink above: toilet.   trailer position: handSink below: topSpace.   "Position shower by East wall (east of center aisle in bath roos)"   shower := HumSpace id: 'shower'  height: interiorHeight width: bulkheadWidth length: bathLength.    trailer position: shower onTopOf: deck.   trailer position: shower westOf: eastWall.   trailer position: shower northOf: eastCloset.   interiorLayer addParts: { toilet. handSink. shower. }.      "======== galley =========="   bulkheadThickness := (0.04 meter).   galleyBulkhead := HumSolid id: 'galleyBulkhead' type: #box                               height: interiorHeight width: bulkheadWidth length: bulkheadThickness.   galleyLength := (0.50 meters) "space for 3-burner stove"                 + (1.20 meters) "space for kichen sink and food prep".   "Assure shoulder room at table"    shoulderWidth := (0.80 meters).   ( galleyLength &lt; ( shoulderWidth * 2.0)  ) ifTrue: [ galleyLength := ( shoulderWidth * 2.0) ].   galleyTable := HumSolid id: 'galleyTable' type: #box                           height: (0.02 meters) width: (0.6 meter) length: galleyLength.   galley := HumSolid id: 'galley' type: #box                            height: (1 meter) width: (0.4 meters) length: galleyLength.   trailer position: galleyBulkhead above: deck.   trailer position: galleyBulkhead northOf: shower.   trailer position: galley above: deck.   trailer position: galley northOf: galleyBulkhead.   trailer position: galleyTable northOf: galleyBulkhead.   trailer position: galleyTable below: topSpace.      interiorLayer addParts: { galleyBulkhead. galley. galleyTable. }.      "Reset interior length"   interiorLength := bed length + bedWalkSpace length + eastCloset length                    + shower length                    + galleyBulkhead length + galley length.   "Transcript cr; show: 'buildTrailer'; cr; show: 'corrected interior length = ', interiorLength asString; cr."   self assert: (interiorLength &gt;= (2.0 + 0.5 + 0.5 + 0.8 + (2*0.8) ) meters ).   "Correct south wall position"   deck length: interiorLength.   eastWall length: interiorLength.   westWall length: interiorLength.   trailer position: northWall northOf: deck.      scene := HumScene new.   scene addParts: { deckLayer. wallLayer. interiorLayer. }.
   ^scene.         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; checkViewPortMorph</h3><pre>checkViewPortMorph   ^ checkViewPortMorph ifNil: [ checkViewPortMorph := false ].</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; checkViewPortMorph:</h3><pre>checkViewPortMorph: aBoolean   checkViewPortMorph := aBoolean</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; expect:is:</h3><pre>expect: actualValue is: expectedValue    "syntax sugar"   ^ self expect: expectedValue actual: actualValue.</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; for:expect:</h3><pre>for: someExpression expect: someResult   |   |    ^self expect: someResult actual: someExpression</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; lastChange</h3><pre>lastChange   ^ lastChange </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; showViewPort:</h3><pre>showViewPort: aHumViewPort    | morph |   self checkViewPortMorph ifFalse: [ ^self ].      morph := aHumViewPort asMorph.   morph openInWorld.   false ifTrue: [morph delete].</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test110surfaceHasOrigin</h3><pre>test110surfaceHasOrigin   "A surface is initialized with a origin object which is zerosized and at 0,0."   | surface zero|   surface := HumSurface new.   zero := 0 px.   self assert: ( surface origin left = zero).   self assert: ( surface origin right = zero ).      self assert: ( surface origin top = zero ).      self assert: ( surface origin bottom = zero ).   self assert: ( surface origin height = zero ).   self assert: ( surface origin width = zero ).   self assert: ( surface origin layer = zero ).</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test120surfaceSizeIsDurable</h3><pre>test120surfaceSizeIsDurable   "A surface is initialized with a origin object which is zero-sized and at 0,0."   | surface |   "Note: Dimensions used here are not typical - They are just for testing convenience."      surface := HumSurface new.   surface width: 1 px; height: 1 px.   "Bump surface over the the right."   surface left: 1 px.   self assert: ( surface right = 2 px ).   "Bump surface up."   surface top: 3 px.   self assert: ( surface bottom = 2 px ).   "Bump surface from bottom."   surface bottom: 3 px.   self assert: ( surface top = 4 px ).   "Pull surface via the right edge."   surface right: 5 px.   self assert: ( surface left = 4 px).</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test130surfaceLayers</h3><pre>test130surfaceLayers   "An Surface Assembly has multiple shapes in one or more layers ."   | surface rectangleA rectangleB |   "Note: Dimensions used here are not typical - They are just for testing convenience."   surface := HumSurface new.   rectangleA := ( HumSurface new ) width: 20 px; height: 10 px.   rectangleB := ( HumSurface new ) width: 30 px; height: 40 px.      "Put rectangle A on the surface."   surface place: rectangleA at: {5 px. 5 px. 0}.   self expect: (5 px) actual: ( rectangleA left   ).   self expect: (25 px) actual: ( rectangleA right ).   self expect: (5 px) actual: ( rectangleA top ).   self expect: (-5 px) actual: ( rectangleA bottom ).   self expect: ( 0 ) actual: ( rectangleA layer ).      "Overlay rectangle B on top of rectangle A"   surface overlay: rectangleB onTopOf: rectangleA.   self assert: ( rectangleB layer ) &gt; ( rectangleA layer ).   self expect: ( 0 ) actual: ( rectangleA layer ).   self expect: ( 1 ) actual: ( rectangleB layer ).   "By convention, the top and left edges will align."   self expect: ( rectangleA top ) actual: ( rectangleB top   ).   self expect: ( rectangleA left ) actual: ( rectangleB left   ).   "And other edges should be:"   self expect: (5 px) actual: ( rectangleB left   ).   self expect: (35 px) actual: ( rectangleB right ).   self expect: (5 px) actual: ( rectangleB top ).   self expect: (-35 px) actual: ( rectangleB bottom ).   "By convention, the layer is greater for the thing on top."         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test135surfaceBoundingBox</h3><pre>test135surfaceBoundingBox   "An pane has a bounding box determined by the min/max of its collection of shapes."   | pane rectangleA rectangleB |   "Note: Dimensions used here are meaningless - They are just for testing convenience."   pane := HumPane new.   rectangleA := ( HumSurface new ) width: 20 px; height: 10 px.   rectangleB := ( HumSurface new ) width: 30 px; height: 40 px.      "Put rectangle A on the pane."   pane place: rectangleA at: {5 px. 5 px. 0}.   self expect: (5 px) actual: ( rectangleA left   ).   self expect: (25 px) actual: ( rectangleA right ).   self expect: (5 px) actual: ( rectangleA top ).   self expect: (-5 px) actual: ( rectangleA bottom ).   self expect: ( 0 ) actual: ( rectangleA layer ).      "Put rectange B on top of rectangle A"   pane overlay: rectangleB onTopOf: rectangleA.   "By convention, the top and left edges will align."   self expect: (5 px) actual: ( rectangleB left   ).   self expect: (35 px) actual: ( rectangleB right ).   self expect: (5 px) actual: ( rectangleB top ).   self expect: (-35 px) actual: ( rectangleB bottom ).   self expect: ( 1 ) actual: ( rectangleB layer ).   "By convention, the layer is greater for the thing on top."   self assert: ( rectangleB layer ) &gt; ( rectangleA layer ).      "Expect bounding box metrics to be . . ."   self expect: (5 px) actual: (pane bbTop).   self expect: (-35 px) actual: (pane bbBottom).   self expect: (0 px) actual: (pane bbLeft).   self expect: (35 px) actual: (pane bbRight).   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test140surfaceLayout</h3><pre>test140surfaceLayout   "A surface is initialized with a origin shape which is zero-sized and at 0,0."   | surface rectangleA rectangleB |      "Note: Dimensions used here are arbitrary - They are just for testing convenience."   surface := HumSurface new.   rectangleA := ( HumSurface new ) width: 20 px; height: 10 px.   rectangleB := ( HumSurface new ) width: 30 px; height: 40 px.      "Put rectangle A on the surface."   surface place: rectangleA at: { 5 px. 5px. 1. }.   self assert: ( rectangleA left = 5 px ).   self assert: ( rectangleA top = 5 px ).   self assert: ( rectangleA layer = 1 ).      "Put B below A."   surface place: rectangleB below: rectangleA.   self assert: ( rectangleB top ) = ( rectangleA bottom ).   "By convention B is in same layer as A. (They are side by side in the same layer. )"   self assert: ( rectangleB layer ) = ( rectangleA layer ).      "Now put B above A. "   rectangleA layer: 3.   surface place: rectangleB above: rectangleA.   self assert: ( rectangleB bottom ) = ( rectangleA top ).   self assert: ( rectangleB layer ) = ( rectangleA layer ).      "Now put B left of A."   rectangleA layer: 4.   surface place: rectangleB leftOf: rectangleA.   self assert: ( rectangleB left ) = ( rectangleA right ).   self assert: ( rectangleB layer ) = ( rectangleA layer ).      "Now put B right of A."   rectangleA layer: 5.   surface place: rectangleB rightOf: rectangleA.   self assert: ( rectangleB left ) = ( rectangleA right ).   self assert: ( rectangleB layer ) = ( rectangleA layer ).      </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test150surfaceLayoutForPA</h3><pre>test150surfaceLayoutForPA   "Test for API usability -- Consider a layout like the PA."   | window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram |   "NOTE: Dimensions used here are percents !!!"   "TODO: Percent notation may be leaking rendering engine layout API."   "TODO: Would 'em' be a more appropriate unit of measure?"      "Create the main divisions."   window := HumSurface new initialize: '%'; width: 100 ; height: 100 .   menuStack := HumSurface new initialize: '%'; width: 100 ; height: 10 ; top: 0 ; left: 0 .   editStack := HumSurface new initialize: '%'; width: 75 ; height: 90 ; left: 0 .   diagramStack := HumSurface new initialize: '%'; width: 25 ; height: 90 .   "Assemble them."   window place:  editStack below: menuStack.   self expect: -100 actual: (editStack bottom quantity).   window place: diagramStack below: menuStack.   self expect: -100 actual: (diagramStack bottom quantity).   window place: diagramStack rightOf: editStack.   self expect:  100 actual: (diagramStack right quantity).      "Create editStack divisions and assemble them."   editMenu := HumSurface new initialize: '%'; width: 100 ; height: 10 ; top: 0 ; left: 0 .   codeView := HumSurface new initialize: '%'; width: 100 ; height: 80 .   critiqueView := HumSurface new initialize: '%'; width: 100 ; height: 10 .      editStack place: codeView below: editMenu.   editStack place: critiqueView below: codeView.   self expect:  critiqueView bottom quantity is: -100 .      "Create diagramStack divisions."   planTreeDiagram := HumSurface new initialize: '%'; width: 100 ; height: 25 ; left: 0 ; top: 0 .   roleRelationsDiagram := HumSurface new initialize: '%'; width: 100 ; height: 25 .   wordRelationsDiagram := HumSurface new initialize: '%'; width: 100 ; height: 25 .   vignetteDiagram := HumSurface new initialize: '%'; width: 100 ; height: 25 .      diagramStack place: roleRelationsDiagram below:  planTreeDiagram.   diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.   diagramStack place: vignetteDiagram below: wordRelationsDiagram.   self expect: vignetteDiagram bottom quantity is: -100 .   self expect: vignetteDiagram top quantity is: -75 .   self expect: vignetteDiagram left quantity is: 0 .   self expect: vignetteDiagram right quantity is: 100 .          </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test210boxHasOrigin</h3><pre>test210boxHasOrigin   "A box is initialized with a origin object which is zero-sized and at 0,0."   | box zero |   zero := 0 meter.   box := HumBox new.   self assert: ( box origin height = zero ).   self assert: ( box origin width = zero ).   self assert: ( box origin length = zero ).      self assert: ( box origin westEdge = zero ).   self assert: ( box origin eastEdge = zero ).      self assert: ( box origin northEdge = zero ).      self assert: ( box origin southEdge = zero ).      self assert: ( box origin topEdge = zero ).      self assert: ( box origin bottomEdge = zero ).</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test210surfaceAsSVG</h3><pre>test210surfaceAsSVG   "Test for usability -- Consider a layout like the PA."   | window svgString |      true ifFalse: [Transcript cr; show: 'test210surfaceAsSVG turned off'; cr.  ^self skip].      window := HumSurface new initialize: 'px'; width: 1600 px; height: 900 px; id: 'window'.   "Get the SVG string for this assembly."   svgString := window asSVG.      self assert: ( svgString trimBoth beginsWith: '&lt;svg ' ).   self assert: ( svgString includesSubString: '&lt;rect ' ).   self assert: ( svgString includesSubString: ' ID="window" ' ).   self assert: ( svgString includesSubString: ' width="1600 px" ' ).   self assert: ( svgString includesSubString: ' height="900 px" ' ).             </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test220boxSizeIsDurable</h3><pre>test220boxSizeIsDurable   "When we move an edge, the width, height, and length are not affected."   | box |   box := HumBox new.   box width: 1 meter; height: 1 meter; length: 1 meter.   "Bump box over to the the East by pushing on the West edge."   box westEdge: 1 meter.   self assert: ( box eastEdge = 2 meter ).   "Bump box up."   box topEdge: 3 meter.    self assert: ( box bottomEdge = 2 meter ).   "Bump box from bottom."   box bottomEdge: 3 meter.   self assert: ( box topEdge = 4 meter).   "Pull box via the East edge."   box eastEdge: 5 meter.   self assert: ( box westEdge = 4 meter ).   "Bump box to the South by pushing on the North edge."   box northEdge: 7 meter.   self assert: ( box southEdge = 6 meter ).   "Pull box to the South by pulling on the South edge."   box southEdge: -2 meter.   self assert: ( box northEdge = -1 meter ).</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test220surfaceAsSvgViewBox</h3><pre>test220surfaceAsSvgViewBox   "Test for usability -- Consider a layout like the PA."   | window svgString |      true ifFalse: [Transcript cr; show: 'test220surfaceAsSvgViewBox turned off'; cr.  ^self skip ].      window := HumSurface new initialize: #pixel; width: 1600 px; height: 900 px; id: 'window'.   "Get the SVG string for this assembly."   svgString := window asSvgViewBox.      self assert: ( svgString beginsWith: '&lt;svg ' ).   self assert: ( svgString includesSubString: '&lt;rect ' ).   self assert: ( svgString includesSubString: ' ID="window" ' ).   self assert: ( svgString includesSubString: ' width="1600 px" ' ).   self assert: ( svgString includesSubString: ' height="900 px" ' ).   self assert: ( svgString includesSubString: ' viewBox="0.0 0.0 1600 900" ').                </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test230boxIsAContainer</h3><pre>test230boxIsAContainer   "HumAssembly (subtype of HumBox) may contain other boxes/spaces. "   | container box  |      ""   container := HumAssembly new.   container length: 100 meter; width: 100 meter; height: 100 meter.      box := ( HumBox new ) length: 10 meter; width: 10 meter; height: 10 meter.      container center: box at: { 20 meter. 30 meter. 50 meter. }.      self assert: (container parts includes: box).   self assert: ( box eastEdge = 25 meter ).   self assert: ( box northEdge = 35 meter ).   self assert: ( box bottomEdge = 45 meter ).</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test240boxLayout</h3><pre>test240boxLayout   "We can position boxes using absolute position values and relative positions."   | container boxA boxB |      ""   container := HumAssembly new.   container length: 100 meter; width: 100 meter; height: 100 meter.      boxA :=( HumBox new ) length: 10 meter; width: 10 meter; height: 10 meter.   boxB :=( HumBox new ) length: 10 meter; width: 10 meter; height: 10 meter.      "Set absolute position (centroid)"   container center: boxA at: { 20 meter. 30 meter. 50 meter. }.   self assert: ( boxA eastEdge = 25 meter ).   self assert: ( boxA northEdge = 35 meter ).   self assert: ( boxA bottomEdge = 45 meter ).      self assert: ( boxA westEdge = 15 meter ).   self assert: ( boxA southEdge = 25 meter ).   self assert: ( boxA topEdge = 55 meter ).      "Position boxes relative to each other."   "Place B on top of A."   container position: boxB onTopOf: boxA.   self assert: ( boxB bottomEdge ) = ( boxA topEdge ).      "Place B under A."   container position: boxB onBottomOf: boxA.   self assert: ( boxB topEdge ) = ( boxA bottomEdge ).      "Place B on East side of A."   container position: boxB eastOf: boxA.   self assert: ( boxB westEdge ) = ( boxA eastEdge ).      "Place B on West side of A."   container position: boxB westOf: boxA.   self assert: ( boxB eastEdge ) = ( boxA westEdge ).      "Place B on North side of A."   container position: boxB northOf: boxA.   self assert: ( boxB southEdge ) = ( boxA northEdge ).      "Place B on South side  of A."   container position: boxB southOf: boxA.   self assert: ( boxB northEdge ) = ( boxA southEdge ).      </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test250boxCentering</h3><pre>test250boxCentering   "Center one box on top of another."   | container boxA boxB |      "Default unit of measure is meter."   container := HumAssembly new.   container length: 100; width: 100; height: 100.      boxA :=( HumBox new ) length: 20; width: 20; height: 20.   boxB :=( HumBox new ) length: 10; width: 10; height: 10.      "Center B on top of A."   container center: boxB onTopOf: boxA.   self assert: ( boxB center x) = ( boxA center x ).   self assert: ( boxB center y ) = (  boxA center y ).   self assert: ( boxB bottomEdge ) = (  boxA topEdge ).</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test255surfaceAssemblyAsSVG</h3><pre>test255surfaceAssemblyAsSVG   "Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."   | window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram svgString diagramMenu |   true ifFalse: [Transcript cr; show: 'test255surfaceAssemblyAsSVG turned off'; cr.  self skip. ].      "Create the main divisions. NOTE: Dimensions will default to inches"   window := HumSurface new initialize: 'screenInch'; width: 13.0; height: 8.0; id: 'window'.   menuStack := HumSurface new initialize: 'screenInch'; width: 12.0; height: 0.25; top: 0; left: 0; id: 'menu stack'.   editStack := HumSurface new initialize: 'screenInch'; width: 8.0; height: 7.5; left: 0; id: 'edit stack'.   diagramStack := HumSurface new initialize: 'screenInch'; width: 5.0; height: 7.5; id: 'diagram stack'.   "Assemble them."   window place:  editStack below: menuStack.   window place: diagramStack below: menuStack.   window place: diagramStack rightOf: editStack.   "Create editStack divisions and assemble them."   editMenu := HumSurface new initialize: 'screenInch'; width: 8.0; height: 0.25; top: 0; left: 0; id: 'edit menu'.   codeView := HumSurface new initialize: 'screenInch'; width: 8.0; height: 7.0; id: 'code view'.   critiqueView := HumSurface new initialize: 'screenInch'; width: 8.0; height: 0.25; id: 'critique view'.      editStack place: codeView below: editMenu.   editStack place: critiqueView below: codeView.      "Create diagramStack divisions."   diagramMenu := HumSurface new initialize: 'screenInch'; width: 5.0; height: 0.25; left: 0; top: 0; id: 'diagram menu'.   planTreeDiagram := HumSurface new initialize: 'screenInch'; width: 5.0; height: 2.0; left: 0; top: 0; id: 'plan tree'.   roleRelationsDiagram := HumSurface new initialize: 'screenInch'; width: 5.0; height: 2.0; id: 'role relations'.   wordRelationsDiagram := HumSurface new initialize: 'screenInch'; width: 5.0; height: 2.0; id: 'word relations'.   vignetteDiagram := HumSurface new initialize: 'screenInch'; width: 5.0; height: 2.0; id: 'vignette relations'.        diagramStack place: planTreeDiagram below: diagramMenu.   diagramStack place: roleRelationsDiagram below:  planTreeDiagram.   diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.   diagramStack place: vignetteDiagram below: wordRelationsDiagram.      "Get the SVG string for this assembly."   svgString := window asSvgViewBox .      self assert: ( svgString beginsWith: '&lt;svg ' ).   self assert: ( svgString includesSubString: '&lt;rect ' ).   self assert: ( svgString includesSubString: ' ID="window" ' ).   self assert: ( svgString includesSubString: ' ID="edit stack" ' ).   self assert: ( svgString includesSubString: ' ID="diagram stack" ' ).   self assert: ( svgString includesSubString: ' ID="critique view" ' ).      "Transcript cr; show: 'test255surfaceAssemblyAsSVG'; cr; show: svgString; cr."</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test260surfaceAssemblyAsSvgPercent</h3><pre>test260surfaceAssemblyAsSvgPercent   "Test for usability -- Consider a layout like the PA."   | window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram svgString |   true ifFalse: [Transcript cr; show: 'test260surfaceAssemblyAsSvgPercent turned off'; cr. self skip ].   "NOTE: Dimensions used here are percentages of the container !!!"      "Create the main divisions."   window := HumSurface new initialize: #percent; width: 100 percent; height: 100 percent; id: 'window'.   menuStack := HumSurface new initialize: #percent; width: 100 percent; height: 10 percent; top: 0 percent; left: 0 percent.   editStack := HumSurface new initialize: #percent; width: 75 percent; height: 90 percent; left: 0 percent; id: 'edit stack'.   diagramStack := HumSurface new initialize: #percent; width: 25 percent; height: 90 percent; id: 'diagram stack'.   "Assemble them."   window place: editStack below: menuStack.   window place: diagramStack below: menuStack.   window place: diagramStack rightOf: editStack.      "Create editStack divisions and assemble them."   editMenu := HumSurface new initialize: #percent; width: 100 percent; height: 10 percent; top: 0 percent; left: 0 percent.   codeView := HumSurface new initialize: #percent; width: 100 percent; height: 80 percent.   critiqueView := HumSurface new initialize: #percent; width: 100 percent; height: 10 percent; id: 'critique view'.      editStack place: codeView below: editMenu.   editStack place: critiqueView below: codeView.      "Create diagramStack divisions."   planTreeDiagram := HumSurface new initialize: #percent; width: 100 percent; height: 25 percent; left: 0 percent; top: 0 percent.   roleRelationsDiagram := HumSurface new initialize: #percent; width: 100 percent; height: 25 percent.   wordRelationsDiagram := HumSurface new initialize: #percent; width: 100 percent; height: 25 percent.   vignetteDiagram := HumSurface new initialize: #percent; width: 100 percent; height: 25 percent.      diagramStack place: roleRelationsDiagram below: planTreeDiagram.   diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.   diagramStack place: vignetteDiagram below: wordRelationsDiagram.      "Get the SVG string for this assembly."   svgString := window asSVG.      self assert: ( svgString trimBoth beginsWith: '&lt;svg ' ).   self assert: ( svgString includesSubString: '&lt;rect ' ).   self assert: ( svgString includesSubString: 'ID="window" ' ).   self assert: ( svgString includesSubString: 'ID="edit stack" ' ).   self assert: ( svgString includesSubString: 'ID="diagram stack" ' ).   self assert: ( svgString includesSubString: 'ID="critique view" ' ).      "Transcript cr; show: 'from test260surfaceAssemblyAsSvgPercent: ; cr; show: svgString; cr."             </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test270surfaceAssemblyAsSvgInch</h3><pre>test270surfaceAssemblyAsSvgInch   "Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."   | window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram svgString diagramMenu |   true ifFalse: [Transcript cr; show: 'test270surfaceAssemblyAsSvgInch turned off'; cr. self skip ].   "Create the main divisions."   window := HumSurface new initialize: 'screenInch'; width: 13.0; height: 8.0; id: 'window'.   menuStack := HumSurface new initialize: 'screenInch'; width: 13.0 ; height: 0.25 ; top: 0 ; left: 0 ; id: 'menu stack'.   editStack := HumSurface new initialize: 'screenInch'; width: 8.0 ; height: 7.5 ; left: 0 ; id: 'edit stack'.   diagramStack := HumSurface new initialize: 'screenInch'; width: 5.0 ; height: 7.5 ; id: 'diagram stack'.   "Assemble them."   window place:  editStack below: menuStack.   window place: diagramStack below: menuStack.   window place: diagramStack rightOf: editStack.      "Create editStack divisions and assemble them."   editMenu := HumSurface new initialize: 'screenInch'; width: 8.0 ; height: 0.25 ; top: 0 ; left: 0 ; id: 'edit menu'.   codeView := HumSurface new initialize: 'screenInch'; width: 8.0 ; height: 7.0 ; id: 'code view'.   critiqueView := HumSurface new initialize: 'screenInch'; width: 8.0 ; height: 0.25 ; id: 'critique view'.      editStack place: codeView below: editMenu.   editStack place: critiqueView below: codeView.      "Create diagramStack divisions."   diagramMenu := HumSurface new initialize: 'screenInch'; width: 5.0 ; height: 0.25 ; left: 0 ; top: 0 ; id: 'diagram menu'.   planTreeDiagram := HumSurface new initialize: 'screenInch'; width: 5.0 ; height: 2.0 ; left: 0 ; top: 0 ; id: 'plan tree'.   roleRelationsDiagram := HumSurface new initialize: 'screenInch'; width: 5.0 ; height: 2.0 ; id: 'role relations'.   wordRelationsDiagram := HumSurface new initialize: 'screenInch'; width: 5.0 ; height: 2.0 ; id: 'word relations'.   vignetteDiagram := HumSurface new initialize: 'screenInch'; width: 5.0 ; height: 2.0 ; id: 'vignette relations'.        diagramStack place: planTreeDiagram below: diagramMenu.   diagramStack place: roleRelationsDiagram below:  planTreeDiagram.   diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.   diagramStack place: vignetteDiagram below: wordRelationsDiagram.      "Get the SVG string for this assembly."   svgString := window asSvgViewBox .      self assert: ( svgString beginsWith: '&lt;svg ' ).   self assert: ( svgString includesSubString: '&lt;rect ' ).   self assert: ( svgString includesSubString: ' ID="window" ' ).   self assert: ( svgString includesSubString: ' ID="edit stack" ' ).   self assert: ( svgString includesSubString: ' ID="diagram stack" ' ).   self assert: ( svgString includesSubString: ' ID="critique view" ' ).      "Transcript cr; show: svgString; cr."             </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test310spaceHasOrigin</h3><pre>test310spaceHasOrigin   "A space is initialized with a origin object which is zero-sized and at 0,0."   | space zero |   zero := 0 meter.   space := HumSpace new.   self assert: ( space origin height = zero ).   self assert: ( space origin width = zero ).   self assert: ( space origin length = zero ).      self assert: ( space origin westEdge = zero ).   self assert: ( space origin eastEdge = zero ).      self assert: ( space origin northEdge = zero ).      self assert: ( space origin southEdge = zero ).      self assert: ( space origin topEdge = zero ).      self assert: ( space origin bottomEdge = zero ).</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test310surfaceAsXML</h3><pre>test310surfaceAsXML   "First principle: Express a hum surface as XML.   The recipient of the XML may interpret it using some local framework.   For example: The Hum RunTime may provide a JavaScript interpreter.   "   | window xmlString |      true ifFalse: [Transcript cr; show: 'test310surfaceAsXML turned off'; cr.  ^self skip ].      window := HumSurface new initialize: 'px'; width: 800 px; height: 450 px; id: 'window'.   "Get the SVG string for this assembly."   xmlString := window asXML.      self assert: ( xmlString trimBoth beginsWith: '&lt;script ' ).   self assert: ( xmlString includesSubString: '&lt;hum:surface ' ).   self assert: ( xmlString includesSubString: ' ID="window" ' ).   self assert: ( xmlString includesSubString: ' width="800 px" ' ).   self assert: ( xmlString includesSubString: ' height="450 px" ' ).          "Transcript cr; show: 'from test310surfaceAsXML : '; cr; show: xmlString; cr."   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test320spaceSizeIsDurable</h3><pre>test320spaceSizeIsDurable   "When an edge is moved, the opposite edge is also moved."   | space |   space := HumSpace new.   space width: 1 meter; height: 1 meter; length: 1 meter.   "Bump space over to the the East by pushing on the West edge."   space westEdge: 1 meter.   self assert: ( space eastEdge = 2 meter ).   "Bump space up."   space topEdge: 3 meter.   self assert: ( space bottomEdge = 2 meter ).   "Bump space from bottom."   space bottomEdge: 3 meter.   self assert: ( space topEdge = 4 meter ).   "Pull space via the East edge."   space eastEdge: 5 meter.   self assert: ( space westEdge = 4 meter ).   "Bump space to the South by pushing on the North edge."   space northEdge: 7 meter.   self assert: ( space southEdge = 6 meter ).   "Pull space to the South by pulling on the South edge."   space southEdge: -2 meter.   self assert: ( space northEdge = -1 meter ).</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test320surfaceAssemblyAsXML</h3><pre>test320surfaceAssemblyAsXML   "Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."   | window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram xmlString diagramMenu |   true ifFalse: [Transcript cr; show: 'test320surfaceAssemblyAsXML turned off'; cr. ^self skip ].   "NOTE: Dimensions used here are percentages of the container !!!"      "Create the main divisions."   window := HumSurface new    initialize: 'px'; width: 1300 px; height: 800 px; id: 'window'.   menuStack := HumSurface new initialize: 'px'; width: 1300 px; height: 25 px; top: 0 px; left: 0 px; id: 'menu stack'.   editStack := HumSurface new initialize: 'px'; width: 800 px; height: 75 px; left: 0 px; id: 'edit stack'.   diagramStack := HumSurface new initialize: 'px'; width: 500 px; height: 75 px; id: 'diagram stack'.   "Assemble them."   window place:  editStack below: menuStack.   window place: diagramStack below: menuStack.   window place: diagramStack rightOf: editStack.      "Create editStack divisions and assemble them."   editMenu := HumSurface new initialize: 'px'; width: 800 px; height: 25 px; top: 0 px; left: 0 px; id: 'edit menu'.   codeView := HumSurface new initialize: 'px'; width: 800 px; height: 700 px; id: 'code view'.   critiqueView := HumSurface new initialize: 'px'; width: 800 px; height: 25 px; id: 'critique view'.      editStack place: codeView below: editMenu.   editStack place: critiqueView below: codeView.      "Create diagramStack divisions."   diagramMenu := HumSurface new initialize: 'px'; width: 500 px; height: 25 px; left: 0 px; top: 0 px; id: 'diagram menu'.   planTreeDiagram := HumSurface new initialize: 'px'; width: 500 px; height: 200 px; left: 0 px; top: 0 px; id: 'plan tree'.   roleRelationsDiagram := HumSurface new initialize: 'px'; width: 500 px; height: 200 px; id: 'role relations'.   wordRelationsDiagram := HumSurface new initialize: 'px'; width: 500 px; height: 200 px; id: 'word relations'.   vignetteDiagram := HumSurface new initialize: 'px'; width: 500 px; height: 200 px; id: 'vignette relations'.        diagramStack place: planTreeDiagram below: diagramMenu.   diagramStack place: roleRelationsDiagram below:  planTreeDiagram.   diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.   diagramStack place: vignetteDiagram below: wordRelationsDiagram.      "Get the SVG string for this assembly."   xmlString := window asXML .      self assert: ( xmlString trimBoth beginsWith: '&lt;script' ).   self assert: ( xmlString includesSubString: '&lt;hum:surface ' ).   self assert: ( xmlString includesSubString: '&lt;hum:surface ID="window" ' ).   self assert: ( xmlString includesSubString: '&lt;hum:surface ID="edit stack" ' ).   self assert: ( xmlString includesSubString: '&lt;hum:surface ID="diagram stack" ' ).   self assert: ( xmlString includesSubString: '&lt;hum:surface ID="critique view" ' ).      "Transcript cr; show: 'from test320surfaceAssemblyAsXML'; cr; show: xmlString; cr."             </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test330spaceContainer</h3><pre>test330spaceContainer   "We can specify a box position in terms of its centroid."   | container box  |      ""   container := HumAssembly new.   container length: 100 meter; width: 100 meter; height: 100 meter.   container bottomEdge: 1000 meter; westEdge: 2000 meter; southEdge: 3000 meter.      box :=( HumBox new ) length: 10 meter; width: 10 meter; height: 10 meter.      container center: box at: { 20 meter. 30 meter. 50 meter. }.   "Note: These box positions are relative to the container`s edges."   self assert: ( box eastEdge = 25 meter ).   self assert: ( box northEdge = 35 meter ).   self assert: ( box bottomEdge = 45 meter ).</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test340spaceLayout</h3><pre>test340spaceLayout   "HumAssembly may position its parts relative to itself and each other."   | container spaceA spaceB |      ""   container := HumAssembly new.   container length: 100 meter; width: 100 meter; height: 100 meter.      spaceA :=( HumSpace new ) length: 10 meter; width: 10 meter; height: 10 meter.   spaceB :=( HumSpace new ) length: 10 meter; width: 10 meter; height: 10 meter.      container center: spaceA at: { 20 meter. 30 meter. 50 meter. }.   self assert: ( spaceA eastEdge = 25 meter).   self assert: ( spaceA northEdge = 35 meter ).   self assert: ( spaceA bottomEdge = 45 meter ).      self assert: ( spaceA westEdge = 15 meter ).   self assert: ( spaceA southEdge = 25 meter ).   self assert: ( spaceA topEdge = 55 meter ).      "Place B on top of A."   container position: spaceB onTopOf: spaceA.   self assert: ( spaceB bottomEdge ) = ( spaceA topEdge ).      "Place B under A."   container position: spaceB onBottomOf: spaceA.   self assert: ( spaceB topEdge ) = ( spaceA bottomEdge ).      "Place B on East side of A."   container position: spaceB eastOf: spaceA.   self assert: ( spaceB westEdge ) = ( spaceA eastEdge ).      "Place B on West side of A."   container position: spaceB westOf: spaceA.   self assert: ( spaceB eastEdge ) = ( spaceA westEdge ).      "Place B on North side of A."   container position: spaceB northOf: spaceA.   self assert: ( spaceB southEdge ) = ( spaceA northEdge ).      "Place B on South side  of A."   container position: spaceB southOf: spaceA.   self assert: ( spaceB northEdge ) = ( spaceA southEdge ).      </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test350assemblyDimensions</h3><pre>test350assemblyDimensions   "A HumAssembly dimensions enclose whatever is inside the assembly"   | container spaceA spaceB |      ""   container := HumAssembly new.   container length: 0 meter; width: 0 meter; height: 0 meter.      spaceA := ( HumSpace new ) length: 10 meter; width: 10 meter; height: 10 meter.   spaceB := ( HumSpace new ) length: 10 meter; width: 10 meter; height: 10 meter.      "Note: These positions are relative to the container`s origin."   container center: spaceA at: { 20 meter. 30 meter. 50 meter. }.   self assert: ( spaceA eastEdge = 25 meter).   self assert: ( spaceA northEdge = 35 meter ).   self assert: ( spaceA bottomEdge = 45 meter ).      self assert: ( spaceA westEdge = 15 meter ).   self assert: ( spaceA southEdge = 25 meter ).   self assert: ( spaceA topEdge = 55 meter ).      "Place B on top of A."   container position: spaceB onTopOf: spaceA.   self assert: ( spaceB bottomEdge ) = ( spaceA topEdge ).   self assert: ( container bottomEdge ) &lt; ( spaceA bottomEdge ).   self assert: ( container bbTopEdge ) &gt;= ( spaceB topEdge ).      "Place B under A."   container position: spaceB onBottomOf: spaceA.   self assert: ( spaceB topEdge ) = ( spaceA bottomEdge ).      "Place B on East side of A."   container position: spaceB eastOf: spaceA.   self assert: ( spaceB westEdge ) = ( spaceA eastEdge ).      "Place B on West side of A."   container position: spaceB westOf: spaceA.   self assert: ( spaceB eastEdge ) = ( spaceA westEdge ).      "Place B on North side of A."   container position: spaceB northOf: spaceA.   self assert: ( spaceB southEdge ) = ( spaceA northEdge ).      "Place B on South side  of A."   container position: spaceB southOf: spaceA.   self assert: ( spaceB northEdge ) = ( spaceA southEdge ).      "Test bounding box of the assembly."   self expect: ( 65 meter ) actual: ( container bbHeight ).   self expect: ( 25 meter ) actual: ( container bbWidth ).   self expect: ( 35 meter ) actual: ( container bbLength ).   "Test bounding box edges of the assembly."   self expect: ( 0 meter ) actual: ( container westEdge ).   self expect: ( 25 meter ) actual: ( container eastEdge ).   self expect: ( 35 meter ) actual: ( container northEdge ).   self expect: ( 0 meter ) actual: ( container southEdge ).   self expect: ( 0 meter ) actual: ( container bottomEdge ).   self expect: ( 65 meter ) actual: ( container topEdge ).         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test410surfaceAsHTML</h3><pre>test410surfaceAsHTML   "Test for usability -- Consider a layout like the PA."   | window htmlString |      "This #asHTML  feature is deferred until javascript code is written to enable it."   false ifFalse: [Transcript cr; show: '*** test410surfaceAsHTML TURNED OFF until javascript code is written to enable it '; cr.  ^self skip ].      window := HumSurface new width: '800 px'; height: '450 px'; id: 'window'.   "Get the SVG string for this assembly."   htmlString := window asHTML.      self assert: ( htmlString beginsWith: '&lt;html' ).   self assert: ( htmlString includesSubString: '&lt;canvas ' ).   self assert: ( htmlString includesSubString: ' id="window" ' ).   self assert: ( htmlString includesSubString: ' width="800 px" ' ).   self assert: ( htmlString includesSubString: ' height="450 px" ' ).          Transcript cr; show: 'from test410surfaceAsHTML '; cr; show: htmlString; cr.   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test470surfaceAssemblyAsHTML</h3><pre>test470surfaceAssemblyAsHTML   "Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."   | window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram htmlString diagramMenu |   "This feature is deferred until javascript code is written to enable it."   false ifFalse: [Transcript cr; show: '*** test470surfaceAssemblyAsHTML TURNED OFF until javascript code is written to enable it'; cr.       ^self skip ].   "NOTE: Dimensions used here are percentages of the container !!!"      "Create the main divisions."   window := HumSurface new width: '1300' ; height: '800'; id: 'window'.   menuStack := HumSurface new width: '1300'; height: '25'; top: 0; left: 0; id: 'menu stack'.   editStack := HumSurface new width: '800'; height: '75'; left: 0; id: 'edit stack'.   diagramStack := HumSurface new width: '500'; height: '75'; id: 'diagram stack'.   "Assemble them."   window place:  editStack below: menuStack.   window place: diagramStack below: menuStack.   window place: diagramStack rightOf: editStack.      "Create editStack divisions and assemble them."   editMenu := HumSurface new width: '800'; height: '25'; top: 0; left: 0; id: 'edit menu'.   codeView := HumSurface new width: '800'; height: '700'; id: 'code view'.   critiqueView := HumSurface new width: '800'; height: '25'; id: 'critique view'.      editStack place: codeView below: editMenu.   editStack place: critiqueView below: codeView.      "Create diagramStack divisions."   diagramMenu := HumSurface new width: '500'; height: '25'; left: 0; top: 0; id: 'diagram menu'.   planTreeDiagram := HumSurface new width: '500'; height: '200'; left: 0; top: 0; id: 'plan tree'.   roleRelationsDiagram := HumSurface new width: '500'; height: '200'; id: 'role relations'.   wordRelationsDiagram := HumSurface new width: '500'; height: '200'; id: 'word relations'.   vignetteDiagram := HumSurface new width: '500'; height: '200'; id: 'vignette relations'.        diagramStack place: planTreeDiagram below: diagramMenu.   diagramStack place: roleRelationsDiagram below:  planTreeDiagram.   diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.   diagramStack place: vignetteDiagram below: wordRelationsDiagram.      "Get the SVG string for this assembly."   htmlString := window asHTML .      self assert: ( htmlString beginsWith: '&lt;html' ).   self assert: ( htmlString includesSubString: '&lt;canvas ' ).   self assert: ( htmlString includesSubString: ' id="window" ' ).   self assert: ( htmlString includesSubString: ' id="edit stack" ' ).   self assert: ( htmlString includesSubString: ' id="diagram stack" ' ).   self assert: ( htmlString includesSubString: ' id="critique view" ' ).      Transcript cr; show: 'from test470surfaceAssemblyAsHTML'; cr; show: htmlString; cr.             </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test510surfaceAsHumScript</h3><pre>test510surfaceAsHumScript   "Test first principle: Produce a Hum action call.   The Hum script may be translated into some target language.   The target language could be a series of openGL calls, or PyQt, JavaScript canvas, et cetera.   "   | window script |      "This #asHTML  feature is deferred until javascript code is written to enable it."   true ifFalse: [Transcript cr; show: 'test510surfaceAsHumScript turned off'; cr.  ^self skip ].      window := HumSurface new initialize: 'px'; width: 800 px; height: 450 px; id: 'window'.   "Get the SVG string for this assembly."   script := window generateHumScript.      "Expect something like '. Painter: Paint surface with id 'window' width '800 px' height '450 px'.   "   self assert: ( script beginsWith: '. Painter:' ).   self assert: ( script includesSubString: 'Paint surface ' ).   self assert: ( script includesSubString: ' id ''window''' ).   self assert: ( script includesSubString: ' width ''800 px''' ).   self assert: ( script includesSubString: ' height ''450 px''' ).   self assert: ( script includesSubString: ' left ''0 px''' ).   self assert: ( script includesSubString: ' top ''0 px''' ).   self assert: ( script endsWith: '.' ).          "Transcript cr; show: 'from test510surfaceAsHumScript '; cr; show: script; cr."   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; test570surfaceAssemblyAsHumScript</h3><pre>test570surfaceAssemblyAsHumScript   "Test for usability -- Consider a layout like the PA -- This time use inches as the unit of measure."   | window menuStack editStack diagramStack editMenu codeView critiqueView planTreeDiagram roleRelationsDiagram wordRelationsDiagram vignetteDiagram script diagramMenu |   "This feature is deferred until javascript code is written to enable it."   true ifFalse: [Transcript cr; show: 'test570surfaceAssemblyAsHumScript turned off px'; cr. ^self skip ].   "NOTE: Dimensions used here are percentages of the container !!!"      "Create the main divisions."   window := HumSurface new initialize: 'px'; width: 1300 px; height: 800 px; id: 'window'.   menuStack := HumSurface new initialize: 'px'; width: 1300 px; height: 25 px; top: 0 px; left: 0 px; id: 'menu stack'.   editStack := HumSurface new initialize: 'px'; width: 800 px; height: 75 px; left: 0 px; id: 'edit stack'.   diagramStack := HumSurface new initialize: 'px'; width: 500 px; height: 75 px; id: 'diagram stack'.   "Assemble them."   window place:  editStack below: menuStack.   window place: diagramStack below: menuStack.   window place: diagramStack rightOf: editStack.      "Create editStack divisions and assemble them."   editMenu := HumSurface new initialize: 'px'; width: 800 px; height: 25 px; top: 0 px; left: 0 px; id: 'edit menu'.   codeView := HumSurface new initialize: 'px'; width: 800 px; height: 700 px; id: 'code view'.   critiqueView := HumSurface new initialize: 'px'; width: 800 px; height: 25 px; id: 'critique view'.      editStack place: codeView below: editMenu.   editStack place: critiqueView below: codeView.      "Create diagramStack divisions."   diagramMenu := HumSurface new initialize: 'px'; width: 500 px; height: 25 px; left: 0 px; top: 0 px; id: 'diagram menu'.   planTreeDiagram := HumSurface new initialize: 'px'; width: 500 px; height: 200 px; left: 0 px; top: 0 px; id: 'plan tree'.   roleRelationsDiagram := HumSurface new initialize: 'px'; width: 500 px; height: 200 px; id: 'role relations'.   wordRelationsDiagram := HumSurface new initialize: 'px'; width: 500 px; height: 200 px; id: 'word relations'.   vignetteDiagram := HumSurface new initialize: 'px'; width: 500 px; height: 200 px; id: 'vignette relations'.        diagramStack place: planTreeDiagram below: diagramMenu.   diagramStack place: roleRelationsDiagram below:  planTreeDiagram.   diagramStack place: wordRelationsDiagram below: roleRelationsDiagram.   diagramStack place: vignetteDiagram below: wordRelationsDiagram.      "Get the SVG string for this assembly."   script := window generateHumScript .      self assert: ( script beginsWith: '. Painter: ' ).   self assert: ( script includesSubString: 'surface' ).   self assert: ( script includesSubString: ' id ''window'' ' ).   self assert: ( script includesSubString: ' id ''edit stack'' ' ).   self assert: ( script includesSubString: ' id ''diagram stack'' ' ).   self assert: ( script includesSubString: ' id ''critique view'' ' ).   "   Transcript cr; show: 'from test570surfaceAssemblyAsHumScript px'; cr; show: script; cr.   "          </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testA110addPart</h3><pre>testA110addPart   "Add a part to an assembly. Check content and event handling"   | assembly part1 part2  |   assembly := HumAssembly id: 'assembly for testA110'.   part1 := HumSolid id: 'part1-testA110' height: 1.0 width: 2.0  length: 3.0.   part2 := HumSolid id: 'part2-testA110' height: 3.0 width: 2.0  length: 1.0.   assembly center: part1 at: { 1.0. 1.0. 1.0. }.   assembly center: part2 at: { 20.0. 20.0. 20.0. }.      "At this point part1 and part2 should be in assembly`s parts."   self expect: 2 actual: ( assembly parts size ).   "The assembly should be in the dependents of each part."   self expect: { assembly } actual: (part1 dependents asArray).   self expect: { assembly } actual: (part2 dependents asArray).       "Whan  part is changed, the assembly should be informed and activate its #changed actions."      "First check my test bed."   self eventSeen: 'not yet'.   self expect: {  } actual: ( assembly dependents asArray ).   assembly changed.   self expect: 'not yet' actual: (self eventSeen).   assembly addDependent: self.   self expect: { self } actual: ( assembly dependents asArray ).   assembly changed.   self expect: assembly actual: (self eventSeen).      "Now check for part to assembly notification."   self eventSeen: 'not yet'.   self expect: 'not yet' actual: (self eventSeen).   part2 slideUp: (1 meter).   self expect: assembly actual: (self eventSeen).                  </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testA210assembleAvatar</h3><pre>testA210assembleAvatar   "Create example to indicate development idea/s."   | avatar head torso upperArmLeft upperArmRight hips wheelLeft wheelRight |   head := HumSolid id: '' type: #elipsoid height: 0.3 width: 0.2 depth: 0.2.   torso := HumSolid id: '' type: #box height: 1.0 width: 0.5 depth: 0.3.   upperArmLeft := HumSolid id: '' type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.      upperArmRight := HumSolid id: 'upperArmRight'type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.   hips := HumSolid id: '' type: #box height: 0.25 width: 0.6 depth: 0.3.   wheelLeft := HumSolid id: '' type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.   wheelRight := HumSolid id: '' type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.      "Assemble."   avatar := HumAssembly new.   avatar center: head onTopOf: torso.   avatar position: upperArmLeft eastOf: torso. "Assume avatar is facing us."   avatar position: upperArmRight westOf: torso. "Assume avatar is facing us."   avatar position: hips onBottomOf: torso.   avatar position: wheelLeft eastOf: hips.   avatar position: wheelRight westOf: hips.   "Assert some expectations"   self assert: ( head bottomEdge closeTo: torso topEdge ) .  "Got a funky round-off error on this, but not on others."   self assert: ( hips topEdge = torso bottomEdge ).   self assert: ( wheelLeft westEdge = hips eastEdge ).      self assert: ( wheelRight eastEdge = hips westEdge ).   self assert: ( upperArmLeft westEdge = torso eastEdge ).   self assert: ( upperArmRight eastEdge = torso westEdge ).   "Head is centered. So edges are inboard from torso."   self assert: ( head eastEdge = torso eastEdge ) not.    self assert:  ( head westEdge = torso westEdge ) not.   "But some things were not constrained. So set those also."   upperArmLeft  topEdge: ( torso topEdge ).   upperArmRight topEdge: ( torso topEdge ).   wheelLeft  topEdge: ( hips topEdge ).   wheelRight topEdge: ( hips topEdge ).   "TODO: Check that constraints are effective."            </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testA220colorAvatar</h3><pre>testA220colorAvatar   "Create example to indicate development idea/s."   | avatar head torso upperArmLeft upperArmRight hips wheelLeft wheelRight |   head := HumSolid id: '' type: #elipsoid height: 0.3 width: 0.2 depth: 0.2.   torso := HumSolid id: '' type: #box height: 1.0 width: 0.5 depth: 0.3.   upperArmLeft := HumSolid id: '' type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.      upperArmRight := HumSolid id: '' type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.   hips := HumSolid id: '' type: #box height: 0.25 width: 0.5 depth: 0.3.   wheelLeft := HumSolid id: '' type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.   wheelRight := HumSolid id: '' type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.      "Assemble."   avatar := HumAssembly new.   avatar position: head onTopOf: torso.   avatar position: upperArmLeft eastOf: torso. "Assume avatar is facing us."   avatar position: upperArmRight westOf: torso. "Assume avatar is facing us."   avatar position: hips onBottomOf: torso.   avatar position: wheelLeft eastOf: hips.   avatar position: wheelRight westOf: hips.   "Color"   head color: ( Color paleBuff ).   torso color: ( Color green ).   upperArmLeft color: ( Color paleGreen ).      upperArmRight color: ( Color paleGreen ).   hips color: ( Color blue ).   wheelLeft color: ( Color paleBlue ).   wheelRight color: ( Color paleBlue ).   "This is a usability test. Does it pass?"   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testA410x3dAssembly</h3><pre>testA410x3dAssembly   "render the objects in HumAssembly"   | avatar head torso "upperArmLeft upperArmRight hips wheelLeft wheelRight" x3d file |   head := HumSolid id: #head type: #elipsoid height: 0.3 width: 0.2 depth: 0.2.   torso := HumSolid id: #torso type: #box height: 1.0 width: 0.5 depth: 0.3.   "TODO: Most parts of this assembly are omitted to temporarily simplify this test. ***"   "upperArmLeft := HumSolid id: #upperArmLeft type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.      upperArmRight := HumSolid id: #upperArmRight type: #elipsoid height: 0.5 width: 0.1 depth: 0.1.   hips := HumSolid id: #hips type: #box height: 0.25 width: 0.5 depth: 0.3.   wheelLeft := HumSolid id: #wheelLeft type: #elipsoid height: 0.5 width: 0.1 depth: 0.5.   wheelRight := HumSolid id: wheelRight type: #elipsoid height: 0.5 width: 0.1 depth: 0.5."      "Assemble."   avatar := HumAssembly new.   avatar id: #avatar.   avatar position: head onTopOf: torso.   "Assume avatar is facing us."   "avatar position: upperArmLeft eastOf: torso.   avatar position: upperArmRight westOf: torso.    avatar position: hips onBottomOf: torso.   avatar position: wheelLeft eastOf: hips.   avatar position: wheelRight westOf: hips."   "Color"   head color: ( Color paleBuff ).   torso color: ( Color green )."   upperArmLeft color: ( Color paleGreen ).      upperArmRight color: ( Color paleGreen ).   hips color: ( Color blue ).   wheelLeft color: ( Color paleBlue ).   wheelRight color: ( Color paleBlue )."   "render"   x3d := avatar asX3D.   "Transcript cr; show: 'testS410x3dAssembly'; cr; show: x3d; cr."      "Write code out to a file for easier inspection and possible compilation."   file := StandardFileStream fileNamed: 'testS410x3dAssembly.x3d'.   file nextPutAll: x3d.   file close.</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testA420trailerExample</h3><pre>testA420trailerExample   "Test DSL usability - No code is generated by this test."   | trailer deckLayer wallLayer interiorLayer      interiorLength interiorWidth interiorHeight       deck  deckThickness     wallThickness wallHeight eastWall westWall northWall southWall      bed bedClearance bedWalkSpace      centerAisle eastCloset westCloset closetDepth      bulkheadWidth bulkheadThickness topSpace     toilet handSink shower     galleyBulkhead shoulderWidth galleyLength galley galleyTable   |   trailer := (HumAssembly new) id: 'trailer'.   deckLayer := (HumLayer new) id: 'deck layer'.   wallLayer := (HumLayer new) id: 'wall layer'.   interiorLayer := (HumLayer new) id: 'interior layer'.      "deck"   deckThickness   := 0.20 meters.   interiorLength  := 6.00 meters.   interiorWidth   := 2.00 meters.   interiorHeight  := 2.00 meters.      deck :=  HumSolid id: 'deck' type: #box height: deckThickness width: interiorWidth depth: interiorLength.   deckLayer addPart: deck.  "walls"   wallThickness := 0.10 meters.   wallHeight    := 1.00 meters.   northWall := HumSolid id: 'northWall' type: #box height: wallHeight width: interiorWidth depth: wallThickness.   southWall := HumSolid id: 'southWall' type: #box height: wallHeight width: interiorWidth depth: wallThickness.   eastWall := HumSolid id: 'eastWall' type: #box height: wallHeight width: wallThickness depth: interiorLength.   westWall := HumSolid id: 'westWall' type: #box height: wallHeight width: wallThickness depth: interiorLength.   "Assembly deck and walls"   trailer position: northWall northOf: deck.   trailer position: southWall southOf: deck.   trailer position: eastWall eastOf: deck.   trailer position: westWall westOf: deck.   wallLayer addParts: { northWall. southWall. eastWall. westWall. }.   "======= bed room ========"   bed := HumSolid id: 'bed' type: #box height: (0.5 meters) width: (1.2 meters) depth: (2.0 meters).   trailer position: bed southOf: northWall.   trailer position: bed onTopOf: deck.   bedClearance := 0.50 meters.   bedWalkSpace := HumSpace id: 'bedWalkSpace' height: interiorHeight width: interiorWidth depth: bedClearance .   "closets"   closetDepth   := 0.50 meters.   bulkheadWidth := 0.70 meters.  eastCloset := HumSolid   id: 'eastCloset' type: #box height: interiorHeight width: bulkheadWidth depth: closetDepth.   westCloset := HumSolid   id: 'westCloset' type: #box height: interiorHeight width: bulkheadWidth depth: closetDepth.   centerAisle := HumSpace id: 'centerAisle' height: interiorHeight width: (interiorWidth - (bulkheadWidth*2.0)) depth: interiorLength.   trailer center: centerAisle onTopOf: deck.  trailer position: bedWalkSpace southOf: bed.   trailer position: eastCloset eastOf: centerAisle.   trailer position: eastCloset southOf: bedWalkSpace.   trailer position: westCloset westOf: centerAisle.   trailer position: westCloset southOf: bedWalkSpace.   interiorLayer addParts: { bed. bedWalkSpace. eastCloset. westCloset. centerAisle. }. "bed room parts"   "======= bath room ==========="   toilet := HumSolid id: 'toilet' type: #box height: (0.40 meters) width: (0.20 meters) depth: (0.80 meters).   trailer position: toilet onTopOf: deck.   trailer position: toilet southOf: westCloset.   trailer position: toilet eastOf: westWall.   "Postion hand sink above toilet but below topSpace - top will be ~ 1 meter ~ 40 inches above floor"   handSink := HumSolid id: 'hand sink' type: #box height: (0.20 meters) width: (0.20 meters) depth: (0.80 meters).   topSpace := HumSpace id: 'top space' height: (interiorHeight / 2.0) width: interiorWidth depth: interiorLength.   trailer center: topSpace over: deck.   trailer position: topSpace over: westWall.   trailer center: handSink above: toilet.   trailer position: handSink below: topSpace.   "Position shower by East wall (east of center aisle in bath roos)"   shower := HumSpace id: 'shower'  height: interiorHeight width: bulkheadWidth depth: (0.80 meters).    trailer position: shower onTopOf: deck.   trailer position: shower westOf: eastWall.   trailer position: shower southOf: eastCloset.   interiorLayer addParts: { toilet. handSink. shower. }.      "======== galley =========="   bulkheadThickness := (0.04 meter).   galleyBulkhead := HumSolid id: 'galleyBulkhead' type: #box                               height: interiorHeight width: bulkheadWidth depth: bulkheadThickness.   galleyLength := (0.50 meters) "space for 3-burner stove"                 + (1.20 meters) "space for kichen sink and food prep".   "Assure shoulder room at table"    shoulderWidth := (0.80 meters).   ( galleyLength &lt; ( shoulderWidth * 2.0)  ) ifTrue: [ galleyLength := ( shoulderWidth * 2.0) ].   galleyTable := HumSolid id: 'galleyTable' type: #box                           height: (0.02 meters) width: (0.6 meter) depth: galleyLength.   galley := HumSolid id: 'galley' type: #box                            height: (1 meter) width: (0.4 meters) depth: galleyLength.   trailer position: galleyBulkhead above: deck.   trailer position: galleyBulkhead southOf: shower.   trailer position: galley above: deck.   trailer position: galley southOf: galleyBulkhead.   trailer position: galleyTable southOf: galleyBulkhead.   trailer position: galleyTable below: topSpace.      interiorLayer addParts: { galleyBulkhead. galley. galleyTable. }.      "Reset interior length"   interiorLength := bed depth + bedWalkSpace depth + eastCloset depth                    + shower depth                    + galleyBulkhead depth + galley depth.   "Transcript cr; show: 'testS420trailerExample'; cr; show: 'corrected interior length = ', interiorLength asString; cr."   self assert: (interiorLength &gt;= (2.0 + 0.5 + 0.5 + 0.8 + (2*0.8) ) meters ).   "Correct south wall position"   trailer position: southWall southOf: deck.         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testA425trailerExample2</h3><pre>testA425trailerExample2   "Test DSL usability -- change #depth to #length -- No code is generated."   | trailer deckLayer wallLayer interiorLayer      interiorLength interiorWidth interiorHeight       deck  deckThickness     wallThickness wallHeight eastWall westWall northWall southWall      bed bedClearance bedWalkSpace      centerAisle eastCloset westCloset closetDepth      bulkheadWidth bulkheadThickness topSpace     toilet handSink shower     galleyBulkhead shoulderWidth galleyLength galley galleyTable   |   trailer := (HumAssembly new) id: 'trailer'.   deckLayer := (HumLayer new) id: 'deck layer'.   wallLayer := (HumLayer new) id: 'wall layer'.   interiorLayer := (HumLayer new) id: 'interior layer'.      "deck"   deckThickness   := 0.20 meters.   interiorLength  := 6.00 meters.   interiorWidth   := 2.00 meters.   interiorHeight  := 2.00 meters.      deck :=  HumSolid id: 'deck' type: #box height: deckThickness width: interiorWidth length: interiorLength.   deckLayer addPart: deck.  "walls"   wallThickness := 0.10 meters.   wallHeight    := 1.00 meters.   northWall := HumSolid id: 'northWall' type: #box height: wallHeight width: interiorWidth length: wallThickness.   southWall := HumSolid id: 'southWall' type: #box height: wallHeight width: interiorWidth length: wallThickness.   eastWall := HumSolid id: 'eastWall' type: #box height: wallHeight width: wallThickness length: interiorLength.   westWall := HumSolid id: 'westWall' type: #box height: wallHeight width: wallThickness length: interiorLength.   "Assembly deck and walls"   trailer position: northWall northOf: deck.   trailer position: southWall southOf: deck.   trailer position: eastWall eastOf: deck.   trailer position: westWall westOf: deck.   wallLayer addParts: { northWall. southWall. eastWall. westWall. }.   "======= bed room ========"   bed := HumSolid id: 'bed' type: #box height: (0.5 meters) width: (1.2 meters) length: (2.0 meters).   trailer position: bed southOf: northWall.   trailer position: bed onTopOf: deck.   bedClearance := 0.50 meters.   bedWalkSpace := HumSpace id: 'bedWalkSpace' height: interiorHeight width: interiorWidth length: bedClearance .   "closets"   closetDepth   := 0.50 meters.   bulkheadWidth := 0.70 meters.  eastCloset := HumSolid   id: 'eastCloset' type: #box height: interiorHeight width: bulkheadWidth length: closetDepth.   westCloset := HumSolid   id: 'westCloset' type: #box height: interiorHeight width: bulkheadWidth length: closetDepth.   centerAisle := HumSpace id: 'centerAisle' height: interiorHeight width: (interiorWidth - (bulkheadWidth*2.0)) length: interiorLength.   trailer center: centerAisle onTopOf: deck.  trailer position: bedWalkSpace southOf: bed.   trailer position: eastCloset eastOf: centerAisle.   trailer position: eastCloset southOf: bedWalkSpace.   trailer position: westCloset westOf: centerAisle.   trailer position: westCloset southOf: bedWalkSpace.   interiorLayer addParts: { bed. bedWalkSpace. eastCloset. westCloset. centerAisle. }. "bed room parts"   "======= bath room ==========="   toilet := HumSolid id: 'toilet' type: #box height: (0.40 meters) width: (0.20 meters) length: (0.80 meters).   trailer position: toilet onTopOf: deck.   trailer position: toilet southOf: westCloset.   trailer position: toilet eastOf: westWall.   "Postion hand sink above toilet but below topSpace - top will be ~ 1 meter ~ 40 inches above floor"   handSink := HumSolid id: 'hand sink' type: #box height: (0.20 meters) width: (0.20 meters) length: (0.80 meters).   topSpace := HumSpace id: 'top space' height: (interiorHeight / 2.0) width: interiorWidth length: interiorLength.   trailer center: topSpace over: deck.   trailer position: topSpace over: westWall.   trailer center: handSink above: toilet.   trailer position: handSink below: topSpace.   "Position shower by East wall (east of center aisle in bath roos)"   shower := HumSpace id: 'shower'  height: interiorHeight width: bulkheadWidth length: (0.80 meters).    trailer position: shower onTopOf: deck.   trailer position: shower westOf: eastWall.   trailer position: shower southOf: eastCloset.   interiorLayer addParts: { toilet. handSink. shower. }.      "======== galley =========="   bulkheadThickness := (0.04 meter).   galleyBulkhead := HumSolid id: 'galleyBulkhead' type: #box                               height: interiorHeight width: bulkheadWidth length: bulkheadThickness.   galleyLength := (0.50 meters) "space for 3-burner stove"                 + (1.20 meters) "space for kichen sink and food prep".   "Assure shoulder room at table"    shoulderWidth := (0.80 meters).   ( galleyLength &lt; ( shoulderWidth * 2.0)  ) ifTrue: [ galleyLength := ( shoulderWidth * 2.0) ].   galleyTable := HumSolid id: 'galleyTable' type: #box                           height: (0.02 meters) width: (0.6 meter) length: galleyLength.   galley := HumSolid id: 'galley' type: #box                            height: (1 meter) width: (0.4 meters) length: galleyLength.   trailer position: galleyBulkhead above: deck.   trailer position: galleyBulkhead southOf: shower.   trailer position: galley above: deck.   trailer position: galley southOf: galleyBulkhead.   trailer position: galleyTable southOf: galleyBulkhead.   trailer position: galleyTable below: topSpace.      interiorLayer addParts: { galleyBulkhead. galley. galleyTable. }.      "Reset interior length"   interiorLength := bed length + bedWalkSpace length + eastCloset length                    + shower length                    + galleyBulkhead length + galley length.   "Transcript cr; show: 'testS425trailerExample'; cr; show: 'corrected interior length = ', interiorLength asString; cr."   self assert: (interiorLength &gt;= (2.0 + 0.5 + 0.5 + 0.8 + (2*0.8) ) meters ).   "Correct south wall position"   trailer position: southWall southOf: deck.         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testA430showTrailerLayoutTable</h3><pre>testA430showTrailerLayoutTable   "Display a table of the trailer parts edges.   ... Testing HumSolid layout positioning.   "   | trailer |      false ifFalse: [ Transcript cr; show: 'testS430showTrailerLayoutTable is turned off';cr. ^self.].   trailer := self buildTrailerAssembly.   "table heading"   Transcript cr; show: ''; cr.   Transcript show: ('id' padded: #left to: 16 with: $.), ' north-south'; cr.   "table rows"   (trailer parts)      do: [ :part | "for each part:"         Transcript show: ((part id) padded: #left to: 16 with: $.  )                        , String tab, (part mm: #southEdge)                        , String tab, (part mm: #northEdge);                       cr.         ].</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testA530assemblyAsThreeJS</h3><pre>testA530assemblyAsThreeJS   "Render a box as a ThreeJS cube"   | assembly js expect |   assembly := self buildTrailerAssembly.      js := assembly asThreeJS.      "Expect this prolog."      expect := 'var trailer = new THREE.Geometry();'.   self assert: ( ('*',expect,'*') match: js ).     "Expect this code fragment -- one of many like this."   expect := 'var southWall = new THREE.Mesh( ( new THREE.CubeGeometry( 2.000, 0.100, 1.000 )  )                                     , ( new THREE.MeshBasicMaterial( { color: 0x808080 } )  )                                     );         southWall.position.set( 1.000, -0.050, 0.500 );            THREE.GeometryUtils.merge( trailer, southWall );'.   self assert: ( ('*',expect,'*') match: js ).   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testA540sceneAsThreeJS</h3><pre>testA540sceneAsThreeJS   "Render a box as a ThreeJS cube"   | scene js expect |   scene := self buildTrailerScene.   scene id: 'theScene'.      js := scene asThreeJS.
   "Expect this scene prolog"   expect := 'scene = new THREE.Scene();'.   self assert: ( ('*',expect,'*') match: js ).      "Expect this layer prolog. One of several like this."      expect := 'var wallLayer = new THREE.Geometry();'.   self assert: ( ('*',expect,'*') match: js ).     "Expect this code fragment -- one of many like this."   expect := 'var southWall = new THREE.Mesh( ( new THREE.CubeGeometry( 2.000, 0.100, 1.000 )  )                                     , ( new THREE.MeshBasicMaterial( { color: 0x808080 } )  )                                     );         southWall.position.set( 1.000, -0.050, 0.500 );            THREE.GeometryUtils.merge( wallLayer, southWall );'.   self assert: ( ('*',expect,'*') match: js ).   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testA550sceneAsThreeJSinHTML</h3><pre>testA550sceneAsThreeJSinHTML   "Render a box as a ThreeJS cube"   | scene js  html |   scene := self buildTrailerScene.   scene id: 'theScene'.      js := scene asThreeJS.
   html := scene asThreeJSinHTML.      "write it to a file as see if it compiles and renders"   HumCalculator writeString: html toFileNamed: ((scene asCamelCase),'.html').</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testA600VPythonReadMe</h3><pre>testA600VPythonReadMe   "I started this when my VPython environment started working again.   However: The X3D (markup language) has better support,       is a standard of sorts as a VRML descendent.   I will refocus my 3D efforts on X3D.   "   "2016-11-01:   HOWEVER, VPython is much more accessable from my point of view.   X3D implementations are mainly in the web browser - which means I would have to build Scribe code in JavaScript instead of Python.   "   "If I want to use a web browser platform as my client,   Three.js is a somewhat better environment than X3D.   "</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testA625VPythonTrailer</h3><pre>testA625VPythonTrailer   | trailer pythonCode scene file |   trailer := self buildTrailerAssembly.   scene := HumScene new.   scene addPart: trailer.   pythonCode := scene asVPython.   "Generated code should contain BoxThing() instances."   self assert: ( '*BoxThing(*' match: pythonCode ).   "TODO: Generated code should contain positioning statements."      "Write code out to a file for easier inspection and possible compilation."   file := StandardFileStream fileNamed: 'testS625VPythonTrailer.py'.   file nextPutAll: pythonCode.   file close.   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testC210CreateHumCanvas</h3><pre>testC210CreateHumCanvas   "HumCanvas provides a wrapper on actual implementation."   | canvas |   canvas := HumCanvas new.     "HumCanvas provides a wrapper on the physical implentation. (So we can move to another one if needed)"   "For time being, use the Squeak Canvase API -- May change my mind later."   self assert: ( canvas isKindOf: DisplayObject ). "Provides most of the drawing API."   self assert: ( canvas formCanvas isKindOf: FormCanvas ). "FormCanvas provides most of API."         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testC211CreateHumCanvas</h3><pre>testC211CreateHumCanvas   "HumCanvas provides a wrapper on actual implementation."   | canvas |   canvas := HumCanvas extent: 400@300.     "HumCanvas provides a wrapper on the physical implentation. (So we can move to another one if needed)"   "For time being, use the Squeak Canvase API -- May change my mind later."   self assert: ( canvas isKindOf: DisplayObject ). "Provides most of the drawing API."   self assert: ( canvas formCanvas isKindOf: FormCanvas ). "FormCanvas provides most of API."         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testC220DrawRawPolygon</h3><pre>testC220DrawRawPolygon   "HumCanvas provides a wrapper on actual implementation."   | canvas rawPolygon  |   canvas := FormCanvas extent: 400@300 depth: nil origin: 90@90 clipRect: (Rectangle origin: 0@0 extent: 100@100 ).     "Triangle"   rawPolygon := Polygon new.   rawPolygon      addVertex: 10@11;   "bottom left"      addVertex: 20@12;   "bottom right"      addVertex: 15@33.   "apex (down or up?)"      "Draw it on canvas"   canvas drawPolygon: (rawPolygon vertices) fillStyle: (Color red).     canvas drawPolygon: (rawPolygon vertices) fillStyle: (Color red) borderWidth: 3 borderColor: (Color black).   canvas drawPolygon: (rawPolygon vertices) color: (Color red) borderWidth: 3 borderColor: (Color black).         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testC222DrawHumPolygon</h3><pre>testC222DrawHumPolygon   "HumCanvas provides a wrapper on actual implementation."   | canvas humPolygon  |   canvas := HumCanvas extent: 400@350.   "Triangle"   humPolygon := HumPolygon borderColor: (Color black) fillColor: (Color red).   humPolygon      addVertex: { 100 px. 110 px.};    "bottom left"      addVertex: { 200 px. 120 px.};   "bottom right"      addVertex:  { 150 px. 330 px. }.   "apex (down or up?)"      "Draw it on canvas -- Note: HumCanvas delegates to FormCanvas."   canvas drawHumPolygon: humPolygon.          </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testD110CreateDiagram</h3><pre>testD110CreateDiagram   "Create a diagram with three nodes and two connections."   | diagram nodeA nodeB nodeC |   diagram := HumDiagram new.   nodeA := HumEntity title: 'A'.   nodeB := HumEntity title: 'B'.   nodeC := HumEntity title: 'C'.      diagram       addNode: nodeA;      addNode: nodeB;      addNode: nodeC.         self assert: ( diagram nodes size = 3 ).      diagram      addConnection: ( nodeA -&gt; nodeB );      addConnection: ( nodeB -&gt; nodeC ).        self assert: ( diagram connections size = 2 ).            </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testD210LayoutDiagram</h3><pre>testD210LayoutDiagram   "Create a diagram with three nodes and two connections."   | diagram nodeA nodeB nodeC |   diagram := HumDiagram new.   nodeA := HumEntity title: 'A'.   nodeB := HumEntity title: 'B'.   nodeC := HumEntity title: 'C'.      diagram       addNode: nodeA;      addNode: nodeB;      addNode: nodeC.         self assert: ( diagram nodes size = 3 ).      diagram      addConnection: ( nodeA -&gt; nodeB );      addConnection: ( nodeB -&gt; nodeC ).        self assert: ( diagram connections size = 2 ).  "Layout the diagram."   diagram layoutDiagramWithNodeExtent: (16@8) nodeSpacing: (4@4).   self assert: ( diagram mapNodePosition size = 3 ).   self assert: ( diagram mapPositionNode size = 3 ).   self expect: { (0@0). (12@0). (-12@0) } sorted actual: ( diagram mapPositionNode keys sorted ).            </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testD220LayoutDiagram</h3><pre>testD220LayoutDiagram   "Create a diagram with four nodes and three connections."   | diagram nodeA nodeB nodeC nodeD nNodes |   diagram := HumDiagram new.   nodeA := HumEntity title: 'A'.   nodeB := HumEntity title: 'B'.   nodeC := HumEntity title: 'C'.   nodeD := HumEntity title: 'D'.      diagram       addNode: nodeA;      addNode: nodeB;      addNode: nodeC.         nNodes := diagram nodes size.   self expect: 3 actual: nNodes.      diagram      addConnection: ( nodeA -&gt; nodeB );      addConnection: ( nodeB -&gt; nodeC );      addConnection: ( nodeB -&gt; nodeD ).  "Fan-out downstream from B"        self assert: ( diagram connections size = 3 ).  "Layout the diagram."   diagram layoutDiagramWithNodeExtent: (16@8) nodeSpacing: (4@4).   self assert: ( diagram mapNodePosition size = 4 ).   self assert: ( diagram mapPositionNode size = 4 ).   self expect: { (0@0). (-12@0). (12@0). (12@8) } sorted actual: ( diagram mapPositionNode keys sorted ).            </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testD230LayoutDiagram</h3><pre>testD230LayoutDiagram   "Create a diagram with five nodes and four connections."   | diagram nodeA1 nodeA2 nodeB nodeC nodeD |   diagram := HumDiagram new.   nodeA1 := HumEntity title: 'A1'.   nodeA2 := HumEntity title: 'A2'.   nodeB := HumEntity title: 'B'.   nodeC := HumEntity title: 'C'.   nodeD := HumEntity title: 'D'.      diagram       addNode: nodeA1;      addNode: nodeA2;      addNode: nodeB;      addNode: nodeC;      addNode: nodeD.         self assert: ( diagram nodes size = 5 ).      diagram      addConnection: ( nodeA1 -&gt; nodeB );      addConnection: ( nodeA2 -&gt; nodeB ); "Fan-in upstream from B"      addConnection: ( nodeB -&gt; nodeC );      addConnection: ( nodeB -&gt; nodeD ).  "Fan-out downstream from B"        self assert: ( diagram connections size = 4 ).  "Layout the diagram."   diagram layoutDiagramWithNodeExtent: (16@8) nodeSpacing: (4@4).   self assert: ( diagram mapNodePosition size = 5 ).   self assert: ( diagram mapPositionNode size = 5 ).      self assert: (( diagram mapNodePosition ) at: nodeB) equals: ( 0@0 ).                  "Note nodeC and nodeD will be assigned 12@0 or 12@8. But the choice may be random."         self assert: (( diagram mapNodePosition ) at: nodeC) equals: (12@0) or: (12@8).   self assert: (( diagram mapNodePosition ) at: nodeD) equals: (12@0) or: (12@8).   self assert: (( diagram mapNodePosition ) at: nodeC) ~= (( diagram mapNodePosition ) at: nodeD).      "Note nodeC and nodeD will be assigned -12@0 or -12@8. But the choice may be random."         self assert: (( diagram mapNodePosition ) at: nodeA1) equals: (-12@0) or: (-12@8).   self assert: (( diagram mapNodePosition ) at: nodeA2) equals: (-12@0) or: (-12@8).   self assert: (( diagram mapNodePosition ) at: nodeA1) ~= (( diagram mapNodePosition ) at: nodeA2).               "diagram inspect."   self expect: { (0@0). (12@0). (-12@0). (12@8). (-12@8). } sorted            actual: ( diagram mapPositionNode keys sorted ).   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testD310DistanceBetweenNodes</h3><pre>testD310DistanceBetweenNodes   "Calculate the (layout) distance between two nodes."   | diagram nodeA nodeB nodeC distance |   diagram := HumDiagram new.   nodeA := HumEntity title: 'A'.   nodeB := HumEntity title: 'B'.   nodeC := HumEntity title: 'C'.      diagram       addNode: nodeA;      addNode: nodeB;      addNode: nodeC.         self assert: ( diagram nodes size = 3 ).      diagram      addConnection: ( nodeA -&gt; nodeB );      addConnection: ( nodeB -&gt; nodeC );      addConnection: ( nodeA -&gt; nodeC ).        self assert: ( diagram connections size = 3 ).   "Force the layout 3-4-5 triangle to make this test easier"   diagram setNode: nodeA position: (0@0).   diagram setNode: nodeB position: (40@0).   diagram setNode: nodeC position: (40@30).      "The distance from nodeA to nodeC should be 50."   distance := diagram layoutDistanceFromNode: nodeA toNode: nodeC.   self assert: distance equals: 50.               </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testD321EnergyBetweenNodes</h3><pre>testD321EnergyBetweenNodes   "Calculate the (layout) force between two nodes."   | diagram nodeA nodeB nodeC forceA forceB |   diagram := HumDiagram new.   nodeA := HumEntity title: 'A'.   nodeB := HumEntity title: 'B'.   nodeC := HumEntity title: 'C'.      diagram       addNode: nodeA;      addNode: nodeB;      addNode: nodeC.         self assert: ( diagram nodes size = 3 ).      diagram      addConnection: ( nodeA -&gt; nodeB ).      ";      addConnection: ( nodeB -&gt; nodeC );      addConnection: ( nodeA -&gt; nodeC ).      "  self assert: ( diagram connections size = 1 ).   "Force the layout to make this test easier"   diagram setNode: nodeA position: (0@0).   diagram setNode: nodeB position: (2@0).      forceA := diagram layoutEnergyOnNode: nodeA fromNode: nodeB.   forceB := diagram layoutEnergyOnNode: nodeB fromNode: nodeA.      self assert: ( forceA = forceB ).   self assert: ( forceA &gt;= 0 ).                        </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testE110EditorPosition</h3><pre>testE110EditorPosition   "The editor owns a (cursor) position."   | editor |   editor := HumEditor new.   "Initial position is at front of first line."   self assert: editor lineIndex equals: 1.   self assert: editor characterIndex equals: 0.   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testE120EditorInsertCharacterAtEndOfLine</h3><pre>testE120EditorInsertCharacterAtEndOfLine   "When we insert a character, the cursor advances and the character is in the text string."   | editor |   "Initial position of the cursor is line 1, column 1"   editor := HumEditor new.   self for: ( editor lineIndex ) expect:  1.   self for: ( editor characterIndex ) expect:  0.   self for: ( editor text string ) expect:  ('',String cr).      "When a character is inserted at the cursor position, the cursor advances."   editor insertCharacter: $x.   self for: ( editor characterIndex ) expect:  1.      "And, of course, the text has the new character."   self for: ( editor text string ) expect:  ('x',String cr).            "Insert another character . . ."   editor insertCharacter: $y.   self for: ( editor characterIndex ) expect:  2.   self for: ( editor text string ) expect:  ('xy',String cr).            "Editor is a controller. Text is a model. When text is changed, it issues a change notice."   editor text addDependent: self. "This TestCase instance will receive #update: call."   editor insertCharacter: $z.   self assert: (self lastChange = editor text ).   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testE121EditorInsertCharacterAtFrontOfLine</h3><pre>testE121EditorInsertCharacterAtFrontOfLine   "When we insert a character, the cursor advances and the character is in the text string."   | editor |   "Initial position of the cursor is line 1, column 1"   editor := HumEditor new.   self for: ( editor lineIndex ) expect:  1.   self for: ( editor characterIndex ) expect:  0.   self for: ( editor text string ) expect:  ('',String cr).      "When a character is inserted at the cursor position, the cursor advances."   editor insertCharacter: $x.   self for: ( editor characterIndex ) expect:  1.      "And, of course, the text has the new character."   self for: ( editor text string ) expect:  ('x',String cr).            "Insert another character, but at the front of the line."   editor characterIndex: 0.   editor insertCharacter: $y.   self for: ( editor characterIndex ) expect:  1.   self for: ( editor text string ) expect:  ('yx',String cr).      </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testE130EditorInsertLine</h3><pre>testE130EditorInsertLine   "When we insert a line, the cursor advances to the beginning of the new line."   | editor |   "Initial position of the cursor is line 1, column 1"   editor := HumEditor new.   self for: ( editor lineIndex ) expect:  1.   self for: ( editor characterIndex ) expect:  0.   self for: ( editor text string ) expect:  ('',String cr).      "When a character is inserted at the cursor position, the cursor advances."   editor insertCharacter: $x.   self for: ( editor characterIndex ) expect:  1.      "And, of course, the text has the new character."   self for: ( editor text string ) expect:  ('x',String cr).            "Insert another character . . ."   editor insertCharacter: $y.   self for: ( editor characterIndex ) expect:  2.   self for: ( editor text string ) expect:  ('xy',String cr).            "Insert an empty line."   editor insertLine.   self for: ( editor lineIndex ) expect:  2.   self for: ( editor characterIndex ) expect:  0.   self for: ( editor text string ) expect:  ('xy',String cr, String cr).      "We should see event"   editor text addDependent: self.   editor insertLine.   self assert: ( self lastChange == editor text ).      </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testE131EditorInsertTwoLines</h3><pre>testE131EditorInsertTwoLines   "When we insert a line, the cursor advances to the beginning of the new line."   | editor |   "Initial position of the cursor is line 1, column 1"   editor := HumEditor new.   self for: ( editor lineIndex ) expect:  1.   self for: ( editor characterIndex ) expect:  0.   self for: ( editor text string ) expect:  ('',String cr).      "When a character is inserted at the cursor position, the cursor advances."   editor insertCharacter: $x.   self for: ( editor characterIndex ) expect:  1.      "And, of course, the text has the new character."   self for: ( editor text string ) expect:  ('x',String cr).            "Insert another character . . ."   editor insertCharacter: $y.   self for: ( editor characterIndex ) expect:  2.   self for: ( editor text string ) expect:  ('xy',String cr).            "Insert an empty line."   editor insertLine.   editor insertLine.   self for: ( editor lineIndex ) expect:  3.   self for: ( editor characterIndex ) expect:  0.   self for: ( editor text string ) expect:  ('xy', String cr, String cr, String cr).      </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testE140EditorDeleteCharacterAtEndOfLine</h3><pre>testE140EditorDeleteCharacterAtEndOfLine   "When we delete a character, the cursor decrements    and the character is no longer in the text string."   | editor |   "Initial position of the cursor is line 1, column 1"   editor := HumEditor new.   self for: ( editor lineIndex ) expect:  1.   self for: ( editor characterIndex ) expect:  0.   self for: ( editor text string ) expect:  ('',String cr).      "When a character is inserted at the cursor position, the cursor advances."   editor insertCharacter: $x.   self for: ( editor characterIndex ) expect:  1.      "And, of course, the text has the new character."   self for: ( editor text string ) expect:  ('x',String cr).            "Insert another character . . ."   editor insertCharacter: $y.   self for: ( editor characterIndex ) expect:  2.   self for: ( editor text string ) expect:  ('xy',String cr).            "Delete the character at end of line."   editor text addDependent: self.   editor deletePriorCharacter.   self for: ( editor characterIndex ) expect:  1.   self for: ( editor text string ) expect:  ('x',String cr).      self assert: (self lastChange == editor text ).      </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testE141EditorDeleteCharacterAtStartOfLine</h3><pre>testE141EditorDeleteCharacterAtStartOfLine   "When we delete a character, the cursor decrements    and the character is no longer in the text string."   | editor |   "Initial position of the cursor is line 1, column 1"   editor := HumEditor new.   self for: ( editor lineIndex ) expect:  1.   self for: ( editor characterIndex ) expect:  0.   self for: ( editor text string ) expect:  ('',String cr).      "When a character is inserted at the cursor position, the cursor advances."   editor insertCharacter: $x.   self for: ( editor characterIndex ) expect:  1.      "And, of course, the text has the new character."   self for: ( editor text string ) expect:  ('x',String cr).            "Insert another character . . ."   editor insertCharacter: $y.   self for: ( editor characterIndex ) expect:  2.   self for: ( editor text string ) expect:  ('xy',String cr).            "Delete the character at end of line."   editor deletePriorCharacter.   self for: ( editor characterIndex ) expect:  1.   self for: ( editor text string ) expect:  ('x',String cr).         "Delete the character at start of line."   editor deletePriorCharacter.   self for: ( editor characterIndex ) expect:  0.   self for: ( editor text string ) expect:  ('',String cr).         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testE142EditorIgnoresDeleteWhenCursorAtStartOfLine</h3><pre>testE142EditorIgnoresDeleteWhenCursorAtStartOfLine   "When we delete a character, the cursor decrements    and the character is no longer in the text string."   | editor |   "Initial position of the cursor is line 1, column 1"   editor := HumEditor new.   self for: ( editor lineIndex ) expect:  1.   self for: ( editor characterIndex ) expect:  0.   self for: ( editor text string ) expect:  ('',String cr).      "When a character is inserted at the cursor position, the cursor advances."   editor insertCharacter: $x.   self for: ( editor characterIndex ) expect:  1.      "And, of course, the text has the new character."   self for: ( editor text string ) expect:  ('x',String cr).            "Insert another character . . ."   editor insertCharacter: $y.   self for: ( editor characterIndex ) expect:  2.   self for: ( editor text string ) expect:  ('xy',String cr).            "Move cursor to start of line"   editor characterIndex: 0.   "Attempt delete -- should be ignored"   "Delete the character at start of line."   editor deletePriorCharacter.   self for: ( editor characterIndex ) expect:  0.   self for: ( editor text string ) expect:  ('xy',String cr).         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testE143EditorDeleteCharactersWillNotBackOverBeginningOfLine</h3><pre>testE143EditorDeleteCharactersWillNotBackOverBeginningOfLine   "When we delete a character, the cursor decrements    and the character is no longer in the text string.   When the cursor is at the start of the line (position zero),   it will back no further (and will not delete the prior line-end).   TODO: Decide if this is the correct behavior.   "   | editor |   "Initial position of the cursor is line 1, column 1"   editor := HumEditor new.   self for: ( editor lineIndex ) expect:  1.   self for: ( editor characterIndex ) expect:  0.   self for: ( editor text string ) expect:  ('',String cr).      "When a character is inserted at the cursor position, the cursor advances."   editor insertCharacter: $x.   self for: ( editor characterIndex ) expect:  1.      "And, of course, the text has the new character."   self for: ( editor text string ) expect:  ('x',String cr).            "Insert another character . . ."   editor insertCharacter: $y.   self for: ( editor characterIndex ) expect:  2.   self for: ( editor text string ) expect:  ('xy',String cr).            "Delete the character at end of line."   editor deletePriorCharacter.   self for: ( editor characterIndex ) expect:  1.   self for: ( editor text string ) expect:  ('x',String cr).         "Delete the character at start of line."   editor deletePriorCharacter.   self for: ( editor characterIndex ) expect:  0.   self for: ( editor text string ) expect:  ('',String cr).         "Attempt one more delete."   editor deletePriorCharacter.   self for: ( editor characterIndex ) expect:  0.   self for: ( editor text string ) expect:  ('',String cr).         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testE210InterpretArrowKeys</h3><pre>testE210InterpretArrowKeys   "The arrow keys move the cursor and forget the selection.   arrowUp ==&gt; move cursor upward   arrowDown ==&gt; move cursor downward   arrowRight ==&gt; move cursor to the right   arrowLeft ==&gt; move cursor to the left   "   | editor |   editor := HumEditor new.   editor addLine: 'This is line one.'.   editor addLine: 'This is line two.'.   editor lineIndex: 2.   editor characterIndex: 0.   self for: (editor lineIndex) expect: 2.   self for: (editor characterIndex) expect: 0.   editor interpretKey: #arrowUp.   self for: ( editor lineIndex ) expect: 1.      editor interpretKey: #arrowDown.   self for: ( editor lineIndex ) expect: 2.      editor interpretKey: #arrowRight.   self for: ( editor characterIndex ) expect: 1.      editor interpretKey: #arrowLeft.   self for: ( editor characterIndex ) expect: 0.      "When we try to push beyond the current text. The cursor does not move."   editor interpretKey: #arrowLeft.   self for: ( editor characterIndex ) expect: 0.      editor interpretKey: #arrowDown.   self for: ( editor lineIndex ) expect: 2.      editor interpretKey: #arrowUp.   self for: ( editor lineIndex ) expect: 1.      editor interpretKey: #arrowUp.   self for: ( editor lineIndex ) expect: 1.                     </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testE220InterpretAltArrowKeys</h3><pre>testE220InterpretAltArrowKeys   "The arrow keys move the cursor and forget the selection.   altArrowUp ==&gt; move cursor to start of first line.   altArrowDown ==&gt; move cursor to end of last line.   altArrowRight ==&gt; move cursor to start of current line.   altArrowLeft ==&gt; move cursor to end of current line.   "   | editor |   editor := HumEditor new.   editor addLine: 'This is line one.'.   editor addLine: 'This is line two.'.   editor lineIndex: 2.   editor characterIndex: 0.   self for: (editor lineIndex) expect: 2.   self for: (editor characterIndex) expect: 0.   editor interpretKey: #altArrowUp.   self for: ( editor lineIndex ) expect: 1.   self for: ( editor characterIndex ) expect: 0.      editor interpretKey: #altArrowDown.   self for: ( editor lineIndex ) expect: 2.   self for: ( editor characterIndex ) expect: ('This is line two.' size).      editor characterIndex: 1.   editor interpretKey: #altArrowRight.   self for: ( editor characterIndex ) expect:  ('This is line two.' size).      editor interpretKey: #altArrowLeft.   self for: ( editor characterIndex ) expect: 0.      "When we try to push beyond the current text. The cursor does not move."   editor interpretKey: #altArrowLeft.   self for: ( editor characterIndex ) expect: 0.      editor interpretKey: #altArrowDown.   self for: ( editor lineIndex ) expect: 2.      editor interpretKey: #altArrowUp.   self for: ( editor lineIndex ) expect: 1.      editor interpretKey: #altArrowUp.   self for: ( editor lineIndex ) expect: 1.                     </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testE230InterpretShiftArrowKeys</h3><pre>testE230InterpretShiftArrowKeys   "The shift arrow keys move the cursor and update the selection.   shiftArrowUp ==&gt; Move cursor upward. Update selection.   shiftArrowDown ==&gt; Move cursor downward. Update selection.    shiftArrowRight ==&gt; Move cursor to the right. Update selection.   shiftArrowLeft ==&gt; Move cursor to the left. Update selection.   Selection is updated so that either the start or the end includes the cursor.   Note: Selection is modal and history dependent.   "   | editor cr |   cr := String cr.   editor := HumEditor new.   editor addLine: 'ABCD'.   editor addLine: 'abcd'.   editor lineIndex: 2.   editor characterIndex: 0.   self for: (editor lineIndex) expect: 2.   self for: (editor characterIndex) expect: 0.   editor       characterIndex: 2;      lineIndex: 1;      interpretKey: #arrowLeft.   self for: ( editor characterIndex ) expect: 1.   editor interpretKey: #shiftArrowRight.   self for: ( editor selectedText ) expect: 'B'.   editor interpretKey: #shiftArrowRight.   self for: ( editor selectedText ) expect: 'BC'.   editor interpretKey: #shiftArrowRight.   self for: ( editor selectedText ) expect: 'BCD'.   editor interpretKey: #shiftArrowRight.   self for: ( editor selectedText ) expect: 'BCD'. "does not wrap"   editor interpretKey: #shiftArrowLeft.   self for: ( editor selectedText ) expect: 'BC'.   editor interpretKey: #shiftArrowLeft.   self for: ( editor selectedText ) expect: 'B'.   editor interpretKey: #shiftArrowDown.   self for: ( editor selectedText ) expect: 'BCD',cr,'ab'.   editor interpretKey: #shiftArrowLeft.   self for: ( editor selectedText ) expect: 'BCD',cr,'a'.   editor interpretKey: #shiftArrowLeft.   self for: (editor characterIndex ) expect: 0.   self for: ( editor selectedText ) expect: 'BCD',cr.      "Go the other way."   editor      lineIndex: 2;      characterIndex: 2;      interpretKey: #arrowRight.   self for: ( editor characterIndex ) expect: 3.   editor      interpretKey: #shiftArrowUp.   self for: ( editor characterIndex ) expect: 3.   self for: ( editor lineIndex ) expect: 1.      self for: ( editor selectedText ) expect: 'D',cr,'abc'.      </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testE310EditorSupportsUnDo</h3><pre>testE310EditorSupportsUnDo   "Editor supports multiple levels of undo."      | editor text1 text2 text3 text4 |   "Initial position of the cursor is line 1, column 1"   editor := HumEditor new.   self for: (editor lineIndex) expect: 1.   self for: (editor characterIndex) expect: 0.   text1 := editor text copy.   self for: ( text1 lines size ) expect: 1.   self for: ( text1 string ) expect:  ('',String cr).      "When a character is inserted at the cursor position, the cursor advances."   editor insertCharacter: $x.   text2 := editor text copy.   self for: ( text2 string ) expect:  ('x',String cr).            "Insert another character . . ."   editor insertCharacter: $y.   text3 := editor text copy.   self for: ( text3 string ) expect:  ('xy',String cr).            "Insert an empty line."   editor insertLine.   text4 := editor text copy.   self for: ( text4 string ) expect:  ('xy', String cr, String cr).      self for: ( text1 string ) expect:  ('',String cr).   self for: ( text2 string ) expect:  ('x',String cr).      self for: ( text3 string ) expect:  ('xy',String cr).      self for: ( text4 string ) expect:  ('xy', String cr, String cr).      "Test undo"   editor undo.   self assert: ( editor text = text4 ) not.   self for: ( editor text  ) expect:  text3 .      "Multiple levels of undo"   editor undo.   self for: ( editor text  ) expect:  text2 .   editor undo.   self for: ( editor text  ) expect:  text1 .      </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testE315EditorSupportsUnDoAtBottom</h3><pre>testE315EditorSupportsUnDoAtBottom   "Editor supports multiple levels of undo - tolerates too many pops."      | editor text1 text2 text3 text4 |   "Initial position of the cursor is line 1, column 1"   editor := HumEditor new.   self for: (editor lineIndex) expect: 1.   self for: (editor characterIndex) expect: 0.   text1 := editor text copy.   self for: ( text1 lines size ) expect: 1.   self for: ( text1 string ) expect:  ('',String cr).      "When a character is inserted at the cursor position, the cursor advances."   editor insertCharacter: $x.   text2 := editor text copy.   self for: ( text2 string ) expect:  ('x',String cr).            "Insert another character . . ."   editor insertCharacter: $y.   text3 := editor text copy.   self for: ( text3 string ) expect:  ('xy',String cr).            "Insert an empty line."   editor insertLine.   text4 := editor text copy.   self for: ( text4 string ) expect:  ('xy', String cr, String cr).      self for: ( text1 string ) expect:  ('',String cr).   self for: ( text2 string ) expect:  ('x',String cr).      self for: ( text3 string ) expect:  ('xy',String cr).      self for: ( text4 string ) expect:  ('xy', String cr, String cr).      "Test undo"   editor undo.   self assert: ( editor text = text4 ) not.   self for: ( editor text  ) expect:  text3 .      "Multiple levels of undo"   editor undo.   self for: ( editor text  ) expect:  text2 .   editor undo.   self for: ( editor text  ) expect:  text1 .   "Too many undo should not raise exception or produce unexpected side effect."   editor undo.   self for: ( editor text  ) expect:  text1 .         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testE320EditorSupportsReDo</h3><pre>testE320EditorSupportsReDo   "Editor supports multiple levels of undo and redo."      | editor text1 text2 text3 text4 |   "Initial position of the cursor is line 1, column 1"   editor := HumEditor new.   self for: (editor lineIndex) expect: 1.   self for: (editor characterIndex) expect: 0.   text1 := editor text copy.   self for: ( text1 lines size ) expect: 1.   self for: ( text1 string ) expect:  ('',String cr).      "When a character is inserted at the cursor position, the cursor advances."   editor insertCharacter: $x.   text2 := editor text copy.   self for: ( text2 string ) expect:  ('x',String cr).            "Insert another character . . ."   editor insertCharacter: $y.   text3 := editor text copy.   self for: ( text3 string ) expect:  ('xy',String cr).            "Insert an empty line."   editor insertLine.   text4 := editor text copy.   self for: ( text4 string ) expect:  ('xy', String cr, String cr).      self for: ( text1 string ) expect:  ('',String cr).   self for: ( text2 string ) expect:  ('x',String cr).      self for: ( text3 string ) expect:  ('xy',String cr).      self for: ( text4 string ) expect:  ('xy', String cr, String cr).      "Test undo"   editor undo.   self assert: ( editor text = text4 ) not.   self for: ( editor text  ) expect:  text3 .      "Multiple levels of undo"   editor undo.   self for: ( editor text  ) expect:  text2 .   editor undo.   self for: ( editor text  ) expect:  text1 .      "Multiple levels of redo"   editor redo.   self for: ( editor text  ) expect:  text2 .   editor redo.   self for: ( editor text  ) expect:  text3 .   editor redo.   self for: ( editor text  ) expect:  text4 .         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testE325EditorSupportsReDoToBottom</h3><pre>testE325EditorSupportsReDoToBottom   "Editor supports multiple levels of undo and redo."      | editor text1 text2 text3 text4 |   "Initial position of the cursor is line 1, column 1"   editor := HumEditor new.   self for: (editor lineIndex) expect: 1.   self for: (editor characterIndex) expect: 0.   text1 := editor text copy.   self for: ( text1 lines size ) expect: 1.   self for: ( text1 string ) expect:  ('',String cr).      "When a character is inserted at the cursor position, the cursor advances."   editor insertCharacter: $x.   text2 := editor text copy.   self for: ( text2 string ) expect:  ('x',String cr).            "Insert another character . . ."   editor insertCharacter: $y.   text3 := editor text copy.   self for: ( text3 string ) expect:  ('xy',String cr).            "Insert an empty line."   editor insertLine.   text4 := editor text copy.   self for: ( text4 string ) expect:  ('xy', String cr, String cr).      self for: ( text1 string ) expect:  ('',String cr).   self for: ( text2 string ) expect:  ('x',String cr).      self for: ( text3 string ) expect:  ('xy',String cr).      self for: ( text4 string ) expect:  ('xy', String cr, String cr).      "Test undo"   editor undo.   self assert: ( editor text = text4 ) not.   self for: ( editor text  ) expect:  text3 .      "Multiple levels of undo"   editor undo.   self for: ( editor text  ) expect:  text2 .   editor undo.   self for: ( editor text  ) expect:  text1 .      "Multiple levels of redo"   editor redo.   self for: ( editor text  ) expect:  text2 .   editor redo.   self for: ( editor text  ) expect:  text3 .   editor redo.   self for: ( editor text  ) expect:  text4 .      "Tolerate one too many."   editor redo.   self for: ( editor text  ) expect:  text4 .         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testS110boxFacesAsPolygons</h3><pre>testS110boxFacesAsPolygons   | box polygons southFace |   box := HumSolid id: 'testS110boxFacesAsPolygons' type: #box height: 10 width: 20 depth: 30.    polygons := box asPolygons.   self expect: 6 actual: ( polygons size ).   "Expect South face"   southFace := HumPolygon new.   southFace      addVertex: {  20 meter. 0 meter. 10 meter. };    "top right"      addVertex: {  0 meter.   0 meter. 10 meter. };    "top left"      addVertex: {  0 meter.   0 meter. 0 meter. };        "bottom left"      addVertex: {  20 meter. 0 meter. 0 meter. }.      "bottom right"   self assert: ( polygons anySatisfy: [ :polygon | polygon vertices = southFace vertices ] )         description: 'South Face missing?'.   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testS120boxVolumeMassWeight</h3><pre>testS120boxVolumeMassWeight   | box  volume mass weight weightDimensions |   box := HumSolid id: 'testS110boxFacesAsPolygons' type: #box height: 0.5 width: 1.0 length: 2.0.    volume := box volume.   self expect: ( HumMeasure quantity: 1 units: 'cubic meter') actual: volume.      box density: ( HumMeasure quantity: 1000 units: #kilogram per: 'cubic meter' ).   mass := box mass.   self expect: ( HumMeasure quantity: 1000 units: 'kilogram' ) actual: mass.         weight := box weight.   self expect: '9806.650 Newton' actual: weight asString.   self expect: (9806.65) actual: weight quantity.   weightDimensions := Dictionary new.   weightDimensions      at: 'kilogram' put: 1;      at: 'meter' put: 1;      at: 'second' put: -2.   self expect: (weightDimensions) actual: weight dimensions.</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testS200x3dReadMe</h3><pre>testS200x3dReadMe   "   TODO: X3D is my preferred target language for 3D visualization.   X3D is a direct superset of VRML (It supercedes VRML97 as a standard.).   X3D is relatively well supported.   X3D can run in a browser as part of a DOM.      TODO: Add X3D web page preamble feature to HumScene.   "</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testS210x3dColor</h3><pre>testS210x3dColor   "HumSolid x3dColor should produce a X3D color string"   | solid colorString |   solid := HumSolid new.   solid color: Color red.   colorString := solid x3dColor.   self assert: (colorString = '1.00 0.00 0.00').</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testS220x3dExtent</h3><pre>testS220x3dExtent   "Produce a x3d box extent from my length width height"   | box result |   box := HumBox new.   box length: 10.0; width: 20.0; height: 30.0.   result := box x3dExtent.      self assert: '20.000 10.000 30.000' equals: result.</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testS230x3dCenter</h3><pre>testS230x3dCenter      "Produce a x3d box position from my length width height (and default position)"   | box result |   box := HumBox new.   box length: 10.0; width: 20.0; height: 30.0.   result := box x3dCenter.      self assert: '10.0 5.0 15.0' equals: result.</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testS310x3dMaterial</h3><pre>testS310x3dMaterial   "HumSolid x3dMaterial should produce a X3D xml string"   | solid colorString expect result |   solid := HumSolid new.   solid color: Color red.   colorString := solid x3dColor.   self assert: (colorString = '1.00 0.00 0.00').   expect := '&lt;material color="1.00 0.00 0.00 1.00" /&gt;   '.  result := solid x3dMaterial.  self assert: (HumCalculator string: result isLike: expect).</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testS320x3dShape</h3><pre>testS320x3dShape   "Produce a x3d box extent from my length width height"   | box result expect |   box := HumSolid new.   box id: 'BOX1'; length: 10.0; width: 20.0; height: 30.0; color: (Color red).   result := box x3dShape.   expect := '    &lt;Transform translation="10.0 5.0 15.0"&gt;         &lt;Shape&gt;            &lt;Appearance&gt;               &lt;Material diffuseColor="1.00 0.00 0.00" specularColor="0.5 0.5 0.5"/&gt;            &lt;/Appearance&gt;            &lt;Box DEF="NONE" id="BOX1" size="20.000 10.000 30.000"/&gt;         &lt;/Shape&gt;      &lt;/Transform&gt;            '.   self assert: (HumCalculator string: expect isLike: result).</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testS330changed</h3><pre>testS330changed   "#changed is propagated to parent, dependents."   | box result |   box := HumBox new.   box length: 10.0; width: 20.0; height: 30.0.   result := box x3dCenter.      self assert: '10.0 5.0 15.0' equals: result.      box changed.</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testS500ThreeJSReadMe</h3><pre>testS500ThreeJSReadMe   "The advantage of ThreeJS is that it runs WebGL in a relatively straight-forward manner.   The disadvantage of ThreeJS is that the API is relativelyl low-level.   "</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testS505ThreeJSColor</h3><pre>testS505ThreeJSColor   "HumSolid three.js needs HTML color string"   | solid colorString |   solid := HumSolid new.   solid color: Color green.   colorString := solid color asHexString.   self assert: (colorString = '00FF00').</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testS520ThreeJSBox</h3><pre>testS520ThreeJSBox   "Produce a Three.js cube with my length width height and position"   | box result expect |   box := HumSolid new.   box id: 'box102030'; length: 10.0; width: 20.0; height: 30.0; color: (Color green).   result := box asThreeJS.   expect := '         var box102030 = new THREE.Mesh( ( new THREE.CubeGeometry( 20.000, 10.000, 30.000   )  )                                     , ( new THREE.MeshBasicMaterial( { color: 0x00ff00 } )  )                                     );         box102030.position.set( 10.000, 5.000, 15.000 );   '.   self assert: ( HumCalculator string:  expect isLike: result ).</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testS610VPythonThing</h3><pre>testS610VPythonThing   "Produce a VPython Thing.py box with my length width height and position"   | box result expected |   box := HumSolid new.   box id: 'box102030'; length: 10.0; width: 20.0; height: 30.0; color: (Color green).   result := box asVPythonThing.   expected := 'box102030 = BoxThing( label = "box102030", length = 10.000, width = 20.000, height = 30.000, pos = ( 10.000, 5.000, 15.000 ), aColor = color.green )'.   self expect: expected actual: result.</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testS615VPythonSpace</h3><pre>testS615VPythonSpace   "Produce a VPython Thing.py box with my length width height and position, but not visible"   | box result expected |   box := HumSpace new.   box id: 'space102030'; length: 10.0; width: 20.0; height: 30.0.   result := box asVPythonThing.   expected := 'space102030 = BoxThing( label = "space102030", length = 10.000, width = 20.000, height = 30.000, pos = ( 10.000, 5.000, 15.000 ), visible = false )'.   self expect: expected actual: result.</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testS620VPythonPreamble</h3><pre>testS620VPythonPreamble   "Produce a general purpose VPython scene preamble "   | scene result expected |   scene := HumScene new.   self assert: (scene isKindOf: HumScene).   result := scene asVPythonPreamble.   expected := 'from visual import *import Thingfrom Thing import BoxThingfrom Thing import PipeThing# Set window attributesscene.width=800scene.height=800scene.title="Scene Title"scene.background = ( 0.7, 0.7, 0.7 )# Set camera/viewport attributesscene.autoscale = Truescene.center = ( 4*12, 13*12, 4*12 )scene.up = ( 0, 0, 1 )'.   self expect: expected actual: result.   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testT110initialTextHasOneEmptyLine</h3><pre>testT110initialTextHasOneEmptyLine   "When it is initialized, there is one empty line.   "   | text |      "Initial position of the cursor is line 1, column 1"   text := HumText new.   self for: ( text lines size ) expect: 1.   self for: ( text string ) expect:  ('',String cr).</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testT115initialTextCopyHasOneEmptyLine</h3><pre>testT115initialTextCopyHasOneEmptyLine   "When it is initialized, there is one empty line.   "   | text textCopy |   "Initial position of the cursor is line 1, column 1"   text := HumText new.   textCopy := text copy.   self for: ( textCopy lines size ) expect: 1.   self for: ( textCopy string ) expect:  ('',String cr).</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testT210TurtleCreation</h3><pre>testT210TurtleCreation   "Create a new turtle and check initial state."   | turtle |   turtle := HumTurtle new.   self expect: 0@0 actual: turtle position.   self expect: (0 degrees) actual: turtle heading.   self expect: #up actual: turtle tail.   self expect: 1.0 actual: turtle speed.   self expect: (Color black) actual: turtle tailColor.</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testT220TurtleHeading</h3><pre>testT220TurtleHeading   "Test methods that change the heading."   | turtle |   turtle := HumTurtle new.   turtle headNorth.   self expect: (0 degrees) actual: (turtle heading).   turtle turnRight.   self expect: (90 degrees) actual: (turtle heading).   turtle turnLeft.   self expect: (0 degrees) actual: (turtle heading).   turtle turnLeft.   self expect: (-90 degrees) actual: (turtle heading).   turtle headEast.   self expect: (90 degrees) actual: (turtle heading).   turtle headWest.   self expect: (-90 degrees) actual: (turtle heading).   turtle headSouth.   self expect: (180 degrees) actual: (turtle heading).   turtle turnRight.   self expect: (270 degrees) actual: (turtle heading).   self expect: ( -90 degrees) actual: (turtle heading).         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testT230TurtleStepping</h3><pre>testT230TurtleStepping   "Test methods that change the heading."   | turtle |   turtle := HumTurtle new.   turtle headNorth.   turtle step.   self expect: (0.0@1.0) actual: (turtle position).   turtle turnRight. "East"   turtle step.   self expect: (1.0@1.0) actual: (turtle position).   turtle turnLeft. "North again"   turtle step.   self expect: (1.0@2.0) actual: (turtle position).   turtle turnLeft.    "West"   turtle step.   self expect: (0.0@2.0) actual: (turtle position).      turtle headEast.   turtle step.   self expect: (1.0@2.0) actual: (turtle position).   turtle headWest.   turtle step.   self expect: (0.0@2.0) actual: (turtle position).   turtle headSouth.   turtle step.   self expect: (0.0@1.0) actual: (turtle position).   turtle turnRight. "West"   turtle step.   self expect: (-1.0@1.0) actual: (turtle position).         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testT240TurtleSpeeding</h3><pre>testT240TurtleSpeeding   "Test methods that change the heading."   | turtle |   turtle := HumTurtle new.   turtle speed: 11.0.      turtle headNorth.   turtle step.   self expect: (0.0@11.0) actual: (turtle position).   turtle turnRight. "East"   turtle step.   self expect: (11.0@11.0) actual: (turtle position).   turtle turnLeft. "North again"   turtle step.   self expect: (11.0@22.0) actual: (turtle position).   turtle turnLeft.    "West"   turtle step.   self expect: (0.0@22.0) actual: (turtle position).      turtle headEast.   turtle step.   self expect: (11.0@22.0) actual: (turtle position).   turtle headWest.   turtle step.   self expect: (0.0@22.0) actual: (turtle position).   turtle headSouth.   turtle step.   self expect: (0.0@11.0) actual: (turtle position).   turtle turnRight. "West"   turtle step.   self expect: (-11.0@11.0) actual: (turtle position).         </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV100ReadMe</h3><pre>testV100ReadMe   "The current viewport uses low-level graphics functions rather than Morph.    The intent is to avoid the rather large and poorly documented Morph APIs.   Portability might be a side-effect, but that is not my main goal.   "</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV105CreateCamera</h3><pre>testV105CreateCamera   "The camera is modeled by a pin-hole box camera."   | camera |   camera := HumCamera defaultCamera.    self assert: ( camera isKindOf: HumCamera ).   self assert: ( camera isKindOf: HumBox ).      "Camera should be positioned at adult eye-height."   self expect: (1.75 meter) actual: camera topEdge.     "Default camera has westEdge at zero."   self expect: (0 meter) actual: camera westEdge.               </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV110PositionCameraFacingBillboard</h3><pre>testV110PositionCameraFacingBillboard   "The default/initial viewport frustrum is laid directly onto the surface.   Hence scale will be 1 to 1 for pixel dimensioned surfaces.   "   | camera blueSurface redSurface greenSurface assembly billboard scene |   "Create a simple billboard with three surfaces."   blueSurface := HumPane      id: 'blue surface'      height: 90 px      width: 160 px      background: Color blue.   redSurface  := HumPane      id: 'red surface'      height: 44 px      width: 80 px      background: Color red.   greenSurface := HumPane      id: 'blue surface'      height: 33 px      width: 80 px      background: Color green.   assembly := HumPane new.   assembly place: blueSurface at: { 0 px. 200 px. 0 px. }.   self expect: ( 200 px ) actual: ( blueSurface top ).   assembly place: redSurface rightOf: blueSurface.    redSurface top: (blueSurface top).   self expect: ( 200 px ) actual: ( redSurface top ).   assembly place: greenSurface below: redSurface.    assembly place: greenSurface rightOf: blueSurface.   self expect: ( (200 - 44) px ) actual: ( greenSurface top ).   self expect: ( 200 px ) actual: ( assembly bbHeight ).   self expect: ( 240 px ) actual: ( assembly bbWidth ).      "Create a billboard and put it into a scene."   billboard := assembly asBillBoard.   self expect: (1.75 meter) actual: (billboard topEdge).   camera := HumCamera defaultCamera.      self expect: (1.75 meter) actual: (camera topEdge).   scene := HumScene new.   scene position: billboard northOf: camera.      </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV115PanCameraUpDownLeftRight</h3><pre>testV115PanCameraUpDownLeftRight   "Move the camera in the scene to effect pan motion."   | camera  |   "Create a camera and put it into a scene."   camera := HumCamera defaultCamera.      self expect: (1.75 meter) actual: (camera topEdge).   self expect: (0.00 meter) actual: (camera westEdge).   self expect: (0.01 meter) actual: (camera northEdge).    camera slideDown: (0.10 meter).   self expect: (1.65 meter) actual: ( camera bbTopEdge ).   camera slideUp: (0.10 meter).   self expect: (1.75 meter) actual: ( camera bbTopEdge ).   camera slideRight: (0.10 meter).   self expect: (0.10 meter) actual: ( camera bbWestEdge ).   camera slideLeft: (0.10 meter).   self expect: (0.00 meter) actual: ( camera bbWestEdge ).   camera slideForward:(1.0 meter).   self expect: (1.01 meter) actual: (camera northEdge).      </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV116CameraRotateSlideForward</h3><pre>testV116CameraRotateSlideForward   "Move the camera in the scene to effect pan motion."   | camera centroidBefore centroidAfter distance |   "Create a camera - with default positioning."   camera := HumCamera defaultCamera.      self expect: (1.75 meter) actual: (camera topEdge).   self expect: (0.00 meter) actual: (camera westEdge).   self expect: (0.01 meter) actual: (camera northEdge).      distance := 2.0 meter.    centroidBefore := camera center.   camera slideForward:( distance ).   centroidAfter := camera center.   self expect: (distance) actual: (centroidAfter - centroidBefore) length.      camera slideForward:( distance negated ).   centroidBefore := camera center.   camera rotateLeft: ( 45 degrees ).   camera slideForward:( 2.0 meter ).   centroidAfter := camera center.   self expect: (distance) actual: (centroidAfter - centroidBefore) length.      camera rotateLeft: ( -45 degrees ).   centroidBefore := camera center.   camera tiltDown:( 45 degrees ).   camera slideForward:( distance ).   centroidAfter := camera center.   self expect: (distance) actual: (centroidAfter - centroidBefore) length.      camera tiltDown: ( -45 degrees ).   centroidBefore := camera center.   camera rotateLeft:( 45 degrees ).   camera tiltDown:( 45 degrees ).   camera slideForward:( distance ).   centroidAfter := camera center.   self expect: (distance) actual: (centroidAfter - centroidBefore) length.</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV117CameraRotateSlideSideways</h3><pre>testV117CameraRotateSlideSideways   "Move the camera in the scene to effect pan motion."   | camera centroidBefore centroidAfter distance |   "Create a camera with default positioning."   camera := HumCamera defaultCamera.      self expect: (1.75 meter) actual: (camera topEdge).   self expect: (0.00 meter) actual: (camera westEdge).   self expect: (0.01 meter) actual: (camera northEdge).      distance := 2.0 meter.    centroidBefore := camera center.   camera slideRight:( distance ).   centroidAfter := camera center.   self expect: (distance) actual: (centroidAfter - centroidBefore) length.      camera slideRight:( distance negated ).   centroidBefore := camera center.   camera rotateLeft:( 45 degrees ).   camera slideRight:( 2.0 meter ).   centroidAfter := camera center.   self expect: (distance) actual: (centroidAfter - centroidBefore) length.      camera rotateLeft: ( -45 degrees ).   centroidBefore := camera center.   camera tiltDown:( 45 degrees ).   camera slideRight:( distance ).   centroidAfter := camera center.   self expect: (distance) actual: (centroidAfter - centroidBefore) length.      camera tiltDown: ( -45 degrees ).   centroidBefore := camera center.   camera rotateLeft:( 45 degrees ).   camera tiltDown:( 45 degrees ).   camera slideRight:( distance ).   centroidAfter := camera center.   self expect: (distance) actual: (centroidAfter - centroidBefore) length.</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV118CameraRotateSlideUpDown</h3><pre>testV118CameraRotateSlideUpDown   "Move the camera in the scene to effect pan motion."   | camera centroidBefore centroidAfter distance |   "Create camera with default positioning"   camera := HumCamera defaultCamera.      self expect: (1.75 meter) actual: (camera topEdge).   self expect: (0.00 meter) actual: (camera westEdge).   self expect: (0.01 meter) actual: (camera northEdge).      distance := 2.0 meter.    centroidBefore := camera center.   camera slideUpward: distance .   centroidAfter := camera center.   self expect: distance actual: (centroidAfter - centroidBefore) length.      camera slideRight: ( distance negated ).   centroidBefore := camera center.   camera rotateLeft: 45 degrees.   camera slideUpward: distance.   centroidAfter := camera center.   self expect: distance actual: (centroidAfter - centroidBefore) length.      camera rotateLeft: ( -45 degrees ).   centroidBefore := camera center.   camera tiltDown: 45 degrees.   camera slideUpward: distance .   centroidAfter := camera center.   self expect: distance actual: (centroidAfter - centroidBefore) length.      camera tiltDown: ( -45 degrees ).   centroidBefore := camera center.   camera rotateLeft: 45 degrees.   camera tiltDown: 45 degrees .   camera slideUpward: distance .   centroidAfter := camera center.   self expect: distance actual: (centroidAfter - centroidBefore) length.</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV120MapPointsFromSceneToViewport</h3><pre>testV120MapPointsFromSceneToViewport   "In an orthographic projection,    XY (up-down, left-right) points are mapped to the viewport    by a simple scale factor.   In a perspective projection,   XYZ is mapped to XY via dx/dz * camera (virtual box depth).   "   | scene solidA solidB  camera viewPort viewportPolygons |      ""   scene := HumScene new.   scene length: 100 meter; width: 100 meter; height: 100 meter.      solidA :=( HumSolid new ) length: 20 meter; width: 20 meter; height: 20 meter; solidColor: Color red.   solidB :=( HumSolid new ) length: 10 meter; width: 10 meter; height: 10 meter; solidColor: Color blue.      "Note: These positions are relative to the container`s origin."   scene center: solidA at: { 20 meter. 30 meter. 50 meter. }.   self expect: (30 meter) actual: ( solidA eastEdge ).   self expect: (40 meter) actual: ( solidA northEdge  ).   self expect: (40 meter) actual: ( solidA bottomEdge  ).      self expect: (10 meter) actual: ( solidA westEdge  ).   self expect: (20 meter) actual: ( solidA southEdge ).   self expect: (60 meter) actual: ( solidA topEdge  ).      "Place B on top of A."   scene position: solidB onTopOf: solidA.      "Place B on East side of A."   scene position: solidB eastOf: solidA.   "Place B on North side of A."   scene position: solidB northOf: solidA.      "Put camera in the scene. Attach a viewport to the camera."   camera := HumCamera defaultCamera.   scene addParts: { solidA. solidB. camera. }.   viewPort := HumViewPort onScene: scene viaCamera: camera.   viewPort projectionMode: #orthographic.   viewPort projectionMode: #perspective.      "Position camera"   camera northEdge: (-100 meter).      "Project the 3D points onto the 2D surface."   viewportPolygons := viewPort mapPolygonsFrom3Dto2D.   "viewportPolygons inspect."          </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV200ReadMe</h3><pre>testV200ReadMe   "This group characterizes the low level drawing infrastructure    - so that we know how to use it in HumViewPort."   self checkViewPortMorph: false.</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV300checkViewPortMorph</h3><pre>testV300checkViewPortMorph   "This group characterizes the low level drawing infrastructure    - so that we know how to use it in HumViewPort."   self checkViewPortMorph: false.</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV310ConnectViewPortToHumCanvas</h3><pre>testV310ConnectViewPortToHumCanvas   "HumCanvas provides a wrapper on actual implementation."   | canvas viewPort |   canvas := HumCanvas new.        "Connect the viewport to the canvas."   "The viewport will paint itself onto the canvas at the given canvas coordinates."   viewPort := HumViewPort new.   viewPort mapToCanvas: canvas bounds: ( Rectangle origin: 10@10 extent: 160@90  ).   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV320DrawPolygonOnBillboard</h3><pre>testV320DrawPolygonOnBillboard   "Draw a 2D polygon on the viewport canvas."   | canvas viewPort polygon surface billboard scene camera  viewer |   canvas := HumCanvas new.   "Connect the viewport to the canvas."   "The viewport will paint itself onto the canvas at the given canvas coordinates."   viewPort := HumViewPort new.   viewPort mapToCanvas: canvas bounds: ( Rectangle origin: 10@10 extent: 160@90  ).      "Polygon -- Triangle in canvas pixel coordinates."   polygon := HumPolygon borderColor: (Color black) fillColor: (Color red).   polygon       addVertex: { 100 px. 111 px. }; "bottom left"      addVertex: { 200 px. 122 px }; "bottom right"      addVertex: { 150 px. 300 px }. "apex"         "Paint the polygon onto a Surface."   surface := HumSurface new.   surface addShape: polygon.   "Reset height and width to fit content."   surface expandToFit.   "Tranlate the surface into a Billboard."   billboard := surface asBillBoard.   "Put the Billboard into a Scene."   scene := HumScene new.   "Put a Camera in the Scene and attach it to a ViewPort."   camera := HumCamera defaultCamera.   scene center: billboard northOf: camera.    "Project the scene into the ViewPort."   viewPort := HumViewPort onScene: scene viaCamera: camera.   "Render the ViewPort onto the assigned Canvas."   viewPort renderScene.   "Display the Canvas to see what we got."   viewer := HumViewPort onScene: scene viaCamera: camera.   viewer paintSceneColorCoded. "Paint box polygons onto canvas."   self checkViewPortMorph: false.   self showViewPort: viewer.    </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV330DrawABox</h3><pre>testV330DrawABox   "Draw a 3D box on the viewport - use perspective projection."   | canvas box scene camera viewer  |   canvas := HumCanvas new.   scene := HumScene  id: 'Scene'  height: 90 width: 160 length: 50.    box := HumSolid id: 'Box'  height: 9 width: 16 length: 5. "dimensions in meters"   camera := HumCamera defaultCamera.   scene center: box at: { 0. 0. 0. }.   scene center: camera at: { 0. -80. 4. }.   viewer := HumViewPort onScene: scene viaCamera: camera.   viewer renderScene. "Paint box polygons onto canvas."   self checkViewPortMorph: false..   self showViewPort: viewer.    </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV331PaintABox</h3><pre>testV331PaintABox   "Draw a 3D box on the viewport - use perspective projection."   | canvas box scene camera viewer  |   canvas := HumCanvas new.   scene := HumScene  id: 'Scene'  height: 90 width: 160 length: 50.    box := HumSolid id: 'Box' type: #box height: 3 width: 4 length: 5. "dimensions in meters"   camera := HumCamera defaultCamera.   scene center: box at: { 10. 20. 5. }.   scene center: camera at: { 20. 0. 10. }.   camera rotationDegrees: (30 degrees).   camera tiltDegrees: (-10 degrees).   viewer := HumViewPort onScene: scene viaCamera: camera.   viewer paintScene. "Paint box polygons onto canvas."   self checkViewPortMorph: false.   self showViewPort: viewer.    </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV332PaintAPyramid</h3><pre>testV332PaintAPyramid   "Draw a 3D box on the viewport - use perspective projection."   | canvas pyramid scene camera viewer  |   canvas := HumCanvas new.   scene := HumScene  id: 'Scene'  height: 90 width: 160 length: 50.    pyramid := HumRotation id: 'Pyramid' type: #pyramid xyList: { 0@10. 10@0. 0@0. }   nWedges: 3.    camera := HumCamera defaultCamera.   scene center: pyramid at: { 0. 0. 0. }.   scene center: camera at: { 30. -30. 5. }.   camera rotationDegrees: (45 degrees).   camera tiltDegrees: (0 degrees).   viewer := HumViewPort onScene: scene viaCamera: camera.   viewer paintSceneColorCoded. "Paint pyramid polygons onto canvas."   self checkViewPortMorph: false.   self showViewPort: viewer.    </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV333PaintARotation</h3><pre>testV333PaintARotation   "Draw a 3D box on the viewport - use perspective projection."   | canvas pyramid scene camera viewer  |   canvas := HumCanvas new.   scene := HumScene  id: 'Scene'  height: 90 width: 160 length: 50.    pyramid := HumRotation id: 'Pyramid' type: #pyramid xyList: {  0@10. 10@0. 0@0. }  nWedges: 3.    camera := HumCamera defaultCamera.   scene center: pyramid at: { 0. 0. 5. }.   scene center: camera at: { 40. -40. 20. }.   camera rotationDegrees: (45 degrees).   camera tiltDegrees: (-10 degrees).   viewer := HumViewPort onScene: scene viaCamera: camera.   viewer paintScene. "Paint box polygons onto canvas."   self checkViewPortMorph: false.   self showViewPort: viewer.    </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV334PaintACylinder</h3><pre>testV334PaintACylinder   "Draw a 3D box on the viewport - use perspective projection."   | canvas cylinder scene camera viewer  |   canvas := HumCanvas new.   scene := HumScene  id: 'Scene'  height: 90 width: 160 length: 50.    cylinder := HumRotation id: 'cylinder' type: #cylinder xyList: {  0@10. 5@10. 5@0.  0@0. }  nWedges: 10.    cylinder color: (Color blue).   camera := HumCamera defaultCamera.   scene center: cylinder at: { 0. 0. 5. }.   scene center: camera at: { 40. -40. 20. }.   camera rotationDegrees: (45 degrees).   camera tiltDegrees: (-10 degrees).   viewer := HumViewPort onScene: scene viaCamera: camera.   self checkViewPortMorph: false.   viewer paintScene"ColorCoded". "Paint box polygons onto canvas."   self showViewPort: viewer.    </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV334PaintAnElipsoid</h3><pre>testV334PaintAnElipsoid   "Draw a 3D box on the viewport - use perspective projection."   |  elipsoid scene camera viewer    |   scene := HumScene  id: 'Scene'  height: 200 width: 200 length: 200. "   xy := OrderedCollection new.   pi := Float pi.   (0.0 to: pi by: pi/8.0) do: [ :angle |  xy add: (  ((angle sin)*10.0) @ ((angle cos)*5.0) ) ].   self assert: (xy size = 9)."      elipsoid := HumElipsoid id: 'Elipsoid' type: #elipsoid height: 10.0 width: 10.0 length: 1.0.   elipsoid color: (Color green).   camera := HumCamera defaultCamera.   scene center: elipsoid at: { 0. 0. 0. }.   scene center: camera at: { 0. -100. 0. }.   "camera rotationDegrees: (45 degrees).   camera tiltDegrees: (-20 degrees).   "   viewer := HumViewPort onScene: scene viaCamera: camera.   viewer paintSceneColorCoded. "Paint box polygons onto canvas."   self checkViewPortMorph: false.   self showViewPort: viewer.    </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV335PaintAThing</h3><pre>testV335PaintAThing   "Draw a 3D thing on the viewport - use perspective projection."   |  thing scene camera viewer  pi xy |   scene := HumScene  id: 'Scene'  height: 90 width: 160 length: 50.    xy := OrderedCollection new.   pi := Float pi.   (0.0 to: 2*pi by: pi/8.0) do: [ :angle |  xy add: (  (angle cos)*3.0 + 5.0 ) @ ( (angle sin)*3.0 )  ].   self expect: 17 actual: (xy size).   thing := HumRotation id: 'torus' type: #thing xyList: xy  nWedges: 20.    thing color: (Color yellow).   camera := HumCamera defaultCamera.   scene center: thing at: { 0. 0. 8. }.   scene center: camera at: { 40. -40. 30. }.   camera rotationDegrees: (45 degrees).   camera tiltDegrees: (-20 degrees).   viewer := HumViewPort onScene: scene viaCamera: camera.   viewer paintScene. "Paint box polygons onto canvas."   self showViewPort: viewer.    </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV335PaintATorus</h3><pre>testV335PaintATorus   "Draw a 3D thing on the viewport - use perspective projection."   |  thing scene camera viewer  pi xy |   scene := HumScene  id: 'Scene'  height: 90 width: 160 length: 50.    xy := OrderedCollection new.   pi := Float pi.   (0.0 to: 2*pi by: pi/8.0) do: [ :angle |  xy add: (  (angle cos)*3.0 + 5.0 ) @ ( (angle sin)*3.0 )  ].   self expect: 17 actual: (xy size).   thing := HumRotation id: 'torus' type: #thing xyList: xy  nWedges: 20.    thing color: (Color yellow).   camera := HumCamera defaultCamera.   scene center: thing at: { 0. 0. 8. }.   scene center: camera at: { 0.0. -40.0. 3.0. }.   "scene center: camera at: { 40. -40. 30. }.   camera rotationDegrees: (45 degrees).   camera tiltDegrees: (-20 degrees)."   viewer  := HumViewPort onScene: scene viaCamera: camera.   viewer paintSceneColorCoded. "Paint box polygons onto canvas."   self showViewPort: viewer.    </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV335PaintExtrusion</h3><pre>testV335PaintExtrusion   "Draw a 3D thing on the viewport - use perspective projection."   |  thing scene camera viewer a3DpathForMold a3DpathForExtrusion |   scene := HumScene  id: 'testV335PaintExtrusion-Scene'  height: 90 width: 160 length: 50.    a3DpathForMold := H3dPath new.   a3DpathForMold       addVertex: (HumVector x: 0.0 y: 0.0 z: 0.0);      addVertex: (HumVector x: 0.0 y: 1.0 z: 0.0);      addVertex: (HumVector x: 1.0 y: 1.0 z: 0.0);      addVertex: (HumVector x: 0.0 y: 0.0 z: 0.0).   a3DpathForExtrusion := H3dPath new.   a3DpathForExtrusion      addVertex: (HumVector x: 0.0 y: 0.0 z: 1.0);      addVertex: (HumVector x: 0.0 y: 0.0 z: 2.0).         thing := HumExtrusion id: 'testV335PaintExtrusion-Extrusion' moldLoop: a3DpathForMold extrusionPath: a3DpathForExtrusion.   thing color: (Color yellow).   camera := HumCamera defaultCamera.   scene addPart: thing.   scene center: camera at: { 0.0. -40.0. 3.0. }.   "scene center: camera at: { 40. -40. 30. }.   camera rotationDegrees: (45 degrees).   camera tiltDegrees: (-20 degrees)."   viewer  := HumViewPort onScene: scene viaCamera: camera.   viewer paintSceneColorCoded. "Paint box polygons onto canvas."   self assert: (thing polygons size = 3).   self checkViewPortMorph: false.   self showViewPort: viewer.    </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV336DrawAThing</h3><pre>testV336DrawAThing   "Draw a 3D thing on the viewport - use perspective projection."   | canvas thing scene camera viewer  pi xy |   canvas := HumCanvas new.   scene := HumScene  id: 'Scene'  height: 90 width: 160 length: 50.    xy := OrderedCollection new.   pi := Float pi.   (0.0 to: pi by: pi/8.0) do: [ :angle |  xy add: (  (((angle * 2) sin abs )*5.0 + 1.0) @ (((angle * 1) cos )*8.0) ) ].   self assert: (xy size = 9).   thing := HumRotation id: 'elipsoid' type: #thing xyList: xy  nWedges: 20.    thing color: (Color gray).   camera := HumCamera defaultCamera.   scene center: thing at: { 0. 0. 8. }.   scene center: camera at: { 40. -40. 30. }.   camera rotationDegrees: (45 degrees).   camera tiltDegrees: (-20 degrees).   viewer := HumViewPort onScene: scene viaCamera: camera.   viewer renderScene. "Paint box polygons onto canvas."   self showViewPort: viewer.    </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV336WireframeATorus</h3><pre>testV336WireframeATorus   "Draw a 3D thing on the viewport - use perspective projection."   |  thing scene camera viewer  pi xy |   scene := HumScene  id: 'Scene'  height: 90 width: 160 length: 50.    xy := OrderedCollection new.   pi := Float pi.   (0.0 to: 2*pi by: pi/8.0) do: [ :angle |  xy add: (  (angle cos)*3.0 + 5.0 ) @ ( (angle sin)*3.0 )  ].   self expect: 17 actual: (xy size).   thing := HumRotation id: 'torus' type: #thing xyList: xy  nWedges: 20.    thing color: (Color transparent).   camera := HumCamera defaultCamera.   scene center: thing at: { 0. 0. 8. }.   scene center: camera at: { 40. -40. 30. }.   camera rotationDegrees: (45 degrees).   camera tiltDegrees: (-20 degrees).   viewer := HumViewPort onScene: scene viaCamera: camera.   viewer renderScene. "Paint box polygons onto canvas."   self showViewPort: viewer.    </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV337DrawAThingWireFrame</h3><pre>testV337DrawAThingWireFrame   "Draw a 3D box on the viewport - use perspective projection."   | canvas thing scene camera viewer  pi xy |   canvas := HumCanvas new.   scene := HumScene  id: 'Scene'  height: 90 width: 160 length: 50.    xy := OrderedCollection new.   pi := Float pi.   (0.0 to: pi by: pi/8.0) do: [ :angle |  xy add: (  (((angle * 2) sin abs )*5.0 + 1.0) @ (((angle * 1) cos )*8.0) ) ].   self assert: (xy size = 9).   thing := HumRotation id: 'elipsoid' type: #thing xyList: xy  nWedges: 20.    thing color: (Color gray).   camera := HumCamera defaultCamera.   scene center: thing at: { 0. 0. 8. }.   scene center: camera at: { 40. -40. 30. }.   camera rotationDegrees: (45 degrees).   camera tiltDegrees: (-20 degrees).   viewer := HumViewPort onScene: scene viaCamera: camera.   viewer renderSceneAsWireFrame.  "Paint box polygons onto canvas."   self showViewPort: viewer.    </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV338DrawABoxAsTriangles</h3><pre>testV338DrawABoxAsTriangles   "Draw a 3D box on the viewport - use perspective projection."   | canvas box scene camera viewer  |   canvas := HumCanvas new.   scene := HumScene  id: 'Scene'  height: 90 width: 160 length: 50.    box := HumSolid id: 'Box'  height: 9 width: 16 length: 5. "dimensions in meters"   camera := HumCamera defaultCamera.   scene center: box at: { 0. 0. 0. }.   scene center: camera at: { 0. -80. 4. }.   viewer := HumViewPort onScene: scene viaCamera: camera.   viewer renderSceneAsTriangles. "Paint box triangles onto canvas."   self checkViewPortMorph: false.   self showViewPort: viewer.    </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV345DrawASolidRotated</h3><pre>testV345DrawASolidRotated   "Draw a 3D box on the viewport - use perspective projection."   | canvas box scene camera viewer  |   canvas := HumCanvas new.   scene := HumScene  id: 'Scene'  height: 90 width: 160 length: 50.    box := HumSolid id: 'Box'  height: 9 width: 16 length: 5. "dimensions in meters"   box color: (Color blue).   box rotateLeft: 30 degrees.   camera := HumCamera defaultCamera.   scene center: box at: { 9. 80. 0. }.   scene center: camera at: { 12. 50. 1. }.   viewer := HumViewPort onScene: scene viaCamera: camera.   viewer renderScene. "Paint box polygons onto canvas."   self showViewPort: viewer.    </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV346DrawASolidTilted</h3><pre>testV346DrawASolidTilted   "Draw a 3D box on the viewport - use perspective projection."   | canvas box scene camera viewer  |   canvas := HumCanvas new.   scene := HumScene  id: 'Scene'  height: 90 width: 160 length: 50.    box := HumSolid id: 'Box'  height: 9 width: 16 length: 5. "dimensions in meters"   box color: (Color blue).   box tiltUp: 30 degrees.   camera := HumCamera defaultCamera.   scene center: box at: { 9. 80. 0. }.   scene center: camera at: { 12. 50. 1. }.   viewer := HumViewPort onScene: scene viaCamera: camera.   viewer renderScene. "Paint box polygons onto canvas."   self showViewPort: viewer.    </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV347DrawASolidRotatedAndTilted</h3><pre>testV347DrawASolidRotatedAndTilted   "Draw a 3D box on the viewport - use perspective projection."   | canvas box scene camera viewer  |   canvas := HumCanvas new.   scene := HumScene  id: 'Scene'  height: 90 width: 160 length: 50.    box := HumSolid id: 'Box'  height: 9 width: 16 length: 5. "dimensions in meters"   box color: (Color blue).   box rotateLeft: 30 degrees.   box tiltUp: 30 degrees.   camera := HumCamera defaultCamera.   scene center: box at: { 9. 80. 0. }.   scene center: camera at: { 12. 50. 1. }.   viewer := HumViewPort onScene: scene viaCamera: camera.   viewer renderScene. "Paint box polygons onto canvas."   self showViewPort: viewer.    </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testV350paintAvatar</h3><pre>testV350paintAvatar   | avatar scene camera viewer  |   avatar := self buildAvatar.   self assert: ( avatar isKindOf: HumAssembly ).   scene := HumScene id: 'Scene-testV350paintAvatar'.   camera := HumCamera defaultCamera.   scene center: avatar at: { 0.0. 0.0. 0.0. }.   scene center: camera at: { 0.0. -10.0.  5.0 }.   "camera rotateRight: (90 degrees)."   camera tiltDown: (20 degrees).   viewer := HumViewPort onScene: scene viaCamera: camera.   viewer paintScene .    self checkViewPortMorph: false.   self showViewPort: viewer.</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testW100ReadMe</h3><pre>testW100ReadMe   "Hum Widgets are wrappers on various presentation layer technologies.   They often generate code, but may return objects.   For example:   - humWidget asHTML returns a code string.   - humWidget asMorph returns a Morph object.   "   "Hum Widgets are typically bound to a BlackBoard and an Ontology.   The BlackBoard provides persistence.   The Ontology provides dictionary-like knowledge and will often influence how a widget is rendered.   "</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testW110LayoutContainsOtherWidgets</h3><pre>testW110LayoutContainsOtherWidgets   "A layout widget contains one or more other widgets."   | layoutWidget widgetA widgetB |   layoutWidget := HumLayoutWidget new.   widgetA := HumStringWidget new.   widgetB := HumStringWidget new.   layoutWidget addWidget: widgetA.   layoutWidget addWidget: widgetB.   self assert: ( layoutWidget widgets isKindOf: OrderedCollection ).   "Widgets are orderd as added."   self expect: 2 actual: ( layoutWidget widgets size ).   self expect: widgetA actual: ( layoutWidget widgets at: 1 ).   self expect: widgetB actual: ( layoutWidget widgets at: 2 ).      </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testW120RowLayout</h3><pre>testW120RowLayout   "A row layout arranges child widgets in a row."   | layoutWidget |   layoutWidget := HumRowLayoutWidget new.   self assert: (layoutWidget isKindOf: HumLayoutWidget).</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testW130ColumnLayout</h3><pre>testW130ColumnLayout   "A column layout arranges child widgets in a column."   | layoutWidget |   layoutWidget := HumColumnLayoutWidget new.   self assert: ( layoutWidget isKindOf: HumLayoutWidget ).   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testW220RowLayoutHTML</h3><pre>testW220RowLayoutHTML   "A row layout arranges child widgets in a row."   | layoutWidget widgetA widgetB html |      layoutWidget := HumRowLayoutWidget new.   self assert: (layoutWidget isKindOf: HumLayoutWidget).      widgetA := HumStringWidget new.   widgetA attributeName: 'title'; attributeValue: 'This is only a test'.   widgetB := HumTextWidget new.   widgetB attributeName: 'description'; attributeValue: 'If this were real,   the text might span several lines.'.      layoutWidget addWidget: widgetA; addWidget: widgetB.   html := layoutWidget asHTML.   self assert: ('*&lt;div*' match: html ).   self assert: ('*&lt;div*&lt;table*&lt;tr*&lt;td*&lt;input*&lt;/input&gt;*&lt;/td&gt;*&lt;td*&lt;textarea*&lt;/textarea&gt;*&lt;/td&gt;*&lt;/tr&gt;*&lt;/table&gt;*&lt;/div&gt;*' match: html).   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testW230ColumnLayoutHTML</h3><pre>testW230ColumnLayoutHTML   "A row layout arranges child widgets in a row."   | layoutWidget widgetA widgetB html |      layoutWidget := HumColumnLayoutWidget new.   self assert: (layoutWidget isKindOf: HumLayoutWidget).      widgetA := HumStringWidget new.   widgetA attributeName: 'title'; attributeValue: 'This is only a test'.   widgetB := HumTextWidget new.   widgetB attributeName: 'description'; attributeValue: 'If this were real,   the text might span several lines.'.   layoutWidget addWidget: widgetA; addWidget: widgetB.   html := layoutWidget asHTML.   self assert: ('*&lt;div*' match: html ).   self assert: ('*&lt;div*&lt;table*&lt;tr*&lt;td*&lt;input*&lt;/input&gt;*&lt;/td&gt;*&lt;/tr&gt;**&lt;tr*&lt;td*&lt;textarea*&lt;/textarea&gt;*&lt;/td&gt;*&lt;/tr&gt;*&lt;/table&gt;*&lt;/div&gt;*' match: html).   </pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testW320RowLayoutAsMorph</h3><pre>testW320RowLayoutAsMorph   "A row layout arranges child widgets in a row."   | layoutWidget widgetA widgetB morph  window |      layoutWidget := HumRowLayoutWidget new.   self assert: (layoutWidget isKindOf: HumLayoutWidget).      widgetA := HumStringWidget new.   widgetA attributeName: 'title'; attributeValue: 'This is only a test'.   widgetB := HumTextWidget new.   widgetB attributeName: 'description'; attributeValue: 'If this were real,   the text might span several lines.'.      layoutWidget addWidget: widgetA; addWidget: widgetB.   morph := layoutWidget asMorph.   self assert: (morph isKindOf: Morph).   self assert: (morph isKindOf: AlignmentMorph ).   self expect: #leftToRight actual: (morph listDirection).   window := morph openInWindowLabeled: 'testW320RowLayoutAsMorph'.   window close.   morph delete.</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; testW330ColumnLayoutAsMorph</h3><pre>testW330ColumnLayoutAsMorph   "A row layout arranges child widgets in a row."   | layoutWidget widgetA widgetB morph  window |      layoutWidget := HumColumnLayoutWidget new.   self assert: (layoutWidget isKindOf: HumLayoutWidget).      widgetA := HumStringWidget new.   widgetA attributeName: 'title'; attributeValue: 'This is only a test'.   widgetB := HumTextWidget new.   widgetB attributeName: 'description'; attributeValue: 'If this were real,   the text might span several lines.'.      layoutWidget addWidget: widgetA; addWidget: widgetB.   morph := layoutWidget asMorph.   self assert: (morph isKindOf: Morph).   self assert: (morph isKindOf: AlignmentMorph ).   self expect: #topToBottom actual: (morph listDirection).   window := morph openInWindowLabeled: 'testW330ColumnLayoutAsMorph'.   window close.   morph delete.</pre><h3>Hum-Tests -- HumUserInterfaceTests &gt;&gt; update:</h3><pre>update: someObject   "Record fact that someObject was updated by a test.   We must call 'someObject addDependent: self' prior to causing update.   "   super update: someObject.   lastChange := someObject.</pre><h3>Hum-Tests -- HumVRTests &gt;&gt; test100CreateVRwith2scenes</h3><pre>test100CreateVRwith2scenes   "A virtual reality has one or more scenes."   | world sceneA sceneB |   "Create a VR world"   world := HumVR new.   "Create two scenes"   sceneA := HumScene id: 'Scene with cube'.   sceneA addPart: (HumBox new).   sceneB := HumScene id: 'Scene with ball'.   sceneB addPart: (HumElipsoid new).   "Add scenes to world."   world addScene: sceneA.   world addScene: sceneB.   "Start the world - stepping."   world start.   "Stop the world - stop stepping."   world stop.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; addPart:</h3><pre>addPart: aHumBox   "Add the component to my parts list"   | |   self assert: ( aHumBox isKindOf: HumBox ).   (self parts) add: aHumBox.   "When the part is changed, the assembly (me myself) (e.g. scene) will be notified."   aHumBox addDependent: self.   aHumBox when: #changed send: #changed  to: self with: aHumBox.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; addParts:</h3><pre>addParts: aCollection   "Add the component to my parts list"   | |   aCollection do: [ :each | self addPart: each ].</pre><h3>Hum-UI -- HumAssembly &gt;&gt; advance:by:</h3><pre>advance: aBox by: anArray    "Move the box by the given increments.   anArray is velocity per step.   ( velocity per second divided by steps per second )   It`s elements have units of L^1 T^-1.   Note: This method moves box in assembly (scene) frame, not the boxes frame.   TODO: Think about moving box in its own coordinates - correcting for rotation and tilt.   "   | dEast dNorth dUp |   dEast  := self asMeasure: (anArray at: 1).   dNorth := self asMeasure: (anArray at: 2).   dUp    := self asMeasure: (anArray at: 3).      "Assure that aBox is in my collection. "   ( self parts ) add: aBox.      "Compute edge positions to center aBox at those coordinates."   aBox eastEdge:  ( aBox eastEdge  + dEast ).   aBox northEdge: ( aBox northEdge + dNorth ).   aBox topEdge:   ( aBox topEdge   + dUp ).         </pre><h3>Hum-UI -- HumAssembly &gt;&gt; asPolygons</h3><pre>asPolygons   "Return polygons for my parts."   | assemblyPolygons |   assemblyPolygons := OrderedCollection new.   self exploded       do: [ :part |          | partPolygons |         partPolygons := part asPolygons.         assemblyPolygons addAll: partPolygons.          ].   ^assemblyPolygons.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; asPolygonsColorCoded</h3><pre>asPolygonsColorCoded   "Return polygons for my parts."   | assemblyPolygons |   assemblyPolygons := OrderedCollection new.   self parts       do: [ :part |          | partPolygons |         partPolygons := part asPolygonsColorCoded.         assemblyPolygons addAll: partPolygons.          ].   ^assemblyPolygons.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; asThreeJS</h3><pre>asThreeJS   "render the parts contained in this assembly"   | js calc dictionary prologTemplate |   dictionary := Dictionary new.   dictionary at: 'assemblyID' put: (self asCamelCase ).   calc := HumCalculator new.   "TODO: Add method to generate Three.js boiler plate."   "Initialize geometry for this assembly."   prologTemplate := String cr, 'var @assemblyID = new THREE.Geometry();'.   js := calc fillTemplate: prologTemplate fromDictionary: dictionary.      ( self parts )      do: [ :part |             | assemblyTemplate assemblyJS |            "Create the part"            js := js, ( part asThreeJS ).            "Merge it into the assembly."            assemblyTemplate := '         THREE.GeometryUtils.merge( @assemblyID, @partID );', String cr.            dictionary at: 'partID' put: ( part asCamelCase ).            "The template drives this, producing one line of code."            assemblyJS := calc fillTemplate: assemblyTemplate fromDictionary: dictionary.             js := js, assemblyJS.             ].   ^js.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; asVPython</h3><pre>asVPython   "Render my parts via Visual Python Things"   | pythonCode |   "Note: Put the assembly in a scene.   The preamble code must be generated via HumScene."   pythonCode := String new.   self parts do: [ :part | pythonCode := pythonCode, String cr, (part asVPython) ].   pythonCode := pythonCode, String cr.   ^pythonCode.   </pre><h3>Hum-UI -- HumAssembly &gt;&gt; asX3D</h3><pre>asX3D   "Return a string representing this assembly as a X3D element and scene.   "   |  x3d calc |   calc := HumCalculator new.   x3d := calc xml: 'X3D' dictionary: (self x3dBoilerPlate)              with: [ self x3dScene ].   ^x3d.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; bbBottomEdge</h3><pre>bbBottomEdge   "Find my bounding box edge."   | myEdge |   myEdge := self bottomEdge.   self parts       do: [ :part |             | otherEdge |            otherEdge := (part bottomEdge).            (otherEdge &lt; myEdge ) ifTrue: [ myEdge := otherEdge ]            ].   ^bottomEdge := myEdge.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; bbDepth</h3><pre>bbDepth   "Depth is another name for length."   ^self bbLength.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; bbEastEdge</h3><pre>bbEastEdge   "Find my bounding box edge."   | myEdge |   myEdge :=self eastEdge.   self parts       do: [ :part |             | otherEdge |            otherEdge := (part eastEdge).            ( otherEdge &gt; myEdge ) ifTrue: [ myEdge := otherEdge ]            ].   ^eastEdge := myEdge.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; bbHeight</h3><pre>bbHeight   "height of my bounding box"   | |   height := ((self bbTopEdge) - (self bbBottomEdge)) abs.   ^height.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; bbLength</h3><pre>bbLength   "length of my bounding box"   | |   height := ((self bbNorthEdge) - (self bbSouthEdge)) abs.   ^height.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; bbNorthEdge</h3><pre>bbNorthEdge   "Find my bounding box edge."   | myEdge |   myEdge :=self northEdge.   self parts       do: [ :part |             | otherEdge |            otherEdge := (part northEdge).            (otherEdge &gt; myEdge ) ifTrue: [ myEdge := otherEdge ]            ].   ^northEdge := myEdge.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; bbSouthEdge</h3><pre>bbSouthEdge   "Find my bounding box edge."   | myEdge |   myEdge := self southEdge.   self parts       do: [ :part |             | otherEdge |            otherEdge := (part southEdge).            (otherEdge &lt; myEdge ) ifTrue: [ myEdge := otherEdge ]            ].   ^southEdge := myEdge.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; bbTopEdge</h3><pre>bbTopEdge   "Find my bounding box edge."   | myEdge |   myEdge := self topEdge.   self parts       do: [ :part |             | otherEdge |            otherEdge := (part topEdge).            (otherEdge &gt; myEdge ) ifTrue: [ myEdge := otherEdge ]            ].   ^topEdge := myEdge.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; bbWestEdge</h3><pre>bbWestEdge   "Find my bounding box edge."   | myEdge |   myEdge := self westEdge.   self parts       do: [ :part |             | otherEdge |            otherEdge := (part westEdge).            (otherEdge &lt; myEdge ) ifTrue: [ myEdge := otherEdge ]            ].   ^westEdge := myEdge.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; bbWidth</h3><pre>bbWidth   "width of my bounding box"   | |   height := ( self bbEastEdge ) - ( self bbWestEdge ).   ^height.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; center:above:</h3><pre>center: aHumBox above: aHumBox2    "synonym"   self center: aHumBox onTopOf: aHumBox2 </pre><h3>Hum-UI -- HumAssembly &gt;&gt; center:at:</h3><pre>center: aBox at: a3Vector    "Center the part (aBox) at the given coordinates. { east. north. up. }   Note: Those coordinates are relative to my origin."   |  calc |   calc := HumCalculator new.   calc cases;      when: [ a3Vector isKindOf: Array ] then: [ aBox centerAt: (HumVector newFrom: a3Vector). ];      when: [ a3Vector isKindOf: HumVector ] then: [ aBox centerAt: a3Vector ];      otherwise: [ Error signal: 'unexpected type sent to HumAssembly&gt;&gt;center:at:' ].   "Make sure I have that box in my parts list."   self addPart: aBox.      </pre><h3>Hum-UI -- HumAssembly &gt;&gt; center:below:</h3><pre>center: boxB below: boxA   "Center boxB over boxA"   | newCenter |   self addParts: { boxB. boxA. }.   newCenter := { boxA centerX. boxA centerY. ((boxA centerZ) - ((boxA height + boxB height) / 2.0 )) }.   self center: boxB at: newCenter.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; center:eastOf:</h3><pre>center: boxB eastOf: boxA   "Center boxB over boxA"   | newCenter |   self addParts: { boxB. boxA. }.   newCenter := { ((boxA centerX) + ( (boxA width + boxB width)/2.0) ). boxA centerY. boxA centerZ.  }.   self center: boxB at: newCenter.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; center:northOf:</h3><pre>center: boxB northOf: boxA   "Center boxB over boxA"   | newCenter |   self addParts: { boxB. boxA. }.   newCenter := { boxA centerX. ((boxA centerY) + boxA length). boxA centerZ.  }.   self center: boxB at: newCenter.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; center:onTopOf:</h3><pre>center: boxB onTopOf: boxA   "Center boxB over boxA"   | newCenter |   self addParts: { boxB. boxA. }.   newCenter := { boxA centerX. boxA centerY. ((boxA centerZ) + ((boxA height + boxB height) / 2.0 )) }.   self center: boxB at: newCenter.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; center:over:</h3><pre>center: aHumBox over: aHumBox2    "synonym"   self center: aHumBox onTopOf: aHumBox2 </pre><h3>Hum-UI -- HumAssembly &gt;&gt; center:southOf:</h3><pre>center: boxB southOf: boxA   "Center boxB over boxA"   | newCenter |   self addParts: { boxB. boxA. }.   newCenter := { boxA centerX. ((boxA centerY) - boxA length). boxA centerZ.  }.   self center: boxB at: newCenter.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; center:westOf:</h3><pre>center: boxB westOf: boxA   "Center boxB over boxA"   | newCenter |   self addParts: { boxB. boxA. }.   newCenter := { ((boxA centerX) - ( (boxA width + boxB width)/2.0) ). boxA centerY. boxA centerZ.  }.   self center: boxB at: newCenter.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; changed</h3><pre>changed   super changed.   "Transcript cr; show: 'Assembly ',self id,' changed.'."</pre><h3>Hum-UI -- HumAssembly &gt;&gt; exploded</h3><pre>exploded   "Explode assemblies so that all the parts of parts become visible."   | allParts |   allParts := OrderedCollection new.   (self parts) do: [ :subassembly |  (subassembly exploded) do: [ :each | allParts add: each ] ].   ^allParts.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; parts</h3><pre>parts   ^ parts ifNil: [ parts := Set new ].</pre><h3>Hum-UI -- HumAssembly &gt;&gt; position:above:</h3><pre>position: boxA above: boxB   "synonym"   self position: boxA onTopOf: boxB</pre><h3>Hum-UI -- HumAssembly &gt;&gt; position:below:</h3><pre>position: boxA below: boxB   "synonym"   self position: boxA onBottomOf: boxB</pre><h3>Hum-UI -- HumAssembly &gt;&gt; position:eastOf:</h3><pre>position: boxA eastOf: boxB   "Position A on East edge of B."   "Assure both are in my collection."   self addParts: { boxA. boxB. }.   "By convention, A`s West edge will now equal B`s East edge. (zero clearance)"   boxA westEdge: ( boxB eastEdge ).   "Note that up-down  and north-south edges are not affected.   "</pre><h3>Hum-UI -- HumAssembly &gt;&gt; position:northOf:</h3><pre>position: boxA northOf: boxB   "Position A on North edge of B."   "Assure both are in my collection."   self addParts: { boxA. boxB. }.  "By convention, A`s South edget will now equal B`s North."   boxA southEdge: ( boxB northEdge ).</pre><h3>Hum-UI -- HumAssembly &gt;&gt; position:onBottomOf:</h3><pre>position: boxA onBottomOf: boxB   "Position A on bottom of B."  "Assure both are in my collection."   self addParts: { boxA. boxB. }.   "By convention, A`s top will now equal B`s bottom."   boxA topEdge: ( boxB bottomEdge ).</pre><h3>Hum-UI -- HumAssembly &gt;&gt; position:onTopOf:</h3><pre>position: boxA onTopOf: boxB   "Position A on top of B."  "Assure both are in my collection."   self addParts: { boxA. boxB. }.   "By convention, A`s bottom will now equal B`s top."   boxA bottomEdge: ( boxB topEdge ).</pre><h3>Hum-UI -- HumAssembly &gt;&gt; position:over:</h3><pre>position: boxA over: boxB   "synonym"   self position: boxA onTopOf: boxB</pre><h3>Hum-UI -- HumAssembly &gt;&gt; position:southOf:</h3><pre>position: boxA southOf: boxB   "Position A on South edge of B."  "Assure both are in my collection."   self addParts: { boxA. boxB. }.   "By convention, A`s North edge will now equal B`s South. (zero clearance)"   boxA northEdge: ( boxB southEdge ).</pre><h3>Hum-UI -- HumAssembly &gt;&gt; position:under:</h3><pre>position: boxA under: boxB   "synonym"   self position: boxA onBottomOf: boxB</pre><h3>Hum-UI -- HumAssembly &gt;&gt; position:westOf:</h3><pre>position: boxA westOf: boxB   "Position A on West edge of B."  "Assure both are in my collection."   self addParts: { boxA. boxB. }.   "By convention, A`s bottom will now equal B`s top."   boxA eastEdge: ( boxB westEdge ).</pre><h3>Hum-UI -- HumAssembly &gt;&gt; update:</h3><pre>update:  anObject    "TBD"   "Transcript cr; show: 'Assembly: ', self id, ' sees update of: ', anObject asString."   self changed.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; update:with:</h3><pre>update: anAspect with: anObject    "TBD"   Transcript cr; show: 'Assembly: ', self id, ' sees update of: ', anObject asString.   self halt.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; x3DOM</h3><pre>x3DOM   "TODO: Generate HTML to enable X3DOM viewing in Browser."   | html |   self shouldBeImplemented.
   html := '&lt;!DOCTYPE html&gt;&lt;html lang="en" style="width:100%; height:100%; border:0; margin:0; padding:0;"&gt;&lt;head&gt;    &lt;meta charset="utf-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt;    &lt;meta name="description" content=""&gt;    &lt;meta name="keywords" content=""&gt;    &lt;meta name="index" content="follow"&gt;    &lt;meta name="revisit-after" content="2 days"&gt;        &lt;title&gt;Model: Landing Gear &lt;/title&gt;        &lt;link rel="stylesheet" href="static/x3dom.css" type="text/css" charset="utf-8"&gt;&lt;/link&gt;    &lt;link rel="stylesheet" type="text/css" href="static/css/jquery-ui-1.9.2.custom.css" /&gt;    &lt;link rel="stylesheet" type="text/css" href="static/css/ui.css"/&gt;    &lt;style&gt;        .x3dom-logContainer { bottom: 0px; position: absolute; }        body { width:100%; height:100%; border:0; margin:0; padding:0; }    &lt;/style&gt;    &lt;script src="static/x3dom-full.js" type="text/javascript"&gt;&lt;/script&gt;        &lt;script type="text/javascript" src="static/js/jquery-1.9.0.min.js"&gt;&lt;/script&gt;    &lt;script type="text/javascript" src="static/js/jquery-ui-1.9.2.custom.min.js"&gt;&lt;/script&gt;    &lt;script type="text/javascript" src="static/js/settings.js"&gt;&lt;/script&gt;    &lt;script type="text/javascript" src="static/js/ui.js"&gt;&lt;/script&gt;     &lt;script&gt;        // LOD LUT HACK        //x3dom.debug.usePrecisionLevelAsTexCoord = true;    &lt;/script&gt;     &lt;/head&gt;&lt;body&gt;&lt;div class="container" style="width:100%; height:100%; border:0; margin:0; padding:0;"&gt;    &lt;div class="uiTransparent" id="statsWidget" style="right:4px; top:4px;"&gt;        &lt;form class="uiHalfTransparent section" &gt;            &lt;!-- Statistics--&gt;            &lt;div class="uiTransparent" title="Statistics"&gt;Statistics&lt;/div&gt;            &lt;div id="statistics" class="uiTransparent" &gt;                &lt;!-- FPS --&gt;                &lt;div class="setting" id="fpsSetting" title="Frames per Second"&gt;                    &lt;div id="FPS" style="font-size: 1.5em; "&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;!-- rendered triangles --&gt;                &lt;div class="setting" id="renderedTriangles" title="Amount of triangles currently rendered and total"&gt;                    &lt;div class="settingName"&gt;Rendered Triangles&lt;/div&gt;                    &lt;div class="settingControlFullSize"&gt;                        &lt;div id="renderedTrianglesPB" class="progress triangles" &gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;                    &lt;/div&gt;                &lt;/div&gt;                            &lt;/div&gt;        &lt;/form&gt;        &lt;form class="uiHalfTransparent section"&gt;            &lt;!-- interaction --&gt;            &lt;div class="uiTransparent" title="Interaction"&gt;Interaction&lt;/div&gt;            &lt;div id="interaction" class="uiTransparent" &gt;                              &lt;!-- Error Bound--&gt;                                &lt;div class="setting" id="errorBoundSetting" &gt;                    &lt;div class="settingName" id="ebTitle"&gt;Error Bound (Pixels): 1&lt;/div&gt;                    &lt;div class="settingControlFullSize"&gt;                        &lt;div id="errorBoundSlider"&gt;&lt;/div&gt;                    &lt;/div&gt;                &lt;/div&gt;                                &lt;!-- Interaction Factor--&gt;                &lt;div class="setting" id="interactionFactorSetting" &gt;                    &lt;div class="settingName" id="ifTitle"&gt;Interaction Factor: 1&lt;/div&gt;                    &lt;div class="settingControlFullSize"&gt;                        &lt;div id="interactionFactorSlider"&gt;&lt;/div&gt;                    &lt;/div&gt;                &lt;/div&gt;                                &lt;!-- Render Mode--&gt;                &lt;div class="setting" id="renderMode" title="Render mode settings"&gt;                    &lt;div class="settingName" id="renderModeRadio"&gt;Render Mode&lt;/div&gt;                    &lt;div class="settingControlFullSize"&gt;                        &lt;input type="radio" name="rendermode" id="renderPointsButton"&gt;&lt;label for="renderPointsButton" class="roundBorders"&gt;Points&lt;/label&gt;&lt;/input&gt;                        &lt;input type="radio" name="rendermode" id="renderTrianglesButton" checked&gt;&lt;label for="renderTrianglesButton" class="roundBorders"&gt;Faces&lt;/label&gt;&lt;/input&gt;                                            &lt;/div&gt;                &lt;/div&gt;                             &lt;div class="setting"&gt;                    &lt;!-- reset View --&gt;                    &lt;button id="rvButton" title="reset camera to initial position"&gt;Reset View&lt;/button&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/form&gt;    &lt;/div&gt;    &lt;div id="HUDs_Div"&gt;       &lt;div id="X3DOM_AOPT_Links" class="group" style="margin:2px; margin-top:26px; padding:4px; background-color:rgba(199,202,204,.7); position:absolute; float:center; z-index:1000;"&gt;         &lt;a href="http://www.x3dom.org"&gt;X3DOM &lt;/a&gt; output created with &lt;a href="http://www.instantreality.org"&gt;InstantReality &lt;/a&gt; aopt tool.      &lt;/div&gt;             &lt;/div&gt;        &lt;x3d id="x3dElement" swfpath="static/x3dom.swf" showStat="false" showLog="false" style="width:100%; height:100%; border:0; margin:0; padding:0;"&gt;      &lt;scene doPickPass="false"&gt;        &lt;navigationInfo headlight="false"&gt;&lt;/navigationInfo&gt;        &lt;background skyColor="0 0 0"&gt;&lt;/background&gt;                &lt;directionalLight DEF="KEY_LIGHT"  color="0.9 0.9 1.0" direction="-0.7 -0.7 -0.3" intensity="1.0"&gt;&lt;/directionalLight&gt;        &lt;directionalLight DEF="FILL_LIGHT" color="0.9 0.7 0.4" direction="0.7   0.7 -0.3" intensity="0.9"&gt;&lt;/directionalLight&gt;        &lt;directionalLight DEF="BACK_LIGHT" color="1.0 0.9 0.0" direction="0.0   0.7  0.7" intensity="0.4"&gt;&lt;/directionalLight&gt;              &lt;inline DEF="MODEL" url="data/landinggear/landinggear-pop.x3d" mapDEFToID="true" nameSpaceName="model"&gt;&lt;/inline&gt;      &lt;/scene&gt;    &lt;/x3d&gt;            &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;'.   ^html.
</pre><h3>Hum-UI -- HumAssembly &gt;&gt; x3dBackground</h3><pre>x3dBackground   "Provide (default) X3D background element (skybox)"   | x3d |   x3d := '   &lt;Background groundColor="0.7 0.7 0.7"                    skyAngle="0.05 1.5 1.59"                    skyColor="0.6 0.6 0.4  0.4 0.4 0.7  0.3 0.3 0.6  0.1 0.1 0.3"/&gt;  '.   ^x3d.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; x3dBoilerPlate</h3><pre>x3dBoilerPlate   "Provide boilerplate attributes for X3D element"   "profile='Interchange' version='3.2'     xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance'     xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-3.2.xsd'"   | attributes |   attributes := Dictionary new.   attributes      at: 'profile' put: 'Interchange';      at: 'version' put: '3.2';      at: 'xsd' put: 'http://www.w3.org/2001/XMLSchema-instance';      at: 'xsd:noNamespaceSchemaLocation' put: 'http://www.web3d.org/specifications/x3d-3.2.xsd'.   ^attributes.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; x3dObjects</h3><pre>x3dObjects   "Render each of the objects in my collection"   | x3d |
   x3d := '&lt;Group ID="', (self id asString), '" &gt;', String cr.   (self parts)      do: [ :part | x3d := x3d, (part asX3D) ].   x3d := x3d, '&lt;/Group&gt;'.      ^x3d.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; x3dScene</h3><pre>x3dScene   "Return a string representing this assembly as a X3D scene.   "   |  x3d calc |   calc := HumCalculator new.   x3d := calc xml: 'Scene' with: [ ( self x3dBackground ), ( self x3dObjects ) ].   ^x3d.</pre><h3>Hum-UI -- HumAssembly &gt;&gt; zcenter:at:</h3><pre>zcenter: aBox at: anArray    "Center the part (aBox) at the given coordinates. { east. north. up. }   Note: Those coordinates are relative to my origin."   | eastOffset northOffset topOffset |   eastOffset  := self asMeasure: (anArray at: 1).   northOffset := self asMeasure: (anArray at: 2).   topOffset   := self asMeasure: (anArray at: 3).      "Assure that aBox is in my collection. "   self addPart: aBox.      "Compute edge positions to center aBox at those coordinates relative to my origin."   aBox eastEdge:  ( eastOffset  + ( (aBox width  ) * 0.5 ) ).   aBox northEdge: ( northOffset + ( (aBox length ) * 0.5 ) ).   aBox topEdge:   ( topOffset   + ( (aBox height ) * 0.5 ) ).      </pre><h3>Hum-UI -- HumAssembly &gt;&gt; zcenter:onTopOf:</h3><pre>zcenter: boxB onTopOf: boxA   "Center boxB over boxA"   | baseCenter raisedCenter newCenter |   self addParts: { boxB. boxA. }.   self position: boxB onTopOf: boxA.   raisedCenter := boxB center.   baseCenter := boxA center.  "Adjust the x,y coordinates to match the bottom box`s center"   newCenter := Array new: 3.   newCenter at: 1 put: ( baseCenter at: 1).   newCenter at: 2 put: ( baseCenter at: 2 ).   "Keep the new Z."   newCenter at: 3 put: ( raisedCenter at: 3 ).   self center: boxB at: newCenter.</pre><h3>Hum-UI -- HumBox &gt;&gt; aboutEdges</h3><pre>aboutEdges   ^'WARNING: The set/get methods for edges assume a default orientation.'.</pre><h3>Hum-UI -- HumBox &gt;&gt; addPolygon:</h3><pre>addPolygon: aHumPolygon    (self polygons) add: aHumPolygon</pre><h3>Hum-UI -- HumBox &gt;&gt; asCamelCase</h3><pre>asCamelCase   "Return identifier as a camelcase string."   ^ (self id asCamelCase uncapitalized ).</pre><h3>Hum-UI -- HumBox &gt;&gt; asMeasure:</h3><pre>asMeasure: aQuantity   "Convert string/number/measure to a measure. (default unit is meter)"   | measure |   ( aQuantity isKindOf: HumMeasure )      ifTrue: [ measure := aQuantity ].   ( aQuantity isKindOf: String )       ifTrue: [ measure := HumMeasure fromString: aQuantity ].   ( aQuantity isKindOf: Number )      ifTrue: [ measure := HumMeasure quantity: aQuantity units: 'meter' ].   self assert: ( measure isKindOf: HumMeasure ).   ^measure</pre><h3>Hum-UI -- HumBox &gt;&gt; asThreeJS</h3><pre>asThreeJS   "Render this as a box in Three.js"   | js template dictionary calc |   "Note: Caller must merge this into a scene or group geometry"   template := '         var @ID = new THREE.Mesh( ( new THREE.CubeGeometry( @width, @length, @height   )  )                                     , ( new THREE.MeshBasicMaterial( { transparent: true } )  )                                     );         @ID.position.set( @x, @y, @z );         '.    dictionary := Dictionary new.   dictionary     at: 'ID' put: (self asCamelCase );     at: 'width'  put: ( self mm: width  );     at: 'length' put: ( self mm: length );     at: 'height' put: ( self mm: height );      at: 'x' put: (self mm: #centerX );      at: 'y' put: (self mm: #centerY );      at: 'z' put: (self mm: #centerZ ).   calc := HumCalculator new.   js := calc fillTemplate: template fromDictionary: dictionary.   ^js. </pre><h3>Hum-UI -- HumBox &gt;&gt; asX3D</h3><pre>asX3D   "Return a string in X3D notation representing this box / thing.   Caller is responsible for embedding this in a scene.   "   |  x3d calc space position extent |   space := String space.      position := Dictionary new.   position at: 'translation' put: ( self x3dCenter ).   extent := Dictionary new.   extent at: 'size' put: ( self x3dExtent ).   calc := HumCalculator new.   x3d := calc xml: 'transform' dictionary: position                      with: [ calc xml: 'box' dictionary: extent ].  "TODO: Subtypes may add appearance and/or material elements"                        ^x3d.</pre><h3>Hum-UI -- HumBox &gt;&gt; bottomEdge</h3><pre>bottomEdge   ^ bottomEdge</pre><h3>Hum-UI -- HumBox &gt;&gt; bottomEdge:</h3><pre>bottomEdge: aQuantity   "WARNING: Assumes the box has default orientation."   | measure |   measure := self asMeasure: aQuantity.   "Reset the bottom edge"   bottomEdge := measure.   "Force the top "   topEdge := bottomEdge + height.</pre><h3>Hum-UI -- HumBox &gt;&gt; center</h3><pre>center   "Center of box (and/or center of bounding box) -- { x y z } = { east north up }"   | position |   "Compute my center coordinates - { east. north. up }"   position := HumVector newFrom: { self centerX.  self centerY.  self centerZ. }.   ^position.      </pre><h3>Hum-UI -- HumBox &gt;&gt; centerAt:</h3><pre>centerAt: a3Vector    "Center myself at the given coordinates. { east. north. up. }   Note: Those coordinates are relative to my container`s origin."   | eastOffset northOffset topOffset |   eastOffset  := self asMeasure: (a3Vector x).   northOffset := self asMeasure: (a3Vector y).   topOffset   := self asMeasure: (a3Vector z).      "Compute new edge positions to center aBox at those coordinates relative to my origin."   "TODO: This does not provide pitch, yaw, roll."   self eastEdge:   ( eastOffset  + ( ( self width  ) * 0.5 ) ).   self northEdge: ( northOffset + ( ( self length ) * 0.5 ) ).   self topEdge:    ( topOffset    + ( ( self height ) * 0.5 ) ).      </pre><h3>Hum-UI -- HumBox &gt;&gt; centerX</h3><pre>centerX   "X axis points East"    ^(self westEdge + ( (self width ) * 0.5 )).</pre><h3>Hum-UI -- HumBox &gt;&gt; centerY</h3><pre>centerY   "Y dimension points North"    ^( self southEdge + ( (self length ) * 0.5 ) ).</pre><h3>Hum-UI -- HumBox &gt;&gt; centerZ</h3><pre>centerZ   "Z dimension points up."    ^( self bottomEdge + ( (self height ) * 0.5 )  ).</pre><h3>Hum-UI -- HumBox &gt;&gt; changed</h3><pre>changed   "Notify my rendering engine that I am changed."   | comma |   "Notify my dependents."   super changed.   "x,y,z are HumMeasure"   comma := ', '.   "Transcript cr;       show: 'id: ', self id, '(x,y,z): ', self centerX quantityAsString, comma, self centerY quantityAsString, comma, self centerZ quantityAsString;      show: ' (rot,tilt): ', self rotation asString, comma, self tilt asString."</pre><h3>Hum-UI -- HumBox &gt;&gt; depth</h3><pre>depth  "synonym"   ^ length.</pre><h3>Hum-UI -- HumBox &gt;&gt; depth:</h3><pre>depth: aHumMeasure    "synonym"   self length: aHumMeasure.</pre><h3>Hum-UI -- HumBox &gt;&gt; eastEdge</h3><pre>eastEdge   ^ eastEdge</pre><h3>Hum-UI -- HumBox &gt;&gt; eastEdge:</h3><pre>eastEdge: aQuantity   | measure |   measure := self asMeasure: aQuantity.   "Reset the East edge."   eastEdge := measure.   "Force the West edge."   westEdge := eastEdge - width.   </pre><h3>Hum-UI -- HumBox &gt;&gt; equationOfMotion</h3><pre>equationOfMotion   "The equation-of-motion should be a block with args: box and time"   equationOfMotion          ifNil: [ self equationOfMotion: [ :box :time | box centerAt: (box center) + (velocity*time) ] ].   ^equationOfMotion.</pre><h3>Hum-UI -- HumBox &gt;&gt; equationOfMotion:</h3><pre>equationOfMotion: fcSelfAndTime   "The equation-of-motion should be a block with args: box and time"   self assert: ( fcSelfAndTime isKindOf: BlockClosure ).   self assert: ( fcSelfAndTime numArgs = 2 ).   equationOfMotion := fcSelfAndTime.</pre><h3>Hum-UI -- HumBox &gt;&gt; exploded</h3><pre>exploded   ^{ self }.</pre><h3>Hum-UI -- HumBox &gt;&gt; height</h3><pre>height   "Get the height. By convention, height runs up and down."   ^ height</pre><h3>Hum-UI -- HumBox &gt;&gt; height:</h3><pre>height: aQuantity   "Reset the up-down dimension."   | measure |   measure := self asMeasure: aQuantity.
   height := measure.   self assert: ( height quantity &gt;= 0.0 ).   "Hold botton steady and force the top."   topEdge := bottomEdge + height.</pre><h3>Hum-UI -- HumBox &gt;&gt; id</h3><pre>id   "Identifier used in rendering context"   ^ id ifNil: [ id := self identityHash printString ].</pre><h3>Hum-UI -- HumBox &gt;&gt; id:</h3><pre>id: aString   "Identifier used in rendering contexts"   id := aString.</pre><h3>Hum-UI -- HumBox &gt;&gt; id:height:width:depth:</h3><pre>id: aString height: aHeight width: aWidth depth: aDepth    "synonym"   ^ self id: aString height: aHeight width: aWidth length: aDepth.</pre><h3>Hum-UI -- HumBox &gt;&gt; id:height:width:length:</h3><pre>id: aString height: aHeight width: aWidth length: aLength    self initialize;        id: aString;         height: aHeight;         width: aWidth;         length: aLength.</pre><h3>Hum-UI -- HumBox &gt;&gt; initialize</h3><pre>initialize   "Set dimensions to zero."   | zero |   "By convention length is North-South, width is East-West, and height is top-bottom."   "X: East is +. West is -."   "Y: North is +. South is -."   "Z: Up is +. Down is -."   "Default system of metrics is MKS (Meters, Kilograms, Seconds)"   zero := 0 meter.   length := zero.   width := zero.   height := zero.   "Velocity vector = (northward, eastward, upward)"   self velocity: (HumVector newFrom: { 0 mps. 0 mps. 0 mps. }).   "Position edges at zero."   bottomEdge := zero.   topEdge := zero.   eastEdge := zero.   westEdge := zero.   northEdge := zero.   southEdge := zero.</pre><h3>Hum-UI -- HumBox &gt;&gt; jump:</h3><pre>jump: aTime   self assert: (aTime isKindOf: HumMeasure).   "Evaluate my equationOfMotion"   self equationOfMotion value: self value: aTime.   "TODO: Can we make this compatible with HumSimulator?"   </pre><h3>Hum-UI -- HumBox &gt;&gt; length</h3><pre>length   "Get the length. By convention, length runs North and South."   ^ length</pre><h3>Hum-UI -- HumBox &gt;&gt; length:</h3><pre>length: aQuantity   "set North-South dimension"   | measure |   measure := self asMeasure: aQuantity.   "Reset the length. By convention, length runs North and South."   self assert: ( measure quantity &gt;= 0.0 ).   length := measure.   "Hold South steady and force the North."   northEdge := southEdge + length.</pre><h3>Hum-UI -- HumBox &gt;&gt; mm:</h3><pre>mm: aMeasure   "Format this measure to 3 digits accuracy - i.e. millimeter accuracy"   ( aMeasure isKindOf: HumMeasure )         ifTrue: [^ aMeasure quantity printShowingDecimalPlaces: 3.].   ( aMeasure isKindOf: Symbol )         ifTrue: [ |measure|            measure := self perform: aMeasure.            ^ measure quantity printShowingDecimalPlaces: 3. ].         self fail.   </pre><h3>Hum-UI -- HumBox &gt;&gt; mmShave:</h3><pre>mmShave: aMeasure   "Format this measure to 3 digits accuracy - i.e. millimeter accuracy.   But first shave a millimeter from both ends."   ^ (aMeasure - (2 millimeter)) quantity printShowingDecimalPlaces: 3.</pre><h3>Hum-UI -- HumBox &gt;&gt; nextColor</h3><pre>nextColor    "Select from a sequence of colors. Enables reproducable result."   | colorSequence  nextColor |   colorStream       ifNil: [ colorSequence := { Color red. Color orange. Color yellow. Color green. Color blue. Color purple. }.                  colorStream := ReadStream on: colorSequence.           ].   (colorStream atEnd) ifTrue: [ colorStream position: 0 ].   nextColor := colorStream next.   ^nextColor.      </pre><h3>Hum-UI -- HumBox &gt;&gt; northEdge</h3><pre>northEdge   ^ northEdge</pre><h3>Hum-UI -- HumBox &gt;&gt; northEdge:</h3><pre>northEdge: aQuantity   | measure |   measure := self asMeasure: aQuantity.   "Reset North edge."   northEdge := measure.   "Hold North steady and force South."   southEdge := northEdge - length.</pre><h3>Hum-UI -- HumBox &gt;&gt; origin</h3><pre>origin   "Origin is always a zero-sized object at (0 0 0)."   ^ origin ifNil: [ origin := HumBox new.  ].</pre><h3>Hum-UI -- HumBox &gt;&gt; polygons</h3><pre>polygons   "TODO: DANGER -- asPolygons is not defined in this supertype."   ^ polygons ifNil: [ polygons := self asPolygonsColoredBy: [ self color ] ].</pre><h3>Hum-UI -- HumBox &gt;&gt; polygons:</h3><pre>polygons: aCollection    "Computed polygons *may* be stored here."   polygons := aCollection.</pre><h3>Hum-UI -- HumBox &gt;&gt; printOn:</h3><pre>printOn: aStream   "Append to the argument, aStream, a sequence of characters that     identifies the receiver."   | title |   title := self class name.   aStream      nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);      nextPutAll: title;      nextPutAll: '(', self id,')'.</pre><h3>Hum-UI -- HumBox &gt;&gt; rSquared</h3><pre>rSquared   "How far am I from the origin? Use R-squared of my centroid as metric."   | cx cy cz rSquared |   cx := self centerX.   cy := self centerY.   cz := self centerZ.   rSquared := (cx*cx) + (cy*cy) + (cz*cz).   ^rSquared.</pre><h3>Hum-UI -- HumBox &gt;&gt; resetColoring</h3><pre>resetColoring   self nextColor.   colorStream position: 0.</pre><h3>Hum-UI -- HumBox &gt;&gt; rotateLeft:</h3><pre>rotateLeft: angleInDegrees   "Set rotation (yaw) in scene coordinates - Note: This is not additive."   self rotationDegrees: angleInDegrees.</pre><h3>Hum-UI -- HumBox &gt;&gt; rotatePolygons:</h3><pre>rotatePolygons: inputPolygons    "Correct the polygons for my rotation (yaw)."   | resultPolygons centerX centerY  |   centerX := self centerX.   centerY := self centerY.   resultPolygons := OrderedCollection new.   inputPolygons       do: [ :polygon |         | resultPolygon |         resultPolygon := HumPolygon borderColor: polygon borderColor fillColor: polygon fillColor.         resultPolygon parentSolid: self.         resultPolygons add: resultPolygon.         polygon verticesDo: [  :x :y :z |            | alpha beta distance relativeX relativeY rotatedX rotatedY |            relativeX := x - centerX.            relativeY := y - centerY.            alpha := relativeY arcTan: relativeX.            beta := alpha + (self rotation).            distance := ((relativeX*relativeX) + (relativeY*relativeY)) sqrt.            rotatedX := (distance * ( beta cos ) )+ centerX.            rotatedY := (distance * ( beta sin ) ) + centerY.            resultPolygon addVertex: { rotatedX. rotatedY. z. }.             ].         ].   ^resultPolygons.</pre><h3>Hum-UI -- HumBox &gt;&gt; rotateRight:</h3><pre>rotateRight: angleInDegrees   "Set rotation (yaw) in scene coordinates - Note: This is not additive."   self rotationDegrees: angleInDegrees negated.</pre><h3>Hum-UI -- HumBox &gt;&gt; rotation</h3><pre>rotation   "Get my rotation (yaw) in scene coordinates as a value expressed in radians "   | |   ^rotation ifNil: [ rotation := 0.0 ].   </pre><h3>Hum-UI -- HumBox &gt;&gt; rotation:</h3><pre>rotation: angle   "Set my rotation (yaw) in scene coordinates as a value expressed in radians "   | calc |   calc := HumCalculator new.   calc cases;      when: [ angle isKindOf: Float ]          then: [ rotation := angle ];      when: [( angle isKindOf: HumMeasure ) and: [ angle units = #radian ] ]          then: [ rotation := angle quantity ];      otherwise: [ Error signal: 'angle not in expected units' ].   self changed.   </pre><h3>Hum-UI -- HumBox &gt;&gt; rotationDegrees:</h3><pre>rotationDegrees: angle   "Set my rotation (yaw) angle in scene coordinates. "   | calc |   calc := HumCalculator new.   calc cases;      when: [ (angle isKindOf: HumMeasure) and: [angle units = #radian] ]          then: [ self rotation: ( self rotation )+( angle quantity). ];      when: [ (angle isKindOf: HumMeasure) and: [angle units = #degree] ]          then: [ self rotation: ( self rotation )+( angle quantity degreesToRadians ). ];      when: [ angle isKindOf: Float ]         then: [ self rotation: (self rotation) + angle ];       "Assume radian angle."      otherwise: [ Error signal: 'angle not in expected units' ].   self changed. </pre><h3>Hum-UI -- HumBox &gt;&gt; slideBackward:</h3><pre>slideBackward: aHumMeasure    "Slide in the South direction - TODO: adjust for camera rotation."   self slideForward: ( aHumMeasure negated ).</pre><h3>Hum-UI -- HumBox &gt;&gt; slideDown:</h3><pre>slideDown: aHumMeasure    "Move box (e.g. camera) up or down in the scene coordinates."   self topEdge: (self topEdge) - aHumMeasure.   "TODO: Refactor to make this work in camera coordinates - corrected for rotation and tilt."   self changed.</pre><h3>Hum-UI -- HumBox &gt;&gt; slideForward:</h3><pre>slideForward: aHumMeasure    "Slide in the North direction - TODO: adjust for camera rotation."   self southEdge:  ( self southEdge ) + aHumMeasure.   self changed.</pre><h3>Hum-UI -- HumBox &gt;&gt; slideLeft:</h3><pre>slideLeft: aHumMeasure    ^self slideRight: (aHumMeasure negated).</pre><h3>Hum-UI -- HumBox &gt;&gt; slideRight:</h3><pre>slideRight: aHumMeasure    "Move camera left or right --- TODO: Correct this for camera orientation."   self westEdge: (self westEdge) + aHumMeasure.   self changed.</pre><h3>Hum-UI -- HumBox &gt;&gt; slideUp:</h3><pre>slideUp: aHumMeasure    ^self slideDown: (aHumMeasure negated).</pre><h3>Hum-UI -- HumBox &gt;&gt; solidColor:</h3><pre>solidColor: aColor   "What color should be used to render box or bounding-box in a view?"   self assert: (aColor isNil or: [aColor isKindOf: Color]).   solidColor := aColor.</pre><h3>Hum-UI -- HumBox &gt;&gt; southEdge</h3><pre>southEdge   ^ southEdge</pre><h3>Hum-UI -- HumBox &gt;&gt; southEdge:</h3><pre>southEdge: aQuantity   | measure |   measure := self asMeasure: aQuantity.   "Reset the South edge."   southEdge := measure.   "Force North edge."   northEdge := southEdge + length.</pre><h3>Hum-UI -- HumBox &gt;&gt; tilt</h3><pre>tilt   "Get my tilt (pitch) in scene coordinates as a value expressed in radians.   Positive value is an upward tilt. "   ^tiltUpDown ifNil: [ tiltUpDown := 0.0. ].   </pre><h3>Hum-UI -- HumBox &gt;&gt; tilt:</h3><pre>tilt: tiltInRadians   "Set my tilt (pitch) in scene coordinates as a value expressed in radians.   Positive value is an upward tilt. "   | |   self assert: (tiltInRadians isKindOf: Float).   tiltUpDown := tiltInRadians.   self changed.   </pre><h3>Hum-UI -- HumBox &gt;&gt; tiltDegrees:</h3><pre>tiltDegrees: angleInDegrees   "Set my tilt (pitch) angle in scene coordinates. "   | |   (angleInDegrees isKindOf: HumMeasure)      ifTrue: [ ^self tilt: ( self tilt ) + ( angleInDegrees quantity degreesToRadians )  ].   "Otherwise:"   self tilt: ( self tilt ) + ( angleInDegrees degreesToRadians ).</pre><h3>Hum-UI -- HumBox &gt;&gt; tiltDown:</h3><pre>tiltDown: angleInDegrees   "Set tilt  (pitch)  in scene coordinates - Note: This is not additive."   self tiltDegrees: angleInDegrees negated.</pre><h3>Hum-UI -- HumBox &gt;&gt; tiltPolygons:</h3><pre>tiltPolygons: inputPolygons    "Correct the polygons for my tilt (pitch)."   | resultPolygons  centerY  centerZ |   (self tilt = 0) ifTrue: [ ^inputPolygons ].   centerY := self centerY.   centerZ := self centerZ.   resultPolygons := OrderedCollection new.   inputPolygons       do: [ :polygon |         | resultPolygon |         resultPolygon := HumPolygon borderColor: polygon borderColor fillColor: polygon fillColor.         resultPolygon parentSolid: self.         resultPolygons add: resultPolygon.         polygon verticesDo: [  :x :y :z |            | alpha beta distance  relativeY relativeZ  tiltY tiltZ |            relativeY := y - centerY.            relativeZ := z - centerZ.            alpha := relativeY arcTan: relativeZ. "Float&gt;&gt;arcTan"            beta := alpha + (self tilt).            distance := ( (relativeY*relativeY) + (relativeZ*relativeZ) ) sqrt.            tiltY := ( distance * ( beta cos  ) ) + centerY.            tiltZ := ( distance * ( beta sin ) ) + centerZ.            resultPolygon addVertex: { x. tiltY. tiltZ. }.             ].         ].   ^resultPolygons.</pre><h3>Hum-UI -- HumBox &gt;&gt; tiltUp:</h3><pre>tiltUp: angleInDegrees   "Set tilt (pitch) in scene coordinates - Note: This is not additive."   self tiltDegrees: angleInDegrees.</pre><h3>Hum-UI -- HumBox &gt;&gt; topEdge</h3><pre>topEdge   ^ topEdge</pre><h3>Hum-UI -- HumBox &gt;&gt; topEdge:</h3><pre>topEdge: aQuantity   | measure |   measure := self asMeasure: aQuantity.   "Reset the top edge."   topEdge := measure.   "Force the bottom edge."   bottomEdge := topEdge - height.</pre><h3>Hum-UI -- HumBox &gt;&gt; velocity:</h3><pre>velocity: aHumVector   "What is the 3D object`s current velocity?"   self assert: (aHumVector isKindOf: HumVector).   self assert: (aHumVector dimensions = (1.0 meterPerSecond dimensions) ).   velocity := aHumVector.</pre><h3>Hum-UI -- HumBox &gt;&gt; volume</h3><pre>volume   "Calculate the volume"   | v |   v := (self height) * (self width) * (self length).   "TODO: This should be a HumMeasure with dimension of L^3"   ^v.</pre><h3>Hum-UI -- HumBox &gt;&gt; westEdge</h3><pre>westEdge   ^ westEdge</pre><h3>Hum-UI -- HumBox &gt;&gt; westEdge:</h3><pre>westEdge: aQuantity   | measure |   measure := self asMeasure: aQuantity.   "Reset the West edge."   westEdge := measure.   "Force the East edge."   eastEdge := westEdge + width.</pre><h3>Hum-UI -- HumBox &gt;&gt; width</h3><pre>width   "Get the width. By convention, the width runs East and West."   ^ width</pre><h3>Hum-UI -- HumBox &gt;&gt; width:</h3><pre>width: aQuantity   "Reset the East-West dimension"   | measure |   measure := self asMeasure: aQuantity.   self assert: (measure quantity &gt;= 0.0 ).   width := measure.   "Hold West edge steady and force the East edge."   eastEdge := westEdge + width.</pre><h3>Hum-UI -- HumBox &gt;&gt; x3dCenter</h3><pre>x3dCenter   "Center of box (and/or center of bounding box) -- { x y z }   Note: This needs to map Hum coordinates to X3D coordinates.   "   | s |   "X"   s := ( self westEdge + ( (self width ) * 0.5 ) ) quantity asString.   "Y"   s := s, ' ', ( self southEdge + ( (self length ) * 0.5 ) ) quantity asString.
   "Z"   s := s, ' ', ( self bottomEdge + ( (self height ) * 0.5 ) ) quantity asString.   ^s      </pre><h3>Hum-UI -- HumBox &gt;&gt; x3dExtent</h3><pre>x3dExtent   "Return x y z extents as a string   Note: This needs to map Hum coordinates to X3D coordinates.   TODO: HumSolid may override to subtract some clearance quantity (e.g. 1 or 2 mm) from quantities.   "   |s|   "X"   s :=         ( self mm: width  ).   "Y"   s := s, ' ', ( self mm: length ).   "Z"   s := s, ' ', ( self mm: height ).   ^s.</pre><h3>Hum-UI -- HumBox &gt;&gt; xyzString</h3><pre>xyzString   | s x y z space |   x := self centerX.   y := self centerY.   z := self centerZ.   self assert: (x isKindOf: HumMeasure).   space := ' '.   s := '( ',(x quantityAsString), space, (y quantityAsString), space, (z quantityAsString), ')'.   ^s.</pre><h3>Hum-UI -- HumBox &gt;&gt; zslideRight:</h3><pre>zslideRight: aHumMeasure    "Move camera left or right --- TODO: Correct this for camera orientation."   self westEdge: (self westEdge) + aHumMeasure.   self changed.</pre><h3>Hum-UI -- HumCamera &gt;&gt; eyeX</h3><pre>eyeX   "Eye in scene coordinates.     Note: In a simulation, this should be location of pin-hole;    but . . . center point is more convenient."   ^(self westEdge + ((self width) * 0.5) ).</pre><h3>Hum-UI -- HumCamera &gt;&gt; eyeY</h3><pre>eyeY   "Eye in scene coordinates."   ^(self northEdge) - (self depth).</pre><h3>Hum-UI -- HumCamera &gt;&gt; eyeZ</h3><pre>eyeZ   "Eye in scene coordinates."   ^((self topEdge) - ((self height) * 0.5) )</pre><h3>Hum-UI -- HumCamera &gt;&gt; isPointInFieldOfView:</h3><pre>isPointInFieldOfView: a3Dpoint    "Is the given 3D point within my field of view.     Note: The point must be in camera coordinates."   | x y z  pointDxDy pointDzDy  cameraDxDy cameraDzDy |      x := a3Dpoint at: 1.   y := a3Dpoint at: 2.   z := a3Dpoint at: 3.      "Is the point behind the camera`s aperture?"   (y  &lt; (self depth)) ifTrue: [  ^false ].   "Is point in horizontal field of view?"   pointDxDy := x / y.   cameraDxDy :=  ( self width )  / ( self depth ).   ( (pointDxDy abs) &lt;= cameraDxDy ) ifFalse: [ ^false. ].   "Is point in verticle field of view?"   pointDzDy := z / y.   cameraDzDy :=  ( self height )  / ( self depth ).   ( (pointDzDy abs) &lt;= cameraDzDy ) ifFalse: [ ^false. ].   "Passed the filters. Looks okay."   ^true.</pre><h3>Hum-UI -- HumCamera &gt;&gt; slideBackward:</h3><pre>slideBackward: aDistance   self slideForward: ( aDistance negated ).</pre><h3>Hum-UI -- HumCamera &gt;&gt; slideForward:</h3><pre>slideForward: aDistance   "Move in the direction the camera is pointing."   | myCentroid nextCentroid directionVector |   self assert: (aDistance isKindOf: HumMeasure). "a scalar"      myCentroid := self center.   self assert: (myCentroid isKindOf: HumVector).   directionVector := self unitForward.   self assert: (directionVector isKindOf: HumVector).   nextCentroid := myCentroid + (directionVector * aDistance).   self centerAt: nextCentroid.   self changed.      </pre><h3>Hum-UI -- HumCamera &gt;&gt; slideLeft:</h3><pre>slideLeft: aDistance   ^self slideRight: (aDistance negated).      </pre><h3>Hum-UI -- HumCamera &gt;&gt; slideRight:</h3><pre>slideRight: aDistance   "Move in the direction the camera is pointing."   | myCentroid nextCentroid directionVector |   self assert: (aDistance isKindOf: HumMeasure). "a scalar"      myCentroid := self center.   self assert: (myCentroid isKindOf: HumVector).   directionVector := self unitSideways.   self assert: (directionVector isKindOf: HumVector).   nextCentroid := myCentroid + (directionVector * aDistance).   self centerAt: nextCentroid.   self changed.      </pre><h3>Hum-UI -- HumCamera &gt;&gt; slideUpward:</h3><pre>slideUpward: aDistance   "Move in the direction the camera is pointing."   | myCentroid nextCentroid directionVector |   self assert: (aDistance isKindOf: HumMeasure). "a scalar"      myCentroid := self center.   self assert: (myCentroid isKindOf: HumVector).   directionVector := self unitUpDown.   self assert: (directionVector isKindOf: HumVector).   nextCentroid := myCentroid + (directionVector * aDistance).   self centerAt: nextCentroid.   self changed.      </pre><h3>Hum-UI -- HumCamera &gt;&gt; unitForward</h3><pre>unitForward   "Return unit vector pointing along my internal y axis due to my rotation and tilt."   | x y z alpha beta unitVector |   alpha := self rotation.   beta := self tilt.   x := ( alpha sin ) * ( 1.0 ).   y := ( alpha cos ) * ( beta cos ).   z := ( alpha cos ) * ( beta sin ).   unitVector := HumVector newFrom: { x. y. z. } units: 'none'. "unit vector is dimensionless"   self assert: (  ( unitVector length quantity - 1.0 ) abs &lt; (0.001 )  ).   ^unitVector.</pre><h3>Hum-UI -- HumCamera &gt;&gt; unitSideways</h3><pre>unitSideways   "Return unit vector pointing along my internal x axis due to my rotation and tilt."   | x y z alpha beta unitVector |   alpha := (self rotation) + ( 90.0 degreesToRadians ).   beta := self tilt.   x := ( alpha sin ) * ( 1.0 ).   y := ( alpha cos ) * ( beta cos ).   z := ( alpha cos ) * ( beta sin ).   unitVector := HumVector newFrom: { x. y. z. } units: 'none'. "unit vector is dimensionless"   self assert: (  ( unitVector length quantity - 1.0 ) abs &lt; (0.001 )  ).   ^unitVector.</pre><h3>Hum-UI -- HumCamera &gt;&gt; unitUpDown</h3><pre>unitUpDown   "Return unit vector pointing along my internal x axis due to my rotation and tilt."   | x y z alpha beta unitVector |   alpha := ( self rotation ).   beta := ( self tilt ) + ( 90.0 degreesToRadians ).   x := ( alpha sin ) * ( 1.0 ).   y := ( alpha cos ) * ( beta cos ).   z := ( alpha cos ) * ( beta sin ).   unitVector := HumVector newFrom: { x. y. z. } units: 'none'. "unit vector is dimensionless"   self assert: (  ( unitVector length quantity - 1.0 ) abs &lt; (0.001 )  ).   ^unitVector.</pre><h3>Hum-UI -- HumCanvas &gt;&gt; about</h3><pre>about"Q: What is the relation between Sensor, Scribe, Widget, Canvas, Solid, ViewPort.A: The Scribe interprets inputs from the Sensor and updates a Widget.The Widget is drawn on a Canvas which is painted on a Surface.A Surface might be painted on a Solid within a Scene.Note: A Surface is not rendered if it is not visible to the Viewport`s Camera. The flow is Sensor &gt;&gt; Scribe &gt;&gt; Widget &gt;&gt; Canvas &gt;&gt; Surface &gt;&gt; ViewPort (Camera)."</pre><h3>Hum-UI -- HumCanvas &gt;&gt; asMorph</h3><pre>asMorph   | morph baseForm |   "morph := self formCanvas form asMorph."   baseForm :=  self formCanvas form.   morph := HumViewPortMorph withForm: baseForm.   morph isOpaque: true.    ^morph.   </pre><h3>Hum-UI -- HumCanvas &gt;&gt; borderWidth:borderColor:</h3><pre>borderWidth: aWidth borderColor: aColor    self formCanvas form border: (formCanvas form boundingBox) width: aWidth fillColor: aColor.</pre><h3>Hum-UI -- HumCanvas &gt;&gt; brushColor</h3><pre>brushColor   "Get my brush color."      ^brushColor ifNil: [brushColor := Color black].</pre><h3>Hum-UI -- HumCanvas &gt;&gt; brushColor:</h3><pre>brushColor: aColor    "Set my brush color."   self assert: ( aColor isKindOf: Color ).   brushColor := aColor.</pre><h3>Hum-UI -- HumCanvas &gt;&gt; brushPosition</h3><pre>brushPosition   "Get my latest brush position."   ^brushPosition ifNil: [ Error signal: 'brush position has not been set' ]</pre><h3>Hum-UI -- HumCanvas &gt;&gt; brushPosition:</h3><pre>brushPosition: aPoint    "Remember my latest brush position."   brushPosition := aPoint</pre><h3>Hum-UI -- HumCanvas &gt;&gt; drawHumPolygon:</h3><pre>drawHumPolygon: aHumPolygon    "The HumPolygon contains 3D points  and specifies fill and border colors.    We translate to 2D and draw on our form."   | polygonVertices  borderWidth aBorderColor firstPoint  |   borderWidth := 3.  "TODO: MAGIC NUMBER."   aBorderColor := aHumPolygon borderColor.   self brushColor: aBorderColor.   "aFillColor := aHumPolygon fillColor."   "Transform to 2D points"   polygonVertices := aHumPolygon xyPoints.    firstPoint := "self scaleScenePoint:" ( polygonVertices at: 1 ).   self moveBrushTo: firstPoint.   polygonVertices allButFirstDo: [ :vertex |         | nextPoint |         nextPoint := "self scaleScenePoint:" vertex.         self paintTo: nextPoint.          ].   self paintTo: firstPoint.</pre><h3>Hum-UI -- HumCanvas &gt;&gt; drawPolygon:scale:</h3><pre>drawPolygon: aHumPolygon scale: pxPerMeter    |  vertices  |   self assert: ( aHumPolygon isKindOf: HumPolygon).   self assert: ( pxPerMeter isKindOf: HumMeasure).      self brushColor: aHumPolygon borderColor.   vertices := aHumPolygon vertices.   self moveBrushTo: ( self scalePoint: (vertices first) scaleRatio: pxPerMeter ).   vertices allButFirstDo: [ :vertex |  self paintTo: (self scalePoint: vertex scaleRatio: pxPerMeter) ].   self paintTo: ( self scalePoint: (vertices first) scaleRatio: pxPerMeter).</pre><h3>Hum-UI -- HumCanvas &gt;&gt; drawTextLines:withFont:</h3><pre>drawTextLines: textLines withFont: aFont   | lineHeight em myCanvas |   lineHeight := aFont height.   em := aFont linearWidthOf: $m.   myCanvas := (self formCanvas)."FormCanvas"   textLines      keysAndValuesDo: [ :key :value |         | string |                  string:= "(key printPaddedWith: Character space to: 3 ), ' ', " value.         myCanvas drawString: string at: em@(key*(lineHeight)) font: aFont color: (Color black).          ].</pre><h3>Hum-UI -- HumCanvas &gt;&gt; extent</h3><pre>extent   "What is my height and width?"   | extent |   extent := self formCanvas extent.   self assert: (extent isKindOf: Point).   ^extent.   </pre><h3>Hum-UI -- HumCanvas &gt;&gt; fillBackground</h3><pre>fillBackground   | rectangle fillColor |   fillColor := self skyColor.   rectangle := Rectangle origin: 0@0 extent: formCanvas  extent .   "self formCanvas             frameAndFillRectangle: rectangle             fillColor: fillColor             borderWidth: 2 topLeftColor: fillColor bottomRightColor: fillColor."   self formCanvas form fillWithColor: fillColor.</pre><h3>Hum-UI -- HumCanvas &gt;&gt; formCanvas</h3><pre>formCanvas    "What form should I draw on."   ^formCanvas ifNil: [  formCanvas := FormCanvas on: (Form extent: DisplayScreen boundingBox extent depth: 32) ].</pre><h3>Hum-UI -- HumCanvas &gt;&gt; formCanvas:</h3><pre>formCanvas: aFormCanvas    "What form should I draw on."   formCanvas := aFormCanvas.   self fillBackground.</pre><h3>Hum-UI -- HumCanvas &gt;&gt; height</h3><pre>height   "What is my height?"   | extent height |   extent := self extent.   self assert: (extent isKindOf: Point).   height := extent y.   ^height.   </pre><h3>Hum-UI -- HumCanvas &gt;&gt; moveBrushTo:</h3><pre>moveBrushTo: aCanvasPoint   "Position the brush, but do not paint yet."   |  |   self assert: (aCanvasPoint isKindOf: Point).   self brushPosition: aCanvasPoint.       </pre><h3>Hum-UI -- HumCanvas &gt;&gt; paintTo:</h3><pre>paintTo: aCanvasPoint    self assert: (aCanvasPoint isKindOf: Point).   "The point should be inside the canvas bounds. Rectangle"   self assert: (self formCanvas clipRect containsPoint: aCanvasPoint )          description: 'Attempt to move brush beyond canvas: ', (aCanvasPoint asString).   "TODO: Put pixels from brush onto my Form."   self formCanvas line: self brushPosition to: aCanvasPoint width: 2 color: self brushColor.   self brushPosition: aCanvasPoint.</pre><h3>Hum-UI -- HumCanvas &gt;&gt; projectScenePoint:cameraDepth:</h3><pre>projectScenePoint: aScenePoint cameraDepth: aCameraDepth   "Translate from scene coordinates (meters) to canvas coordinates (px)"   | aCanvasPoint  sceneX sceneY sceneZ screenX screenY x y xOffset yOffset dxdy dzdy |   self assert: (aScenePoint isKindOf: Array ).   self assert: (aScenePoint size &gt; 1).   "Map East-West to x; North-South to y; Up-Down to z, Time to w."   sceneX := aScenePoint at: 1.   sceneY := aScenePoint at: 2.   sceneZ := aScenePoint at: 3.      dxdy := (sceneX / sceneY) quantity.  "East over North"   dzdy := (sceneZ / sceneY) quantity.      screenX :=  aCameraDepth * dxdy.   screenY :=  aCameraDepth * dzdy.      x := (screenX * (self scalePixelsPerMillimeter)) quantity rounded.   y := (screenY * (self scalePixelsPerMillimeter)) quantity rounded.      xOffset := self formCanvas form width // 2.   yOffset := self formCanvas form height // 2.   aCanvasPoint := ( x + xOffset )@(y +  yOffset).    ^aCanvasPoint.</pre><h3>Hum-UI -- HumCanvas &gt;&gt; scalePixelsPerMillimeter</h3><pre>scalePixelsPerMillimeter   "How many pixels per millimeter of camera viewbox?"   ^ pixelsPerMillimeter ifNil: [ 4 ].</pre><h3>Hum-UI -- HumCanvas &gt;&gt; scalePixelsPerMillimeter:</h3><pre>scalePixelsPerMillimeter: aNumber   "How many pixels per millimeter of viewbox?"   pixelsPerMillimeter := aNumber.</pre><h3>Hum-UI -- HumCanvas &gt;&gt; scalePoint:scaleRatio:</h3><pre>scalePoint: aScenePoint scaleRatio: pxPerMeter    "Return a x@y point by scaling the given scene point"   | sceneX sceneY canvasX canvasY |   (((aScenePoint isKindOf: HumVector)       or: [aScenePoint isKindOf: Array])      or: [aScenePoint isKindOf: OrderedCollection]   )      ifFalse: [ Error signal: 'Scene Point is not of expected type' ].   sceneX := aScenePoint at: 1.   sceneY := aScenePoint at: 2.   ( sceneX isPixels )       ifTrue: [ "Already scaled."         canvasX := sceneX quantity rounded.          canvasY := sceneY quantity rounded.          ]       ifFalse: [ "Apply scale factor"         canvasX := ( sceneX * pxPerMeter ) quantity rounded.          canvasY := ( sceneY * pxPerMeter ) quantity rounded.         ].   ^ canvasX @ canvasY.      </pre><h3>Hum-UI -- HumCanvas &gt;&gt; skyColor</h3><pre>skyColor   "What color to use for background fill?"   ^ skyColor ifNil: [ skyColor := Color cyan lighter lighter  ]</pre><h3>Hum-UI -- HumCanvas &gt;&gt; skyColor:</h3><pre>skyColor: aColor   "What color to use for background fill?"   skyColor := aColor.</pre><h3>Hum-UI -- HumCanvas &gt;&gt; width</h3><pre>width   "What is my width?"   | extent width |   extent := self extent.   self assert: (extent isKindOf: Point).   width := extent x.   ^width.   </pre><h3>Hum-UI -- HumCategoryWidget &gt;&gt; categories</h3><pre>categories   ^categories ifNil: [Error signal: 'categories have not been initialized']</pre><h3>Hum-UI -- HumCategoryWidget &gt;&gt; categories:</h3><pre>categories: anArrayOfCategoryNames    categories := anArrayOfCategoryNames. </pre><h3>Hum-UI -- HumCategoryWidget &gt;&gt; renderContentOn:</h3><pre>renderContentOn: aWAHtmlCanvas   "render self via a simple input tag"   |  |aWAHtmlCanvas select      list: (self categories);      attributeAt: 'id' put: (self attributeName );      callback: [:value | self store: value ];      with: (self attributeValue asString).</pre><h3>Hum-UI -- HumColumnLayoutWidget &gt;&gt; asHTML</h3><pre>asHTML   "Generate a div containing child widget renderings."   |  html calc columnGenerator |   calc := HumCalculator new.      columnGenerator := [ | innerHTML |      innerHTML := String new.      ( self widgets ) do: [ :widget |          | cellHTML |         cellHTML := calc xml: 'tr'                            with: [calc xml: 'td'                                        with: [ widget asHTML ]                                       ].         innerHTML := innerHTML, cellHTML.          ].         innerHTML. "returned value"      ].   html := calc xml: 'div'                   with: [ calc xml: 'table'                               with: [  columnGenerator value  ].                                     ].   ^html.   </pre><h3>Hum-UI -- HumColumnLayoutWidget &gt;&gt; asMorph</h3><pre>asMorph   | layoutMorph childMorphs |   layoutMorph := AlignmentMorph new.   childMorphs := OrderedCollection new.   (self widgets)       do: [ :widget |          | child |         child := widget asMorph.         child cellPositioning: #topLeft; autoFit: true.         childMorphs add: child.          ].      layoutMorph  setAsColumn             color: Color white;         vResizing: #shrinkWrap;         hResizing: #shrinkWrap;         layoutInset: 1;         wrapCentering: #center;         cellPositioning: #topLeft.            childMorphs      do: [ :each | layoutMorph addMorphBack: each ].   ^layoutMorph.</pre><h3>Hum-UI -- HumDateWidget &gt;&gt; renderContentOn:</h3><pre>renderContentOn: aWAHtmlCanvas   "render self via a simple input tag"   | |   aWAHtmlCanvas textInput     type: 'date';       attributeAt: 'id' put: (self attributeName );      callback: [:value | self store: value ];      with: (self attributeValue asString).</pre><h3>Hum-UI -- HumDiagram &gt;&gt; addConnection:</h3><pre>addConnection: anAssociation    "anAssociation := ( fromNode -&gt; toNode )"   | label  fromNode toNode |   self assert: ( anAssociation isKindOf: Association ).   fromNode := anAssociation key.   toNode := anAssociation value.   label := (fromNode title),'-&gt;',(toNode title).   self graph addConnection: anAssociation label: label.</pre><h3>Hum-UI -- HumDiagram &gt;&gt; addConnection:label:</h3><pre>addConnection: anAssociation label: aString   "anAssociation := ( fromNode -&gt; toNode )"   self assert: ( anAssociation isKindOf: Association ).   self graph addConnection: anAssociation label: aString.</pre><h3>Hum-UI -- HumDiagram &gt;&gt; addNode:</h3><pre>addNode: anObject   "A node object should have a title.    (It should have something to display in a rendering or mouse-over or debug.) "   self assert: (anObject class selectors includes: #title ).   self graph addNode: anObject label: anObject title.</pre><h3>Hum-UI -- HumDiagram &gt;&gt; asSVGonHtml:width:height:</h3><pre>asSVGonHtml: html width: aWidth height: aHeight    "TODO: REFACTOR to render as HTML string."   |  |   self assert: ( html isKindOf: String ).   html div       class: 'diagram';       id: (self title asCamelCase);      with: ["Label and Diagram"         html strong: self title.         html break.         "Eventually, we want to draw the diagram using SVG."         ( html tag: 'svg' )             attributeAt: 'width' put: (aWidth asString);                 attributeAt: 'height' put: (aHeight asString);            attributeAt: 'viewBox' put: '0 0 1000 1000';            attributeAt: 'style' put: 'background: CYAN';            "FOLLOWING IS A STUB -- EVENTUALLY THIS WILL DRAW NODES AND CONNECTIONS"            "ToDo: Finish this after we have layout working."            with: ["SVG path element"               ( html tag: 'path' )                  attributeAt: 'd' put: 'M 100 100  q 0,100 100,100 ';                  attributeAt: 'fill' put: 'none';                  attributeAt: 'stroke' put: 'red';                  attributeAt: 'stroke-width' put: '1'.               ( html tag: 'text' )                   attributeAt: 'x' put: 200;                  attributeAt: 'y' put: 200;                  attributeAt: 'font-size' put: 20;                  attributeAt: 'fill' put: 'BLUE';                  with: 'This is just a test of the SVG text rendering.'               ].         ].</pre><h3>Hum-UI -- HumDiagram &gt;&gt; asSVGonHtmlCanvas:width:height:</h3><pre>asSVGonHtmlCanvas: html width: aWidth height: aHeight    "Render this diagram on the given Seaside canvas.   Note: We use SVG.   "   |  |   self assert: ( html isKindOf: WACanvas ).   html div       class: 'diagram';       id: (self title asCamelCase);      with: ["Label and Diagram"         html strong: self title.         html break.         "Eventually, we want to draw the diagram using SVG."         ( html tag: 'svg' )             attributeAt: 'width' put: (aWidth asString);                 attributeAt: 'height' put: (aHeight asString);            attributeAt: 'viewBox' put: '0 0 1000 1000';            attributeAt: 'style' put: 'background: CYAN';            "FOLLOWING IS A STUB -- EVENTUALLY THIS WILL DRAW NODES AND CONNECTIONS"            "ToDo: Finish this after we have layout working."            with: ["SVG path element"               ( html tag: 'path' )                  attributeAt: 'd' put: 'M 100 100  q 0,100 100,100 ';                  attributeAt: 'fill' put: 'none';                  attributeAt: 'stroke' put: 'red';                  attributeAt: 'stroke-width' put: '1'.               ( html tag: 'text' )                   attributeAt: 'x' put: 200;                  attributeAt: 'y' put: 200;                  attributeAt: 'font-size' put: 20;                  attributeAt: 'fill' put: 'BLUE';                  with: 'This is just a test of the SVG text rendering.'               ].         ].</pre><h3>Hum-UI -- HumDiagram &gt;&gt; asSVGonSeasideCanvas:width:height:</h3><pre>asSVGonSeasideCanvas: html width: aWidth height: aHeight    "Render this diagram on the given Seaside canvas.   Note: We use SVG.   "   |  |   self assert: ( html isKindOf: (self seasideCanvas) ).   html div       class: 'diagram';       id: (self title asCamelCase);      with: ["Label and Diagram"         html strong: self title.         html break.         "Eventually, we want to draw the diagram using SVG."         ( html tag: 'svg' )             attributeAt: 'width' put: (aWidth asString);                 attributeAt: 'height' put: (aHeight asString);            attributeAt: 'viewBox' put: '0 0 1000 1000';            attributeAt: 'style' put: 'background: CYAN';            "FOLLOWING IS A STUB -- EVENTUALLY THIS WILL DRAW NODES AND CONNECTIONS"            "ToDo: Finish this after we have layout working."            with: ["SVG path element"               ( html tag: 'path' )                  attributeAt: 'd' put: 'M 100 100  q 0,100 100,100 ';                  attributeAt: 'fill' put: 'none';                  attributeAt: 'stroke' put: 'red';                  attributeAt: 'stroke-width' put: '1'.               ( html tag: 'text' )                   attributeAt: 'x' put: 200;                  attributeAt: 'y' put: 200;                  attributeAt: 'font-size' put: 20;                  attributeAt: 'fill' put: 'BLUE';                  with: 'This is just a test of the SVG text rendering.'               ].         ].</pre><h3>Hum-UI -- HumDiagram &gt;&gt; connections</h3><pre>connections   "Model connections as a set of associations."   ^ self graph connections.   </pre><h3>Hum-UI -- HumDiagram &gt;&gt; countNeighborsOfNode:</h3><pre>countNeighborsOfNode: aNode   "Return the number of neighbors of this node.    (Count nodes that are directly connected to this node)"   | count |   count := 0.   ( self connections )       do: [ :map | (((map key) = aNode) or: [(map value) = aNode])          ifTrue: [ count := count + 1 ] ].   ^ count</pre><h3>Hum-UI -- HumDiagram &gt;&gt; getNodesDownstreamFromNode:</h3><pre>getNodesDownstreamFromNode: thisNode    "Return nodes that are connected downstream from this node."   | result |   result := Set new.   ( self connections )      do: [ :connection |         | upstreamNode downstreamNode |         upstreamNode := connection key.         downstreamNode := connection value.         ( upstreamNode = thisNode )            ifTrue: [ result add: downstreamNode ].         ].   ^ result.</pre><h3>Hum-UI -- HumDiagram &gt;&gt; getNodesUpstreamFromNode:</h3><pre>getNodesUpstreamFromNode: thisNode    "Return nodes that are connected upstream from this node."   | result |   result := Set new.   ( self connections )      do: [ :connection |         | upstreamNode downstreamNode |         upstreamNode := connection key.         downstreamNode := connection value.         ( downstreamNode = thisNode )            ifTrue: [ result add: upstreamNode ].         ].   ^ result.</pre><h3>Hum-UI -- HumDiagram &gt;&gt; getPositionForNode:</h3><pre>getPositionForNode: aNodeObject   ^ self mapNodePosition at: aNodeObject ifAbsent: [ ^nil ].</pre><h3>Hum-UI -- HumDiagram &gt;&gt; graph</h3><pre>graph   ^graph ifNil: [ graph := HumGraph new. ].</pre><h3>Hum-UI -- HumDiagram &gt;&gt; initialize</h3><pre>initialize   "Set up the graph instance that backs this diagram."   | |   self assert: ((self graph) isKindOf: HumGraph).</pre><h3>Hum-UI -- HumDiagram &gt;&gt; layoutDiagramWithNodeExtent:nodeSpacing:</h3><pre>layoutDiagramWithNodeExtent: extentPoint nodeSpacing: spacingPoint   "Layout the diagram using the given node extent and spacing between node edges."   | xIncrement yIncrement nodePriority nodesByPriority |   "Following must be set before calling me."   self assert: ( extentPoint notNil ).   self assert: ( spacingPoint notNil ).   "Following is assumed in code below."   self assert: ( extentPoint  isKindOf: Point).   self assert: ( spacingPoint isKindOf: Point).   "Reset these instance (global) variables!"   nodeExtent := extentPoint.   nodeSpacing := spacingPoint.      "Compute increments between grid locations."   "In this version, the placement is on a rectalinear grid.   But other/future versions may be radial and/or decrease as the number of priorNodes increases.   "   xIncrement := (nodeSpacing x) + (( nodeExtent x )/2).   yIncrement := (nodeSpacing y) + (( nodeExtent y )/2).      "Strategy: Prioritize the objects that have the most connections."   "Count the number of connections that each node has."   nodePriority := Dictionary new.   (self connections)      do: [ :map |          | fromNode toNode fromCount toCount |         fromNode := map key.         toNode := map value.          fromCount := nodePriority at: fromNode ifAbsent: [0].         nodePriority at: fromNode put: ( fromCount + 1).         toCount := nodePriority at: toNode ifAbsent: [0].         nodePriority at: toNode put: ( toCount + 1).         ].   "Sort into a collection where nodes with most connections appear first."      nodesByPriority := SortedCollection new.   nodePriority       keysAndValuesDo: [ :node :priority |         nodesByPriority add: ( (priority negated) -&gt; node ).         ].    "Place the nodes with the most connections on the first pass.   Note: This documentation uses term 'primary node' to refer to the node seen first.         The primary node will be placed at 0@0.   "      nodesByPriority      do: [ :map |         | node xy |         node := map value.         xy := 0@0.         self layoutRecursiveWithNode: node relativePosition: xy seenBefore: (Set new).         xy := xy + (0@yIncrement).         ].       </pre><h3>Hum-UI -- HumDiagram &gt;&gt; layoutDistanceFromNode:toNode:</h3><pre>layoutDistanceFromNode: nodeA toNode: nodeB   "Calculate the length of the connection between the nodes."   | xA xB yA yB xR yR r2 r|   xA := (( self mapNodePosition ) at: nodeA ) x.   yA := (( self mapNodePosition ) at: nodeA ) y.   xB := (( self mapNodePosition ) at: nodeB ) x.   yB := (( self mapNodePosition ) at: nodeB ) y.      xR := xA - xB.   yR := yA - yB.      r2 := ( xR * xR ) + ( yR * yR ).   r := r2 sqrt.   ^r   </pre><h3>Hum-UI -- HumDiagram &gt;&gt; layoutEnergyOnNode:fromNode:</h3><pre>layoutEnergyOnNode: nodeA fromNode: nodeB   "Calculate a energy scalar.     Rules are similar to elctrostatic energy.    But since the layout is in a 2-D world,      the energy rules are linear. (in this version)    Note: This method assumes that nodeA and nodeB are directly connected.   "   | r qA qB attraction repulsion attractionFactor repulsionFactor |      "Radius is the length of the connection between the nodes."   r := self layoutDistanceFromNode: nodeA toNode: nodeB.      "Attractive force increases when the radius increases.   This is analog of spring rate.   "   attractionFactor  := 1.0.   attraction := attractionFactor * r.      "Repulsion increases when charge Q (number of direct connections) increases.   "   repulsionFactor := 1.0.   qA := self countNeighborsOfNode: nodeA.   qB := self countNeighborsOfNode: nodeB.      repulsion := repulsionFactor * ( qA + qB ).   "TODO: Consider using minimum of qA or qB.    TODO: Consider dividing by r.   "      ^ ( attraction - repulsion ).    "Notes:    1. Return value is a scalar quantity. Not a vector.   2. Since the connected entities require space on the diagram,        it may work better if we sqared the connection 'charge' quantities.   3. Perhaps we should divide by 'radius' in the repulsion calculation.   4. This calculation assumes the that nodeA and nodeB are directly connected.   5. What if return was ( attraction / repulsion )?   "   "TODO: Refactor so that attraction and repulsion factors are instance variables and externally adjustable."   "TODO: Set up a UI where user can tinker with the factors. (And we can verify the intended layout effects.)"   </pre><h3>Hum-UI -- HumDiagram &gt;&gt; layoutNode:from:by:</h3><pre>layoutNode: aNode from: aPosition by: anIncrement   "Find a place for the given node starting from the given position.    Increment the position until an empty position is found.    Return the position where we placed the node.   Typically, aPosition is down-right from an existing node, and the increment is down - giving a tree-like structure.   "               | proposedPosition nodePosition |      proposedPosition := aPosition.   nodePosition := self getPositionForNode: aNode.   "If the node has already been positioned, leave it where it is."   [ nodePosition  isNil]      whileTrue: [ "Is the proposed position empty?"         ((self mapPositionNode) at: proposedPosition ifAbsent: [nil])            ifNil: [ "Yes. It is empty"               nodePosition := proposedPosition.               self setNode: aNode position: nodePosition.               ]            ifNotNil: ["Compute next proposed position"                   proposedPosition := proposedPosition + anIncrement.               ].         ].            "At this point, proposedPosition should be the related node`s position"   self assert: ( nodePosition = (self getPositionForNode: aNode) ).         "Return the position where we placed the node."      ^ nodePosition.</pre><h3>Hum-UI -- HumDiagram &gt;&gt; layoutRecursiveWithNode:relativePosition:seenBefore:</h3><pre>layoutRecursiveWithNode: node relativePosition: relativePosition seenBefore: priorNodes   "Assign initial position to this node, and then, using recursion, to its neighbors.   - relativePosition is suggested first position to try.    If that position is already filled, try other positions below it until one is found.   - priorNodes contains nodes that have been seen before in this recursion.   If this node is also in priorNodes,     it has already been handled and we return immediately to avoid a loop.   In some implementations,     we might want to limit the depth (based on priorNodes size).   "   | xIncrement  xy downStreamNodes upStreamNodes yIncrement |   "Return immediately if this node has been seen before.   Otherwise add it to the nodes we have seen before and proceed."   ( priorNodes includes: node ) ifTrue: [ ^self ] ifFalse: [ priorNodes add: node ].      "Following must be set before calling me."   self assert: ( nodeExtent notNil ).   self assert: ( nodeSpacing notNil ).   "Following is assumed in code below."   self assert: ( nodeExtent  isKindOf: Point).   self assert: ( nodeSpacing isKindOf: Point).      "Compute increments between grid locations."   "In this version, the placement is on a rectalinear grid.   But other/future versions may be radial and/or decrease as the number of priorNodes increases.   "   xIncrement := (nodeSpacing x) + (( nodeExtent x )/2).   yIncrement := (nodeSpacing y) + (( nodeExtent y )/2).      xy := self layoutNode: node from: relativePosition by: (0@yIncrement).      "Next: Find positions for nodes that are downstream from this node."   downStreamNodes := self getNodesDownstreamFromNode: node.   downStreamNodes            do: [ :downStreamNode | "Place downstream nodes to right and below of priority node."               self layoutRecursiveWithNode: downStreamNode                             relativePosition: (xy + (xIncrement@0))                                  seenBefore: priorNodes.               "ToDo: Calculate which node positions are intersected by connecting lines.                      Assign the central node or a dummy node to those positions also.                      The parent node might be expanded to fill or the dummy node never drawn.               "               ].            "Next: Find positions for nodes that are upstream from this node."   upStreamNodes := self getNodesUpstreamFromNode: node.   upStreamNodes            do: [ :upStreamNode | "Place upstream nodes to left and below priority node."               self layoutRecursiveWithNode: upStreamNode                             relativePosition: (xy - (xIncrement@0))                                 seenBefore: priorNodes.               "ToDo: Calculate which node positions are intersected by connecting lines."               ].   </pre><h3>Hum-UI -- HumDiagram &gt;&gt; mapNodePosition</h3><pre>mapNodePosition   ^ mapNodePosition ifNil: [ mapNodePosition := Dictionary new. ].</pre><h3>Hum-UI -- HumDiagram &gt;&gt; mapPositionNode</h3><pre>mapPositionNode   " What node is at a position"   ^ mapPositionNode ifNil: [ mapPositionNode := Dictionary new. ].</pre><h3>Hum-UI -- HumDiagram &gt;&gt; nodeExtent:</h3><pre>nodeExtent: aPoint    nodeExtent := aPoint</pre><h3>Hum-UI -- HumDiagram &gt;&gt; nodeSpacing:</h3><pre>nodeSpacing: aPoint    nodeSpacing := aPoint</pre><h3>Hum-UI -- HumDiagram &gt;&gt; nodes</h3><pre>nodes   "Model nodes as a set of objects."   ^ self graph nodes.</pre><h3>Hum-UI -- HumDiagram &gt;&gt; setNode:position:</h3><pre>setNode: aNodeObject position: aPosition   "Node should also be in nodes collection for internal consistency."   self addNode: aNodeObject.   self mapNodePosition at: aNodeObject  put: aPosition.   self mapPositionNode at: aPosition put: aNodeObject.</pre><h3>Hum-UI -- HumDiagram &gt;&gt; title</h3><pre>title   ^ title ifNil: [ title := '** Diagram has no title! **'].</pre><h3>Hum-UI -- HumDiagram &gt;&gt; title:</h3><pre>title: aString   title := aString.   </pre><h3>Hum-UI -- HumEditor &gt;&gt; addLine:</h3><pre>addLine: aString    "Delegate to HumText instance."   (self text) addLine: aString</pre><h3>Hum-UI -- HumEditor &gt;&gt; beep</h3><pre>beep   "If sound is enabled, beep."            Beeper beep.</pre><h3>Hum-UI -- HumEditor &gt;&gt; characterIndex</h3><pre>characterIndex   "Character index is equal to the number of charactes to the left of the cursor."   ^ characterIndex ifNil: [ characterIndex := 0 ].</pre><h3>Hum-UI -- HumEditor &gt;&gt; characterIndex:</h3><pre>characterIndex: aSmallInteger    "character index ranges from 0 (left of line) to ()"   | n |   characterIndex := aSmallInteger.      (characterIndex &lt; 0 )       ifTrue: [ characterIndex := 0.         self beep.         ].      n := ( text lines at: lineIndex   ) size.      (characterIndex &gt; n )       ifTrue: [ characterIndex := n.         self beep.         ]. </pre><h3>Hum-UI -- HumEditor &gt;&gt; currentLine</h3><pre>currentLine   | result |   result := ( self lines ) at: ( self lineIndex ).   ^result.</pre><h3>Hum-UI -- HumEditor &gt;&gt; deletePriorCharacter</h3><pre>deletePriorCharacter   "Insert a character into the text at the current (cursor) position"   | humTextLine currentLine stringUpto stringAfter newLine currentIndex  |   "If cursor is at the front of the line, delete is a no op."   currentIndex := (self characterIndex).   ( currentIndex = 0 ) ifTrue: [ Beeper beep. ^self ].   "Otherwise . . ."   humTextLine := (self lines) at: (self lineIndex).   currentLine := humTextLine string.   ( currentIndex &gt;= currentLine size )            ifTrue: [    "Delete the last character in the line."                  stringUpto := currentLine copyFrom: 1 to: (currentLine size - 1).                stringAfter := ''.                ]            ifFalse: [    "Delete the character left of the cursor."                   stringUpto := currentLine copyFrom: 1 to: (currentIndex - 1).                  stringAfter := currentLine copyFrom: (currentIndex+1) to: (currentLine size).               ].      newLine := stringUpto,  stringAfter.   humTextLine string: newLine.   text changed.   "(self lines) at: (self lineIndex) put: humTextLine."   "Back the cursor."   self characterIndex: currentIndex - 1.   </pre><h3>Hum-UI -- HumEditor &gt;&gt; emptySelection</h3><pre>emptySelection   "The selection is empty.   start and end are at current cursor"   selectionAnchor := lineIndex @ characterIndex.   selectionStart := selectionAnchor.   selectionEnd   := selectionAnchor.</pre><h3>Hum-UI -- HumEditor &gt;&gt; initialize</h3><pre>initialize   "Set up undo stack and notification."   self undoStack.</pre><h3>Hum-UI -- HumEditor &gt;&gt; insertCharacter:</h3><pre>insertCharacter: aCharacter    "Insert a character into the text at the current (cursor) position"   | humTextLine currentLine currentIndex stringUpto stringAfter newLine |   humTextLine := (self lines) at: (self lineIndex).   currentLine := humTextLine string.   currentIndex := self characterIndex.   ( currentIndex &gt;= currentLine size )      ifFalse: [   stringUpto := currentLine copyFrom: 1 to: currentIndex.               stringAfter := currentLine copyFrom: ( currentIndex +1 ) to: (currentLine size).               ]      ifTrue: [    stringUpto := currentLine copy.                   stringAfter := ''.                ].      newLine := stringUpto, (aCharacter asString), stringAfter.   humTextLine string: newLine.   "notify model"   text changed.   "(self lines) at: (self lineIndex) put: humTextLine."   "Advance the cursor."   self characterIndex: (self characterIndex + 1).   </pre><h3>Hum-UI -- HumEditor &gt;&gt; insertLine</h3><pre>insertLine   "Delegate to our HumText instance"   self text insertEmptyLineAfter: (self lineIndex).   "Adjust the cursor to point to the beginning of the new line."   lineIndex := lineIndex + 1.   characterIndex := 0.         </pre><h3>Hum-UI -- HumEditor &gt;&gt; interpretKey:</h3><pre>interpretKey: aSymbol    "Interpret various keyboard gestures."   | action |   keyboardActions ifNil: ["initialize"      keyboardActions := Dictionary  new.      keyboardActions         "Simple arrow keys"         at: #arrowUp      put: [ self lineIndex: ( (self lineIndex) - 1 ).  self emptySelection. ];         at: #arrowDown put: [ self lineIndex: ( (self lineIndex) + 1 ).  self emptySelection. ];         at: #arrowLeft   put: [ self characterIndex: ( (self characterIndex ) - 1).  self emptySelection. ];         at: #arrowRight put: [ self characterIndex: ( (self characterIndex ) + 1).  self emptySelection. ];                  "Alt-Arrow keys"         at: #altArrowUp      put: [ self lineIndex: 1. self emptySelection.];         at: #altArrowDown put: [ self lineIndex: ( self lines size ).                                               self characterIndex:  (self currentLine string size). self emptySelection. ];         at: #altArrowLeft   put: [ self characterIndex: 0. self emptySelection. ];         at: #altArrowRight  put: [ self characterIndex: (self currentLine string size). self emptySelection. ];                  "Shift-Arrow keys move cursor same as simple arrow keys, but selection is updated."         at: #shiftArrowUp      put: [ self lineIndex: ( (self lineIndex) - 1). self updateSelection. ];         at: #shiftArrowDown put: [ self lineIndex: ( (self lineIndex) + 1 ). self updateSelection. ];         at: #shiftArrowLeft    put: [ self characterIndex: ( (self characterIndex ) - 1). self updateSelection. ];         at: #shiftArrowRight  put: [ self characterIndex: ( (self characterIndex ) + 1). self updateSelection. ];                  "Escape key is a no-op at this time."         at: #escape put: [ Beeper beep ].       ].   "Interpret the symbol (keyboard action name) given"   action := keyboardActions at: aSymbol                   ifAbsent: [ Error signal: 'No action for: ', (aSymbol asString)].   action value.   </pre><h3>Hum-UI -- HumEditor &gt;&gt; lineIndex</h3><pre>lineIndex   ^ lineIndex ifNil: [ lineIndex := 1 ].</pre><h3>Hum-UI -- HumEditor &gt;&gt; lineIndex:</h3><pre>lineIndex: aSmallInteger    | maxLine |   lineIndex := aSmallInteger.   maxLine := ((self text ) lines size).   ( lineIndex &gt;  maxLine ) ifTrue: [ lineIndex := maxLine].   ( lineIndex &lt; 1 ) ifTrue: [ lineIndex := 1 ].</pre><h3>Hum-UI -- HumEditor &gt;&gt; lines</h3><pre>lines   ^ self text lines.</pre><h3>Hum-UI -- HumEditor &gt;&gt; redo</h3><pre>redo   "Replace text with text that was replaced at last undo."   | stack replacedText |   stack := self redoStack.   stack ifEmpty: [ self beep. ^self ].   replacedText := stack removeLast.   text := replacedText.</pre><h3>Hum-UI -- HumEditor &gt;&gt; redoStack</h3><pre>redoStack   ^ redoStack ifNil: [ redoStack := OrderedCollection new ].</pre><h3>Hum-UI -- HumEditor &gt;&gt; selectedText</h3><pre>selectedText   "Return selected text as a string with CR inserted as needed at ends of lines."   | result calc startRow startColumn endRow endColumn line|   calc := HumCalculator new.   result := String new.   startRow  := selectionStart x.   endRow    := selectionEnd x.      (startRow to: endRow)     do: [ :row |       line := (text lines at: row ) string.      calc cases;         when: [row = startRow and: [row &lt; endRow]]             then: [startColumn := selectionStart y. endColumn := line size. ];         when: [row = startRow and: [row = endRow]]             then: [startColumn := selectionStart y. endColumn := selectionEnd y. ];         when: [row = endRow and: [row &gt; startRow]]               then: [startColumn := 0. endColumn := selectionEnd y. ];         otherwise: [Error signal: 'eh?'].      (endColumn &gt; line size) ifTrue: [endColumn := line size].            (startColumn+1 to: endColumn)         do: [:column |            result := result, ((line at: column) asString).            ].       (endRow &gt; startRow and: [(row &lt; endRow) and: [endColumn = line size]]  )             ifTrue:   [result := result, String cr]      ].      ^result.</pre><h3>Hum-UI -- HumEditor &gt;&gt; selectionAnchor</h3><pre>selectionAnchor   "Return selection anchor."   ^ selectionAnchor ifNil: [selectionAnchor := lineIndex @ characterIndex ].</pre><h3>Hum-UI -- HumEditor &gt;&gt; text</h3><pre>text   ^ text ifNil: [ text := HumText new ].</pre><h3>Hum-UI -- HumEditor &gt;&gt; undo</h3><pre>undo   "Replace text with last item from undo stack."   | stack priorText replacedText |   stack := self undoStack.   stack ifEmpty: [ Error signal: 'Undo stack should never be empty'. self beep. ^self].   (stack size = 1) ifTrue: [self beep. ^self].      "last contains current text"   self assert: ( stack last = text ).   replacedText := stack removeLast.    self redoStack add: replacedText.   stack ifEmpty: [Error signal: 'programming error?'].   "Now top contains priorText"   priorText := stack last.   text := priorText.   "TODO: Keep track of where the cursor was."</pre><h3>Hum-UI -- HumEditor &gt;&gt; undoStack</h3><pre>undoStack   undoStack       ifNil: [ "Setup notification. See #update:"               self text addDependent: self.                  "Initialize stack"               undoStack := OrderedCollection new.               undoStack add: text copy. ].   ^undoStack.   </pre><h3>Hum-UI -- HumEditor &gt;&gt; update:</h3><pre>update: aText   "When text is updated, we are informed. Put on undo stack."   self undoStack add: aText copy.   "TODO: Also track the cursor.    self undoStack add: { aText copy. lineIndex. characterIndex. }   "</pre><h3>Hum-UI -- HumEditor &gt;&gt; updateSelection</h3><pre>updateSelection   "Selection extends from an anchor-point to current cursor position.   Constraint: Start &lt; End.   "   | currentRowColumn anchorRow currentRow anchorColumn currentColumn calc |   currentRow := self lineIndex.   currentColumn := self characterIndex.   currentRowColumn := currentRow @ currentColumn.   anchorRow := selectionAnchor x.   anchorColumn := selectionAnchor y.      calc := HumCalculator new.   calc cases;      when: [currentRow &gt; anchorRow] then: [selectionStart := selectionAnchor. selectionEnd   := currentRowColumn];      when: [currentRow &lt; anchorRow] then: [selectionEnd   := selectionAnchor. selectionStart := currentRowColumn];      when: [currentColumn &gt; anchorColumn] then: [selectionStart := selectionAnchor. selectionEnd   := currentRowColumn];      when: [currentColumn &lt;= anchorColumn]then: [selectionEnd  := selectionAnchor. selectionStart := currentRowColumn];      otherwise: [Error signal: 'programming error'].               </pre><h3>Hum-UI -- HumElipsoid &gt;&gt; asPolygons</h3><pre>asPolygons   ^ self asPolygonsColoredBy: [ self solidColor ].</pre><h3>Hum-UI -- HumElipsoid &gt;&gt; asPolygonsColorCoded</h3><pre>asPolygonsColorCoded   ^ self asPolygonsColoredBy: [ self nextColor ].</pre><h3>Hum-UI -- HumElipsoid &gt;&gt; asPolygonsColoredBy:</h3><pre>asPolygonsColoredBy: aBlockRule   "Produce polygons from the xyList points and the rotation nWedges."   |  priorAngle pi makePoint fillColor borderColor  wedgeAngle centerX centerY centerZ xMax yMax zMax |   polygons := OrderedCollection new.   fillColor := self solidColor.   borderColor := self wireFrameColor.   priorAngle := 0.0.   pi := Float pi.   wedgeAngle := (2*pi)/16.   centerX := self centerX.   centerY := self centerY.   centerZ := self centerZ.   xMax := self width / 2.0.   yMax := self length / 2.0.   zMax := self height / 2.0.   "Wikipedia:   The surface of the ellipsoid may be parameterized in several ways. One possible choice which singles out the 'z'-axis is:   x = a * cos u * cos v   y = b * cos u * sin v   z = c * sin u   where u is in [ -pi/2, +pi/2 ] and v is in [ -pi, +pi ].   "   makePoint := [ :u :v  |           | x y z  |         x := xMax * (u cos ) * (v cos).         y := yMax * (u cos) * (v sin).         z := zMax * (u sin).         { x + centerX.  y + centerY.  z + centerZ. }         ].    ( ((pi/2.0) negated) to: (pi/2.0) by: wedgeAngle ) do: [ :u |          ( (pi negated) to: pi by: wedgeAngle ) do: [ :v |               | polygon  |               fillColor := aBlockRule value.  "Evaluate the caller`s coloring rule."               polygon := HumPolygon borderColor: borderColor fillColor: fillColor.               polygon parentSolid: (self).               polygon                   addVertex: ( makePoint value: u value: v );                  addVertex: ( makePoint value: u + wedgeAngle value: v );                  addVertex: ( makePoint value: u + wedgeAngle value: v + wedgeAngle );                  addVertex: ( makePoint value: u value: v + wedgeAngle ).               polygons add: polygon.             ]. "v"         ]. "u"   ^polygons.</pre><h3>Hum-UI -- HumElipsoid &gt;&gt; asVPython</h3><pre>asVPython   self shouldBeImplemented </pre><h3>Hum-UI -- HumExtrusion &gt;&gt; asPolygonsColoredBy:</h3><pre>asPolygonsColoredBy: aColorRule   "Translate the moldLoop`s points     so that the origin is translated to each point in the extrusionPath."   "Create quadrangles (HumPolygons) by connecting the dots."   | priorMoldLoop |   polygons ifNil: [ polygons := OrderedCollection new ] ifNotNil: [ ^polygons ].   "Preconditions"   self assert: (self extrusionPath size &gt; 1).   self assert: (self moldLoop size &gt;= 4).   polygons := OrderedCollection new.   "Make polygons covering exterior of the extrusion."   priorMoldLoop := (self moldLoop) translatedBy: (extrusionPath at: 1).   (2 to: extrusionPath size)      do: [ :x |         | thisMoldLoop |         thisMoldLoop := (self moldLoop) translatedBy: (extrusionPath at: x).         (2 to: moldLoop size)            do: [ :m |                | polygon |               polygon := HumPolygon parentSolid: self fillColor: aColorRule value.               polygon               "start"                  addVertex: (thisMoldLoop at: m);               "up"                  addVertex: (thisMoldLoop at: m-1);               "back"                   addVertex: (priorMoldLoop at: m-1);               "down"                  addVertex: (priorMoldLoop at: m);               "forward to end"                  addVertex: (thisMoldLoop at: m). "Close the loop."               self polygons add: polygon.               ].         priorMoldLoop := thisMoldLoop.          ].   self assert: (polygons size &gt;= 3).   "Note: If end-caps need to be covered, the caller must do it."   ^polygons.</pre><h3>Hum-UI -- HumExtrusion &gt;&gt; asVPython</h3><pre>asVPython   self shouldBeImplemented </pre><h3>Hum-UI -- HumExtrusion &gt;&gt; centerX</h3><pre>centerX   "centerX = average value of x from polygon vertices"   |  sum n |   centerX ifNotNil: [ ^centerX ].   sum := 0.0 meter.   n := 0.   (self polygons)      do: [ :polygon | "HumPolygon"         polygon verticesDo: [ :x :y :z | n := n + 1. sum := sum + x. ].          ].   centerX := sum / n.   ^centerX.   </pre><h3>Hum-UI -- HumExtrusion &gt;&gt; centerY</h3><pre>centerY   "centerY = average value of Y values from polygon vertices"   |  sum n |   centerY ifNotNil: [ ^centerY ].   sum := 0.0 meter.   n := 0.   (self polygons)      do: [ :polygon | "HumPolygon"         polygon verticesDo: [ :x :y :z | n := n + 1. sum := sum + y. ].          ].   centerY := sum / n.   ^centerY.   </pre><h3>Hum-UI -- HumExtrusion &gt;&gt; centerZ</h3><pre>centerZ   "centerZ = average value of Z values from polygon vertices"   |  sum n |   centerZ ifNotNil: [ ^centerZ ].   sum := 0.0 meter.   n := 0.   (self polygons)      do: [ :polygon | "HumPolygon"         polygon verticesDo: [ :x :y :z | n := n + 1. sum := sum + z. ].          ].   centerZ := sum / n.   ^centerZ.   </pre><h3>Hum-UI -- HumExtrusion &gt;&gt; changed</h3><pre>changed   "Force recalculation of geometry when next asked."   polygons := nil.   centerX := nil.   centerY := nil.   centerZ := nil.   </pre><h3>Hum-UI -- HumExtrusion &gt;&gt; extrusionPath</h3><pre>extrusionPath   "The moldLoop origin is translated along this path to outline the extrusion."   self assert: ( extrusionPath isKindOf: H3dPath ).   ^extrusionPath. </pre><h3>Hum-UI -- HumExtrusion &gt;&gt; extrusionPath:</h3><pre>extrusionPath: a3Dpath   "The moldLoop origin is translated along this path to outline the extrusion."   extrusionPath := a3Dpath.   self assert: ( extrusionPath isKindOf: H3dPath ).</pre><h3>Hum-UI -- HumExtrusion &gt;&gt; moldLoop</h3><pre>moldLoop   "This loop defines the edges of the extrusion. See also: #extrusionPath:"   "The 3D path is closed by connecting the last point to the first."   self assert: ( moldLoop isKindOf: H3dPath ).   ^moldLoop.</pre><h3>Hum-UI -- HumExtrusion &gt;&gt; moldLoop:</h3><pre>moldLoop: a3Dpath   "This loop defines the edges of the extrusion. See also: #extrusionPath:"   "The 3D path must be closed by connecting the last point to the first."   moldLoop := a3Dpath.   self assert: ( moldLoop isKindOf: H3dPath ).   self assert: (a3Dpath first) = (a3Dpath last).</pre><h3>Hum-UI -- HumExtrusion &gt;&gt; volume</h3><pre>volume   Error signal: 'I do not know how to compute the volume of an extrusion in the general case.'.</pre><h3>Hum-UI -- HumFormWidget &gt;&gt; renderContentOn:</h3><pre>renderContentOn: aWAHtmlCanvas   | tag |   tag := aWAHtmlCanvas tag: 'view'.   tag   attributeAt: 'id' put: (self view id).   tag with: [ "A view becomes an HTML form."      aWAHtmlCanvas form          attributeAt: 'id' put: (self view id);          with: [ self view renderMarkupLinesViaSeasideOn: aWAHtmlCanvas ].      ].   </pre><h3>Hum-UI -- HumFormWidget &gt;&gt; renderOn:</h3><pre>renderOn: aWAHtmlCanvas   | tag |   tag := aWAHtmlCanvas tag: 'view'.   tag   attributeAt: 'id' put: (self view id).   tag with: [ "A view becomes an HTML form."      aWAHtmlCanvas form          attributeAt: 'id' put: (self view id);          with: [ self view renderMarkupLinesViaSeasideOn: aWAHtmlCanvas ].      ].   </pre><h3>Hum-UI -- HumFormWidget &gt;&gt; view</h3><pre>view  "Return my view"   ^ view ifNil: [Error signal: (self class,' not properly initialized')]</pre><h3>Hum-UI -- HumFormWidget &gt;&gt; view:</h3><pre>view: aHumView    view := aHumView.</pre><h3>Hum-UI -- HumLayoutWidget &gt;&gt; addWidget:</h3><pre>addWidget: aHumWidget    (self widgets) add: aHumWidget.</pre><h3>Hum-UI -- HumLayoutWidget &gt;&gt; reorder:</h3><pre>reorder: aSortBlock   "Re-order the widgets according to the given sort criteria."   self notYetImplemented.</pre><h3>Hum-UI -- HumLayoutWidget &gt;&gt; widgets</h3><pre>widgets   ^ widgets ifNil: [ widgets := OrderedCollection new. ]</pre><h3>Hum-UI -- HumMeasureWidget &gt;&gt; renderContentOn:</h3><pre>renderContentOn: aWAHtmlCanvas   "render self via a simple input tag"   | |   aWAHtmlCanvas numberInput      type: 'number';      attributeAt: 'id' put: (self attributeName );      callback: [:value | self store: value ];      with: (self attributeValue asString).</pre><h3>Hum-UI -- HumPane &gt;&gt; drawTextLines:onCanvas:font:</h3><pre>drawTextLines: textLines onCanvas: aCanvas font: aFont    |   lineHeight em depth clipRectangle extent maxLineLength |   self assert: (aCanvas isKindOf: HumCanvas).   self assert: (aFont isKindOf: AbstractFont).   lineHeight := aFont height.   em := aFont linearWidthOf: $m.   height := ( lineHeight * (textLines size + 2) ).   maxLineLength := (textLines values max: [ :line | line size ] ).   width := em* (maxLineLength + 2).   textLines keysAndValuesDo: [ :key :value |  width := width max: (em*(value size)) ].   depth := 32.   origin := 0@0.   extent := width@height.   clipRectangle := Rectangle origin: origin extent: extent.    canvas := HumCanvas  extent: extent depth: depth origin: origin clipRect: clipRectangle.   canvas drawTextLines: textLines withFont: aFont..</pre><h3>Hum-UI -- HumPane &gt;&gt; textChanged:</h3><pre>textChanged: aHumTextEditor    "Text to be displayed in this pane has changed."   | myCanvas  lines |   "Draw the text lines on my canvas."   myCanvas := self canvas.   lines := aHumTextEditor lines.   self drawTextLines: lines onCanvas: myCanvas font: (StandardFonts defaultFont).    </pre><h3>Hum-UI -- HumPolygon &gt;&gt; <=</h3><pre>&lt;= aHumPolygon    "Z-ordering: Is my north-most point more northerly than the other."   | myNorthMost otherNorthMost result |   myNorthMost := self northMostPoint.   otherNorthMost := aHumPolygon northMostPoint.   (myNorthMost = otherNorthMost)      ifFalse: [ result := ( myNorthMost &gt;= otherNorthMost ). ]      ifTrue: [ | myCentroid otherCentroid |         myCentroid := self centroid.         otherCentroid := aHumPolygon centroid.         result := ( myCentroid at: 2) &gt;= (otherCentroid at: 2).          ].      ^result.</pre><h3>Hum-UI -- HumPolygon &gt;&gt; ></h3><pre>&gt; aHumPolygon    "Is my north-most point more northerly than the other."   | result |   result := ( self &lt;= aHumPolygon ) not.      ^result.</pre><h3>Hum-UI -- HumPolygon &gt;&gt; addVertex:</h3><pre>addVertex: aScenePoint    "The convention is to list vertices in a counter-clockwise direction as seen from the 'outside' of a solid."   | calc |   "Comment: Wishing to be programmer-friendly or more generic, we allow more than one kind of point.        Of course: There will be consequences."   calc := HumCalculator new.   calc cases;      when: [ ( self vertices size &gt; 0 )  and: [aScenePoint = vertices last] ]         then: [ "Do not add redundant scene point." ];      when: [ ( aScenePoint isKindOf: Array ) and: [ aScenePoint size &gt;= 2 ] ]  "Allow for 3D to 2D mapping."         then:  [ self path addVertex: aScenePoint. ];      when: [ ( aScenePoint isKindOf: Collection ) and: [ aScenePoint size = 3 ] ] "Allow for collection instead of array."         then:  [ self halt. self vertices add: aScenePoint. ];      when: [ aScenePoint isKindOf: HumVector ]         then: [ self path addVertex: { aScenePoint x. aScenePoint y. aScenePoint z. } ];         when: [ aScenePoint isKindOf: Point ]         then: [ "okay" self path addVertex: aScenePoint ];  "Viewport XY pixel coordinates"      otherwise: [ Error signal: 'Scene point is not of expected type' ].   </pre><h3>Hum-UI -- HumPolygon &gt;&gt; asTriangles</h3><pre>asTriangles   | center triangles firstVertex priorVertex triangle |   self assert: (vertices size &gt; 2) description: 'A polygon should have at least 3 vertices.'.   triangles := OrderedCollection new.   center := self centroid.   firstVertex := vertices first.   priorVertex := firstVertex.   vertices       allButFirstDo:  [ :thisVertex |           "Make a polygon with same colors"         triangle := HumPolygon borderColor: (self fillColor) fillColor: (self fillColor).         triangle parentSolid: (self parentSolid).         triangle            addVertex: center;             addVertex: priorVertex;            addVertex: thisVertex.         triangles add: triangle.         priorVertex := thisVertex.      ].         triangle            addVertex: center;             addVertex: priorVertex;            addVertex: firstVertex.         triangles add: triangle.      ^triangles.   </pre><h3>Hum-UI -- HumPolygon &gt;&gt; borderColor</h3><pre>borderColor   ^ borderColor ifNil: [ borderColor := Color blue ].</pre><h3>Hum-UI -- HumPolygon &gt;&gt; borderColor:</h3><pre>borderColor: aColor    borderColor := aColor</pre><h3>Hum-UI -- HumPolygon &gt;&gt; bottom</h3><pre>bottom   "If points are 2D, Return min y or zero."   | minY  |   minY := self vertices max: [ :vertex | (vertex at: 2) negated ].   ^minY negated.</pre><h3>Hum-UI -- HumPolygon &gt;&gt; centroid</h3><pre>centroid   "Compute the centroid of the vertices."   | sumX sumY sumZ centroid n |   n := self vertices size.   self assert: (n &gt; 2).   sumX := sumY := sumZ := 0.0 meter.   self verticesDo: [ :x :y :z |      sumX := sumX + x.      sumY := sumY + y.      sumZ := sumZ + z.      ].   centroid := {  sumX / n. sumY / n. sumZ / n. }.   ^centroid.</pre><h3>Hum-UI -- HumPolygon &gt;&gt; color:</h3><pre>color: aColor    "Specify border-color or fll-color instead."   self shouldNotBeImplemented.</pre><h3>Hum-UI -- HumPolygon &gt;&gt; drawOn:</h3><pre>drawOn: aHumCanvas    aHumCanvas drawPolygon: self scale: ((5 px )/ (1 millimeter)).</pre><h3>Hum-UI -- HumPolygon &gt;&gt; fillColor</h3><pre>fillColor   ^ fillColor ifNil: [  fillColor := Color gray. ].</pre><h3>Hum-UI -- HumPolygon &gt;&gt; fillColor:</h3><pre>fillColor: aColor    fillColor := aColor</pre><h3>Hum-UI -- HumPolygon &gt;&gt; inFrontOfCamera</h3><pre>inFrontOfCamera   "Return true if at least one y-value is positive."   |  |   "This only works properly if vertices have been transformed into camera coordinates."   self verticesDo: [ :x :y :z | ( y quantity &gt; 0.0 ) ifTrue: [ ^true ] ].   ^false.</pre><h3>Hum-UI -- HumPolygon &gt;&gt; left</h3><pre>left   | minY |   "Trick because we collection has max: method but no min: method."   minY := self vertices max: [ :vertex | (vertex at: 2) negated ].    ^minY negated.</pre><h3>Hum-UI -- HumPolygon &gt;&gt; maxRsquared</h3><pre>maxRsquared   "Compute the centroid of the vertices."   |  maxSquared n |   n := self vertices size.   self assert: (n &gt; 0).   maxSquared := 0.   self verticesDo: [ :xMeasure :yMeasure :zMeasure |      | thisSquared x y z |      x := xMeasure quantity.      y := yMeasure quantity.      z := zMeasure quantity.      thisSquared := (x*x) + (y*y) + (z*z).      (thisSquared &gt; maxSquared) ifTrue: [ maxSquared := thisSquared ].      ].      ^maxSquared.</pre><h3>Hum-UI -- HumPolygon &gt;&gt; meanRsquared</h3><pre>meanRsquared   "Compute the centroid of the vertices."   |  meanRsquared n |   n := self vertices size.   self assert: (n &gt; 0).   meanRsquared := 0.   self verticesDo: [ :xMeasure :yMeasure :zMeasure |      | thisSquared x y z |      x := xMeasure quantity.      y := yMeasure quantity.      z := zMeasure quantity.      thisSquared := (x*x) + (y*y) + (z*z).      meanRsquared := meanRsquared + thisSquared.      ].      ^(meanRsquared / n).</pre><h3>Hum-UI -- HumPolygon &gt;&gt; minRsquared</h3><pre>minRsquared   "Compute the centroid of the vertices."   |  minSquared n |   n := self vertices size.   self assert: (n &gt; 0).   minSquared := 0.   self verticesDo: [ :xMeasure :yMeasure :zMeasure |      | thisSquared x y z |      x := xMeasure quantity.      y := yMeasure quantity.      z := zMeasure quantity.      thisSquared := (x*x) + (y*y) + (z*z).      (thisSquared &lt; minSquared) ifTrue: [ minSquared := thisSquared ].      ].      ^minSquared.</pre><h3>Hum-UI -- HumPolygon &gt;&gt; northMostPoint</h3><pre>northMostPoint   "Find the value of the point that is furtherest North (z-Ordering)"   | northMost |   "Hum coordinate axis point {East. North. Up.}"   northMost := ( (self vertices) first ) at: 2.   self verticesDo: [ :x :y :z | northMost := northMost max: y ].   ^northMost.   </pre><h3>Hum-UI -- HumPolygon &gt;&gt; parentSolid</h3><pre>parentSolid   "Remember where I came from."   ^ parentSolid ifNil: [ Error signal: 'parentSolid not defined' ].</pre><h3>Hum-UI -- HumPolygon &gt;&gt; parentSolid:</h3><pre>parentSolid: aHumSolid    "Remember where I came from."   parentSolid := aHumSolid. </pre><h3>Hum-UI -- HumPolygon &gt;&gt; path</h3><pre>path   ^self vertices.</pre><h3>Hum-UI -- HumPolygon &gt;&gt; pitch:</h3><pre>pitch: pitchAngle    "Return a new polygon with my points adjusted by pitch about origin."   | newPolygon |   newPolygon := HumPolygon new.   self vertices do: [ :vertex |  newPolygon addVertex: (vertex pitch: pitchAngle). ].   ^newPolygon</pre><h3>Hum-UI -- HumPolygon &gt;&gt; rSquared</h3><pre>rSquared   | xyz cx cy cz rSquared |   xyz  := self centroid.   cx := xyz at: 1.   cy := xyz at: 2.   cz := xyz at: 3.   rSquared := (cx*cx) + (cy*cy) + (cz*cz).   ^rSquared.   </pre><h3>Hum-UI -- HumPolygon &gt;&gt; right</h3><pre>right   | maxY |   maxY := self vertices max: [ :vertex | (vertex at: 2) ].   ^maxY</pre><h3>Hum-UI -- HumPolygon &gt;&gt; roll:</h3><pre>roll: rollAngle    "Return a new polygon with my points adjusted by roll about origin."   | newPolygon |   newPolygon := HumPolygon new.   self vertices do: [ :vertex |  newPolygon addVertex: (vertex roll: rollAngle). ].   ^newPolygon</pre><h3>Hum-UI -- HumPolygon &gt;&gt; top</h3><pre>top   "If points are 2D, Return max y."   | maxY |   maxY := 0 meter.   self verticesDo: [ :x :y :z |  y &gt; maxY ifTrue: [maxY := y] ].   ^maxY.</pre><h3>Hum-UI -- HumPolygon &gt;&gt; vertices</h3><pre>vertices   "The convention is to list vertices in a counter-clockwise direction as seen from the 'outside' of a solid."   ^vertices ifNil: [ vertices := H3dPath new ].</pre><h3>Hum-UI -- HumPolygon &gt;&gt; verticesDo:</h3><pre>verticesDo: aBlockClosure    self vertices do: [ :vertex |      | x y z |      x := vertex at: 1. y := vertex at: 2.       (vertex size = 3) ifTrue: [ z := vertex at: 3 ] ifFalse: [ z := nil ].      aBlockClosure value: x value: y value: z.       ].</pre><h3>Hum-UI -- HumPolygon &gt;&gt; xyPoints</h3><pre>xyPoints   "Flatten my 3D points to 2D points in X-Y (floor plan) plane"   | xyVertices |   xyVertices := OrderedCollection new.   self verticesDo: [ :x :y :z |       self assert: ( (x isKindOf: HumMeasure) and: [x units = #px]).      xyVertices add: (x quantity) @ (y quantity).       ].   ^xyVertices.   </pre><h3>Hum-UI -- HumPolygon &gt;&gt; xzPoints</h3><pre>xzPoints   "Flatten my 3D points to 2D points in X-Z (viewport/billboard) plane. "   | xzVertices  |   xzVertices := OrderedCollection new.   self verticesDo: [ :x :y :z | xzVertices add: (x@z) ].   ^xzVertices.   </pre><h3>Hum-UI -- HumPolygon &gt;&gt; yaw:</h3><pre>yaw: yawAngle    "Return a new polygon with my points adjusted by yaw about origin."   | newPolygon |   newPolygon := H3dPath new.   self vertices do: [ :vertex |  newPolygon addVertex: (vertex yaw: yawAngle). ].   "See HumVector"   ^newPolygon</pre><h3>Hum-UI -- HumPolygon &gt;&gt; yaw:aboutPivot:</h3><pre>yaw: yawAngle aboutPivot: pivot   "Return a new polygon with my points adjusted by yaw about origin."   | newPolygon |   newPolygon := H3dPath new.   self vertices do: [ :vertex |  newPolygon addVertex: (vertex yaw: yawAngle aboutPivot: pivot). ].   "See HumVector"   ^newPolygon</pre><h3>Hum-UI -- HumRotation &gt;&gt; asPolygonsColoredBy:</h3><pre>asPolygonsColoredBy: aColorRule   "Produce polygons from the xyList points and the rotation nWedges."   |  priorAngle pi makePoint fillColor borderColor tPolygons wedgeAngle centerX centerY centerZ |   tPolygons := OrderedCollection new.   fillColor := self solidColor.   borderColor := self wireFrameColor.   priorAngle := 0.0.   pi := Float pi.   wedgeAngle := (2*pi)/nWedges.   centerX := self centerX.   centerY := self centerY.   centerZ := self centerZ.   makePoint := [ :angle :xy |           | x y z radius |         radius := xy at: 1.         x := radius * (angle sin).         y := radius * (angle cos).         z := xy at: 2.         { x + centerX.  y + centerY.  z + centerZ. }         ].    ( wedgeAngle to: (2*pi) by: wedgeAngle )      do: [ :currentAngle |         | priorXY |         priorXY := xyList at: 1.         xyList             allButFirstDo:  [ :xy |               | polygon  |               fillColor := (aColorRule value).  "Select from a sequence of colors."               polygon := HumPolygon borderColor: borderColor fillColor: fillColor.               polygon parentSolid: self.               polygon                   addVertex: (makePoint value: currentAngle value: xy);                  addVertex: (makePoint value: currentAngle value: priorXY);                  addVertex: (makePoint value: priorAngle value: priorXY);                  addVertex: (makePoint value: priorAngle value: xy).               priorXY := xy.               tPolygons add: polygon.               ]. "xy"         priorAngle := currentAngle.           ]. "currentAngle"   ^tPolygons.</pre><h3>Hum-UI -- HumRotation &gt;&gt; asVPython</h3><pre>asVPython   self shouldBeImplemented </pre><h3>Hum-UI -- HumRotation &gt;&gt; nWedges:</h3><pre>nWedges: numberOfWedges   nWedges := numberOfWedges.</pre><h3>Hum-UI -- HumRotation &gt;&gt; xyList:</h3><pre>xyList: aCollection    "List of XY (XZ) points that define surface of revolution."   xyList := aCollection                collect: [ :point |                    | x y xMeasure yMeasure |                  x := point x.                  y := point y.                  xMeasure := self asMeasure: x.                  yMeasure := self asMeasure: y.                  { xMeasure. yMeasure. }.                  ].                  </pre><h3>Hum-UI -- HumRowLayoutWidget &gt;&gt; asHTML</h3><pre>asHTML   "Generate a div containing child widget renderings."   |  html calc rowGenerator |   calc := HumCalculator new.      rowGenerator := [ | innerHTML |      innerHTML := String new.      ( self widgets ) do: [ :widget |          | cellHTML |         cellHTML := calc xml: 'td' with: [ widget asHTML ].         innerHTML := innerHTML, cellHTML.          ].         innerHTML. "returned value"      ].   html := calc xml: 'div'                   with: [ calc xml: 'table'                               with: [ calc xml: 'tr'                                           with: [ rowGenerator value  ]                                     ]                          ].   ^html.   </pre><h3>Hum-UI -- HumRowLayoutWidget &gt;&gt; asMorph</h3><pre>asMorph   | morph childMorphs |   morph := AlignmentMorph new.   childMorphs := OrderedCollection new.   (self widgets) do: [ :widget | childMorphs add: (widget asMorph) ].   morph inARow: childMorphs.   morph cellPositioning: #topLeft.   ^morph.</pre><h3>Hum-UI -- HumScene &gt;&gt; asThreeJS</h3><pre>asThreeJS   "Render the scene as ThreeJS"   | js calc prologTemplate epilogTemplate dictionary |   calc := HumCalculator new.   dictionary := Dictionary new.   dictionary at: 'sceneID' put: (self asCamelCase).   "Prolog: Create the ThreeJS scene with appropriate attributes."   js := self setupScene4ThreeJS.   "Render the content (layers or objects)"   js := js, ( self asThreeJSGeometry ).   "Append the epilog."   epilogTemplate := 'setupScene();'.   js := js, ( calc fillTemplate: epilogTemplate fromDictionary: dictionary ).   ^js.</pre><h3>Hum-UI -- HumScene &gt;&gt; asThreeJSGeometry</h3><pre>asThreeJSGeometry   "Render the assembly as ThreeJS geometry"   | js |   "Render the content (layers or objects)"   js := ( super asThreeJS ).   ^js.</pre><h3>Hum-UI -- HumScene &gt;&gt; asThreeJSinHTML</h3><pre>asThreeJSinHTML   "Wrap ThreeJS rendering with HTML5."   | html calc js worldScript dictionary  template |   calc := HumCalculator new.      html := '&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;   &lt;head&gt;      &lt;title&gt;three.js webgl - orbit controls&lt;/title&gt;      &lt;meta charset="utf-8"&gt;      &lt;meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"&gt;      &lt;style&gt;         body {            color: #000;            font-family:Monospace;            font-size:13px;            text-align:center;            font-weight: bold;            background-color: #fff;            margin: 0px;            overflow: hidden;         }         #info {            color:#000;            position: absolute;            top: 0px; width: 100%;            padding: 5px;         }         a {            color: red;         }      &lt;/style&gt;   &lt;/head&gt;   &lt;body&gt;      &lt;div id="container"&gt;&lt;/div&gt;      &lt;!--      &lt;div id="info"&gt;         &lt;a href="http://threejs.org" target="_blank"&gt;three.js&lt;/a&gt; - orbit controls example      &lt;/div&gt;      --&gt;      &lt;script src="js/three.min.js"&gt;&lt;/script&gt;      &lt;script src="js/OrbitControls.js"&gt;&lt;/script&gt;      &lt;script src="js/Detector.js"&gt;&lt;/script&gt;            &lt;script src="js/Stats.js"&gt;&lt;/script&gt;      &lt;script&gt;         if ( ! Detector.webgl ) Detector.addGetWebGLMessage();         var container, stats;         var camera, controls, scene, renderer, myAssembly;         var cross;         init();         animate();         function init() {            camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );            camera.position.z = 500;            controls = new THREE.OrbitControls( camera );            controls.addEventListener( "change", render );            scene = new THREE.Scene();            //scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );            // world                        myAssembly = buildMyAssembly();  // Function is defined in separate script tag.            scene.add( myAssembly );                        // lights            light = new THREE.DirectionalLight( 0xffffff );            light.position.set( 1, 1, 1 );            scene.add( light );            light = new THREE.DirectionalLight( 0x002288 );            light.position.set( -1, -1, -1 );            scene.add( light );            light = new THREE.AmbientLight( 0x222222 );            scene.add( light );            // renderer            renderer = new THREE.WebGLRenderer( { antialias: false } );            // renderer.setClearColor( scene.fog.color, 1 );            renderer.setSize( window.innerWidth, window.innerHeight );            container = document.getElementById( "container" );            container.appendChild( renderer.domElement );                        // stats pane            stats = new Stats();            stats.domElement.style.position = "absolute";            stats.domElement.style.top = "0px";            stats.domElement.style.zIndex = 100;            container.appendChild( stats.domElement );            //            window.addEventListener( "resize", onWindowResize, false );         }         function onWindowResize() {            camera.aspect = window.innerWidth / window.innerHeight;            camera.updateProjectionMatrix();            renderer.setSize( window.innerWidth, window.innerHeight );            render();         }         function animate() {            requestAnimationFrame( animate );            controls.update();         }         function render() {            renderer.render( scene, camera );            stats.update();         }      '.      "Define a geometry named by (self asCamelCase)."      js := (self asThreeJSGeometry ).        "Generate additional function to build geometry and insert it into scene."      dictionary := Dictionary new.      dictionary at: 'assemblyID' put: (self asCamelCase ).      template := '         function buildMyAssembly() {         ', js,         '  return @assemblyID;         }'.      worldScript := calc fillTemplate: template fromDictionary: dictionary.      html := html, worldScript.            "Complete the HTML."      html := html, '      &lt;/script&gt;   &lt;/body&gt;&lt;/html&gt;'.   ^html.</pre><h3>Hum-UI -- HumScene &gt;&gt; asVPython</h3><pre>asVPython   "render scene and the objects in it via VPython."   | pythonCode |   pythonCode := self asVPythonPreamble.   pythonCode := pythonCode, ( super asVPython ).   ^ pythonCode.</pre><h3>Hum-UI -- HumScene &gt;&gt; asVPythonPreamble</h3><pre>asVPythonPreamble   | pythonCode |   pythonCode := 'from visual import *import Thingfrom Thing import BoxThingfrom Thing import PipeThing# Set window attributesscene.width=800scene.height=800scene.title="Scene Title"scene.background = ( 0.7, 0.7, 0.7 )# Set camera/viewport attributesscene.autoscale = Truescene.center = ( 4*12, 13*12, 4*12 )scene.up = ( 0, 0, 1 )'.   ^ pythonCode.</pre><h3>Hum-UI -- HumScene &gt;&gt; jump:</h3><pre>jump: aTime   "TODO: Is this consistent with HumSimulator?"   self parts do: [ :part | part jump: aTime ].</pre><h3>Hum-UI -- HumScene &gt;&gt; setupFloor4ThreeJS</h3><pre>setupFloor4ThreeJS   "Provide boilerplate that creates a visible floor."   | js |   "NOTE: JavaScript must call setupScene() before setupFloor()."   js := 'function setupFloor() {  // Floor  var geometry = new THREE.PlaneGeometry(2000, 2000, 20, 20);  var material = new THREE.MeshBasicMaterial({color: 0x9db3b5, overdraw: true});  var floor = new THREE.Mesh(geometry, material);  // floor.rotation.x = -90 * Math.PI / 180;  scene.add(floor);   }.'.   "TODO: Parameterize the size of the floor."   ^ js.</pre><h3>Hum-UI -- HumScene &gt;&gt; setupScene4ThreeJS</h3><pre>setupScene4ThreeJS   ""   | js |   js := 'var camera, scene, renderer;function setupScene() {  document.body.style.backgroundColor = "#d7f0f7";  setupThreeJS();  requestAnimationFrame(function animate() {    renderer.render(scene, camera);    requestAnimationFrame(animate);  });}function setupThreeJS() {  scene = new THREE.Scene();  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);  camera.position.y = 400;  camera.position.z = 400;  camera.rotation.x = -45 * Math.PI / 180;  renderer = new THREE.CanvasRenderer();  renderer.setSize(window.innerWidth, window.innerHeight);  document.body.appendChild(renderer.domElement);}'.   ^js, String cr.</pre><h3>Hum-UI -- HumSolid &gt;&gt; asPolygons</h3><pre>asPolygons   "Translate each face into a list of 3D points."   ^polygons ifNil: [ polygons := self asPolygonsColoredBy: [ self solidColor ] ].</pre><h3>Hum-UI -- HumSolid &gt;&gt; asPolygonsColorCoded</h3><pre>asPolygonsColorCoded   "Color code the facets of the solid."    ^self asPolygonsColoredBy: [ self nextColor ].    </pre><h3>Hum-UI -- HumSolid &gt;&gt; asPolygonsColoredBy:</h3><pre>asPolygonsColoredBy: aColorRule   "Generate polygons from the solid`s dimension. - Subtypes should over-ride."   "Color by evaluating the given color rule block."   "Hum coordinates are plan view. X points East. Y points North. Z points up."   |  polygon rotatedPolygons tiltedPolygons |   polygons notNil      ifTrue: [ ^polygons. ]      ifFalse: [ polygons := OrderedCollection new. ].   "North surface "   polygon := HumPolygon parentSolid: self fillColor: (aColorRule value). "Polygon"   polygon "Go clockwise as seen from outside the cube looking South"      addVertex: { westEdge.  northEdge. topEdge. };      addVertex: { eastEdge.  northEdge. topEdge. }; "&lt;"      addVertex: { eastEdge.  northEdge. bottomEdge. }; "v"      addVertex: { westEdge. northEdge. bottomEdge. }. "&gt;"   polygons add: polygon.      "East surface"   polygon := HumPolygon parentSolid: self fillColor: (aColorRule value).   polygon "Go clockwise as seen from outside the cube looking West"      addVertex: { eastEdge. northEdge. topEdge. };      addVertex: { eastEdge. southEdge. topEdge. }; "&lt;"      addVertex: { eastEdge. southEdge. bottomEdge. }; "V"      addVertex: { eastEdge. northEdge. bottomEdge. }. "&gt;"   polygons add: polygon copy.      "West surface"   polygon := HumPolygon parentSolid: self fillColor: (aColorRule value).   polygon "Go clockwise as seen from outside the cube looking East"      addVertex: { westEdge. southEdge. topEdge. };      addVertex: { westEdge. northEdge. topEdge. }; "&lt;"      addVertex: { westEdge. northEdge. bottomEdge. }; "V"      addVertex: { westEdge. southEdge. bottomEdge. }. "&gt;"   polygons add: polygon copy.      "Bottom surface"   polygon := HumPolygon parentSolid: self fillColor: (aColorRule value).   polygon "Go clockwise as seen from outside the cube looking Up and North at the bottom"      addVertex: { eastEdge. southEdge. bottomEdge. };      addVertex: { westEdge. southEdge. bottomEdge. }; "&lt;"      addVertex: { westEdge. northEdge. bottomEdge. }; "V"      addVertex: { eastEdge. northEdge. bottomEdge. }. "&gt;"   polygons add: polygon copy.      "Top surface"   polygon := HumPolygon parentSolid: self fillColor: (aColorRule value).   polygon "Go clockwise as seen from outside the cube looking down and North"      addVertex: { eastEdge. northEdge. topEdge. };        addVertex: { westEdge. northEdge. topEdge. }; "&lt;"      addVertex: { westEdge. southEdge. topEdge. }; "V"      addVertex: { eastEdge. southEdge. topEdge. }. "&gt;"   polygons add: polygon copy.      "South surface"   polygon := HumPolygon parentSolid: self fillColor: (aColorRule value).   polygon "Go clockwise as seen from outside the cube looking North"      addVertex: { eastEdge. southEdge. topEdge. };      addVertex: { westEdge. southEdge. topEdge. }; "&lt;"      addVertex: { westEdge. southEdge. bottomEdge. }; "V"      addVertex: { eastEdge.  southEdge. bottomEdge. }. "&gt;"   polygons add: polygon copy.      (self rotation = 0.0)       ifTrue: [ rotatedPolygons := polygons ]      ifFalse: [ rotatedPolygons := self rotatePolygons: polygons ].   (self tilt = 0.0)       ifTrue: [ tiltedPolygons := rotatedPolygons ]      ifFalse: [ tiltedPolygons := self tiltPolygons: rotatedPolygons ].   "TODO: What is meaning of polygons instance variable if we return something else here?"   "TODO: If a canvas is attached to a face (e.g. billboard), it needs to be rendered."   ^tiltedPolygons.    </pre><h3>Hum-UI -- HumSolid &gt;&gt; asThreeJS</h3><pre>asThreeJS   "Render this solid  as a cube via three.js"   | js template dictionary calc|   "Note: Caller must merge this into a scene or group geometry"   template := '         var @ID = new THREE.Mesh( ( new THREE.CubeGeometry( @width, @length, @height )  )                                     , ( new THREE.MeshBasicMaterial( { color: 0x@color } )  )                                     );         @ID.position.set( @x, @y, @z );   '.    "TODO:  *** Implement Subtypes ***"   dictionary := Dictionary new.   dictionary     at: 'ID'    put: ( self asCamelCase );     at: 'color' put: ( self color asHexString asLowercase ); "Color"        at: 'x' put: ( self mm: ( self centerX ) );     at: 'y' put: ( self mm: ( self centerY ) );     at: 'z' put: ( self mm: ( self centerZ ) );        at: 'width'  put: ( self mm: width  );     at: 'length' put: ( self mm: length );      at: 'height' put: ( self mm: height ).         calc := HumCalculator new.   js := calc fillTemplate: template fromDictionary: dictionary.   ^js.    </pre><h3>Hum-UI -- HumSolid &gt;&gt; asVPython</h3><pre>asVPython   | pythonCode |   pythonCode := self asVPythonThing.   ^pythonCode</pre><h3>Hum-UI -- HumSolid &gt;&gt; asVPythonPosition</h3><pre>asVPythonPosition   "Generate VPythgon code giving position."   |  comma eastString northString upString centerString |                 comma := ', '.            eastString := ( self westEdge + ( self width / 2 )) quantity printShowingDecimalPlaces: 3.  "Number"        northString := ( self southEdge + ( self length / 2 )) quantity printShowingDecimalPlaces: 3.        upString := ( self bottomEdge + ( self height / 2 )) quantity printShowingDecimalPlaces: 3.        centerString := '( ', eastString, comma, northString, comma, upString, ' )'.   ^centerString.</pre><h3>Hum-UI -- HumSolid &gt;&gt; asVPythonThing</h3><pre>asVPythonThing   "A solid has color and is visible."   | pythonCode |   pythonCode := id asCamelCase uncapitalized                                 ,' = BoxThing( label = "',id,'"'                                 ,', length = ', ( length quantity printShowingDecimalPlaces: 3 ) "millimeter precision"                                 ,', width = ',  ( width quantity printShowingDecimalPlaces: 3 )                                 ,', height = ', ( height quantity printShowingDecimalPlaces: 3 )                          ,', pos = ', ( self asVPythonPosition )                                 ,', aColor = color.', self color name       "eh?"                                 ,' )'.   ^pythonCode</pre><h3>Hum-UI -- HumSolid &gt;&gt; asX3D</h3><pre>asX3D   "Return a string in X3D notation representing this box / thing.   Caller is responsible for embedding this in a scene.   "   | template x3d calc dictionary |   "TODO: Replace this with a template implementation"   template := '   &lt;Transform translation="@translation"&gt;      &lt;Shape ID:="@ID"&gt;         &lt;Appearance&gt;            &lt;Material diffuseColor="@diffuseColor" /&gt;         &lt;/Appearance&gt;         &lt;@type size="@boxExtent" /&gt;      &lt;/Shape&gt;   &lt;/Transform&gt;
  '.  dictionary := (Dictionary new).  dictionary       at: 'translation' put: ( self x3dCenter );      at: 'ID' put: ( self id );      at: 'diffuseColor' put: ( self x3dColor );      at: 'type' put: ( typeOfSolid );      at: 'boxExtent' put: ( self x3dExtent ).   calc := HumCalculator new.   x3d := calc fillTemplate: template fromDictionary: dictionary.    ^x3d.</pre><h3>Hum-UI -- HumSolid &gt;&gt; attachCanvas:toFace:</h3><pre>attachCanvas: aCanvas toFace: aSymbol    "Attach the  canvas to the face. -- Used for billboards.    Maybe someday for texture, costume, decoration?"   ( self faces ) at: aSymbol put: aCanvas.</pre><h3>Hum-UI -- HumSolid &gt;&gt; color</h3><pre>color   ^solidColor ifNil: [ solidColor := Color gray. ].</pre><h3>Hum-UI -- HumSolid &gt;&gt; color:</h3><pre>color: aColor    "What id the default (background) color of the surface and interior of this solid 3D object?"   self assert: ( aColor isKindOf: Color ).   self solidColor: aColor.</pre><h3>Hum-UI -- HumSolid &gt;&gt; density</h3><pre>density   "Return set density otherwise lookup the density of my material."   ^ density ifNil: [ (self densityOfMaterial) ].</pre><h3>Hum-UI -- HumSolid &gt;&gt; density:</h3><pre>density: aMeasure   "What is the average density (mass per cube) of this solid?   *** Note: Use &gt;&gt;densityOfMaterial when possible. ***   *** Use this method to over-ride density given by material. ***   *** Example: You might use this method to provide average density of an aggregate. ***   "   self assert: ( aMeasure isKindOf: HumMeasure ).   "HumMeasure handles conversions to KMS units.   See also: methods in Number under HumMeasure category .   "   density := aMeasure.</pre><h3>Hum-UI -- HumSolid &gt;&gt; densityOfMaterial</h3><pre>densityOfMaterial   | result |   "The table is held on the class side to avoid clutter and instance bloat."   result := self class densityOfMaterial: material.   ^result.</pre><h3>Hum-UI -- HumSolid &gt;&gt; faces</h3><pre>faces   "Hold image/canvas to be attached to a face."   ^faces ifNil: [  faces := Dictionary new. ]</pre><h3>Hum-UI -- HumSolid &gt;&gt; initialize</h3><pre>initialize   super initialize.   self type: #box.</pre><h3>Hum-UI -- HumSolid &gt;&gt; mass</h3><pre>mass   ^ mass ifNil: [ mass := (self volume) * (self density)].</pre><h3>Hum-UI -- HumSolid &gt;&gt; mass:</h3><pre>mass: aMeasure   "What is the mass of this object?"   self assert: ( aMeasure isKindOf: HumMeasure ).   "HumMeasure handles conversions to KMS units.   See also: methods in Number under HumMeasure category .   "   mass := aMeasure.</pre><h3>Hum-UI -- HumSolid &gt;&gt; material</h3><pre>material   ^ material ifNil: [ Error signal: 'Material has not been set for this solid'].</pre><h3>Hum-UI -- HumSolid &gt;&gt; material:</h3><pre>material: aString    "See also: #densityOfMaterial for names of standard materials. "   self assert: ( aString isKindOf: String ).   material := aString.</pre><h3>Hum-UI -- HumSolid &gt;&gt; solidColor</h3><pre>solidColor   ^solidColor ifNil: [ solidColor := Color gray. ]</pre><h3>Hum-UI -- HumSolid &gt;&gt; type:</h3><pre>type: aSymbol    "TODO: Why was this coded?    I would expect subtyping of HumSolid to provide 'type' information."   self assert: ( aSymbol isKindOf: Symbol ).   self assert: ( #( #box #rotation #elipsoid #extrusion #space ) includes: aSymbol ).   typeOfSolid := aSymbol.</pre><h3>Hum-UI -- HumSolid &gt;&gt; weight</h3><pre>weight   "Get the Earth-bound weight of the object.  (in Newtons)."   ^ ( self mass ) * ( 1.0 gravity ).</pre><h3>Hum-UI -- HumSolid &gt;&gt; wireFrameColor</h3><pre>wireFrameColor   ^wireFrameColor ifNil: [ wireFrameColor := Color black ].</pre><h3>Hum-UI -- HumSolid &gt;&gt; x3dColor</h3><pre>x3dColor   "Translate my Smalltalk Color to x3dColor string"   | result sp c |   self assert: ( solidColor isKindOf: Color ).   c := solidColor.   sp := String space.   result := (c red   printShowingDecimalPlaces:2 ), sp,              (c green printShowingDecimalPlaces:2 ), sp,              (c blue  printShowingDecimalPlaces:2 ).   ^result.</pre><h3>Hum-UI -- HumSolid &gt;&gt; x3dExampleJSON</h3><pre>x3dExampleJSON   | json |      "Following is here to hold some useful patterns while I think over the design strategy."   json := '   {  "html": {    "-xmlns": "http://www.w3.org/1999/xhtml",    "head": {      "meta": [        {          "-http-equiv": "X-UA-Compatible",          "-content": "chrome=1"        },        {          "-http-equiv": "Content-Type",          "-content": "text/html;charset=utf-8"        }      ],      "title": "Primitives: Box, Cone, Cylinder and Sphere Primitives",      "link": {        "-rel": "stylesheet",        "-type": "text/css",        "-href": "x3dom.css"      }    },    "body": {      "h1": "Primitives: Box, Cone, Cylinder and Sphere Primitives",      "p": [        {          "-class": "case",          "X3D": {            "-xmlns": "http://www.web3d.org/specifications/x3d-namespace",            "-id": "boxes",            "-showStat": "true",            "-showLog": "false",            "-x": "0px",            "-y": "0px",            "-width": "400px",            "-height": "400px",            "Scene": {              "Background": { "-skyColor": "1 1 1" },              "Transform": [                {                  "-DEF": "coneTrafo",                  "-translation": "-4.5 0 0",                  "Shape": {                    "-DEF": "coneShape",                    "Appearance": {                      "-DEF": "coneApp",                      "Material": {                        "-diffuseColor": "0 1 0",                        "-specularColor": ".5 .5 .5"                      }                    },                    "Cone": { "-DEF": "cone" }                  }                },                {                  "-DEF": "boxTrafo",                  "-translation": "-1.5 0 0",                  "Shape": {                    "-DEF": "boxShape",                    "Appearance": {                      "-DEF": "boxApp",                      "Material": {                        "-diffuseColor": "1 0 0",                        "-specularColor": ".5 .5 .5"                      }                    },                    "Box": { "-DEF": "box" }                  }                },                {                  "-DEF": "sphereTrafo",                  "-translation": "1.5 0 0",                  "Shape": {                    "-DEF": "sphereShape",                    "Appearance": {                      "-DEF": "sphereApp",                      "Material": {                        "-diffuseColor": "0 0 1",                        "-specularColor": ".5 .5 .5"                      }                    },                    "Sphere": { "-DEF": "sphere" }                  }                },                {                  "-DEF": "cylinderTrafo",                  "-translation": "4.5 0 0",                  "Shape": {                    "-DEF": "cylinderShape",                    "Appearance": {                      "-DEF": "cylinderApp",                      "Material": {                        "-diffuseColor": "1 1 0",                        "-specularColor": ".5 .5 .5"                      }                    },                    "Cylinder": {                      "-DEF": "cylinder",                      "-radius": "1.0",                      "-height": "2.0"                    }                  }                }              ],              "Viewpoint": {                "-centerOfRotation": "0 0 0",                "-position": "0 0 15",                "-orientation": "0 1 0 0"              }            }          }        },        {          "-class": "case",          "#text": "  "        }      ],      "script": {        "-type": "text/javascript",        "-src": "x3dom.js"      }    }  }}   '.   ^ json.</pre><h3>Hum-UI -- HumSolid &gt;&gt; x3dExampleXML</h3><pre>x3dExampleXML   "Example to aid design    - This example shows how X3D is embedded in an HTML page."   | xml |   xml := '   &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;   &lt;head&gt;        &lt;meta http-equiv="X-UA-Compatible" content="chrome=1" /&gt;      &lt;meta http-equiv="Content-Type" content="text/html;charset=utf-8" /&gt;      &lt;title&gt;Primitives: Box, Cone, Cylinder and Sphere Primitives&lt;/title&gt;        &lt;link rel="stylesheet" type="text/css" href="x3dom.css" /   &lt;/head&gt;       &lt;body&gt;    &lt;h1&gt;Primitives: Box, Cone, Cylinder and Sphere Primitives&lt;/h1&gt;      &lt;p class="case"&gt;      &lt;X3D xmlns="http://www.web3d.org/specifications/x3d-namespace" id="boxes" showStat="true" showLog="false" x="0px" y="0px" width="400px" height="400px"&gt;         &lt;Scene&gt;            &lt;Background skyColor="1 1 1"" /&gt;                        &lt;Transform DEF="coneTrafo" translation="-4.5 0 0"&gt;               &lt;Shape DEF="coneShape"&gt;                  &lt;Appearance DEF="coneApp"&gt;                     &lt;Material diffuseColor="0 1 0" specularColor=".5 .5 .5" /&gt;                  &lt;/Appearance&gt;                  &lt;Cone DEF="cone" /&gt;               &lt;/Shape&gt;            &lt;/Transform&gt;                        &lt;Transform DEF="boxTrafo" translation="-1.5 0 0"&gt;               &lt;Shape DEF="boxShape"&gt;                  &lt;Appearance DEF="boxApp"&gt;                      &lt;Material diffuseColor="1 0 0" specularColor=".5 .5 .5" /&gt;                  &lt;/Appearance&gt;                  &lt;Box DEF="box" /&gt;               &lt;/Shape&gt;            &lt;/Transform&gt;                            &lt;Transform DEF="sphereTrafo" translation="1.5 0 0"&gt;               &lt;Shape DEF="sphereShape"&gt;                  &lt;Appearance DEF="sphereApp"&gt;                     &lt;Material diffuseColor="0 0 1" specularColor=".5 .5 .5" /&gt;                  &lt;/Appearance&gt;                  &lt;Sphere DEF="sphere" /&gt;               &lt;/Shape&gt;            &lt;/Transform&gt;                        &lt;Transform DEF="cylinderTrafo" translation="4.5 0 0"&gt;               &lt;Shape DEF="cylinderShape"&gt;                  &lt;Appearance DEF="cylinderApp"&gt;                     &lt;Material diffuseColor="1 1 0" specularColor=".5 .5 .5" /&gt;                  &lt;/Appearance&gt;                  &lt;Cylinder DEF="cylinder" radius="1.0" height="2.0" /&gt;               &lt;/Shape&gt;            &lt;/Transform&gt;                            &lt;Viewpoint centerOfRotation="0 0 0" position="0 0 15" orientation="0 1 0 0" /&gt;         &lt;/Scene&gt;        &lt;/X3D&gt;   &lt;/p&gt;      &lt;p class="case"&gt; &nbsp; &lt;/p&gt;      &lt;script type="text/javascript" src="x3dom.js"&gt;&lt;/script&gt;   &lt;/body&gt;&lt;/html&gt;'.   ^xml.</pre><h3>Hum-UI -- HumSolid &gt;&gt; x3dMaterial</h3><pre>x3dMaterial   "Return X3D element for appearance/material of this color and opacity.   "   | x3d c |   self assert: ( solidColor isKindOf: Color ).   c := solidColor.   x3d := self x3dMaterialColorRed: (c red) green: (c green) blue: (c blue) alpha: (c alpha).   ^x3d.</pre><h3>Hum-UI -- HumSolid &gt;&gt; x3dMaterialColorRed:green:blue:alpha:</h3><pre>x3dMaterialColorRed: red green: green blue: blue alpha: alpha    "Return X3D element for appearance/material of this color and opacity."   | x3d calc space dict |   "All of the arguments are between zero and one."   { red. green. blue. alpha. } do: [ :x | self assert: ( x &gt;= 0.0 and: [ x &lt;= 1.0 ]) ].   space := String space.  calc := HumCalculator new.  dict := Dictionary new.  dict at: 'color' put: (red printShowingDecimalPlaces:2), space,                       (green printShowingDecimalPlaces:2), space,                        (blue printShowingDecimalPlaces:2), space,                       (alpha printShowingDecimalPlaces:2).   x3d := calc xml: 'material' dictionary: dict.   ^x3d.</pre><h3>Hum-UI -- HumSolid &gt;&gt; x3dShape</h3><pre>x3dShape   "Produce X3D XML shape element"   | x3d  |   "Check that my typeOfSolid instance variable is x3d compatible."   self assert: ( #( #box #cone #cylinder #sphere) includes: typeOfSolid ).   x3d := self x3dShape: (typeOfSolid asString) diffuseColor: (self x3dColor) specularColor: '0.5 0.5 0.5'.   ^x3d.</pre><h3>Hum-UI -- HumSolid &gt;&gt; x3dShape:diffuseColor:specularColor:</h3><pre>x3dShape: typeOfShape diffuseColor: diffuseColor specularColor: specularColor   "Produce X3D XML shape element - override instance variable color?"   | x3d calc template parameters |   calc := HumCalculator new.   template := '            &lt;Transform translation="@position"&gt;               &lt;Shape&gt;                  &lt;Appearance&gt;                     &lt;Material diffuseColor="@diffuseColor" specularColor="@specularColor" /&gt;                  &lt;/Appearance&gt;                  &lt;@typeOfShape DEF="NONE" id="@id" size="@extent" /&gt;               &lt;/Shape&gt;            &lt;/Transform&gt;            '.   parameters := Dictionary new.   parameters at: 'id' put: (self id);                  at: 'position' put: ( self x3dCenter );              at: 'typeOfShape' put: typeOfShape;              at: 'diffuseColor'  put: diffuseColor;              at: 'specularColor'  put: specularColor;              at: 'extent'   put: ( self x3dExtent ).   x3d := calc fillTemplate: template fromDictionary: parameters.   ^x3d.</pre><h3>Hum-UI -- HumSpace &gt;&gt; asPolygons</h3><pre>asPolygons   "Return an empty collection of polygons - HumSpace is not drawn. It is used for spacing in layout logic."   ^    OrderedCollection new.</pre><h3>Hum-UI -- HumSpace &gt;&gt; asPolygonsColorCoded</h3><pre>asPolygonsColorCoded   "Return an empty collection of polygons - HumSpace is not drawn. It is used for spacing in layout logic."   ^    OrderedCollection new.</pre><h3>Hum-UI -- HumSpace &gt;&gt; asVPythonThing</h3><pre>asVPythonThing   "A space has no color and is not visible."   | pythonCode |   pythonCode := id, ' = BoxThing( label = "',id,'"'                                 ,', length = ', (length quantity printShowingDecimalPlaces: 3) "millimeter precision"                                 ,', width = ',   (width quantity printShowingDecimalPlaces: 3)                                 ,', height = ', (height quantity printShowingDecimalPlaces: 3)                          ,', pos = ', ( self asVPythonPosition )                                 ,', visible = false'                                 ,' )'.   ^pythonCode</pre><h3>Hum-UI -- HumStringWidget &gt;&gt; asHTML</h3><pre>asHTML   "Generate HTML input element"   | html calc |   calc := HumCalculator new.   html := calc xml: 'input' dictionary: ((Dictionary new) at: 'name' put: (self attributeName); yourself)               with: [ self attributeValue ].   ^html.   </pre><h3>Hum-UI -- HumStringWidget &gt;&gt; asMorph</h3><pre>asMorph   |  morph |   morph := attributeValue asTextMorph.    morph       color: Color black;                        "&lt;&lt; Foreground text color"      backgroundColor: Color white;      borderWidth: 2;      margins: 5.   ^morph.</pre><h3>Hum-UI -- HumStringWidget &gt;&gt; renderContentOn:</h3><pre>renderContentOn: aWAHtmlCanvas   "render self via a simple input tag"   | |   aWAHtmlCanvas textInput       attributeAt: 'id' put: (self attributeName );      callback: [:value | self store: value ];      with: (self attributeValue asString).</pre><h3>Hum-UI -- HumSurface &gt;&gt; about</h3><pre>about"Q: What is the relation between Sensor, Scribe, Widget, Canvas, Solid, ViewPort.A: The Scribe interprets inputs from the Sensor and updates a Widget.The Widget is drawn on a Canvas which is painted on a Surface.A Surface might be painted on a Solid within a Scene.Note: A Surface is not rendered if it is not visible to the Viewport`s Camera. The data-flow is Sensor &gt;&gt; Scribe &gt;&gt; Widget &gt;&gt; Canvas &gt;&gt; Surface &gt;&gt; ViewPort (Camera).2016-11-01:Sensor sends event to Scribe.Scribe publishes to listeners.Widget (listener) updates state and informs Canvas.Canvas paints (raster) image.Image is painted onto 3D surface texture..Viewport maps 3D surface texture to viewport screen pixels.""2016-11-01:Canvas and Image are 2D anachronisms.3D thinking: Text glyphs are 3D objects such as - paint film modeling brush strokes, - extruded 2D surfaces, - raised type face or tooled grooves,- or something like neon tubes.Revision:Sensor sends event to subscribers.Widget (subscriber) updates state and associated 3D shapes.3D shape announces change.VR pipeline updates viewports.. 3D shapes become meshes.. Texture is mapped onto 3D surfaces (3D magic) &lt;&lt; This is also a kind of anachronism.. Viewport pixels updated by simulated light rays."</pre><h3>Hum-UI -- HumSurface &gt;&gt; addShape:</h3><pre>addShape: aHumSurface    (self shapes) add: aHumSurface.</pre><h3>Hum-UI -- HumSurface &gt;&gt; asBillBoard</h3><pre>asBillBoard   "Convert the surface to a thin HumBox, facing South, hung at eye-level."   "Note: Dimensions given in pixels will be coverted to millimeters."   | billboard zCanvas |   billboard := HumSolid new.   billboard      id: 'billboard';      length: 0.001;  "one millimeter thick"      width: self width asMillimeters;    "Same as my width"      height: self height asMillimeters;      solidColor: self backgroundColor;       westEdge: self left asMillimeters;       northEdge: self layer asMillimeters;      topEdge: (1.75 meter) + (top asMillimeters). "Hang at adult eye level"   "Draw children, if any, on canvas"   zCanvas := self canvas.   (self shapes)       do: [ :shape |           "TODO: Position the part on the billboard"         shape drawOn: zCanvas.         ].   "Attach the canvas to the South face of the billboard."      billboard attachCanvas: zCanvas toFace: #North.   ^billboard.      </pre><h3>Hum-UI -- HumSurface &gt;&gt; asHTML</h3><pre>asHTML   " Render surface as HTML"   | myBlock html calc |   calc := HumCalculator new.      myBlock := [ self asHtmlCanvasOffsetX: (self left) y: (self top) ].   html := calc xml: 'html'             with: [ (calc xml: 'head'                            with: [ calc xml: 'title'                                            with: ['Surface as HTML' ]                                  ]),                     (calc xml: 'body'                             with: [ myBlock value ])                   ].               ^html.</pre><h3>Hum-UI -- HumSurface &gt;&gt; asHtmlCanvasOffsetX:y:</h3><pre>asHtmlCanvasOffsetX: offsetX y: offsetY   "Return a HTML &lt;rect . . . /&gt; element for this surface."   | xml canvasAttributes nextLayer viewX viewY calc |   xml := String new.   canvasAttributes := Dictionary new.   ( id notNil ) ifTrue: [ canvasAttributes add: 'id' -&gt; id ].      "Don't scale dimensions in this version"   canvasAttributes at: 'width' put: width asString.   canvasAttributes at: 'height' put: height asString.   viewX := left + offsetX.   viewY := top + offsetY.      canvasAttributes at: 'x' put: viewX asString.   canvasAttributes at: 'y' put: viewY negated asString.  "Flip our Y value because HTML has Y pointing down."   canvasAttributes at: 'style' put: 'border:3px solid black;'.   calc := HumCalculator new.   xml := '  ', ( calc xml: 'canvas' dictionary: canvasAttributes ), String cr  .      nextLayer := ''.   (self shapes )      do: [ :shape |          nextLayer := nextLayer, (shape asHtmlCanvasOffsetX: viewX y: viewY).         ].   xml := xml, nextLayer.   ^xml.       </pre><h3>Hum-UI -- HumSurface &gt;&gt; asMeasure:</h3><pre>asMeasure: aQuantity   | measure |   ( aQuantity isKindOf: HumMeasure )      ifTrue: [ measure := aQuantity ].   ( aQuantity isKindOf: String )       ifTrue: [ measure := HumMeasure fromString: aQuantity ].   ( aQuantity isKindOf: Number )      ifTrue: [          (self defaultUnits = '%')            ifTrue: [ measure := HumMeasure quantity: aQuantity units: defaultUnits ]            ifFalse: [ measure := aQuantity perform: (self defaultUnits asSymbol) ].         ].         self assert: ( measure isKindOf: HumMeasure ).   "Require internal consistency."   self assert: ( measure units = (self defaultUnits)) description: ('Expecting ', defaultUnits, ' but got: ', measure units).      ^measure</pre><h3>Hum-UI -- HumSurface &gt;&gt; asMorph</h3><pre>asMorph   | result |   result := self canvas formCanvas form asMorph.   ^result.</pre><h3>Hum-UI -- HumSurface &gt;&gt; asSVG</h3><pre>asSVG   "Generate the opening &lt;svg . . . &gt; element."   | myBlock svg calc |      myBlock := [ self asSvgRectOffsetX: (self left) y: (self top) ].   calc := HumCalculator new.   svg := calc xml: 'svg' dictionary: ( HumSurface svgAttributes ) with: myBlock.      ^svg.</pre><h3>Hum-UI -- HumSurface &gt;&gt; asSvgRect</h3><pre>asSvgRect   "Return a SVG &lt;rect . . . /&gt; element for this surface."   | xml rectAttributes nextLayer calc |   self delegated.   xml := String new.   rectAttributes := Dictionary new.   ( id notNil ) ifTrue: [ rectAttributes at: 'ID' put: id ].      "TODO: Determine what SVG scale and transpose should be applied to this surface's rectangle."   rectAttributes at: 'width' put: width asString.   rectAttributes at: 'height' put: height asString.   calc := HumCalculator new.   xml := calc xml: 'rect' dictionary: rectAttributes .      "TODO: Order the shapes by layer."   nextLayer := ''.   (self shapes )      do: [ :shape |          nextLayer := nextLayer, shape asSvgRect.         ].   xml := xml, nextLayer.   ^xml.       </pre><h3>Hum-UI -- HumSurface &gt;&gt; asSvgRectOffsetX:y:</h3><pre>asSvgRectOffsetX: offsetX y: offsetY   "Return a SVG &lt;rect . . . /&gt; element for this surface."   | xml rectAttributes nextLayer viewX viewY calc |   xml := String new.   rectAttributes := Dictionary new.   ( id notNil ) ifTrue: [ rectAttributes at: 'ID' put: id ]. "TODO: CLEAN UP THIS HACK."      "Don't scale dimensions in this version"   rectAttributes at: 'width' put: width asString.   rectAttributes at: 'height' put: height asString.   ( offsetX quantity = 0 ) ifTrue: [ viewX := left ] ifFalse: [ viewX := left + offsetX ].   ( offsetY quantity = 0 ) ifTrue: [ viewY := top  ] ifFalse: [ viewY := top  + offsetY ].   rectAttributes at: 'x' put: viewX asString.   rectAttributes at: 'y' put: viewY negated asString.  "Flip our Y value because SVG has Y pointing down."   calc := HumCalculator new.   xml := calc xml: 'rect' dictionary: rectAttributes .      nextLayer := ''.   (self shapes )      do: [ :shape |          nextLayer := nextLayer, (shape asSvgRectOffsetX: viewX y: viewY).         ].   xml := xml, nextLayer.   ^xml.       </pre><h3>Hum-UI -- HumSurface &gt;&gt; asSvgViewBox</h3><pre>asSvgViewBox   | attributes viewBoxAttribute space myBlock svg calc |   "Set up standard attributes for the svg prolog."   calc := HumCalculator new.   space := $   asString.   attributes := Dictionary new.   attributes at: 'xmlns' put: 'http://www.w3.org/2000/svg'.   attributes at: 'xmlns:xlink' put: 'http://www.w3.org/1999/xlink'.   attributes at: 'width' put: '100%'.   attributes at: 'height' put: '100%'.      viewBoxAttribute := self left quantity asString, space,                                  self top quantity asString, space,                                  self width quantity asString, space,                                  self height quantity asString.   attributes add: 'viewBox' -&gt; viewBoxAttribute.      myBlock := [ self asSvgRectOffsetX: 0 px y: 0 px.  ].      svg := calc xmlOpen: 'svg' dictionary: attributes.   svg := svg, '&lt;g stroke="#001122" stroke-width="0.03" fill="ffeedd" &gt;'.   svg := svg, ( myBlock value).   svg := svg, '&lt;/g&gt;'.   svg := svg, '&lt;/svg&gt;'.   ^svg.</pre><h3>Hum-UI -- HumSurface &gt;&gt; asXML</h3><pre>asXML   | myBlock xml calc |      myBlock := [ self asXMLRectOffsetX: (self left) y: (self top) ].   calc := HumCalculator new.   xml := calc xml: 'script' dictionary: ( HumSurface humSurfaceAttributes ) with: myBlock.      ^xml.</pre><h3>Hum-UI -- HumSurface &gt;&gt; asXMLRectOffsetX:y:</h3><pre>asXMLRectOffsetX: offsetX y: offsetY    "Return a hum &lt;surface . . . /&gt; element for this surface."   | xml rectAttributes nextLayer viewX viewY calc |   xml := String new.   rectAttributes := Dictionary new.   ( id notNil ) ifTrue: [ rectAttributes add: 'ID' -&gt; id ].      rectAttributes at: 'width' put: width asString.   rectAttributes at: 'height' put: height asString.   viewX := left + offsetX.   viewY := top + offsetY.      rectAttributes at: 'x' put: viewX asString.   rectAttributes at: 'y' put: viewY asString.     calc := HumCalculator new.   xml := calc xml: 'hum:surface' dictionary: rectAttributes .      nextLayer := ''.   (self shapes )      do: [ :shape |          nextLayer := nextLayer, (shape asXMLRectOffsetX: viewX y: viewY).         ].   xml := xml, nextLayer.   ^xml.       </pre><h3>Hum-UI -- HumSurface &gt;&gt; backgroundColor</h3><pre>backgroundColor      ^ backgroundColor ifNil: [backgroundColor := Color gray ].</pre><h3>Hum-UI -- HumSurface &gt;&gt; backgroundColor:</h3><pre>backgroundColor: aColor   "Set color to be used when background is rendered."   self assert: (aColor isKindOf: Color).   backgroundColor := aColor.</pre><h3>Hum-UI -- HumSurface &gt;&gt; bbBottom</h3><pre>bbBottom   "Find my bounding box edge."   | myEdge  |   myEdge := self bbEdge: #bottom.   ^myEdge.</pre><h3>Hum-UI -- HumSurface &gt;&gt; bbEdge:</h3><pre>bbEdge: aSymbol   "Find my bounding box edge.    aSymbol names an edge."   | myEdge  |   self assert: ( { #bottom. #left. #right. #top. } includes: aSymbol ).   myEdge := self perform: aSymbol.   self shapes       do: [ :shape |             | otherEdge |            otherEdge := (shape perform: aSymbol).            ( ({#right. #top.} includes: aSymbol ) and: [otherEdge &gt; myEdge] ) ifTrue: [ myEdge := otherEdge ].            ( ({#left. #bottom.} includes: aSymbol ) and: [otherEdge &lt; myEdge] ) ifTrue: [ myEdge := otherEdge ].            ].   ^myEdge.</pre><h3>Hum-UI -- HumSurface &gt;&gt; bbHeight</h3><pre>bbHeight   "Find my bounding box edge."   |  bbHeight |   bbHeight := ((self bbTop) - (self bbBottom)) abs.   ^bbHeight.</pre><h3>Hum-UI -- HumSurface &gt;&gt; bbLeft</h3><pre>bbLeft   "Find my bounding box edge."   | myEdge  |   myEdge := self bbEdge: #left.   ^myEdge.</pre><h3>Hum-UI -- HumSurface &gt;&gt; bbRight</h3><pre>bbRight   "Find my bounding box edge."   | myEdge  |   myEdge := self bbEdge: #right.   ^myEdge.</pre><h3>Hum-UI -- HumSurface &gt;&gt; bbTop</h3><pre>bbTop   "Find my bounding box edge."   | myEdge  |   myEdge := self bbEdge: #top.   ^myEdge.</pre><h3>Hum-UI -- HumSurface &gt;&gt; bbWidth</h3><pre>bbWidth   "Find my bounding box edge."   |  bbWidth |   bbWidth := ((self bbRight) - (self bbLeft)) abs.   ^bbWidth.</pre><h3>Hum-UI -- HumSurface &gt;&gt; borderColor</h3><pre>borderColor   "What color is my border, ifany?"   ^borderColor ifNil: [ borderColor := Color black ].</pre><h3>Hum-UI -- HumSurface &gt;&gt; bottom</h3><pre>bottom   ^ bottom ifNil: [ self bottom: 0 meter ].</pre><h3>Hum-UI -- HumSurface &gt;&gt; bottom:</h3><pre>bottom: aNumber   "Reset the bottom edge."   bottom := self asMeasure: aNumber.   "Force top edge to be bottom + height"   top := bottom + (self height).</pre><h3>Hum-UI -- HumSurface &gt;&gt; canvas</h3><pre>canvas   "Attach a canvas - for placing drawings and images on the surface"   ^canvas ifNil:[ canvas := HumCanvas new ].</pre><h3>Hum-UI -- HumSurface &gt;&gt; defaultUnits</h3><pre>defaultUnits   ^defaultUnits ifNil: [ defaultUnits := 'px' ].   </pre><h3>Hum-UI -- HumSurface &gt;&gt; defaultUnits:</h3><pre>defaultUnits: aSymbol   ^defaultUnits := aSymbol.   </pre><h3>Hum-UI -- HumSurface &gt;&gt; drawOn:</h3><pre>drawOn: aHumCanvas    "Draw self on the given canvas."   | polygon |   self assert: (aHumCanvas isKindOf: HumCanvas).   polygon := HumPolygon borderColor: (self borderColor) fillColor: (self fillColor).   polygon      addVertex: { left. top. };      addVertex: { left. bottom. };      addVertex: { right. bottom. };      addVertex: { right. top. }.   aHumCanvas drawPolygon: polygon scale: ((5 px)/(1 millimeter)).    </pre><h3>Hum-UI -- HumSurface &gt;&gt; expandToFit</h3><pre>expandToFit   |  |   ((self height) &lt; (self bbHeight)) ifTrue: [self height: (self bbHeight)].   ((self width) &lt; (self bbWidth)) ifTrue: [self width: (self bbWidth)].   </pre><h3>Hum-UI -- HumSurface &gt;&gt; fillColor</h3><pre>fillColor   "What color is my fill, ifany?"   ^fillColor ifNil: [ fillColor := Color gray ].</pre><h3>Hum-UI -- HumSurface &gt;&gt; generateHumScript</h3><pre>generateHumScript   "Proof of concept: Generate Hum code."   | script space period |   space := ' '.   period := '.'.   script := '. Painter: '.   script := script, 'Paint surface with '.   script := script, space, 'id', space, (self id) quoted.   script := script, space, 'width', space, (self width) asString quoted.   script := script, space, 'height', space, (self height) asString quoted.   script := script, space, 'left', space, (self left) asString quoted.   script := script, space, 'top', space, (self top) asString quoted.      script := script, period.      ( self shapes )      do: [ :shape | script := script, String cr, (shape generateHumScript ) ].      ^script.</pre><h3>Hum-UI -- HumSurface &gt;&gt; height</h3><pre>height   "What is the height of this object?   This is Y extent or length when surface is horizontal as seen on on table or document.   This is Z extent or height when surface is vertical as seen on a billboard.   The other dimensions are width and layer.   NOTE: In this model, a HumSurface has no thickness.   "   ^ height ifNil: [ self height: 0 meter ].</pre><h3>Hum-UI -- HumSurface &gt;&gt; height:</h3><pre>height: aNumber.   "Reset the distance between top and bottom edges."   height := self asMeasure: aNumber.   "Force the bottom to be the top minus the height."   bottom := (self top) - height.</pre><h3>Hum-UI -- HumSurface &gt;&gt; id</h3><pre>id   self assert: ( id isKindOf: String ).   self assert: ( id notEmpty ).   ^ id</pre><h3>Hum-UI -- HumSurface &gt;&gt; id:</h3><pre>id: aString    id := aString.</pre><h3>Hum-UI -- HumSurface &gt;&gt; initialize</h3><pre>initialize   self initialize: 'px'.   </pre><h3>Hum-UI -- HumSurface &gt;&gt; initialize:</h3><pre>initialize: units   | zero unitOfMeasure |   self assert: ( units isKindOf: String ).   "Reset #pixel to #px as needed.   In this case, the abbreviation is the preferred expression.   "   unitOfMeasure := units asString.   (units = 'pixel') ifTrue: [ unitOfMeasure := 'px' ].    (units = 'percent') ifTrue: [ unitOfMeasure := '%'].   zero := HumMeasure quantity: 0.0 units: unitOfMeasure.   self defaultUnits: (zero units).      width := zero.   left := zero.   right := zero.      height := zero.   top := zero.   bottom := zero.      layer := zero.</pre><h3>Hum-UI -- HumSurface &gt;&gt; layer</h3><pre>layer   "What layer is the surface in?   Surfaces with higher layer numbers will overlay (obscure) those with lower layer numbers.   You should avoid overlapping surfaces in the same layer. The result is not deterministic.   See also: #overlay:onTopOf:   "   "By default, a surface is in layer zero."   ^ layer ifNil: [ layer := 0 ].</pre><h3>Hum-UI -- HumSurface &gt;&gt; layer:</h3><pre>layer: aNumber   layer := aNumber</pre><h3>Hum-UI -- HumSurface &gt;&gt; left</h3><pre>left   ^ left ifNil: [ self left: 0 meter ].</pre><h3>Hum-UI -- HumSurface &gt;&gt; left:</h3><pre>left: aNumber   | measure |   measure := self asMeasure: aNumber.   "Reset the left edge."   left := measure.   "Force the right edge to keep width constant."   right := left + (self width).</pre><h3>Hum-UI -- HumSurface &gt;&gt; origin</h3><pre>origin   "a zero-size object positioned at ( left top layer ) = ( 0 0 0 )"      ^ origin ifNil: [ origin := HumSurface new.  ].</pre><h3>Hum-UI -- HumSurface &gt;&gt; overlay:onTopOf:</h3><pre>overlay: aHumSurfaceB onTopOf: aHumSurfaceA    "Both shapes are assumed (forced) to be present in my collection."   self addShape: aHumSurfaceA.   self addShape: aHumSurfaceB.   "By convention, surface B will be aligned with A's top and left edges."   aHumSurfaceB top: (aHumSurfaceA top).      aHumSurfaceB left: (aHumSurfaceA left).   "By convention, surface B will be placed in a higher numbered layer."   "Note: If there already was already another shape on top and in same layer,       there is no attempt to place this one in-between."   aHumSurfaceB layer: (aHumSurfaceA layer) + 1.   </pre><h3>Hum-UI -- HumSurface &gt;&gt; place:above:</h3><pre>place: aHumSurfaceB above: aHumSurfaceA    "Place B above A on the surface.    (Not to be confused with putting B on a different layer.)"      "Assure that A and B are in my collection."   self addShape: aHumSurfaceA.   self addShape: aHumSurfaceB.      "By convention, set B's bottom will be equal to A's top.   i.e. There is no gap."   aHumSurfaceB bottom: ( aHumSurfaceA top ).      "By convention, B is now in the same layer as A."   aHumSurfaceB layer: ( aHumSurfaceA layer ).      </pre><h3>Hum-UI -- HumSurface &gt;&gt; place:at:</h3><pre>place: aHumSurface at: anArray    | x y z |   x := anArray at: 1.   y := anArray at: 2.   z := anArray at: 3.      self addShape: aHumSurface.   aHumSurface top: y; left: x; layer: z.</pre><h3>Hum-UI -- HumSurface &gt;&gt; place:below:</h3><pre>place: aHumSurfaceB below: aHumSurfaceA    "Place B below A on the surface. (Not to be confused with putting B on a different  layer.)"   "TODO: Consider making calls to top: right: left: using blocks (closures) so that everything is dynamic.    Counter: Use relative positions.              When rendering, we will iterate (self shapes).              If child shape positions are relative, we get the same effect.   "      "Assure that A and B are in my collection."   self addShape: aHumSurfaceA.   self addShape: aHumSurfaceB.      "By convention, set B's top to be equal to A's bottom.   i.e. There is no gap."   aHumSurfaceB top: ( aHumSurfaceA bottom ).      "By convention, B is now in the same layer as A."   aHumSurfaceB layer: ( aHumSurfaceA layer ).      </pre><h3>Hum-UI -- HumSurface &gt;&gt; place:leftOf:</h3><pre>place: aHumSurfaceB leftOf: aHumSurfaceA    "Place B left of A on the surface. "      "Assure that A and B are in my collection."   self addShape: aHumSurfaceA.   self addShape: aHumSurfaceB.      "By convention, set B's left to be equal to A's right.   i.e. There is no gap / gutter."   aHumSurfaceB left: ( aHumSurfaceA right ).      "By convention, B is now in the same layer as A."   aHumSurfaceB layer: ( aHumSurfaceA layer ).      </pre><h3>Hum-UI -- HumSurface &gt;&gt; place:rightOf:</h3><pre>place: aHumSurfaceB rightOf: aHumSurfaceA    "Place B right of A on the surface. "      "Assure that A and B are in my collection."   self addShape: aHumSurfaceA.   self addShape: aHumSurfaceB.      "By convention, set B's right to be equal to A's left.   i.e. There is no gap / gutter."   aHumSurfaceB left: ( aHumSurfaceA right ).      "By convention, B is now in the same layer as A."   aHumSurfaceB layer: ( aHumSurfaceA layer ).      </pre><h3>Hum-UI -- HumSurface &gt;&gt; right</h3><pre>right   ^ right ifNil: [self right: 0 meter ].</pre><h3>Hum-UI -- HumSurface &gt;&gt; right:</h3><pre>right: aNumber      "Reset the right edge."   right := self asMeasure: aNumber.   "Force the left edge to keep the width constant."   left := right - (self width).</pre><h3>Hum-UI -- HumSurface &gt;&gt; shapes</h3><pre>shapes   "I remember the 2d objects placed on me."   ^ shapes ifNil: [ shapes := Set new. ].</pre><h3>Hum-UI -- HumSurface &gt;&gt; title</h3><pre>title   ^ title ifNil: [ self id ].</pre><h3>Hum-UI -- HumSurface &gt;&gt; title:</h3><pre>title: aString   title := aString.   </pre><h3>Hum-UI -- HumSurface &gt;&gt; top</h3><pre>top   ^ top ifNil: [ top := 0 ].</pre><h3>Hum-UI -- HumSurface &gt;&gt; top:</h3><pre>top: aNumber   "Reset the top edge."   top := self asMeasure: aNumber.   "Force the bottom edge to keep the height constant."   bottom := top - (self height).</pre><h3>Hum-UI -- HumSurface &gt;&gt; width</h3><pre>width   ^ width ifNil: [ self width: 0 meter. ]</pre><h3>Hum-UI -- HumSurface &gt;&gt; width:</h3><pre>width: anObject   "Reset the width.    This is the X extent in most contexts.   See also: height and layer."   width := self asMeasure: anObject.   "Force the right edge to be consistent."   right := (self left) + width.</pre><h3>Hum-UI -- HumTextPrettyPrinter &gt;&gt; addCommentToEndOfLineStartsWith:</h3><pre>addCommentToEndOfLineStartsWith: aString    | |   self assert: (aString isKindOf:  String).   startCommentToEndOfLine := aString.</pre><h3>Hum-UI -- HumTextPrettyPrinter &gt;&gt; parse:</h3><pre>parse: aHumTextLine    |  tokens ppTokens |   "delimiters := (' ', startCommentToEndOfLine )."   tokens := ( aHumTextLine string ) substrings.    ppTokens := OrderedCollection new.   tokens do: [ :token |       | ppToken |      ppToken := HumTextPrettyToken new.      ppToken string: token.      ppTokens add: ppToken.      ].   ^ ppTokens.   </pre><h3>Hum-UI -- HumTextPrettyToken &gt;&gt; string</h3><pre>string      ^ string ifNil: [ string := String new. ].</pre><h3>Hum-UI -- HumTextPrettyToken &gt;&gt; string:</h3><pre>string: aString    self assert: ( aString isKindOf: String ).   string := aString.</pre><h3>Hum-UI -- HumTextWidget &gt;&gt; asHTML</h3><pre>asHTML   "Generate HTML textarea element"   | html calc |   calc := HumCalculator new.   html := calc xml: 'textarea' with: [ self attributeValue ].   ^html.</pre><h3>Hum-UI -- HumTextWidget &gt;&gt; asMorph</h3><pre>asMorph   | morph |   "Instantiate a TextMorph of some kind."   morph := self attributeValue asTextMorph.   "Set some visual properties."   morph       backgroundColor: Color white;      margins: 5;      borderWidth: 2.   "TODO: Wire up the UI interaction:      KeyStroke &gt;&gt; Morph(TextMorphForEditView ) &gt;&gt; HumTextWidget &gt;&gt; HumTextEditor &gt;&gt; HumText"   ^morph.</pre><h3>Hum-UI -- HumTextWidget &gt;&gt; renderContentOn:</h3><pre>renderContentOn: aWAHtmlCanvas   "render self via a text area tag"   | |   aWAHtmlCanvas textArea       attributeAt: 'id' put: (self attributeName );      rows: (self rows);      callback: [:value | self store: value ];      with: (self attributeValue asString).</pre><h3>Hum-UI -- HumTextWidget &gt;&gt; rows</h3><pre>rows   "How many rows should we display?"    ^ rows</pre><h3>Hum-UI -- HumTextWidget &gt;&gt; rows:</h3><pre>rows: aSmallInteger   "How many rows should we display?"    rows := aSmallInteger. </pre><h3>Hum-UI -- HumTurtle &gt;&gt; headEast</h3><pre>headEast   self heading: (90 degrees).</pre><h3>Hum-UI -- HumTurtle &gt;&gt; headNorth</h3><pre>headNorth   self heading: (0 degrees).</pre><h3>Hum-UI -- HumTurtle &gt;&gt; headSouth</h3><pre>headSouth   self heading: (180 degrees).</pre><h3>Hum-UI -- HumTurtle &gt;&gt; headWest</h3><pre>headWest   self heading: (-90 degrees).</pre><h3>Hum-UI -- HumTurtle &gt;&gt; heading</h3><pre>heading   ^heading ifNil: [ heading := (0 degrees) ].</pre><h3>Hum-UI -- HumTurtle &gt;&gt; heading:</h3><pre>heading: compassHeading   "North is 0 degrees. East is 90 degrees. West is minus 90. South is 180."   self assert: ( compassHeading isKindOf: HumMeasure ).   heading := compassHeading.</pre><h3>Hum-UI -- HumTurtle &gt;&gt; initialize</h3><pre>initialize   "The initial turtle position is at origin (0@0) facing North."   |   |   self assert: self position = (0.0@0.0).   self assert: self heading = (0 degrees).   "The distance per step is the speed."   self assert: self speed = 1.0.    "Tail is up - so the turtle is not painting."   self assert: self tail = #up.   self assert: self tailColor = (Color black).   </pre><h3>Hum-UI -- HumTurtle &gt;&gt; position</h3><pre>position   ^ position ifNil: [ position := 0.0@0.0. ]</pre><h3>Hum-UI -- HumTurtle &gt;&gt; position:</h3><pre>position: aPoint   "Move turtle to aPoint without painting."   position := aPoint.   self moveBrushTo: aPoint.</pre><h3>Hum-UI -- HumTurtle &gt;&gt; speed</h3><pre>speed   "Distance traveled on each step."   ^ speed ifNil: [ speed := 1.0 ]</pre><h3>Hum-UI -- HumTurtle &gt;&gt; speed:</h3><pre>speed: aFloat   "Distance traveled on each step."   speed := aFloat</pre><h3>Hum-UI -- HumTurtle &gt;&gt; step</h3><pre>step   "Move forward one step"   | newPosition stepVector stepX stepY |   stepX := speed * ( heading  sin ).   stepY := speed * ( heading  cos ).   stepVector := stepX @ stepY.   newPosition := position + stepVector.   "Paint using super methods"   ( tail = #up )      ifTrue: [ self moveBrushTo: newPosition ]      ifFalse: [ self paintTo: newPosition ].   "Update position"   position := newPosition.   </pre><h3>Hum-UI -- HumTurtle &gt;&gt; tail</h3><pre>tail   ^ tail ifNil: [ tail := #up ].</pre><h3>Hum-UI -- HumTurtle &gt;&gt; tail:</h3><pre>tail: aSymbol   "tail = #up means no paint, otherwise lines are drawn with tailColor."   tail := aSymbol.   </pre><h3>Hum-UI -- HumTurtle &gt;&gt; tailColor</h3><pre>tailColor   "What color am I painting at this time?"   ^ self brushColor.    "Note: I am a subclass of HumCanvas."</pre><h3>Hum-UI -- HumTurtle &gt;&gt; tailColor:</h3><pre>tailColor: aColor   "What color am I painting at this time?"   ^ self brushColor: aColor.     "Note: I am a subclass of HumCanvas."</pre><h3>Hum-UI -- HumTurtle &gt;&gt; turn:</h3><pre>turn: degreeIncrement   "Change heading by given amount."   | newHeading |   self assert: ( degreeIncrement isKindOf: HumMeasure ).   newHeading := heading + degreeIncrement.   self heading: newHeading.   </pre><h3>Hum-UI -- HumTurtle &gt;&gt; turnLeft</h3><pre>turnLeft   self turn: (90.0 degrees) negated.</pre><h3>Hum-UI -- HumTurtle &gt;&gt; turnRight</h3><pre>turnRight   self turn: (90.0 degrees).</pre><h3>Hum-UI -- HumVR &gt;&gt; addScene:</h3><pre>addScene: aHumScene    self scenes at: aHumScene id put: aHumScene.</pre><h3>Hum-UI -- HumVR &gt;&gt; jump:</h3><pre>jump:  aTime   "Execute equations of motion, etc."   self jumpTime: aTime.   self scenes do: [ :scene | scene jump: (self jumpTime) ].   "TODO: Make compatible to HumSimulator."</pre><h3>Hum-UI -- HumVR &gt;&gt; jumpTime</h3><pre>jumpTime   "Get the latest VR-world time. This is set by the last time-jump. See: #jump: "   jumpTime ifNil: [ self jumpTime: (HumMeasure seconds: 1) ].   ^jumpTime.</pre><h3>Hum-UI -- HumVR &gt;&gt; jumpTime:</h3><pre>jumpTime: aTime   "Set the VR-world time. (Use to synchronize state across scenes) - called from #jump:"   self assert: (aTime isKindOf: HumMeasure).   self assert: (aTime dimensions = (HumMeasure seconds: 1) dimensions ).   jumpTime := aTime.</pre><h3>Hum-UI -- HumVR &gt;&gt; scenes</h3><pre>scenes   "A VR world has one or more scenes identified and accessed by their IDs. "   ^ scenes ifNil: [  scenes := Dictionary new ].</pre><h3>Hum-UI -- HumVR &gt;&gt; start</h3><pre>start   "Start stepping."   self jump: (self jumpTime) "*** STUB ***  TODO: Fork a process and start it stepping."</pre><h3>Hum-UI -- HumVR &gt;&gt; stop</h3><pre>stop   "Stop stepping"   </pre><h3>Hum-UI -- HumViewPortMorph &gt;&gt; camera</h3><pre>camera   | camera |   camera := self viewPort camera.   ^camera.</pre><h3>Hum-UI -- HumViewPortMorph &gt;&gt; handleKeystroke:</h3><pre>handleKeystroke: anEvent   | keyValue keyCharacter calc dJump |   self assert: ( anEvent isKindOf: KeyboardEvent ).   dJump := 1 meter.   calc := HumCalculator new.   keyValue := anEvent keyValue.   keyCharacter := anEvent keyCharacter.    calc cases;      when: [ keyCharacter asLowercase  = $q  ] then: [ self delete ];      when: [ keyCharacter asLowercase = $f ] then: [ self camera slideForward: dJump ];      when: [ keyCharacter asLowercase = $b ] then: [ self camera slideBackward: dJump ];      when: [ keyCharacter asLowercase = $l ] then: [ self camera slideLeft: dJump ];      when: [ keyCharacter asLowercase = $r ] then: [ self camera slideRight: dJump ];            when: [ anEvent commandKeyPressed ]          then: [ | calc2 dTilt newTilt |            dTilt := (5 degrees).             newTilt := (self camera tilt) + (5 degreesToRadians).            calc2 := HumCalculator new.            calc2 cases;               when: [ keyValue = 30 "arrowUp" ]       then: [ self camera tiltUp: dTilt ];           "Pitch up."               when: [ keyValue = 31 "arrowDown" ]    then: [ self camera tiltDown: dTilt ];               when: [ keyValue = 28 "arrowLeft" ]       then: [ self camera rotateLeft: dTilt ];      "Yaw to the left."               when: [ keyValue = 29 "arrowRight" ]    then: [ self camera rotateRight: dTilt ];               "TODO: Add ability to roll the camera."               otherwise: [ Transcript cr; show: anEvent keyString, ' keyValue not handled.' ].            ];      when: [ keyValue = 30 "arrowUp" ]       then: [ self camera slideUp: dJump ];      when: [ keyValue = 31 "arrowDown" ]    then: [ self camera slideDown: dJump ];      when: [ keyValue = 28 "arrowLeft" ]       then: [ self camera slideLeft: dJump ];      when: [ keyValue = 29 "arrowRight" ]    then: [ self camera slideRight: dJump ];            otherwise: [ Transcript cr; show: anEvent keyString, ' keyValue not handled.' ].   self changed.</pre><h3>Hum-UI -- HumViewPortMorph &gt;&gt; handlesMouseOver:</h3><pre>handlesMouseOver: evt   ^true.</pre><h3>Hum-UI -- HumViewPortMorph &gt;&gt; mouseEnter:</h3><pre>mouseEnter: anEvent   anEvent hand newKeyboardFocus: self.</pre><h3>Hum-UI -- HumViewPortMorph &gt;&gt; mouseLeave:</h3><pre>mouseLeave: anEvent   anEvent hand newKeyboardFocus: nil.</pre><h3>Hum-UI -- HumViewPortMorph &gt;&gt; viewPort</h3><pre>viewPort   ^ viewPort</pre><h3>Hum-UI -- HumViewPortMorph &gt;&gt; viewPort:</h3><pre>viewPort: aHumViewPort    viewPort := aHumViewPort.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; asMorph</h3><pre>asMorph   | morph |   morph := (self canvas) asMorph.   self assert: (morph isKindOf: HumViewPortMorph ).   morph viewPort: self.   ^morph.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; camera</h3><pre>camera   "Which camera (in the scene)?"   ^camera ifNil: [ Error signal: 'Viewport needs a camera.' ]</pre><h3>Hum-UI -- HumViewPort &gt;&gt; camera:</h3><pre>camera: aCamera    "Which camera (in the scene)?"   self assert: ( aCamera isKindOf: HumCamera ).   camera := aCamera.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; cameraCanSeePolygon:</h3><pre>cameraCanSeePolygon: aHumPolygon    "The camera can see the polygon       if . . . y/x and z/x angles for at least one point are within the camera`s field of view."   aHumPolygon verticesDo: [ :x :y :z |       | answer |      "Delegate to camera (HumCamera)"      answer := self camera isPointInFieldOfView: { x. y. z. }.      (answer) ifTrue: [ ^true. ].      ].   ^false.   </pre><h3>Hum-UI -- HumViewPort &gt;&gt; changed</h3><pre>changed   super changed.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; getPolygonsForSolids:</h3><pre>getPolygonsForSolids: aCollectionOfSolids    "Return polygons corresponding to the surfaces of the given solids."   | polygons |   polygons := OrderedCollection new.   aCollectionOfSolids      do: [ :solid |          | solidPolygons |         solidPolygons := solid asPolygonsColorCoded.         polygons addAll: solidPolygons.         ].   "NOTE: These polygons are not transformed."   ^polygons.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; getPolygonsForSolids:colorRule:</h3><pre>getPolygonsForSolids: aCollectionOfSolids colorRule: aOneArgumentBlock   "Return polygons corresponding to the surfaces of the given solids."   | polygons |   polygons := OrderedCollection new.   aCollectionOfSolids      do: [ :solid |          | solidPolygons |         solidPolygons := solid asPolygonsColoredBy: aOneArgumentBlock.         polygons addAll: solidPolygons.         ].   "NOTE: These polygons are not transformed."   ^polygons.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; mapPolygonsFrom3Dto2D</h3><pre>mapPolygonsFrom3Dto2D   "Each solid in the scene provides a collection of polygons with points in 3D scene coordinates.    Those polygons are translated into new polygons with points in 2D viewport coordinates."   |   cameraSolids viewportPolygons     cameraPolygons culledPolygons sortedPolygons  transformedPolygons cameraTriangles |   cameraSolids := self selectSolidsInFrontOfCamera.   cameraPolygons := self getPolygonsForSolids: cameraSolids.   cameraTriangles := OrderedCollection new.   transformedPolygons := cameraPolygons collect: [ :polygon | self transformPolygonToCameraFrame: polygon ].   culledPolygons := transformedPolygons select: [ :polygon |  self cameraCanSeePolygon: polygon  ].   sortedPolygons := culledPolygons sort: [ :a :b | a northMostPoint  &gt;  b northMostPoint ].   viewportPolygons := self mapPolygonsToViewPort: sortedPolygons.   'This works in simple scenes but simply fails when things get just a little more complex.   What is needed is a kind of pixel matrix where each pixel includes depth (distance from camera) information.   We could extend BitBlt and BitMap classes to get that effect - But their implementations are hidden behind primatives.   Then, while painting, pixels that are closer in may overlay pixels that are farther out.'.   'Of course, much of this might be obviated by delegating to an external 3D scene painter.'.    ^viewportPolygons.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; mapPolygonsFrom3Dto2DcolorCoded</h3><pre>mapPolygonsFrom3Dto2DcolorCoded   "Each solid in the scene provides a collection of polygons with points in 3D scene coordinates.    Those polygons are translated into new polygons with points in 2D viewport coordinates."   | scenePolygons cameraPolygons viewportPolygons cameraDepth transformToCanvas2D |   scenePolygons := OrderedCollection new.  "For debug?"   cameraPolygons := OrderedCollection new.   viewportPolygons := OrderedCollection new.      ((scene parts) reject: [ :part | part isKindOf: HumCamera])      do: [ :solid |         | solidPolygons |         solidPolygons := solid asPolygonsColorCoded.         solid resetColoring.         ( solidPolygons ) "Provides crude z-order - North to South ordering. See HumPolygon"            do: [ :solidPolygon  |                | transformedPolygon  |               "Project onto camera frustrum"               transformedPolygon := self transformPolygonToCameraFrame:  solidPolygon.               cameraPolygons add: transformedPolygon.               ].          ].   cameraDepth := self camera depth.   transformToCanvas2D := [ :x :y :z | self projectScenePoint: { x. y. z. } cameraDepth: cameraDepth ].         "TODO: Cull faces that are behind the camera."         "TODO: Sort faces to draw those that are far from camera under those that are close."   (cameraPolygons sort: [:a :b | (a maxRsquared) &gt; (b maxRsquared) ])       do: [ :cameraPolygon |         | viewportPolygon |         viewportPolygon := HumPolygon copy: cameraPolygon withTransform: transformToCanvas2D.         viewportPolygons add: viewportPolygon.         ].   ^viewportPolygons.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; mapPolygonsToViewPort:</h3><pre>mapPolygonsToViewPort: aCollectionOfPolygons    "Map from 3D to 2D"   | cameraDepth transformToCanvas2D viewportPolygons |   viewportPolygons := OrderedCollection new.   cameraDepth := self camera depth.   transformToCanvas2D := [ :x :y :z | self projectScenePoint: { x. y. z. } cameraDepth: cameraDepth ].   aCollectionOfPolygons      do: [ :polygon |               | viewportPolygon |               viewportPolygon := HumPolygon copy: polygon withTransform: transformToCanvas2D.               viewportPolygons add: viewportPolygon.                ].   ^viewportPolygons</pre><h3>Hum-UI -- HumViewPort &gt;&gt; mapToCanvas:bounds:</h3><pre>mapToCanvas: aHumCanvas bounds: aRectangle    "Declare where to draw me. Drawing is defered. See . . ."   self canvas: aHumCanvas.   bounds := aRectangle.   "TODO: These declarations should affect asMorph."   </pre><h3>Hum-UI -- HumViewPort &gt;&gt; mapTrianglesFrom3Dto2D</h3><pre>mapTrianglesFrom3Dto2D   "Each solid in the scene provides a collection of polygons with points in 3D scene coordinates.    Those polygons are translated into new polygons with points in 2D viewport coordinates."   |   cameraSolids viewportPolygons     cameraPolygons culledPolygons sortedPolygons  transformedPolygons cameraTriangles |   cameraSolids := self selectSolidsInFrontOfCamera.   cameraPolygons := self getPolygonsForSolids: cameraSolids.       cameraTriangles := OrderedCollection new.   cameraPolygons do: [ :quad | |triangles|  triangles := quad asTriangles. cameraTriangles addAll: triangles ].   transformedPolygons := cameraTriangles collect: [ :polygon | self transformPolygonToCameraFrame: polygon ].   culledPolygons := transformedPolygons select: [ :polygon |  self cameraCanSeePolygon: polygon  ].   sortedPolygons := culledPolygons sort: [ :a :b | a meanRsquared  &gt;  b meanRsquared ].   viewportPolygons := self mapPolygonsToViewPort: sortedPolygons.   ^viewportPolygons.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; paintHumPolygon:</h3><pre>paintHumPolygon: aHumPolygon    "The HumPolygon may contain 3D points and specifies fill and border colors.    We project to 2D and draw on our form."   |   aBorderWidth aBorderColor  aFillColor scaledVertices |   aBorderWidth := 2.   aBorderColor := aHumPolygon borderColor.   aFillColor := aHumPolygon fillColor.   scaledVertices := OrderedCollection new.   aHumPolygon verticesDo: [ :x :y :z | scaledVertices add: (x@y) ].   self formCanvas drawPolygon: scaledVertices fillStyle: aFillColor borderWidth: aBorderWidth borderColor: aBorderColor.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; paintScene</h3><pre>paintScene   "Render solids in my scene as polygons projected onto my canvas."   | flatPolygons aCanvas |   "Solid faces are 3D polygons. Project to 2D viewport canvas."   flatPolygons := self mapPolygonsFrom3Dto2D.   aCanvas := self canvas.   flatPolygons      do: [ :polygon |         self paintHumPolygon: polygon.          ].   self repaint: [ self paintScene. ].   'This works in simple scenes but easily fails when things get just a little more complex.   What is needed is a kind of pixel matrix where each pixel includes depth (distance from camera) information.   Then, while painting, pixels that are closer in may overlay pixels that are farther out.'.   </pre><h3>Hum-UI -- HumViewPort &gt;&gt; paintSceneAsTriangles</h3><pre>paintSceneAsTriangles   "Render solids in my scene as polygons projected onto my canvas."   |  triangles aCanvas |   "Solid faces are 3D polygons. Project to 2D viewport canvas."   triangles := self mapPolygonsToTriangles.   aCanvas := self canvas.   triangles      do: [ :triangle |         self paintHumPolygon: triangle.          ].   self repaint: [ self paintSceneAsTriangles. ]   </pre><h3>Hum-UI -- HumViewPort &gt;&gt; paintSceneColorCoded</h3><pre>paintSceneColorCoded   "Render solids in my scene as polygons projected onto my canvas."   ^ self renderSceneAsTriangles.    </pre><h3>Hum-UI -- HumViewPort &gt;&gt; projectPolygon:</h3><pre>projectPolygon: aScenePolygon    "Return a new polygon with the points transformed into camera`s coordinate system."   | transformedPolygon cameraDepth |   "Initialize polygon colors"   transformedPolygon := HumPolygon borderColor: aScenePolygon borderColor fillColor: aScenePolygon fillColor.   "Get camera depth"   cameraDepth := self camera depth.   aScenePolygon       verticesDo: [ :x :y :z |          | cameraXYZ canvasXZ |         cameraXYZ := self transformPointIntoCameraFrame: { x. y. z. }.         canvasXZ := self projectScenePoint: cameraXYZ cameraDepth: cameraDepth.         transformedPolygon addVertex: canvasXZ.         ].   ^transformedPolygon.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; projectScenePoint:cameraDepth:</h3><pre>projectScenePoint: aViewPoint cameraDepth: aCameraDepth   "Translate from camera view coordinates (meters) to canvas coordinates (px)"   | aCanvasPoint  sceneX sceneY sceneZ screenX screenY x y xOffset yOffset dxdy dzdy |   self assert: (aViewPoint isKindOf: Array ).   self assert: (aViewPoint size = 3).   "Map East-West to x; North-South to y; Up-Down to z, Time to w."   sceneX := aViewPoint at: 1.   sceneY := aViewPoint at: 2.   sceneZ := aViewPoint at: 3.      dxdy := (sceneX / sceneY) quantity.  "East over North"   dzdy := (sceneZ / sceneY) quantity.      screenX :=  aCameraDepth * dxdy.   screenY :=  aCameraDepth * dzdy.      x := (screenX * (self scalePixelsPerMillimeter)) quantity rounded.   y := (screenY * (self scalePixelsPerMillimeter)) quantity rounded.      xOffset := self canvas formCanvas extent x // 2.   yOffset := self canvas formCanvas extent y // 2.   aCanvasPoint := ( xOffset + x )@(yOffset - y). "flip y"   ^aCanvasPoint.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; projectionMode</h3><pre>projectionMode   "Map the scene polygons onto the viewport using orthogonal or perspective projection?"   ^ projectionMode ifNil: [ projectionMode := #perspective ]</pre><h3>Hum-UI -- HumViewPort &gt;&gt; projectionMode:</h3><pre>projectionMode: aSymbol    self assert: (#( #orthographic #perspective ) includes: aSymbol ).   projectionMode := aSymbol.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; renderScene</h3><pre>renderScene   "Render solids in my scene as polygons projected onto my canvas."   ^self renderSceneAsTriangles.   </pre><h3>Hum-UI -- HumViewPort &gt;&gt; renderSceneAsTriangles</h3><pre>renderSceneAsTriangles      "Render solids in my scene as polygons projected onto my canvas."   |  triangles aCanvas |   "Solid faces are 3D polygons. Project to 2D viewport canvas."   triangles := self mapTrianglesFrom3Dto2D.   (triangles size &lt; 1) ifTrue: [ Error signal: 'Nothing to see?' ].   aCanvas := self canvas.   triangles      do: [ :polygon |         self paintHumPolygon: polygon.          ].   self repaint: [ self renderSceneAsTriangles ].   'TODO: Find algorithm that maps 3D triangle (tesselation) to pixels   while tracking depth (distance from camera) of 3D point   so that near point pixels will overlap far point pixels'.   </pre><h3>Hum-UI -- HumViewPort &gt;&gt; renderSceneAsWireFrame</h3><pre>renderSceneAsWireFrame   "Render solids in my scene as polygons projected onto my canvas."   | flatPolygons aCanvas |   "Solid faces are 3D polygons. Project to 2D viewport canvas."   flatPolygons := self mapPolygonsFrom3Dto2D.   aCanvas := self canvas.   flatPolygons      do: [ :polygon |         aCanvas drawHumPolygon: polygon.          ].   self repaint: [ self renderSceneAsWireFrame ].      </pre><h3>Hum-UI -- HumViewPort &gt;&gt; repaint</h3><pre>repaint   "Repaint using stored block."   self assert: (repaintBlock notNil).   self assert: (repaintBlock isKindOf: BlockClosure ).   self canvas fillBackground.   repaintBlock value.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; repaint:</h3><pre>repaint: aBlock   "Which method to use when repainting?"   repaintBlock := aBlock.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; scalePixelsPerMillimeter</h3><pre>scalePixelsPerMillimeter   ^pixelsPerMillimeter ifNil: [ pixelsPerMillimeter := (5 px) / (1 millimeter) ].</pre><h3>Hum-UI -- HumViewPort &gt;&gt; scalePoint:scaleRatio:</h3><pre>scalePoint: aScenePoint scaleRatio: pxPerMeter    "Return a x@y point by scaling the given scene point"   | sceneX sceneY canvasX canvasY |   ((aScenePoint isKindOf: Array) or: [aScenePoint isKindOf: OrderedCollection])      ifFalse: [ Error signal: 'Scene Point is not of expected type' ].   sceneX := aScenePoint at: 1.   sceneY := aScenePoint at: 2.   ( sceneX isPixels )       ifTrue: [ "Already scaled."         canvasX := sceneX quantity rounded.          canvasY := sceneY quantity rounded.          ]       ifFalse: [ "Apply scale factor"         canvasX := ( sceneX * pxPerMeter ) quantity rounded.          canvasY := ( sceneY * pxPerMeter ) quantity rounded.         ].         ^ canvasX @ canvasY.      </pre><h3>Hum-UI -- HumViewPort &gt;&gt; scene:</h3><pre>scene: aScene    self assert: (aScene isKindOf:  HumScene ).   scene := aScene.   scene addDependent: self.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; selectSolidsInFrontOfCamera</h3><pre>selectSolidsInFrontOfCamera   "Return collection of solids whose centers are in front of camera."   | cameraSolids sceneSolids |      cameraSolids := OrderedCollection new.  "solids with points transformed to camera coordinates"    "Explode each assembly to get constituent solids."   sceneSolids := ((scene exploded) reject: [ :part | part isKindOf: HumCamera]).   ( sceneSolids )       do: [ :solid |         | centerInSceneFrame centerInCameraFrame |         centerInSceneFrame := solid center.         centerInCameraFrame := self transformPointIntoCameraFrame:  centerInSceneFrame.         ((centerInCameraFrame y) quantity &gt; 0.0 )             ifTrue: [ cameraSolids add: solid. ].          ].   ^cameraSolids.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; transformPointIntoCameraFrame:</h3><pre>transformPointIntoCameraFrame: aPoint3D    "Transform the point into the camera`s coordinate system."   | sceneX sceneY sceneZ    cameraX cameraY cameraZ    translatedX translatedY translatedZ     rotatedX rotatedY rotatedZ     vectorDistance alpha beta  calc |   calc := HumCalculator new.   calc cases;      when: [ aPoint3D isKindOf: Array ]         then: [             sceneX := aPoint3D at: 1.  "offset East"            sceneY := aPoint3D at: 2.  "offset North"            sceneZ := aPoint3D at: 3.  "offset Up" ];      when: [ aPoint3D isKindOf: HumVector ]         then: [             sceneX := aPoint3D x.            sceneY := aPoint3D y.            sceneZ := aPoint3D z.                      ];      otherwise: [ Error signal: 'aPoint3D not of expected type' ].      "Translate"   translatedX := sceneX - (camera eyeX).   translatedY := sceneY - (camera eyeY).   translatedZ := sceneZ - (camera eyeZ).   "Rotate"   vectorDistance := ((translatedX*translatedX) + (translatedY*translatedY) "+ (translatedZ*translatedZ)") sqrt.   alpha := (translatedX quantity/ vectorDistance quantity) arcCos.  "rise over run"   beta := alpha - (camera rotation).   rotatedX := vectorDistance * (beta cos).   rotatedY := vectorDistance * (beta sin).   rotatedZ := translatedZ.      "Tilt"   vectorDistance := ("(translatedX*translatedX) +" (rotatedY*rotatedY) + (rotatedZ*rotatedZ)) sqrt.   alpha := (rotatedZ quantity /  vectorDistance quantity) arcSin. "rise over run"   beta := alpha - (camera tilt).   cameraX := rotatedX.   cameraY := vectorDistance * (beta cos).   cameraZ := vectorDistance * (beta sin).   ^HumVector newFrom: { cameraX. cameraY. cameraZ. }.   </pre><h3>Hum-UI -- HumViewPort &gt;&gt; transformPolygonToCameraFrame:</h3><pre>transformPolygonToCameraFrame: aScenePolygon    "Return a new polygon with the points transformed into camera`s coordinate system."   | transformedPolygon cameraDepth |   "Initialize polygon colors"   transformedPolygon := HumPolygon parentSolid: aScenePolygon parentSolid fillColor: aScenePolygon fillColor.   "Get camera depth"   cameraDepth := self camera depth.   aScenePolygon       verticesDo: [ :x :y :z |          | cameraXYZ  |         cameraXYZ := self transformPointIntoCameraFrame: { x. y. z. }.         transformedPolygon addVertex: cameraXYZ.         ].   ^transformedPolygon.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; update:</h3><pre>update: anObject    "Something in my model has been changed."   self assert: (anObject == scene).   "Transcript cr; show: 'Scene changed.'."   self repaint.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; zmapPolygonsFrom3Dto2D</h3><pre>zmapPolygonsFrom3Dto2D   "Each solid in the scene provides a collection of polygons with points in 3D scene coordinates.    Those polygons are translated into new polygons with points in 2D viewport coordinates."   |   cameraSolids viewportPolygons cameraDepth transformToCanvas2D  |   cameraSolids := self selectSolidsInFrontOfCamera.   viewportPolygons := OrderedCollection new. "Collect resulting 2D polygons"   "Define the function we use to may from 3D to camera pixel point."   cameraDepth := self camera depth.   transformToCanvas2D := [ :x :y :z | self projectScenePoint: { x. y. z. } cameraDepth: cameraDepth ].   "Paint distant objects before those that are near."   ( cameraSolids sorted: [ :aSolid :bSolid | aSolid rSquared &lt; bSolid rSquared ] ) "Use R-squared to avoid taking square root."      do: [ :cameraSolid |         | cameraPolygons culledPolygons |         cameraPolygons := cameraSolid polygons. "These HumPolygons were computed above."         culledPolygons := (cameraPolygons select: [ :polygon |  polygon inFrontOfCamera  ] ).         (culledPolygons sort: [ :a :b | a northMostPoint  &gt;  b northMostPoint ])            do: [ :culledPolygon |               | viewportPolygon |               viewportPolygon := HumPolygon copy: culledPolygon withTransform: transformToCanvas2D.               viewportPolygons add: viewportPolygon.                ].          ].   ^viewportPolygons.</pre><h3>Hum-UI -- HumViewPort &gt;&gt; zrenderScene</h3><pre>zrenderScene   "Render solids in my scene as polygons projected onto my canvas."   | flatPolygons aCanvas |   "Solid faces are 3D polygons. Project to 2D viewport canvas."   flatPolygons := self mapPolygonsFrom3Dto2D.   aCanvas := self canvas.   flatPolygons      do: [ :polygon |         self paintHumPolygon: polygon.          ].   self repaint: [ self renderScene ].   </pre><h3>Hum-UI -- HumView &gt;&gt; asWidget</h3><pre>asWidget   "Initialize a HumFormWidget for this view"   ^formWidget ifNil: [ formWidget := HumFormWidget onView: self]</pre><h3>Hum-UI -- HumView &gt;&gt; blackboard</h3><pre>blackboard   ^ blackboard ifNil: [ Error signal: 'No blackboard has been assigned to this view.'].</pre><h3>Hum-UI -- HumView &gt;&gt; blackboard:</h3><pre>blackboard: aHumBlackBoard   self assert: ( aHumBlackBoard isKindOf: HumBlackBoard ).   blackboard := aHumBlackBoard.</pre><h3>Hum-UI -- HumView &gt;&gt; calc</h3><pre>calc   "Create a calculator to be shared . . ."   ^ calc ifNil: [ calc := HumCalculator new ].</pre><h3>Hum-UI -- HumView &gt;&gt; entityName</h3><pre>entityName   "get"   ^entityName ifNil: [Error signal: 'No entity name has been set for this view.']</pre><h3>Hum-UI -- HumView &gt;&gt; entityName:</h3><pre>entityName: aString   "Set"   entityName := aString.</pre><h3>Hum-UI -- HumView &gt;&gt; interpretEmphasisIn:on:</h3><pre>interpretEmphasisIn: aString on: aWAHtmlCanvas    "TODO: THIS IS A STUB - Expect aString contains Hum Markup."   "See: HumMarkupLine &gt;&gt;generateCodeOfType: aSymbol fromTokens: tokens at: xToken"   "See: HumOntologyViewer &gt;&gt;renderMarkupAsHTML5: markupSource"   "See: HumOntologyViewer &gt;&gt;renderMarkupEmphasisAsHTML5: aString "   "TODO: REFACTOR."   "TODO: Markup rendering seems to be missing tests."   aWAHtmlCanvas text: aString.</pre><h3>Hum-UI -- HumView &gt;&gt; ontology:</h3><pre>ontology: aHumOntology    ontology := aHumOntology. </pre><h3>Hum-UI -- HumView &gt;&gt; renderFrameLine:viaSeasideCanvas:</h3><pre>renderFrameLine: aHumMarkupLine viaSeasideCanvas: aWAHtmlCanvas    | html heading marker remainder level aString markupSource entity |   Error signal: 'The code in this method is internally inconsistent.'.   markupSource := aHumMarkupLine source.   aWAHtmlCanvas break.   self calc.   "Maintain spacing."   aString := calc given: markupSource replaceAll: '  ' with: '&nbsp;&nbsp;'.      "Is this markup line a heading?"   heading := 'none'.   (1 to: 5)      do: [ :i |         marker := '!!!!!' copyFrom: 1 to: i.         ( aString beginsWith: marker )             ifTrue: [ "Set the heading type and extract the remainder."               heading := 'h', (marker size) asString.                remainder := (calc given: aString extractAfter: marker ) ].          ].   "If this is a heading, render the whole line as a heading. "      "Call self recursively to catch any additional emphasis (e.g. italics)"   ( heading = 'none'   ) ifFalse: [ aWAHtmlCanvas heading level: (heading size); with: remainder. ^self ].   "Is this markup line a bullet/numbered list item."      #( '-----' '#####') "If so, compute the indent level."      do: [ :leaderType |            level := 0.      (1 to: 5 )         do: [ :i |            marker := leaderType copyFrom: 1 to: i.            ( aString beginsWith: marker )                ifTrue: [ "Set the heading type and extract the remainder."                  level := (marker size).                   remainder := (calc given: aString extractAfter: marker ) ].             ].      ( level &gt; 0 )         ifTrue: [            html := ''.            ( (lastLevel isNil ) or: [ level &gt; lastLevel ] )                ifTrue:[                   (marker beginsWith: '-') ifTrue: [ self modeStack push: 'ul'].                  (marker beginsWith: '#') ifTrue: [ self modeStack push: 'ol'].                  html := '&lt;',(self modeStack top),'&gt;'.                  ].            "TODO: Figure out how to emit '&lt;/ul&gt;' and '&lt;/ol&gt;.' -- Might need MODES. (heavens)"            ( (lastLevel notNil ) and: [ level &lt; lastLevel ] )                ifTrue:[                   html := '&lt;/',(self modeStack top),'&gt;'.                   ].            lastLevel := level.            html := html, (calc xml: 'li'                                  with: [                                     [ remainder &gt; '' ]                                        whileTrue: [ remainder := self renderUpToNextWidget: remainder on: aWAHtmlCanvas ]                                         ]                                    ).            ^html.               ].         ].      "TODO: AT THIS POINT - OUTPUT UP TO NEXT MARK-UP"   remainder := self renderUpToNextWidget: aString on: aWAHtmlCanvas.   aString := remainder.   ['*[*]*' match: aString]      whileTrue: [ "Interpret by calling a HumWidget"         | between widget |         between := calc given: aString extractBetween: '[' and: ']'.         remainder := calc given: aString extractAfter: ']'.         entity := (self entityName).         ((between at: (between size)) isDigit)            ifTrue: ["Update text"               | attributeName rows |               attributeName := calc given: between extractUpto: ' '.               rows := calc given: between extractAfter: ' '.               widget := HumTextWidget onEntity: entity attribute: between blackboard: blackboard.               widget rows: (rows asNumber).               ]            ifFalse: ["Update . . ."               | supertypes |               "Default type is a simple string"               widget := HumStringWidget onEntity: entity attribute: between blackboard: blackboard.               "Check for special types"               supertypes := ontology allSupertypesOf: between.               (supertypes include: 'date')                     ifTrue: [ widget := HumDateWidget onEntity: entity attribute: between blackboard: blackboard ].               (supertypes include: 'measure')                     ifTrue: [ widget := HumMeasureWidget onEntity: entity attribute: between blackboard: blackboard ].               (supertypes include: 'collection')                     ifTrue: [ widget := HumCollectionWidget onEntity: entity attribute: between blackboard: blackboard ].               (supertypes include: 'category')                     ifTrue: [widget := HumCategoryWidget onEntity: entity attribute: between blackboard: blackboard.                        widget categories: (ontology categoriesOf: between).                        ].               ].         remainder := self renderUpToNextWidget: aString on: aWAHtmlCanvas.            widget renderContentOn: aWAHtmlCanvas.         aString := remainder.         ].    </pre><h3>Hum-UI -- HumView &gt;&gt; renderMarkupLinesViaSeasideOn:</h3><pre>renderMarkupLinesViaSeasideOn: aWAHtmlCanvas    "Render the ontology view frame lines via Seaside"   | |   "self assert: ( aWAHtmlCanvas isKindOf: WAHtmlCanvas )."   Error signal: 'This code has not been tested.'.   (self view) frameLines      do: [:frameLine | self renderFrameLine: frameLine viaSeasideCanvas: aWAHtmlCanvas.].</pre><h3>Hum-UI -- HumView &gt;&gt; renderUpToNextWidget:on:</h3><pre>renderUpToNextWidget: aMarkupString on: html   "Render mark-up that does not involve heading/list/widget"   | wip remainder |      "Precondition: Caller has already handled and removed markup for header or list."   #( '!' '-' '#' ) do: [:mark | self assert: (aMarkupString beginsWith: mark) not ].      "Break up the line. We will only render non-widget stuff."   self calc.   wip := calc given: aMarkupString extractUpto: '['.   remainder := calc given: aMarkupString extractAfter: wip.      "TODO: Interpret emphasis -- if any"   self interpretEmphasisIn: wip on: html.      ^remainder. "TODO: Should this method call itself recursively -- or leave that loop to the caller?"</pre><h3>Hum-UI -- HumView &gt;&gt; view</h3><pre>view   ^ viewFrame ifNil: [Error signal: (self class asString),' not initialized']</pre><h3>Hum-UI -- HumView &gt;&gt; view:</h3><pre>view: aViewNameString    "Fetch the view frame of that name."   viewFrame :=  ontology fetchFrameByName: ('View: ',aViewNameString,'.').   self entityName: aViewNameString.   self id: aViewNameString.   </pre><h3>Hum-UI -- HumWidget &gt;&gt; about</h3><pre>about" The traditional idea of a widget is that it is a component in a view. (MVC concept)But in a 3D virtual-reality context, the widget concept must be extended.""Q: What is the relation between Sensor, Scribe, Widget, Canvas, Solid, ViewPort.A: The Scribe interprets inputs from the Sensor and updates a Widget.The Widget is drawn on a Canvas which is painted on a Surface.A Surface might be painted on a Solid within a Scene.Note: A Surface is not rendered if it is not visible to the Viewport`s Camera. The flow is Sensor &gt;&gt; Scribe &gt;&gt; Widget &gt;&gt; Canvas &gt;&gt; Surface &gt;&gt; ViewPort (Camera).""Q: What is the relationship between Sensor, Scribe, Widget, Blackboard, Dialog?A: The Scribe interprets Sensor inputs and updates both the view and the Dialog.The update of a Dialog might wait until form data is submitted."" Note: An Avatar may be a kind of widget. It is in the 3D view and may interact with the user."" A Scene is mostly decoration, but it may also trigger interaction via proximity triggers.That means that a proximity trigger may be a kind of widget.Examples:U: User-Avatar enters the conference room.U: User-Avatar is facing the receptionist."</pre><h3>Hum-UI -- HumWidget &gt;&gt; asGlamorBrick</h3><pre>asGlamorBrick   "Render widget and data as Glamor Brick object"   self subclassResponsibility.</pre><h3>Hum-UI -- HumWidget &gt;&gt; asHTML</h3><pre>asHTML   "Render widget and data as HTML code"   self subclassResponsibility.</pre><h3>Hum-UI -- HumWidget &gt;&gt; asJSF</h3><pre>asJSF   "Render widget and data as Jave Server Face code"   self subclassResponsibility.</pre><h3>Hum-UI -- HumWidget &gt;&gt; asMagritteMorph</h3><pre>asMagritteMorph   "Render widget and data as Magritte Morph object"   self subclassResponsibility.</pre><h3>Hum-UI -- HumWidget &gt;&gt; asMorph</h3><pre>asMorph   "Render widget and data as Morph object     - See: MorphicModel hierarchy"   self subclassResponsibility.</pre><h3>Hum-UI -- HumWidget &gt;&gt; asXUL</h3><pre>asXUL   "Render widget and data as XUL code"   self subclassResponsibility.</pre><h3>Hum-UI -- HumWidget &gt;&gt; attributeName</h3><pre>attributeName   ^attributeName</pre><h3>Hum-UI -- HumWidget &gt;&gt; attributeName:</h3><pre>attributeName: aString   "name of attribute"   attributeName := aString.</pre><h3>Hum-UI -- HumWidget &gt;&gt; attributeValue</h3><pre>attributeValue   ^ attributeValue ifNil: [ '' ].</pre><h3>Hum-UI -- HumWidget &gt;&gt; attributeValue:</h3><pre>attributeValue: aString   "Set current value of attribute -- in display/input format."   "See &gt;&gt;store: -- which sets the value and also notifies the blackboard."   attributeValue := aString.</pre><h3>Hum-UI -- HumWidget &gt;&gt; blackboard:</h3><pre>blackboard: aHumBlackBoard    blackboard := aHumBlackBoard. </pre><h3>Hum-UI -- HumWidget &gt;&gt; canvas</h3><pre>canvas   "Canvas on which to draw the widget - "   ^canvas ifNil: [ canvas := HumCanvas new. ].   "Q: What is the relation between Sensor, Scribe, Widget, Canvas, Solid, ViewPort.A: The Scribe interprets inputs from the Sensor and updates a Widget.The Widget is drawn on a Canvas which is painted on a Surface.A Surface might be painted on a Solid within a Scene.Note: A Surface is not rendered if it is not visible to the Viewport`s Camera. The flow is Sensor &gt;&gt; Scribe &gt;&gt; Widget &gt;&gt; Canvas &gt;&gt; Surface &gt;&gt; ViewPort (Camera)."</pre><h3>Hum-UI -- HumWidget &gt;&gt; canvas:</h3><pre>canvas: aHumCanvas    "Canvas on which to draw the widget - "   self assert: (aHumCanvas isKindOf: HumCanvas).   canvas := aHumCanvas.</pre><h3>Hum-UI -- HumWidget &gt;&gt; entityName:</h3><pre>entityName: aString    entityName := aString.</pre><h3>Hum-UI -- HumWidget &gt;&gt; formCanvas</h3><pre>formCanvas   ^self canvas formCanvas.</pre><h3>Hum-UI -- HumWidget &gt;&gt; renderContentOn:</h3><pre>renderContentOn: aWAHtmlCanvas   "Default: Render self via a simple input tag"   | |   aWAHtmlCanvas textInput       attributeAt: 'id' put: (self attributeName );      callback: [:value | self store: value ];      with: (self attributeValue asString).</pre><h3>Hum-UI -- HumWidget &gt;&gt; store:</h3><pre>store: anObject    "Set my attribute value and store it on my blackboard."   "TODO: Perhaps this should be #update: method to correspond with other UI controller conventions."     self attributeValue: anObject.   "Note: The blackboard might send the value to it`s world-base, if it has a world-base."   blackboard setEntityName: entityName attribute: attributeName toValue: anObject.</pre><h3>Hum-X -- H3dCamera &gt;&gt; depth</h3><pre>depth   "Distance from eye point to viewport rectangle."   ^ depth</pre><h3>Hum-X -- H3dCamera &gt;&gt; depth:</h3><pre>depth: aHumMeasure    "Distance from eye point to viewport rectangle."   depth := aHumMeasure.   length := depth. "Enable showing me as a box."</pre><h3>Hum-X -- H3dCamera &gt;&gt; projectScenePointToScreenPoint:</h3><pre>projectScenePointToScreenPoint: aScenePoint   "Map a scene point onto a screen point ( x y z ) ==&gt; ( x' y' z').   Return nil if the point cannot be mapped."   | screenPoint diff rotated dzdy dxdy x y z |   self assert: ( aScenePoint isKindOf: HumVector ).   diff := (aScenePoint - (self center)).    rotated := ((diff pitch: (self pitch negated)) roll: (self roll negated)) yaw: (self yaw negated).   "Filter points that are behind the screen."   y := rotated y. "North"   ( y &lt; depth ) ifTrue: [ ^nil ].   x := rotated x. "East"   z := rotated z. "Up"   "Get the rise over run (tangent of angle)."   dzdy := z / y.   dxdy := x / y.   "Filter points that are not visible."   ( dzdy &gt; ( height * 0.5 / depth)) ifTrue: [ ^nil ].   ( dzdy &lt; ( height * 0.5 / depth) negated ) ifTrue: [ ^nil ].   ( dxdy &gt; ( width * 0.5 / depth) ) ifTrue: [ ^nil ].   ( dxdy &lt; ( width * 0.5 / depth) negated ) ifTrue: [ ^nil ].   "Calculate the offset in meters."   screenPoint := HumVector newFrom: { dxdy * depth.  ( y ). dzdy * depth. }.   "Original y is kept so that we can render overlaping points correctly. "   ^screenPoint.</pre><h3>Hum-X -- H3dCamera &gt;&gt; scene:</h3><pre>scene: aScene   "Scene (or layer) the camera is viewing."   self assert: ( aScene isKindOf: H3dObject ).   scene := aScene.</pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test110buildBox</h3><pre>test110buildBox   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   "Check that dimension were stored."   self expect: ( 05.0 meter ) actual: ( box maxX ).      self expect: ( 10.0 meter ) actual: ( box maxY ).      self expect: ( 15.0 meter ) actual: ( box maxZ ).      "Volume"   self expect: (HumMeasure quantity: (10*20*30) units: 'cubic meter') actual: (box volume).   "Polygons ==&gt; cube faces in this case"   self expect: 6 actual: (box polygons size).</pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test120yawBox90degrees</h3><pre>test120yawBox90degrees   "90 degree yaw exchanges X and Y"   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: ( 05.0 meter ) actual: ( box maxX ).      self expect: ( 10.0 meter ) actual: ( box maxY ).      self expect: ( 15.0 meter ) actual: ( box maxZ ).      box yaw: ((Float pi)/ 2.0) radian.   self expect: ( 10.0 meter ) actual: ( box maxX ).      self expect: ( 05.0 meter ) actual: ( box maxY ).      self expect: ( 15.0 meter ) actual: ( box maxZ ).      </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test122yawBox90degreesAroundPivot</h3><pre>test122yawBox90degreesAroundPivot   "90 degree yaw exchanges X and Y"   | box |   box := H3dObject newBoxWidth: (10 meter) length: (22 meter) height: (30 meter).   box pivotPoint: ( HumVector newFrom: { 0.0. 0.0. 0.0 } ).   self expect: ( 05.0 meter ) actual: ( box maxX ).      self expect: ( 11.0 meter ) actual: ( box maxY ).      self expect: ( 15.0 meter ) actual: ( box maxZ ).      box yaw: ((Float pi)/ 2.0) radian.   self expect: ( 11.0 meter ) actual: ( box maxX ).      self expect: ( 05.0 meter ) actual: ( box maxY ).      self expect: ( 15.0 meter ) actual: ( box maxZ ).      box pivotPoint: ( HumVector newFrom: { box east. 0.0 meter. 0.0 meter. } ).   self expect: ( 16.0 meter ) actual: ( box maxX ).   "5 + 11 = 16"   self expect: (-06.0 meter ) actual: ( box minX ).   "5 - 11 = -6"   self expect: ( 00.0 meter ) actual: ( box maxY ).      self expect: (-10.0 meter) actual: (box minY).       "0 - 10 = -10"   self expect: ( 15.0 meter ) actual: ( box maxZ ).      self expect: (-15.0 meter ) actual: ( box minZ ).      </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test125yawBox180degrees</h3><pre>test125yawBox180degrees   "180 degree rotations should leave bounds the same."   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: ( 05.0 meter ) actual: ( box maxX ).      self expect: ( 10.0 meter ) actual: ( box maxY ).      self expect: ( 15.0 meter ) actual: ( box maxZ ).      box yaw: ((Float pi)) radian.   self expect: ( 05.0 meter ) actual: ( box maxX ).      self expect: ( 10.0 meter ) actual: ( box maxY ).      self expect: ( 15.0 meter ) actual: ( box maxZ ).      </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test130pitchBox90degrees</h3><pre>test130pitchBox90degrees   "90 degree pitch exchanges Y and Z"   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: ( 05.0 meter ) actual: ( box maxX ).      self expect: ( 10.0 meter ) actual: ( box maxY ).      self expect: ( 15.0 meter ) actual: ( box maxZ ).      box pitch: ((Float pi)/ 2.0) radian.   self expect: ( 05.0 meter ) actual: ( box maxX ).      self expect: ( 15.0 meter ) actual: ( box maxY ).      self expect: ( 10.0 meter ) actual: ( box maxZ ).      </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test132pitchBox90degreesAboutPivot</h3><pre>test132pitchBox90degreesAboutPivot   "90 degree pitch exchanges Y and Z"   | box |   box := H3dObject newBoxWidth: (10 meter) length: (22 meter) height: (30 meter).   self expect: ( 05.0 meter ) actual: ( box maxX ).      self expect: ( 11.0 meter ) actual: ( box maxY ).      self expect: ( 15.0 meter ) actual: ( box maxZ ).      box pitch: ((Float pi)/ 2.0) radian.   self expect: ( 05.0 meter ) actual: ( box maxX ).      self expect: ( 15.0 meter ) actual: ( box maxY ).      self expect: ( 11.0 meter ) actual: ( box maxZ ).      box pivotPoint: (HumVector newFrom: { 0.0 meter. box north. 0.0 meter. } ).   self expect: ( 05.0 meter ) actual: ( box maxX ).      self expect: ( -5.0 meter ) actual: ( box minX ).      self expect: ( 26.0 meter ) actual: ( box maxY ).   "11 + 15 = 26"   self expect: ( -4.0 meter ) actual: ( box minY ).   "11 - 15 = -4"   self expect: ( 00.0 meter ) actual: ( box maxZ ).      self expect: ( -22.0 meter ) actual: ( box minZ ).   </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test135pitchBox180degrees</h3><pre>test135pitchBox180degrees   "180 degree rotations should leave bounds the same."   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: ( 05.0 meter ) actual: ( box maxX ).      self expect: ( 10.0 meter ) actual: ( box maxY ).      self expect: ( 15.0 meter ) actual: ( box maxZ ).      box pitch: ((Float pi)) radian.   self expect: ( 05.0 meter ) actual: ( box maxX ).      self expect: ( 10.0 meter ) actual: ( box maxY ).      self expect: ( 15.0 meter ) actual: ( box maxZ ).      </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test140rollBox90degrees</h3><pre>test140rollBox90degrees   "90 degree roll exchanges X and Z"   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: ( 05.0 meter ) actual: ( box maxX ).      self expect: ( 10.0 meter ) actual: ( box maxY ).      self expect: ( 15.0 meter ) actual: ( box maxZ ).      box roll: ((Float pi)/ 2.0) radian.   self expect: ( 15.0 meter ) actual: ( box maxX ).      self expect: ( 10.0 meter ) actual: ( box maxY ).      self expect: ( 05.0 meter ) actual: ( box maxZ ).      </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test142rollBox90degreesAboutPivot</h3><pre>test142rollBox90degreesAboutPivot   "90 degree roll exchanges X and Z"   | box |   box := H3dObject newBoxWidth: (12 meter) length: (22 meter) height: (30 meter).   self expect: ( 06.0 meter ) actual: ( box maxX ).      self expect: ( 11.0 meter ) actual: ( box maxY ).      self expect: ( 15.0 meter ) actual: ( box maxZ ).      box roll: ((Float pi)/ 2.0) radian.   self expect: ( 15.0 meter ) actual: ( box maxX ).      self expect: ( 11.0 meter ) actual: ( box maxY ).      self expect: ( 06.0 meter ) actual: ( box maxZ ).      box pivotPoint: ( HumVector newFrom: { box west. 0.0 meter. 0.0 meter. } ).   self expect: ( 09.0 meter ) actual: ( box maxX ).   "15 - 6 = 9"   self expect: ( 11.0 meter ) actual: ( box maxY ).      self expect: ( 12.0 meter ) actual: ( box maxZ ).      </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test143rollBox90degreesAboutPivot</h3><pre>test143rollBox90degreesAboutPivot   "90 degree roll exchanges X and Z"   | box |   box := H3dObject newBoxWidth: (12 meter) length: (22 meter) height: (30 meter).   self expect: ( 06.0 meter ) actual: ( box maxX ).      self expect: ( 11.0 meter ) actual: ( box maxY ).      self expect: ( 15.0 meter ) actual: ( box maxZ ).      box roll: ((Float pi)/ 2.0) radian.   self expect: ( 15.0 meter ) actual: ( box maxX ).      self expect: ( 11.0 meter ) actual: ( box maxY ).      self expect: ( 06.0 meter ) actual: ( box maxZ ).      box pivotPoint: ( HumVector newFrom: { 1.0 meter. 0.0 meter. 2.0 meter. } ).   self expect: ( 18.0 meter ) actual: ( box maxX ).   "0+1+(15+2) = 18"   self expect: ( 11.0 meter ) actual: ( box maxY ).   "STS"   self expect: ( 07.0 meter ) actual: ( box maxZ ).   "0+1+(6+1)"   </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test145rollBox180degrees</h3><pre>test145rollBox180degrees   "180 degree rotations should leave bounds the same."   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: ( 05.0 meter ) actual: ( box maxX ).      self expect: ( 10.0 meter ) actual: ( box maxY ).      self expect: ( 15.0 meter ) actual: ( box maxZ ).      box roll: ((Float pi)) radian.   self expect: ( 05.0 meter ) actual: ( box maxX ).      self expect: ( 10.0 meter ) actual: ( box maxY ).      self expect: ( 15.0 meter ) actual: ( box maxZ ).      </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test150yawPitchRollBox</h3><pre>test150yawPitchRollBox   "180 degree rotations should leave it looking the same."   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: ( 05.0 meter ) actual: ( box maxX ).      self expect: ( 10.0 meter ) actual: ( box maxY ).      self expect: ( 15.0 meter ) actual: ( box maxZ ).      box yaw: ((Float pi)) radian.   box pitch: ((Float pi)) radian.   box roll: ((Float pi)) radian.   self expect: ( 05.0 meter ) actual: ( box maxX ).      self expect: ( 10.0 meter ) actual: ( box maxY ).      self expect: ( 15.0 meter ) actual: ( box maxZ ).      </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test220moveBoxEast</h3><pre>test220moveBoxEast   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   box east: 40 meters.   self expect: (40 meter) actual: (box east).   self expect: (35 meter) actual: (box center x).   self expect: 40 meter actual: (box maxX).</pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test225moveBoxWest</h3><pre>test225moveBoxWest   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: ( -5.0 meter) actual: (box west).   box west: 40 meters.   self expect: (40 meter) actual: (box west).   self expect: (45 meter) actual: (box center x).   self expect: 40 meter actual: (box minX).</pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test230moveBoxNorth</h3><pre>test230moveBoxNorth   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: (10 meter) actual: (box maxY).   box north: 40 meters.   self expect: (40 meter) actual: (box north).   self expect: (30 meter) actual: (box center y).   self expect: (40 meter) actual: (box maxY).</pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test235moveBoxSouth</h3><pre>test235moveBoxSouth   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: (-10 meter) actual: (box south).   box south: 40 meters.   self expect: (40 meter) actual: (box south).   self expect: (50 meter) actual: (box center y).   self expect: (40 meter) actual: (box minY).</pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test240moveBoxTop</h3><pre>test240moveBoxTop   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: (15 meter) actual: (box maxZ).   box top: 40 meters.   self expect: (40 meter) actual: (box top).   self expect: (25 meter) actual: (box center z).   self expect: (40 meter) actual: (box maxZ).</pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test245moveBoxBottom</h3><pre>test245moveBoxBottom   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: (-15 meter) actual: (box bottom).   box bottom: 40 meters.   self expect: (40 meter) actual: (box bottom).   self expect: (55 meter) actual: (box center z).   self expect: (40 meter) actual: (box minZ).</pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test310stepVelocity</h3><pre>test310stepVelocity   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   box velocity: (HumVector newFrom: {1 mps. 2 mps. 3 mps.} ).   self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).   box step: (HumMeasure seconds: 1).   self expect: ( HumVector newFrom: {1 meter. 2 meter. 3 meter} ) actual: (box center).   </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test320stepYawRate</h3><pre>test320stepYawRate   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: (05 meter) actual: (box east).   self expect: (10 meter) actual: (box north).   self expect: (15 meter) actual: (box top).   box yawRate: (0.25 rps).   self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).   box step: (HumMeasure seconds: 1).   self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).   "Expect X and Y bounds to exchange."   self expect: (10 meter) actual: (box maxX).   self expect: (05 meter) actual: (box maxY).   self expect: (15 meter) actual: (box maxZ).   </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test325stepVelocityAndYawRate</h3><pre>test325stepVelocityAndYawRate   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: (05 meter) actual: (box east).   self expect: (10 meter) actual: (box north).   self expect: (15 meter) actual: (box top).   self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).   self expect: (05 meter) actual: (box maxX).   self expect: (10 meter) actual: (box maxY).   self expect: (15 meter) actual: (box maxZ).   box yawRate: (0.25 rps).   box velocity: ( HumVector newFrom: { 100 mps. 100 mps. 100 mps.} ).   box step: (HumMeasure seconds: 1).   self expect: ( HumVector newFrom: {100 meter. 100 meter. 100 meter} ) actual: (box center).   "Expect X and Y bounds to exchange."   self expect: (110 meter) actual: (box maxX).   self expect: (105 meter) actual: (box maxY).   self expect: (115 meter) actual: (box maxZ).   </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test330stepPitchRate</h3><pre>test330stepPitchRate   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: (05 meter) actual: (box east).   self expect: (10 meter) actual: (box north).   self expect: (15 meter) actual: (box top).   box pitchRate: (0.25 rps).   self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).   box step: (HumMeasure seconds: 1).   self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).   "Expect Y and Z bounds to exchange."   self expect: (05 meter) actual: (box maxX).   self expect: (15 meter) actual: (box maxY).   self expect: (10 meter) actual: (box maxZ).   </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test335stepVelocityAndPitchRate</h3><pre>test335stepVelocityAndPitchRate   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: (05 meter) actual: (box east).   self expect: (10 meter) actual: (box north).   self expect: (15 meter) actual: (box top).   self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).   self expect: (05 meter) actual: (box maxX).   self expect: (10 meter) actual: (box maxY).   self expect: (15 meter) actual: (box maxZ).   box pitchRate: (0.25 rps).   box velocity: ( HumVector newFrom: { 100 mps. 100 mps. 100 mps.} ).   box step: (HumMeasure seconds: 1).   self expect: ( HumVector newFrom: {100 meter. 100 meter. 100 meter} ) actual: (box center).   "Expect Y and Z bounds to exchange."   self expect: (105 meter) actual: (box maxX).   self expect: (115 meter) actual: (box maxY).   self expect: (110 meter) actual: (box maxZ).   </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test340stepRollRate</h3><pre>test340stepRollRate   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: (05 meter) actual: (box east).   self expect: (10 meter) actual: (box north).   self expect: (15 meter) actual: (box top).   box rollRate: (0.25 rps).   self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).   box step: (HumMeasure seconds: 1).   self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).   "Expect X and Z bounds to exchange."   self expect: (15 meter) actual: (box maxX).   self expect: (10 meter) actual: (box maxY).   self expect: (05 meter) actual: (box maxZ).   </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test345stepVelocityAndRollRate</h3><pre>test345stepVelocityAndRollRate   | box |   box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: (05 meter) actual: (box east).   self expect: (10 meter) actual: (box north).   self expect: (15 meter) actual: (box top).   self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).   self expect: (05 meter) actual: (box maxX).   self expect: (10 meter) actual: (box maxY).   self expect: (15 meter) actual: (box maxZ).   box rollRate: (0.25 rps).   box velocity: ( HumVector newFrom: { 100 mps. 100 mps. 100 mps.} ).   box step: (HumMeasure seconds: 1).   self expect: ( HumVector newFrom: {100 meter. 100 meter. 100 meter} ) actual: (box center).   "Expect X and Z bounds to exchange."   self expect: (115 meter) actual: (box maxX).   self expect: (110 meter) actual: (box maxY).   self expect: (105 meter) actual: (box maxZ).   </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test350stepEverything</h3><pre>test350stepEverything   | box |   box := H3dObject newBoxWidth: ( 10 meter ) length: ( 22 meter ) height: ( 30 meter ).   self expect: ( 05 meter ) actual: ( box east ).   self expect: ( 11 meter ) actual: ( box north ).   self expect: ( 15 meter ) actual: ( box top ).   self expect: (  HumVector newFrom: {0 meter. 0 meter. 0 meter}  ) actual: ( box center ).   self expect: ( 05 meter ) actual: ( box maxX ).   self expect: ( 11 meter ) actual: ( box maxY ).   self expect: ( 15 meter ) actual: ( box maxZ ).   box yawRate: ( 0.5 rps ). "Rotate 180 degrees per second. -- Should leave maxX . . . the same."   box pitchRate: ( 0.5 rps ).   box rollRate: ( 0.5 rps ).   box velocity: ( HumVector newFrom: { 100 mps. 100 mps. 100 mps.} ).   box step: ( HumMeasure seconds: 1 ).   self expect: ( HumVector newFrom: {100 meter. 100 meter. 100 meter} ) actual: ( box center ).   "Expect X and Z bounds to exchange."   self expect: ( 105 meter ) actual: ( box maxX ).   self expect: ( 095 meter ) actual: ( box minX ).   self expect: ( 111 meter ) actual: ( box maxY ).   self expect: ( 089 meter ) actual: ( box minY ).   self expect: ( 115 meter ) actual: ( box maxZ ).   self expect: ( 085 meter ) actual: ( box minZ ).</pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test610buildElipsoid</h3><pre>test610buildElipsoid   | elipsoid |   elipsoid := H3dObject newElipsoidWidth: (10 meter) length: (20 meter) height: (30 meter).   "Check that dimensions were stored."   self expect: (HumMeasure quantity: (5*10*15*(Float pi)*4/3) units: 'cubic meter') actual: (elipsoid volume).   "The number of polygons should be the square of the numberOfWedges."   self expect: (elipsoid numberOfWedges squared) actual: (elipsoid polygons size).   "Check that the polygons are in range."   self expect: ( 05.0 meter ) actual: ( elipsoid maxX ).      self expect: ( 10.0 meter ) actual: ( elipsoid maxY ).      self expect: ( 15.0 meter ) actual: ( elipsoid maxZ ).            self expect: ( -05.0 meter ) actual: ( elipsoid minX ).      self expect: ( -10.0 meter ) actual: ( elipsoid minY ).      self expect: ( -15.0 meter ) actual: ( elipsoid minZ ).   </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test620yawElipsoid90degrees</h3><pre>test620yawElipsoid90degrees   "90 degree yaw exchanges X and Y"   | elipsoid |   elipsoid := H3dObject newElipsoidWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: ( 05.0 meter ) actual: ( elipsoid maxX ).      self expect: ( 10.0 meter ) actual: ( elipsoid maxY ).      self expect: ( 15.0 meter ) actual: ( elipsoid maxZ ).      elipsoid yaw: ((Float pi)/ 2.0) radian.   self expect: ( 10.0 meter ) actual: ( elipsoid maxX ).      self expect: ( 05.0 meter ) actual: ( elipsoid maxY ).      self expect: ( 15.0 meter ) actual: ( elipsoid maxZ ).      </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test630pitchElipsoid90degrees</h3><pre>test630pitchElipsoid90degrees   "90 degree pitch exchanges Y and Z"   | elipsoid |   elipsoid := H3dObject newElipsoidWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: ( 05.0 meter ) actual: ( elipsoid maxX ).      self expect: ( 10.0 meter ) actual: ( elipsoid maxY ).      self expect: ( 15.0 meter ) actual: ( elipsoid maxZ ).      elipsoid pitch: ((Float pi)/ 2.0) radian.   self expect: ( 05.0 meter ) actual: ( elipsoid maxX ).      self expect: ( 15.0 meter ) actual: ( elipsoid maxY ).      self expect: ( 10.0 meter ) actual: ( elipsoid maxZ ).      </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test640rollElipsoid90degrees</h3><pre>test640rollElipsoid90degrees   "90 degree roll exchanges X and Z bounds"   | elipsoid |   elipsoid := H3dObject newElipsoidWidth: (10 meter) length: (20 meter) height: (30 meter).   self expect: ( 05.0 meter ) actual: ( elipsoid maxX ).      self expect: ( 10.0 meter ) actual: ( elipsoid maxY ).      self expect: ( 15.0 meter ) actual: ( elipsoid maxZ ).      elipsoid roll: ((Float pi)/ 2.0) radian.   self expect: ( 15.0 meter ) actual: ( elipsoid maxX ).      self expect: ( 10.0 meter ) actual: ( elipsoid maxY ).      self expect: ( 05.0 meter ) actual: ( elipsoid maxZ ).      </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test710buildRotation</h3><pre>test710buildRotation   | rotation xyPoints |   xyPoints := H3dPath newFrom: { 0@0. 11@0. 11@11. 0@11. }.   rotation := H3dObject newRotationAround: #z curve: xyPoints.   rotation numberOfWedges: 4.   "Check that dimension were stored."   self expect: 12 actual: ( rotation polygons size ).   "Check expected bounds"   self expect: ( 11 meter ) actual: ( rotation maxX ).   self expect: ( 11 meter ) actual: ( rotation maxY ).   self expect: ( 11 meter ) actual: ( rotation maxZ ).      self expect: ( -11 meter ) actual: ( rotation minX ).   self expect: ( -11 meter ) actual: ( rotation minY ).   self expect: ( 0 meter ) actual: ( rotation minZ ).   </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test711buildRotationAroundX</h3><pre>test711buildRotationAroundX   | rotation xyPoints |   xyPoints := H3dPath newFrom: { 0@0. 11@0. 11@11. 0@11. }.   rotation := H3dObject newRotationAround: #x curve: xyPoints.   rotation numberOfWedges: 4.   "Check that dimension were stored."   self expect: 12 actual: ( rotation polygons size ).   "Check expected bounds"   self expect: ( 11 meter ) actual: ( rotation maxX ).   self expect: (11 meter ) actual: ( rotation maxY ).   self expect: ( 11 meter ) actual: ( rotation maxZ ).      self expect: ( 0 meter ) actual: ( rotation minX ).   self expect: ( -11 meter ) actual: ( rotation minY ).   self expect: ( -11 meter ) actual: ( rotation minZ ).   </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test712buildRotationAroundY</h3><pre>test712buildRotationAroundY   | rotation xyPoints |   xyPoints := H3dPath newFrom: { 0@0. 11@0. 11@11. 0@11. }.   rotation := H3dObject newRotationAround: #y curve: xyPoints.   rotation numberOfWedges: 4.   "Check that dimension were stored."   self expect: 12 actual: ( rotation polygons size ).   "Check expected bounds"   self expect: ( 11 meter ) actual: ( rotation maxX ).   self expect: ( 11 meter ) actual: ( rotation maxY ).   self expect: ( 11 meter ) actual: ( rotation maxZ ).      self expect: ( -11 meter ) actual: ( rotation minX ).   self expect: ( 0 meter ) actual: ( rotation minY ).   self expect: ( -11 meter ) actual: ( rotation minZ ).   </pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test810buildAssembly</h3><pre>test810buildAssembly   | boxA boxB boxC assembly |   boxA := H3dObject newBoxWidth: ( 0.10 meter ) length: ( 0.20 meter)  height: ( 0.30 meter ).   boxB := H3dObject newBoxWidth: ( 1.10 meter ) length: ( 1.20 meter ) height: ( 1.30 meter ).   boxC := H3dObject newBoxWidth: ( 2.10 meter ) length: ( 2.20 meter ) height: ( 2.30 meter ).   assembly := H3dObject newAssemblyFromParts: { boxA. boxB. boxC }.</pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test820stackBoxes</h3><pre>test820stackBoxes   | boxA boxB boxC assembly clearance totalHeight |   boxA := H3dObject newBoxWidth: ( 0.10 meter ) length: ( 0.20 meter)  height: ( 0.30 meter ).   boxB := H3dObject newBoxWidth: ( 1.10 meter ) length: ( 1.20 meter ) height: ( 1.30 meter ).   boxC := H3dObject newBoxWidth: ( 2.10 meter ) length: ( 2.20 meter ) height: ( 2.30 meter ).   assembly := H3dObject newAssemblyFromParts: { boxA. boxB. boxC }.   "Part positions are relative to the assembly center."   assembly center: (HumVector newFrom: { 10.0 meter. 20.0 meter. 30.0 meter. }).   assembly move: boxA toMyCoordinate: ( HumVector newFrom: { 1.0 meter. 2.0 meter. 3.0 meter. } ).   assembly place: boxB onTopOf: boxA.   assembly place: boxC onTopOf: boxB.   "Check resulting positions in CONTAINER coordinates."   self expect:  ( HumVector newFrom: { 1.0 meter. 2.0 meter. 3.0 meter. } ) actual: ( boxA center ).   self expect: ( boxA center x ) actual: ( boxB center x ).   self expect: ( boxA center y ) actual: ( boxB center y ).   self expect: ( boxA center x ) actual: ( boxC center x ).   self expect: ( boxA center y ) actual: ( boxC center y ).   clearance := 0.001 meter.   self expect: ( ( boxA center z ) +  ( boxA height/2 ) )  actual: ( boxA maxZ ).   self expect: ( boxA maxZ + clearance + ( boxB height ) ) actual: ( boxB maxZ ).   self expect: ( boxB maxZ + clearance + ( boxC height ) ) actual: ( boxC maxZ ).   totalHeight := boxA height + clearance + boxB height + clearance + boxC height.   self expect: ( 3.902 meter ) actual: (totalHeight).   "Check resulting positions in SCENE coordinates"   self expect: ( ( assembly center + boxA center) x + ((boxC width)/2.0 ) ) actual: ( assembly maxX ).   self expect: ( ( assembly center + boxA center) x - ((boxC width)/2.0 )  ) actual: ( assembly minX ).   self expect: ( ( assembly center + boxA center) y + ((boxC length)/2.0 ) ) actual: ( assembly maxY ).   self expect: ( ( assembly center + boxA center) y - ((boxC length)/2.0 ) ) actual: ( assembly minY ).   self expect: ( ( assembly center + boxA center) z - ((boxA height)/2.0 ) ) actual: ( assembly minZ ).   self expect: ( ( assembly center + boxA center) z - ((boxA height)/2.0 ) + totalHeight ) actual: ( assembly maxZ ).</pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test821stackAndYaw90</h3><pre>test821stackAndYaw90   | boxA boxB boxC assembly clearance totalHeight heightOverPivot |   boxA := H3dObject newBoxWidth: ( 0.10 meter ) length: ( 0.20 meter)  height: ( 0.30 meter ).   boxB := H3dObject newBoxWidth: ( 1.10 meter ) length: ( 1.20 meter ) height: ( 1.30 meter ).   boxC := H3dObject newBoxWidth: ( 2.10 meter ) length: ( 2.20 meter ) height: ( 2.30 meter ).   assembly := H3dObject newAssemblyFromParts: { boxA. boxB. boxC }.   "Part positions are relative to the assembly center."   assembly center: (HumVector newFrom: { 10.0 meter. 20.0 meter. 30.0 meter. }).   assembly move: boxA toMyCoordinate: ( HumVector newFrom: { 1.0 meter. 2.0 meter. 3.0 meter. } ).   assembly place: boxB onTopOf: boxA.   assembly place: boxC onTopOf: boxB.   "Check resulting positions in CONTAINER coordinates."   self expect:  ( HumVector newFrom: { 1.0 meter. 2.0 meter. 3.0 meter. } ) actual: ( boxA center ).   self expect: ( boxA center x ) actual: ( boxB center x ).   self expect: ( boxA center y ) actual: ( boxB center y ).   self expect: ( boxA center x ) actual: ( boxC center x ).   self expect: ( boxA center y ) actual: ( boxC center y ).   clearance := 0.001 meter.   self expect: ( ( boxA center z ) +  ( boxA height/2 ) )  actual: ( boxA maxZ ).   self expect: ( boxA maxZ + clearance + ( boxB height ) ) actual: ( boxB maxZ ).   self expect: ( boxB maxZ + clearance + ( boxC height ) ) actual: ( boxC maxZ ).   totalHeight := boxA height + clearance + boxB height + clearance + boxC height.   self expect: ( 3.902 meter ) actual: (totalHeight).   "Check resulting positions in SCENE coordinates"   assembly pivotPoint: boxA center.    assembly      yaw: 0.0 radian.   "Zero yaw should have no effect."      self expect: ( ( assembly center + boxA center) x + ( (boxC width) / 2.0 ) ) actual: ( assembly maxX ).   self expect: ( ( assembly center + boxA center) x - ( (boxC width) / 2.0 )  ) actual: ( assembly minX ).   self expect: ( ( assembly center + boxA center) y + ( (boxC length) / 2.0 ) ) actual: ( assembly maxY ).   self expect: ( ( assembly center + boxA center) y - ( (boxC length) / 2.0 ) ) actual: ( assembly minY ).   self expect: ( ( assembly center + boxA center) z - ( (boxA height) / 2.0 ) ) actual: ( assembly minZ ).   self expect: ( ( assembly center + boxA center) z - ( (boxA height) / 2.0 ) + totalHeight ) actual: ( assembly maxZ ).      "Yaw 90 degrees and see . . ."   assembly      yaw: (Float pi/2.0) radian.   heightOverPivot := totalHeight - (boxA height/2.0).   "x and y offsets should exchange"   self expect: ( ( assembly center + boxA center) x + ( (boxC length) / 2.0 ) ) actual: ( assembly maxX ). "STS"   self expect: ( ( assembly center + boxA center) x - ( (boxC length) / 2.0 )  ) actual: ( assembly minX ).   "STS"   self expect: ( ( assembly center + boxA center) y + ( (boxC width ) / 2.0 ) ) actual: ( assembly maxY ).   self expect: ( ( assembly center + boxA center) y - ( (boxC width) / 2.0 ) ) actual: ( assembly minY ).   self expect: ( ( assembly center + boxA center) z - ( (boxA height) / 2.0 ) ) actual: ( assembly minZ ).   self expect: ( ( assembly center + boxA center) z - ( (boxA height) / 2.0 ) + totalHeight ) actual: ( assembly maxZ ).</pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test822stackAndPitch90</h3><pre>test822stackAndPitch90   | boxA boxB boxC assembly clearance totalHeight heightOverPivot |   boxA := H3dObject newBoxWidth: ( 0.10 meter ) length: ( 0.20 meter)  height: ( 0.30 meter ).   boxB := H3dObject newBoxWidth: ( 1.10 meter ) length: ( 1.20 meter ) height: ( 1.30 meter ).   boxC := H3dObject newBoxWidth: ( 2.10 meter ) length: ( 2.20 meter ) height: ( 2.30 meter ).   assembly := H3dObject newAssemblyFromParts: { boxA. boxB. boxC }.   "Part positions are relative to the assembly center."   assembly center: (HumVector newFrom: { 10.0 meter. 20.0 meter. 30.0 meter. }).   assembly move: boxA toMyCoordinate: ( HumVector newFrom: { 1.0 meter. 2.0 meter. 3.0 meter. } ).   assembly place: boxB onTopOf: boxA.   assembly place: boxC onTopOf: boxB.   "Check resulting positions in CONTAINER coordinates."   self expect:  ( HumVector newFrom: { 1.0 meter. 2.0 meter. 3.0 meter. } ) actual: ( boxA center ).   self expect: ( boxA center x ) actual: ( boxB center x ).   self expect: ( boxA center y ) actual: ( boxB center y ).   self expect: ( boxA center x ) actual: ( boxC center x ).   self expect: ( boxA center y ) actual: ( boxC center y ).   clearance := 0.001 meter.   self expect: ( ( boxA center z ) +  ( boxA height/2 ) )  actual: ( boxA maxZ ).   self expect: ( boxA maxZ + clearance + ( boxB height ) ) actual: ( boxB maxZ ).   self expect: ( boxB maxZ + clearance + ( boxC height ) ) actual: ( boxC maxZ ).   totalHeight := boxA height + clearance + boxB height + clearance + boxC height.   self expect: ( 3.902 meter ) actual: (totalHeight).   "Check resulting positions in SCENE coordinates"   assembly pivotPoint: boxA center.    assembly      pitch: 0.0 radian.   "Zero pitch should have no effect."      self expect: ( ( assembly center + boxA center) x + ( (boxC width) / 2.0 ) ) actual: ( assembly maxX ).   self expect: ( ( assembly center + boxA center) x - ( (boxC width) / 2.0 )  ) actual: ( assembly minX ).   self expect: ( ( assembly center + boxA center) y + ( (boxC length) / 2.0 ) ) actual: ( assembly maxY ).   self expect: ( ( assembly center + boxA center) y - ( (boxC length) / 2.0 ) ) actual: ( assembly minY ).   self expect: ( ( assembly center + boxA center) z - ( (boxA height) / 2.0 ) ) actual: ( assembly minZ ).   self expect: ( ( assembly center + boxA center) z - ( (boxA height) / 2.0 ) + totalHeight ) actual: ( assembly maxZ ).      "Pitch 90 degrees up and see . . ."   assembly      pitch: (Float pi/2.0) radian.   heightOverPivot := totalHeight - (boxA height/2.0).   "y and z offsets should exchange"   self expect: ( ( assembly center + boxA center) x + ( (boxC width) / 2.0 ) ) actual: ( assembly maxX ). "STS"   self expect: ( ( assembly center + boxA center) x - ( (boxC width) / 2.0 )  ) actual: ( assembly minX ).   "STS"   self expect: ( ( assembly center + boxA center) y + ( boxA height / 2.0)  ) actual: ( assembly maxY ).   self expect: ( ( assembly center + boxA center) y - heightOverPivot ) actual: ( assembly minY ).   self expect: ( ( assembly center + boxA center) z - ( (boxC length) / 2.0 )  ) actual: ( assembly minZ ).   self expect: ( ( assembly center + boxA center) z + ( (boxC length) / 2.0 )  ) actual: ( assembly maxZ ).</pre><h3>Hum-X -- H3dObjectTests &gt;&gt; test824stackAndRoll90</h3><pre>test824stackAndRoll90   | boxA boxB boxC assembly clearance totalHeight heightOverPivot |   boxA := H3dObject newBoxWidth: ( 0.10 meter ) length: ( 0.20 meter)  height: ( 0.30 meter ).   boxB := H3dObject newBoxWidth: ( 1.10 meter ) length: ( 1.20 meter ) height: ( 1.30 meter ).   boxC := H3dObject newBoxWidth: ( 2.10 meter ) length: ( 2.20 meter ) height: ( 2.30 meter ).   assembly := H3dObject newAssemblyFromParts: { boxA. boxB. boxC }.   "Part positions are relative to the assembly center."   assembly center: (HumVector newFrom: { 10.0 meter. 20.0 meter. 30.0 meter. }).   assembly move: boxA toMyCoordinate: ( HumVector newFrom: { 1.0 meter. 2.0 meter. 3.0 meter. } ).   assembly place: boxB onTopOf: boxA.   assembly place: boxC onTopOf: boxB.   "Check resulting positions in CONTAINER coordinates."   self expect:  ( HumVector newFrom: { 1.0 meter. 2.0 meter. 3.0 meter. } ) actual: ( boxA center ).   self expect: ( boxA center x ) actual: ( boxB center x ).   self expect: ( boxA center y ) actual: ( boxB center y ).   self expect: ( boxA center x ) actual: ( boxC center x ).   self expect: ( boxA center y ) actual: ( boxC center y ).   clearance := 0.001 meter.   self expect: ( ( boxA center z ) +  ( boxA height/2 ) )  actual: ( boxA maxZ ).   self expect: ( boxA maxZ + clearance + ( boxB height ) ) actual: ( boxB maxZ ).   self expect: ( boxB maxZ + clearance + ( boxC height ) ) actual: ( boxC maxZ ).   totalHeight := boxA height + clearance + boxB height + clearance + boxC height.   self expect: ( 3.902 meter ) actual: (totalHeight).   "Check resulting positions in SCENE coordinates"   assembly pivotPoint: boxA center.    assembly      roll: 0.0 radian.   "Zero roll should have no effect."      self expect: ( ( assembly center + boxA center) x + ( (boxC width) / 2.0 ) ) actual: ( assembly maxX ).   self expect: ( ( assembly center + boxA center) x - ( (boxC width) / 2.0 )  ) actual: ( assembly minX ).   self expect: ( ( assembly center + boxA center) y + ( (boxC length) / 2.0 ) ) actual: ( assembly maxY ).   self expect: ( ( assembly center + boxA center) y - ( (boxC length) / 2.0 ) ) actual: ( assembly minY ).   self expect: ( ( assembly center + boxA center) z - ( (boxA height) / 2.0 ) ) actual: ( assembly minZ ).   self expect: ( ( assembly center + boxA center) z - ( (boxA height) / 2.0 ) + totalHeight ) actual: ( assembly maxZ ).      "Roll 90 degrees and see . . ."   assembly      roll: (Float pi/2.0) radian.   heightOverPivot := totalHeight - (boxA height/2.0).   "x and z offsets should exchange"   self expect: ( ( assembly center + boxA center) x + ( (boxA height) / 2.0 ) ) actual: ( assembly maxX ).    self expect: ( ( assembly center + boxA center) x - heightOverPivot  ) actual: ( assembly minX ).      self expect: ( ( assembly center + boxA center) y + ( boxC length / 2.0)  ) actual: ( assembly maxY ).   "STS"   self expect: ( ( assembly center + boxA center) y - ( boxC length / 2.0)  ) actual: ( assembly minY ).      "STS"   self expect: ( ( assembly center + boxA center) z - ( (boxC width) / 2.0 )  ) actual: ( assembly minZ ).   self expect: ( ( assembly center + boxA center) z + ( (boxC width) / 2.0 )  ) actual: ( assembly maxZ ).</pre><h3>Hum-X -- H3dObject &gt;&gt; addPart:</h3><pre>addPart: anH3dObject   "Add a part (or subassembly) to my assembly."   self assert: (anH3dObject isKindOf: H3dObject ).   self deny: (anH3dObject == self ).       (self parts) add: anH3dObject.</pre><h3>Hum-X -- H3dObject &gt;&gt; addParts:</h3><pre>addParts: aPartsList   "Add each part to my set of parts."   aPartsList do: [  :part | (self parts) add: part. ].</pre><h3>Hum-X -- H3dObject &gt;&gt; assertRadians:</h3><pre>assertRadians: anAngleInRadians      self assert: ( (anAngleInRadians isKindOf: HumMeasure) and: [anAngleInRadians dimensions = (1 radian) dimensions ] )         description: 'Angles should be HumMeasure with units of #radian'.</pre><h3>Hum-X -- H3dObject &gt;&gt; assertRadiansPerSecond:</h3><pre>assertRadiansPerSecond: radiansPerSecond      self assert: ( (radiansPerSecond isKindOf: HumMeasure) and: [radiansPerSecond dimensions = (1 rpm) dimensions ] ) "Number&gt;&gt;rpm"         description: 'Angular-velocity should be HumMeasure with units of radians per second'.</pre><h3>Hum-X -- H3dObject &gt;&gt; axis:</h3><pre>axis: anAxisSymbol   "Which axis is rotation around?    Use with #curve: to set-up surface of rotation."   self assert: (anAxisSymbol isKindOf: Symbol ).   ^ axis := anAxisSymbol.</pre><h3>Hum-X -- H3dObject &gt;&gt; borderColor</h3><pre>borderColor   ^ borderColor ifNil: [ borderColor := (self fillColor) lighter. ].</pre><h3>Hum-X -- H3dObject &gt;&gt; bottom</h3><pre>bottom   "Value without yaw, pitch, roll - Use minZ to see value with yaw, pitch, roll."   ^  ( center z ) - ( height / 2.0 ).</pre><h3>Hum-X -- H3dObject &gt;&gt; bottom:</h3><pre>bottom: aMeasure   "Move so that bottom is at given z value."   | cx cy cz |   cx := center x.    cy := center y.   cz := center z.   self center: ( HumVector newFrom: { cx. cy. ( aMeasure + ( height / 2.0 ) ). } ).</pre><h3>Hum-X -- H3dObject &gt;&gt; buildAndOrient</h3><pre>buildAndOrient   "Return polygons in scene coordinates.   Build base polygons.    Then, adjust orientation for yaw, pitch, roll. "   | basePolygons adjustedPolygons pivot |   basePolygons := self buildBasePolygons.   adjustedPolygons := OrderedCollection new.   pivot := self pivot.   self assert: ( pivot isKindOf: HumVector ).   basePolygons do: [ :p0 | "p0 is a polygon"      |  p1 p2 p3 |      "To assure consistent results, alway apply in order: yaw, pitch, roll. "      ( yaw quantity closeTo: 0.0 )   ifTrue: [ p1 := p0 ] ifFalse: [ p1 := p0 yaw: yaw aboutPivot: pivot ].      ( pitch quantity closeTo: 0.0 )   ifTrue: [ p2 := p1 ] ifFalse: [ p2 := p1 pitch: pitch aboutPivot: pivot ] .      ( roll quantity closeTo: 0.0 )   ifTrue: [ p3 := p2 ] ifFalse: [ p3 := p2 roll: roll aboutPivot: pivot ].      adjustedPolygons add: p3.       ].   ^adjustedPolygons.   </pre><h3>Hum-X -- H3dObject &gt;&gt; buildAssembly</h3><pre>buildAssembly   "Build the polygons for the assembly by aggregating and translating polygons from the parts."   | localPolygons translatedPolygons |   localPolygons := OrderedCollection new.   translatedPolygons := OrderedCollection new.   self parts  do: [ :part |  localPolygons addAllLast: ( part buildBasePolygons ) ].   localPolygons do: [ :polygon | translatedPolygons addLast: (polygon translateBy: self center)  ].     ^translatedPolygons.</pre><h3>Hum-X -- H3dObject &gt;&gt; buildBasePolygons</h3><pre>buildBasePolygons   "Return my base polygons. Polygons before pitch, yaw, roll."   | calc polygons  |   polygons := OrderedCollection new.   calc := HumCalculator new.   calc cases;      when: [ type = #box ] then: [ polygons := self buildBox ];      when: [ type = #elipsoid ] then: [ polygons := self buildElipsoid ];      when: [ type = #rotation ] then: [ polygons := self buildRotation ];      when: [ type = #assembly ] then: [ polygons := self buildAssembly ];      otherwise: [ Error signal: 'Unknown type of 3D object: ', (type asString) ].   self assert: ( polygons size &gt; 0 ) description: 'Empty assembly? Unexpected it is.'.   ^polygons.</pre><h3>Hum-X -- H3dObject &gt;&gt; buildBox</h3><pre>buildBox   "Create polygons for a box"   | polygons points dx dy dz cx cy cz top bottom east west north south |   polygons := OrderedCollection new.   dx := width / 2.0.   dy := length / 2.0.   dz := height / 2.0.   cx := center x.   cy := center y.   cz := center z.      points := Collection new.   top := H3dPath new.   top       addVertex: { cx+dx. cy+dy. cz+dz. }; "Right-hand rule: Wind clockwise facing inward."      addVertex: { cx+dx. cy-dy. cz+dz. };      addVertex: { cx-dx. cy-dy. cz+dz. };      addVertex: { cx-dx. cy+dy. cz+dz. }.         bottom := H3dPath new.   bottom      addVertex: { cx+dx. cy+dy. cz-dz. };      addVertex: { cx-dx. cy+dy. cz-dz. };      addVertex: { cx-dx. cy-dy. cz-dz. };      addVertex: { cx+dx. cy-dy. cz-dz. }.   north := H3dPath new.   north      addVertex: { cx+dx. cy+dy. cz+dz. };      addVertex: { cx-dx. cy+dy. cz+dz. };      addVertex: { cx-dx. cy+dy. cz-dz. };      addVertex: { cx+dx. cy+dy. cz-dz. }.   south := H3dPath new.   south      addVertex: { cx+dx. cy-dy. cz+dz. };      addVertex: { cx+dx. cy-dy. cz-dz. };      addVertex: { cx-dx. cy-dy. cz-dz. };      addVertex: { cx-dx. cy-dy. cz+dz. }.   east := H3dPath new.   east      addVertex: { cx+dx. cy+dy. cz+dz. };      addVertex: { cx+dx. cy+dy. cz-dz. };      addVertex: { cx+dx. cy-dy. cz-dz. };      addVertex: { cx+dx. cy-dy. cz+dz. }.   west := H3dPath new.   west      addVertex: { cx-dx. cy+dy. cz+dz. };      addVertex: { cx-dx. cy-dy. cz+dz. };      addVertex: { cx-dx. cy-dy. cz-dz. };      addVertex: { cx-dx. cy+dy. cz-dz. }.   "assemble faces"            polygons addAll: { top. bottom. north. south. east. west. }.      "color"   polygons do: [ :polygon | polygon borderColor: (self borderColor); fillColor: (self fillColor) ].   ^ polygons.</pre><h3>Hum-X -- H3dObject &gt;&gt; buildElipsoid</h3><pre>buildElipsoid   "Create polygons forming the elipsoid."   | polygons pi minusPi twoPi nWedges  dAlpha dBeta makePoint xMax yMax zMax |   polygons := OrderedCollection new.   pi := Float pi.   minusPi := pi negated.   twoPi := 2.0 * pi.   nWedges := self numberOfWedges.   dAlpha := pi / nWedges.   dBeta := twoPi / nWedges.   xMax := width / 2.0.   yMax := length / 2.0.   zMax := height / 2.0.   makePoint := [ :alpha :beta |     "BlockClosure to build a point given alpha and beta angles."         | x y z vertex |         x := xMax * ( beta cos ) * ( alpha cos ).         y := yMax * ( beta sin ) * ( alpha cos ).         z := zMax * ( alpha sin ).          vertex := HumVector newFrom: { x. y. z. }.       "return"         ].   "Work from bottom to top"   ( ((minusPi / 2.0) + dAlpha ) to: pi / 2.0 by: dAlpha) do: [ :alpha |  "verticle angle from x-y plane"      ( minusPi  to: ( pi - dBeta ) by: dBeta ) do: [ :beta | "circle around z axis"          | polygon |         polygon := H3dPath new.         polygon             addVertex: ( makePoint value: alpha value: beta );            addVertex: ( makePoint value: alpha value: beta + dBeta );            addVertex: ( makePoint value: alpha - dAlpha value: beta + dBeta );            addVertex: ( makePoint value: alpha - dAlpha value: beta ).         polygons add: polygon.         ].      ].   "color"   polygons do: [ :polygon | polygon borderColor: (self borderColor); fillColor: (self fillColor) ].   ^polygons.   </pre><h3>Hum-X -- H3dObject &gt;&gt; buildRotation</h3><pre>buildRotation   "Given curve and an axis, build a rotation as a collection of polygons."   | polygons nWedges dAngle cx cy cz priorXY priorPoint twoPi calc adjustedPolygons |   polygons := OrderedCollection new.   nWedges := self numberOfWedges.   cx := center x.   cy := center y.   cz := center z.   priorXY := curve first.   priorPoint := HumVector newFrom: { cx + (priorXY x). cy. cz + (priorXY y).  }.   twoPi := 2.0 * (Float pi).   dAngle := twoPi / nWedges.   ( dAngle to: twoPi by: dAngle ) do: [ :angle |             ( curve vertices copyFrom: 2 to: curve size ) do: [ :xy |               | polygon thisPoint |                 thisPoint := HumVector newFrom: {  cx + (xy x). cy. cz + (xy y). }.               polygon := HumPolygon new.               polygon                   addVertex: ( thisPoint yaw: angle radian );  "Right-hand rule: Wind clockwise looking inward."                  addVertex: ( priorPoint yaw: angle radian  );                  addVertex: ( priorPoint yaw: (angle - dAngle) radian );                  addVertex: ( thisPoint yaw: (angle - dAngle) radian ).               polygons add: polygon.               priorPoint := thisPoint.            ].         ].   calc := HumCalculator new.   "Adjust for non-default axis of rotation."   adjustedPolygons := OrderedCollection new.   calc cases;      when: [ axis = #z ] then: [ adjustedPolygons := polygons ];      when: [ axis = #x ] then: [ adjustedPolygons := polygons collect: [ :polygon | polygon roll:  (Float pi / 2.0) negated radian ]  ];      when: [ axis = #y ] then: [ adjustedPolygons := polygons collect: [ :polygon | polygon pitch:  (Float pi / 2.0) negated radian ]  ];      "TODO: Should this be #pitch:aboutPivot: ?? "      otherwise: [ "default is #z" adjustedPolygons := polygons ].   "color"   adjustedPolygons do: [ :polygon | polygon borderColor: (self borderColor); fillColor: (self fillColor ) ]. "Color"    ^adjustedPolygons. </pre><h3>Hum-X -- H3dObject &gt;&gt; center</h3><pre>center   ^ center ifNil: [ center := (HumVector newFrom: { 0.0 meter. 0.0 meter. 0.0 meter. } ) ].</pre><h3>Hum-X -- H3dObject &gt;&gt; center:</h3><pre>center: aVector   "Set my center in container coordinates."   self assert: ( aVector isKindOf: HumVector ).   center := aVector copy.</pre><h3>Hum-X -- H3dObject &gt;&gt; clearance</h3><pre>clearance   "Default value for clearance is one millimeter."   ^clearance ifNil: [ clearance := 0.001 meter ].</pre><h3>Hum-X -- H3dObject &gt;&gt; curve:</h3><pre>curve: xyPoints   "Curve to use when building a rotation.   Use with #axis to define a surface of rotation."   self assert: ( xyPoints isKindOf: H3dPath ).   curve := xyPoints.</pre><h3>Hum-X -- H3dObject &gt;&gt; east</h3><pre>east   "Value without yaw, pitch, roll - Use maxX to see value with yaw, pitch, roll."   ^  ( center x ) + ( width / 2.0 ).</pre><h3>Hum-X -- H3dObject &gt;&gt; east:</h3><pre>east: aMeasure   "Move so that east edge is at the given value."   | cx cy cz |   cx := center x.    cy := center y.   cz := center z.   self center: (HumVector newFrom: { (aMeasure - ( width / 2.0 ) ). cy. cz. }).   </pre><h3>Hum-X -- H3dObject &gt;&gt; fillColor</h3><pre>fillColor   ^ fillColor ifNil: [ fillColor := Color gray. ].</pre><h3>Hum-X -- H3dObject &gt;&gt; height</h3><pre>height   "What is my Up-Down height? (prior to pitch, yaw, roll).   Defines height of box or elipsoid."   ^ height ifNil: [ Error signal: 'height dimension has not been set' ].</pre><h3>Hum-X -- H3dObject &gt;&gt; height:</h3><pre>height: aHeight   "What is my Up-Down height? (prior to pitch, yaw, roll).   Defines height of box or elipsoid."   height := aHeight.</pre><h3>Hum-X -- H3dObject &gt;&gt; initialize</h3><pre>initialize   "Set initial position, orientation, velocity, and rotation rates to zero."   | zeroOffset zeroSpeed zeroRotation zeroRateOfRotation |      zeroOffset := 0.0 meter.   zeroSpeed := 0.0 mps.   zeroRotation := 0.0 radian.   zeroRateOfRotation := 0.0 rps.      self center: ( HumVector newFrom: { zeroOffset. zeroOffset. zeroOffset. } ).   self velocity: ( HumVector newFrom: { zeroSpeed.  zeroSpeed.  zeroSpeed. } ).      self yaw: zeroRotation.   self pitch: zeroRotation.   self roll: zeroRotation.      self yawRate: zeroRateOfRotation.   self pitchRate: zeroRateOfRotation.   self rollRate: zeroRateOfRotation.</pre><h3>Hum-X -- H3dObject &gt;&gt; length</h3><pre>length   "What is my North-South length? (prior to pitch, yaw, roll)   Define length of box or elipsoid."   ^ length ifNil: [ Error signal: 'length dimesion has not been set' ].</pre><h3>Hum-X -- H3dObject &gt;&gt; length:</h3><pre>length: aLength   "What is my North-South length? (prior to pitch, yaw, roll)   Define length of box or elipsoid."   length := aLength.</pre><h3>Hum-X -- H3dObject &gt;&gt; maxX</h3><pre>maxX   | v |   v := nil.   (self polygons) do: [ :polygon |       polygon vertices do: [ :vertex |          ( v isNil )             ifTrue: [ v := vertex x ]            ifFalse: [ v := v max: (vertex x) ]          ].        ].   ^ v.   </pre><h3>Hum-X -- H3dObject &gt;&gt; maxY</h3><pre>maxY   | v |   v := nil.   (self polygons) do: [ :polygon |       polygon vertices do: [ :vertex |          ( v isNil )             ifTrue: [ v := vertex y ]            ifFalse: [ v := v max: (vertex y) ]          ].        ].   ^ v.   </pre><h3>Hum-X -- H3dObject &gt;&gt; maxZ</h3><pre>maxZ   | v |   v := nil.   (self polygons) do: [ :polygon |       polygon vertices do: [ :vertex |          ( v isNil )             ifTrue: [ v := vertex z ]            ifFalse: [ v := v max: (vertex z) ]          ].        ].   ^ v.   </pre><h3>Hum-X -- H3dObject &gt;&gt; minX</h3><pre>minX   | v |   v := nil.   (self polygons) do: [ :polygon |       polygon vertices do: [ :vertex |          ( v isNil )             ifTrue: [ v := vertex x ]            ifFalse: [ v := v min: (vertex x) ]          ].        ].   ^ v.   </pre><h3>Hum-X -- H3dObject &gt;&gt; minY</h3><pre>minY   | v |   v := nil.   (self polygons) do: [ :polygon |       polygon vertices do: [ :vertex |          ( v isNil )             ifTrue: [ v := vertex y ]            ifFalse: [ v := v min: (vertex y) ]          ].        ].   ^ v.   </pre><h3>Hum-X -- H3dObject &gt;&gt; minZ</h3><pre>minZ   | v |   v := nil.   (self polygons) do: [ :polygon |       polygon vertices do: [ :vertex |          ( v isNil )             ifTrue: [ v := vertex z ]            ifFalse: [ v := v min: (vertex z) ]          ].        ].   ^ v.   </pre><h3>Hum-X -- H3dObject &gt;&gt; move:toMyCoordinate:</h3><pre>move: aH3dObject toMyCoordinate: aHumVector    aH3dObject center: aHumVector.</pre><h3>Hum-X -- H3dObject &gt;&gt; north</h3><pre>north   "Value without yaw, pitch, roll - Use maxY to see value with yaw, pitch, roll."   ^  ( center y ) + ( length / 2.0 ).</pre><h3>Hum-X -- H3dObject &gt;&gt; north:</h3><pre>north: aMeasure   "Move so that north edge is at given value."   | cx cy cz |   cx := center x.    cy := center y.   cz := center z.   self center: (HumVector newFrom: { cx. ( aMeasure - ( length / 2.0 ) ). cz. }).</pre><h3>Hum-X -- H3dObject &gt;&gt; numberOfWedges</h3><pre>numberOfWedges   "Number of wedges to produce when drawing rotation or elipsoid."   ^ numberOfWedges ifNil: [ numberOfWedges := 12 ].</pre><h3>Hum-X -- H3dObject &gt;&gt; numberOfWedges:</h3><pre>numberOfWedges: anInteger    numberOfWedges := anInteger</pre><h3>Hum-X -- H3dObject &gt;&gt; parts</h3><pre>parts   "Return my set of parts/subassemblies - each part is unique - hence a member of a set."   ^ parts ifNil: [  parts := Set new. ].</pre><h3>Hum-X -- H3dObject &gt;&gt; pitch</h3><pre>pitch   "Amount of current pitch = rotation about x-axis"   ^ pitch ifNil: [ pitch := 0.0 radian ].</pre><h3>Hum-X -- H3dObject &gt;&gt; pitch:</h3><pre>pitch: anAngleInRadians   "Amount of current pitch = rotation about x-axis"   self assertRadians: anAngleInRadians.   pitch := anAngleInRadians.</pre><h3>Hum-X -- H3dObject &gt;&gt; pitchRate:</h3><pre>pitchRate: randiansPerSecond   "pitch rate (angular velocity) "   self assertRadiansPerSecond: randiansPerSecond.   pitchRate := randiansPerSecond.</pre><h3>Hum-X -- H3dObject &gt;&gt; pivot</h3><pre>pivot   "Return the pivot in scene coordinates."   | pivot |   pivot := (self center) + (self pivotPoint).   ^pivot</pre><h3>Hum-X -- H3dObject &gt;&gt; pivotPoint</h3><pre>pivotPoint   "Pivot-point is relative to object`s center.    By default we pivot around the center."   ^pivotPoint ifNil: [ pivotPoint := HumVector zeroVector: #meter ].</pre><h3>Hum-X -- H3dObject &gt;&gt; pivotPoint:</h3><pre>pivotPoint: aVector   "Pivot-point is relative to object`s center.   Example: The pivot is inset from top edge of arm.   w := 0.10.   h := 0.50   arm := H3dObject boxWidth: w length: w height: h.   arm pivotPoint: (HumVector newFrom: { 0.0. 0.0. (h/2)-(w/2). }."   pivotPoint := aVector</pre><h3>Hum-X -- H3dObject &gt;&gt; place:onTopOf:</h3><pre>place: aH3dObjectA onTopOf: aH3dObjectB    "Position so that  bottom matches top with a little clearance."   | offsetA offsetB sameX sameY newCenter  |   offsetA := ( aH3dObjectA maxZ ) - ( aH3dObjectA center z ).   offsetB := ( aH3dObjectB center z ) - ( aH3dObjectB minZ ).   sameX := aH3dObjectA center x.   sameY := aH3dObjectA center y.   clearance := self clearance.   newCenter := aH3dObjectB center + (HumVector newFrom: { sameX. sameY. (offsetA + offsetB + clearance ). } ).   aH3dObjectA center: newCenter.   </pre><h3>Hum-X -- H3dObject &gt;&gt; polygons</h3><pre>polygons   | polygons |   polygons := self buildAndOrient.   ^polygons</pre><h3>Hum-X -- H3dObject &gt;&gt; roll</h3><pre>roll   "Amount of current roll. = rotation about y-axis"   ^roll ifNil: [ roll := 0.0 radian ].</pre><h3>Hum-X -- H3dObject &gt;&gt; roll:</h3><pre>roll: anAngleInRadians   "Amount of current roll. = rotation about y-axis"   self assertRadians: anAngleInRadians.   roll := anAngleInRadians.</pre><h3>Hum-X -- H3dObject &gt;&gt; rollRate:</h3><pre>rollRate: randiansPerSecond   "roll rate (angular velocity) "   self assertRadiansPerSecond: randiansPerSecond.   rollRate := randiansPerSecond.</pre><h3>Hum-X -- H3dObject &gt;&gt; south</h3><pre>south   "Value without yaw, pitch, roll - Use minY to see value with yaw, pitch, roll."   ^  ( center y ) - ( length / 2.0 ).</pre><h3>Hum-X -- H3dObject &gt;&gt; south:</h3><pre>south: aMeasure   "Move so that south edge is at given value."   | cx cy cz |   cx := center x.    cy := center y.   cz := center z.   self center: ( HumVector newFrom: { cx. ( aMeasure + ( length / 2.0 ) ). cz. } ).</pre><h3>Hum-X -- H3dObject &gt;&gt; step:</h3><pre>step: aTimeIncrement   "Step the position and orientation."   | newCenter newPitch newYaw newRoll |   "self assert: ((aTimeIncrement isKindOf: HumMeasure) and: [ aTimeIncrement dimensions = { #second-&gt;1. } ] )."   newCenter := center + ( velocity * aTimeIncrement ).   "Always do yaw, pitch, roll in that order."   newYaw := yaw + ( yawRate * aTimeIncrement ).   newPitch := pitch + ( pitchRate * aTimeIncrement ).   newRoll := roll + ( rollRate * aTimeIncrement ).   "Update:"   self       center: newCenter;      yaw: newYaw;      pitch: newPitch;      roll: newRoll.   self changed.  "Inform subscribers."         </pre><h3>Hum-X -- H3dObject &gt;&gt; top</h3><pre>top   "Value without yaw, pitch, roll - Use maxZ to see value with yaw, pitch, roll."   ^  ( center z ) + ( height / 2.0 ).</pre><h3>Hum-X -- H3dObject &gt;&gt; top:</h3><pre>top: aMeasure   "Move so that top is at given z value."   | cx cy cz |   cx := center x.    cy := center y.   cz := center z.   self center: (HumVector newFrom: { cx. cy. ( aMeasure - ( height / 2.0 ) ). }).</pre><h3>Hum-X -- H3dObject &gt;&gt; type:</h3><pre>type: aType   "What type of 3D object am I?"   type := aType.</pre><h3>Hum-X -- H3dObject &gt;&gt; velocity:</h3><pre>velocity: aVector   "Set my velocity in container coordinates."   self assert: ( aVector isKindOf: HumVector ).   velocity := aVector.</pre><h3>Hum-X -- H3dObject &gt;&gt; volume</h3><pre>volume   "Return volume of box."   | volume calc |   calc := HumCalculator new.   calc cases;      when: [ type = #box ] then: [ volume := width * length * height. ];      when: [ type = #elipsoid ] then: [| a b c | a := width/2.0.  b := length/2.0. c := height/2.0. volume := a * b * c * (Float pi)* 4.0 / 3.0 ];      when: [ type = #rotation ] then: [ self shouldBeImplemented  ];      otherwise: [ Error signal: '3D object type not given' ].    ^volume.   </pre><h3>Hum-X -- H3dObject &gt;&gt; west</h3><pre>west   "Value without yaw, pitch, roll - Use minX to see value with yaw, pitch, roll."   ^  ( center x ) - ( width / 2.0 ).</pre><h3>Hum-X -- H3dObject &gt;&gt; west:</h3><pre>west: aMeasure   "Move so that west edge is at the given value."   | cx cy cz |   cx := center x.    cy := center y.   cz := center z.   self center:  (HumVector newFrom: { ( aMeasure + ( width / 2.0 ) ). cy. cz. }).   </pre><h3>Hum-X -- H3dObject &gt;&gt; width</h3><pre>width   ^ width ifNil: [ Error signal: 'width has not been set' ].</pre><h3>Hum-X -- H3dObject &gt;&gt; width:</h3><pre>width: aWidth   "What is my East-West width? (prior to pitch, yaw, roll)   Define width of box or elipsoid."   width := aWidth.</pre><h3>Hum-X -- H3dObject &gt;&gt; yaw</h3><pre>yaw   "Amount of current yaw. = rotation about z-axis"   ^ yaw ifNil: [ yaw := 0.0 radian ].</pre><h3>Hum-X -- H3dObject &gt;&gt; yaw:</h3><pre>yaw: anAngleInRadians   "Amount of current yaw. = rotation about z-axis"   self assertRadians: anAngleInRadians.   yaw := anAngleInRadians.</pre><h3>Hum-X -- H3dObject &gt;&gt; yawRate:</h3><pre>yawRate: randiansPerSecond   "yaw rate (angular velocity) = rotation about z-axis"   self assertRadiansPerSecond: randiansPerSecond.   yawRate := randiansPerSecond.</pre><h3>Hum-X -- H3dPath &gt;&gt; =</h3><pre>= anotherPath   "Are the two paths equal."   | result |   "Are they the same size?"   ( self vertices size = anotherPath vertices size )       ifFalse: [ ^false ].      result := true. "Innocent until proven otherwise."   (1 to: self size)      do: [ :i | ((self vertices at: i) = (anotherPath vertices at: i)) ifFalse: [ ^false ]. ].   ^result.   </pre><h3>Hum-X -- H3dPath &gt;&gt; addVertex:</h3><pre>addVertex: xyzCoordinates    | vector calc |   calc := HumCalculator new.   calc cases;      when: [ xyzCoordinates isKindOf: HumVector ] then: [ vector := xyzCoordinates. ];      when: [ xyzCoordinates isKindOf: Array ] then: [ vector := HumVector newFrom: xyzCoordinates. ];      when: [ xyzCoordinates isKindOf: Point ] then: [ vector := HumVector newFromPoint: xyzCoordinates. ];            otherwise: [ Error signal: 'xyzCoordinates of unexpected type' ].   (self vertices) add: vector.   </pre><h3>Hum-X -- H3dPath &gt;&gt; allButFirstDo:</h3><pre>allButFirstDo: aBlockClosure    ^self vertices allButFirstDo: aBlockClosure.</pre><h3>Hum-X -- H3dPath &gt;&gt; at:</h3><pre>at: anInteger   "Return the vertex at: ..."   | vertex |   self assert: (anInteger &lt;= (self vertices size)).   vertex := (self vertices) at: anInteger.   ^vertex.</pre><h3>Hum-X -- H3dPath &gt;&gt; borderColor</h3><pre>borderColor   ^ borderColor ifNil: [ borderColor := (self fillColor) lighter ].</pre><h3>Hum-X -- H3dPath &gt;&gt; borderColor:</h3><pre>borderColor: aColor    "Color to use when rendering path (polygon edges)."   borderColor := aColor.</pre><h3>Hum-X -- H3dPath &gt;&gt; do:</h3><pre>do: aBlockClosure    ^self vertices do: aBlockClosure.</pre><h3>Hum-X -- H3dPath &gt;&gt; fillColor</h3><pre>fillColor   ^ fillColor ifNil: [ fillColor := Color gray ].</pre><h3>Hum-X -- H3dPath &gt;&gt; fillColor:</h3><pre>fillColor: aColor    "Color to use when rendering path as a polygon"   fillColor := aColor.</pre><h3>Hum-X -- H3dPath &gt;&gt; first</h3><pre>first   | points |   points := self vertices.   self assert: ( points size &gt; 0 ). "OrderedCollection"   ^ points at: 1.</pre><h3>Hum-X -- H3dPath &gt;&gt; last</h3><pre>last   | points |   points := self vertices.   self assert: ( points size &gt; 0 ). "OrderedCollection"   ^ points last.</pre><h3>Hum-X -- H3dPath &gt;&gt; max:</h3><pre>max: aBlockClosure    ^self vertices max: aBlockClosure.</pre><h3>Hum-X -- H3dPath &gt;&gt; pitch:</h3><pre>pitch: pitchAngle    "Return a new path with my points adjusted by pitch about origin."   | newPath |   newPath := self pitch: pitchAngle aboutPivot: ( HumVector zeroVector: #meter ).   ^newPath</pre><h3>Hum-X -- H3dPath &gt;&gt; pitch:aboutPivot:</h3><pre>pitch: pitchAngle aboutPivot: aPivot   "Return a new path with my points adjusted by pitch about origin."   | newPath |   newPath := self class  new.   self vertices do: [ :vertex |  newPath addVertex: ( vertex pitch: pitchAngle aboutPivot: aPivot ). ].   ^newPath</pre><h3>Hum-X -- H3dPath &gt;&gt; roll:</h3><pre>roll: rollAngle    "Return a new path with my points adjusted by roll about origin."   | newPath |   newPath := self roll: rollAngle aboutPivot: ( HumVector zeroVector: #meter ).   ^newPath</pre><h3>Hum-X -- H3dPath &gt;&gt; roll:aboutPivot:</h3><pre>roll: rollAngle aboutPivot: aPivot   "Return a new path with my points adjusted by roll about origin."   | newPath |   newPath := self class new.   self vertices do: [ :vertex |  newPath addVertex: ( vertex roll: rollAngle aboutPivot: aPivot ). ]."HumVector"   ^newPath</pre><h3>Hum-X -- H3dPath &gt;&gt; size</h3><pre>size   ^ self vertices size.</pre><h3>Hum-X -- H3dPath &gt;&gt; translateBy:</h3><pre>translateBy: aHumVector    "Return a path with vertices translated by the given vector."   | newVertices instance |   newVertices := OrderedCollection new.   self vertices do: [ :vertex |          | newVertex |         newVertex := vertex + aHumVector.         newVertices addLast: newVertex.       ].   instance := self class newFrom: newVertices.   instance       fillColor: (self fillColor);      borderColor: (self borderColor).   ^instance.      </pre><h3>Hum-X -- H3dPath &gt;&gt; translatedBy:</h3><pre>translatedBy: aHumVector   "Return a new path with my vertices translated by the given vector"   "This is just a synonym"   ^self translateBy: aHumVector.</pre><h3>Hum-X -- H3dPath &gt;&gt; vertices</h3><pre>vertices   ^ vertices ifNil: [ vertices := OrderedCollection new ].</pre><h3>Hum-X -- H3dPath &gt;&gt; yaw:</h3><pre>yaw: yawAngle    "Return a new path with my points adjusted by yaw about origin."   | newPath  |   newPath := self yaw: yawAngle aboutPivot: ( HumVector zeroVector: #meter ).   ^newPath</pre><h3>Hum-X -- H3dPath &gt;&gt; yaw:aboutPivot:</h3><pre>yaw: yawAngle aboutPivot: pivot   "Return a new path with my points adjusted by yaw about origin."   | newPath |   newPath := self class new.   self vertices do: [ :vertex |  newPath addVertex: ( vertex yaw: yawAngle aboutPivot: pivot ). ].   ^newPath</pre><h3>Hum-X -- H3dViewPortTests &gt;&gt; test110CreateCamera</h3><pre>test110CreateCamera   | camera scene |   "A camera is a 3d-object. Dimensions refer to virtual viewport and eye-point."   camera := H3dCamera depth: 0.40 meter height: 0.20 meter width: 0.30 meter.   self expect: 0.40 meter actual: camera depth.   self expect: 0.20 meter actual: camera height.   self expect: 0.30 meter actual: camera width.   "A camera has a position in a scene."   scene := H3dObject newAssemblyFromParts: { camera }.   scene move: camera toMyCoordinate: ( HumVector newFrom: { 10. 20. 30. } ).     self expect: 10.0 meter actual: ( camera center x ).      self expect: 20.0 meter actual: ( camera center y ).      self expect: 30.0 meter actual: ( camera center z ).   "A camera has an orientation."   camera pitch: (-10 degrees).   self expect: ( HumMeasure ) actual: ( camera pitch class ).   self expect: ( #radian ) actual: ( camera pitch units ).   self expect: ( 10 degrees negated ) actual: ( camera pitch ).   "Camera views scene"   camera scene: scene.</pre><h3>Hum-X -- H3dViewPortTests &gt;&gt; test120ProjectScenePointToCameraViewPort</h3><pre>test120ProjectScenePointToCameraViewPort   |  camera  scenePoint viewPoint |   "A camera is a 3d-object with dimensions of ..."   camera := H3dCamera depth: 0.40 meter height: 0.20 meter width: 0.30 meter.   self expect: ( HumVector newFrom: { 0.0 meter. 0.0 meter. 0.0 meter. } ) actual: ( camera center ).   "For this test the orientation is level with no yaw."   self expect: (0.0 radian) actual: ( camera pitch ).   self expect: (0.0 radian) actual: ( camera roll ).   self expect: (0.0 radian) actual: ( camera yaw ).   "Test private method ..."   scenePoint := HumVector newFrom: { 1.0 meter. 10.0 meter. 2.0 meter. }.   viewPoint := camera projectScenePointToScreenPoint: scenePoint.    self expect: (HumVector newFrom: { 0.04 meter. 10.0 meter. 0.08 meter. })  actual: viewPoint .</pre><h3>Hum-X -- H3dViewPortTests &gt;&gt; test130PitchCamera</h3><pre>test130PitchCamera   |  camera  scenePoint viewPoint |   "A camera is a 3d-object with dimensions of ..."   camera := H3dCamera depth: 0.40 meter height: 0.20 meter width: 0.30 meter.   self expect: ( HumVector newFrom: { 0.0 meter. 0.0 meter. 0.0 meter. } ) actual: ( camera center ).   "For this test the orientation is level with no yaw."   self expect: (0.0 radian) actual: ( camera pitch ).   self expect: (0.0 radian) actual: ( camera roll ).   self expect: (0.0 radian) actual: ( camera yaw ).   "Test private method ..."   scenePoint := HumVector newFrom: { 1.0 meter. 10.0 meter. 2.0 meter. }.   viewPoint := camera projectScenePointToScreenPoint: scenePoint.    self expect: (HumVector newFrom: { 0.04 meter. 10.0 meter. 0.08 meter. })  actual: viewPoint.   "Pitch the camera up a little."   camera pitch: ( 0.01 / 0.40 ) arcTan radian.   viewPoint := camera projectScenePointToScreenPoint: scenePoint.    self expect: (HumVector newFrom: { 0.03981 meter. 10.047 meter. 0.06965 meter. })  actual: viewPoint.</pre><h3>Hum-X -- H3dViewPortTests &gt;&gt; test140RollCamera</h3><pre>test140RollCamera   |  camera  scenePoint viewPoint |   "A camera is a 3d-object with dimensions of ..."   camera := H3dCamera depth: 0.40 meter height: 0.20 meter width: 0.30 meter.   self expect: ( HumVector newFrom: { 0.0 meter. 0.0 meter. 0.0 meter. } ) actual: ( camera center ).   "For this test the orientation is level with no yaw."   self expect: (0.0 radian) actual: ( camera pitch ).   self expect: (0.0 radian) actual: ( camera roll ).   self expect: (0.0 radian) actual: ( camera yaw ).   "Test private method ..."   scenePoint := HumVector newFrom: { 1.0 meter. 10.0 meter. 2.0 meter. }.   viewPoint := camera projectScenePointToScreenPoint: scenePoint.    self expect: (HumVector newFrom: { 0.04 meter. 10.0 meter. 0.08 meter. })  actual: viewPoint.   "Roll the camera 90 degrees."   camera roll: (Float pi/2.0) radian.   viewPoint := camera projectScenePointToScreenPoint: scenePoint.    self expect: (HumVector newFrom: { 0.08 meter. 10.0 meter. -0.04 meter. }) actual: viewPoint.</pre><h3>Hum-X -- H3dViewPortTests &gt;&gt; test150YawCamera</h3><pre>test150YawCamera   |  camera  scenePoint viewPoint |   "A camera is a 3d-object with dimensions of ..."   camera := H3dCamera depth: 0.40 meter height: 0.20 meter width: 0.30 meter.   self expect: ( HumVector newFrom: { 0.0 meter. 0.0 meter. 0.0 meter. } ) actual: ( camera center ).   "For this test the orientation is level with no yaw."   self expect: (0.0 radian) actual: ( camera pitch ).   self expect: (0.0 radian) actual: ( camera roll ).   self expect: (0.0 radian) actual: ( camera yaw ).   "Test private method ..."   scenePoint := HumVector newFrom: { 1.0 meter. 10.0 meter. 2.0 meter. }.   viewPoint := camera projectScenePointToScreenPoint: scenePoint.    self expect: (HumVector newFrom: { 0.04 meter. 10.0 meter. 0.08 meter. })  actual: viewPoint.   "Yaw the camera a little."   camera yaw: ( 0.01 / 0.40 ) arcTan radian.   viewPoint := camera projectScenePointToScreenPoint: scenePoint.    self expect: (HumVector newFrom: { 0.050125 meter. 9.972 meter. 0.080226 meter. })  actual: viewPoint.</pre><h3>Hum-X -- H3dViewPortTests &gt;&gt; test160TranslateCamera</h3><pre>test160TranslateCamera   |  camera  scenePoint viewPoint |   "A camera is a 3d-object with dimensions of ..."   camera := H3dCamera depth: 0.40 meter height: 0.20 meter width: 0.30 meter.   self expect: ( HumVector newFrom: { 0.0 meter. 0.0 meter. 0.0 meter. } ) actual: ( camera center ).   "For this test the orientation is level with no yaw."   self expect: (0.0 radian) actual: ( camera pitch ).   self expect: (0.0 radian) actual: ( camera roll ).   self expect: (0.0 radian) actual: ( camera yaw ).   "Test private method ..."   scenePoint := HumVector newFrom: { 1.0 meter. 10.0 meter. 2.0 meter. }.   viewPoint := camera projectScenePointToScreenPoint: scenePoint.    self expect: (HumVector newFrom: { 0.04 meter. 10.0 meter. 0.08 meter. })  actual: viewPoint.   "Yaw the camera a little."   camera center: (HumVector newFrom: { 1.0 meter. 0.0 meter. 0.0 meter. }).   viewPoint := camera projectScenePointToScreenPoint: scenePoint.    self expect: (HumVector newFrom: { 0.0 meter. 10.0 meter. 0.08 meter. })  actual: viewPoint.</pre><h3>Hum-X -- H3dViewPortTests &gt;&gt; test210CreateViewPort</h3><pre>test210CreateViewPort   "A viewport is a view on a scene via a camera in the scene."   | viewport camera scene scenePoint viewPoint |   viewport := H3dViewPort new.   "A viewport is mapped onto a surface."   viewport origin: 10@10 extent: 1600@900. "See: Rectangle&gt;&gt;origin:extent:"   "A viewport scales the camera image."   viewport scale: 100 px per: 1 centimeter.   self expect: ( HumMeasure quantity: 100*100 units: #px per: #meter ) actual: ( 100 px / 1 centimeter).   self expect: ( 100 px / 1 centimeter ) actual: ( viewport scale ).   "A viewport is attached to a camera in a scene."   camera := H3dCamera depth: 0.40 meter height: 0.20 meter width: 0.30 meter.   scene := H3dObject newAssemblyFromParts: { camera }.   camera scene: scene.   viewport camera: camera.   "A viewport maps points in the camera image to points in the viewport image."   scenePoint := (HumVector newFrom:{ 1.0 meter. 10.0 meter. 2.0 meter. }).   viewPoint := viewport mapScenePoint: scenePoint.   self expect: (HumVector newFrom: { 400 px. (10.0*100*100) px. 800 px. }) actual: viewPoint.   "How much distance does a pixel cover at y distance?"   self expect: ( 2.5 millimeter ) actual: ( viewport resolutionAt: 10.0 meter ). </pre><h3>Hum-X -- H3dViewPort &gt;&gt; camera:</h3><pre>camera: anH3dCamera    "The viewport is attached to this camera."   camera := anH3dCamera.</pre><h3>Hum-X -- H3dViewPort &gt;&gt; mapScenePoint:</h3><pre>mapScenePoint: aScenePoint    "Map scene point to camera image, camera image to my image."   | viewPoint cameraPoint |   self assert: (aScenePoint isKindOf: HumVector).   "The camera returns nil if the point is not visible on its screen, and so do we."   cameraPoint := camera projectScenePointToScreenPoint: aScenePoint.   cameraPoint ifNil: [ ^nil ].   "TODO: Returning nil as a signal is generally a bad idea."   "One of the problems with returning nil, is that the point may be the start of a line."   "Another problem is that I will have to screen for nils in all of the down-stream code."   viewPoint := cameraPoint * scale.   ^viewPoint.      </pre><h3>Hum-X -- H3dViewPort &gt;&gt; origin:extent:</h3><pre>origin: pointOrigin extent: pointExtent     "What is my origin and extent in container coordinates and pixel metrics?"   self assert: ( pointOrigin isKindOf: Point ).   self assert: ( pointOrigin x isKindOf: Integer ). "pixel (px) units are assumed."   self assert: ( pointOrigin y isKindOf: Integer ). "pixel (px) units are assumed."   self assert: ( pointExtent isKindOf: Point ).   self assert: ( pointExtent x isKindOf: Integer ). "pixel (px) units are assumed."   self assert: ( pointExtent y isKindOf: Integer ). "pixel (px) units are assumed."   self assert: ( pointExtent x &gt; 0 ). "Extent is non-negative / positive-definite."   self assert: ( pointExtent y &gt; 0 ). "Extent is non-negative / positive-definite."   "As a practival matter, viewports dimensions need to be in the hundreds."      rectangle := Rectangle origin: pointOrigin extent: pointExtent. </pre><h3>Hum-X -- H3dViewPort &gt;&gt; resolutionAt:</h3><pre>resolutionAt: aDistance   "What is the resolution per pixel at given distance"   | d dsdy resolution |   self assert: ( scale isNotNil ).   self assert: ( aDistance isKindOf: HumMeasure ).   d := (1 pixel) / scale. " px / (px/mm) ==&gt; px * mm / px ==&gt; mm"   dsdy := d / (camera depth).  " mm / mm ==&gt; a scalar"   resolution := aDistance * dsdy.   ^resolution.</pre><h3>Hum-X -- H3dViewPort &gt;&gt; scale</h3><pre>scale   ^scale ifNil: [ Error signal: 'This viewport`s scale has not been set yet.' ].</pre><h3>Hum-X -- H3dViewPort &gt;&gt; scale:per:</h3><pre>scale: measureNumerator per: measureDenominator    "Multiply camera screen coordinates by scale to get my coordinates."   "Expect the numerator to be pixels    and the denominator to be a length that translates to SI length units."   self assert: ( measureNumerator dimensions = ( 1 px ) dimensions ).   self assert: ( measureDenominator dimensions = ( 1 centimeter    ) dimensions ).   scale := measureNumerator / measureDenominator.</pre><h3>Hum-X -- HApplication &gt;&gt; handleRequest:</h3><pre>handleRequest: aZnRequest    "Return a response for given request"   | response |   response := myHandler value: aZnRequest.   ^response.</pre><h3>Hum-X -- HApplication &gt;&gt; handler:</h3><pre>handler: aBlockClosure    "Use the block to handle request"   myHandler := aBlockClosure.</pre><h3>Hum-X -- HBaseTests &gt;&gt; test240WorldBaseBacksBlackBoard</h3><pre>test240WorldBaseBacksBlackBoard   "Blackboard calls on World Base to persist events, state-changes."   | event blackboard |      blackboard := HBlackboard new.   blackboard worldBase: HBase new.      event := HEvent who: 'TTester' what: 'named' when: (HTime now)                 where: 'test240WorldBaseBacksBlackBoard'                    why: 'intialize blackboard nouns'.       blackboard putEvent: event.      "Put first name, last name"   blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event.      blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event.      </pre><h3>Hum-X -- HBase &gt;&gt; entities</h3><pre>entities   "Dictionary of (id -&gt; entity)"   ^ entities ifNil: [ entities := Dictionary new ].</pre><h3>Hum-X -- HBase &gt;&gt; events</h3><pre>events   ^events ifNil: [ events := Dictionary new ].</pre><h3>Hum-X -- HBase &gt;&gt; putEntity:attribute:value:event:</h3><pre>putEntity: anEntity attribute: anAttribute value: aValue event: anEvent    "Record entity attribute value"   | entity |   entity := (self entities) at: (anEntity id)                               ifAbsent: [nil].   entity       ifNil: [entity := HEntity title: (anEntity title).                entity id: (anEntity id).         ].      entity attribute: anAttribute value: aValue event: anEvent.   (self entities) at: (anEntity id) put: entity.  </pre><h3>Hum-X -- HBase &gt;&gt; putEvent:</h3><pre>putEvent: anEvent    "Record the given event in my store."   |  |   (self events) at: (anEvent id) put: anEvent.   </pre><h3>Hum-X -- HBlackboardTests &gt;&gt; test140BlackboardSaveFetch</h3><pre>test140BlackboardSaveFetch   "A blackboard records events, noun values"   | value event blackboard |   blackboard := HBlackboard new.   event := HEvent who: 'TTester' what: 'named' when: (HTime now)                 where: 'test140BlackboardSaveFetch'                    why: 'intialize blackboard nouns'.    blackboard putEvent: event.      "Put first name"   blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event.   value := blackboard getEntity: 'tester' attribute: 'first-name'.   "Put last name"   self expect: 'Tessie' actual: value.      blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event.   value := blackboard getEntity: 'tester' attribute: 'last-name'.   self expect: 'Tester' actual: value.   "First name is still there"   value := blackboard getEntity: 'tester' attribute: 'first-name'.   self expect: 'Tessie' actual: value.      </pre><h3>Hum-X -- HBlackboardTests &gt;&gt; test145BlackboardSaveFetchNouns</h3><pre>test145BlackboardSaveFetchNouns   "A blackboard records events, noun values"   | value event blackboard nounValue |   blackboard := HBlackboard new.   event := HEvent who: 'TTester' what: 'named' when: (HTime now)                 where: 'test140BlackboardSaveFetch'                    why: 'intialize blackboard nouns'.    blackboard putEvent: event.      "Put first name"   blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event.   value := blackboard getEntity: 'tester' attribute: 'first-name'.   "Put last name"   self expect: 'Tessie' actual: value.   nounValue := blackboard getNoun: {'tester'. 'first-name'.}.   self expect: value actual: nounValue.      blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event.   value := blackboard getEntity: 'tester' attribute: 'last-name'.   self expect: 'Tester' actual: value.   "First name is still there"   value := blackboard getEntity: 'tester' attribute: 'first-name'.   self expect: 'Tessie' actual: value.      </pre><h3>Hum-X -- HBlackboardTests &gt;&gt; test150BlackboardSaveFetchUpdate</h3><pre>test150BlackboardSaveFetchUpdate   "A blackboard records events, noun values"   | value event1 blackboard event2 |   blackboard := HBlackboard new.   event1 := HEvent who: 'TTester' what: 'named' when: (HTime now)                 where: 'test150BlackboardSaveFetchUpdate'                    why: 'intialize blackboard nouns'.    blackboard putEvent: event1.   blackboard putEntityNamed: 'tester'.   "Put first name"   blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event1.   value := blackboard getEntity: 'tester' attribute: 'first-name'.   "Put last name"   self expect: 'Tessie' actual: value.      blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event1.   value := blackboard getEntity: 'tester' attribute: 'last-name'.   self expect: 'Tester' actual: value.   "First name is still there"   value := blackboard getEntity: 'tester' attribute: 'first-name'.   self expect: 'Tessie' actual: value.   "==========="   event2 := HEvent who: 'TTester' what: 'named' when: (HTime now)                 where: 'test150BlackboardSaveFetchUpdate'                    why: 'update blackboard nouns'.   self assert: ( event2 &gt; event1 ).    blackboard putEvent: event2.   blackboard putEntityNamed: 'tester'.   "Put first name"   blackboard putEntity: 'tester' attribute: 'first-name' value: 'Teddy' event: event2.   value := blackboard getEntity: 'tester' attribute: 'first-name'.   "Put last name"   self expect: 'Teddy' actual: value.      blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tinker' event: event2.   value := blackboard getEntity: 'tester' attribute: 'last-name'.   self expect: 'Tinker' actual: value.   "First name is still there"   value := blackboard getEntity: 'tester' attribute: 'first-name'.   self expect: 'Teddy' actual: value.      </pre><h3>Hum-X -- HBlackboardTests &gt;&gt; test160BlackboardToStream</h3><pre>test160BlackboardToStream   "A blackboard records events, noun values"   | event blackboard |   blackboard := HBlackboard new.   event := HEvent who: 'TTester' what: 'named' when: (HTime now)                 where: 'test140BlackboardSaveFetch'                    why: 'intialize blackboard nouns'.    blackboard putEvent: event.      "Put first name"   blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event.      blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event.      self expect: 'tester:    first-name: Tessie   last-name: Tester'          actual: ( blackboard asStream contents ).      </pre><h3>Hum-X -- HBlackboard &gt;&gt; asStream</h3><pre>asStream   "Show the values in the blackboard on a stream."   | stream |   stream := ReadWriteStream on: ''.   nouns       keysAndValuesDo: [ :k :v |
         (v isKindOf: HEntity)  ifTrue: [ v printOn: stream. ]                   ].   ^stream.      </pre><h3>Hum-X -- HBlackboard &gt;&gt; events</h3><pre>events   ^ events ifNil: [ events := OrderedCollection new.]</pre><h3>Hum-X -- HBlackboard &gt;&gt; getEntity:attribute:</h3><pre>getEntity: anEntity attribute: anAttribute    | result entity |   entity := self getEntityNamed: anEntity.   result := entity getAttribute: anAttribute.   ^result.</pre><h3>Hum-X -- HBlackboard &gt;&gt; getEntityNamed:</h3><pre>getEntityNamed: aNoun    | entity |   entity := self nouns at: aNoun ifAbsent: [ self putEntityNamed: aNoun ].   self assert: (entity isKindOf: HEntity).   ^ entity.</pre><h3>Hum-X -- HBlackboard &gt;&gt; getNoun:</h3><pre>getNoun: aNoun    | value |   value := self nouns at: aNoun.   ^value.</pre><h3>Hum-X -- HBlackboard &gt;&gt; nouns</h3><pre>nouns   ^ nouns ifNil: [ nouns := Dictionary new ].</pre><h3>Hum-X -- HBlackboard &gt;&gt; putEntity:attribute:value:event:</h3><pre>putEntity: anEntity attribute: anAttribute value: aValue event: anEvent    | entity |   entity := self getEntityNamed: anEntity.   entity attribute: anAttribute value: aValue event: anEvent.   self nouns at: {anEntity. anAttribute.} put: aValue.   worldBaseProxy       ifNotNil: [ worldBaseProxy putEntity: entity attribute: anAttribute value: aValue event: anEvent ].</pre><h3>Hum-X -- HBlackboard &gt;&gt; putEntityNamed:</h3><pre>putEntityNamed: aNoun    | entity |   entity := HEntity title: aNoun.   self nouns at: aNoun put: entity.   ^entity.</pre><h3>Hum-X -- HBlackboard &gt;&gt; putEvent:</h3><pre>putEvent: anEvent    self assert: (anEvent isKindOf: HEvent).   self events add: anEvent.   worldBaseProxy       ifNotNil: [ worldBaseProxy putEvent: anEvent ].</pre><h3>Hum-X -- HBlackboard &gt;&gt; worldBase:</h3><pre>worldBase: aWorldBase    "MOCK: Pretend we are persisting values on world base.   "   worldBaseProxy := aWorldBase.</pre><h3>Hum-X -- HClientServerTests &gt;&gt; setUp</h3><pre>setUp   ZnSingleThreadedServer shutDown.   ZnMultiThreadedServer shutDown.   ZnServer shutDown.</pre><h3>Hum-X -- HClientServerTests &gt;&gt; tearDown</h3><pre>tearDown   ZnSingleThreadedServer shutDown.   ZnMultiThreadedServer shutDown.   ZnServer shutDown.</pre><h3>Hum-X -- HClientServerTests &gt;&gt; test110CharacterizeZnHttpClient</h3><pre>test110CharacterizeZnHttpClient   "Characterize ZnHttpClient"   | client settings |   client := ZnHttpClient new.   self expect: ZnHttpClient actual: client class.   "At this point the client has nothing much going on."    self assert: client response isNil.   self assert: client request isNil.   self expect: ZnUserAgentSettings actual: client settings class.   settings := client settings settings.   self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).   self expect: true actual: (settings at: #followRedirect ).   self expect: 7 actual: (settings at: #redirectLimit ).      self expect: 180 actual: (settings at: #timeout ).   self expect: 4 actual: (settings size).   </pre><h3>Hum-X -- HClientServerTests &gt;&gt; test112CharacterizeZnHttpClientNotFound</h3><pre>test112CharacterizeZnHttpClientNotFound   "Characterize ZnHttpClient"   | client settings response responseString |   client := ZnHttpClient new.   self expect: ZnHttpClient actual: client class.   "At this point the client has nothing much going on."    self assert: client response isNil.   self assert: client request isNil.   self expect: ZnUserAgentSettings actual: client settings class.   settings := client settings settings.   self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).   self expect: true actual: (settings at: #followRedirect ).   self expect: 7 actual: (settings at: #redirectLimit ).      self expect: 180 actual: (settings at: #timeout ).   self expect: 4 actual: (settings size).      client url: 'http://localhost:8081/nonesuch'.
  responseString := client get.   self expect: ByteString actual: (responseString class).   self assert: ('Not Found /nonesuch*' matches: responseString ). 
  
  self expect: ZnResponse actual: (client response class).  self expect: ZnUrl actual: (client url class).   self expect: ZnUserAgentSession actual: (client session class).   self expect: ZnUserAgentSettings actual: (client settings class).   self expect: ZnRequest actual: (client request class).   self expect: ZnLogSupport actual: (client log class).   self expect: BlockClosure actual: (client errorHandler class).   self expect: ZnMultiValueDictionary actual: (client params class).   self expect: ZnMultiValueDictionary actual: (client headers class).   self expect: 0 actual: (client headers size).      response := client response.   self expect: ZnResponse actual: (response class).   self expect: 404 actual: (response code).   self expect: 'Not Found' actual: (response statusLine reason).         



   </pre><h3>Hum-X -- HClientServerTests &gt;&gt; test114CharacterizeZnHttpConnected</h3><pre>test114CharacterizeZnHttpConnected   "Characterize ZnHttpClient"   | client settings response responseString |   client := ZnHttpClient new.   self expect: ZnHttpClient actual: client class.   "At this point the client has nothing much going on."    self assert: client response isNil.   self assert: client request isNil.   self expect: ZnUserAgentSettings actual: client settings class.   settings := client settings settings.   self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).   self expect: true actual: (settings at: #followRedirect ).   self expect: 7 actual: (settings at: #redirectLimit ).      self expect: 180 actual: (settings at: #timeout ).   self expect: 4 actual: (settings size).      client url: 'http://localhost:8081'.
  responseString := client get.   self expect: ByteString actual: (responseString class).   "Happens to be there even though I try to shut it down."   self assert: ('*&lt;title&gt;Zinc HTTP Components&lt;/title&gt;*' matches: responseString ). 
  
  self expect: ZnResponse actual: (client response class).  self expect: ZnUrl actual: (client url class).   self expect: ZnUserAgentSession actual: (client session class).   self expect: ZnUserAgentSettings actual: (client settings class).   self expect: ZnRequest actual: (client request class).   self expect: ZnLogSupport actual: (client log class).   self expect: BlockClosure actual: (client errorHandler class).   self expect: ZnMultiValueDictionary actual: (client params class).   self expect: ZnMultiValueDictionary actual: (client headers class).   self expect: 0 actual: (client headers size).      response := client response.   self expect: ZnResponse actual: (response class).   self expect: 200 actual: (response code).   self expect: 'OK' actual: (response statusLine reason).         



   </pre><h3>Hum-X -- HClientServerTests &gt;&gt; test115CharacterizeZnHttpHead</h3><pre>test115CharacterizeZnHttpHead   "Characterize ZnHttpClient"   | client settings response |   client := ZnHttpClient new.   self expect: ZnHttpClient actual: client class.   "At this point the client has nothing much going on."    self assert: client response isNil.   self assert: client request isNil.   self expect: ZnUserAgentSettings actual: client settings class.   settings := client settings settings.   self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).   self expect: true actual: (settings at: #followRedirect ).   self expect: 7 actual: (settings at: #redirectLimit ).      self expect: 180 actual: (settings at: #timeout ).   self expect: 4 actual: (settings size).      client url: 'http://localhost:8080'.
  response := client head. "In this case, we get ZnResponse back instead of ByteString."   self expect: ZnResponse actual: (response class).    
  self expect: ZnResponse actual: (client response class).  self expect: ZnUrl actual: (client url class).   self expect: ZnUserAgentSession actual: (client session class).   self expect: ZnUserAgentSettings actual: (client settings class).   self expect: ZnRequest actual: (client request class).   self expect: ZnLogSupport actual: (client log class).   self expect: BlockClosure actual: (client errorHandler class).   self expect: ZnMultiValueDictionary actual: (client params class).   self expect: ZnMultiValueDictionary actual: (client headers class).   self expect: 0 actual: (client headers size).      response := client response.   self expect: ZnResponse actual: (response class).   self expect: 200 actual: (response code).   self expect: 'OK' actual: (response statusLine reason).         



   </pre><h3>Hum-X -- HClientServerTests &gt;&gt; test116CharacterizeZnHttpConnectExternal</h3><pre>test116CharacterizeZnHttpConnectExternal   "Characterize ZnHttpClient"   | client settings response responseString |      ( NetNameResolver isConnected )       ifFalse: [ Transcript cr; show: 'test116CharacterizeZnHttpConnectExternal - no net';cr.         ^self].   client := ZnHttpClient new.   self expect: ZnHttpClient actual: client class.   "At this point the client has nothing much going on."    self assert: client response isNil.   self assert: client request isNil.   self expect: ZnUserAgentSettings actual: client settings class.   settings := client settings settings.   self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).   self expect: true actual: (settings at: #followRedirect ).   self expect: 7 actual: (settings at: #redirectLimit ).      self expect: 180 actual: (settings at: #timeout ).   self expect: 4 actual: (settings size).      client url: 'http://www.w3.org/Help/search'.
  responseString := client get.   self expect: ByteString actual: (responseString class).   "Happens to be there even though I try to shut it down."   self assert: ('*&lt;title&gt;W3C web site search&lt;/title&gt;*' matches: responseString ). 
  
  self expect: ZnResponse actual: (client response class).  self expect: ZnUrl actual: (client url class).   self expect: ZnUserAgentSession actual: (client session class).   self expect: ZnUserAgentSettings actual: (client settings class).   self expect: ZnRequest actual: (client request class).   self expect: ZnLogSupport actual: (client log class).   self expect: BlockClosure actual: (client errorHandler class).   self expect: ZnMultiValueDictionary actual: (client params class).   self expect: ZnMultiValueDictionary actual: (client headers class).   self expect: 0 actual: (client headers size).      response := client response.   self expect: ZnResponse actual: (response class).   self expect: 200 actual: (response code).   self expect: 'OK' actual: (response statusLine reason).         



   </pre><h3>Hum-X -- HClientServerTests &gt;&gt; test120CharacterizeZnHTTPSocketFacade</h3><pre>test120CharacterizeZnHTTPSocketFacade   "Characterize ZnHttpClient"   | client |   client := ZnHTTPSocketFacade new.   self expect: ZnHTTPSocketFacade actual: client class.   "ZnHTTPSocketFacade is stateless.     It does one-shot calls based on the arguments we pass."   </pre><h3>Hum-X -- HClientServerTests &gt;&gt; test190CharacterizeHClient</h3><pre>test190CharacterizeHClient   "HClient is light wrapper on ZnHTTPSocketFacade."   | client settings |   false ifFalse: [ Transcript cr; show: 'test190CharacterizeHClient is turned off'; cr. ^self].   client := HClient new.   self expect: HClient actual: client class.   "At this point the client has nothing much going on."    self assert: client response isNil.   self assert: client request isNil.   settings := client clientSettings.   self expect: Dictionary actual: settings class.   self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0'                      actual: ( settings at: #agent ).   self expect: true actual: ( settings at: #followRedirect ).   self expect: 7    actual: ( settings at: #redirectLimit ).      self expect: 180  actual: ( settings at: #timeout ).   "That`s all folks!"   self expect: 4 actual: (settings size).</pre><h3>Hum-X -- HClientServerTests &gt;&gt; test210CharacterizeZnServer</h3><pre>test210CharacterizeZnServer   | server |   server := ZnSingleThreadedServer startOn: 8080.   self expect: ZnSingleThreadedServer actual: server class.   self expect: 8080 actual: server port.   self expect: false actual: server log enabled.      server logToTranscript.   self expect: true actual: server log enabled.   self expect: nil actual: server lastRequest.   self expect: nil actual: server lastResponse.   self expect: true actual: server isRunning.   self expect: false actual: server isListening.  "???"      server stop.   self expect: false actual: server isRunning.   </pre><h3>Hum-X -- HClientServerTests &gt;&gt; test211CharacterizeZnServer</h3><pre>test211CharacterizeZnServer   | server |   server := ZnMultiThreadedServer startOn: 8080.   self expect: ZnMultiThreadedServer actual: server class.   self expect: 8080 actual: server port.   self expect: false actual: server log enabled.   server logToTranscript.   self expect: true actual: server log enabled.   self expect: nil actual: server lastRequest.   self expect: nil actual: server lastResponse.   self expect: true actual: server isRunning.   self expect: false actual: server isListening.  "???"      server stop.   self expect: false actual: server isRunning.   </pre><h3>Hum-X -- HClientServerTests &gt;&gt; test212CharacterizeZnHTTPSocketFacadeNotFound</h3><pre>test212CharacterizeZnHTTPSocketFacadeNotFound   "Characterize ZnHttpClient"   | client responseStream |   client := ZnHTTPSocketFacade new.   self expect: ZnHTTPSocketFacade actual: client class.  responseStream := ZnHTTPSocketFacade httpGet: 'http://localhost:8081/test'.   self expect: (ByteString) actual: (responseStream class).   self assert: ('*Not Found*' matches: responseStream).</pre><h3>Hum-X -- HClientServerTests &gt;&gt; test212CharacterizeZnServer</h3><pre>test212CharacterizeZnServer   | server |   server := ZnMultiThreadedServer startOn: 8081.   self expect: ZnMultiThreadedServer actual: server class.   self expect: 8081 actual: server port.   self expect: false actual: server log enabled.   server logToTranscript.   self expect: true actual: server log enabled.   self expect: nil actual: server lastRequest.   self expect: nil actual: server lastResponse.   self expect: true actual: server isRunning.   self expect: false actual: server isListening.  "???"      server stop.   self expect: false actual: server isRunning.   </pre><h3>Hum-X -- HClientServerTests &gt;&gt; test214CharacterizeZnHTTPSocketFacadeConnected</h3><pre>test214CharacterizeZnHTTPSocketFacadeConnected   "Characterize ZnHttpClient"   | client responseStream |   client := ZnHTTPSocketFacade new.   self expect: ZnHTTPSocketFacade actual: client class.  responseStream := ZnHTTPSocketFacade httpGet: 'http://localhost:8081'.   self expect: (RWBinaryOrTextStream) actual: (responseStream class).   self assert: ('*&lt;title&gt;Zinc HTTP Components&lt;/title&gt;*' matches: responseStream contents).</pre><h3>Hum-X -- HClientServerTests &gt;&gt; test216CharacterizeZnHTTPSocketFacadePost</h3><pre>test216CharacterizeZnHTTPSocketFacadePost   "Characterize ZnHttpClient"   | client responseStream dict |   client := ZnHTTPSocketFacade new.   self expect: ZnHTTPSocketFacade actual: client class.      dict := Dictionary newFrom: {'name'-&gt;'tester'.}.  responseStream := ZnHTTPSocketFacade httpPost: 'http://localhost:8081' args: dict accept: ''.   self expect: (RWBinaryOrTextStream) actual: (responseStream class).   self assert: ('*&lt;title&gt;Zinc HTTP Components&lt;/title&gt;*' matches: responseStream contents).</pre><h3>Hum-X -- HClientServerTests &gt;&gt; test220CharacterizeZnServerGetResponse</h3><pre>test220CharacterizeZnServerGetResponse   | server request response |   server := ZnSingleThreadedServer startOn: 80220.      server logToTranscript.      "client := ZnHttpClient new."   request := ZnRequest get: 'http://localhost:80220/test220'.      response := server handleRequest: request.   self expect: ZnResponse actual: ( response class ).   self expect: 404 actual: ( response statusLine code ).   self expect: 'Not Found' actual: ( response statusLine reason ).      server delegate: (HApplication echo).   response := server handleRequest: request.   self expect: ZnResponse actual: ( response class ).   self expect: 200 actual: ( response statusLine code ).   self expect: 'OK' actual: ( response statusLine reason ).   self expect: 'GET.../test220Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80220'       actual: ( response contents ).

   server delegate: nil.  server stop.         </pre><h3>Hum-X -- HClientServerTests &gt;&gt; test221CharacterizeZnServerPutResponse</h3><pre>test221CharacterizeZnServerPutResponse   | server request response |   server := ZnSingleThreadedServer startOn: 80221.      server logToTranscript.      "client := ZnHttpClient new."   request := ZnRequest put: 'http://localhost:80221/test221'.      response := server handleRequest: request.   self expect: ZnResponse actual: ( response class ).   self expect: 404 actual: ( response statusLine code ).   self expect: 'Not Found' actual: ( response statusLine reason ).      server delegate: (HApplication echo).   response := server handleRequest: request.   self expect: ZnResponse actual: ( response class ).   self expect: 200 actual: ( response statusLine code ).   self expect: 'OK' actual: ( response statusLine reason ).   self expect: 'PUT.../test221Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80221'       actual: ( response contents ).
   server delegate: nil.
  server stop.         </pre><h3>Hum-X -- HClientServerTests &gt;&gt; test222CharacterizeZnServerPostResponse</h3><pre>test222CharacterizeZnServerPostResponse   | server request response |   server := ZnSingleThreadedServer startOn: 80222.   server logToTranscript.      "client := ZnHttpClient new."   request := ZnRequest post: 'http://localhost:80222/test222'.      response := server handleRequest: request.   self expect: ZnResponse actual: ( response class ).   self expect: 404 actual: ( response statusLine code ).   self expect: 'Not Found' actual: ( response statusLine reason ).      server delegate: (HApplication echo).   response := server handleRequest: request.   self expect: ZnResponse actual: ( response class ).   self expect: 200 actual: ( response statusLine code ).   self expect: 'OK' actual: ( response statusLine reason ).   self expect: 'POST.../test222POST:  No query arguments seen.Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80222'       actual: ( response contents ).
   server delegate: nil.
  server stop.         </pre><h3>Hum-X -- HClientServerTests &gt;&gt; test223CharacterizeZnServerDeleteResponse</h3><pre>test223CharacterizeZnServerDeleteResponse   | server request response |   server := ZnSingleThreadedServer startOn: 80223.      server logToTranscript.      "client := ZnHttpClient new."   request := ZnRequest delete: 'http://localhost:80223/test223'.      response := server handleRequest: request.   self expect: ZnResponse actual: ( response class ).   self expect: 404 actual: ( response statusLine code ).   self expect: 'Not Found' actual: ( response statusLine reason ).      server delegate: (HApplication echo).   response := server handleRequest: request.   self expect: ZnResponse actual: ( response class ).   self expect: 200 actual: ( response statusLine code ).   self expect: 'OK' actual: ( response statusLine reason ).   self expect: 'DELETE.../test223Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80223'        actual: ( response contents ).
   server delegate: nil.
  server stop.         </pre><h3>Hum-X -- HClientServerTests &gt;&gt; test224CharacterizeZnServerHeadResponse</h3><pre>test224CharacterizeZnServerHeadResponse   | server request response |   server := ZnSingleThreadedServer startOn: 80224.      server logToTranscript.   request := ZnRequest head: 'http://localhost:80224/test224'.      response := server handleRequest: request.   self expect: ZnResponse actual: ( response class ).   self expect: 404 actual: ( response statusLine code ).   self expect: 'Not Found' actual: ( response statusLine reason ).      server delegate: (HApplication echo).   response := server handleRequest: request.   self expect: ZnResponse actual: ( response class ).   self expect: 200 actual: ( response statusLine code ).   self expect: 'OK' actual: ( response statusLine reason ).   self expect: 'HEAD.../test224Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80224'   actual: ( response contents ).
   server delegate: nil.
  server stop.         </pre><h3>Hum-X -- HClientServerTests &gt;&gt; test226CharacterizeZnHTTPSocketFacadePost</h3><pre>test226CharacterizeZnHTTPSocketFacadePost   "Characterize ZnHttpClient"   | client responseStream dict server |      server := ZnMultiThreadedServer startOn: 80226.   server logToTranscript.   server delegate: (HApplication echo).   self ensureBlock: [server stop].   client := ZnHTTPSocketFacade new.   self expect: ZnHTTPSocketFacade actual: client class.      dict := ZnMultiValueDictionary new.   dict at: 'MYNAMEIS' add: 'tester'.     responseStream := ZnHTTPSocketFacade httpPost: 'http://localhost:80226/test226' args: dict accept: 'application/octet-stream'.   server delegate: nil.   server stop.   self expect: (RWBinaryOrTextStream) actual: (responseStream class).   self expect: 'POST.../test226POST: MYNAMEIS=testerX-Zinc-Remote-Address: 127.0.0.1Content-Length: 15User-Agent: Zinc HTTP Components 1.0Connection: closeHost: localhost:80226Content-Type: application/x-www-form-urlencodedAccept: */*'         actual: responseStream contents.         </pre><h3>Hum-X -- HClientServerTests &gt;&gt; test310CharacterizeZnRequest</h3><pre>test310CharacterizeZnRequest   ""   | request headers uri |   request := ZnRequest get: 'http://localhost:8080/test'.   self expect: ZnRequest actual: ( request class ).   self expect: ZnRequestLine actual: ( request requestLine class).   self expect: #GET actual: ( request requestLine method ).      uri := request requestLine uri.   self expect: ZnUrl  actual: ( uri class).   self expect: 'http' actual: ( uri scheme).   self expect: 'localhost' actual: ( uri host).   self expect: 8080   actual: ( uri port).   self expect: nil    actual: ( uri query ).   self expect: #('test') actual: ( uri segments asArray ).         headers := request headers.   self expect: ZnHeaders actual: ( headers class ).   self expect: 'localhost:8080' actual: ( headers at: #host ).   self expect: '*/*' actual: ( headers at: #accept ).   self expect: 'Zinc HTTP Components 1.0' actual: ( headers at: 'User-Agent' ).  self expect: 3 actual: (headers headers size).</pre><h3>Hum-X -- HClientServerTests &gt;&gt; test324CharacterizeZnServerGetResponse</h3><pre>test324CharacterizeZnServerGetResponse   "Use Case: (Single Threaded) Server with HApplication responds to client GET request."   | server response |   server := ZnSingleThreadedServer startOn: 80324.   self ensureBlock: [server stop].      server delegate: (HApplication echo).   response := ZnClient get: 'http://localhost:80324/test324'.
   self expect: ZnResponse actual: ( response class ).   self expect: 200 actual: ( response statusLine code ).   self expect: 'OK' actual: ( response statusLine reason ).   self expect: 'GET /test324X-Zinc-Remote-Address: 127.0.0.1User-Agent: Zinc HTTP Components 1.0Connection: closeHost: localhost:80324Accept: */*'       actual: ( response contents ).  server delegate: nil.   self expect: ZnDefaultServerDelegate actual: (server delegate class).  server stop.               </pre><h3>Hum-X -- HClientServerTests &gt;&gt; test325CharacterizeZnServerGetResponse</h3><pre>test325CharacterizeZnServerGetResponse   "Use Case: (Multi-Threaded) Server with HApplication responds to client GET request."   | server response |   server := ZnMultiThreadedServer startOn: 80325.   self ensureBlock: [server stop].      server delegate: (HApplication echo).   response := ZnClient get: 'http://localhost:80325/test325'.
   self expect: ZnResponse actual: ( response class ).   self expect: 200 actual: ( response statusLine code ).   self expect: 'OK' actual: ( response statusLine reason ).   self expect: 'GET /test325X-Zinc-Remote-Address: 127.0.0.1User-Agent: Zinc HTTP Components 1.0Connection: closeHost: localhost:80325Accept: */*'       actual: ( response contents ).  server delegate: nil.   self expect: ZnDefaultServerDelegate actual: (server delegate class).  server stop.               </pre><h3>Hum-X -- HClientServerTests &gt;&gt; test326CharacterizeZnServerGetResponse</h3><pre>test326CharacterizeZnServerGetResponse   "Use Case: (Multi-Threaded) Server with HApplication responds to HClient GET request."   | server response |   server := ZnMultiThreadedServer startOn: 80326.   self ensureBlock: [server stop].      server delegate: (HApplication echo).   response := HClient get: 'http://localhost:80326/test326'. "HClient is a wrapper on ZnClient."
   self expect: ZnResponse actual: ( response class ).   self expect: 200 actual: ( response statusLine code ).   self expect: 'OK' actual: ( response statusLine reason ).   self expect: 'GET /test326X-Zinc-Remote-Address: 127.0.0.1User-Agent: Zinc HTTP Components 1.0Connection: closeHost: localhost:80326Accept: */*'       actual: ( response contents ).  server delegate: nil.   self expect: ZnDefaultServerDelegate actual: (server delegate class).  server stop.               </pre><h3>Hum-X -- HClient &gt;&gt; clientSettings</h3><pre>clientSettings   self assert: (super settings isKindOf: ZnUserAgentSettings).   ^ super settings settings.</pre><h3>Hum-X -- HEntityTests &gt;&gt; test110EntityHasAttributes</h3><pre>test110EntityHasAttributes   "An entity has one or more attributes"   | entity value |   entity := HEntity new.   "Put first name"   entity attribute: 'first-name' value: 'Tessie'.   value := entity getAttribute: 'first-name'.   "Put last name"   self expect: 'Tessie' actual: value.      entity attribute: 'last-name' value: 'Tester'.   value := entity getAttribute: 'last-name'.   self expect: 'Tester' actual: value.   "First name is still there"   value := entity getAttribute: 'first-name'.   self expect: 'Tessie' actual: value.      </pre><h3>Hum-X -- HEntityTests &gt;&gt; test120SetAttributeValueInEvent</h3><pre>test120SetAttributeValueInEvent   "An entity has one or more attributes"   | entity value event |   event := HEvent who: 'TTester' what: 'named' when: (TimeStamp now)                 where: 'test120SetAttributeValueInEvent'                    why: 'test120SetAttributeValueInEvent'.    entity := HEntity new.   "Put first name"   entity attribute: 'first-name' value: 'Tessie' event: event.   value := entity getAttribute: 'first-name'.   "Put last name"   self expect: 'Tessie' actual: value.      entity attribute: 'last-name' value: 'Tester' event: event.   value := entity getAttribute: 'last-name'.   self expect: 'Tester' actual: value.   "First name is still there"   value := entity getAttribute: 'first-name'.   self expect: 'Tessie' actual: value.      </pre><h3>Hum-X -- HEntityTests &gt;&gt; test125EntityPrintOn</h3><pre>test125EntityPrintOn   "An entity has one or more attributes"   | entity event stream |   event := HEvent who: 'TTester' what: 'named' when: (TimeStamp now)                 where: 'test120SetAttributeValueInEvent'                    why: 'test120SetAttributeValueInEvent'.    entity := HEntity title: 'tester'.   "Put first name"   entity attribute: 'first-name' value: 'Tessie' event: event.      entity attribute: 'last-name' value: 'Tester' event: event.      stream := ReadWriteStream on: ''.   entity printOn: stream.   self expect: 'tester:    first-name: Tessie   last-name: Tester'          actual: ( stream contents ).      </pre><h3>Hum-X -- HEntityTests &gt;&gt; test130UpdateAttributeValueInEvent</h3><pre>test130UpdateAttributeValueInEvent   "An entity has one or more attributes"   | entity value event event2 |   event := HEvent who: 'TTester' what: 'named' when: (TimeStamp now)                 where: 'test130UpdateAttributeValueInEvent'                    why: 'testing entity-initialize attributes'.    entity := HEntity new.   "Put first name"   entity attribute: 'first-name' value: 'Tessie' event: event.   value := entity getAttribute: 'first-name'.   "Put last name"   self expect: 'Tessie' actual: value.      entity attribute: 'last-name' value: 'Tester' event: event.   value := entity getAttribute: 'last-name'.   self expect: 'Tester' actual: value.   "First name is still there"   value := entity getAttribute: 'first-name'.   self expect: 'Tessie' actual: value.   "============"   event2 := HEvent who: 'TTester' what: 'renamed' when: (TimeStamp now)                 where: 'test130UpdateAttributeValueInEvent-rename'                    why: 'testing entity-rename updates attributes'.    entity := HEntity new.   "Put first name"   entity attribute: 'first-name' value: 'Teddy' event: event2.   value := entity getAttribute: 'first-name'.   "Put last name"   self expect: 'Teddy' actual: value.      entity attribute: 'last-name' value: 'Tinker' event: event2.   value := entity getAttribute: 'last-name'.   self expect: 'Tinker' actual: value.   "First name is still there"   value := entity getAttribute: 'first-name'.   self expect: 'Teddy' actual: value.         </pre><h3>Hum-X -- HEntity &gt;&gt; attribute:value:</h3><pre>attribute: anAttributeName value: anAttributeValue    "Initialize entity-attribute value. (No event, no history)   - Use '#attribute:value:event:' to record state-changes.   "   (self attributes) at: anAttributeName put: anAttributeValue.</pre><h3>Hum-X -- HEntity &gt;&gt; attribute:value:event:</h3><pre>attribute: anAttributeType value: aValue event: anEvent    "Record a state-change associated with the given event."   self attributes at: anAttributeType put: aValue.   self history add: { anEvent. anAttributeType. aValue. }.</pre><h3>Hum-X -- HEntity &gt;&gt; attributes</h3><pre>attributes   "Return my dictionary of current attribute values."   ^ attributes ifNil: [ attributes := Dictionary new ].</pre><h3>Hum-X -- HEntity &gt;&gt; getAttribute:</h3><pre>getAttribute: anAttributeName    "What is the value of the given attribute?"   | result |   result := self attributes at: anAttributeName.   ^result.</pre><h3>Hum-X -- HEntity &gt;&gt; history</h3><pre>history   "Return history of state-changes."   ^ history ifNil: [ history := OrderedCollection new].</pre><h3>Hum-X -- HEntity &gt;&gt; id</h3><pre>id   ^ id</pre><h3>Hum-X -- HEntity &gt;&gt; id:</h3><pre>id: aLargePositiveInteger    "Set unique identifier.   - This value may be used to refer to this entity in relationships."   id := aLargePositiveInteger.</pre><h3>Hum-X -- HEntity &gt;&gt; printOn:</h3><pre>printOn: aStream   "Format my data for easy reading.    - Append lines to given stream (expecting aReadWriteStream).   - TODO: Consider using a JSON format instead.   "   | |   "Put my name/title on the stream"   aStream &lt;&lt; (self title) &lt;&lt;  ': ' &lt;&lt; String cr.   "Append indented list of my attribute values to stream."   (self attributes)      keysAndValuesDo:          [ :attr :value |            aStream &lt;&lt; '   ' &lt;&lt;  attr &lt;&lt; ': ' &lt;&lt; value &lt;&lt; String cr.            "TODO: Handle attributes that refer to other entities."         ].      </pre><h3>Hum-X -- HEntity &gt;&gt; title</h3><pre>title   "Entity should be given a contextually unique name (noun)"   ^ title ifNil: [ Error signal: 'unknown entity'].</pre><h3>Hum-X -- HEntity &gt;&gt; title:</h3><pre>title: aString    "Set my title - something appropriate to usage and unique within the context.   Typically a noun (entity type or model component) within a blackboard.   "   title := aString</pre><h3>Hum-X -- HEvent &gt;&gt; ></h3><pre>&gt; otherEvent    | result |   result := (self when) &gt; (otherEvent when).   ^result.</pre><h3>Hum-X -- HEvent &gt;&gt; attributes</h3><pre>attributes   | dict |   dict := (super attributes).   dict      at: 'who' put: who;      at: 'what' put: what;      at: 'when' put: when;      at: 'where' put: where;      at: 'why' put: why.</pre><h3>Hum-X -- HEvent &gt;&gt; id:</h3><pre>id: aLargePositiveInteger    id := aLargePositiveInteger.</pre><h3>Hum-X -- HEvent &gt;&gt; what:</h3><pre>what: aWhat    "What happened? (Relate to business process event.)"   what := aWhat.</pre><h3>Hum-X -- HEvent &gt;&gt; when</h3><pre>when   ^ when</pre><h3>Hum-X -- HEvent &gt;&gt; when:</h3><pre>when: aTimeStamp    "When did the event occur? Real clock or simulated clock"   when := aTimeStamp</pre><h3>Hum-X -- HEvent &gt;&gt; where:</h3><pre>where: aWhere    "Where did event occur? - Test/Simulation/Host/Application/Service"   where := aWhere</pre><h3>Hum-X -- HEvent &gt;&gt; who:</h3><pre>who: aWho    "Who caused the event? - User/Robot/Actor/Test"   who := aWho.</pre><h3>Hum-X -- HEvent &gt;&gt; why:</h3><pre>why: aWhy    "Why did the event occur? - Authorization/JobTicket"   why := aWhy.</pre><h3>Hum-X -- HGlamourTest &gt;&gt; test100ReadMe</h3><pre>test100ReadMe   "This group of tests follows 'Deep into Pharo - chapter 10' "   self skip: 'Just a ReadMe'.</pre><h3>Hum-X -- HGlamourTest &gt;&gt; test110Page192</h3><pre>test110Page192   "Example at page 192"   | browser |   self skip: 'I am finished with this example'.   browser := GLMFinder new.   browser show: [ :a | a list display: #children ].   browser openOn: FileSystem disk root.</pre><h3>Hum-X -- HGlamourTest &gt;&gt; test110Page193a</h3><pre>test110Page193a   "Example at page 193"   | browser |   self skip: 'I am finished with this example'.   browser := GLMFinder new.   browser show: [ :a |       a list           when: #isDirectory;         display: #children;          format: #basename ].   browser openOn: FileSystem disk root.</pre><h3>Hum-X -- HGlamourTest &gt;&gt; test110Page193b</h3><pre>test110Page193b   "Example at page 193"   | browser |   self skip: 'I am finished with this example'.   browser := GLMFinder new.   browser show: [ :a |       a list           when: #isDirectory;         display: #children;          format: #basenameWithIndicator ].   browser openOn: FileSystem disk root.</pre><h3>Hum-X -- HGlamourTest &gt;&gt; test110Page194</h3><pre>test110Page194   "Example at page 194"   | browser |   self skip: 'I am finished with this example'.   browser := GLMFinder new                  variableSizePanes;                  title: 'Navigate file structure';                  yourself.   browser show: [ :a |       a list           when: #isDirectory;         display: [:fileRef | [fileRef children] on: Exception do: [ Array new ] ];         format: #basenameWithIndicator.      a text         when: #isFile;         display: [:fileRef |                      [ fileRef readStream contents]                            on: Exception                            do: ['Cannot display content of file'].                           ].                  ].   browser openOn: FileSystem disk root.</pre><h3>Hum-X -- HTimeTests &gt;&gt; test110timestampIsBigInteger</h3><pre>test110timestampIsBigInteger   ""   | t |   t := HTime timeStamp.   self assert: ( t isKindOf: Integer ).</pre><h3>Hum-X -- HTimeTests &gt;&gt; test120timestampIsUnique</h3><pre>test120timestampIsUnique   ""   | a  n |   n := 1e4.    "n = 1e4 resembles a database transaction rate.    n = 1e5 runs in about 2 seconds.         1e6 requires 20-25 seconds."   a := Array new: n.   ( 1 to: n )      do: [ :i | a at: i put: (HTime timeStamp) ].   self assert: (( a at: 1 ) &lt; ( a at: 2 )).      self assert: (( a at: 1 ) &lt; ( a atRandom )) description: 'Can trip if atRandom happens to pull (a at: 1)'.   self assert: (( a at: 1 ) &lt; ( a at: n )).</pre>