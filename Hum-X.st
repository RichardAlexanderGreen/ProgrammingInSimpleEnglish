ZnHTTPSocketFacade subclass: #HClient	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HClient commentStamp: 'RichardAlexanderGreen 4/21/2015 10:30' prior: 0!the Client simulates client requests.(Primarily in test/simulation context.)!!HClient methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/10/2015 20:00'!clientSettings	self assert: (super settings isKindOf: ZnUserAgentSettings).	^ super settings settings.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HClient class	instanceVariableNames: ''!!HClient class methodsFor: 'message handling' stamp: 'RichardAlexanderGreen 4/16/2015 09:04'!get: aURI	"Send URI as a HTTP GET - return ZnResponse."	| response |	response := ZnClient get: aURI.	^response.! !Object subclass: #HBaseTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HBaseTests commentStamp: 'RichardAlexanderGreen 4/8/2015 12:09' prior: 0!The World Base represents "corporate memory".It records business events and entity attribute values.Use Cases: (There should be at least one test for each use case.)==========Business Events:. Plan Frame post-condition satisfied.. Dialog context changed.Entity Attribute values:. Dialog noun value set by input pattern.. Dialog noun values set by 'Ask view-name'.!!HBaseTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/3/2015 10:19'!test240WorldBaseBacksBlackBoard	"Blackboard calls on World Base to persist events, state-changes."	| event blackboard |		blackboard := HBlackboard new.	blackboard worldBase: HBase new.		event := HEvent who: 'TTester' what: 'named' when: (HTime now)	              where: 'test240WorldBaseBacksBlackBoard' 	                why: 'intialize blackboard nouns'. 		blackboard putEvent: event.		"Put first name, last name"	blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event.		blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event.		! !Object subclass: #HBase	instanceVariableNames: 'events entities'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HBase commentStamp: 'RichardAlexanderGreen 4/9/2015 10:39' prior: 0!The World Base represents "corporate memory".It records business events and entity attribute values.Business Events:. Plan Frame post-condition satisfied. (Plan Coordinator WIP persistence). Dialog context changed.. TODO: Give some thought about relationship (associative entity) instantiation.. . Business-Relationships are typically caused by business actions.. . But: Where is the observer?. . Most such business actions are transactions (buy-sell, bid, subscribe/register, assign).Entity Attribute values:. Dialog noun value set by input pattern. . Dialog noun value set by 'Ask view-name'.Three cases are "dialog-persistence" - providing persistence for a dialog blackboard.Actors that need persistent state may also use a world base component.However, that component does not necessarily need to be the enterprise world base.Different actors may, in effect, live in different worlds.Other persistence mechanisms:. Job-Ticket charges - are handled by bookkeeper - Charges have a different meaning and dynamic than world base.. Actor`s internal state - Example: a robot may perist its internal state (blackboard) separately.. Coordinator state - (Noun blackboard + Plan WIP state). Dispatcher state - (Actor available, busy) !!HBase methodsFor: 'events-registering' stamp: 'RichardAlexanderGreen 4/7/2015 14:34'!putEvent: anEvent 	"Record the given event in my store."	|  |	(self events) at: (anEvent id) put: anEvent.	! !!HBase methodsFor: 'events-registering' stamp: 'RichardAlexanderGreen 4/3/2015 10:31'!putEntity: anEntity attribute: anAttribute value: aValue event: anEvent 	"Record entity attribute value"	| entity |	entity := (self entities) at: (anEntity id) 										ifAbsent: [nil].	entity 		ifNil: [entity := HEntity title: (anEntity title). 			      entity id: (anEntity id).			].		entity attribute: anAttribute value: aValue event: anEvent.	(self entities) at: (anEntity id) put: entity.  ! !!HBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:36'!entities	"Dictionary of (id -> entity)"	^ entities ifNil: [ entities := Dictionary new ].! !!HBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/7/2015 14:34'!events	^events ifNil: [ events := Dictionary new ].! !Object subclass: #HEntityTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HEntityTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/30/2015 09:16'!test110EntityHasAttributes	"An entity has one or more attributes"	| entity value |	entity := HEntity new.	"Put first name"	entity attribute: 'first-name' value: 'Tessie'.	value := entity getAttribute: 'first-name'.	"Put last name"	self expect: 'Tessie' actual: value.		entity attribute: 'last-name' value: 'Tester'.	value := entity getAttribute: 'last-name'.	self expect: 'Tester' actual: value.	"First name is still there"	value := entity getAttribute: 'first-name'.	self expect: 'Tessie' actual: value.		! !!HEntityTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/2/2015 11:23'!test125EntityPrintOn	"An entity has one or more attributes"	| entity event stream |	event := HEvent who: 'TTester' what: 'named' when: (TimeStamp now)	              where: 'test120SetAttributeValueInEvent' 	                why: 'test120SetAttributeValueInEvent'. 	entity := HEntity title: 'tester'.	"Put first name"	entity attribute: 'first-name' value: 'Tessie' event: event.		entity attribute: 'last-name' value: 'Tester' event: event.		stream := ReadWriteStream on: ''.	entity printOn: stream.	self expect: 'tester: 	first-name: Tessie	last-name: Tester' 			actual: ( stream contents ).		! !!HEntityTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/30/2015 09:47'!test120SetAttributeValueInEvent	"An entity has one or more attributes"	| entity value event |	event := HEvent who: 'TTester' what: 'named' when: (TimeStamp now)	              where: 'test120SetAttributeValueInEvent' 	                why: 'test120SetAttributeValueInEvent'. 	entity := HEntity new.	"Put first name"	entity attribute: 'first-name' value: 'Tessie' event: event.	value := entity getAttribute: 'first-name'.	"Put last name"	self expect: 'Tessie' actual: value.		entity attribute: 'last-name' value: 'Tester' event: event.	value := entity getAttribute: 'last-name'.	self expect: 'Tester' actual: value.	"First name is still there"	value := entity getAttribute: 'first-name'.	self expect: 'Tessie' actual: value.		! !!HEntityTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/30/2015 10:26'!test130UpdateAttributeValueInEvent	"An entity has one or more attributes"	| entity value event event2 |	event := HEvent who: 'TTester' what: 'named' when: (TimeStamp now)	              where: 'test130UpdateAttributeValueInEvent' 	                why: 'testing entity-initialize attributes'. 	entity := HEntity new.	"Put first name"	entity attribute: 'first-name' value: 'Tessie' event: event.	value := entity getAttribute: 'first-name'.	"Put last name"	self expect: 'Tessie' actual: value.		entity attribute: 'last-name' value: 'Tester' event: event.	value := entity getAttribute: 'last-name'.	self expect: 'Tester' actual: value.	"First name is still there"	value := entity getAttribute: 'first-name'.	self expect: 'Tessie' actual: value.	"============"	event2 := HEvent who: 'TTester' what: 'renamed' when: (TimeStamp now)	              where: 'test130UpdateAttributeValueInEvent-rename' 	                why: 'testing entity-rename updates attributes'. 	entity := HEntity new.	"Put first name"	entity attribute: 'first-name' value: 'Teddy' event: event2.	value := entity getAttribute: 'first-name'.	"Put last name"	self expect: 'Teddy' actual: value.		entity attribute: 'last-name' value: 'Tinker' event: event2.	value := entity getAttribute: 'last-name'.	self expect: 'Tinker' actual: value.	"First name is still there"	value := entity getAttribute: 'first-name'.	self expect: 'Teddy' actual: value.			! !Object subclass: #HumXReadMe	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HumXReadMe commentStamp: 'RichardAlexanderGreen 4/21/2015 10:15' prior: 0!The Hum-X package contains 'thinking out loud' code.Basically, I am thinking about refactoring the persistence system.My review of current code for world-base, blackboard, entity (HumWorldBase, HumBlackboard, HumEntity)caused me to feel that there was a design problem - those classes did not conform to my expected abstractions.Also: My fondness for "quad" data structure seemed to be skewing the design and the code.So I decided to experiment with a redesign.So far, it appears that giving more strength to the Entity concept seems to simplify blackboard and base.I simplified HTime - making it a singleton that generates unique timestamps as large integers.That seems to be simplifying some of the code.I made Event an explicit class and a subclass of Entity.The who, what, when, where, why attributes of Event are NOT sufficiently well-defined as a methodology for consistently describing a business event.But I am reluctant to abandon the five W`s.  (See HEvent for attempt to stabilize.)!Object subclass: #HClientServerTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HClientServerTests methodsFor: 'Server Characterization Tests' stamp: 'RichardAlexanderGreen 4/10/2015 19:42'!test211CharacterizeZnServer	| server |	server := ZnMultiThreadedServer startOn: 8080.	self expect: ZnMultiThreadedServer actual: server class.	self expect: 8080 actual: server port.	self expect: false actual: server log enabled.	server logToTranscript.	self expect: true actual: server log enabled.	self expect: nil actual: server lastRequest.	self expect: nil actual: server lastResponse.	self expect: true actual: server isRunning.	self expect: false actual: server isListening.  "???"		server stop.	self expect: false actual: server isRunning.	! !!HClientServerTests methodsFor: 'Server Characterization Tests' stamp: 'RichardAlexanderGreen 4/10/2015 22:11'!test210CharacterizeZnServer	| server |	server := ZnSingleThreadedServer startOn: 8080.	self expect: ZnSingleThreadedServer actual: server class.	self expect: 8080 actual: server port.	self expect: false actual: server log enabled.		server logToTranscript.	self expect: true actual: server log enabled.	self expect: nil actual: server lastRequest.	self expect: nil actual: server lastResponse.	self expect: true actual: server isRunning.	self expect: false actual: server isListening.  "???"		server stop.	self expect: false actual: server isRunning.	! !!HClientServerTests methodsFor: 'Server Characterization Tests' stamp: 'RichardAlexanderGreen 4/13/2015 09:03'!test212CharacterizeZnServer	| server |	server := ZnMultiThreadedServer startOn: 8081.	self expect: ZnMultiThreadedServer actual: server class.	self expect: 8081 actual: server port.	self expect: false actual: server log enabled.	server logToTranscript.	self expect: true actual: server log enabled.	self expect: nil actual: server lastRequest.	self expect: nil actual: server lastResponse.	self expect: true actual: server isRunning.	self expect: false actual: server isListening.  "???"		server stop.	self expect: false actual: server isRunning.	! !!HClientServerTests methodsFor: 'Request Characterization Tests' stamp: 'RichardAlexanderGreen 4/10/2015 20:49'!test310CharacterizeZnRequest	""	| request headers uri |	request := ZnRequest get: 'http://localhost:8080/test'.	self expect: ZnRequest actual: ( request class ).	self expect: ZnRequestLine actual: ( request requestLine class).	self expect: #GET actual: ( request requestLine method ).		uri := request requestLine uri.	self expect: ZnUrl  actual: ( uri class).	self expect: 'http' actual: ( uri scheme).	self expect: 'localhost' actual: ( uri host).	self expect: 8080   actual: ( uri port).	self expect: nil    actual: ( uri query ).	self expect: #('test') actual: ( uri segments asArray ).			headers := request headers.	self expect: ZnHeaders actual: ( headers class ).	self expect: 'localhost:8080' actual: ( headers at: #host ).	self expect: '*/*' actual: ( headers at: #accept ).	self expect: 'Zinc HTTP Components 1.0' actual: ( headers at: 'User-Agent' ).  self expect: 3 actual: (headers headers size).! !!HClientServerTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/16/2015 21:36'!setUp	ZnSingleThreadedServer shutDown.	ZnMultiThreadedServer shutDown.	ZnServer shutDown.! !!HClientServerTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/16/2015 21:36'!tearDown	ZnSingleThreadedServer shutDown.	ZnMultiThreadedServer shutDown.	ZnServer shutDown.! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:51'!test325CharacterizeZnServerGetResponse	"Use Case: (Multi-Threaded) Server with HApplication responds to client GET request."	| server response |	server := ZnMultiThreadedServer startOn: 80325.	self ensureBlock: [server stop].		server delegate: (HApplication echo).	response := ZnClient get: 'http://localhost:80325/test325'.
	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'GET /test325X-Zinc-Remote-Address: 127.0.0.1User-Agent: Zinc HTTP Components 1.0Connection: closeHost: localhost:80325Accept: */*'       actual: ( response contents ).  server delegate: nil.	self expect: ZnDefaultServerDelegate actual: (server delegate class).  server stop.					! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 22:10'!test224CharacterizeZnServerHeadResponse	| server request response |	server := ZnSingleThreadedServer startOn: 80224.		server logToTranscript.	request := ZnRequest head: 'http://localhost:80224/test224'.		response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 404 actual: ( response statusLine code ).	self expect: 'Not Found' actual: ( response statusLine reason ).		server delegate: (HApplication echo).	response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'HEAD.../test224Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80224'   actual: ( response contents ).
	server delegate: nil.
  server stop.			! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 22:10'!test221CharacterizeZnServerPutResponse	| server request response |	server := ZnSingleThreadedServer startOn: 80221.		server logToTranscript.		"client := ZnHttpClient new."	request := ZnRequest put: 'http://localhost:80221/test221'.		response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 404 actual: ( response statusLine code ).	self expect: 'Not Found' actual: ( response statusLine reason ).		server delegate: (HApplication echo).	response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'PUT.../test221Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80221'       actual: ( response contents ).
	server delegate: nil.
  server stop.			! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:49'!test324CharacterizeZnServerGetResponse	"Use Case: (Single Threaded) Server with HApplication responds to client GET request."	| server response |	server := ZnSingleThreadedServer startOn: 80324.	self ensureBlock: [server stop].		server delegate: (HApplication echo).	response := ZnClient get: 'http://localhost:80324/test324'.
	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'GET /test324X-Zinc-Remote-Address: 127.0.0.1User-Agent: Zinc HTTP Components 1.0Connection: closeHost: localhost:80324Accept: */*'       actual: ( response contents ).  server delegate: nil.	self expect: ZnDefaultServerDelegate actual: (server delegate class).  server stop.					! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 22:09'!test220CharacterizeZnServerGetResponse	| server request response |	server := ZnSingleThreadedServer startOn: 80220.		server logToTranscript.		"client := ZnHttpClient new."	request := ZnRequest get: 'http://localhost:80220/test220'.		response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 404 actual: ( response statusLine code ).	self expect: 'Not Found' actual: ( response statusLine reason ).		server delegate: (HApplication echo).	response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'GET.../test220Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80220'       actual: ( response contents ).

	server delegate: nil.  server stop.			! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 22:10'!test223CharacterizeZnServerDeleteResponse	| server request response |	server := ZnSingleThreadedServer startOn: 80223.		server logToTranscript.		"client := ZnHttpClient new."	request := ZnRequest delete: 'http://localhost:80223/test223'.		response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 404 actual: ( response statusLine code ).	self expect: 'Not Found' actual: ( response statusLine reason ).		server delegate: (HApplication echo).	response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'DELETE.../test223Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80223'        actual: ( response contents ).
	server delegate: nil.
  server stop.			! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:51'!test326CharacterizeZnServerGetResponse	"Use Case: (Multi-Threaded) Server with HApplication responds to HClient GET request."	| server response |	server := ZnMultiThreadedServer startOn: 80326.	self ensureBlock: [server stop].		server delegate: (HApplication echo).	response := HClient get: 'http://localhost:80326/test326'. "HClient is a wrapper on ZnClient."
	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'GET /test326X-Zinc-Remote-Address: 127.0.0.1User-Agent: Zinc HTTP Components 1.0Connection: closeHost: localhost:80326Accept: */*'       actual: ( response contents ).  server delegate: nil.	self expect: ZnDefaultServerDelegate actual: (server delegate class).  server stop.					! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 22:10'!test222CharacterizeZnServerPostResponse	| server request response |	server := ZnSingleThreadedServer startOn: 80222.	server logToTranscript.		"client := ZnHttpClient new."	request := ZnRequest post: 'http://localhost:80222/test222'.		response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 404 actual: ( response statusLine code ).	self expect: 'Not Found' actual: ( response statusLine reason ).		server delegate: (HApplication echo).	response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'POST.../test222POST:  No query arguments seen.Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80222'       actual: ( response contents ).
	server delegate: nil.
  server stop.			! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:46'!test216CharacterizeZnHTTPSocketFacadePost	"Characterize ZnHttpClient"	| client responseStream dict |	client := ZnHTTPSocketFacade new.	self expect: ZnHTTPSocketFacade actual: client class.		dict := Dictionary newFrom: {'name'->'tester'.}.  responseStream := ZnHTTPSocketFacade httpPost: 'http://localhost:8081' args: dict accept: ''.	self expect: (RWBinaryOrTextStream) actual: (responseStream class).	self assert: ('*<title>Zinc HTTP Components</title>*' matches: responseStream contents).! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:46'!test214CharacterizeZnHTTPSocketFacadeConnected	"Characterize ZnHttpClient"	| client responseStream |	client := ZnHTTPSocketFacade new.	self expect: ZnHTTPSocketFacade actual: client class.  responseStream := ZnHTTPSocketFacade httpGet: 'http://localhost:8081'.	self expect: (RWBinaryOrTextStream) actual: (responseStream class).	self assert: ('*<title>Zinc HTTP Components</title>*' matches: responseStream contents).! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 09:41'!test120CharacterizeZnHTTPSocketFacade	"Characterize ZnHttpClient"	| client |	client := ZnHTTPSocketFacade new.	self expect: ZnHTTPSocketFacade actual: client class.	"ZnHTTPSocketFacade is stateless. 	 It does one-shot calls based on the arguments we pass."	! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:46'!test212CharacterizeZnHTTPSocketFacadeNotFound	"Characterize ZnHttpClient"	| client responseStream |	client := ZnHTTPSocketFacade new.	self expect: ZnHTTPSocketFacade actual: client class.  responseStream := ZnHTTPSocketFacade httpGet: 'http://localhost:8081/test'.	self expect: (ByteString) actual: (responseStream class).	self assert: ('*Not Found*' matches: responseStream).! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 10:05'!test116CharacterizeZnHttpConnectExternal	"Characterize ZnHttpClient"	| client settings response responseString |		( NetNameResolver isConnected ) 		ifFalse: [ Transcript cr; show: 'test116CharacterizeZnHttpConnectExternal - no net';cr.			^self].	client := ZnHttpClient new.	self expect: ZnHttpClient actual: client class.	"At this point the client has nothing much going on." 	self assert: client response isNil.	self assert: client request isNil.	self expect: ZnUserAgentSettings actual: client settings class.	settings := client settings settings.	self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).	self expect: true actual: (settings at: #followRedirect ).	self expect: 7 actual: (settings at: #redirectLimit ).		self expect: 180 actual: (settings at: #timeout ).	self expect: 4 actual: (settings size).		client url: 'http://www.w3.org/Help/search'.
  responseString := client get.	self expect: ByteString actual: (responseString class).	"Happens to be there even though I try to shut it down."	self assert: ('*<title>W3C web site search</title>*' matches: responseString ). 
  
  self expect: ZnResponse actual: (client response class).  self expect: ZnUrl actual: (client url class).	self expect: ZnUserAgentSession actual: (client session class).	self expect: ZnUserAgentSettings actual: (client settings class).	self expect: ZnRequest actual: (client request class).	self expect: ZnLogSupport actual: (client log class).	self expect: BlockClosure actual: (client errorHandler class).	self expect: ZnMultiValueDictionary actual: (client params class).	self expect: ZnMultiValueDictionary actual: (client headers class).	self expect: 0 actual: (client headers size).		response := client response.	self expect: ZnResponse actual: (response class).	self expect: 200 actual: (response code).	self expect: 'OK' actual: (response statusLine reason).			



	! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:45'!test112CharacterizeZnHttpClientNotFound	"Characterize ZnHttpClient"	| client settings response responseString |	client := ZnHttpClient new.	self expect: ZnHttpClient actual: client class.	"At this point the client has nothing much going on." 	self assert: client response isNil.	self assert: client request isNil.	self expect: ZnUserAgentSettings actual: client settings class.	settings := client settings settings.	self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).	self expect: true actual: (settings at: #followRedirect ).	self expect: 7 actual: (settings at: #redirectLimit ).		self expect: 180 actual: (settings at: #timeout ).	self expect: 4 actual: (settings size).		client url: 'http://localhost:8081/nonesuch'.
  responseString := client get.	self expect: ByteString actual: (responseString class).	self assert: ('Not Found /nonesuch*' matches: responseString ). 
  
  self expect: ZnResponse actual: (client response class).  self expect: ZnUrl actual: (client url class).	self expect: ZnUserAgentSession actual: (client session class).	self expect: ZnUserAgentSettings actual: (client settings class).	self expect: ZnRequest actual: (client request class).	self expect: ZnLogSupport actual: (client log class).	self expect: BlockClosure actual: (client errorHandler class).	self expect: ZnMultiValueDictionary actual: (client params class).	self expect: ZnMultiValueDictionary actual: (client headers class).	self expect: 0 actual: (client headers size).		response := client response.	self expect: ZnResponse actual: (response class).	self expect: 404 actual: (response code).	self expect: 'Not Found' actual: (response statusLine reason).			



	! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 09:58'!test190CharacterizeHClient	"HClient is light wrapper on ZnHTTPSocketFacade."	| client settings |	false ifFalse: [ Transcript cr; show: 'test190CharacterizeHClient is turned off'; cr. ^self].	client := HClient new.	self expect: HClient actual: client class.	"At this point the client has nothing much going on." 	self assert: client response isNil.	self assert: client request isNil.	settings := client clientSettings.	self expect: Dictionary actual: settings class.	self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' 	                  actual: ( settings at: #agent ).	self expect: true actual: ( settings at: #followRedirect ).	self expect: 7    actual: ( settings at: #redirectLimit ).		self expect: 180  actual: ( settings at: #timeout ).	"That`s all folks!!"	self expect: 4 actual: (settings size).! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:46'!test114CharacterizeZnHttpConnected	"Characterize ZnHttpClient"	| client settings response responseString |	client := ZnHttpClient new.	self expect: ZnHttpClient actual: client class.	"At this point the client has nothing much going on." 	self assert: client response isNil.	self assert: client request isNil.	self expect: ZnUserAgentSettings actual: client settings class.	settings := client settings settings.	self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).	self expect: true actual: (settings at: #followRedirect ).	self expect: 7 actual: (settings at: #redirectLimit ).		self expect: 180 actual: (settings at: #timeout ).	self expect: 4 actual: (settings size).		client url: 'http://localhost:8081'.
  responseString := client get.	self expect: ByteString actual: (responseString class).	"Happens to be there even though I try to shut it down."	self assert: ('*<title>Zinc HTTP Components</title>*' matches: responseString ). 
  
  self expect: ZnResponse actual: (client response class).  self expect: ZnUrl actual: (client url class).	self expect: ZnUserAgentSession actual: (client session class).	self expect: ZnUserAgentSettings actual: (client settings class).	self expect: ZnRequest actual: (client request class).	self expect: ZnLogSupport actual: (client log class).	self expect: BlockClosure actual: (client errorHandler class).	self expect: ZnMultiValueDictionary actual: (client params class).	self expect: ZnMultiValueDictionary actual: (client headers class).	self expect: 0 actual: (client headers size).		response := client response.	self expect: ZnResponse actual: (response class).	self expect: 200 actual: (response code).	self expect: 'OK' actual: (response statusLine reason).			



	! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/15/2015 14:08'!test110CharacterizeZnHttpClient	"Characterize ZnHttpClient"	| client settings |	client := ZnHttpClient new.	self expect: ZnHttpClient actual: client class.	"At this point the client has nothing much going on." 	self assert: client response isNil.	self assert: client request isNil.	self expect: ZnUserAgentSettings actual: client settings class.	settings := client settings settings.	self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).	self expect: true actual: (settings at: #followRedirect ).	self expect: 7 actual: (settings at: #redirectLimit ).		self expect: 180 actual: (settings at: #timeout ).	self expect: 4 actual: (settings size).	! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/15/2015 14:09'!test115CharacterizeZnHttpHead	"Characterize ZnHttpClient"	| client settings response |	client := ZnHttpClient new.	self expect: ZnHttpClient actual: client class.	"At this point the client has nothing much going on." 	self assert: client response isNil.	self assert: client request isNil.	self expect: ZnUserAgentSettings actual: client settings class.	settings := client settings settings.	self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).	self expect: true actual: (settings at: #followRedirect ).	self expect: 7 actual: (settings at: #redirectLimit ).		self expect: 180 actual: (settings at: #timeout ).	self expect: 4 actual: (settings size).		client url: 'http://localhost:8080'.
  response := client head. "In this case, we get ZnResponse back instead of ByteString."	self expect: ZnResponse actual: (response class).	 
  self expect: ZnResponse actual: (client response class).  self expect: ZnUrl actual: (client url class).	self expect: ZnUserAgentSession actual: (client session class).	self expect: ZnUserAgentSettings actual: (client settings class).	self expect: ZnRequest actual: (client request class).	self expect: ZnLogSupport actual: (client log class).	self expect: BlockClosure actual: (client errorHandler class).	self expect: ZnMultiValueDictionary actual: (client params class).	self expect: ZnMultiValueDictionary actual: (client headers class).	self expect: 0 actual: (client headers size).		response := client response.	self expect: ZnResponse actual: (response class).	self expect: 200 actual: (response code).	self expect: 'OK' actual: (response statusLine reason).			



	! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 22:14'!test226CharacterizeZnHTTPSocketFacadePost	"Characterize ZnHttpClient"	| client responseStream dict server |		server := ZnMultiThreadedServer startOn: 80226.	server logToTranscript.	server delegate: (HApplication echo).	self ensureBlock: [server stop].	client := ZnHTTPSocketFacade new.	self expect: ZnHTTPSocketFacade actual: client class.		dict := ZnMultiValueDictionary new.	dict at: 'MYNAMEIS' add: 'tester'.	  responseStream := ZnHTTPSocketFacade httpPost: 'http://localhost:80226/test226' args: dict accept: 'application/octet-stream'.	server delegate: nil.	server stop.	self expect: (RWBinaryOrTextStream) actual: (responseStream class).	self expect: 'POST.../test226POST: MYNAMEIS=testerX-Zinc-Remote-Address: 127.0.0.1Content-Length: 15User-Agent: Zinc HTTP Components 1.0Connection: closeHost: localhost:80226Content-Type: application/x-www-form-urlencodedAccept: */*'			actual: responseStream contents.			! !Object subclass: #HTime	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HTime commentStamp: 'RichardAlexanderGreen 4/21/2015 10:33' prior: 0!HTime is a singleton whose purpose is to return a unique time-stamp.The time-stamp is monotonically increasing over time.It is guranteed unique within the context where the singleton executes.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HTime class	instanceVariableNames: 'clock'!!HTime class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 10:32'!reset	clock := 0.! !!HTime class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/31/2015 21:15'!now	^ self timeStamp.! !!HTime class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:48'!seconds	"Return number of seconds since beginning of epoc"	| ticks tickDays tickSeconds seconds |	ticks := TimeStamp now asUTC ticks copy.	tickDays := ticks at: 1.	tickSeconds := ticks at: 2.	"	tickNanos := ticks at: 3.	self assert: (tickNanos = 0).	"	"WARNING: tickNanos is not really nano-seconds. 	 The actual meaning depends on context.	 Context = TimeStamp class and Operating System implementation."		seconds := ( tickDays * 86400 ) + tickSeconds. 	^seconds! !!HTime class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:47'!timeStamp	"Return a large positive integer representing the number of nanoseconds since ..."	| priorClock microSeconds |	priorClock := clock. "Clock is CLASS VARIABLE"	microSeconds := 0. "Replace this if you find something that works."	clock := ( ( self seconds ) * 1e6 ) + microSeconds. 	[ clock <= priorClock ] 		whileTrue: [ clock := priorClock + 1 ]. "We can get away with this because of nanos implementation."	"If you tinker with this method, call (HTime reset) to reset clock to zero/nil."	^clock. ! !!HTime class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:45'!new	self shouldNotImplement.! !Object subclass: #HEntity	instanceVariableNames: 'attributes history title id'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HEntity commentStamp: 'RichardAlexanderGreen 4/3/2015 10:08' prior: 0!Represent an entity instance in data.Instance Variables:	attributes	<Dictionary> - a dictionary of (attributeName -> attributeValue).	history	<OrderedCollection> - a sequence of state-change records.	title	<String>       - a locally unique noun naming this entity. (blackboard context)	id	    <LargeInteger> - a globally unique identifier for this entity. (world-base context)!!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 09:44'!getAttribute: anAttributeName 	"What is the value of the given attribute?"	| result |	result := self attributes at: anAttributeName.	^result.! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:38'!id	^ id! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 09:48'!id: aLargePositiveInteger 	"Set unique identifier.	- This value may be used to refer to this entity in relationships."	id := aLargePositiveInteger.! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 09:44'!attributes	"Return my dictionary of current attribute values."	^ attributes ifNil: [ attributes := Dictionary new ].! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 09:39'!attribute: anAttributeType value: aValue event: anEvent 	"Record a state-change associated with the given event."	self attributes at: anAttributeType put: aValue.	self history add: { anEvent. anAttributeType. aValue. }.! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 09:43'!attribute: anAttributeName value: anAttributeValue 	"Initialize entity-attribute value. (No event, no history)	- Use '#attribute:value:event:' to record state-changes.	"	(self attributes) at: anAttributeName put: anAttributeValue.! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:00'!printOn: aStream	"Format my data for easy reading. 	- Append lines to given stream (expecting aReadWriteStream).	- TODO: Consider using a JSON format instead.	"	| |	"Put my name/title on the stream"	aStream << (self title) <<  ': ' << String cr.	"Append indented list of my attribute values to stream."	(self attributes)		keysAndValuesDo: 			[ :attr :value |				aStream << '	' <<  attr << ': ' << value << String cr.				"TODO: Handle attributes that refer to other entities."			].		! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:27'!title	"Entity should be given a contextually unique name (noun)"	^ title ifNil: [ Error signal: 'unknown entity'].! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 09:45'!history	"Return history of state-changes."	^ history ifNil: [ history := OrderedCollection new].! !!HEntity methodsFor: 'associating' stamp: 'RichardAlexanderGreen 4/3/2015 10:02'!title: aString 	"Set my title - something appropriate to usage and unique within the context.	Typically a noun (entity type or model component) within a blackboard.	"	title := aString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HEntity class	instanceVariableNames: ''!!HEntity class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/2/2015 11:31'!title: aString 	"Return an instance with that title/name"	| instance |	instance := self basicNew.	instance title: aString.	instance id: (HTime timeStamp).	^instance.! !HEntity subclass: #HEvent	instanceVariableNames: 'who what where why when'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HEvent commentStamp: 'RichardAlexanderGreen 4/9/2015 10:27' prior: 0!a business event (not to be confused with a data event)	Events serve as a kind of log. Events give data values a business (causality) context.'		instance		id: (HTime timeStamp); "Unique identifier."		who: aWho;				"who is associated with the cause - e.g. client-id/actor-id"		what: aWhat; 		"What is happening - e.g. Action statement"		where: aWhere;  	"Where: a host"		why: aWhy;				"Why: a job or seesion"		when: aTimeStamp. "Observer`s clock. May be simulator clock."'Although data events may be the framework`s way of remembering/recording a business event,the two concepts should not be confused.In the run-time framework,business-events are automatically recorded when:- a post-condition is satisfied in a running plan.- a client/user provides a value for a noun- - via "Ask view-name"- - by matching parameters in a vignette pattern.- an action procedure executes a 'giving' instruction. (Perhaps this should be limited in some way.)Examples:- Post-condition satisfied.- - who: client-id  what: post-condition  where: host-URI  why: job-id (top-goal, client, authorization)- Instruction giving persistent noun-value.- - who: actor-id   what: instruction     where: host-URI  why: job-id- Noun value entered.- - who: client-id  what: vignette        where: host-URI  why: session-id - - who: client-id  what: view            where: host-URI  why: session-id  !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:38'!when: aTimeStamp 	"When did the event occur? Real clock or simulated clock"	when := aTimeStamp! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:40'!who: aWho 	"Who caused the event? - User/Robot/Actor/Test"	who := aWho.! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:39'!where: aWhere 	"Where did event occur? - Test/Simulation/Host/Application/Service"	where := aWhere! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:42'!why: aWhy 	"Why did the event occur? - Authorization/JobTicket"	why := aWhy.! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:35'!id: aLargePositiveInteger 	id := aLargePositiveInteger.! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/7/2015 14:40'!attributes	| dict |	dict := (super attributes).	dict		at: 'who' put: who;		at: 'what' put: what;		at: 'when' put: when;		at: 'where' put: where;		at: 'why' put: why.! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/30/2015 10:40'!when	^ when! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:38'!what: aWhat 	"What happened? (Relate to business process event.)"	what := aWhat.! !!HEvent methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 3/30/2015 10:39'!> otherEvent 	| result |	result := (self when) > (otherEvent when).	^result.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HEvent class	instanceVariableNames: ''!!HEvent class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/21/2015 10:25'!who: aWho what: aWhat when: aTimeStamp where: aWhere why: aWhy  	| instance |	instance := self basicNew.	instance		who: aWho;				"Who is associated with the event? - client-id/actor-id"		what: aWhat; 			"What is happening? - statement / vignette / view"		when: aTimeStamp; 	"Observer`s clock. May be simulator clock."		where: aWhere;  		"Where? - a host-URI"		why: aWhy;				"Why?   - a job ticket or session identifier"		id: (HTime timeStamp). "Unique identifier for the event."	^instance.
"Examples:- Post-condition satisfied.- - who: client-id  what: post-condition  where: host-URI  why: job-id (top-goal, client, originating-session-id)- Instruction giving persistent noun-value.- - who: actor-id   what: instruction     where: host-URI  why: job-id- Noun value/s entered.- - who: client-id  what: vignette+pattern        where: host-URI  why: session-id - - who: client-id  what: vignette+view            where: host-URI  why: session-id See: Class documentation."! !HEntity subclass: #HEntityType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HEntityType commentStamp: 'RichardAlexanderGreen 4/8/2015 13:10' prior: 0!An Entity-Type instance holds meta-data.	The type of an entity-type is named by a noun in the ontology.	The attributes of an entity-type are identified in the ontology.	The data-type of the attributes are identified in the ontology. (Default is string when there is no supertype).Currently, the ontology does not contain user-interface (scribe) *hints* such as - field-width          (Calculated at 90% statistic.)- required attributes  (We could add a base-ontology type called 'required-value'.)- immutable attributes (We could add a base-ontology type called 'immutable-value'.)- natural key          (We could add a base-ontology type called 'natural-key'.)       - ranges for measure, date, or timestamp values. (Should we add annotations to dictionary notation?)- Default ordering (natural key?) on sets and bags. - Help data - explaining how the entity and its attributes are to be interpreted (data entered)- - Comment: Help probably should be provided by separate views rather than meta-data. But this can be argued.Consider:- Should supertype attributes be displayed above subtype attributes?*** The functions identified above can be handled in ontology, and do not require a separate class. ***!HumTestCase subclass: #HGlamourTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HGlamourTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/23/2015 16:19'!test110Page193b	"Example at page 193"	| browser |	self skip: 'I am finished with this example'.	browser := GLMFinder new.	browser show: [ :a | 		a list 		    when: #isDirectory;			display: #children; 			format: #basenameWithIndicator ].	browser openOn: FileSystem disk root.! !!HGlamourTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/23/2015 16:14'!test100ReadMe	"This group of tests follows 'Deep into Pharo - chapter 10' "	self skip: 'Just a ReadMe'.! !!HGlamourTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/23/2015 16:19'!test110Page193a	"Example at page 193"	| browser |	self skip: 'I am finished with this example'.	browser := GLMFinder new.	browser show: [ :a | 		a list 		    when: #isDirectory;			display: #children; 			format: #basename ].	browser openOn: FileSystem disk root.! !!HGlamourTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/23/2015 16:18'!test110Page194	"Example at page 194"	| browser |	self skip: 'I am finished with this example'.	browser := GLMFinder new						variableSizePanes;						title: 'Navigate file structure';						yourself.	browser show: [ :a | 		a list 		    when: #isDirectory;			display: [:fileRef | [fileRef children] on: Exception do: [ Array new ] ];			format: #basenameWithIndicator.		a text			when: #isFile;			display: [:fileRef | 							[ fileRef readStream contents] 									on: Exception 									do: ['Cannot display content of file'].									].						].	browser openOn: FileSystem disk root.! !!HGlamourTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/23/2015 16:12'!test110Page192	"Example at page 192"	| browser |	self skip: 'I am finished with this example'.	browser := GLMFinder new.	browser show: [ :a | a list display: #children ].	browser openOn: FileSystem disk root.! !Object subclass: #HApplication	instanceVariableNames: 'myHandler'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HApplication commentStamp: 'RichardAlexanderGreen 4/21/2015 10:26' prior: 0!An application instance handles HTTP requests.!!HApplication methodsFor: 'message handling' stamp: 'RichardAlexanderGreen 4/10/2015 21:14'!handleRequest: aZnRequest 	"Return a response for given request"	| response |	response := myHandler value: aZnRequest.	^response.! !!HApplication methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2015 21:12'!handler: aBlockClosure 	"Use the block to handle request"	myHandler := aBlockClosure.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HApplication class	instanceVariableNames: ''!!HApplication class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/16/2015 22:19'!echo	"Return an instance of myself handles request by echoing it."	| instance |		instance := self basicNew.	instance handler: [:request |  			| entity  response stream string |			stream := ReadWriteStream on: ''.			stream 				nextPutAll: ( request requestLine method  );			  nextPutAll: '...';			  nextPutAll: ( request requestLine uri pathPrintString).			(request requestLine method sameAs: 'POST') 				ifTrue: [ "Show POST and query"					stream nextPutAll: (String cr); nextPutAll: 'POST: '.					(request requestLine uri query isNil) 						ifTrue: [stream << ' No query arguments seen.']						ifFalse:[request requestLine uri queryDo: [:k :v | stream nextPutAll: (k, '=', v, '  ') ].							]					].						string := stream contents.			(string trimBoth size > 0) ifFalse: [string:= 'Method and URI not seen in echo.'].			(request headers) keysAndValuesDo: [:k :v | string := string, String cr, k,': ',v ].			entity := ZnStringEntity text: string.  		  response := ZnResponse ok: entity.		  response.		  ].	^instance.! !Object subclass: #HBlackboardTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HBlackboardTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/31/2015 22:44'!test145BlackboardSaveFetchNouns	"A blackboard records events, noun values"	| value event blackboard nounValue |	blackboard := HBlackboard new.	event := HEvent who: 'TTester' what: 'named' when: (HTime now)	              where: 'test140BlackboardSaveFetch' 	                why: 'intialize blackboard nouns'. 	blackboard putEvent: event.		"Put first name"	blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event.	value := blackboard getEntity: 'tester' attribute: 'first-name'.	"Put last name"	self expect: 'Tessie' actual: value.	nounValue := blackboard getNoun: {'tester'. 'first-name'.}.	self expect: value actual: nounValue.		blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event.	value := blackboard getEntity: 'tester' attribute: 'last-name'.	self expect: 'Tester' actual: value.	"First name is still there"	value := blackboard getEntity: 'tester' attribute: 'first-name'.	self expect: 'Tessie' actual: value.		! !!HBlackboardTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/31/2015 22:35'!test140BlackboardSaveFetch	"A blackboard records events, noun values"	| value event blackboard |	blackboard := HBlackboard new.	event := HEvent who: 'TTester' what: 'named' when: (HTime now)	              where: 'test140BlackboardSaveFetch' 	                why: 'intialize blackboard nouns'. 	blackboard putEvent: event.		"Put first name"	blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event.	value := blackboard getEntity: 'tester' attribute: 'first-name'.	"Put last name"	self expect: 'Tessie' actual: value.		blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event.	value := blackboard getEntity: 'tester' attribute: 'last-name'.	self expect: 'Tester' actual: value.	"First name is still there"	value := blackboard getEntity: 'tester' attribute: 'first-name'.	self expect: 'Tessie' actual: value.		! !!HBlackboardTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/31/2015 21:14'!test150BlackboardSaveFetchUpdate	"A blackboard records events, noun values"	| value event1 blackboard event2 |	blackboard := HBlackboard new.	event1 := HEvent who: 'TTester' what: 'named' when: (HTime now)	              where: 'test150BlackboardSaveFetchUpdate' 	                why: 'intialize blackboard nouns'. 	blackboard putEvent: event1.	blackboard putEntityNamed: 'tester'.	"Put first name"	blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event1.	value := blackboard getEntity: 'tester' attribute: 'first-name'.	"Put last name"	self expect: 'Tessie' actual: value.		blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event1.	value := blackboard getEntity: 'tester' attribute: 'last-name'.	self expect: 'Tester' actual: value.	"First name is still there"	value := blackboard getEntity: 'tester' attribute: 'first-name'.	self expect: 'Tessie' actual: value.	"==========="	event2 := HEvent who: 'TTester' what: 'named' when: (HTime now)	              where: 'test150BlackboardSaveFetchUpdate' 	                why: 'update blackboard nouns'.	self assert: ( event2 > event1 ). 	blackboard putEvent: event2.	blackboard putEntityNamed: 'tester'.	"Put first name"	blackboard putEntity: 'tester' attribute: 'first-name' value: 'Teddy' event: event2.	value := blackboard getEntity: 'tester' attribute: 'first-name'.	"Put last name"	self expect: 'Teddy' actual: value.		blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tinker' event: event2.	value := blackboard getEntity: 'tester' attribute: 'last-name'.	self expect: 'Tinker' actual: value.	"First name is still there"	value := blackboard getEntity: 'tester' attribute: 'first-name'.	self expect: 'Teddy' actual: value.		! !!HBlackboardTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/2/2015 10:06'!test160BlackboardToStream	"A blackboard records events, noun values"	| event blackboard |	blackboard := HBlackboard new.	event := HEvent who: 'TTester' what: 'named' when: (HTime now)	              where: 'test140BlackboardSaveFetch' 	                why: 'intialize blackboard nouns'. 	blackboard putEvent: event.		"Put first name"	blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event.		blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event.		self expect: 'tester: 	first-name: Tessie	last-name: Tester' 			actual: ( blackboard asStream contents ).		! !Object subclass: #HTimeTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HTimeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/31/2015 22:20'!test110timestampIsBigInteger	""	| t |	t := HTime timeStamp.	self assert: ( t isKindOf: Integer ).! !!HTimeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/2/2015 11:17'!test120timestampIsUnique	""	| a  n |	n := 1e4. 	"n = 1e4 resembles a database transaction rate.	 n = 1e5 runs in about 2 seconds. 	     1e6 requires 20-25 seconds."	a := Array new: n.	( 1 to: n )		do: [ :i | a at: i put: (HTime timeStamp) ].	self assert: (( a at: 1 ) < ( a at: 2 )).		self assert: (( a at: 1 ) < ( a atRandom )) description: 'Can trip if atRandom happens to pull (a at: 1)'.	self assert: (( a at: 1 ) < ( a at: n )).! !Object subclass: #HBlackboard	instanceVariableNames: 'events nouns clock worldBaseProxy'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HBlackboard commentStamp: 'RichardAlexanderGreen 4/21/2015 10:28' prior: 0!A Blackboard stores entity data in memory.It persists data via a world base (HBase).!!HBlackboard methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 4/2/2015 09:44'!asStream	"Show the values in the blackboard on a stream."	| stream |	stream := ReadWriteStream on: ''.	nouns 		keysAndValuesDo: [ :k :v |
			(v isKindOf: HEntity)  ifTrue: [ v printOn: stream. ] 						].	^stream.		! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/30/2015 10:12'!nouns	^ nouns ifNil: [ nouns := Dictionary new ].! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/30/2015 10:31'!getNoun: aNoun 	| value |	value := self nouns at: aNoun.	^value.! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:37'!putEntity: anEntity attribute: anAttribute value: aValue event: anEvent 	| entity |	entity := self getEntityNamed: anEntity.	entity attribute: anAttribute value: aValue event: anEvent.	self nouns at: {anEntity. anAttribute.} put: aValue.	worldBaseProxy 		ifNotNil: [ worldBaseProxy putEntity: entity attribute: anAttribute value: aValue event: anEvent ].! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 09:46'!putEntityNamed: aNoun 	| entity |	entity := HEntity title: aNoun.	self nouns at: aNoun put: entity.	^entity.! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/30/2015 10:06'!events	^ events ifNil: [ events := OrderedCollection new.]! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/31/2015 21:18'!getEntityNamed: aNoun 	| entity |	entity := self nouns at: aNoun ifAbsent: [ self putEntityNamed: aNoun ].	self assert: (entity isKindOf: HEntity).	^ entity.! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:13'!putEvent: anEvent 	self assert: (anEvent isKindOf: HEvent).	self events add: anEvent.	worldBaseProxy 		ifNotNil: [ worldBaseProxy putEvent: anEvent ].! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/30/2015 10:27'!getEntity: anEntity attribute: anAttribute 	| result entity |	entity := self getEntityNamed: anEntity.	result := entity getAttribute: anAttribute.	^result.! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:41'!worldBase: aWorldBase 	"MOCK: Pretend we are persisting values on world base.	"	worldBaseProxy := aWorldBase.! !Object subclass: #HGlamour	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!HEntity subclass: #HRelation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HRelation commentStamp: 'RichardAlexanderGreen 4/9/2015 09:27' prior: 0!A Relation is an "associative entity". It is identifiable and real-world.An "associative entity" differs from a "kernal entity"   in that two or more of its required-attributes are "role-type".The attribute-name of a role-type attribute names the relationship role.The attribute-value of a role-type attribute is an entity-identifier.. TODO: Give some thought about relationship (associative entity) instantiation.. Business-Relationships are typically caused by business actions.. . But: Where is the observer?. Most such business actions are transactions (buy-sell, bid, subscribe/register, assign).. . We record and track such transactional events because they represent contracts and opportunities.. Subtypes of Party and Person are often roles in such contracts.. . e.g. Customer, Worker, Supplier, Subscriber, User.. Subtypes of Order represent work-in-progress or fulfilled contracts.. . e.g. Sales-Order Purchase-Order Work-Order Requisition Option!