Object subclass: #HBlackboard	instanceVariableNames: 'events nouns clock worldBaseProxy'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HBlackboard commentStamp: 'RichardAlexanderGreen 4/21/2015 10:28' prior: 0!A Blackboard stores entity data in memory.It persists data via a world base (HBase).!!HBlackboard methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 4/2/2015 09:44'!asStream	"Show the values in the blackboard on a stream."	| stream |	stream := ReadWriteStream on: ''.	nouns 		keysAndValuesDo: [ :k :v |
			(v isKindOf: HEntity)  ifTrue: [ v printOn: stream. ] 						].	^stream.		! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:13'!putEvent: anEvent 	self assert: (anEvent isKindOf: HEvent).	self events add: anEvent.	worldBaseProxy 		ifNotNil: [ worldBaseProxy putEvent: anEvent ].! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:41'!worldBase: aWorldBase 	"MOCK: Pretend we are persisting values on world base.	"	worldBaseProxy := aWorldBase.! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:37'!putEntity: anEntity attribute: anAttribute value: aValue event: anEvent 	| entity |	entity := self getEntityNamed: anEntity.	entity attribute: anAttribute value: aValue event: anEvent.	self nouns at: {anEntity. anAttribute.} put: aValue.	worldBaseProxy 		ifNotNil: [ worldBaseProxy putEntity: entity attribute: anAttribute value: aValue event: anEvent ].! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/30/2015 10:06'!events	^ events ifNil: [ events := OrderedCollection new.]! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/30/2015 10:31'!getNoun: aNoun 	| value |	value := self nouns at: aNoun.	^value.! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/30/2015 10:12'!nouns	^ nouns ifNil: [ nouns := Dictionary new ].! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 09:46'!putEntityNamed: aNoun 	| entity |	entity := HEntity title: aNoun.	self nouns at: aNoun put: entity.	^entity.! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/31/2015 21:18'!getEntityNamed: aNoun 	| entity |	entity := self nouns at: aNoun ifAbsent: [ self putEntityNamed: aNoun ].	self assert: (entity isKindOf: HEntity).	^ entity.! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/30/2015 10:27'!getEntity: anEntity attribute: anAttribute 	| result entity |	entity := self getEntityNamed: anEntity.	result := entity getAttribute: anAttribute.	^result.! !Object subclass: #HClientServerTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HClientServerTests commentStamp: 'RichardAlexanderGreen 7/19/2015 09:16' prior: 0!NOTE: This test suite is currently disabled by making the supertype "Object" instead of "TestCase".!!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:46'!test214CharacterizeZnHTTPSocketFacadeConnected	"Characterize ZnHttpClient"	| client responseStream |	client := ZnHTTPSocketFacade new.	self expect: ZnHTTPSocketFacade actual: client class.  responseStream := ZnHTTPSocketFacade httpGet: 'http://localhost:8081'.	self expect: (RWBinaryOrTextStream) actual: (responseStream class).	self assert: ('*<title>Zinc HTTP Components</title>*' matches: responseStream contents).! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/15/2015 14:08'!test110CharacterizeZnHttpClient	"Characterize ZnHttpClient"	| client settings |	client := ZnHttpClient new.	self expect: ZnHttpClient actual: client class.	"At this point the client has nothing much going on." 	self assert: client response isNil.	self assert: client request isNil.	self expect: ZnUserAgentSettings actual: client settings class.	settings := client settings settings.	self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).	self expect: true actual: (settings at: #followRedirect ).	self expect: 7 actual: (settings at: #redirectLimit ).		self expect: 180 actual: (settings at: #timeout ).	self expect: 4 actual: (settings size).	! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 09:58'!test190CharacterizeHClient	"HClient is light wrapper on ZnHTTPSocketFacade."	| client settings |	false ifFalse: [ Transcript cr; show: 'test190CharacterizeHClient is turned off'; cr. ^self].	client := HClient new.	self expect: HClient actual: client class.	"At this point the client has nothing much going on." 	self assert: client response isNil.	self assert: client request isNil.	settings := client clientSettings.	self expect: Dictionary actual: settings class.	self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' 	                  actual: ( settings at: #agent ).	self expect: true actual: ( settings at: #followRedirect ).	self expect: 7    actual: ( settings at: #redirectLimit ).		self expect: 180  actual: ( settings at: #timeout ).	"That`s all folks!!"	self expect: 4 actual: (settings size).! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:46'!test216CharacterizeZnHTTPSocketFacadePost	"Characterize ZnHttpClient"	| client responseStream dict |	client := ZnHTTPSocketFacade new.	self expect: ZnHTTPSocketFacade actual: client class.		dict := Dictionary newFrom: {'name'->'tester'.}.  responseStream := ZnHTTPSocketFacade httpPost: 'http://localhost:8081' args: dict accept: ''.	self expect: (RWBinaryOrTextStream) actual: (responseStream class).	self assert: ('*<title>Zinc HTTP Components</title>*' matches: responseStream contents).! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:46'!test212CharacterizeZnHTTPSocketFacadeNotFound	"Characterize ZnHttpClient"	| client responseStream |	client := ZnHTTPSocketFacade new.	self expect: ZnHTTPSocketFacade actual: client class.  responseStream := ZnHTTPSocketFacade httpGet: 'http://localhost:8081/test'.	self expect: (ByteString) actual: (responseStream class).	self assert: ('*Not Found*' matches: responseStream).! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:45'!test112CharacterizeZnHttpClientNotFound	"Characterize ZnHttpClient"	| client settings response responseString |	client := ZnHttpClient new.	self expect: ZnHttpClient actual: client class.	"At this point the client has nothing much going on." 	self assert: client response isNil.	self assert: client request isNil.	self expect: ZnUserAgentSettings actual: client settings class.	settings := client settings settings.	self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).	self expect: true actual: (settings at: #followRedirect ).	self expect: 7 actual: (settings at: #redirectLimit ).		self expect: 180 actual: (settings at: #timeout ).	self expect: 4 actual: (settings size).		client url: 'http://localhost:8081/nonesuch'.
  responseString := client get.	self expect: ByteString actual: (responseString class).	self assert: ('Not Found /nonesuch*' matches: responseString ). 
  
  self expect: ZnResponse actual: (client response class).  self expect: ZnUrl actual: (client url class).	self expect: ZnUserAgentSession actual: (client session class).	self expect: ZnUserAgentSettings actual: (client settings class).	self expect: ZnRequest actual: (client request class).	self expect: ZnLogSupport actual: (client log class).	self expect: BlockClosure actual: (client errorHandler class).	self expect: ZnMultiValueDictionary actual: (client params class).	self expect: ZnMultiValueDictionary actual: (client headers class).	self expect: 0 actual: (client headers size).		response := client response.	self expect: ZnResponse actual: (response class).	self expect: 404 actual: (response code).	self expect: 'Not Found' actual: (response statusLine reason).			



	! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/15/2015 14:09'!test115CharacterizeZnHttpHead	"Characterize ZnHttpClient"	| client settings response |	client := ZnHttpClient new.	self expect: ZnHttpClient actual: client class.	"At this point the client has nothing much going on." 	self assert: client response isNil.	self assert: client request isNil.	self expect: ZnUserAgentSettings actual: client settings class.	settings := client settings settings.	self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).	self expect: true actual: (settings at: #followRedirect ).	self expect: 7 actual: (settings at: #redirectLimit ).		self expect: 180 actual: (settings at: #timeout ).	self expect: 4 actual: (settings size).		client url: 'http://localhost:8080'.
  response := client head. "In this case, we get ZnResponse back instead of ByteString."	self expect: ZnResponse actual: (response class).	 
  self expect: ZnResponse actual: (client response class).  self expect: ZnUrl actual: (client url class).	self expect: ZnUserAgentSession actual: (client session class).	self expect: ZnUserAgentSettings actual: (client settings class).	self expect: ZnRequest actual: (client request class).	self expect: ZnLogSupport actual: (client log class).	self expect: BlockClosure actual: (client errorHandler class).	self expect: ZnMultiValueDictionary actual: (client params class).	self expect: ZnMultiValueDictionary actual: (client headers class).	self expect: 0 actual: (client headers size).		response := client response.	self expect: ZnResponse actual: (response class).	self expect: 200 actual: (response code).	self expect: 'OK' actual: (response statusLine reason).			



	! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:46'!test114CharacterizeZnHttpConnected	"Characterize ZnHttpClient"	| client settings response responseString |	client := ZnHttpClient new.	self expect: ZnHttpClient actual: client class.	"At this point the client has nothing much going on." 	self assert: client response isNil.	self assert: client request isNil.	self expect: ZnUserAgentSettings actual: client settings class.	settings := client settings settings.	self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).	self expect: true actual: (settings at: #followRedirect ).	self expect: 7 actual: (settings at: #redirectLimit ).		self expect: 180 actual: (settings at: #timeout ).	self expect: 4 actual: (settings size).		client url: 'http://localhost:8081'.
  responseString := client get.	self expect: ByteString actual: (responseString class).	"Happens to be there even though I try to shut it down."	self assert: ('*<title>Zinc HTTP Components</title>*' matches: responseString ). 
  
  self expect: ZnResponse actual: (client response class).  self expect: ZnUrl actual: (client url class).	self expect: ZnUserAgentSession actual: (client session class).	self expect: ZnUserAgentSettings actual: (client settings class).	self expect: ZnRequest actual: (client request class).	self expect: ZnLogSupport actual: (client log class).	self expect: BlockClosure actual: (client errorHandler class).	self expect: ZnMultiValueDictionary actual: (client params class).	self expect: ZnMultiValueDictionary actual: (client headers class).	self expect: 0 actual: (client headers size).		response := client response.	self expect: ZnResponse actual: (response class).	self expect: 200 actual: (response code).	self expect: 'OK' actual: (response statusLine reason).			



	! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 22:14'!test226CharacterizeZnHTTPSocketFacadePost	"Characterize ZnHttpClient"	| client responseStream dict server |		server := ZnMultiThreadedServer startOn: 80226.	server logToTranscript.	server delegate: (HApplication echo).	self ensureBlock: [server stop].	client := ZnHTTPSocketFacade new.	self expect: ZnHTTPSocketFacade actual: client class.		dict := ZnMultiValueDictionary new.	dict at: 'MYNAMEIS' add: 'tester'.	  responseStream := ZnHTTPSocketFacade httpPost: 'http://localhost:80226/test226' args: dict accept: 'application/octet-stream'.	server delegate: nil.	server stop.	self expect: (RWBinaryOrTextStream) actual: (responseStream class).	self expect: 'POST.../test226POST: MYNAMEIS=testerX-Zinc-Remote-Address: 127.0.0.1Content-Length: 15User-Agent: Zinc HTTP Components 1.0Connection: closeHost: localhost:80226Content-Type: application/x-www-form-urlencodedAccept: */*'			actual: responseStream contents.			! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 10:05'!test116CharacterizeZnHttpConnectExternal	"Characterize ZnHttpClient"	| client settings response responseString |		( NetNameResolver isConnected ) 		ifFalse: [ Transcript cr; show: 'test116CharacterizeZnHttpConnectExternal - no net';cr.			^self].	client := ZnHttpClient new.	self expect: ZnHttpClient actual: client class.	"At this point the client has nothing much going on." 	self assert: client response isNil.	self assert: client request isNil.	self expect: ZnUserAgentSettings actual: client settings class.	settings := client settings settings.	self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).	self expect: true actual: (settings at: #followRedirect ).	self expect: 7 actual: (settings at: #redirectLimit ).		self expect: 180 actual: (settings at: #timeout ).	self expect: 4 actual: (settings size).		client url: 'http://www.w3.org/Help/search'.
  responseString := client get.	self expect: ByteString actual: (responseString class).	"Happens to be there even though I try to shut it down."	self assert: ('*<title>W3C web site search</title>*' matches: responseString ). 
  
  self expect: ZnResponse actual: (client response class).  self expect: ZnUrl actual: (client url class).	self expect: ZnUserAgentSession actual: (client session class).	self expect: ZnUserAgentSettings actual: (client settings class).	self expect: ZnRequest actual: (client request class).	self expect: ZnLogSupport actual: (client log class).	self expect: BlockClosure actual: (client errorHandler class).	self expect: ZnMultiValueDictionary actual: (client params class).	self expect: ZnMultiValueDictionary actual: (client headers class).	self expect: 0 actual: (client headers size).		response := client response.	self expect: ZnResponse actual: (response class).	self expect: 200 actual: (response code).	self expect: 'OK' actual: (response statusLine reason).			



	! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 09:41'!test120CharacterizeZnHTTPSocketFacade	"Characterize ZnHttpClient"	| client |	client := ZnHTTPSocketFacade new.	self expect: ZnHTTPSocketFacade actual: client class.	"ZnHTTPSocketFacade is stateless. 	 It does one-shot calls based on the arguments we pass."	! !!HClientServerTests methodsFor: 'Server Characterization Tests' stamp: 'RichardAlexanderGreen 4/10/2015 19:42'!test211CharacterizeZnServer	| server |	server := ZnMultiThreadedServer startOn: 8080.	self expect: ZnMultiThreadedServer actual: server class.	self expect: 8080 actual: server port.	self expect: false actual: server log enabled.	server logToTranscript.	self expect: true actual: server log enabled.	self expect: nil actual: server lastRequest.	self expect: nil actual: server lastResponse.	self expect: true actual: server isRunning.	self expect: false actual: server isListening.  "???"		server stop.	self expect: false actual: server isRunning.	! !!HClientServerTests methodsFor: 'Server Characterization Tests' stamp: 'RichardAlexanderGreen 4/10/2015 22:11'!test210CharacterizeZnServer	| server |	server := ZnSingleThreadedServer startOn: 8080.	self expect: ZnSingleThreadedServer actual: server class.	self expect: 8080 actual: server port.	self expect: false actual: server log enabled.		server logToTranscript.	self expect: true actual: server log enabled.	self expect: nil actual: server lastRequest.	self expect: nil actual: server lastResponse.	self expect: true actual: server isRunning.	self expect: false actual: server isListening.  "???"		server stop.	self expect: false actual: server isRunning.	! !!HClientServerTests methodsFor: 'Server Characterization Tests' stamp: 'RichardAlexanderGreen 4/13/2015 09:03'!test212CharacterizeZnServer	| server |	server := ZnMultiThreadedServer startOn: 8081.	self expect: ZnMultiThreadedServer actual: server class.	self expect: 8081 actual: server port.	self expect: false actual: server log enabled.	server logToTranscript.	self expect: true actual: server log enabled.	self expect: nil actual: server lastRequest.	self expect: nil actual: server lastResponse.	self expect: true actual: server isRunning.	self expect: false actual: server isListening.  "???"		server stop.	self expect: false actual: server isRunning.	! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 22:09'!test220CharacterizeZnServerGetResponse	| server request response |	server := ZnSingleThreadedServer startOn: 80220.		server logToTranscript.		"client := ZnHttpClient new."	request := ZnRequest get: 'http://localhost:80220/test220'.		response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 404 actual: ( response statusLine code ).	self expect: 'Not Found' actual: ( response statusLine reason ).		server delegate: (HApplication echo).	response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'GET.../test220Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80220'       actual: ( response contents ).

	server delegate: nil.  server stop.			! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 22:10'!test221CharacterizeZnServerPutResponse	| server request response |	server := ZnSingleThreadedServer startOn: 80221.		server logToTranscript.		"client := ZnHttpClient new."	request := ZnRequest put: 'http://localhost:80221/test221'.		response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 404 actual: ( response statusLine code ).	self expect: 'Not Found' actual: ( response statusLine reason ).		server delegate: (HApplication echo).	response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'PUT.../test221Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80221'       actual: ( response contents ).
	server delegate: nil.
  server stop.			! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:51'!test325CharacterizeZnServerGetResponse	"Use Case: (Multi-Threaded) Server with HApplication responds to client GET request."	| server response |	server := ZnMultiThreadedServer startOn: 80325.	self ensureBlock: [server stop].		server delegate: (HApplication echo).	response := ZnClient get: 'http://localhost:80325/test325'.
	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'GET /test325X-Zinc-Remote-Address: 127.0.0.1User-Agent: Zinc HTTP Components 1.0Connection: closeHost: localhost:80325Accept: */*'       actual: ( response contents ).  server delegate: nil.	self expect: ZnDefaultServerDelegate actual: (server delegate class).  server stop.					! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:51'!test326CharacterizeZnServerGetResponse	"Use Case: (Multi-Threaded) Server with HApplication responds to HClient GET request."	| server response |	server := ZnMultiThreadedServer startOn: 80326.	self ensureBlock: [server stop].		server delegate: (HApplication echo).	response := HClient get: 'http://localhost:80326/test326'. "HClient is a wrapper on ZnClient."
	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'GET /test326X-Zinc-Remote-Address: 127.0.0.1User-Agent: Zinc HTTP Components 1.0Connection: closeHost: localhost:80326Accept: */*'       actual: ( response contents ).  server delegate: nil.	self expect: ZnDefaultServerDelegate actual: (server delegate class).  server stop.					! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:49'!test324CharacterizeZnServerGetResponse	"Use Case: (Single Threaded) Server with HApplication responds to client GET request."	| server response |	server := ZnSingleThreadedServer startOn: 80324.	self ensureBlock: [server stop].		server delegate: (HApplication echo).	response := ZnClient get: 'http://localhost:80324/test324'.
	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'GET /test324X-Zinc-Remote-Address: 127.0.0.1User-Agent: Zinc HTTP Components 1.0Connection: closeHost: localhost:80324Accept: */*'       actual: ( response contents ).  server delegate: nil.	self expect: ZnDefaultServerDelegate actual: (server delegate class).  server stop.					! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 22:10'!test224CharacterizeZnServerHeadResponse	| server request response |	server := ZnSingleThreadedServer startOn: 80224.		server logToTranscript.	request := ZnRequest head: 'http://localhost:80224/test224'.		response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 404 actual: ( response statusLine code ).	self expect: 'Not Found' actual: ( response statusLine reason ).		server delegate: (HApplication echo).	response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'HEAD.../test224Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80224'   actual: ( response contents ).
	server delegate: nil.
  server stop.			! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 22:10'!test222CharacterizeZnServerPostResponse	| server request response |	server := ZnSingleThreadedServer startOn: 80222.	server logToTranscript.		"client := ZnHttpClient new."	request := ZnRequest post: 'http://localhost:80222/test222'.		response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 404 actual: ( response statusLine code ).	self expect: 'Not Found' actual: ( response statusLine reason ).		server delegate: (HApplication echo).	response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'POST.../test222POST:  No query arguments seen.Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80222'       actual: ( response contents ).
	server delegate: nil.
  server stop.			! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 22:10'!test223CharacterizeZnServerDeleteResponse	| server request response |	server := ZnSingleThreadedServer startOn: 80223.		server logToTranscript.		"client := ZnHttpClient new."	request := ZnRequest delete: 'http://localhost:80223/test223'.		response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 404 actual: ( response statusLine code ).	self expect: 'Not Found' actual: ( response statusLine reason ).		server delegate: (HApplication echo).	response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'DELETE.../test223Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80223'        actual: ( response contents ).
	server delegate: nil.
  server stop.			! !!HClientServerTests methodsFor: 'Request Characterization Tests' stamp: 'RichardAlexanderGreen 4/10/2015 20:49'!test310CharacterizeZnRequest	""	| request headers uri |	request := ZnRequest get: 'http://localhost:8080/test'.	self expect: ZnRequest actual: ( request class ).	self expect: ZnRequestLine actual: ( request requestLine class).	self expect: #GET actual: ( request requestLine method ).		uri := request requestLine uri.	self expect: ZnUrl  actual: ( uri class).	self expect: 'http' actual: ( uri scheme).	self expect: 'localhost' actual: ( uri host).	self expect: 8080   actual: ( uri port).	self expect: nil    actual: ( uri query ).	self expect: #('test') actual: ( uri segments asArray ).			headers := request headers.	self expect: ZnHeaders actual: ( headers class ).	self expect: 'localhost:8080' actual: ( headers at: #host ).	self expect: '*/*' actual: ( headers at: #accept ).	self expect: 'Zinc HTTP Components 1.0' actual: ( headers at: 'User-Agent' ).  self expect: 3 actual: (headers headers size).! !!HClientServerTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/16/2015 21:36'!setUp	ZnSingleThreadedServer shutDown.	ZnMultiThreadedServer shutDown.	ZnServer shutDown.! !!HClientServerTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/16/2015 21:36'!tearDown	ZnSingleThreadedServer shutDown.	ZnMultiThreadedServer shutDown.	ZnServer shutDown.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HClientServerTests class	instanceVariableNames: ''!!HClientServerTests class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/29/2016 09:48'!isAbstract	^false.! !!HClientServerTests class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/29/2016 11:46'!hasErrorTest	self halt.	^false.! !!HClientServerTests class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/29/2016 11:46'!hasFailedTest	self halt.	^false.! !!HClientServerTests class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/29/2016 11:46'!hasPassedTest	self halt.	^false.! !HumTestCase subclass: #H3dObjectTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 11:05'!test220moveBoxEast	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	box east: 40 meters.	self expect: (40 meter) actual: (box east).	self expect: (35 meter) actual: (box center x).	self expect: 40 meter actual: (box maxX).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/12/2016 10:21'!test335stepVelocityAndPitchRate	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (05 meter) actual: (box east).	self expect: (10 meter) actual: (box north).	self expect: (15 meter) actual: (box top).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	self expect: (05 meter) actual: (box maxX).	self expect: (10 meter) actual: (box maxY).	self expect: (15 meter) actual: (box maxZ).	box pitchRate: (0.25 rps).	box velocity: ( HumVector newFrom: { 100 mps. 100 mps. 100 mps.} ).	box step: (HumMeasure seconds: 1).	self expect: ( HumVector newFrom: {100 meter. 100 meter. 100 meter} ) actual: (box center).	"Expect Y and Z bounds to exchange."	self expect: (105 meter) actual: (box maxX).	self expect: (115 meter) actual: (box maxY).	self expect: (110 meter) actual: (box maxZ).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/14/2016 09:29'!test142rollBox90degreesAboutPivot	"90 degree roll exchanges X and Z"	| box |	box := H3dObject newBoxWidth: (12 meter) length: (22 meter) height: (30 meter).	self expect: ( 06.0 meter ) actual: ( box maxX ).		self expect: ( 11.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box roll: ((Float pi)/ 2.0) radian.	self expect: ( 15.0 meter ) actual: ( box maxX ).		self expect: ( 11.0 meter ) actual: ( box maxY ).		self expect: ( 06.0 meter ) actual: ( box maxZ ).		box pivotPoint: ( HumVector newFrom: { box west. 0.0 meter. 0.0 meter. } ).	self expect: ( 09.0 meter ) actual: ( box maxX ).	"15 - 6 = 9"	self expect: ( 11.0 meter ) actual: ( box maxY ).		self expect: ( 12.0 meter ) actual: ( box maxZ ).		! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/19/2016 15:17'!test712buildRotationAroundY	| rotation xyPoints |	xyPoints := H3dPath newFrom: { 0@0. 11@0. 11@11. 0@11. }.	rotation := H3dObject newRotationAround: #y curve: xyPoints.	rotation numberOfWedges: 4.	"Check that dimension were stored."	self expect: 12 actual: ( rotation polygons size ).	"Check expected bounds"	self expect: ( 11 meter ) actual: ( rotation maxX ).	self expect: ( 11 meter ) actual: ( rotation maxY ).	self expect: ( 11 meter ) actual: ( rotation maxZ ).		self expect: ( -11 meter ) actual: ( rotation minX ).	self expect: ( 0 meter ) actual: ( rotation minY ).	self expect: ( -11 meter ) actual: ( rotation minZ ).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/14/2016 09:38'!test122yawBox90degreesAroundPivot	"90 degree yaw exchanges X and Y"	| box |	box := H3dObject newBoxWidth: (10 meter) length: (22 meter) height: (30 meter).	box pivotPoint: ( HumVector newFrom: { 0.0. 0.0. 0.0 } ).	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 11.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box yaw: ((Float pi)/ 2.0) radian.	self expect: ( 11.0 meter ) actual: ( box maxX ).		self expect: ( 05.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box pivotPoint: ( HumVector newFrom: { box east. 0.0 meter. 0.0 meter. } ).	self expect: ( 16.0 meter ) actual: ( box maxX ).	"5 + 11 = 16"	self expect: (-06.0 meter ) actual: ( box minX ).	"5 - 11 = -6"	self expect: ( 00.0 meter ) actual: ( box maxY ).		self expect: (-10.0 meter) actual: (box minY). 		"0 - 10 = -10"	self expect: ( 15.0 meter ) actual: ( box maxZ ).		self expect: (-15.0 meter ) actual: ( box minZ ).		! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/25/2016 17:51'!test810buildAssembly	| boxA boxB boxC assembly |	boxA := H3dObject newBoxWidth: ( 0.10 meter ) length: ( 0.20 meter)  height: ( 0.30 meter ).	boxB := H3dObject newBoxWidth: ( 1.10 meter ) length: ( 1.20 meter ) height: ( 1.30 meter ).	boxC := H3dObject newBoxWidth: ( 2.10 meter ) length: ( 2.20 meter ) height: ( 2.30 meter ).	assembly := H3dObject newAssemblyFromParts: { boxA. boxB. boxC }.! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/22/2016 15:22'!test110buildBox	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	"Check that dimension were stored."	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		"Volume"	self expect: (HumMeasure quantity: (10*20*30) units: 'cubic meter') actual: (box volume).	"Polygons ==> cube faces in this case"	self expect: 6 actual: (box polygons size).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 11:10'!test225moveBoxWest	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( -5.0 meter) actual: (box west).	box west: 40 meters.	self expect: (40 meter) actual: (box west).	self expect: (45 meter) actual: (box center x).	self expect: 40 meter actual: (box minX).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:09'!test135pitchBox180degrees	"180 degree rotations should leave bounds the same."	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box pitch: ((Float pi)) radian.	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/14/2016 10:49'!test620yawElipsoid90degrees	"90 degree yaw exchanges X and Y"	| elipsoid |	elipsoid := H3dObject newElipsoidWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( 05.0 meter ) actual: ( elipsoid maxX ).		self expect: ( 10.0 meter ) actual: ( elipsoid maxY ).		self expect: ( 15.0 meter ) actual: ( elipsoid maxZ ).		elipsoid yaw: ((Float pi)/ 2.0) radian.	self expect: ( 10.0 meter ) actual: ( elipsoid maxX ).		self expect: ( 05.0 meter ) actual: ( elipsoid maxY ).		self expect: ( 15.0 meter ) actual: ( elipsoid maxZ ).		! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/22/2016 14:39'!test711buildRotationAroundX	| rotation xyPoints |	xyPoints := H3dPath newFrom: { 0@0. 11@0. 11@11. 0@11. }.	rotation := H3dObject newRotationAround: #x curve: xyPoints.	rotation numberOfWedges: 4.	"Check that dimension were stored."	self expect: 12 actual: ( rotation polygons size ).	"Check expected bounds"	self expect: ( 11 meter ) actual: ( rotation maxX ).	self expect: (11 meter ) actual: ( rotation maxY ).	self expect: ( 11 meter ) actual: ( rotation maxZ ).		self expect: ( 0 meter ) actual: ( rotation minX ).	self expect: ( -11 meter ) actual: ( rotation minY ).	self expect: ( -11 meter ) actual: ( rotation minZ ).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/2/2016 13:23'!test820stackBoxes	| boxA boxB boxC assembly clearance totalHeight |	boxA := H3dObject newBoxWidth: ( 0.10 meter ) length: ( 0.20 meter)  height: ( 0.30 meter ).	boxB := H3dObject newBoxWidth: ( 1.10 meter ) length: ( 1.20 meter ) height: ( 1.30 meter ).	boxC := H3dObject newBoxWidth: ( 2.10 meter ) length: ( 2.20 meter ) height: ( 2.30 meter ).	assembly := H3dObject newAssemblyFromParts: { boxA. boxB. boxC }.	"Part positions are relative to the assembly center."	assembly center: (HumVector newFrom: { 10.0 meter. 20.0 meter. 30.0 meter. }).	assembly move: boxA toMyCoordinate: ( HumVector newFrom: { 1.0 meter. 2.0 meter. 3.0 meter. } ).	assembly place: boxB onTopOf: boxA.	assembly place: boxC onTopOf: boxB.	"Check resulting positions in CONTAINER coordinates."	self expect:  ( HumVector newFrom: { 1.0 meter. 2.0 meter. 3.0 meter. } ) actual: ( boxA center ).	self expect: ( boxA center x ) actual: ( boxB center x ).	self expect: ( boxA center y ) actual: ( boxB center y ).	self expect: ( boxA center x ) actual: ( boxC center x ).	self expect: ( boxA center y ) actual: ( boxC center y ).	clearance := 0.001 meter.	self expect: ( ( boxA center z ) +  ( boxA height/2 ) )  actual: ( boxA maxZ ).	self expect: ( boxA maxZ + clearance + ( boxB height ) ) actual: ( boxB maxZ ).	self expect: ( boxB maxZ + clearance + ( boxC height ) ) actual: ( boxC maxZ ).	totalHeight := boxA height + clearance + boxB height + clearance + boxC height.	self expect: ( 3.902 meter ) actual: (totalHeight).	"Check resulting positions in SCENE coordinates"	self expect: ( ( assembly center + boxA center) x + ((boxC width)/2.0 ) ) actual: ( assembly maxX ).	self expect: ( ( assembly center + boxA center) x - ((boxC width)/2.0 )  ) actual: ( assembly minX ).	self expect: ( ( assembly center + boxA center) y + ((boxC length)/2.0 ) ) actual: ( assembly maxY ).	self expect: ( ( assembly center + boxA center) y - ((boxC length)/2.0 ) ) actual: ( assembly minY ).	self expect: ( ( assembly center + boxA center) z - ((boxA height)/2.0 ) ) actual: ( assembly minZ ).	self expect: ( ( assembly center + boxA center) z - ((boxA height)/2.0 ) + totalHeight ) actual: ( assembly maxZ ).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/19/2016 09:16'!test640rollElipsoid90degrees	"90 degree roll exchanges X and Z bounds"	| elipsoid |	elipsoid := H3dObject newElipsoidWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( 05.0 meter ) actual: ( elipsoid maxX ).		self expect: ( 10.0 meter ) actual: ( elipsoid maxY ).		self expect: ( 15.0 meter ) actual: ( elipsoid maxZ ).		elipsoid roll: ((Float pi)/ 2.0) radian.	self expect: ( 15.0 meter ) actual: ( elipsoid maxX ).		self expect: ( 10.0 meter ) actual: ( elipsoid maxY ).		self expect: ( 05.0 meter ) actual: ( elipsoid maxZ ).		! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/19/2016 15:09'!test710buildRotation	| rotation xyPoints |	xyPoints := H3dPath newFrom: { 0@0. 11@0. 11@11. 0@11. }.	rotation := H3dObject newRotationAround: #z curve: xyPoints.	rotation numberOfWedges: 4.	"Check that dimension were stored."	self expect: 12 actual: ( rotation polygons size ).	"Check expected bounds"	self expect: ( 11 meter ) actual: ( rotation maxX ).	self expect: ( 11 meter ) actual: ( rotation maxY ).	self expect: ( 11 meter ) actual: ( rotation maxZ ).		self expect: ( -11 meter ) actual: ( rotation minX ).	self expect: ( -11 meter ) actual: ( rotation minY ).	self expect: ( 0 meter ) actual: ( rotation minZ ).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 10:34'!test230moveBoxNorth	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (10 meter) actual: (box maxY).	box north: 40 meters.	self expect: (40 meter) actual: (box north).	self expect: (30 meter) actual: (box center y).	self expect: (40 meter) actual: (box maxY).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:06'!test310stepVelocity	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	box velocity: (HumVector newFrom: {1 mps. 2 mps. 3 mps.} ).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	box step: (HumMeasure seconds: 1).	self expect: ( HumVector newFrom: {1 meter. 2 meter. 3 meter} ) actual: (box center).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/19/2016 09:15'!test630pitchElipsoid90degrees	"90 degree pitch exchanges Y and Z"	| elipsoid |	elipsoid := H3dObject newElipsoidWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( 05.0 meter ) actual: ( elipsoid maxX ).		self expect: ( 10.0 meter ) actual: ( elipsoid maxY ).		self expect: ( 15.0 meter ) actual: ( elipsoid maxZ ).		elipsoid pitch: ((Float pi)/ 2.0) radian.	self expect: ( 05.0 meter ) actual: ( elipsoid maxX ).		self expect: ( 15.0 meter ) actual: ( elipsoid maxY ).		self expect: ( 10.0 meter ) actual: ( elipsoid maxZ ).		! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/12/2016 10:22'!test345stepVelocityAndRollRate	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (05 meter) actual: (box east).	self expect: (10 meter) actual: (box north).	self expect: (15 meter) actual: (box top).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	self expect: (05 meter) actual: (box maxX).	self expect: (10 meter) actual: (box maxY).	self expect: (15 meter) actual: (box maxZ).	box rollRate: (0.25 rps).	box velocity: ( HumVector newFrom: { 100 mps. 100 mps. 100 mps.} ).	box step: (HumMeasure seconds: 1).	self expect: ( HumVector newFrom: {100 meter. 100 meter. 100 meter} ) actual: (box center).	"Expect X and Z bounds to exchange."	self expect: (115 meter) actual: (box maxX).	self expect: (110 meter) actual: (box maxY).	self expect: (105 meter) actual: (box maxZ).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:05'!test330stepPitchRate	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (05 meter) actual: (box east).	self expect: (10 meter) actual: (box north).	self expect: (15 meter) actual: (box top).	box pitchRate: (0.25 rps).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	box step: (HumMeasure seconds: 1).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	"Expect Y and Z bounds to exchange."	self expect: (05 meter) actual: (box maxX).	self expect: (15 meter) actual: (box maxY).	self expect: (10 meter) actual: (box maxZ).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:09'!test140rollBox90degrees	"90 degree roll exchanges X and Z"	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box roll: ((Float pi)/ 2.0) radian.	self expect: ( 15.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 05.0 meter ) actual: ( box maxZ ).		! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 11:16'!test235moveBoxSouth	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (-10 meter) actual: (box south).	box south: 40 meters.	self expect: (40 meter) actual: (box south).	self expect: (50 meter) actual: (box center y).	self expect: (40 meter) actual: (box minY).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:09'!test130pitchBox90degrees	"90 degree pitch exchanges Y and Z"	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box pitch: ((Float pi)/ 2.0) radian.	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 15.0 meter ) actual: ( box maxY ).		self expect: ( 10.0 meter ) actual: ( box maxZ ).		! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/14/2016 09:44'!test132pitchBox90degreesAboutPivot	"90 degree pitch exchanges Y and Z"	| box |	box := H3dObject newBoxWidth: (10 meter) length: (22 meter) height: (30 meter).	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 11.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box pitch: ((Float pi)/ 2.0) radian.	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 15.0 meter ) actual: ( box maxY ).		self expect: ( 11.0 meter ) actual: ( box maxZ ).		box pivotPoint: (HumVector newFrom: { 0.0 meter. box north. 0.0 meter. } ).	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( -5.0 meter ) actual: ( box minX ).		self expect: ( 26.0 meter ) actual: ( box maxY ).	"11 + 15 = 26"	self expect: ( -4.0 meter ) actual: ( box minY ).	"11 - 15 = -4"	self expect: ( 00.0 meter ) actual: ( box maxZ ).		self expect: ( -22.0 meter ) actual: ( box minZ ).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:10'!test145rollBox180degrees	"180 degree rotations should leave bounds the same."	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box roll: ((Float pi)) radian.	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/19/2016 08:54'!test610buildElipsoid	| elipsoid |	elipsoid := H3dObject newElipsoidWidth: (10 meter) length: (20 meter) height: (30 meter).	"Check that dimensions were stored."	self expect: (HumMeasure quantity: (5*10*15*(Float pi)*4/3) units: 'cubic meter') actual: (elipsoid volume).	"The number of polygons should be the square of the numberOfWedges."	self expect: (elipsoid numberOfWedges squared) actual: (elipsoid polygons size).	"Check that the polygons are in range."	self expect: ( 05.0 meter ) actual: ( elipsoid maxX ).		self expect: ( 10.0 meter ) actual: ( elipsoid maxY ).		self expect: ( 15.0 meter ) actual: ( elipsoid maxZ ).				self expect: ( -05.0 meter ) actual: ( elipsoid minX ).		self expect: ( -10.0 meter ) actual: ( elipsoid minY ).		self expect: ( -15.0 meter ) actual: ( elipsoid minZ ).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/7/2016 12:13'!test150yawPitchRollBox	"180 degree rotations should leave it looking the same."	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box yaw: ((Float pi)) radian.	box pitch: ((Float pi)) radian.	box roll: ((Float pi)) radian.	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:06'!test340stepRollRate	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (05 meter) actual: (box east).	self expect: (10 meter) actual: (box north).	self expect: (15 meter) actual: (box top).	box rollRate: (0.25 rps).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	box step: (HumMeasure seconds: 1).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	"Expect X and Z bounds to exchange."	self expect: (15 meter) actual: (box maxX).	self expect: (10 meter) actual: (box maxY).	self expect: (05 meter) actual: (box maxZ).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/2/2016 13:59'!test822stackAndPitch90	| boxA boxB boxC assembly clearance totalHeight heightOverPivot |	boxA := H3dObject newBoxWidth: ( 0.10 meter ) length: ( 0.20 meter)  height: ( 0.30 meter ).	boxB := H3dObject newBoxWidth: ( 1.10 meter ) length: ( 1.20 meter ) height: ( 1.30 meter ).	boxC := H3dObject newBoxWidth: ( 2.10 meter ) length: ( 2.20 meter ) height: ( 2.30 meter ).	assembly := H3dObject newAssemblyFromParts: { boxA. boxB. boxC }.	"Part positions are relative to the assembly center."	assembly center: (HumVector newFrom: { 10.0 meter. 20.0 meter. 30.0 meter. }).	assembly move: boxA toMyCoordinate: ( HumVector newFrom: { 1.0 meter. 2.0 meter. 3.0 meter. } ).	assembly place: boxB onTopOf: boxA.	assembly place: boxC onTopOf: boxB.	"Check resulting positions in CONTAINER coordinates."	self expect:  ( HumVector newFrom: { 1.0 meter. 2.0 meter. 3.0 meter. } ) actual: ( boxA center ).	self expect: ( boxA center x ) actual: ( boxB center x ).	self expect: ( boxA center y ) actual: ( boxB center y ).	self expect: ( boxA center x ) actual: ( boxC center x ).	self expect: ( boxA center y ) actual: ( boxC center y ).	clearance := 0.001 meter.	self expect: ( ( boxA center z ) +  ( boxA height/2 ) )  actual: ( boxA maxZ ).	self expect: ( boxA maxZ + clearance + ( boxB height ) ) actual: ( boxB maxZ ).	self expect: ( boxB maxZ + clearance + ( boxC height ) ) actual: ( boxC maxZ ).	totalHeight := boxA height + clearance + boxB height + clearance + boxC height.	self expect: ( 3.902 meter ) actual: (totalHeight).	"Check resulting positions in SCENE coordinates"	assembly pivotPoint: boxA center. 	assembly		pitch: 0.0 radian.	"Zero pitch should have no effect."		self expect: ( ( assembly center + boxA center) x + ( (boxC width) / 2.0 ) ) actual: ( assembly maxX ).	self expect: ( ( assembly center + boxA center) x - ( (boxC width) / 2.0 )  ) actual: ( assembly minX ).	self expect: ( ( assembly center + boxA center) y + ( (boxC length) / 2.0 ) ) actual: ( assembly maxY ).	self expect: ( ( assembly center + boxA center) y - ( (boxC length) / 2.0 ) ) actual: ( assembly minY ).	self expect: ( ( assembly center + boxA center) z - ( (boxA height) / 2.0 ) ) actual: ( assembly minZ ).	self expect: ( ( assembly center + boxA center) z - ( (boxA height) / 2.0 ) + totalHeight ) actual: ( assembly maxZ ).		"Pitch 90 degrees up and see . . ."	assembly		pitch: (Float pi/2.0) radian.	heightOverPivot := totalHeight - (boxA height/2.0).	"y and z offsets should exchange"	self expect: ( ( assembly center + boxA center) x + ( (boxC width) / 2.0 ) ) actual: ( assembly maxX ). "STS"	self expect: ( ( assembly center + boxA center) x - ( (boxC width) / 2.0 )  ) actual: ( assembly minX ).	"STS"	self expect: ( ( assembly center + boxA center) y + ( boxA height / 2.0)  ) actual: ( assembly maxY ).	self expect: ( ( assembly center + boxA center) y - heightOverPivot ) actual: ( assembly minY ).	self expect: ( ( assembly center + boxA center) z - ( (boxC length) / 2.0 )  ) actual: ( assembly minZ ).	self expect: ( ( assembly center + boxA center) z + ( (boxC length) / 2.0 )  ) actual: ( assembly maxZ ).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:04'!test320stepYawRate	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (05 meter) actual: (box east).	self expect: (10 meter) actual: (box north).	self expect: (15 meter) actual: (box top).	box yawRate: (0.25 rps).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	box step: (HumMeasure seconds: 1).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	"Expect X and Y bounds to exchange."	self expect: (10 meter) actual: (box maxX).	self expect: (05 meter) actual: (box maxY).	self expect: (15 meter) actual: (box maxZ).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:09'!test120yawBox90degrees	"90 degree yaw exchanges X and Y"	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box yaw: ((Float pi)/ 2.0) radian.	self expect: ( 10.0 meter ) actual: ( box maxX ).		self expect: ( 05.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 11:21'!test245moveBoxBottom	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (-15 meter) actual: (box bottom).	box bottom: 40 meters.	self expect: (40 meter) actual: (box bottom).	self expect: (55 meter) actual: (box center z).	self expect: (40 meter) actual: (box minZ).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:09'!test125yawBox180degrees	"180 degree rotations should leave bounds the same."	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box yaw: ((Float pi)) radian.	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/12/2016 10:14'!test325stepVelocityAndYawRate	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (05 meter) actual: (box east).	self expect: (10 meter) actual: (box north).	self expect: (15 meter) actual: (box top).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	self expect: (05 meter) actual: (box maxX).	self expect: (10 meter) actual: (box maxY).	self expect: (15 meter) actual: (box maxZ).	box yawRate: (0.25 rps).	box velocity: ( HumVector newFrom: { 100 mps. 100 mps. 100 mps.} ).	box step: (HumMeasure seconds: 1).	self expect: ( HumVector newFrom: {100 meter. 100 meter. 100 meter} ) actual: (box center).	"Expect X and Y bounds to exchange."	self expect: (110 meter) actual: (box maxX).	self expect: (105 meter) actual: (box maxY).	self expect: (115 meter) actual: (box maxZ).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/14/2016 09:56'!test350stepEverything	| box |	box := H3dObject newBoxWidth: ( 10 meter ) length: ( 22 meter ) height: ( 30 meter ).	self expect: ( 05 meter ) actual: ( box east ).	self expect: ( 11 meter ) actual: ( box north ).	self expect: ( 15 meter ) actual: ( box top ).	self expect: (  HumVector newFrom: {0 meter. 0 meter. 0 meter}  ) actual: ( box center ).	self expect: ( 05 meter ) actual: ( box maxX ).	self expect: ( 11 meter ) actual: ( box maxY ).	self expect: ( 15 meter ) actual: ( box maxZ ).	box yawRate: ( 0.5 rps ). "Rotate 180 degrees per second. -- Should leave maxX . . . the same."	box pitchRate: ( 0.5 rps ).	box rollRate: ( 0.5 rps ).	box velocity: ( HumVector newFrom: { 100 mps. 100 mps. 100 mps.} ).	box step: ( HumMeasure seconds: 1 ).	self expect: ( HumVector newFrom: {100 meter. 100 meter. 100 meter} ) actual: ( box center ).	"Expect X and Z bounds to exchange."	self expect: ( 105 meter ) actual: ( box maxX ).	self expect: ( 095 meter ) actual: ( box minX ).	self expect: ( 111 meter ) actual: ( box maxY ).	self expect: ( 089 meter ) actual: ( box minY ).	self expect: ( 115 meter ) actual: ( box maxZ ).	self expect: ( 085 meter ) actual: ( box minZ ).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 11:07'!test240moveBoxTop	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (15 meter) actual: (box maxZ).	box top: 40 meters.	self expect: (40 meter) actual: (box top).	self expect: (25 meter) actual: (box center z).	self expect: (40 meter) actual: (box maxZ).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/2/2016 14:00'!test824stackAndRoll90	| boxA boxB boxC assembly clearance totalHeight heightOverPivot |	boxA := H3dObject newBoxWidth: ( 0.10 meter ) length: ( 0.20 meter)  height: ( 0.30 meter ).	boxB := H3dObject newBoxWidth: ( 1.10 meter ) length: ( 1.20 meter ) height: ( 1.30 meter ).	boxC := H3dObject newBoxWidth: ( 2.10 meter ) length: ( 2.20 meter ) height: ( 2.30 meter ).	assembly := H3dObject newAssemblyFromParts: { boxA. boxB. boxC }.	"Part positions are relative to the assembly center."	assembly center: (HumVector newFrom: { 10.0 meter. 20.0 meter. 30.0 meter. }).	assembly move: boxA toMyCoordinate: ( HumVector newFrom: { 1.0 meter. 2.0 meter. 3.0 meter. } ).	assembly place: boxB onTopOf: boxA.	assembly place: boxC onTopOf: boxB.	"Check resulting positions in CONTAINER coordinates."	self expect:  ( HumVector newFrom: { 1.0 meter. 2.0 meter. 3.0 meter. } ) actual: ( boxA center ).	self expect: ( boxA center x ) actual: ( boxB center x ).	self expect: ( boxA center y ) actual: ( boxB center y ).	self expect: ( boxA center x ) actual: ( boxC center x ).	self expect: ( boxA center y ) actual: ( boxC center y ).	clearance := 0.001 meter.	self expect: ( ( boxA center z ) +  ( boxA height/2 ) )  actual: ( boxA maxZ ).	self expect: ( boxA maxZ + clearance + ( boxB height ) ) actual: ( boxB maxZ ).	self expect: ( boxB maxZ + clearance + ( boxC height ) ) actual: ( boxC maxZ ).	totalHeight := boxA height + clearance + boxB height + clearance + boxC height.	self expect: ( 3.902 meter ) actual: (totalHeight).	"Check resulting positions in SCENE coordinates"	assembly pivotPoint: boxA center. 	assembly		roll: 0.0 radian.	"Zero roll should have no effect."		self expect: ( ( assembly center + boxA center) x + ( (boxC width) / 2.0 ) ) actual: ( assembly maxX ).	self expect: ( ( assembly center + boxA center) x - ( (boxC width) / 2.0 )  ) actual: ( assembly minX ).	self expect: ( ( assembly center + boxA center) y + ( (boxC length) / 2.0 ) ) actual: ( assembly maxY ).	self expect: ( ( assembly center + boxA center) y - ( (boxC length) / 2.0 ) ) actual: ( assembly minY ).	self expect: ( ( assembly center + boxA center) z - ( (boxA height) / 2.0 ) ) actual: ( assembly minZ ).	self expect: ( ( assembly center + boxA center) z - ( (boxA height) / 2.0 ) + totalHeight ) actual: ( assembly maxZ ).		"Roll 90 degrees and see . . ."	assembly		roll: (Float pi/2.0) radian.	heightOverPivot := totalHeight - (boxA height/2.0).	"x and z offsets should exchange"	self expect: ( ( assembly center + boxA center) x + ( (boxA height) / 2.0 ) ) actual: ( assembly maxX ). 	self expect: ( ( assembly center + boxA center) x - heightOverPivot  ) actual: ( assembly minX ).		self expect: ( ( assembly center + boxA center) y + ( boxC length / 2.0)  ) actual: ( assembly maxY ).	"STS"	self expect: ( ( assembly center + boxA center) y - ( boxC length / 2.0)  ) actual: ( assembly minY ).		"STS"	self expect: ( ( assembly center + boxA center) z - ( (boxC width) / 2.0 )  ) actual: ( assembly minZ ).	self expect: ( ( assembly center + boxA center) z + ( (boxC width) / 2.0 )  ) actual: ( assembly maxZ ).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/2/2016 14:01'!test821stackAndYaw90	| boxA boxB boxC assembly clearance totalHeight heightOverPivot |	boxA := H3dObject newBoxWidth: ( 0.10 meter ) length: ( 0.20 meter)  height: ( 0.30 meter ).	boxB := H3dObject newBoxWidth: ( 1.10 meter ) length: ( 1.20 meter ) height: ( 1.30 meter ).	boxC := H3dObject newBoxWidth: ( 2.10 meter ) length: ( 2.20 meter ) height: ( 2.30 meter ).	assembly := H3dObject newAssemblyFromParts: { boxA. boxB. boxC }.	"Part positions are relative to the assembly center."	assembly center: (HumVector newFrom: { 10.0 meter. 20.0 meter. 30.0 meter. }).	assembly move: boxA toMyCoordinate: ( HumVector newFrom: { 1.0 meter. 2.0 meter. 3.0 meter. } ).	assembly place: boxB onTopOf: boxA.	assembly place: boxC onTopOf: boxB.	"Check resulting positions in CONTAINER coordinates."	self expect:  ( HumVector newFrom: { 1.0 meter. 2.0 meter. 3.0 meter. } ) actual: ( boxA center ).	self expect: ( boxA center x ) actual: ( boxB center x ).	self expect: ( boxA center y ) actual: ( boxB center y ).	self expect: ( boxA center x ) actual: ( boxC center x ).	self expect: ( boxA center y ) actual: ( boxC center y ).	clearance := 0.001 meter.	self expect: ( ( boxA center z ) +  ( boxA height/2 ) )  actual: ( boxA maxZ ).	self expect: ( boxA maxZ + clearance + ( boxB height ) ) actual: ( boxB maxZ ).	self expect: ( boxB maxZ + clearance + ( boxC height ) ) actual: ( boxC maxZ ).	totalHeight := boxA height + clearance + boxB height + clearance + boxC height.	self expect: ( 3.902 meter ) actual: (totalHeight).	"Check resulting positions in SCENE coordinates"	assembly pivotPoint: boxA center. 	assembly		yaw: 0.0 radian.	"Zero yaw should have no effect."		self expect: ( ( assembly center + boxA center) x + ( (boxC width) / 2.0 ) ) actual: ( assembly maxX ).	self expect: ( ( assembly center + boxA center) x - ( (boxC width) / 2.0 )  ) actual: ( assembly minX ).	self expect: ( ( assembly center + boxA center) y + ( (boxC length) / 2.0 ) ) actual: ( assembly maxY ).	self expect: ( ( assembly center + boxA center) y - ( (boxC length) / 2.0 ) ) actual: ( assembly minY ).	self expect: ( ( assembly center + boxA center) z - ( (boxA height) / 2.0 ) ) actual: ( assembly minZ ).	self expect: ( ( assembly center + boxA center) z - ( (boxA height) / 2.0 ) + totalHeight ) actual: ( assembly maxZ ).		"Yaw 90 degrees and see . . ."	assembly		yaw: (Float pi/2.0) radian.	heightOverPivot := totalHeight - (boxA height/2.0).	"x and y offsets should exchange"	self expect: ( ( assembly center + boxA center) x + ( (boxC length) / 2.0 ) ) actual: ( assembly maxX ). "STS"	self expect: ( ( assembly center + boxA center) x - ( (boxC length) / 2.0 )  ) actual: ( assembly minX ).	"STS"	self expect: ( ( assembly center + boxA center) y + ( (boxC width ) / 2.0 ) ) actual: ( assembly maxY ).	self expect: ( ( assembly center + boxA center) y - ( (boxC width) / 2.0 ) ) actual: ( assembly minY ).	self expect: ( ( assembly center + boxA center) z - ( (boxA height) / 2.0 ) ) actual: ( assembly minZ ).	self expect: ( ( assembly center + boxA center) z - ( (boxA height) / 2.0 ) + totalHeight ) actual: ( assembly maxZ ).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/31/2016 07:27'!test143rollBox90degreesAboutPivot	"90 degree roll exchanges X and Z"	| box |	box := H3dObject newBoxWidth: (12 meter) length: (22 meter) height: (30 meter).	self expect: ( 06.0 meter ) actual: ( box maxX ).		self expect: ( 11.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box roll: ((Float pi)/ 2.0) radian.	self expect: ( 15.0 meter ) actual: ( box maxX ).		self expect: ( 11.0 meter ) actual: ( box maxY ).		self expect: ( 06.0 meter ) actual: ( box maxZ ).		box pivotPoint: ( HumVector newFrom: { 1.0 meter. 0.0 meter. 2.0 meter. } ).	self expect: ( 18.0 meter ) actual: ( box maxX ).	"0+1+(15+2) = 18"	self expect: ( 11.0 meter ) actual: ( box maxY ).	"STS"	self expect: ( 07.0 meter ) actual: ( box maxZ ).	"0+1+(6+1)"	! !HumTestCase subclass: #HBlackboardTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HBlackboardTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/31/2015 22:35'!test140BlackboardSaveFetch	"A blackboard records events, noun values"	| value event blackboard |	blackboard := HBlackboard new.	event := HEvent who: 'TTester' what: 'named' when: (HTime now)	              where: 'test140BlackboardSaveFetch' 	                why: 'intialize blackboard nouns'. 	blackboard putEvent: event.		"Put first name"	blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event.	value := blackboard getEntity: 'tester' attribute: 'first-name'.	"Put last name"	self expect: 'Tessie' actual: value.		blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event.	value := blackboard getEntity: 'tester' attribute: 'last-name'.	self expect: 'Tester' actual: value.	"First name is still there"	value := blackboard getEntity: 'tester' attribute: 'first-name'.	self expect: 'Tessie' actual: value.		! !!HBlackboardTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/31/2015 21:14'!test150BlackboardSaveFetchUpdate	"A blackboard records events, noun values"	| value event1 blackboard event2 |	blackboard := HBlackboard new.	event1 := HEvent who: 'TTester' what: 'named' when: (HTime now)	              where: 'test150BlackboardSaveFetchUpdate' 	                why: 'intialize blackboard nouns'. 	blackboard putEvent: event1.	blackboard putEntityNamed: 'tester'.	"Put first name"	blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event1.	value := blackboard getEntity: 'tester' attribute: 'first-name'.	"Put last name"	self expect: 'Tessie' actual: value.		blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event1.	value := blackboard getEntity: 'tester' attribute: 'last-name'.	self expect: 'Tester' actual: value.	"First name is still there"	value := blackboard getEntity: 'tester' attribute: 'first-name'.	self expect: 'Tessie' actual: value.	"==========="	event2 := HEvent who: 'TTester' what: 'named' when: (HTime now)	              where: 'test150BlackboardSaveFetchUpdate' 	                why: 'update blackboard nouns'.	self assert: ( event2 > event1 ). 	blackboard putEvent: event2.	blackboard putEntityNamed: 'tester'.	"Put first name"	blackboard putEntity: 'tester' attribute: 'first-name' value: 'Teddy' event: event2.	value := blackboard getEntity: 'tester' attribute: 'first-name'.	"Put last name"	self expect: 'Teddy' actual: value.		blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tinker' event: event2.	value := blackboard getEntity: 'tester' attribute: 'last-name'.	self expect: 'Tinker' actual: value.	"First name is still there"	value := blackboard getEntity: 'tester' attribute: 'first-name'.	self expect: 'Teddy' actual: value.		! !!HBlackboardTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/31/2015 22:44'!test145BlackboardSaveFetchNouns	"A blackboard records events, noun values"	| value event blackboard nounValue |	blackboard := HBlackboard new.	event := HEvent who: 'TTester' what: 'named' when: (HTime now)	              where: 'test140BlackboardSaveFetch' 	                why: 'intialize blackboard nouns'. 	blackboard putEvent: event.		"Put first name"	blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event.	value := blackboard getEntity: 'tester' attribute: 'first-name'.	"Put last name"	self expect: 'Tessie' actual: value.	nounValue := blackboard getNoun: {'tester'. 'first-name'.}.	self expect: value actual: nounValue.		blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event.	value := blackboard getEntity: 'tester' attribute: 'last-name'.	self expect: 'Tester' actual: value.	"First name is still there"	value := blackboard getEntity: 'tester' attribute: 'first-name'.	self expect: 'Tessie' actual: value.		! !!HBlackboardTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/2/2015 10:06'!test160BlackboardToStream	"A blackboard records events, noun values"	| event blackboard |	blackboard := HBlackboard new.	event := HEvent who: 'TTester' what: 'named' when: (HTime now)	              where: 'test140BlackboardSaveFetch' 	                why: 'intialize blackboard nouns'. 	blackboard putEvent: event.		"Put first name"	blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event.		blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event.		self expect: 'tester: 	first-name: Tessie	last-name: Tester' 			actual: ( blackboard asStream contents ).		! !Object subclass: #HApplication	instanceVariableNames: 'myHandler'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HApplication commentStamp: 'RichardAlexanderGreen 4/21/2015 10:26' prior: 0!An application instance handles HTTP requests.!!HApplication methodsFor: 'message handling' stamp: 'RichardAlexanderGreen 4/10/2015 21:14'!handleRequest: aZnRequest 	"Return a response for given request"	| response |	response := myHandler value: aZnRequest.	^response.! !!HApplication methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2015 21:12'!handler: aBlockClosure 	"Use the block to handle request"	myHandler := aBlockClosure.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HApplication class	instanceVariableNames: ''!!HApplication class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/16/2015 22:19'!echo	"Return an instance of myself handles request by echoing it."	| instance |		instance := self basicNew.	instance handler: [:request |  			| entity  response stream string |			stream := ReadWriteStream on: ''.			stream 				nextPutAll: ( request requestLine method  );			  nextPutAll: '...';			  nextPutAll: ( request requestLine uri pathPrintString).			(request requestLine method sameAs: 'POST') 				ifTrue: [ "Show POST and query"					stream nextPutAll: (String cr); nextPutAll: 'POST: '.					(request requestLine uri query isNil) 						ifTrue: [stream << ' No query arguments seen.']						ifFalse:[request requestLine uri queryDo: [:k :v | stream nextPutAll: (k, '=', v, '  ') ].							]					].						string := stream contents.			(string trimBoth size > 0) ifFalse: [string:= 'Method and URI not seen in echo.'].			(request headers) keysAndValuesDo: [:k :v | string := string, String cr, k,': ',v ].			entity := ZnStringEntity text: string.  		  response := ZnResponse ok: entity.		  response.		  ].	^instance.! !Object subclass: #H3dPath	instanceVariableNames: 'vertices borderColor fillColor'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!H3dPath commentStamp: 'RichardAlexanderGreen 3/7/2016 10:14' prior: 0!a list of 3D verticesBut it can also be interpreted as a polygon if the path is in a plane.Each vertex is a HumVector.!!H3dPath methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/7/2016 10:23'!fillColor: aColor 	"Color to use when rendering path as a polygon"	fillColor := aColor.! !!H3dPath methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/7/2016 10:23'!borderColor: aColor 	"Color to use when rendering path (polygon edges)."	borderColor := aColor.! !!H3dPath methodsFor: 'access' stamp: 'RichardAlexanderGreen 6/20/2016 10:46'!= anotherPath	"Are the two paths equal."	| result |	"Are they the same size?"	( self vertices size = anotherPath vertices size ) 		ifFalse: [ ^false ].		result := true. "Innocent until proven otherwise."	(1 to: self size)		do: [ :i | ((self vertices at: i) = (anotherPath vertices at: i)) ifFalse: [ ^false ]. ].	^result.	! !!H3dPath methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/28/2016 08:04'!borderColor	^ borderColor ifNil: [ borderColor := (self fillColor) lighter ].! !!H3dPath methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/19/2016 14:53'!vertices	^ vertices ifNil: [ vertices := OrderedCollection new ].! !!H3dPath methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/19/2016 14:58'!first	| points |	points := self vertices.	self assert: ( points size > 0 ). "OrderedCollection"	^ points at: 1.! !!H3dPath methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/28/2016 08:04'!fillColor	^ fillColor ifNil: [ fillColor := Color gray ].! !!H3dPath methodsFor: 'access' stamp: 'RichardAlexanderGreen 4/4/2016 10:11'!allButFirstDo: aBlockClosure 	^self vertices allButFirstDo: aBlockClosure.! !!H3dPath methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/19/2016 14:59'!size	^ self vertices size.! !!H3dPath methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/19/2016 15:04'!last	| points |	points := self vertices.	self assert: ( points size > 0 ). "OrderedCollection"	^ points last.! !!H3dPath methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/19/2016 15:05'!do: aBlockClosure 	^self vertices do: aBlockClosure.! !!H3dPath methodsFor: 'access' stamp: 'RichardAlexanderGreen 4/8/2016 08:00'!addVertex: xyzCoordinates 	| vector calc |	calc := HumCalculator new.	calc cases;		when: [ xyzCoordinates isKindOf: HumVector ] then: [ vector := xyzCoordinates. ];		when: [ xyzCoordinates isKindOf: Array ] then: [ vector := HumVector newFrom: xyzCoordinates. ];		when: [ xyzCoordinates isKindOf: Point ] then: [ vector := HumVector newFromPoint: xyzCoordinates. ];				otherwise: [ Error signal: 'xyzCoordinates of unexpected type' ].	(self vertices) add: vector.	! !!H3dPath methodsFor: 'access' stamp: 'RichardAlexanderGreen 4/8/2016 08:10'!max: aBlockClosure 	^self vertices max: aBlockClosure.! !!H3dPath methodsFor: 'transforms' stamp: 'RichardAlexanderGreen 3/12/2016 09:27'!yaw: yawAngle aboutPivot: pivot	"Return a new path with my points adjusted by yaw about origin."	| newPath |	newPath := self class new.	self vertices do: [ :vertex |  newPath addVertex: ( vertex yaw: yawAngle aboutPivot: pivot ). ].	^newPath! !!H3dPath methodsFor: 'transforms' stamp: 'RichardAlexanderGreen 3/12/2016 09:28'!pitch: pitchAngle aboutPivot: aPivot	"Return a new path with my points adjusted by pitch about origin."	| newPath |	newPath := self class  new.	self vertices do: [ :vertex |  newPath addVertex: ( vertex pitch: pitchAngle aboutPivot: aPivot ). ].	^newPath! !!H3dPath methodsFor: 'transforms' stamp: 'RichardAlexanderGreen 3/12/2016 09:31'!yaw: yawAngle 	"Return a new path with my points adjusted by yaw about origin."	| newPath  |	newPath := self yaw: yawAngle aboutPivot: ( HumVector zeroVector: #meter ).	^newPath! !!H3dPath methodsFor: 'transforms' stamp: 'RichardAlexanderGreen 4/4/2016 09:08'!roll: rollAngle aboutPivot: aPivot	"Return a new path with my points adjusted by roll about origin."	| newPath |	newPath := self class new.	self vertices do: [ :vertex |  newPath addVertex: ( vertex roll: rollAngle aboutPivot: aPivot ). ]."HumVector"	^newPath! !!H3dPath methodsFor: 'transforms' stamp: 'RichardAlexanderGreen 3/12/2016 09:32'!roll: rollAngle 	"Return a new path with my points adjusted by roll about origin."	| newPath |	newPath := self roll: rollAngle aboutPivot: ( HumVector zeroVector: #meter ).	^newPath! !!H3dPath methodsFor: 'transforms' stamp: 'RichardAlexanderGreen 3/28/2016 08:01'!translateBy: aHumVector 	"Return a path with vertices translated by the given vector."	| newVertices instance |	newVertices := OrderedCollection new.	self vertices do: [ :vertex | 			| newVertex |			newVertex := vertex + aHumVector.			newVertices addLast: newVertex.		 ].	instance := self class newFrom: newVertices.	instance 		fillColor: (self fillColor);		borderColor: (self borderColor).	^instance.		! !!H3dPath methodsFor: 'transforms' stamp: 'RichardAlexanderGreen 3/12/2016 09:33'!pitch: pitchAngle 	"Return a new path with my points adjusted by pitch about origin."	| newPath |	newPath := self pitch: pitchAngle aboutPivot: ( HumVector zeroVector: #meter ).	^newPath! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!H3dPath class	instanceVariableNames: ''!!H3dPath class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/19/2016 09:30'!newFrom: aCollection	"Create an instance from the points in the collection/array"	| instance |	instance := self new.	aCollection do: [ :vertex | instance addVertex: vertex ].	^instance! !Object subclass: #HEntity	instanceVariableNames: 'attributes history title id'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HEntity commentStamp: 'RichardAlexanderGreen 4/3/2015 10:08' prior: 0!Represent an entity instance in data.Instance Variables:	attributes	<Dictionary> - a dictionary of (attributeName -> attributeValue).	history	<OrderedCollection> - a sequence of state-change records.	title	<String>       - a locally unique noun naming this entity. (blackboard context)	id	    <LargeInteger> - a globally unique identifier for this entity. (world-base context)!!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 09:44'!attributes	"Return my dictionary of current attribute values."	^ attributes ifNil: [ attributes := Dictionary new ].! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 09:39'!attribute: anAttributeType value: aValue event: anEvent 	"Record a state-change associated with the given event."	self attributes at: anAttributeType put: aValue.	self history add: { anEvent. anAttributeType. aValue. }.! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 09:45'!history	"Return history of state-changes."	^ history ifNil: [ history := OrderedCollection new].! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 09:44'!getAttribute: anAttributeName 	"What is the value of the given attribute?"	| result |	result := self attributes at: anAttributeName.	^result.! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 09:43'!attribute: anAttributeName value: anAttributeValue 	"Initialize entity-attribute value. (No event, no history)	- Use '#attribute:value:event:' to record state-changes.	"	(self attributes) at: anAttributeName put: anAttributeValue.! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:38'!id	^ id! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 09:48'!id: aLargePositiveInteger 	"Set unique identifier.	- This value may be used to refer to this entity in relationships."	id := aLargePositiveInteger.! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:00'!printOn: aStream	"Format my data for easy reading. 	- Append lines to given stream (expecting aReadWriteStream).	- TODO: Consider using a JSON format instead.	"	| |	"Put my name/title on the stream"	aStream << (self title) <<  ': ' << String cr.	"Append indented list of my attribute values to stream."	(self attributes)		keysAndValuesDo: 			[ :attr :value |				aStream << '	' <<  attr << ': ' << value << String cr.				"TODO: Handle attributes that refer to other entities."			].		! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:27'!title	"Entity should be given a contextually unique name (noun)"	^ title ifNil: [ Error signal: 'unknown entity'].! !!HEntity methodsFor: 'associating' stamp: 'RichardAlexanderGreen 4/3/2015 10:02'!title: aString 	"Set my title - something appropriate to usage and unique within the context.	Typically a noun (entity type or model component) within a blackboard.	"	title := aString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HEntity class	instanceVariableNames: ''!!HEntity class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/2/2015 11:31'!title: aString 	"Return an instance with that title/name"	| instance |	instance := self basicNew.	instance title: aString.	instance id: (HTime timeStamp).	^instance.! !Object subclass: #H3dObject	instanceVariableNames: 'type parameters center velocity width length height numberOfWedges axis curve yaw pitch roll yawRate pitchRate rollRate pivotPoint fillColor borderColor parts clearance'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!H3dObject commentStamp: 'RichardAlexanderGreen 2/29/2016 09:43' prior: 0!Experimental: Rewrite HumBox to simplify dynamics.!!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 11:08'!top: aMeasure	"Move so that top is at given z value."	| cx cy cz |	cx := center x. 	cy := center y.	cz := center z.	self center: (HumVector newFrom: { cx. cy. ( aMeasure - ( height / 2.0 ) ). }).! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 11:14'!south: aMeasure	"Move so that south edge is at given value."	| cx cy cz |	cx := center x. 	cy := center y.	cz := center z.	self center: ( HumVector newFrom: { cx. ( aMeasure + ( length / 2.0 ) ). cz. } ).! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 13:00'!south	"Value without yaw, pitch, roll - Use minY to see value with yaw, pitch, roll."	^  ( center y ) - ( length / 2.0 ).! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 12:58'!east	"Value without yaw, pitch, roll - Use maxX to see value with yaw, pitch, roll."	^  ( center x ) + ( width / 2.0 ).! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 13:00'!north	"Value without yaw, pitch, roll - Use maxY to see value with yaw, pitch, roll."	^  ( center y ) + ( length / 2.0 ).! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 13:00'!bottom	"Value without yaw, pitch, roll - Use minZ to see value with yaw, pitch, roll."	^  ( center z ) - ( height / 2.0 ).! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 12:59'!west	"Value without yaw, pitch, roll - Use minX to see value with yaw, pitch, roll."	^  ( center x ) - ( width / 2.0 ).! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/7/2016 12:23'!north: aMeasure	"Move so that north edge is at given value."	| cx cy cz |	cx := center x. 	cy := center y.	cz := center z.	self center: (HumVector newFrom: { cx. ( aMeasure - ( length / 2.0 ) ). cz. }).! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 11:11'!west: aMeasure	"Move so that west edge is at the given value."	| cx cy cz |	cx := center x. 	cy := center y.	cz := center z.	self center:  (HumVector newFrom: { ( aMeasure + ( width / 2.0 ) ). cy. cz. }).	! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/7/2016 12:15'!east: aMeasure	"Move so that east edge is at the given value."	| cx cy cz |	cx := center x. 	cy := center y.	cz := center z.	self center: (HumVector newFrom: { (aMeasure - ( width / 2.0 ) ). cy. cz. }).	! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 11:21'!bottom: aMeasure	"Move so that bottom is at given z value."	| cx cy cz |	cx := center x. 	cy := center y.	cz := center z.	self center: ( HumVector newFrom: { cx. cy. ( aMeasure + ( height / 2.0 ) ). } ).! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 13:00'!top	"Value without yaw, pitch, roll - Use maxZ to see value with yaw, pitch, roll."	^  ( center z ) + ( height / 2.0 ).! !!H3dObject methodsFor: 'draw' stamp: 'RichardAlexanderGreen 3/28/2016 08:14'!buildAssembly	"Build the polygons for the assembly by aggregating and translating polygons from the parts."	| localPolygons translatedPolygons |	localPolygons := OrderedCollection new.	translatedPolygons := OrderedCollection new.	self parts  do: [ :part |  localPolygons addAllLast: ( part buildBasePolygons ) ].	localPolygons do: [ :polygon | translatedPolygons addLast: (polygon translateBy: self center)  ].  	^translatedPolygons.! !!H3dObject methodsFor: 'draw' stamp: 'RichardAlexanderGreen 3/12/2016 20:40'!buildBox	"Create polygons for a box"	| polygons points dx dy dz cx cy cz top bottom east west north south |	polygons := OrderedCollection new.	dx := width / 2.0.	dy := length / 2.0.	dz := height / 2.0.	cx := center x.	cy := center y.	cz := center z.		points := Collection new.	top := H3dPath new.	top 		addVertex: { cx+dx. cy+dy. cz+dz. }; "Right-hand rule: Wind clockwise facing inward."		addVertex: { cx+dx. cy-dy. cz+dz. };		addVertex: { cx-dx. cy-dy. cz+dz. };		addVertex: { cx-dx. cy+dy. cz+dz. }.			bottom := H3dPath new.	bottom		addVertex: { cx+dx. cy+dy. cz-dz. };		addVertex: { cx-dx. cy+dy. cz-dz. };		addVertex: { cx-dx. cy-dy. cz-dz. };		addVertex: { cx+dx. cy-dy. cz-dz. }.	north := H3dPath new.	north		addVertex: { cx+dx. cy+dy. cz+dz. };		addVertex: { cx-dx. cy+dy. cz+dz. };		addVertex: { cx-dx. cy+dy. cz-dz. };		addVertex: { cx+dx. cy+dy. cz-dz. }.	south := H3dPath new.	south		addVertex: { cx+dx. cy-dy. cz+dz. };		addVertex: { cx+dx. cy-dy. cz-dz. };		addVertex: { cx-dx. cy-dy. cz-dz. };		addVertex: { cx-dx. cy-dy. cz+dz. }.	east := H3dPath new.	east		addVertex: { cx+dx. cy+dy. cz+dz. };		addVertex: { cx+dx. cy+dy. cz-dz. };		addVertex: { cx+dx. cy-dy. cz-dz. };		addVertex: { cx+dx. cy-dy. cz+dz. }.	west := H3dPath new.	west		addVertex: { cx-dx. cy+dy. cz+dz. };		addVertex: { cx-dx. cy-dy. cz+dz. };		addVertex: { cx-dx. cy-dy. cz-dz. };		addVertex: { cx-dx. cy+dy. cz-dz. }.	"assemble faces"				polygons addAll: { top. bottom. north. south. east. west. }.		"color"	polygons do: [ :polygon | polygon borderColor: (self borderColor); fillColor: (self fillColor) ].	^ polygons.! !!H3dObject methodsFor: 'draw' stamp: 'RichardAlexanderGreen 3/28/2016 08:14'!buildBasePolygons	"Return my base polygons. Polygons before pitch, yaw, roll."	| calc polygons  |	polygons := OrderedCollection new.	calc := HumCalculator new.	calc cases;		when: [ type = #box ] then: [ polygons := self buildBox ];		when: [ type = #elipsoid ] then: [ polygons := self buildElipsoid ];		when: [ type = #rotation ] then: [ polygons := self buildRotation ];		when: [ type = #assembly ] then: [ polygons := self buildAssembly ];		otherwise: [ Error signal: 'Unknown type of 3D object: ', (type asString) ].	self assert: ( polygons size > 0 ) description: 'Empty assembly? Unexpected it is.'.	^polygons.! !!H3dObject methodsFor: 'draw' stamp: 'RichardAlexanderGreen 3/7/2016 09:57'!polygons	| polygons |	polygons := self buildAndOrient.	^polygons! !!H3dObject methodsFor: 'draw' stamp: 'RichardAlexanderGreen 4/8/2016 08:22'!buildAndOrient	"Return polygons in scene coordinates.	Build base polygons. 	Then, adjust orientation for yaw, pitch, roll. "	| basePolygons adjustedPolygons pivot |	basePolygons := self buildBasePolygons.	adjustedPolygons := OrderedCollection new.	pivot := self pivot.	self assert: ( pivot isKindOf: HumVector ).	basePolygons do: [ :p0 | "p0 is a polygon"		|  p1 p2 p3 |		"To assure consistent results, alway apply in order: yaw, pitch, roll. "		( yaw quantity = 0.0 )	ifTrue: [ p1 := p0 ] ifFalse: [ p1 := p0 yaw: yaw aboutPivot: pivot ].		( pitch quantity = 0.0 )	ifTrue: [ p2 := p1 ] ifFalse: [ p2 := p1 pitch: pitch aboutPivot: pivot ] .		( roll quantity = 0.0 )		ifTrue: [ p3 := p2 ] ifFalse: [ p3 := p2 roll: roll aboutPivot: pivot ].		adjustedPolygons add: p3. 		].	^adjustedPolygons.	! !!H3dObject methodsFor: 'draw' stamp: 'RichardAlexanderGreen 3/19/2016 08:45'!buildElipsoid	"Create polygons forming the elipsoid."	| polygons pi minusPi twoPi nWedges  dAlpha dBeta makePoint xMax yMax zMax |	polygons := OrderedCollection new.	pi := Float pi.	minusPi := pi negated.	twoPi := 2.0 * pi.	nWedges := self numberOfWedges.	dAlpha := pi / nWedges.	dBeta := twoPi / nWedges.	xMax := width / 2.0.	yMax := length / 2.0.	zMax := height / 2.0.	makePoint := [ :alpha :beta |  	"BlockClosure to build a point given alpha and beta angles."			| x y z vertex |			x := xMax * ( beta cos ) * ( alpha cos ).			y := yMax * ( beta sin ) * ( alpha cos ).			z := zMax * ( alpha sin ). 			vertex := HumVector newFrom: { x. y. z. }. 		"return"			].	"Work from bottom to top"	( ((minusPi / 2.0) + dAlpha ) to: pi / 2.0 by: dAlpha) do: [ :alpha |  "verticle angle from x-y plane"		( minusPi  to: ( pi - dBeta ) by: dBeta ) do: [ :beta | "circle around z axis" 			| polygon |			polygon := H3dPath new.			polygon 				addVertex: ( makePoint value: alpha value: beta );				addVertex: ( makePoint value: alpha value: beta + dBeta );				addVertex: ( makePoint value: alpha - dAlpha value: beta + dBeta );				addVertex: ( makePoint value: alpha - dAlpha value: beta ).			polygons add: polygon.			].		].	"color"	polygons do: [ :polygon | polygon borderColor: (self borderColor); fillColor: (self fillColor) ].	^polygons.	! !!H3dObject methodsFor: 'draw' stamp: 'RichardAlexanderGreen 3/22/2016 14:38'!buildRotation	"Given curve and an axis, build a rotation as a collection of polygons."	| polygons nWedges dAngle cx cy cz priorXY priorPoint twoPi calc adjustedPolygons |	polygons := OrderedCollection new.	nWedges := self numberOfWedges.	cx := center x.	cy := center y.	cz := center z.	priorXY := curve first.	priorPoint := HumVector newFrom: { cx + (priorXY x). cy. cz + (priorXY y).  }.	twoPi := 2.0 * (Float pi).	dAngle := twoPi / nWedges.	( dAngle to: twoPi by: dAngle ) do: [ :angle |	 			( curve vertices copyFrom: 2 to: curve size ) do: [ :xy |					| polygon thisPoint |  					thisPoint := HumVector newFrom: {  cx + (xy x). cy. cz + (xy y). }.					polygon := HumPolygon new.					polygon 						addVertex: ( thisPoint yaw: angle radian );  "Right-hand rule: Wind clockwise looking inward."						addVertex: ( priorPoint yaw: angle radian  );						addVertex: ( priorPoint yaw: (angle - dAngle) radian );						addVertex: ( thisPoint yaw: (angle - dAngle) radian ).					polygons add: polygon.					priorPoint := thisPoint.				].			].	calc := HumCalculator new.	"Adjust for non-default axis of rotation."	adjustedPolygons := OrderedCollection new.	calc cases;		when: [ axis = #z ] then: [ adjustedPolygons := polygons ];		when: [ axis = #x ] then: [ polygons do: [ :polygon | adjustedPolygons add: ( polygon roll:  (Float pi / 2.0) negated radian )  ] ];		when: [ axis = #y ] then: [ polygons do: [ :polygon | adjustedPolygons add: ( polygon pitch: (Float pi / 2.0) negated radian )  ] ];		otherwise: [ "default is #z" adjustedPolygons := polygons ].	"color"	adjustedPolygons do: [ :polygon | polygon borderColor: (self borderColor); fillColor: (self fillColor ) ]. "Color"	 ^adjustedPolygons. ! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/2/2016 12:02'!velocity: aVector	"Set my velocity in container coordinates."	self assert: ( aVector isKindOf: HumVector ).	velocity := aVector.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/11/2016 15:22'!center: aVector	"Set my center in container coordinates."	self assert: ( aVector isKindOf: HumVector ).	center := aVector copy.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/6/2016 16:41'!step: aTimeIncrement	"Step the position and orientation."	| newCenter newPitch newYaw newRoll |	"self assert: ((aTimeIncrement isKindOf: HumMeasure) and: [ aTimeIncrement dimensions = { #second->1. } ] )."	newCenter := center + ( velocity * aTimeIncrement ).	"Always do yaw, pitch, roll in that order."	newYaw := yaw + ( yawRate * aTimeIncrement ).	newPitch := pitch + ( pitchRate * aTimeIncrement ).	newRoll := roll + ( rollRate * aTimeIncrement ).	"Update:"	self 		center: newCenter;		yaw: newYaw;		pitch: newPitch;		roll: newRoll.	self changed.  "Inform subscribers."			! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/4/2016 16:59'!roll: anAngleInRadians	"Amount of current roll. = rotation about y-axis"	self assertRadians: anAngleInRadians.	roll := anAngleInRadians.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/4/2016 16:59'!yaw: anAngleInRadians	"Amount of current yaw. = rotation about z-axis"	self assertRadians: anAngleInRadians.	yaw := anAngleInRadians.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/6/2016 16:27'!yaw	"Amount of current yaw. = rotation about z-axis"	^ yaw ifNil: [ yaw := 0.0 radian ].! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/4/2016 17:12'!assertRadiansPerSecond: radiansPerSecond		self assert: ( (radiansPerSecond isKindOf: HumMeasure) and: [radiansPerSecond dimensions = (1 rpm) dimensions ] ) "Number>>rpm"			description: 'Angular-velocity should be HumMeasure with units of radians per second'.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/6/2016 16:35'!initialize	"Set initial position, orientation, velocity, and rotation rates to zero."	| zeroOffset zeroSpeed zeroRotation zeroRateOfRotation |		zeroOffset := 0.0 meter.	zeroSpeed := 0.0 mps.	zeroRotation := 0.0 radian.	zeroRateOfRotation := 0.0 rps.		self center: ( HumVector newFrom: { zeroOffset. zeroOffset. zeroOffset. } ).	self velocity: ( HumVector newFrom: { zeroSpeed.  zeroSpeed.  zeroSpeed. } ).		self yaw: zeroRotation.	self pitch: zeroRotation.	self roll: zeroRotation.		self yawRate: zeroRateOfRotation.	self pitchRate: zeroRateOfRotation.	self rollRate: zeroRateOfRotation.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/4/2016 17:10'!yawRate: randiansPerSecond	"yaw rate (angular velocity) = rotation about z-axis"	self assertRadiansPerSecond: randiansPerSecond.	yawRate := randiansPerSecond.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/6/2016 16:27'!roll	"Amount of current roll. = rotation about y-axis"	^roll ifNil: [ roll := 0.0 radian ].! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/4/2016 17:11'!pitchRate: randiansPerSecond	"pitch rate (angular velocity) "	self assertRadiansPerSecond: randiansPerSecond.	pitchRate := randiansPerSecond.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/6/2016 16:27'!pitch	"Amount of current pitch = rotation about x-axis"	^ pitch ifNil: [ pitch := 0.0 radian ].! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/4/2016 16:59'!pitch: anAngleInRadians	"Amount of current pitch = rotation about x-axis"	self assertRadians: anAngleInRadians.	pitch := anAngleInRadians.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/4/2016 16:58'!assertRadians: anAngleInRadians		self assert: ( (anAngleInRadians isKindOf: HumMeasure) and: [anAngleInRadians dimensions = (1 radian) dimensions ] )			description: 'Angles should be HumMeasure with units of #radian'.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/14/2016 10:18'!center	^ center ifNil: [ center := (HumVector newFrom: { 0.0 meter. 0.0 meter. 0.0 meter. } ) ].! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/14/2016 08:11'!pivot	"Return the pivot in scene coordinates."	| pivot |	pivot := (self center) + (self pivotPoint).	^pivot! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/4/2016 17:11'!rollRate: randiansPerSecond	"roll rate (angular velocity) "	self assertRadiansPerSecond: randiansPerSecond.	rollRate := randiansPerSecond.! !!H3dObject methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/12/2016 20:39'!borderColor	^ borderColor ifNil: [ borderColor := (self fillColor) lighter. ].! !!H3dObject methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/12/2016 20:38'!fillColor	^ fillColor ifNil: [ fillColor := Color gray. ].! !!H3dObject methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/26/2016 09:33'!clearance	"Default value for clearance is one millimeter."	^clearance ifNil: [ clearance := 0.001 meter ].! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/3/2016 15:42'!numberOfWedges	"Number of wedges to produce when drawing rotation or elipsoid."	^ numberOfWedges ifNil: [ numberOfWedges := 12 ].! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/14/2016 08:46'!width	^ width ifNil: [ Error signal: 'width has not been set' ].! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/19/2016 09:22'!numberOfWedges: anInteger 	numberOfWedges := anInteger! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/19/2016 09:45'!curve: xyPoints	"Curve to use when building a rotation.	Use with #axis to define a surface of rotation."	self assert: ( xyPoints isKindOf: H3dPath ).	curve := xyPoints.! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/3/2016 15:41'!length: aLength	"What is my North-South length? (prior to pitch, yaw, roll)	Define length of box or elipsoid."	length := aLength.! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/25/2016 18:42'!height	"What is my Up-Down height? (prior to pitch, yaw, roll).	Defines height of box or elipsoid."	^ height ifNil: [ Error signal: 'height dimension has not been set' ].! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/14/2016 10:47'!volume	"Return volume of box."	| volume calc |	calc := HumCalculator new.	calc cases;		when: [ type = #box ] then: [ volume := width * length * height. ];		when: [ type = #elipsoid ] then: [| a b c | a := width/2.0.  b := length/2.0. c := height/2.0. volume := a * b * c * (Float pi)* 4.0 / 3.0 ];		when: [ type = #rotation ] then: [ self shouldBeImplemented  ];		otherwise: [ Error signal: '3D object type not given' ].	 ^volume.	! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/3/2016 15:40'!axis: anAxisSymbol	"Which axis is rotation around? 	Use with #curve: to set-up surface of rotation."	self assert: (anAxisSymbol isKindOf: Symbol ).	^ axis := anAxisSymbol.! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/3/2016 15:42'!width: aWidth	"What is my East-West width? (prior to pitch, yaw, roll)	Define width of box or elipsoid."	width := aWidth.! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/14/2016 08:29'!pivotPoint: aVector	"Pivot-point is relative to object`s center.	Example: The pivot is inset from top edge of arm.	w := 0.10.	h := 0.50	arm := H3dObject boxWidth: w length: w height: h.	arm pivotPoint: (HumVector newFrom: { 0.0. 0.0. (h/2)-(w/2). }."	pivotPoint := aVector! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/2/2016 11:53'!type: aType	"What type of 3D object am I?"	type := aType.! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/3/2016 15:41'!height: aHeight	"What is my Up-Down height? (prior to pitch, yaw, roll).	Defines height of box or elipsoid."	height := aHeight.! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/12/2016 09:23'!pivotPoint	"Pivot-point is relative to object`s center. 	By default we pivot around the center."	^pivotPoint ifNil: [ pivotPoint := HumVector zeroVector: #meter ].! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/14/2016 08:38'!length	"What is my North-South length? (prior to pitch, yaw, roll)	Define length of box or elipsoid."	^ length ifNil: [ Error signal: 'length dimesion has not been set' ].! !!H3dObject methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 3/26/2016 09:35'!place: aH3dObjectA onTopOf: aH3dObjectB 	"Position so that  bottom matches top with a little clearance."	| offsetA offsetB sameX sameY newCenter  |	offsetA := ( aH3dObjectA maxZ ) - ( aH3dObjectA center z ).	offsetB := ( aH3dObjectB center z ) - ( aH3dObjectB minZ ).	sameX := aH3dObjectA center x.	sameY := aH3dObjectA center y.	clearance := self clearance.	newCenter := aH3dObjectB center + (HumVector newFrom: { sameX. sameY. (offsetA + offsetB + clearance ). } ).	aH3dObjectA center: newCenter.	! !!H3dObject methodsFor: 'positioning' stamp: 'RichardAlexanderGreen 3/26/2016 09:26'!move: aH3dObject toMyCoordinate: aHumVector 	aH3dObject center: aHumVector.! !!H3dObject methodsFor: 'access - bounds' stamp: 'RichardAlexanderGreen 4/2/2016 12:58'!minX	| v |	v := nil.	(self polygons) do: [ :polygon | 		polygon vertices do: [ :vertex | 			( v isNil ) 				ifTrue: [ v := vertex x ]				ifFalse: [ v := v min: (vertex x) ]			 ].  		].	^ v.	! !!H3dObject methodsFor: 'access - bounds' stamp: 'RichardAlexanderGreen 4/2/2016 12:59'!maxY	| v |	v := nil.	(self polygons) do: [ :polygon | 		polygon vertices do: [ :vertex | 			( v isNil ) 				ifTrue: [ v := vertex y ]				ifFalse: [ v := v max: (vertex y) ]			 ].  		].	^ v.	! !!H3dObject methodsFor: 'access - bounds' stamp: 'RichardAlexanderGreen 4/2/2016 12:59'!minY	| v |	v := nil.	(self polygons) do: [ :polygon | 		polygon vertices do: [ :vertex | 			( v isNil ) 				ifTrue: [ v := vertex y ]				ifFalse: [ v := v min: (vertex y) ]			 ].  		].	^ v.	! !!H3dObject methodsFor: 'access - bounds' stamp: 'RichardAlexanderGreen 4/2/2016 12:59'!minZ	| v |	v := nil.	(self polygons) do: [ :polygon | 		polygon vertices do: [ :vertex | 			( v isNil ) 				ifTrue: [ v := vertex z ]				ifFalse: [ v := v min: (vertex z) ]			 ].  		].	^ v.	! !!H3dObject methodsFor: 'access - bounds' stamp: 'RichardAlexanderGreen 4/2/2016 13:00'!maxZ	| v |	v := nil.	(self polygons) do: [ :polygon | 		polygon vertices do: [ :vertex | 			( v isNil ) 				ifTrue: [ v := vertex z ]				ifFalse: [ v := v max: (vertex z) ]			 ].  		].	^ v.	! !!H3dObject methodsFor: 'access - bounds' stamp: 'RichardAlexanderGreen 4/2/2016 13:09'!maxX	| v |	v := nil.	(self polygons) do: [ :polygon | 		polygon vertices do: [ :vertex | 			( v isNil ) 				ifTrue: [ v := vertex x ]				ifFalse: [ v := v max: (vertex x) ]			 ].  		].	^ v.	! !!H3dObject methodsFor: 'access - assembly' stamp: 'RichardAlexanderGreen 3/22/2016 15:27'!parts	"Return my set of parts/subassemblies - each part is unique - hence a member of a set."	^ parts ifNil: [  parts := Set new. ].! !!H3dObject methodsFor: 'access - assembly' stamp: 'RichardAlexanderGreen 3/22/2016 16:25'!addPart: anH3dObject	"Add a part (or subassembly) to my assembly."	self assert: (anH3dObject isKindOf: H3dObject ).	self deny: (anH3dObject == self ). 		(self parts) add: anH3dObject.! !!H3dObject methodsFor: 'access - assembly' stamp: 'RichardAlexanderGreen 3/25/2016 17:56'!addParts: aPartsList	"Add each part to my set of parts."	aPartsList do: [  :part | (self parts) add: part. ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!H3dObject class	instanceVariableNames: ''!!H3dObject class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 3/19/2016 09:42'!newRotationAround: anAxis curve: xyPoints	"Return instance of a rotation"	| instance |	self assert: ( #( #x #y #z ) includes: anAxis ).	self assert: (xyPoints isKindOf: H3dPath ).	self assert: ( (xyPoints vertices first) isKindOf: HumVector ).		instance := self new.	instance		type: #rotation;		axis: anAxis;		curve: xyPoints.	^instance.! !!H3dObject class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 3/7/2016 10:03'!newBoxWidth: aWidth length: aLength height: aHeight	"Return instance of a box"	| instance |	self assert: ( aWidth isKindOf: HumMeasure ).	self assert: ( aLength isKindOf: HumMeasure ).	self assert: ( aHeight isKindOf: HumMeasure ).		instance := self new.	instance		type: #box;		width: aWidth;		length: aLength;		height: aHeight.	^instance.! !!H3dObject class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 3/14/2016 10:20'!newElipsoidWidth: aWidth length: aLength height: aHeight	"Return instance of an elipsoid"	| instance |	self assert: ( aWidth isKindOf: HumMeasure ).	self assert: ( aLength isKindOf: HumMeasure ).	self assert: ( aHeight isKindOf: HumMeasure ).	instance := self new.	instance		type: #elipsoid;		width: aWidth;		length: aLength;		height: aHeight.	^instance.! !!H3dObject class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 3/28/2016 07:52'!newAssemblyFromParts: aPartsList	"Create instance of an assembly containing the given parts."	| instance |	instance := self new.	instance type: #assembly.	instance addParts: aPartsList.	^instance.! !HEntity subclass: #HEntityType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HEntityType commentStamp: 'RichardAlexanderGreen 4/8/2015 13:10' prior: 0!An Entity-Type instance holds meta-data.	The type of an entity-type is named by a noun in the ontology.	The attributes of an entity-type are identified in the ontology.	The data-type of the attributes are identified in the ontology. (Default is string when there is no supertype).Currently, the ontology does not contain user-interface (scribe) *hints* such as - field-width          (Calculated at 90% statistic.)- required attributes  (We could add a base-ontology type called 'required-value'.)- immutable attributes (We could add a base-ontology type called 'immutable-value'.)- natural key          (We could add a base-ontology type called 'natural-key'.)       - ranges for measure, date, or timestamp values. (Should we add annotations to dictionary notation?)- Default ordering (natural key?) on sets and bags. - Help data - explaining how the entity and its attributes are to be interpreted (data entered)- - Comment: Help probably should be provided by separate views rather than meta-data. But this can be argued.Consider:- Should supertype attributes be displayed above subtype attributes?*** The functions identified above can be handled in ontology, and do not require a separate class. ***!HumTestCase subclass: #HGlamourTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HGlamourTest commentStamp: 'RichardAlexanderGreen 7/19/2015 09:18' prior: 0!The purpose of this test suite is to characterize the Glamour package, and thus, understand how it is intended to be used."This group of tests follows 'Deep into Pharo - chapter 10' "!!HGlamourTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/23/2015 16:19'!test110Page193b	"Example at page 193"	| browser |	self skip: 'I am finished with this example'.	browser := GLMFinder new.	browser show: [ :a | 		a list 		    when: #isDirectory;			display: #children; 			format: #basenameWithIndicator ].	browser openOn: FileSystem disk root.! !!HGlamourTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/23/2015 16:19'!test110Page193a	"Example at page 193"	| browser |	self skip: 'I am finished with this example'.	browser := GLMFinder new.	browser show: [ :a | 		a list 		    when: #isDirectory;			display: #children; 			format: #basename ].	browser openOn: FileSystem disk root.! !!HGlamourTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/23/2015 16:14'!test100ReadMe	"This group of tests follows 'Deep into Pharo - chapter 10' "	self skip: 'Just a ReadMe'.! !!HGlamourTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/23/2015 16:18'!test110Page194	"Example at page 194"	| browser |	self skip: 'I am finished with this example'.	browser := GLMFinder new						variableSizePanes;						title: 'Navigate file structure';						yourself.	browser show: [ :a | 		a list 		    when: #isDirectory;			display: [:fileRef | [fileRef children] on: Exception do: [ Array new ] ];			format: #basenameWithIndicator.		a text			when: #isFile;			display: [:fileRef | 							[ fileRef readStream contents] 									on: Exception 									do: ['Cannot display content of file'].									].						].	browser openOn: FileSystem disk root.! !!HGlamourTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/23/2015 16:12'!test110Page192	"Example at page 192"	| browser |	self skip: 'I am finished with this example'.	browser := GLMFinder new.	browser show: [ :a | a list display: #children ].	browser openOn: FileSystem disk root.! !Object subclass: #HClient	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HClient commentStamp: 'RichardAlexanderGreen 4/21/2015 10:30' prior: 0!the Client simulates client requests.(Primarily in test/simulation context.)!!HClient methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/10/2015 20:00'!clientSettings	self assert: (super settings isKindOf: ZnUserAgentSettings).	^ super settings settings.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HClient class	instanceVariableNames: ''!!HClient class methodsFor: 'message handling' stamp: 'RichardAlexanderGreen 4/16/2015 09:04'!get: aURI	"Send URI as a HTTP GET - return ZnResponse."	| response |	response := ZnClient get: aURI.	^response.! !HEntity subclass: #HRelation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HRelation commentStamp: 'RichardAlexanderGreen 4/9/2015 09:27' prior: 0!A Relation is an "associative entity". It is identifiable and real-world.An "associative entity" differs from a "kernal entity"   in that two or more of its required-attributes are "role-type".The attribute-name of a role-type attribute names the relationship role.The attribute-value of a role-type attribute is an entity-identifier.. TODO: Give some thought about relationship (associative entity) instantiation.. Business-Relationships are typically caused by business actions.. . But: Where is the observer?. Most such business actions are transactions (buy-sell, bid, subscribe/register, assign).. . We record and track such transactional events because they represent contracts and opportunities.. Subtypes of Party and Person are often roles in such contracts.. . e.g. Customer, Worker, Supplier, Subscriber, User.. Subtypes of Order represent work-in-progress or fulfilled contracts.. . e.g. Sales-Order Purchase-Order Work-Order Requisition Option!H3dObject subclass: #H3dCamera	instanceVariableNames: 'depth scene'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!H3dCamera commentStamp: 'RichardAlexanderGreen 4/13/2016 12:21' prior: 0!A camera provides a projection of the scene onto a viewport.It is also (optionally) an object in the scene (or a layer)which can be seen by other cameras.The center of the camera is the eye-point.The viewport is located by the camera`s depth in front of the eye.The width and height attributes describe the viewport dimensions.Depth, width, height are typically in user-world metricsfor visualization of people-scaled objects.However, a micro-world bugs-view or astro-world gods-view may use measures appropriate to those scales.!!H3dCamera methodsFor: 'projection' stamp: 'RichardAlexanderGreen 4/13/2016 17:25'!projectScenePointToScreenPoint: aScenePoint	"Map a scene point onto a screen point ( x y z ) ==> ( x' y' z').	Return nil if the point cannot be mapped."	| screenPoint diff rotated dzdy dxdy x y z |	self assert: ( aScenePoint isKindOf: HumVector ).	diff := (aScenePoint - (self center)). 	rotated := ((diff pitch: (self pitch negated)) roll: (self roll negated)) yaw: (self yaw negated).	"Filter points that are behind the screen."	y := rotated y. "North"	( y < depth ) ifTrue: [ ^nil ].	x := rotated x. "East"	z := rotated z. "Up"	"Get the rise over run (tangent of angle)."	dzdy := z / y.	dxdy := x / y.	"Filter points that are not visible."	( dzdy > ( height * 0.5 / depth)) ifTrue: [ ^nil ].	( dzdy < ( height * 0.5 / depth) negated ) ifTrue: [ ^nil ].	( dxdy > ( width * 0.5 / depth) ) ifTrue: [ ^nil ].	( dxdy < ( width * 0.5 / depth) negated ) ifTrue: [ ^nil ].	"Calculate the offset in meters."	screenPoint := HumVector newFrom: { dxdy * depth.  ( y ). dzdy * depth. }.	"Original y is kept so that we can render overlaping points correctly. "	^screenPoint.! !!H3dCamera methodsFor: 'access' stamp: 'RichardAlexanderGreen 4/8/2016 10:17'!scene: aScene	"Scene (or layer) the camera is viewing."	self assert: ( aScene isKindOf: H3dObject ).	scene := aScene.! !!H3dCamera methodsFor: 'access' stamp: 'RichardAlexanderGreen 4/8/2016 08:53'!depth: aHumMeasure 	"Distance from eye point to viewport rectangle."	depth := aHumMeasure.	length := depth. "Enable showing me as a box."! !!H3dCamera methodsFor: 'access' stamp: 'RichardAlexanderGreen 4/8/2016 08:58'!depth	"Distance from eye point to viewport rectangle."	^ depth! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!H3dCamera class	instanceVariableNames: ''!!H3dCamera class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/8/2016 09:01'!depth: aDepth height: aHeight width: aWidth 	"Set pin-hole camera dimensions (values should be HumMeasures)"	| instance |	{ aDepth. aHeight. aWidth } 		do: [ :measure | self assert: (measure isKindOf: HumMeasure) ].	instance := self new.	instance 		depth: aDepth;		"distance from eye to viewport"		height: aHeight;	"height of the viewport"		width: aWidth.		"width of the viewport"	^instance.! !HumTestCase subclass: #H3dViewPortTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!H3dViewPortTests methodsFor: 'ViewPort Tests' stamp: 'RichardAlexanderGreen 4/24/2016 12:51'!test210CreateViewPort	"A viewport is a view on a scene via a camera in the scene."	| viewport camera scene scenePoint viewPoint |	viewport := H3dViewPort new.	"A viewport is mapped onto a surface."	viewport origin: 10@10 extent: 1600@900. "See: Rectangle>>origin:extent:"	"A viewport scales the camera image."	viewport scale: 100 px per: 1 centimeter.	self expect: ( HumMeasure quantity: 100*100 units: #px per: #meter ) actual: ( 100 px / 1 centimeter).	self expect: ( 100 px / 1 centimeter ) actual: ( viewport scale ).	"A viewport is attached to a camera in a scene."	camera := H3dCamera depth: 0.40 meter height: 0.20 meter width: 0.30 meter.	scene := H3dObject newAssemblyFromParts: { camera }.	camera scene: scene.	viewport camera: camera.	"A viewport maps points in the camera image to points in the viewport image."	scenePoint := (HumVector newFrom:{ 1.0 meter. 10.0 meter. 2.0 meter. }).	viewPoint := viewport mapScenePoint: scenePoint.	self expect: (HumVector newFrom: { 400 px. (10.0*100*100) px. 800 px. }) actual: viewPoint.	"How much distance does a pixel cover at y distance?"	self expect: ( 2.5 millimeter ) actual: ( viewport resolutionAt: 10.0 meter ). ! !!H3dViewPortTests methodsFor: 'Camera Tests' stamp: 'RichardAlexanderGreen 4/13/2016 17:41'!test130PitchCamera	|  camera  scenePoint viewPoint |	"A camera is a 3d-object with dimensions of ..."	camera := H3dCamera depth: 0.40 meter height: 0.20 meter width: 0.30 meter.	self expect: ( HumVector newFrom: { 0.0 meter. 0.0 meter. 0.0 meter. } ) actual: ( camera center ).	"For this test the orientation is level with no yaw."	self expect: (0.0 radian) actual: ( camera pitch ).	self expect: (0.0 radian) actual: ( camera roll ).	self expect: (0.0 radian) actual: ( camera yaw ).	"Test private method ..."	scenePoint := HumVector newFrom: { 1.0 meter. 10.0 meter. 2.0 meter. }.	viewPoint := camera projectScenePointToScreenPoint: scenePoint. 	self expect: (HumVector newFrom: { 0.04 meter. 10.0 meter. 0.08 meter. })  actual: viewPoint.	"Pitch the camera up a little."	camera pitch: ( 0.01 / 0.40 ) arcTan radian.	viewPoint := camera projectScenePointToScreenPoint: scenePoint. 	self expect: (HumVector newFrom: { 0.03981 meter. 10.047 meter. 0.06965 meter. })  actual: viewPoint.! !!H3dViewPortTests methodsFor: 'Camera Tests' stamp: 'RichardAlexanderGreen 4/13/2016 17:36'!test150YawCamera	|  camera  scenePoint viewPoint |	"A camera is a 3d-object with dimensions of ..."	camera := H3dCamera depth: 0.40 meter height: 0.20 meter width: 0.30 meter.	self expect: ( HumVector newFrom: { 0.0 meter. 0.0 meter. 0.0 meter. } ) actual: ( camera center ).	"For this test the orientation is level with no yaw."	self expect: (0.0 radian) actual: ( camera pitch ).	self expect: (0.0 radian) actual: ( camera roll ).	self expect: (0.0 radian) actual: ( camera yaw ).	"Test private method ..."	scenePoint := HumVector newFrom: { 1.0 meter. 10.0 meter. 2.0 meter. }.	viewPoint := camera projectScenePointToScreenPoint: scenePoint. 	self expect: (HumVector newFrom: { 0.04 meter. 10.0 meter. 0.08 meter. })  actual: viewPoint.	"Yaw the camera a little."	camera yaw: ( 0.01 / 0.40 ) arcTan radian.	viewPoint := camera projectScenePointToScreenPoint: scenePoint. 	self expect: (HumVector newFrom: { 0.050125 meter. 9.972 meter. 0.080226 meter. })  actual: viewPoint.! !!H3dViewPortTests methodsFor: 'Camera Tests' stamp: 'RichardAlexanderGreen 4/13/2016 17:31'!test140RollCamera	|  camera  scenePoint viewPoint |	"A camera is a 3d-object with dimensions of ..."	camera := H3dCamera depth: 0.40 meter height: 0.20 meter width: 0.30 meter.	self expect: ( HumVector newFrom: { 0.0 meter. 0.0 meter. 0.0 meter. } ) actual: ( camera center ).	"For this test the orientation is level with no yaw."	self expect: (0.0 radian) actual: ( camera pitch ).	self expect: (0.0 radian) actual: ( camera roll ).	self expect: (0.0 radian) actual: ( camera yaw ).	"Test private method ..."	scenePoint := HumVector newFrom: { 1.0 meter. 10.0 meter. 2.0 meter. }.	viewPoint := camera projectScenePointToScreenPoint: scenePoint. 	self expect: (HumVector newFrom: { 0.04 meter. 10.0 meter. 0.08 meter. })  actual: viewPoint.	"Roll the camera 90 degrees."	camera roll: (Float pi/2.0) radian.	viewPoint := camera projectScenePointToScreenPoint: scenePoint. 	self expect: (HumVector newFrom: { 0.08 meter. 10.0 meter. -0.04 meter. }) actual: viewPoint.! !!H3dViewPortTests methodsFor: 'Camera Tests' stamp: 'RichardAlexanderGreen 4/13/2016 12:35'!test110CreateCamera	| camera scene |	"A camera is a 3d-object. Dimensions refer to virtual viewport and eye-point."	camera := H3dCamera depth: 0.40 meter height: 0.20 meter width: 0.30 meter.	self expect: 0.40 meter actual: camera depth.	self expect: 0.20 meter actual: camera height.	self expect: 0.30 meter actual: camera width.	"A camera has a position in a scene."	scene := H3dObject newAssemblyFromParts: { camera }.	scene move: camera toMyCoordinate: ( HumVector newFrom: { 10. 20. 30. } ).  	self expect: 10.0 meter actual: ( camera center x ).		self expect: 20.0 meter actual: ( camera center y ).		self expect: 30.0 meter actual: ( camera center z ).	"A camera has an orientation."	camera pitch: (-10 degrees).	self expect: ( HumMeasure ) actual: ( camera pitch class ).	self expect: ( #radian ) actual: ( camera pitch units ).	self expect: ( 10 degrees negated ) actual: ( camera pitch ).	"Camera views scene"	camera scene: scene.! !!H3dViewPortTests methodsFor: 'Camera Tests' stamp: 'RichardAlexanderGreen 4/13/2016 21:14'!test160TranslateCamera	|  camera  scenePoint viewPoint |	"A camera is a 3d-object with dimensions of ..."	camera := H3dCamera depth: 0.40 meter height: 0.20 meter width: 0.30 meter.	self expect: ( HumVector newFrom: { 0.0 meter. 0.0 meter. 0.0 meter. } ) actual: ( camera center ).	"For this test the orientation is level with no yaw."	self expect: (0.0 radian) actual: ( camera pitch ).	self expect: (0.0 radian) actual: ( camera roll ).	self expect: (0.0 radian) actual: ( camera yaw ).	"Test private method ..."	scenePoint := HumVector newFrom: { 1.0 meter. 10.0 meter. 2.0 meter. }.	viewPoint := camera projectScenePointToScreenPoint: scenePoint. 	self expect: (HumVector newFrom: { 0.04 meter. 10.0 meter. 0.08 meter. })  actual: viewPoint.	"Yaw the camera a little."	camera center: (HumVector newFrom: { 1.0 meter. 0.0 meter. 0.0 meter. }).	viewPoint := camera projectScenePointToScreenPoint: scenePoint. 	self expect: (HumVector newFrom: { 0.0 meter. 10.0 meter. 0.08 meter. })  actual: viewPoint.! !!H3dViewPortTests methodsFor: 'Camera Tests' stamp: 'RichardAlexanderGreen 4/13/2016 16:54'!test120ProjectScenePointToCameraViewPort	|  camera  scenePoint viewPoint |	"A camera is a 3d-object with dimensions of ..."	camera := H3dCamera depth: 0.40 meter height: 0.20 meter width: 0.30 meter.	self expect: ( HumVector newFrom: { 0.0 meter. 0.0 meter. 0.0 meter. } ) actual: ( camera center ).	"For this test the orientation is level with no yaw."	self expect: (0.0 radian) actual: ( camera pitch ).	self expect: (0.0 radian) actual: ( camera roll ).	self expect: (0.0 radian) actual: ( camera yaw ).	"Test private method ..."	scenePoint := HumVector newFrom: { 1.0 meter. 10.0 meter. 2.0 meter. }.	viewPoint := camera projectScenePointToScreenPoint: scenePoint. 	self expect: (HumVector newFrom: { 0.04 meter. 10.0 meter. 0.08 meter. })  actual: viewPoint .! !HumTestCase subclass: #HBaseTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HBaseTests commentStamp: 'RichardAlexanderGreen 4/8/2015 12:09' prior: 0!The World Base represents "corporate memory".It records business events and entity attribute values.Use Cases: (There should be at least one test for each use case.)==========Business Events:. Plan Frame post-condition satisfied.. Dialog context changed.Entity Attribute values:. Dialog noun value set by input pattern.. Dialog noun values set by 'Ask view-name'.!!HBaseTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/3/2015 10:19'!test240WorldBaseBacksBlackBoard	"Blackboard calls on World Base to persist events, state-changes."	| event blackboard |		blackboard := HBlackboard new.	blackboard worldBase: HBase new.		event := HEvent who: 'TTester' what: 'named' when: (HTime now)	              where: 'test240WorldBaseBacksBlackBoard' 	                why: 'intialize blackboard nouns'. 		blackboard putEvent: event.		"Put first name, last name"	blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event.		blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event.		! !Object subclass: #HTimeTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HTimeTests commentStamp: 'RichardAlexanderGreen 2/29/2016 09:45' prior: 0!Deliberately removed from test sets.!!HTimeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/2/2015 11:17'!test120timestampIsUnique	""	| a  n |	n := 1e4. 	"n = 1e4 resembles a database transaction rate.	 n = 1e5 runs in about 2 seconds. 	     1e6 requires 20-25 seconds."	a := Array new: n.	( 1 to: n )		do: [ :i | a at: i put: (HTime timeStamp) ].	self assert: (( a at: 1 ) < ( a at: 2 )).		self assert: (( a at: 1 ) < ( a atRandom )) description: 'Can trip if atRandom happens to pull (a at: 1)'.	self assert: (( a at: 1 ) < ( a at: n )).! !!HTimeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/31/2015 22:20'!test110timestampIsBigInteger	""	| t |	t := HTime timeStamp.	self assert: ( t isKindOf: Integer ).! !Object subclass: #HEntityTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HEntityTests commentStamp: 'RichardAlexanderGreen 2/29/2016 09:45' prior: 0!Deliberately removed from test sets.!!HEntityTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/30/2015 10:26'!test130UpdateAttributeValueInEvent	"An entity has one or more attributes"	| entity value event event2 |	event := HEvent who: 'TTester' what: 'named' when: (TimeStamp now)	              where: 'test130UpdateAttributeValueInEvent' 	                why: 'testing entity-initialize attributes'. 	entity := HEntity new.	"Put first name"	entity attribute: 'first-name' value: 'Tessie' event: event.	value := entity getAttribute: 'first-name'.	"Put last name"	self expect: 'Tessie' actual: value.		entity attribute: 'last-name' value: 'Tester' event: event.	value := entity getAttribute: 'last-name'.	self expect: 'Tester' actual: value.	"First name is still there"	value := entity getAttribute: 'first-name'.	self expect: 'Tessie' actual: value.	"============"	event2 := HEvent who: 'TTester' what: 'renamed' when: (TimeStamp now)	              where: 'test130UpdateAttributeValueInEvent-rename' 	                why: 'testing entity-rename updates attributes'. 	entity := HEntity new.	"Put first name"	entity attribute: 'first-name' value: 'Teddy' event: event2.	value := entity getAttribute: 'first-name'.	"Put last name"	self expect: 'Teddy' actual: value.		entity attribute: 'last-name' value: 'Tinker' event: event2.	value := entity getAttribute: 'last-name'.	self expect: 'Tinker' actual: value.	"First name is still there"	value := entity getAttribute: 'first-name'.	self expect: 'Teddy' actual: value.			! !!HEntityTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/30/2015 09:16'!test110EntityHasAttributes	"An entity has one or more attributes"	| entity value |	entity := HEntity new.	"Put first name"	entity attribute: 'first-name' value: 'Tessie'.	value := entity getAttribute: 'first-name'.	"Put last name"	self expect: 'Tessie' actual: value.		entity attribute: 'last-name' value: 'Tester'.	value := entity getAttribute: 'last-name'.	self expect: 'Tester' actual: value.	"First name is still there"	value := entity getAttribute: 'first-name'.	self expect: 'Tessie' actual: value.		! !!HEntityTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/2/2015 11:23'!test125EntityPrintOn	"An entity has one or more attributes"	| entity event stream |	event := HEvent who: 'TTester' what: 'named' when: (TimeStamp now)	              where: 'test120SetAttributeValueInEvent' 	                why: 'test120SetAttributeValueInEvent'. 	entity := HEntity title: 'tester'.	"Put first name"	entity attribute: 'first-name' value: 'Tessie' event: event.		entity attribute: 'last-name' value: 'Tester' event: event.		stream := ReadWriteStream on: ''.	entity printOn: stream.	self expect: 'tester: 	first-name: Tessie	last-name: Tester' 			actual: ( stream contents ).		! !!HEntityTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/30/2015 09:47'!test120SetAttributeValueInEvent	"An entity has one or more attributes"	| entity value event |	event := HEvent who: 'TTester' what: 'named' when: (TimeStamp now)	              where: 'test120SetAttributeValueInEvent' 	                why: 'test120SetAttributeValueInEvent'. 	entity := HEntity new.	"Put first name"	entity attribute: 'first-name' value: 'Tessie' event: event.	value := entity getAttribute: 'first-name'.	"Put last name"	self expect: 'Tessie' actual: value.		entity attribute: 'last-name' value: 'Tester' event: event.	value := entity getAttribute: 'last-name'.	self expect: 'Tester' actual: value.	"First name is still there"	value := entity getAttribute: 'first-name'.	self expect: 'Tessie' actual: value.		! !Object subclass: #HBase	instanceVariableNames: 'events entities'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HBase commentStamp: 'RichardAlexanderGreen 4/9/2015 10:39' prior: 0!The World Base represents "corporate memory".It records business events and entity attribute values.Business Events:. Plan Frame post-condition satisfied. (Plan Coordinator WIP persistence). Dialog context changed.. TODO: Give some thought about relationship (associative entity) instantiation.. . Business-Relationships are typically caused by business actions.. . But: Where is the observer?. . Most such business actions are transactions (buy-sell, bid, subscribe/register, assign).Entity Attribute values:. Dialog noun value set by input pattern. . Dialog noun value set by 'Ask view-name'.Three cases are "dialog-persistence" - providing persistence for a dialog blackboard.Actors that need persistent state may also use a world base component.However, that component does not necessarily need to be the enterprise world base.Different actors may, in effect, live in different worlds.Other persistence mechanisms:. Job-Ticket charges - are handled by bookkeeper - Charges have a different meaning and dynamic than world base.. Actor`s internal state - Example: a robot may perist its internal state (blackboard) separately.. Coordinator state - (Noun blackboard + Plan WIP state). Dispatcher state - (Actor available, busy) !!HBase methodsFor: 'events-registering' stamp: 'RichardAlexanderGreen 4/3/2015 10:31'!putEntity: anEntity attribute: anAttribute value: aValue event: anEvent 	"Record entity attribute value"	| entity |	entity := (self entities) at: (anEntity id) 										ifAbsent: [nil].	entity 		ifNil: [entity := HEntity title: (anEntity title). 			      entity id: (anEntity id).			].		entity attribute: anAttribute value: aValue event: anEvent.	(self entities) at: (anEntity id) put: entity.  ! !!HBase methodsFor: 'events-registering' stamp: 'RichardAlexanderGreen 4/7/2015 14:34'!putEvent: anEvent 	"Record the given event in my store."	|  |	(self events) at: (anEvent id) put: anEvent.	! !!HBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:36'!entities	"Dictionary of (id -> entity)"	^ entities ifNil: [ entities := Dictionary new ].! !!HBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/7/2015 14:34'!events	^events ifNil: [ events := Dictionary new ].! !Object subclass: #H3dViewPort	instanceVariableNames: 'rectangle scale camera'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!H3dViewPort commentStamp: 'RichardAlexanderGreen 4/14/2016 07:44' prior: 0!A 3D viewport is a view of a scene via a camera in the scene.A 3D viewport is also a controller that can move the camera.A 3D viewport is also a user-interface widget with the camera`s view mapped into a raster / canvas / bitmap / form.The bitmap is dimensioned in pixels.See also: FormCanvas Form BitBlt!!H3dViewPort methodsFor: 'access' stamp: 'RichardAlexanderGreen 4/24/2016 12:33'!origin: pointOrigin extent: pointExtent  	"What is my origin and extent in container coordinates and pixel metrics?"	self assert: ( pointOrigin isKindOf: Point ).	self assert: ( pointOrigin x isKindOf: Integer ). "pixel (px) units are assumed."	self assert: ( pointOrigin y isKindOf: Integer ). "pixel (px) units are assumed."	self assert: ( pointExtent isKindOf: Point ).	self assert: ( pointExtent x isKindOf: Integer ). "pixel (px) units are assumed."	self assert: ( pointExtent y isKindOf: Integer ). "pixel (px) units are assumed."	self assert: ( pointExtent x > 0 ). "Extent is non-negative / positive-definite."	self assert: ( pointExtent y > 0 ). "Extent is non-negative / positive-definite."	"As a practival matter, viewports dimensions need to be in the hundreds."		rectangle := Rectangle origin: pointOrigin extent: pointExtent. ! !!H3dViewPort methodsFor: 'access' stamp: 'RichardAlexanderGreen 4/14/2016 08:29'!camera: anH3dCamera 	"The viewport is attached to this camera."	camera := anH3dCamera.! !!H3dViewPort methodsFor: 'access' stamp: 'RichardAlexanderGreen 4/24/2016 12:48'!scale: measureNumerator per: measureDenominator 	"Multiply camera screen coordinates by scale to get my coordinates."	"Expect the numerator to be pixels 	and the denominator to be a length that translates to SI length units."	self assert: ( measureNumerator dimensions = ( 1 px ) dimensions ).	self assert: ( measureDenominator dimensions = ( 1 centimeter 	) dimensions ).	scale := measureNumerator / measureDenominator.! !!H3dViewPort methodsFor: 'access' stamp: 'RichardAlexanderGreen 4/14/2016 19:02'!scale	^scale ifNil: [ Error signal: 'This viewport`s scale has not been set yet.' ].! !!H3dViewPort methodsFor: 'draw' stamp: 'RichardAlexanderGreen 4/24/2016 12:40'!mapScenePoint: aScenePoint 	"Map scene point to camera image, camera image to my image."	| viewPoint cameraPoint |	self assert: (aScenePoint isKindOf: HumVector).	"The camera returns nil if the point is not visible on its screen, and so do we."	cameraPoint := camera projectScenePointToScreenPoint: aScenePoint.	cameraPoint ifNil: [ ^nil ].	"TODO: Returning nil as a signal is generally a bad idea."	"One of the problems with returning nil, is that the point may be the start of a line."	"Another problem is that I will have to screen for nils in all of the down-stream code."	viewPoint := cameraPoint * scale.	^viewPoint.		! !!H3dViewPort methodsFor: 'draw' stamp: 'RichardAlexanderGreen 4/24/2016 12:53'!resolutionAt: aDistance	"What is the resolution per pixel at given distance"	| d dsdy resolution |	self assert: ( scale isNotNil ).	self assert: ( aDistance isKindOf: HumMeasure ).	d := (1 pixel) / scale. " px / (px/mm) ==> px * mm / px ==> mm"	dsdy := d / (camera depth).  " mm / mm ==> a scalar"	resolution := aDistance * dsdy.	^resolution.! !Object subclass: #HGlamour	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HGlamour commentStamp: 'RichardAlexanderGreen 2/29/2016 09:45' prior: 0!Deliberately removed from test sets.!HEntity subclass: #HEvent	instanceVariableNames: 'who what where why when'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HEvent commentStamp: 'RichardAlexanderGreen 2/4/2016 11:07' prior: 0!a business event (not to be confused with a data event)	Events serve as a kind of log. Events give data values a business (causality) context.'		instance		id: (HTime timeStamp); "Unique identifier."		who: aWho;				"who is associated with the cause - e.g. client-id/actor-id"		what: aWhat; 		"What is happening - e.g. Action statement"		where: aWhere;  	"Where: a host"		why: aWhy;				"Why: a job or seesion"		when: aTimeStamp. "Observer`s clock. May be simulator clock."'Although data events may be the framework`s way of remembering/recording a business event,the two concepts should not be confused.In the run-time framework,business-events are automatically recorded when:- a post-condition is satisfied in a running plan.- a client/user provides a value for a noun- - via "Ask view-name"- - by matching parameters in a vignette pattern.- an action procedure executes a 'giving' instruction. (Perhaps this should be limited in some way.)Examples:- Post-condition satisfied.- - who: client-id  what: post-condition  where: host-URI  why: job-id (top-goal, client, authorization)- Instruction giving persistent noun-value.- - who: actor-id   what: instruction     where: host-URI  why: job-id- Noun value entered.- - who: client-id  what: vignette	where: host-URI  why: session-id - - who: client-id  what: view		where: host-URI  why: session-id  !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:38'!when: aTimeStamp 	"When did the event occur? Real clock or simulated clock"	when := aTimeStamp! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:35'!id: aLargePositiveInteger 	id := aLargePositiveInteger.! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/7/2015 14:40'!attributes	| dict |	dict := (super attributes).	dict		at: 'who' put: who;		at: 'what' put: what;		at: 'when' put: when;		at: 'where' put: where;		at: 'why' put: why.! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:40'!who: aWho 	"Who caused the event? - User/Robot/Actor/Test"	who := aWho.! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:42'!why: aWhy 	"Why did the event occur? - Authorization/JobTicket"	why := aWhy.! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:39'!where: aWhere 	"Where did event occur? - Test/Simulation/Host/Application/Service"	where := aWhere! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/30/2015 10:40'!when	^ when! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:38'!what: aWhat 	"What happened? (Relate to business process event.)"	what := aWhat.! !!HEvent methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 3/30/2015 10:39'!> otherEvent 	| result |	result := (self when) > (otherEvent when).	^result.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HEvent class	instanceVariableNames: ''!!HEvent class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/21/2015 10:25'!who: aWho what: aWhat when: aTimeStamp where: aWhere why: aWhy  	| instance |	instance := self basicNew.	instance		who: aWho;				"Who is associated with the event? - client-id/actor-id"		what: aWhat; 			"What is happening? - statement / vignette / view"		when: aTimeStamp; 	"Observer`s clock. May be simulator clock."		where: aWhere;  		"Where? - a host-URI"		why: aWhy;				"Why?   - a job ticket or session identifier"		id: (HTime timeStamp). "Unique identifier for the event."	^instance.
"Examples:- Post-condition satisfied.- - who: client-id  what: post-condition  where: host-URI  why: job-id (top-goal, client, originating-session-id)- Instruction giving persistent noun-value.- - who: actor-id   what: instruction     where: host-URI  why: job-id- Noun value/s entered.- - who: client-id  what: vignette+pattern        where: host-URI  why: session-id - - who: client-id  what: vignette+view            where: host-URI  why: session-id See: Class documentation."! !Object subclass: #HumXReadMe	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HumXReadMe commentStamp: 'RichardAlexanderGreen 4/21/2015 10:15' prior: 0!The Hum-X package contains 'thinking out loud' code.Basically, I am thinking about refactoring the persistence system.My review of current code for world-base, blackboard, entity (HumWorldBase, HumBlackboard, HumEntity)caused me to feel that there was a design problem - those classes did not conform to my expected abstractions.Also: My fondness for "quad" data structure seemed to be skewing the design and the code.So I decided to experiment with a redesign.So far, it appears that giving more strength to the Entity concept seems to simplify blackboard and base.I simplified HTime - making it a singleton that generates unique timestamps as large integers.That seems to be simplifying some of the code.I made Event an explicit class and a subclass of Entity.The who, what, when, where, why attributes of Event are NOT sufficiently well-defined as a methodology for consistently describing a business event.But I am reluctant to abandon the five W`s.  (See HEvent for attempt to stabilize.)!Object subclass: #HTime	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HTime commentStamp: 'RichardAlexanderGreen 4/21/2015 10:33' prior: 0!HTime is a singleton whose purpose is to return a unique time-stamp.The time-stamp is monotonically increasing over time.It is guranteed unique within the context where the singleton executes.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HTime class	instanceVariableNames: 'clock'!!HTime class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 10:32'!reset	clock := 0.! !!HTime class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:47'!timeStamp	"Return a large positive integer representing the number of nanoseconds since ..."	| priorClock microSeconds |	priorClock := clock. "Clock is CLASS VARIABLE"	microSeconds := 0. "Replace this if you find something that works."	clock := ( ( self seconds ) * 1e6 ) + microSeconds. 	[ clock <= priorClock ] 		whileTrue: [ clock := priorClock + 1 ]. "We can get away with this because of nanos implementation."	"If you tinker with this method, call (HTime reset) to reset clock to zero/nil."	^clock. ! !!HTime class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:45'!new	self shouldNotImplement.! !!HTime class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/3/2015 09:00'!seconds	"Return number of seconds since beginning of epoc"	| ticks tickDays tickSeconds seconds |	DateAndTime now.	ticks := DateAndTime now asUTC ticks copy.	tickDays := ticks at: 1.	tickSeconds := ticks at: 2.	"	tickNanos := ticks at: 3.	self assert: (tickNanos = 0).	"	"WARNING: tickNanos is not really nano-seconds. 	 The actual meaning depends on context.	 Context = TimeStamp class and Operating System implementation."		seconds := ( tickDays * 86400 ) + tickSeconds. 	^seconds! !!HTime class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/31/2015 21:15'!now	^ self timeStamp.! !