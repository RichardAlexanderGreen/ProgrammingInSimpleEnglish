Object subclass: #HApplication	instanceVariableNames: 'myHandler'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HApplication commentStamp: 'RichardAlexanderGreen 4/21/2015 10:26' prior: 0!An application instance handles HTTP requests.!!HApplication methodsFor: 'message handling' stamp: 'RichardAlexanderGreen 4/10/2015 21:14'!handleRequest: aZnRequest 	"Return a response for given request"	| response |	response := myHandler value: aZnRequest.	^response.! !!HApplication methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/10/2015 21:12'!handler: aBlockClosure 	"Use the block to handle request"	myHandler := aBlockClosure.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HApplication class	instanceVariableNames: ''!!HApplication class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/16/2015 22:19'!echo	"Return an instance of myself handles request by echoing it."	| instance |		instance := self basicNew.	instance handler: [:request |  			| entity  response stream string |			stream := ReadWriteStream on: ''.			stream 				nextPutAll: ( request requestLine method  );			  nextPutAll: '...';			  nextPutAll: ( request requestLine uri pathPrintString).			(request requestLine method sameAs: 'POST') 				ifTrue: [ "Show POST and query"					stream nextPutAll: (String cr); nextPutAll: 'POST: '.					(request requestLine uri query isNil) 						ifTrue: [stream << ' No query arguments seen.']						ifFalse:[request requestLine uri queryDo: [:k :v | stream nextPutAll: (k, '=', v, '  ') ].							]					].						string := stream contents.			(string trimBoth size > 0) ifFalse: [string:= 'Method and URI not seen in echo.'].			(request headers) keysAndValuesDo: [:k :v | string := string, String cr, k,': ',v ].			entity := ZnStringEntity text: string.  		  response := ZnResponse ok: entity.		  response.		  ].	^instance.! !Object subclass: #HumXReadMe	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HumXReadMe commentStamp: 'RichardAlexanderGreen 4/21/2015 10:15' prior: 0!The Hum-X package contains 'thinking out loud' code.Basically, I am thinking about refactoring the persistence system.My review of current code for world-base, blackboard, entity (HumWorldBase, HumBlackboard, HumEntity)caused me to feel that there was a design problem - those classes did not conform to my expected abstractions.Also: My fondness for "quad" data structure seemed to be skewing the design and the code.So I decided to experiment with a redesign.So far, it appears that giving more strength to the Entity concept seems to simplify blackboard and base.I simplified HTime - making it a singleton that generates unique timestamps as large integers.That seems to be simplifying some of the code.I made Event an explicit class and a subclass of Entity.The who, what, when, where, why attributes of Event are NOT sufficiently well-defined as a methodology for consistently describing a business event.But I am reluctant to abandon the five W`s.  (See HEvent for attempt to stabilize.)!Object subclass: #HClient	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HClient commentStamp: 'RichardAlexanderGreen 4/21/2015 10:30' prior: 0!the Client simulates client requests.(Primarily in test/simulation context.)!!HClient methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/10/2015 20:00'!clientSettings	self assert: (super settings isKindOf: ZnUserAgentSettings).	^ super settings settings.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HClient class	instanceVariableNames: ''!!HClient class methodsFor: 'message handling' stamp: 'RichardAlexanderGreen 4/16/2015 09:04'!get: aURI	"Send URI as a HTTP GET - return ZnResponse."	| response |	response := ZnClient get: aURI.	^response.! !Object subclass: #HGlamour	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HGlamour commentStamp: 'RichardAlexanderGreen 2/29/2016 09:45' prior: 0!Deliberately removed from test sets.!HumTestCase subclass: #H3dObjectTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 11:05'!test220moveBoxEast	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	box east: 40 meters.	self expect: (40 meter) actual: (box east).	self expect: (35 meter) actual: (box center x).	self expect: 40 meter actual: (box maxX).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/7/2016 12:05'!test110buildBox	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	"Check that dimension were stored."	self expect: (HumMeasure quantity: (10*20*30) units: 'cubic meter') actual: (box volume).	self expect: 6 actual: (box polygons size).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:09'!test120yawBox90degrees	"90 degree yaw exchanges X and Y"	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box yaw: ((Float pi)/ 2.0) radian.	self expect: ( 10.0 meter ) actual: ( box maxX ).		self expect: ( 05.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:09'!test125yawBox180degrees	"180 degree rotations should leave bounds the same."	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box yaw: ((Float pi)) radian.	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 11:10'!test225moveBoxWest	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( -5.0 meter) actual: (box west).	box west: 40 meters.	self expect: (40 meter) actual: (box west).	self expect: (45 meter) actual: (box center x).	self expect: 40 meter actual: (box minX).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 11:16'!test235moveBoxSouth	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (-10 meter) actual: (box south).	box south: 40 meters.	self expect: (40 meter) actual: (box south).	self expect: (50 meter) actual: (box center y).	self expect: (40 meter) actual: (box minY).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:05'!test330stepPitchRate	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (05 meter) actual: (box east).	self expect: (10 meter) actual: (box north).	self expect: (15 meter) actual: (box top).	box pitchRate: (0.25 rps).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	box step: (HumMeasure seconds: 1).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	"Expect Y and Z bounds to exchange."	self expect: (05 meter) actual: (box maxX).	self expect: (15 meter) actual: (box maxY).	self expect: (10 meter) actual: (box maxZ).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 10:34'!test230moveBoxNorth	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (10 meter) actual: (box maxY).	box north: 40 meters.	self expect: (40 meter) actual: (box north).	self expect: (30 meter) actual: (box center y).	self expect: (40 meter) actual: (box maxY).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 11:21'!test245moveBoxBottom	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (-15 meter) actual: (box bottom).	box bottom: 40 meters.	self expect: (40 meter) actual: (box bottom).	self expect: (55 meter) actual: (box center z).	self expect: (40 meter) actual: (box minZ).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:06'!test340stepRollRate	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (05 meter) actual: (box east).	self expect: (10 meter) actual: (box north).	self expect: (15 meter) actual: (box top).	box rollRate: (0.25 rps).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	box step: (HumMeasure seconds: 1).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	"Expect X and Z bounds to exchange."	self expect: (15 meter) actual: (box maxX).	self expect: (10 meter) actual: (box maxY).	self expect: (05 meter) actual: (box maxZ).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:09'!test135pitchBox180degrees	"180 degree rotations should leave bounds the same."	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box pitch: ((Float pi)) radian.	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:09'!test140rollBox90degrees	"90 degree roll exchanges X and Z"	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box roll: ((Float pi)/ 2.0) radian.	self expect: ( 15.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 05.0 meter ) actual: ( box maxZ ).		! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:10'!test145rollBox180degrees	"180 degree rotations should leave bounds the same."	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box roll: ((Float pi)) radian.	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/12/2016 10:14'!test325stepVelocityAndYawRate	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (05 meter) actual: (box east).	self expect: (10 meter) actual: (box north).	self expect: (15 meter) actual: (box top).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	self expect: (05 meter) actual: (box maxX).	self expect: (10 meter) actual: (box maxY).	self expect: (15 meter) actual: (box maxZ).	box yawRate: (0.25 rps).	box velocity: ( HumVector newFrom: { 100 mps. 100 mps. 100 mps.} ).	box step: (HumMeasure seconds: 1).	self expect: ( HumVector newFrom: {100 meter. 100 meter. 100 meter} ) actual: (box center).	"Expect X and Y bounds to exchange."	self expect: (110 meter) actual: (box maxX).	self expect: (105 meter) actual: (box maxY).	self expect: (115 meter) actual: (box maxZ).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/12/2016 10:22'!test345stepVelocityAndRollRate	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (05 meter) actual: (box east).	self expect: (10 meter) actual: (box north).	self expect: (15 meter) actual: (box top).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	self expect: (05 meter) actual: (box maxX).	self expect: (10 meter) actual: (box maxY).	self expect: (15 meter) actual: (box maxZ).	box rollRate: (0.25 rps).	box velocity: ( HumVector newFrom: { 100 mps. 100 mps. 100 mps.} ).	box step: (HumMeasure seconds: 1).	self expect: ( HumVector newFrom: {100 meter. 100 meter. 100 meter} ) actual: (box center).	"Expect X and Z bounds to exchange."	self expect: (115 meter) actual: (box maxX).	self expect: (110 meter) actual: (box maxY).	self expect: (105 meter) actual: (box maxZ).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/12/2016 20:35'!test350stepEverything	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (05 meter) actual: (box east).	self expect: (10 meter) actual: (box north).	self expect: (15 meter) actual: (box top).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	self expect: (05 meter) actual: (box maxX).	self expect: (10 meter) actual: (box maxY).	self expect: (15 meter) actual: (box maxZ).	box yawRate: (0.5 rps). "Rotate 180 degrees per second. -- Should leave maxX . . . the same."	box pitchRate: (0.5 rps).	box rollRate: (0.5 rps).	box velocity: ( HumVector newFrom: { 100 mps. 100 mps. 100 mps.} ).	box step: (HumMeasure seconds: 1).	self expect: ( HumVector newFrom: {100 meter. 100 meter. 100 meter} ) actual: (box center).	"Expect X and Z bounds to exchange."	self expect: (105 meter) actual: (box maxX).	self expect: (110 meter) actual: (box maxY).	self expect: (115 meter) actual: (box maxZ).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:06'!test310stepVelocity	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	box velocity: (HumVector newFrom: {1 mps. 2 mps. 3 mps.} ).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	box step: (HumMeasure seconds: 1).	self expect: ( HumVector newFrom: {1 meter. 2 meter. 3 meter} ) actual: (box center).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/12/2016 10:21'!test335stepVelocityAndPitchRate	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (05 meter) actual: (box east).	self expect: (10 meter) actual: (box north).	self expect: (15 meter) actual: (box top).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	self expect: (05 meter) actual: (box maxX).	self expect: (10 meter) actual: (box maxY).	self expect: (15 meter) actual: (box maxZ).	box pitchRate: (0.25 rps).	box velocity: ( HumVector newFrom: { 100 mps. 100 mps. 100 mps.} ).	box step: (HumMeasure seconds: 1).	self expect: ( HumVector newFrom: {100 meter. 100 meter. 100 meter} ) actual: (box center).	"Expect Y and Z bounds to exchange."	self expect: (105 meter) actual: (box maxX).	self expect: (115 meter) actual: (box maxY).	self expect: (110 meter) actual: (box maxZ).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:04'!test320stepYawRate	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (05 meter) actual: (box east).	self expect: (10 meter) actual: (box north).	self expect: (15 meter) actual: (box top).	box yawRate: (0.25 rps).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	box step: (HumMeasure seconds: 1).	self expect: ( HumVector newFrom: {0 meter. 0 meter. 0 meter} ) actual: (box center).	"Expect X and Y bounds to exchange."	self expect: (10 meter) actual: (box maxX).	self expect: (05 meter) actual: (box maxY).	self expect: (15 meter) actual: (box maxZ).	! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/7/2016 12:13'!test150yawPitchRollBox	"180 degree rotations should leave it looking the same."	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box yaw: ((Float pi)) radian.	box pitch: ((Float pi)) radian.	box roll: ((Float pi)) radian.	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 11:07'!test240moveBoxTop	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: (15 meter) actual: (box maxZ).	box top: 40 meters.	self expect: (40 meter) actual: (box top).	self expect: (25 meter) actual: (box center z).	self expect: (40 meter) actual: (box maxZ).! !!H3dObjectTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/11/2016 13:09'!test130pitchBox90degrees	"90 degree pitch exchanges Y and Z"	| box |	box := H3dObject newBoxWidth: (10 meter) length: (20 meter) height: (30 meter).	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 10.0 meter ) actual: ( box maxY ).		self expect: ( 15.0 meter ) actual: ( box maxZ ).		box pitch: ((Float pi)/ 2.0) radian.	self expect: ( 05.0 meter ) actual: ( box maxX ).		self expect: ( 15.0 meter ) actual: ( box maxY ).		self expect: ( 10.0 meter ) actual: ( box maxZ ).		! !Object subclass: #HTime	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HTime commentStamp: 'RichardAlexanderGreen 4/21/2015 10:33' prior: 0!HTime is a singleton whose purpose is to return a unique time-stamp.The time-stamp is monotonically increasing over time.It is guranteed unique within the context where the singleton executes.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HTime class	instanceVariableNames: 'clock'!!HTime class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 10:32'!reset	clock := 0.! !!HTime class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:47'!timeStamp	"Return a large positive integer representing the number of nanoseconds since ..."	| priorClock microSeconds |	priorClock := clock. "Clock is CLASS VARIABLE"	microSeconds := 0. "Replace this if you find something that works."	clock := ( ( self seconds ) * 1e6 ) + microSeconds. 	[ clock <= priorClock ] 		whileTrue: [ clock := priorClock + 1 ]. "We can get away with this because of nanos implementation."	"If you tinker with this method, call (HTime reset) to reset clock to zero/nil."	^clock. ! !!HTime class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:45'!new	self shouldNotImplement.! !!HTime class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/3/2015 09:00'!seconds	"Return number of seconds since beginning of epoc"	| ticks tickDays tickSeconds seconds |	DateAndTime now.	ticks := DateAndTime now asUTC ticks copy.	tickDays := ticks at: 1.	tickSeconds := ticks at: 2.	"	tickNanos := ticks at: 3.	self assert: (tickNanos = 0).	"	"WARNING: tickNanos is not really nano-seconds. 	 The actual meaning depends on context.	 Context = TimeStamp class and Operating System implementation."		seconds := ( tickDays * 86400 ) + tickSeconds. 	^seconds! !!HTime class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/31/2015 21:15'!now	^ self timeStamp.! !Object subclass: #HTimeTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HTimeTests commentStamp: 'RichardAlexanderGreen 2/29/2016 09:45' prior: 0!Deliberately removed from test sets.!!HTimeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/2/2015 11:17'!test120timestampIsUnique	""	| a  n |	n := 1e4. 	"n = 1e4 resembles a database transaction rate.	 n = 1e5 runs in about 2 seconds. 	     1e6 requires 20-25 seconds."	a := Array new: n.	( 1 to: n )		do: [ :i | a at: i put: (HTime timeStamp) ].	self assert: (( a at: 1 ) < ( a at: 2 )).		self assert: (( a at: 1 ) < ( a atRandom )) description: 'Can trip if atRandom happens to pull (a at: 1)'.	self assert: (( a at: 1 ) < ( a at: n )).! !!HTimeTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/31/2015 22:20'!test110timestampIsBigInteger	""	| t |	t := HTime timeStamp.	self assert: ( t isKindOf: Integer ).! !Object subclass: #HBase	instanceVariableNames: 'events entities'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HBase commentStamp: 'RichardAlexanderGreen 4/9/2015 10:39' prior: 0!The World Base represents "corporate memory".It records business events and entity attribute values.Business Events:. Plan Frame post-condition satisfied. (Plan Coordinator WIP persistence). Dialog context changed.. TODO: Give some thought about relationship (associative entity) instantiation.. . Business-Relationships are typically caused by business actions.. . But: Where is the observer?. . Most such business actions are transactions (buy-sell, bid, subscribe/register, assign).Entity Attribute values:. Dialog noun value set by input pattern. . Dialog noun value set by 'Ask view-name'.Three cases are "dialog-persistence" - providing persistence for a dialog blackboard.Actors that need persistent state may also use a world base component.However, that component does not necessarily need to be the enterprise world base.Different actors may, in effect, live in different worlds.Other persistence mechanisms:. Job-Ticket charges - are handled by bookkeeper - Charges have a different meaning and dynamic than world base.. Actor`s internal state - Example: a robot may perist its internal state (blackboard) separately.. Coordinator state - (Noun blackboard + Plan WIP state). Dispatcher state - (Actor available, busy) !!HBase methodsFor: 'events-registering' stamp: 'RichardAlexanderGreen 4/3/2015 10:31'!putEntity: anEntity attribute: anAttribute value: aValue event: anEvent 	"Record entity attribute value"	| entity |	entity := (self entities) at: (anEntity id) 										ifAbsent: [nil].	entity 		ifNil: [entity := HEntity title: (anEntity title). 			      entity id: (anEntity id).			].		entity attribute: anAttribute value: aValue event: anEvent.	(self entities) at: (anEntity id) put: entity.  ! !!HBase methodsFor: 'events-registering' stamp: 'RichardAlexanderGreen 4/7/2015 14:34'!putEvent: anEvent 	"Record the given event in my store."	|  |	(self events) at: (anEvent id) put: anEvent.	! !!HBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:36'!entities	"Dictionary of (id -> entity)"	^ entities ifNil: [ entities := Dictionary new ].! !!HBase methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/7/2015 14:34'!events	^events ifNil: [ events := Dictionary new ].! !Object subclass: #HClientServerTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HClientServerTests commentStamp: 'RichardAlexanderGreen 7/19/2015 09:16' prior: 0!NOTE: This test suite is currently disabled by making the supertype "Object" instead of "TestCase".!!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:46'!test214CharacterizeZnHTTPSocketFacadeConnected	"Characterize ZnHttpClient"	| client responseStream |	client := ZnHTTPSocketFacade new.	self expect: ZnHTTPSocketFacade actual: client class.  responseStream := ZnHTTPSocketFacade httpGet: 'http://localhost:8081'.	self expect: (RWBinaryOrTextStream) actual: (responseStream class).	self assert: ('*<title>Zinc HTTP Components</title>*' matches: responseStream contents).! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/15/2015 14:08'!test110CharacterizeZnHttpClient	"Characterize ZnHttpClient"	| client settings |	client := ZnHttpClient new.	self expect: ZnHttpClient actual: client class.	"At this point the client has nothing much going on." 	self assert: client response isNil.	self assert: client request isNil.	self expect: ZnUserAgentSettings actual: client settings class.	settings := client settings settings.	self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).	self expect: true actual: (settings at: #followRedirect ).	self expect: 7 actual: (settings at: #redirectLimit ).		self expect: 180 actual: (settings at: #timeout ).	self expect: 4 actual: (settings size).	! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 09:58'!test190CharacterizeHClient	"HClient is light wrapper on ZnHTTPSocketFacade."	| client settings |	false ifFalse: [ Transcript cr; show: 'test190CharacterizeHClient is turned off'; cr. ^self].	client := HClient new.	self expect: HClient actual: client class.	"At this point the client has nothing much going on." 	self assert: client response isNil.	self assert: client request isNil.	settings := client clientSettings.	self expect: Dictionary actual: settings class.	self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' 	                  actual: ( settings at: #agent ).	self expect: true actual: ( settings at: #followRedirect ).	self expect: 7    actual: ( settings at: #redirectLimit ).		self expect: 180  actual: ( settings at: #timeout ).	"That`s all folks!!"	self expect: 4 actual: (settings size).! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:46'!test216CharacterizeZnHTTPSocketFacadePost	"Characterize ZnHttpClient"	| client responseStream dict |	client := ZnHTTPSocketFacade new.	self expect: ZnHTTPSocketFacade actual: client class.		dict := Dictionary newFrom: {'name'->'tester'.}.  responseStream := ZnHTTPSocketFacade httpPost: 'http://localhost:8081' args: dict accept: ''.	self expect: (RWBinaryOrTextStream) actual: (responseStream class).	self assert: ('*<title>Zinc HTTP Components</title>*' matches: responseStream contents).! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:46'!test212CharacterizeZnHTTPSocketFacadeNotFound	"Characterize ZnHttpClient"	| client responseStream |	client := ZnHTTPSocketFacade new.	self expect: ZnHTTPSocketFacade actual: client class.  responseStream := ZnHTTPSocketFacade httpGet: 'http://localhost:8081/test'.	self expect: (ByteString) actual: (responseStream class).	self assert: ('*Not Found*' matches: responseStream).! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:45'!test112CharacterizeZnHttpClientNotFound	"Characterize ZnHttpClient"	| client settings response responseString |	client := ZnHttpClient new.	self expect: ZnHttpClient actual: client class.	"At this point the client has nothing much going on." 	self assert: client response isNil.	self assert: client request isNil.	self expect: ZnUserAgentSettings actual: client settings class.	settings := client settings settings.	self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).	self expect: true actual: (settings at: #followRedirect ).	self expect: 7 actual: (settings at: #redirectLimit ).		self expect: 180 actual: (settings at: #timeout ).	self expect: 4 actual: (settings size).		client url: 'http://localhost:8081/nonesuch'.
  responseString := client get.	self expect: ByteString actual: (responseString class).	self assert: ('Not Found /nonesuch*' matches: responseString ). 
  
  self expect: ZnResponse actual: (client response class).  self expect: ZnUrl actual: (client url class).	self expect: ZnUserAgentSession actual: (client session class).	self expect: ZnUserAgentSettings actual: (client settings class).	self expect: ZnRequest actual: (client request class).	self expect: ZnLogSupport actual: (client log class).	self expect: BlockClosure actual: (client errorHandler class).	self expect: ZnMultiValueDictionary actual: (client params class).	self expect: ZnMultiValueDictionary actual: (client headers class).	self expect: 0 actual: (client headers size).		response := client response.	self expect: ZnResponse actual: (response class).	self expect: 404 actual: (response code).	self expect: 'Not Found' actual: (response statusLine reason).			



	! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/15/2015 14:09'!test115CharacterizeZnHttpHead	"Characterize ZnHttpClient"	| client settings response |	client := ZnHttpClient new.	self expect: ZnHttpClient actual: client class.	"At this point the client has nothing much going on." 	self assert: client response isNil.	self assert: client request isNil.	self expect: ZnUserAgentSettings actual: client settings class.	settings := client settings settings.	self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).	self expect: true actual: (settings at: #followRedirect ).	self expect: 7 actual: (settings at: #redirectLimit ).		self expect: 180 actual: (settings at: #timeout ).	self expect: 4 actual: (settings size).		client url: 'http://localhost:8080'.
  response := client head. "In this case, we get ZnResponse back instead of ByteString."	self expect: ZnResponse actual: (response class).	 
  self expect: ZnResponse actual: (client response class).  self expect: ZnUrl actual: (client url class).	self expect: ZnUserAgentSession actual: (client session class).	self expect: ZnUserAgentSettings actual: (client settings class).	self expect: ZnRequest actual: (client request class).	self expect: ZnLogSupport actual: (client log class).	self expect: BlockClosure actual: (client errorHandler class).	self expect: ZnMultiValueDictionary actual: (client params class).	self expect: ZnMultiValueDictionary actual: (client headers class).	self expect: 0 actual: (client headers size).		response := client response.	self expect: ZnResponse actual: (response class).	self expect: 200 actual: (response code).	self expect: 'OK' actual: (response statusLine reason).			



	! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:46'!test114CharacterizeZnHttpConnected	"Characterize ZnHttpClient"	| client settings response responseString |	client := ZnHttpClient new.	self expect: ZnHttpClient actual: client class.	"At this point the client has nothing much going on." 	self assert: client response isNil.	self assert: client request isNil.	self expect: ZnUserAgentSettings actual: client settings class.	settings := client settings settings.	self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).	self expect: true actual: (settings at: #followRedirect ).	self expect: 7 actual: (settings at: #redirectLimit ).		self expect: 180 actual: (settings at: #timeout ).	self expect: 4 actual: (settings size).		client url: 'http://localhost:8081'.
  responseString := client get.	self expect: ByteString actual: (responseString class).	"Happens to be there even though I try to shut it down."	self assert: ('*<title>Zinc HTTP Components</title>*' matches: responseString ). 
  
  self expect: ZnResponse actual: (client response class).  self expect: ZnUrl actual: (client url class).	self expect: ZnUserAgentSession actual: (client session class).	self expect: ZnUserAgentSettings actual: (client settings class).	self expect: ZnRequest actual: (client request class).	self expect: ZnLogSupport actual: (client log class).	self expect: BlockClosure actual: (client errorHandler class).	self expect: ZnMultiValueDictionary actual: (client params class).	self expect: ZnMultiValueDictionary actual: (client headers class).	self expect: 0 actual: (client headers size).		response := client response.	self expect: ZnResponse actual: (response class).	self expect: 200 actual: (response code).	self expect: 'OK' actual: (response statusLine reason).			



	! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 22:14'!test226CharacterizeZnHTTPSocketFacadePost	"Characterize ZnHttpClient"	| client responseStream dict server |		server := ZnMultiThreadedServer startOn: 80226.	server logToTranscript.	server delegate: (HApplication echo).	self ensureBlock: [server stop].	client := ZnHTTPSocketFacade new.	self expect: ZnHTTPSocketFacade actual: client class.		dict := ZnMultiValueDictionary new.	dict at: 'MYNAMEIS' add: 'tester'.	  responseStream := ZnHTTPSocketFacade httpPost: 'http://localhost:80226/test226' args: dict accept: 'application/octet-stream'.	server delegate: nil.	server stop.	self expect: (RWBinaryOrTextStream) actual: (responseStream class).	self expect: 'POST.../test226POST: MYNAMEIS=testerX-Zinc-Remote-Address: 127.0.0.1Content-Length: 15User-Agent: Zinc HTTP Components 1.0Connection: closeHost: localhost:80226Content-Type: application/x-www-form-urlencodedAccept: */*'			actual: responseStream contents.			! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 10:05'!test116CharacterizeZnHttpConnectExternal	"Characterize ZnHttpClient"	| client settings response responseString |		( NetNameResolver isConnected ) 		ifFalse: [ Transcript cr; show: 'test116CharacterizeZnHttpConnectExternal - no net';cr.			^self].	client := ZnHttpClient new.	self expect: ZnHttpClient actual: client class.	"At this point the client has nothing much going on." 	self assert: client response isNil.	self assert: client request isNil.	self expect: ZnUserAgentSettings actual: client settings class.	settings := client settings settings.	self expect: 'Zinc HTTP Components 1.0 (Mac OS; N; Mac OS intel 1092; en) 0' actual: (settings at: #agent).	self expect: true actual: (settings at: #followRedirect ).	self expect: 7 actual: (settings at: #redirectLimit ).		self expect: 180 actual: (settings at: #timeout ).	self expect: 4 actual: (settings size).		client url: 'http://www.w3.org/Help/search'.
  responseString := client get.	self expect: ByteString actual: (responseString class).	"Happens to be there even though I try to shut it down."	self assert: ('*<title>W3C web site search</title>*' matches: responseString ). 
  
  self expect: ZnResponse actual: (client response class).  self expect: ZnUrl actual: (client url class).	self expect: ZnUserAgentSession actual: (client session class).	self expect: ZnUserAgentSettings actual: (client settings class).	self expect: ZnRequest actual: (client request class).	self expect: ZnLogSupport actual: (client log class).	self expect: BlockClosure actual: (client errorHandler class).	self expect: ZnMultiValueDictionary actual: (client params class).	self expect: ZnMultiValueDictionary actual: (client headers class).	self expect: 0 actual: (client headers size).		response := client response.	self expect: ZnResponse actual: (response class).	self expect: 200 actual: (response code).	self expect: 'OK' actual: (response statusLine reason).			



	! !!HClientServerTests methodsFor: 'Client Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 09:41'!test120CharacterizeZnHTTPSocketFacade	"Characterize ZnHttpClient"	| client |	client := ZnHTTPSocketFacade new.	self expect: ZnHTTPSocketFacade actual: client class.	"ZnHTTPSocketFacade is stateless. 	 It does one-shot calls based on the arguments we pass."	! !!HClientServerTests methodsFor: 'Server Characterization Tests' stamp: 'RichardAlexanderGreen 4/10/2015 19:42'!test211CharacterizeZnServer	| server |	server := ZnMultiThreadedServer startOn: 8080.	self expect: ZnMultiThreadedServer actual: server class.	self expect: 8080 actual: server port.	self expect: false actual: server log enabled.	server logToTranscript.	self expect: true actual: server log enabled.	self expect: nil actual: server lastRequest.	self expect: nil actual: server lastResponse.	self expect: true actual: server isRunning.	self expect: false actual: server isListening.  "???"		server stop.	self expect: false actual: server isRunning.	! !!HClientServerTests methodsFor: 'Server Characterization Tests' stamp: 'RichardAlexanderGreen 4/10/2015 22:11'!test210CharacterizeZnServer	| server |	server := ZnSingleThreadedServer startOn: 8080.	self expect: ZnSingleThreadedServer actual: server class.	self expect: 8080 actual: server port.	self expect: false actual: server log enabled.		server logToTranscript.	self expect: true actual: server log enabled.	self expect: nil actual: server lastRequest.	self expect: nil actual: server lastResponse.	self expect: true actual: server isRunning.	self expect: false actual: server isListening.  "???"		server stop.	self expect: false actual: server isRunning.	! !!HClientServerTests methodsFor: 'Server Characterization Tests' stamp: 'RichardAlexanderGreen 4/13/2015 09:03'!test212CharacterizeZnServer	| server |	server := ZnMultiThreadedServer startOn: 8081.	self expect: ZnMultiThreadedServer actual: server class.	self expect: 8081 actual: server port.	self expect: false actual: server log enabled.	server logToTranscript.	self expect: true actual: server log enabled.	self expect: nil actual: server lastRequest.	self expect: nil actual: server lastResponse.	self expect: true actual: server isRunning.	self expect: false actual: server isListening.  "???"		server stop.	self expect: false actual: server isRunning.	! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 22:09'!test220CharacterizeZnServerGetResponse	| server request response |	server := ZnSingleThreadedServer startOn: 80220.		server logToTranscript.		"client := ZnHttpClient new."	request := ZnRequest get: 'http://localhost:80220/test220'.		response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 404 actual: ( response statusLine code ).	self expect: 'Not Found' actual: ( response statusLine reason ).		server delegate: (HApplication echo).	response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'GET.../test220Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80220'       actual: ( response contents ).

	server delegate: nil.  server stop.			! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 22:10'!test221CharacterizeZnServerPutResponse	| server request response |	server := ZnSingleThreadedServer startOn: 80221.		server logToTranscript.		"client := ZnHttpClient new."	request := ZnRequest put: 'http://localhost:80221/test221'.		response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 404 actual: ( response statusLine code ).	self expect: 'Not Found' actual: ( response statusLine reason ).		server delegate: (HApplication echo).	response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'PUT.../test221Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80221'       actual: ( response contents ).
	server delegate: nil.
  server stop.			! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:51'!test325CharacterizeZnServerGetResponse	"Use Case: (Multi-Threaded) Server with HApplication responds to client GET request."	| server response |	server := ZnMultiThreadedServer startOn: 80325.	self ensureBlock: [server stop].		server delegate: (HApplication echo).	response := ZnClient get: 'http://localhost:80325/test325'.
	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'GET /test325X-Zinc-Remote-Address: 127.0.0.1User-Agent: Zinc HTTP Components 1.0Connection: closeHost: localhost:80325Accept: */*'       actual: ( response contents ).  server delegate: nil.	self expect: ZnDefaultServerDelegate actual: (server delegate class).  server stop.					! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:51'!test326CharacterizeZnServerGetResponse	"Use Case: (Multi-Threaded) Server with HApplication responds to HClient GET request."	| server response |	server := ZnMultiThreadedServer startOn: 80326.	self ensureBlock: [server stop].		server delegate: (HApplication echo).	response := HClient get: 'http://localhost:80326/test326'. "HClient is a wrapper on ZnClient."
	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'GET /test326X-Zinc-Remote-Address: 127.0.0.1User-Agent: Zinc HTTP Components 1.0Connection: closeHost: localhost:80326Accept: */*'       actual: ( response contents ).  server delegate: nil.	self expect: ZnDefaultServerDelegate actual: (server delegate class).  server stop.					! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 21:49'!test324CharacterizeZnServerGetResponse	"Use Case: (Single Threaded) Server with HApplication responds to client GET request."	| server response |	server := ZnSingleThreadedServer startOn: 80324.	self ensureBlock: [server stop].		server delegate: (HApplication echo).	response := ZnClient get: 'http://localhost:80324/test324'.
	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'GET /test324X-Zinc-Remote-Address: 127.0.0.1User-Agent: Zinc HTTP Components 1.0Connection: closeHost: localhost:80324Accept: */*'       actual: ( response contents ).  server delegate: nil.	self expect: ZnDefaultServerDelegate actual: (server delegate class).  server stop.					! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 22:10'!test224CharacterizeZnServerHeadResponse	| server request response |	server := ZnSingleThreadedServer startOn: 80224.		server logToTranscript.	request := ZnRequest head: 'http://localhost:80224/test224'.		response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 404 actual: ( response statusLine code ).	self expect: 'Not Found' actual: ( response statusLine reason ).		server delegate: (HApplication echo).	response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'HEAD.../test224Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80224'   actual: ( response contents ).
	server delegate: nil.
  server stop.			! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 22:10'!test222CharacterizeZnServerPostResponse	| server request response |	server := ZnSingleThreadedServer startOn: 80222.	server logToTranscript.		"client := ZnHttpClient new."	request := ZnRequest post: 'http://localhost:80222/test222'.		response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 404 actual: ( response statusLine code ).	self expect: 'Not Found' actual: ( response statusLine reason ).		server delegate: (HApplication echo).	response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'POST.../test222POST:  No query arguments seen.Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80222'       actual: ( response contents ).
	server delegate: nil.
  server stop.			! !!HClientServerTests methodsFor: 'Response Characterization Tests' stamp: 'RichardAlexanderGreen 4/16/2015 22:10'!test223CharacterizeZnServerDeleteResponse	| server request response |	server := ZnSingleThreadedServer startOn: 80223.		server logToTranscript.		"client := ZnHttpClient new."	request := ZnRequest delete: 'http://localhost:80223/test223'.		response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 404 actual: ( response statusLine code ).	self expect: 'Not Found' actual: ( response statusLine reason ).		server delegate: (HApplication echo).	response := server handleRequest: request.	self expect: ZnResponse actual: ( response class ).	self expect: 200 actual: ( response statusLine code ).	self expect: 'OK' actual: ( response statusLine reason ).	self expect: 'DELETE.../test223Accept: */*User-Agent: Zinc HTTP Components 1.0Host: localhost:80223'        actual: ( response contents ).
	server delegate: nil.
  server stop.			! !!HClientServerTests methodsFor: 'Request Characterization Tests' stamp: 'RichardAlexanderGreen 4/10/2015 20:49'!test310CharacterizeZnRequest	""	| request headers uri |	request := ZnRequest get: 'http://localhost:8080/test'.	self expect: ZnRequest actual: ( request class ).	self expect: ZnRequestLine actual: ( request requestLine class).	self expect: #GET actual: ( request requestLine method ).		uri := request requestLine uri.	self expect: ZnUrl  actual: ( uri class).	self expect: 'http' actual: ( uri scheme).	self expect: 'localhost' actual: ( uri host).	self expect: 8080   actual: ( uri port).	self expect: nil    actual: ( uri query ).	self expect: #('test') actual: ( uri segments asArray ).			headers := request headers.	self expect: ZnHeaders actual: ( headers class ).	self expect: 'localhost:8080' actual: ( headers at: #host ).	self expect: '*/*' actual: ( headers at: #accept ).	self expect: 'Zinc HTTP Components 1.0' actual: ( headers at: 'User-Agent' ).  self expect: 3 actual: (headers headers size).! !!HClientServerTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/16/2015 21:36'!setUp	ZnSingleThreadedServer shutDown.	ZnMultiThreadedServer shutDown.	ZnServer shutDown.! !!HClientServerTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/16/2015 21:36'!tearDown	ZnSingleThreadedServer shutDown.	ZnMultiThreadedServer shutDown.	ZnServer shutDown.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HClientServerTests class	instanceVariableNames: ''!!HClientServerTests class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/29/2016 09:48'!isAbstract	^false.! !!HClientServerTests class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/29/2016 11:46'!hasErrorTest	self halt.	^false.! !!HClientServerTests class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/29/2016 11:46'!hasFailedTest	self halt.	^false.! !!HClientServerTests class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/29/2016 11:46'!hasPassedTest	self halt.	^false.! !Object subclass: #HEntity	instanceVariableNames: 'attributes history title id'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HEntity commentStamp: 'RichardAlexanderGreen 4/3/2015 10:08' prior: 0!Represent an entity instance in data.Instance Variables:	attributes	<Dictionary> - a dictionary of (attributeName -> attributeValue).	history	<OrderedCollection> - a sequence of state-change records.	title	<String>       - a locally unique noun naming this entity. (blackboard context)	id	    <LargeInteger> - a globally unique identifier for this entity. (world-base context)!!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 09:44'!attributes	"Return my dictionary of current attribute values."	^ attributes ifNil: [ attributes := Dictionary new ].! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 09:39'!attribute: anAttributeType value: aValue event: anEvent 	"Record a state-change associated with the given event."	self attributes at: anAttributeType put: aValue.	self history add: { anEvent. anAttributeType. aValue. }.! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 09:45'!history	"Return history of state-changes."	^ history ifNil: [ history := OrderedCollection new].! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 09:44'!getAttribute: anAttributeName 	"What is the value of the given attribute?"	| result |	result := self attributes at: anAttributeName.	^result.! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 09:43'!attribute: anAttributeName value: anAttributeValue 	"Initialize entity-attribute value. (No event, no history)	- Use '#attribute:value:event:' to record state-changes.	"	(self attributes) at: anAttributeName put: anAttributeValue.! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:38'!id	^ id! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 09:48'!id: aLargePositiveInteger 	"Set unique identifier.	- This value may be used to refer to this entity in relationships."	id := aLargePositiveInteger.! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:00'!printOn: aStream	"Format my data for easy reading. 	- Append lines to given stream (expecting aReadWriteStream).	- TODO: Consider using a JSON format instead.	"	| |	"Put my name/title on the stream"	aStream << (self title) <<  ': ' << String cr.	"Append indented list of my attribute values to stream."	(self attributes)		keysAndValuesDo: 			[ :attr :value |				aStream << '	' <<  attr << ': ' << value << String cr.				"TODO: Handle attributes that refer to other entities."			].		! !!HEntity methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:27'!title	"Entity should be given a contextually unique name (noun)"	^ title ifNil: [ Error signal: 'unknown entity'].! !!HEntity methodsFor: 'associating' stamp: 'RichardAlexanderGreen 4/3/2015 10:02'!title: aString 	"Set my title - something appropriate to usage and unique within the context.	Typically a noun (entity type or model component) within a blackboard.	"	title := aString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HEntity class	instanceVariableNames: ''!!HEntity class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/2/2015 11:31'!title: aString 	"Return an instance with that title/name"	| instance |	instance := self basicNew.	instance title: aString.	instance id: (HTime timeStamp).	^instance.! !HEntity subclass: #HEvent	instanceVariableNames: 'who what where why when'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HEvent commentStamp: 'RichardAlexanderGreen 2/4/2016 11:07' prior: 0!a business event (not to be confused with a data event)	Events serve as a kind of log. Events give data values a business (causality) context.'		instance		id: (HTime timeStamp); "Unique identifier."		who: aWho;				"who is associated with the cause - e.g. client-id/actor-id"		what: aWhat; 		"What is happening - e.g. Action statement"		where: aWhere;  	"Where: a host"		why: aWhy;				"Why: a job or seesion"		when: aTimeStamp. "Observer`s clock. May be simulator clock."'Although data events may be the framework`s way of remembering/recording a business event,the two concepts should not be confused.In the run-time framework,business-events are automatically recorded when:- a post-condition is satisfied in a running plan.- a client/user provides a value for a noun- - via "Ask view-name"- - by matching parameters in a vignette pattern.- an action procedure executes a 'giving' instruction. (Perhaps this should be limited in some way.)Examples:- Post-condition satisfied.- - who: client-id  what: post-condition  where: host-URI  why: job-id (top-goal, client, authorization)- Instruction giving persistent noun-value.- - who: actor-id   what: instruction     where: host-URI  why: job-id- Noun value entered.- - who: client-id  what: vignette	where: host-URI  why: session-id - - who: client-id  what: view		where: host-URI  why: session-id  !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:38'!when: aTimeStamp 	"When did the event occur? Real clock or simulated clock"	when := aTimeStamp! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:35'!id: aLargePositiveInteger 	id := aLargePositiveInteger.! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/7/2015 14:40'!attributes	| dict |	dict := (super attributes).	dict		at: 'who' put: who;		at: 'what' put: what;		at: 'when' put: when;		at: 'where' put: where;		at: 'why' put: why.! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:40'!who: aWho 	"Who caused the event? - User/Robot/Actor/Test"	who := aWho.! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:42'!why: aWhy 	"Why did the event occur? - Authorization/JobTicket"	why := aWhy.! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:39'!where: aWhere 	"Where did event occur? - Test/Simulation/Host/Application/Service"	where := aWhere! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/30/2015 10:40'!when	^ when! !!HEvent methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 11:38'!what: aWhat 	"What happened? (Relate to business process event.)"	what := aWhat.! !!HEvent methodsFor: 'comparing' stamp: 'RichardAlexanderGreen 3/30/2015 10:39'!> otherEvent 	| result |	result := (self when) > (otherEvent when).	^result.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HEvent class	instanceVariableNames: ''!!HEvent class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 4/21/2015 10:25'!who: aWho what: aWhat when: aTimeStamp where: aWhere why: aWhy  	| instance |	instance := self basicNew.	instance		who: aWho;				"Who is associated with the event? - client-id/actor-id"		what: aWhat; 			"What is happening? - statement / vignette / view"		when: aTimeStamp; 	"Observer`s clock. May be simulator clock."		where: aWhere;  		"Where? - a host-URI"		why: aWhy;				"Why?   - a job ticket or session identifier"		id: (HTime timeStamp). "Unique identifier for the event."	^instance.
"Examples:- Post-condition satisfied.- - who: client-id  what: post-condition  where: host-URI  why: job-id (top-goal, client, originating-session-id)- Instruction giving persistent noun-value.- - who: actor-id   what: instruction     where: host-URI  why: job-id- Noun value/s entered.- - who: client-id  what: vignette+pattern        where: host-URI  why: session-id - - who: client-id  what: vignette+view            where: host-URI  why: session-id See: Class documentation."! !HumTestCase subclass: #HBaseTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HBaseTests commentStamp: 'RichardAlexanderGreen 4/8/2015 12:09' prior: 0!The World Base represents "corporate memory".It records business events and entity attribute values.Use Cases: (There should be at least one test for each use case.)==========Business Events:. Plan Frame post-condition satisfied.. Dialog context changed.Entity Attribute values:. Dialog noun value set by input pattern.. Dialog noun values set by 'Ask view-name'.!!HBaseTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/3/2015 10:19'!test240WorldBaseBacksBlackBoard	"Blackboard calls on World Base to persist events, state-changes."	| event blackboard |		blackboard := HBlackboard new.	blackboard worldBase: HBase new.		event := HEvent who: 'TTester' what: 'named' when: (HTime now)	              where: 'test240WorldBaseBacksBlackBoard' 	                why: 'intialize blackboard nouns'. 		blackboard putEvent: event.		"Put first name, last name"	blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event.		blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event.		! !Object subclass: #HEntityTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HEntityTests commentStamp: 'RichardAlexanderGreen 2/29/2016 09:45' prior: 0!Deliberately removed from test sets.!!HEntityTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/30/2015 10:26'!test130UpdateAttributeValueInEvent	"An entity has one or more attributes"	| entity value event event2 |	event := HEvent who: 'TTester' what: 'named' when: (TimeStamp now)	              where: 'test130UpdateAttributeValueInEvent' 	                why: 'testing entity-initialize attributes'. 	entity := HEntity new.	"Put first name"	entity attribute: 'first-name' value: 'Tessie' event: event.	value := entity getAttribute: 'first-name'.	"Put last name"	self expect: 'Tessie' actual: value.		entity attribute: 'last-name' value: 'Tester' event: event.	value := entity getAttribute: 'last-name'.	self expect: 'Tester' actual: value.	"First name is still there"	value := entity getAttribute: 'first-name'.	self expect: 'Tessie' actual: value.	"============"	event2 := HEvent who: 'TTester' what: 'renamed' when: (TimeStamp now)	              where: 'test130UpdateAttributeValueInEvent-rename' 	                why: 'testing entity-rename updates attributes'. 	entity := HEntity new.	"Put first name"	entity attribute: 'first-name' value: 'Teddy' event: event2.	value := entity getAttribute: 'first-name'.	"Put last name"	self expect: 'Teddy' actual: value.		entity attribute: 'last-name' value: 'Tinker' event: event2.	value := entity getAttribute: 'last-name'.	self expect: 'Tinker' actual: value.	"First name is still there"	value := entity getAttribute: 'first-name'.	self expect: 'Teddy' actual: value.			! !!HEntityTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/30/2015 09:16'!test110EntityHasAttributes	"An entity has one or more attributes"	| entity value |	entity := HEntity new.	"Put first name"	entity attribute: 'first-name' value: 'Tessie'.	value := entity getAttribute: 'first-name'.	"Put last name"	self expect: 'Tessie' actual: value.		entity attribute: 'last-name' value: 'Tester'.	value := entity getAttribute: 'last-name'.	self expect: 'Tester' actual: value.	"First name is still there"	value := entity getAttribute: 'first-name'.	self expect: 'Tessie' actual: value.		! !!HEntityTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/2/2015 11:23'!test125EntityPrintOn	"An entity has one or more attributes"	| entity event stream |	event := HEvent who: 'TTester' what: 'named' when: (TimeStamp now)	              where: 'test120SetAttributeValueInEvent' 	                why: 'test120SetAttributeValueInEvent'. 	entity := HEntity title: 'tester'.	"Put first name"	entity attribute: 'first-name' value: 'Tessie' event: event.		entity attribute: 'last-name' value: 'Tester' event: event.		stream := ReadWriteStream on: ''.	entity printOn: stream.	self expect: 'tester: 	first-name: Tessie	last-name: Tester' 			actual: ( stream contents ).		! !!HEntityTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/30/2015 09:47'!test120SetAttributeValueInEvent	"An entity has one or more attributes"	| entity value event |	event := HEvent who: 'TTester' what: 'named' when: (TimeStamp now)	              where: 'test120SetAttributeValueInEvent' 	                why: 'test120SetAttributeValueInEvent'. 	entity := HEntity new.	"Put first name"	entity attribute: 'first-name' value: 'Tessie' event: event.	value := entity getAttribute: 'first-name'.	"Put last name"	self expect: 'Tessie' actual: value.		entity attribute: 'last-name' value: 'Tester' event: event.	value := entity getAttribute: 'last-name'.	self expect: 'Tester' actual: value.	"First name is still there"	value := entity getAttribute: 'first-name'.	self expect: 'Tessie' actual: value.		! !Object subclass: #HBlackboard	instanceVariableNames: 'events nouns clock worldBaseProxy'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HBlackboard commentStamp: 'RichardAlexanderGreen 4/21/2015 10:28' prior: 0!A Blackboard stores entity data in memory.It persists data via a world base (HBase).!!HBlackboard methodsFor: 'user interface' stamp: 'RichardAlexanderGreen 4/2/2015 09:44'!asStream	"Show the values in the blackboard on a stream."	| stream |	stream := ReadWriteStream on: ''.	nouns 		keysAndValuesDo: [ :k :v |
			(v isKindOf: HEntity)  ifTrue: [ v printOn: stream. ] 						].	^stream.		! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:13'!putEvent: anEvent 	self assert: (anEvent isKindOf: HEvent).	self events add: anEvent.	worldBaseProxy 		ifNotNil: [ worldBaseProxy putEvent: anEvent ].! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:41'!worldBase: aWorldBase 	"MOCK: Pretend we are persisting values on world base.	"	worldBaseProxy := aWorldBase.! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/3/2015 10:37'!putEntity: anEntity attribute: anAttribute value: aValue event: anEvent 	| entity |	entity := self getEntityNamed: anEntity.	entity attribute: anAttribute value: aValue event: anEvent.	self nouns at: {anEntity. anAttribute.} put: aValue.	worldBaseProxy 		ifNotNil: [ worldBaseProxy putEntity: entity attribute: anAttribute value: aValue event: anEvent ].! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/30/2015 10:06'!events	^ events ifNil: [ events := OrderedCollection new.]! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/30/2015 10:31'!getNoun: aNoun 	| value |	value := self nouns at: aNoun.	^value.! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/30/2015 10:12'!nouns	^ nouns ifNil: [ nouns := Dictionary new ].! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 4/2/2015 09:46'!putEntityNamed: aNoun 	| entity |	entity := HEntity title: aNoun.	self nouns at: aNoun put: entity.	^entity.! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/31/2015 21:18'!getEntityNamed: aNoun 	| entity |	entity := self nouns at: aNoun ifAbsent: [ self putEntityNamed: aNoun ].	self assert: (entity isKindOf: HEntity).	^ entity.! !!HBlackboard methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 3/30/2015 10:27'!getEntity: anEntity attribute: anAttribute 	| result entity |	entity := self getEntityNamed: anEntity.	result := entity getAttribute: anAttribute.	^result.! !HumTestCase subclass: #HBlackboardTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HBlackboardTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/31/2015 22:35'!test140BlackboardSaveFetch	"A blackboard records events, noun values"	| value event blackboard |	blackboard := HBlackboard new.	event := HEvent who: 'TTester' what: 'named' when: (HTime now)	              where: 'test140BlackboardSaveFetch' 	                why: 'intialize blackboard nouns'. 	blackboard putEvent: event.		"Put first name"	blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event.	value := blackboard getEntity: 'tester' attribute: 'first-name'.	"Put last name"	self expect: 'Tessie' actual: value.		blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event.	value := blackboard getEntity: 'tester' attribute: 'last-name'.	self expect: 'Tester' actual: value.	"First name is still there"	value := blackboard getEntity: 'tester' attribute: 'first-name'.	self expect: 'Tessie' actual: value.		! !!HBlackboardTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/31/2015 21:14'!test150BlackboardSaveFetchUpdate	"A blackboard records events, noun values"	| value event1 blackboard event2 |	blackboard := HBlackboard new.	event1 := HEvent who: 'TTester' what: 'named' when: (HTime now)	              where: 'test150BlackboardSaveFetchUpdate' 	                why: 'intialize blackboard nouns'. 	blackboard putEvent: event1.	blackboard putEntityNamed: 'tester'.	"Put first name"	blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event1.	value := blackboard getEntity: 'tester' attribute: 'first-name'.	"Put last name"	self expect: 'Tessie' actual: value.		blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event1.	value := blackboard getEntity: 'tester' attribute: 'last-name'.	self expect: 'Tester' actual: value.	"First name is still there"	value := blackboard getEntity: 'tester' attribute: 'first-name'.	self expect: 'Tessie' actual: value.	"==========="	event2 := HEvent who: 'TTester' what: 'named' when: (HTime now)	              where: 'test150BlackboardSaveFetchUpdate' 	                why: 'update blackboard nouns'.	self assert: ( event2 > event1 ). 	blackboard putEvent: event2.	blackboard putEntityNamed: 'tester'.	"Put first name"	blackboard putEntity: 'tester' attribute: 'first-name' value: 'Teddy' event: event2.	value := blackboard getEntity: 'tester' attribute: 'first-name'.	"Put last name"	self expect: 'Teddy' actual: value.		blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tinker' event: event2.	value := blackboard getEntity: 'tester' attribute: 'last-name'.	self expect: 'Tinker' actual: value.	"First name is still there"	value := blackboard getEntity: 'tester' attribute: 'first-name'.	self expect: 'Teddy' actual: value.		! !!HBlackboardTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 3/31/2015 22:44'!test145BlackboardSaveFetchNouns	"A blackboard records events, noun values"	| value event blackboard nounValue |	blackboard := HBlackboard new.	event := HEvent who: 'TTester' what: 'named' when: (HTime now)	              where: 'test140BlackboardSaveFetch' 	                why: 'intialize blackboard nouns'. 	blackboard putEvent: event.		"Put first name"	blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event.	value := blackboard getEntity: 'tester' attribute: 'first-name'.	"Put last name"	self expect: 'Tessie' actual: value.	nounValue := blackboard getNoun: {'tester'. 'first-name'.}.	self expect: value actual: nounValue.		blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event.	value := blackboard getEntity: 'tester' attribute: 'last-name'.	self expect: 'Tester' actual: value.	"First name is still there"	value := blackboard getEntity: 'tester' attribute: 'first-name'.	self expect: 'Tessie' actual: value.		! !!HBlackboardTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/2/2015 10:06'!test160BlackboardToStream	"A blackboard records events, noun values"	| event blackboard |	blackboard := HBlackboard new.	event := HEvent who: 'TTester' what: 'named' when: (HTime now)	              where: 'test140BlackboardSaveFetch' 	                why: 'intialize blackboard nouns'. 	blackboard putEvent: event.		"Put first name"	blackboard putEntity: 'tester' attribute: 'first-name' value: 'Tessie' event: event.		blackboard putEntity: 'tester' attribute: 'last-name' value: 'Tester' event: event.		self expect: 'tester: 	first-name: Tessie	last-name: Tester' 			actual: ( blackboard asStream contents ).		! !HumTestCase subclass: #HGlamourTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HGlamourTest commentStamp: 'RichardAlexanderGreen 7/19/2015 09:18' prior: 0!The purpose of this test suite is to characterize the Glamour package, and thus, understand how it is intended to be used."This group of tests follows 'Deep into Pharo - chapter 10' "!!HGlamourTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/23/2015 16:19'!test110Page193b	"Example at page 193"	| browser |	self skip: 'I am finished with this example'.	browser := GLMFinder new.	browser show: [ :a | 		a list 		    when: #isDirectory;			display: #children; 			format: #basenameWithIndicator ].	browser openOn: FileSystem disk root.! !!HGlamourTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/23/2015 16:19'!test110Page193a	"Example at page 193"	| browser |	self skip: 'I am finished with this example'.	browser := GLMFinder new.	browser show: [ :a | 		a list 		    when: #isDirectory;			display: #children; 			format: #basename ].	browser openOn: FileSystem disk root.! !!HGlamourTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/23/2015 16:14'!test100ReadMe	"This group of tests follows 'Deep into Pharo - chapter 10' "	self skip: 'Just a ReadMe'.! !!HGlamourTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/23/2015 16:18'!test110Page194	"Example at page 194"	| browser |	self skip: 'I am finished with this example'.	browser := GLMFinder new						variableSizePanes;						title: 'Navigate file structure';						yourself.	browser show: [ :a | 		a list 		    when: #isDirectory;			display: [:fileRef | [fileRef children] on: Exception do: [ Array new ] ];			format: #basenameWithIndicator.		a text			when: #isFile;			display: [:fileRef | 							[ fileRef readStream contents] 									on: Exception 									do: ['Cannot display content of file'].									].						].	browser openOn: FileSystem disk root.! !!HGlamourTest methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 4/23/2015 16:12'!test110Page192	"Example at page 192"	| browser |	self skip: 'I am finished with this example'.	browser := GLMFinder new.	browser show: [ :a | a list display: #children ].	browser openOn: FileSystem disk root.! !Object subclass: #H3dPath	instanceVariableNames: 'vertices borderColor fillColor'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!H3dPath commentStamp: 'RichardAlexanderGreen 3/7/2016 10:14' prior: 0!a list of 3D verticesBut it can also be interpreted as a polygon if the path is in a plane.Each vertex is a HumVector.!!H3dPath methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/7/2016 10:20'!addVertex: xyzCoordinates 	| vector calc |	calc := HumCalculator new.	calc cases;		when: [ xyzCoordinates isKindOf: HumVector ] then: [ vector := xyzCoordinates. ];		when: [ xyzCoordinates isKindOf: Array ] then: [ vector := HumVector newFrom: xyzCoordinates. ];		otherwise: [ Error signal: 'xyzCoordinates of unexpected type' ].	(self vertices) add: vector.	! !!H3dPath methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/7/2016 10:20'!vertices	^ vertices ifNil: [ vertices := OrderedCollection new. ].! !!H3dPath methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/7/2016 10:23'!borderColor: aColor 	"Color to use when rendering path (polygon edges)."	borderColor := aColor.! !!H3dPath methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/7/2016 10:23'!fillColor: aColor 	"Color to use when rendering path as a polygon"	fillColor := aColor.! !!H3dPath methodsFor: 'transforms' stamp: 'RichardAlexanderGreen 3/12/2016 09:27'!yaw: yawAngle aboutPivot: pivot	"Return a new path with my points adjusted by yaw about origin."	| newPath |	newPath := self class new.	self vertices do: [ :vertex |  newPath addVertex: ( vertex yaw: yawAngle aboutPivot: pivot ). ].	^newPath! !!H3dPath methodsFor: 'transforms' stamp: 'RichardAlexanderGreen 3/12/2016 09:28'!pitch: pitchAngle aboutPivot: aPivot	"Return a new path with my points adjusted by pitch about origin."	| newPath |	newPath := self class  new.	self vertices do: [ :vertex |  newPath addVertex: ( vertex pitch: pitchAngle aboutPivot: aPivot ). ].	^newPath! !!H3dPath methodsFor: 'transforms' stamp: 'RichardAlexanderGreen 3/12/2016 09:31'!yaw: yawAngle 	"Return a new path with my points adjusted by yaw about origin."	| newPath  |	newPath := self yaw: yawAngle aboutPivot: ( HumVector zeroVector: #meter ).	^newPath! !!H3dPath methodsFor: 'transforms' stamp: 'RichardAlexanderGreen 3/12/2016 09:29'!roll: rollAngle aboutPivot: aPivot	"Return a new path with my points adjusted by roll about origin."	| newPath |	newPath := self class new.	self vertices do: [ :vertex |  newPath addVertex: ( vertex roll: rollAngle aboutPivot: aPivot ). ].	^newPath! !!H3dPath methodsFor: 'transforms' stamp: 'RichardAlexanderGreen 3/12/2016 09:32'!roll: rollAngle 	"Return a new path with my points adjusted by roll about origin."	| newPath |	newPath := self roll: rollAngle aboutPivot: ( HumVector zeroVector: #meter ).	^newPath! !!H3dPath methodsFor: 'transforms' stamp: 'RichardAlexanderGreen 3/12/2016 09:33'!pitch: pitchAngle 	"Return a new path with my points adjusted by pitch about origin."	| newPath |	newPath := self pitch: pitchAngle aboutPivot: ( HumVector zeroVector: #meter ).	^newPath! !HEntity subclass: #HRelation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HRelation commentStamp: 'RichardAlexanderGreen 4/9/2015 09:27' prior: 0!A Relation is an "associative entity". It is identifiable and real-world.An "associative entity" differs from a "kernal entity"   in that two or more of its required-attributes are "role-type".The attribute-name of a role-type attribute names the relationship role.The attribute-value of a role-type attribute is an entity-identifier.. TODO: Give some thought about relationship (associative entity) instantiation.. Business-Relationships are typically caused by business actions.. . But: Where is the observer?. Most such business actions are transactions (buy-sell, bid, subscribe/register, assign).. . We record and track such transactional events because they represent contracts and opportunities.. Subtypes of Party and Person are often roles in such contracts.. . e.g. Customer, Worker, Supplier, Subscriber, User.. Subtypes of Order represent work-in-progress or fulfilled contracts.. . e.g. Sales-Order Purchase-Order Work-Order Requisition Option!Object subclass: #H3dObject	instanceVariableNames: 'type parameters center velocity width length height numberOfWedges axis curve yaw pitch roll yawRate pitchRate rollRate pivotPoint fillColor borderColor'	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!H3dObject commentStamp: 'RichardAlexanderGreen 2/29/2016 09:43' prior: 0!Experimental: Rewrite HumBox to simplify dynamics.!!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 11:08'!top: aMeasure	"Move so that top is at given z value."	| cx cy cz |	cx := center x. 	cy := center y.	cz := center z.	self center: (HumVector newFrom: { cx. cy. ( aMeasure - ( height / 2.0 ) ). }).! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 11:14'!south: aMeasure	"Move so that south edge is at given value."	| cx cy cz |	cx := center x. 	cy := center y.	cz := center z.	self center: ( HumVector newFrom: { cx. ( aMeasure + ( length / 2.0 ) ). cz. } ).! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 13:00'!south	"Value without yaw, pitch, roll - Use minY to see value with yaw, pitch, roll."	^  ( center y ) - ( length / 2.0 ).! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 12:58'!east	"Value without yaw, pitch, roll - Use maxX to see value with yaw, pitch, roll."	^  ( center x ) + ( width / 2.0 ).! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 13:00'!north	"Value without yaw, pitch, roll - Use maxY to see value with yaw, pitch, roll."	^  ( center y ) + ( length / 2.0 ).! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 13:00'!bottom	"Value without yaw, pitch, roll - Use minZ to see value with yaw, pitch, roll."	^  ( center z ) - ( height / 2.0 ).! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 12:59'!west	"Value without yaw, pitch, roll - Use minX to see value with yaw, pitch, roll."	^  ( center x ) - ( width / 2.0 ).! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/7/2016 12:23'!north: aMeasure	"Move so that north edge is at given value."	| cx cy cz |	cx := center x. 	cy := center y.	cz := center z.	self center: (HumVector newFrom: { cx. ( aMeasure - ( length / 2.0 ) ). cz. }).! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 11:11'!west: aMeasure	"Move so that west edge is at the given value."	| cx cy cz |	cx := center x. 	cy := center y.	cz := center z.	self center:  (HumVector newFrom: { ( aMeasure + ( width / 2.0 ) ). cy. cz. }).	! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/7/2016 12:15'!east: aMeasure	"Move so that east edge is at the given value."	| cx cy cz |	cx := center x. 	cy := center y.	cz := center z.	self center: (HumVector newFrom: { (aMeasure - ( width / 2.0 ) ). cy. cz. }).	! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 11:21'!bottom: aMeasure	"Move so that bottom is at given z value."	| cx cy cz |	cx := center x. 	cy := center y.	cz := center z.	self center: ( HumVector newFrom: { cx. cy. ( aMeasure + ( height / 2.0 ) ). } ).! !!H3dObject methodsFor: 'access - edges' stamp: 'RichardAlexanderGreen 3/11/2016 13:00'!top	"Value without yaw, pitch, roll - Use maxZ to see value with yaw, pitch, roll."	^  ( center z ) + ( height / 2.0 ).! !!H3dObject methodsFor: 'draw' stamp: 'RichardAlexanderGreen 3/2/2016 12:19'!buildBasePolygons	"Return my base polygons. Polygons before pitch, yaw, roll."	| calc polygons  |	calc := HumCalculator new.	calc cases;		when: [ type = #box ] then: [ polygons := self buildBox ];		when: [ type = #elipsoid ] then: [ polygons := self buildElipsoid ];		when: [ type = #rotation ] then: [ polygons := self buildRotation ];		otherwise: [ Error signal: 'Unknown type of 3D object: ', type ].	^polygons.! !!H3dObject methodsFor: 'draw' stamp: 'RichardAlexanderGreen 3/12/2016 20:40'!buildBox	"Create polygons for a box"	| polygons points dx dy dz cx cy cz top bottom east west north south |	polygons := OrderedCollection new.	dx := width / 2.0.	dy := length / 2.0.	dz := height / 2.0.	cx := center x.	cy := center y.	cz := center z.		points := Collection new.	top := H3dPath new.	top 		addVertex: { cx+dx. cy+dy. cz+dz. }; "Right-hand rule: Wind clockwise facing inward."		addVertex: { cx+dx. cy-dy. cz+dz. };		addVertex: { cx-dx. cy-dy. cz+dz. };		addVertex: { cx-dx. cy+dy. cz+dz. }.			bottom := H3dPath new.	bottom		addVertex: { cx+dx. cy+dy. cz-dz. };		addVertex: { cx-dx. cy+dy. cz-dz. };		addVertex: { cx-dx. cy-dy. cz-dz. };		addVertex: { cx+dx. cy-dy. cz-dz. }.	north := H3dPath new.	north		addVertex: { cx+dx. cy+dy. cz+dz. };		addVertex: { cx-dx. cy+dy. cz+dz. };		addVertex: { cx-dx. cy+dy. cz-dz. };		addVertex: { cx+dx. cy+dy. cz-dz. }.	south := H3dPath new.	south		addVertex: { cx+dx. cy-dy. cz+dz. };		addVertex: { cx+dx. cy-dy. cz-dz. };		addVertex: { cx-dx. cy-dy. cz-dz. };		addVertex: { cx-dx. cy-dy. cz+dz. }.	east := H3dPath new.	east		addVertex: { cx+dx. cy+dy. cz+dz. };		addVertex: { cx+dx. cy+dy. cz-dz. };		addVertex: { cx+dx. cy-dy. cz-dz. };		addVertex: { cx+dx. cy-dy. cz+dz. }.	west := H3dPath new.	west		addVertex: { cx-dx. cy+dy. cz+dz. };		addVertex: { cx-dx. cy-dy. cz+dz. };		addVertex: { cx-dx. cy-dy. cz-dz. };		addVertex: { cx-dx. cy+dy. cz-dz. }.	"assemble faces"				polygons addAll: { top. bottom. north. south. east. west. }.		"color"	polygons do: [ :polygon | polygon borderColor: (self borderColor); fillColor: (self fillColor) ].	^ polygons.! !!H3dObject methodsFor: 'draw' stamp: 'RichardAlexanderGreen 3/7/2016 09:57'!polygons	| polygons |	polygons := self buildAndOrient.	^polygons! !!H3dObject methodsFor: 'draw' stamp: 'RichardAlexanderGreen 3/12/2016 10:08'!buildAndOrient	"Build base polygons. Then, adjust orientation for yaw, pitch, roll. "	| basePolygons adjustedPolygons pivot |	basePolygons := self buildBasePolygons.	adjustedPolygons := OrderedCollection new.	pivot := self pivot.	self assert: ( pivot isKindOf: HumVector ).	basePolygons do: [ :p0 | "p0 is a polygon"		|  p1 p2 p3 |		"To assure consistent results, alway apply in order: yaw, pitch, roll. "		"Use Float <>"		(yaw quantity = 0.0 )  ifTrue:  [ p1 := p0 ]  ifFalse: [ p1 := p0 yaw: yaw aboutPivot: pivot ].		(pitch quantity = 0.0) ifTrue:  [ p2 := p1 ] ifFalse: [ p2 := p1 pitch: pitch aboutPivot: pivot ] .		(roll quantity = 0.0) ifTrue: [ p3 := p2 ]  ifFalse: [ p3 := p2 roll: roll aboutPivot: pivot ].		adjustedPolygons add: p3. 		].	^adjustedPolygons.	! !!H3dObject methodsFor: 'draw' stamp: 'RichardAlexanderGreen 3/7/2016 09:39'!buildElipsoid	"Create polygons forming the elipsoid."	| polygons pi minusPi twoPi nWedges  dAlpha dBeta makePoint xMax yMax zMax |	polygons := Collection new.	pi := Float pi.	minusPi := pi negated.	twoPi := 2.0 * pi.	nWedges := self numberOfWedges.	dAlpha := pi / nWedges.	dBeta := twoPi / nWedges.	xMax := width / 2.0.	yMax := length / 2.0.	zMax := height / 2.0.	makePoint := [ :alpha :beta |  	"BlockClosure to build a point given alpha and beta angles."			| x y z vertex |			x := xMax * (beta cos) * (alpha cos).			y := yMax * (beta sin) * (alpha cos).			z := zMax * (alpha sin). 			vertex := HumVector newFrom: { x. y. z. }. 		"return"			].	"Work from bottom to top"	( ((minusPi / 2.0) + dAlpha ) to: pi / 2.0 by: dAlpha) do: [ :alpha |  "verticle angle from x-y plane"		( minusPi  to: pi by: dBeta ) do: [ :beta | "circle around z axis" 			| polygon |			polygon := HumPolygon new.			polygon 				addVertex: ( makePoint value: alpha value: beta );				addVertex: ( makePoint value: alpha value: beta + dBeta );				addVertex: ( makePoint value: alpha - dAlpha value: beta + dBeta );				addVertex: ( makePoint value: alpha - dAlpha value: beta ).			polygons add: polygon.			].		].	"color"	polygons do: [ :polygon | polygon borderColor: (self color lighter); fillColor: (self color) ].	^polygons.	! !!H3dObject methodsFor: 'draw' stamp: 'RichardAlexanderGreen 3/7/2016 09:43'!buildRotation	"Given curve and an axis, build a rotation as a collection of polygons."	| polygons nWedges dAngle cx cy cz priorXY priorPoint twoPi calc adjustedPolygons |	polygons := OrderedCollection new.	nWedges := self numberOfWedges.	cx := center x.	cy := center y.	cz := center z.	priorXY := curve at: 1.	priorPoint := HumVector newFrom: { cx + (priorXY x). cy. cz + (priorXY y).  }.	twoPi := 2.0 * (Float pi).	dAngle := twoPi / nWedges.	( dAngle to: twoPi by: dAngle ) do: [ :angle |	 			( curve copyFrom: 2 to: curve size ) do: [ :xy |					| polygon thisPoint |  					thisPoint := HumVector newFrom: {  cx + (xy x). cy. cz + (xy y). }.					polygon := HumPolygon new.					polygon 						addVertex: ( thisPoint yaw: angle  );  "Right-hand rule: Wind clockwise looking inward."						addVertex: ( priorPoint yaw: angle  );						addVertex: ( priorPoint yaw: angle - dAngle );						addVertex: ( thisPoint yaw: angle - dAngle ).					polygons add: polygon.					priorPoint := thisPoint.				].			].	calc := HumCalculator new.	"Adjust for non-default axis of rotation."	adjustedPolygons := Collection new	calc cases;		when: [ axis = #z ] then: [ adjustedPolygons := polygons ];		when: [ axis = #x ] then: [ polygons do: [ :polygon | adjustedPolygons add: ( polygon pitch: (Float pi / 2.0)  )  ] ];		when: [ axis = #y ] then: [ polygons do: [ :polygon | adjustedPolygons add: ( polygon roll: (Float pi / 2.0)  )  ] ];		otherwise: [ "default is #z" adjustedPolygons := polygons ].	"color"	adjustedPolygons do: [ :polygon | polygon borderColor: (self color lighter); fillColor: (self color) ]. "Color"	 ^adjustedPolygons. ! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/4/2016 16:58'!assertRadians: anAngleInRadians		self assert: ( (anAngleInRadians isKindOf: HumMeasure) and: [anAngleInRadians dimensions = (1 radian) dimensions ] )			description: 'Angles should be HumMeasure with units of #radian'.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/4/2016 16:59'!roll: anAngleInRadians	"Amount of current roll. = rotation about y-axis"	self assertRadians: anAngleInRadians.	roll := anAngleInRadians.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/4/2016 17:11'!rollRate: randiansPerSecond	"roll rate (angular velocity) "	self assertRadiansPerSecond: randiansPerSecond.	rollRate := randiansPerSecond.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/12/2016 09:20'!pivot	| pivot |	pivot := (self center) + (self pivotPoint).	^pivot! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/4/2016 16:59'!pitch: anAngleInRadians	"Amount of current pitch = rotation about x-axis"	self assertRadians: anAngleInRadians.	pitch := anAngleInRadians.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/6/2016 16:27'!pitch	"Amount of current pitch = rotation about x-axis"	^ pitch ifNil: [ pitch := 0.0 radian ].! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/6/2016 16:27'!yaw	"Amount of current yaw. = rotation about z-axis"	^ yaw ifNil: [ yaw := 0.0 radian ].! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/6/2016 16:35'!initialize	"Set initial position, orientation, velocity, and rotation rates to zero."	| zeroOffset zeroSpeed zeroRotation zeroRateOfRotation |		zeroOffset := 0.0 meter.	zeroSpeed := 0.0 mps.	zeroRotation := 0.0 radian.	zeroRateOfRotation := 0.0 rps.		self center: ( HumVector newFrom: { zeroOffset. zeroOffset. zeroOffset. } ).	self velocity: ( HumVector newFrom: { zeroSpeed.  zeroSpeed.  zeroSpeed. } ).		self yaw: zeroRotation.	self pitch: zeroRotation.	self roll: zeroRotation.		self yawRate: zeroRateOfRotation.	self pitchRate: zeroRateOfRotation.	self rollRate: zeroRateOfRotation.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/2/2016 12:02'!velocity: aVector	"Set my velocity in container coordinates."	self assert: ( aVector isKindOf: HumVector ).	velocity := aVector.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/6/2016 16:41'!step: aTimeIncrement	"Step the position and orientation."	| newCenter newPitch newYaw newRoll |	"self assert: ((aTimeIncrement isKindOf: HumMeasure) and: [ aTimeIncrement dimensions = { #second->1. } ] )."	newCenter := center + ( velocity * aTimeIncrement ).	"Always do yaw, pitch, roll in that order."	newYaw := yaw + ( yawRate * aTimeIncrement ).	newPitch := pitch + ( pitchRate * aTimeIncrement ).	newRoll := roll + ( rollRate * aTimeIncrement ).	"Update:"	self 		center: newCenter;		yaw: newYaw;		pitch: newPitch;		roll: newRoll.	self changed.  "Inform subscribers."			! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/6/2016 16:27'!roll	"Amount of current roll. = rotation about y-axis"	^roll ifNil: [ roll := 0.0 radian ].! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/4/2016 17:10'!yawRate: randiansPerSecond	"yaw rate (angular velocity) = rotation about z-axis"	self assertRadiansPerSecond: randiansPerSecond.	yawRate := randiansPerSecond.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/11/2016 15:22'!center: aVector	"Set my center in container coordinates."	self assert: ( aVector isKindOf: HumVector ).	center := aVector copy.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/4/2016 17:11'!pitchRate: randiansPerSecond	"pitch rate (angular velocity) "	self assertRadiansPerSecond: randiansPerSecond.	pitchRate := randiansPerSecond.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/4/2016 16:59'!yaw: anAngleInRadians	"Amount of current yaw. = rotation about z-axis"	self assertRadians: anAngleInRadians.	yaw := anAngleInRadians.! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/12/2016 09:23'!pivotPoint	"Pivot-point is relative to object`s center. 	By default we pivot around the center."	^pivotPoint ifNil: [ pivotPoint := HumVector zeroVector: #meter ].! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/11/2016 10:36'!center	^ center ifNil: [ Error signal: 'center no default' ].! !!H3dObject methodsFor: 'access - position' stamp: 'RichardAlexanderGreen 3/4/2016 17:12'!assertRadiansPerSecond: radiansPerSecond		self assert: ( (radiansPerSecond isKindOf: HumMeasure) and: [radiansPerSecond dimensions = (1 rpm) dimensions ] ) "Number>>rpm"			description: 'Angular-velocity should be HumMeasure with units of radians per second'.! !!H3dObject methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/12/2016 20:39'!borderColor	^ borderColor ifNil: [ borderColor := (self fillColor) lighter. ].! !!H3dObject methodsFor: 'access' stamp: 'RichardAlexanderGreen 3/12/2016 20:38'!fillColor	^ fillColor ifNil: [ fillColor := Color gray. ].! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/3/2016 15:41'!height: aHeight	"What is my Up-Down height? (prior to pitch, yaw, roll).	Defines height of box or elipsoid."	height := aHeight.! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/3/2016 15:41'!length: aLength	"What is my North-South length? (prior to pitch, yaw, roll)	Define length of box or elipsoid."	length := aLength.! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/3/2016 15:40'!axis: anAxisSymbol	"Which axis is rotation around? 	Use with #curve: to set-up surface of rotation."	self assert: (anAxisSymbol isKindOf: Symbol ).	^ axis := anAxisSymbol.! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/3/2016 15:40'!curve: xyPoints	"Curve to use when building a rotation.	Use with #axis to define a surface of rotation."	self assert: (xyPoints isKindOf: OrderedCollection ).	self assert: ( (xyPoints at: 1) isKindOf: Point ).	curve := xyPoints.! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/2/2016 11:53'!type: aType	"What type of 3D object am I?"	type := aType.! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/3/2016 15:42'!numberOfWedges	"Number of wedges to produce when drawing rotation or elipsoid."	^ numberOfWedges ifNil: [ numberOfWedges := 12 ].! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/7/2016 09:53'!volume	"Return volume of box."	| volume |	self assert: (type = #box).	volume := width * length * height.	^volume.	! !!H3dObject methodsFor: 'access - dimensions' stamp: 'RichardAlexanderGreen 3/3/2016 15:42'!width: aWidth	"What is my East-West width? (prior to pitch, yaw, roll)	Define width of box or elipsoid."	width := aWidth.! !!H3dObject methodsFor: 'access - bounds' stamp: 'RichardAlexanderGreen 3/11/2016 11:12'!minX	| v |	v := center x.	(self polygons) do: [ :polygon | polygon vertices do: [ :vertex | v := v min: (vertex x) ]  ].	^ v.	! !!H3dObject methodsFor: 'access - bounds' stamp: 'RichardAlexanderGreen 3/7/2016 11:56'!maxY	| v |	v := center y.	(self polygons) do: [ :polygon | polygon vertices do: [ :vertex | v := v max: (vertex y) ]  ].	^ v.	! !!H3dObject methodsFor: 'access - bounds' stamp: 'RichardAlexanderGreen 3/11/2016 11:15'!minY	| v |	v := center y.	(self polygons) do: [ :polygon | polygon vertices do: [ :vertex | v := v min: (vertex y) ]  ].	^ v.	! !!H3dObject methodsFor: 'access - bounds' stamp: 'RichardAlexanderGreen 3/11/2016 11:22'!minZ	| v |	v := center z.	(self polygons) do: [ :polygon | polygon vertices do: [ :vertex | v := v min: (vertex z) ]  ].	^ v.	! !!H3dObject methodsFor: 'access - bounds' stamp: 'RichardAlexanderGreen 3/7/2016 11:56'!maxZ	| v |	v := center z.	(self polygons) do: [ :polygon | polygon vertices do: [ :vertex | v := v max: (vertex z) ]  ].	^ v.	! !!H3dObject methodsFor: 'access - bounds' stamp: 'RichardAlexanderGreen 3/7/2016 11:53'!maxX	| v |	v := center x.	(self polygons) do: [ :polygon | polygon vertices do: [ :vertex | v := v max: (vertex x) ]  ].	^ v.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!H3dObject class	instanceVariableNames: ''!!H3dObject class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 3/2/2016 12:24'!newRotationAround: anAxis curve: xyPoints	"Return instance of a rotation"	| instance |	self assert: ( #( #x #y #z ) includes: anAxis ).	self assert: (xyPoints isKindOf: SequenceableCollection ).	self assert: ( (xyPoints at: 1) isKindOf: Point ).		instance := self basicNew.	instance		type: #rotation;		axis: anAxis;		curve: xyPoints.	^instance.! !!H3dObject class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 3/2/2016 12:23'!newElipsoidWidth: aWidth length: aLength height: aHeight	"Return instance of an elipsoid"	| instance |	self assert: ( aWidth isKindOf: HumMeasure ).	self assert: ( aLength isKindOf: HumMeasure ).	self assert: ( aHeight isKindOf: HumMeasure ).	instance := self basicNew.	instance		type: #elipsoid;		width: aWidth;		length: aLength;		height: aHeight.	^instance.! !!H3dObject class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 3/7/2016 10:03'!newBoxWidth: aWidth length: aLength height: aHeight	"Return instance of a box"	| instance |	self assert: ( aWidth isKindOf: HumMeasure ).	self assert: ( aLength isKindOf: HumMeasure ).	self assert: ( aHeight isKindOf: HumMeasure ).		instance := self new.	instance		type: #box;		width: aWidth;		length: aLength;		height: aHeight.	^instance.! !HEntity subclass: #HEntityType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hum-X'!!HEntityType commentStamp: 'RichardAlexanderGreen 4/8/2015 13:10' prior: 0!An Entity-Type instance holds meta-data.	The type of an entity-type is named by a noun in the ontology.	The attributes of an entity-type are identified in the ontology.	The data-type of the attributes are identified in the ontology. (Default is string when there is no supertype).Currently, the ontology does not contain user-interface (scribe) *hints* such as - field-width          (Calculated at 90% statistic.)- required attributes  (We could add a base-ontology type called 'required-value'.)- immutable attributes (We could add a base-ontology type called 'immutable-value'.)- natural key          (We could add a base-ontology type called 'natural-key'.)       - ranges for measure, date, or timestamp values. (Should we add annotations to dictionary notation?)- Default ordering (natural key?) on sets and bags. - Help data - explaining how the entity and its attributes are to be interpreted (data entered)- - Comment: Help probably should be provided by separate views rather than meta-data. But this can be argued.Consider:- Should supertype attributes be displayed above subtype attributes?*** The functions identified above can be handled in ontology, and do not require a separate class. ***!